package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type ArkhamCore struct {
	Exchange
}

func NewArkhamCore() *ArkhamCore {
	p := &ArkhamCore{}
	setDefaults(p)
	return p
}

func (this *ArkhamCore) Describe() interface{} {
	return this.DeepExtend(this.Exchange.Describe(), map[string]interface{}{
		"id":        "arkham",
		"name":      "ARKHAM",
		"countries": []interface{}{"US"},
		"version":   "v1",
		"rateLimit": Divide(20, 3),
		"certified": false,
		"pro":       true,
		"has": map[string]interface{}{
			"CORS":                           false,
			"spot":                           true,
			"margin":                         false,
			"swap":                           true,
			"future":                         false,
			"option":                         false,
			"borrowCrossMargin":              false,
			"borrowIsolatedMargin":           false,
			"borrowMargin":                   false,
			"cancelAllOrders":                true,
			"cancelOrder":                    true,
			"createDepositAddress":           true,
			"createOrder":                    true,
			"fetchAccounts":                  true,
			"fetchAllGreeks":                 false,
			"fetchBalance":                   true,
			"fetchBorrowInterest":            false,
			"fetchBorrowRate":                false,
			"fetchBorrowRateHistories":       false,
			"fetchBorrowRateHistory":         false,
			"fetchBorrowRates":               false,
			"fetchBorrowRatesPerSymbol":      false,
			"fetchClosedOrders":              true,
			"fetchCrossBorrowRate":           false,
			"fetchCrossBorrowRates":          false,
			"fetchCurrencies":                true,
			"fetchDepositAddress":            false,
			"fetchDepositAddressesByNetwork": true,
			"fetchDeposits":                  true,
			"fetchFundingHistory":            true,
			"fetchGreeks":                    false,
			"fetchIsolatedBorrowRate":        false,
			"fetchIsolatedBorrowRates":       false,
			"fetchLeverage":                  true,
			"fetchLeverageTiers":             true,
			"fetchMyTrades":                  true,
			"fetchOHLCV":                     true,
			"fetchOpenOrders":                true,
			"fetchOption":                    false,
			"fetchOptionChain":               false,
			"fetchOrder":                     true,
			"fetchOrderBook":                 true,
			"fetchPositions":                 true,
			"fetchTicker":                    true,
			"fetchTickers":                   true,
			"fetchTime":                      true,
			"fetchTrades":                    true,
			"fetchTradingFees":               true,
			"fetchVolatilityHistory":         false,
			"fetchWithdrawals":               true,
			"repayCrossMargin":               false,
			"repayIsolatedMargin":            false,
			"sandbox":                        false,
			"setLeverage":                    true,
			"withdraw":                       true,
		},
		"timeframes": map[string]interface{}{
			"1m":  "1m",
			"5m":  "5m",
			"15m": "15m",
			"30m": "30m",
			"1h":  "1h",
			"6h":  "6h",
			"1d":  "24h",
		},
		"urls": map[string]interface{}{
			"logo": "https://github.com/user-attachments/assets/5cefdcfb-2c10-445b-835c-fa21317bf5ac",
			"api": map[string]interface{}{
				"v1": "https://arkm.com/api",
			},
			"www": "https://arkm.com/",
			"referral": map[string]interface{}{
				"url":      "https://arkm.com/register?ref=ccxt",
				"discount": 0,
			},
			"doc":  []interface{}{"https://arkm.com/limits-api", "https://info.arkm.com/api-platform"},
			"fees": "https://arkm.com/fees",
		},
		"api": map[string]interface{}{
			"v1": map[string]interface{}{
				"public": map[string]interface{}{
					"get": map[string]interface{}{
						"alerts":           1,
						"announcements":    1,
						"assets":           1,
						"book":             1,
						"candles":          1,
						"chains":           1,
						"contracts":        1,
						"index-price":      1,
						"index-prices":     1,
						"margin-schedules": 1,
						"marketcapchart":   1,
						"marketcaps":       1,
						"pair":             1,
						"pairs":            1,
						"server-time":      1,
						"ticker":           1,
						"tickers":          1,
						"trades":           1,
					},
				},
				"private": map[string]interface{}{
					"get": map[string]interface{}{
						"user":                                     7.5,
						"orders":                                   7.5,
						"orders/by-client-order-id":                7.5,
						"orders/history":                           7.5,
						"orders/history/by-client-order-id":        7.5,
						"orders/history_offset":                    7.5,
						"orders/{id}":                              7.5,
						"trades":                                   7.5,
						"trades/history":                           7.5,
						"trades/time":                              7.5,
						"trigger-orders":                           7.5,
						"account/airdrops":                         7.5,
						"account/balance-updates":                  7.5,
						"account/balances":                         7.5,
						"account/balances/ll":                      7.5,
						"account/balances/history":                 7.5,
						"account/balances/commissions":             7.5,
						"account/deposit/addresses":                7.5,
						"account/deposits":                         7.5,
						"account/fees":                             7.5,
						"account/funding-rate-payments":            7.5,
						"account/leverage":                         7.5,
						"account/lsp-assignments":                  7.5,
						"account/margin":                           7.5,
						"account/margin/all":                       7.5,
						"account/notifications":                    7.5,
						"account/position-updates":                 7.5,
						"account/positions":                        7.5,
						"account/realized-pnl":                     7.5,
						"account/rebates":                          7.5,
						"account/referral-links":                   7.5,
						"account/sessions":                         7.5,
						"account/settings":                         7.5,
						"account/settings/price-alert":             7.5,
						"account/transfers":                        7.5,
						"account/unsubscribe":                      7.5,
						"account/watchlist":                        7.5,
						"account/withdrawal/addresses":             7.5,
						"account/withdrawal/addresses/{id}":        7.5,
						"account/withdrawals":                      7.5,
						"subaccounts":                              7.5,
						"airdrop":                                  7.5,
						"airdrop/claim":                            7.5,
						"affiliate-dashboard/commission-earned":    7.5,
						"affiliate-dashboard/min-arkm-last-30d":    7.5,
						"affiliate-dashboard/points":               7.5,
						"affiliate-dashboard/points-season-1":      7.5,
						"affiliate-dashboard/points-season-2":      7.5,
						"affiliate-dashboard/realized-pnl":         7.5,
						"affiliate-dashboard/rebate-balance":       7.5,
						"affiliate-dashboard/referral-count":       7.5,
						"affiliate-dashboard/referrals-season-1":   7.5,
						"affiliate-dashboard/referrals-season-2":   7.5,
						"affiliate-dashboard/trading-volume-stats": 7.5,
						"affiliate-dashboard/volume-season-1":      7.5,
						"affiliate-dashboard/volume-season-2":      7.5,
						"affiliate-dashboard/api-key":              7.5,
						"competitions/opt-in-status":               7.5,
						"rewards/info":                             7.5,
						"rewards/vouchers":                         7.5,
					},
					"post": map[string]interface{}{
						"orders/new":                           7.5,
						"trigger-orders/new":                   7.5,
						"orders/cancel":                        7.5,
						"trigger-orders/cancel":                7.5,
						"orders/cancel/all":                    7.5,
						"trigger-orders/cancel/all":            7.5,
						"orders/new/simple":                    7.5,
						"account/deposit/addresses/new":        7.5,
						"account/leverage":                     7.5,
						"account/notifications/read":           7.5,
						"account/referral-links":               7.5,
						"account/sessions/delete":              7.5,
						"account/sessions/terminate-all":       7.5,
						"account/settings/update":              7.5,
						"account/watchlist/add":                7.5,
						"account/watchlist/remove":             7.5,
						"account/withdraw":                     7.5,
						"account/withdrawal/addresses/confirm": 7.5,
						"subaccounts":                          7.5,
						"subaccounts/transfer":                 7.5,
						"subaccounts/perp-transfer":            7.5,
						"subaccounts/update-settings":          7.5,
						"airdrop":                              7.5,
						"api-key/create":                       7.5,
						"authenticate":                         7.5,
						"competitions/opt-in":                  7.5,
						"rewards/vouchers/claim":               7.5,
					},
					"put": map[string]interface{}{
						"account/referral-links/{id}/slug":  7.5,
						"account/settings/price-alert":      7.5,
						"account/withdrawal/addresses/{id}": 7.5,
						"subaccounts":                       7.5,
						"api-key/update/{id}":               7.5,
					},
					"delete": map[string]interface{}{
						"account/settings/price-alert":      7.5,
						"account/withdrawal/addresses/{id}": 7.5,
						"subaccounts/{subaccountId}":        7.5,
						"api-key/{id}":                      7.5,
					},
				},
			},
		},
		"options": map[string]interface{}{
			"networks": map[string]interface{}{
				"ETH":    "ETH",
				"ERC20":  "ETH",
				"BTC":    "BTC",
				"SOL":    "SOL",
				"TON":    "TON",
				"DOGE":   "DOGE",
				"SUI":    "SUI",
				"XRP":    "XRP",
				"OP":     "OP",
				"AVAXC":  "AVAX",
				"ARBONE": "ARB",
			},
			"networksById": map[string]interface{}{
				"ETH":   "ERC20",
				"ERC20": "ERC20",
			},
			"requestExpiration": 5000,
			"timeframeDurations": map[string]interface{}{
				"1m":  60000000,
				"5m":  300000000,
				"15m": 900000000,
				"30m": 1800000000,
				"1h":  3600000000,
				"6h":  21600000000,
				"1d":  86400000000,
			},
		},
		"features": map[string]interface{}{
			"default": map[string]interface{}{
				"sandbox": false,
				"createOrder": map[string]interface{}{
					"marginMode":   false,
					"triggerPrice": true,
					"triggerPriceType": map[string]interface{}{
						"mark":  true,
						"index": true,
						"last":  true,
					},
					"triggerDirection":           true,
					"stopLossPrice":              true,
					"takeProfitPrice":            true,
					"attachedStopLossTakeProfit": nil,
					"timeInForce": map[string]interface{}{
						"IOC": true,
						"FOK": true,
						"PO":  true,
						"GTD": false,
					},
					"hedged":                 false,
					"selfTradePrevention":    false,
					"trailing":               false,
					"iceberg":                false,
					"leverage":               false,
					"marketBuyByCost":        false,
					"marketBuyRequiresPrice": false,
				},
				"createOrders": nil,
				"fetchMyTrades": map[string]interface{}{
					"marginMode":     false,
					"limit":          100,
					"daysBack":       nil,
					"untilDays":      1,
					"symbolRequired": false,
				},
				"fetchOrder": map[string]interface{}{
					"marginMode":     false,
					"trigger":        false,
					"trailing":       false,
					"symbolRequired": false,
				},
				"fetchOpenOrders": map[string]interface{}{
					"marginMode":     true,
					"limit":          nil,
					"trigger":        false,
					"trailing":       false,
					"symbolRequired": false,
				},
				"fetchOrders": nil,
				"fetchClosedOrders": map[string]interface{}{
					"marginMode":       false,
					"limit":            100,
					"daysBack":         nil,
					"daysBackCanceled": nil,
					"untilDays":        nil,
					"trigger":          false,
					"trailing":         false,
					"symbolRequired":   false,
				},
				"fetchOHLCV": map[string]interface{}{
					"limit": 365,
				},
			},
			"spot": map[string]interface{}{
				"extends": "default",
			},
			"swap": map[string]interface{}{
				"linear": map[string]interface{}{
					"extends": "default",
				},
				"inverse": nil,
			},
			"future": map[string]interface{}{
				"linear": map[string]interface{}{
					"extends": "default",
				},
				"inverse": nil,
			},
		},
		"precisionMode": TICK_SIZE,
		"exceptions": map[string]interface{}{
			"exact": map[string]interface{}{
				"10000": OperationFailed,
				"10001": BadRequest,
				"10002": AuthenticationError,
				"10003": BadSymbol,
				"10004": ArgumentsRequired,
				"10005": RateLimitExceeded,
				"10006": PermissionDenied,
				"10007": PermissionDenied,
				"10008": RateLimitExceeded,
				"10009": PermissionDenied,
				"10010": PermissionDenied,
				"10011": AuthenticationError,
				"10012": PermissionDenied,
				"10013": PermissionDenied,
				"10014": AuthenticationError,
				"10015": PermissionDenied,
				"10016": PermissionDenied,
				"10017": PermissionDenied,
				"10018": AuthenticationError,
				"10019": AuthenticationError,
				"10020": PermissionDenied,
				"10021": PermissionDenied,
				"10022": ExchangeError,
				"10023": BadRequest,
				"10024": ExchangeError,
				"10025": BadRequest,
				"20001": BadRequest,
				"20002": ArgumentsRequired,
				"20003": BadRequest,
				"20004": ArgumentsRequired,
				"20005": BadRequest,
				"30001": InvalidOrder,
				"30002": InvalidOrder,
				"30003": InvalidOrder,
				"30004": InvalidOrder,
				"30005": InvalidOrder,
				"30006": InvalidOrder,
				"30007": BadSymbol,
				"30008": OperationRejected,
				"30009": OperationRejected,
				"30010": InsufficientFunds,
				"30011": BadSymbol,
				"30012": OperationRejected,
				"30013": OperationRejected,
				"30014": InvalidOrder,
				"30015": OrderNotFound,
				"30016": InvalidOrder,
				"30017": InvalidOrder,
				"30018": InvalidOrder,
				"30019": OperationRejected,
				"30020": InvalidOrder,
				"30021": InvalidOrder,
				"30022": InvalidOrder,
				"30023": InvalidOrder,
				"30024": InvalidOrder,
				"30025": BadRequest,
				"30026": PermissionDenied,
				"30027": PermissionDenied,
				"30028": OrderNotFound,
				"40001": OperationRejected,
				"40002": BadRequest,
				"40003": InvalidAddress,
				"40004": OperationRejected,
				"40005": BadRequest,
				"40006": PermissionDenied,
				"40007": OperationRejected,
				"40008": OperationRejected,
				"40009": OperationRejected,
				"40010": BadRequest,
				"40011": OperationRejected,
				"40012": BadRequest,
				"40013": BadRequest,
				"90001": BadRequest,
				"90002": BadRequest,
				"90003": OperationRejected,
				"90004": BadRequest,
				"90005": BadRequest,
				"90006": RateLimitExceeded,
				"90007": AuthenticationError,
				"90008": RateLimitExceeded,
				"90009": PermissionDenied,
				"90010": BadRequest,
				"90011": RateLimitExceeded,
			},
			"broad": map[string]interface{}{
				"less than min withdrawal ": OperationRejected,
			},
		},
	})
}

/**
 * @method
 * @name arkham#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see https://arkm.com/docs#get/public/assets
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func (this *ArkhamCore) FetchCurrencies(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		response := (<-this.V1PublicGetAssets(params))
		PanicOnError(response)
		//
		//    [
		//        {
		//            "symbol": "USDT",
		//            "name": "Tether",
		//            "imageUrl": "https://static.arkhamintelligence.com/tokens/tether.png",
		//            "stablecoin": true,
		//            "featuredPair": "BTC_USDT",
		//            "chains": [
		//                {
		//                    "symbol": "ETH",
		//                    "assetSymbol": "ETH",
		//                    "name": "Ethereum",
		//                    "type": "1",
		//                    "confirmations": "6",
		//                    "blockTime": "12000000"
		//                }
		//            ],
		//            "status": "listed",
		//            "minDeposit": "5",
		//            "minWithdrawal": "5",
		//            "withdrawalFee": "2"
		//        },
		//        ...
		//
		var result interface{} = map[string]interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
			var currency interface{} = GetValue(response, i)
			var id interface{} = this.SafeString(currency, "symbol")
			var code interface{} = this.SafeCurrencyCode(id)
			var networks interface{} = map[string]interface{}{}
			var chains interface{} = this.SafeList(currency, "chains", []interface{}{})
			for j := 0; IsLessThan(j, GetArrayLength(chains)); j++ {
				var chain interface{} = GetValue(chains, j)
				var networkId interface{} = this.SafeString(chain, "symbol")
				var network interface{} = this.NetworkIdToCode(networkId)
				AddElementToObject(networks, network, map[string]interface{}{
					"info":      chain,
					"id":        networkId,
					"network":   network,
					"title":     this.SafeString(chain, "name"),
					"active":    nil,
					"deposit":   nil,
					"withdraw":  nil,
					"fee":       nil,
					"precision": nil,
					"limits": map[string]interface{}{
						"withdraw": map[string]interface{}{
							"min": nil,
							"max": nil,
						},
					},
				})
			}
			AddElementToObject(result, code, this.SafeCurrencyStructure(map[string]interface{}{
				"info":      currency,
				"id":        id,
				"code":      code,
				"name":      this.SafeString(currency, "name"),
				"active":    IsEqual(this.SafeString(currency, "status"), "listed"),
				"deposit":   nil,
				"withdraw":  nil,
				"fee":       this.SafeNumber(currency, "withdrawalFee"),
				"precision": nil,
				"limits": map[string]interface{}{
					"amount": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
					"withdraw": map[string]interface{}{
						"min": this.SafeNumber(currency, "minWithdrawal"),
						"max": nil,
					},
					"deposit": map[string]interface{}{
						"min": this.SafeNumber(currency, "minDeposit"),
						"max": nil,
					},
				},
				"type":     "crypto",
				"networks": networks,
			}))
		}

		ch <- result
		return nil

	}()
	return ch
}

/**
 * @method
 * @name arkham#fetchMarkets
 * @see https://arkm.com/docs#get/public/pairs
 * @description retrieves data on all markets for arkm
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func (this *ArkhamCore) FetchMarkets(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		response := (<-this.V1PublicGetPairs(params))
		PanicOnError(response)
		//
		//    [
		//        {
		//            "symbol": "BTC_USDT",
		//            "baseSymbol": "BTC",
		//            "baseImageUrl": "https://static.arkhamintelligence.com/tokens/bitcoin.png",
		//            "baseIsStablecoin": false,
		//            "baseName": "Bitcoin",
		//            "quoteSymbol": "USDT",
		//            "quoteImageUrl": "https://static.arkhamintelligence.com/tokens/tether.png",
		//            "quoteIsStablecoin": true,
		//            "quoteName": "Tether",
		//            "minTickPrice": "0.01",
		//            "minLotSize": "0.00001",
		//            "minSize": "0.00001",
		//            "maxSize": "9000",
		//            "minPrice": "0.01",
		//            "maxPrice": "1000000",
		//            "minNotional": "5",
		//            "maxPriceScalarUp": "1.8",
		//            "maxPriceScalarDown": "0.2",
		//            "pairType": "spot", // atm, always 'spot' value
		//            "maxLeverage": "0",
		//            "status": "listed"
		//        },
		//        {
		//            "symbol": "BTC_USDT_PERP",
		//            "baseSymbol": "BTC.P",
		//            "baseImageUrl": "https://static.arkhamintelligence.com/tokens/bitcoin.png",
		//            "baseIsStablecoin": false,
		//            "baseName": "Bitcoin Perpetual",
		//            "quoteSymbol": "USDT",
		//            "quoteImageUrl": "https://static.arkhamintelligence.com/tokens/tether.png",
		//            "quoteIsStablecoin": true,
		//            "quoteName": "Tether",
		//            "minTickPrice": "0.01",
		//            "minLotSize": "0.00001",
		//            "minSize": "0.00001",
		//            "maxSize": "9000",
		//            "minPrice": "0.01",
		//            "maxPrice": "1000000",
		//            "minNotional": "5",
		//            "maxPriceScalarUp": "1.5",
		//            "maxPriceScalarDown": "0.5",
		//            "pairType": "perpetual",
		//            "marginSchedule": "C",
		//            "maxLeverage": "25",
		//            "status": "listed"
		//        },
		//        ...
		//
		var result interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
			var market interface{} = GetValue(response, i)
			var id interface{} = this.SafeString(market, "symbol")
			var baseId interface{} = this.SafeString(market, "baseSymbol")
			var quoteId interface{} = this.SafeString(market, "quoteSymbol")
			var base interface{} = this.SafeCurrencyCode(baseId)
			var quote interface{} = this.SafeCurrencyCode(quoteId)
			var marketType interface{} = nil
			var symbol interface{} = nil
			var pairType interface{} = this.SafeString(market, "pairType")
			var isSpot interface{} = IsEqual(pairType, "spot")
			var isPerpetual interface{} = IsEqual(pairType, "perpetual")
			var settle interface{} = nil
			var settleId interface{} = nil
			if IsTrue(isSpot) {
				marketType = "spot"
				symbol = Add(Add(base, "/"), quote)
			} else if IsTrue(isPerpetual) {
				marketType = "swap"
				base = Replace(base, ".P", "")
				settle = quote
				settleId = quoteId
				symbol = Add(Add(Add(Add(base, "/"), quote), ":"), settle)
			}
			AppendToArray(&result, map[string]interface{}{
				"id":             id,
				"symbol":         symbol,
				"base":           base,
				"quote":          quote,
				"settle":         settle,
				"baseId":         baseId,
				"quoteId":        quoteId,
				"settleId":       settleId,
				"type":           marketType,
				"spot":           isSpot,
				"margin":         nil,
				"swap":           isPerpetual,
				"future":         false,
				"option":         false,
				"active":         IsEqual(this.SafeString(market, "status"), "listed"),
				"contract":       isPerpetual,
				"linear":         Ternary(IsTrue(isPerpetual), true, nil),
				"inverse":        Ternary(IsTrue(isPerpetual), false, nil),
				"contractSize":   Ternary(IsTrue(isSpot), nil, 1),
				"expiry":         nil,
				"expiryDatetime": nil,
				"strike":         nil,
				"optionType":     nil,
				"precision": map[string]interface{}{
					"price":  this.SafeNumber(market, "minTickPrice"),
					"amount": this.SafeNumber(market, "minLotSize"),
				},
				"limits": map[string]interface{}{
					"leverage": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
					"amount": map[string]interface{}{
						"min": this.SafeNumber(market, "minSize"),
						"max": this.SafeNumber(market, "maxSize"),
					},
					"price": map[string]interface{}{
						"min": this.SafeNumber(market, "minPrice"),
						"max": this.SafeNumber(market, "maxPrice"),
					},
					"cost": map[string]interface{}{
						"min": this.SafeNumber(market, "minNotional"),
						"max": nil,
					},
				},
				"created": nil,
				"info":    market,
			})
		}

		ch <- result
		return nil

	}()
	return ch
}

/**
 * @method
 * @name arkham#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @see https://arkm.com/docs#get/public/server-time
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func (this *ArkhamCore) FetchTime(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		response := (<-this.V1PublicGetServerTime(params))
		PanicOnError(response)

		//
		//    {
		//        "serverTime": "1753465832770820"
		//    }
		//
		ch <- this.SafeIntegerProduct(response, "serverTime", 0.001)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name arkham#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://arkm.com/docs#get/public/book
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the number of order book entries to return, max 50
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func (this *ArkhamCore) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		limit := GetArg(optionalArgs, 0, nil)
		_ = limit
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes7138 := (<-this.LoadMarkets())
		PanicOnError(retRes7138)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}

		response := (<-this.V1PublicGetBook(this.Extend(request, params)))
		PanicOnError(response)
		//
		//    {
		//        "symbol": "BTC_USDT",
		//        "group": "0.01",
		//        "asks": [
		//            {
		//                "price": "122900.43",
		//                "size": "0.0243"
		//            },
		//            {
		//                "price": "121885.53",
		//                "size": "0.00116"
		//            },
		//            ...
		//        ],
		//        "bids": [
		//            {
		//                "price": "20400",
		//                "size": "0.00316"
		//            },
		//            {
		//                "price": "30000",
		//                "size": "0.00116"
		//            },
		//            ...
		//        ],
		//        "lastTime": "1753419275604353"
		//    }
		//
		var timestamp interface{} = this.SafeIntegerProduct(response, "lastTime", 0.001)
		var marketId interface{} = this.SafeString(response, "symbol")

		ch <- this.ParseOrderBook(response, this.SafeSymbol(marketId, market), timestamp, "bids", "asks", "price", "size")
		return nil

	}()
	return ch
}

/**
 * @method
 * @name arkham#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://arkm.com/docs#get/public/candles
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms for the ending date filter, default is the current time
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func (this *ArkhamCore) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		timeframe := GetArg(optionalArgs, 0, "1m")
		_ = timeframe
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		var maxLimit interface{} = 365

		retRes7728 := (<-this.LoadMarkets())
		PanicOnError(retRes7728)
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchOHLCV", "paginate", false)
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {

			retRes77619 := (<-this.FetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, params, maxLimit))
			PanicOnError(retRes77619)
			ch <- retRes77619
			return nil
		}
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol":   GetValue(market, "id"),
			"duration": this.SafeString(this.Timeframes, timeframe, timeframe),
		}
		var durationMs interface{} = Multiply(this.ParseTimeframe(timeframe), 1000)
		var until interface{} = this.SafeInteger(params, "until")
		params = this.Omit(params, []interface{}{"until"})
		var selectedLimit interface{} = Ternary(IsTrue((!IsEqual(limit, nil))), mathMin(limit, maxLimit), maxLimit)
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "start", since)
			AddElementToObject(request, "end", this.Sum(since, Multiply(selectedLimit, durationMs)))
		} else {
			var now interface{} = this.Milliseconds()
			AddElementToObject(request, "end", Ternary(IsTrue((!IsEqual(until, nil))), until, now))
			AddElementToObject(request, "start", Subtract(GetValue(request, "end"), Multiply(selectedLimit, durationMs)))
		}
		// exchange needs microseconds
		AddElementToObject(request, "start", Multiply(GetValue(request, "start"), 1000))
		AddElementToObject(request, "end", Multiply(GetValue(request, "end"), 1000))

		response := (<-this.V1PublicGetCandles(this.Extend(request, params)))
		PanicOnError(response)

		//
		//    [
		//        {
		//            "symbol": "BTC_USDT_PERP",
		//            "time": "1753464720000000",
		//            "duration": "60000000",
		//            "open": "116051.35",
		//            "high": "116060.27",
		//            "low": "116051.35",
		//            "close": "116060.27",
		//            "volume": "0.0257",
		//            "quoteVolume": "2982.6724054"
		//        },
		//        ...
		//    ]
		//
		ch <- this.ParseOHLCVs(response, market, timeframe, since, limit)
		return nil

	}()
	return ch
}
func (this *ArkhamCore) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{} {
	//
	//        {
	//            "symbol": "BTC_USDT_PERP",
	//            "time": "1753464720000000",
	//            "duration": "60000000",
	//            "open": "116051.35",
	//            "high": "116060.27",
	//            "low": "116051.35",
	//            "close": "116060.27",
	//            "volume": "0.0257",
	//            "quoteVolume": "2982.6724054"
	//        }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	return []interface{}{this.SafeIntegerProduct(ohlcv, "time", 0.001), this.SafeNumber(ohlcv, "open"), this.SafeNumber(ohlcv, "high"), this.SafeNumber(ohlcv, "low"), this.SafeNumber(ohlcv, "close"), this.SafeNumber(ohlcv, "volume")}
}
func (this *ArkhamCore) FetchTickers(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		response := (<-this.V1PublicGetTickers(params))
		PanicOnError(response)

		//
		//    [
		//        {
		//            "symbol": "BTC_USDT_PERP",
		//            "baseSymbol": "BTC.P",
		//            "quoteSymbol": "USDT",
		//            "indexCurrency": "USDT",
		//            "price": "118806.89",
		//            "price24hAgo": "118212.29",
		//            "high24h": "119468.05",
		//            "low24h": "117104.44",
		//            "volume24h": "180.99438",
		//            "quoteVolume24h": "21430157.5928827",
		//            "markPrice": "118814.71",
		//            "indexPrice": "118804.222610343",
		//            "fundingRate": "0.000007",
		//            "nextFundingRate": "0.000006",
		//            "nextFundingTime": "1753390800000000",
		//            "productType": "perpetual",
		//            "openInterest": "2.55847",
		//            "usdVolume24h": "21430157.5928827",
		//            "openInterestUSD": "303963.8638583"
		//        },
		//        ...
		//
		ch <- this.ParseTickers(response, symbols)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name arkham#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func (this *ArkhamCore) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes8818 := (<-this.LoadMarkets())
		PanicOnError(retRes8818)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}

		response := (<-this.V1PublicGetTicker(this.Extend(request, params)))
		PanicOnError(response)

		//
		//        {
		//            "symbol": "BTC_USDT_PERP",
		//            "baseSymbol": "BTC.P",
		//            "quoteSymbol": "USDT",
		//            "indexCurrency": "USDT",
		//            "price": "118806.89",
		//            "price24hAgo": "118212.29",
		//            "high24h": "119468.05",
		//            "low24h": "117104.44",
		//            "volume24h": "180.99438",
		//            "quoteVolume24h": "21430157.5928827",
		//            "markPrice": "118814.71",
		//            "indexPrice": "118804.222610343",
		//            "fundingRate": "0.000007",
		//            "nextFundingRate": "0.000006",
		//            "nextFundingTime": "1753390800000000",
		//            "productType": "perpetual",
		//            "openInterest": "2.55847",
		//            "usdVolume24h": "21430157.5928827",
		//            "openInterestUSD": "303963.8638583"
		//        }
		//
		ch <- this.ParseTicker(response, market)
		return nil

	}()
	return ch
}
func (this *ArkhamCore) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{} {
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(ticker, "symbol")
	market = this.SafeMarket(marketId, market)
	return this.SafeTicker(map[string]interface{}{
		"info":          ticker,
		"symbol":        this.SafeSymbol(marketId, market),
		"high":          this.SafeNumber(ticker, "high24h"),
		"low":           this.SafeNumber(ticker, "low24h"),
		"bid":           this.SafeNumber(ticker, "bid"),
		"last":          this.SafeNumber(ticker, "price"),
		"open":          this.SafeNumber(ticker, "price24hAgo"),
		"change":        this.SafeNumber(ticker, "priceChange"),
		"percentage":    this.SafeNumber(ticker, "priceChangePercent"),
		"baseVolume":    this.SafeNumber(ticker, "volume24h"),
		"quoteVolume":   this.SafeNumber(ticker, "usdVolume24h"),
		"markPrice":     this.SafeNumber(ticker, "markPrice"),
		"indexPrice":    this.SafeNumber(ticker, "indexPrice"),
		"vwap":          nil,
		"average":       nil,
		"previousClose": nil,
		"askVolume":     nil,
		"bidVolume":     nil,
	})
}

/**
 * @method
 * @name arkham#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://arkm.com/docs#get/public/trades
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.loc] crypto location, default: us
 * @param {string} [params.method] method, default: marketPublicGetV1beta3CryptoLocTrades
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func (this *ArkhamCore) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		since := GetArg(optionalArgs, 0, nil)
		_ = since
		limit := GetArg(optionalArgs, 1, nil)
		_ = limit
		params := GetArg(optionalArgs, 2, map[string]interface{}{})
		_ = params

		retRes9528 := (<-this.LoadMarkets())
		PanicOnError(retRes9528)
		var market interface{} = this.Market(symbol)
		var marketId interface{} = GetValue(market, "id")
		var request interface{} = map[string]interface{}{
			"symbol": marketId,
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}

		response := (<-this.V1PublicGetTrades(this.Extend(request, params)))
		PanicOnError(response)

		//
		//    [
		//        {
		//            "symbol": "BTC_USDT_PERP",
		//            "revisionId": "1130514101",
		//            "size": "0.01668",
		//            "price": "116309.57",
		//            "takerSide": "sell",
		//            "time": "1753439710374047"
		//        },
		//        ...
		//    ]
		//
		ch <- this.ParseTrades(response, market, since, limit)
		return nil

	}()
	return ch
}
func (this *ArkhamCore) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{} {
	//
	// fetchTrades
	//
	//        {
	//            "symbol": "BTC_USDT_PERP",
	//            "revisionId": "1130514101",
	//            "size": "0.01668",
	//            "price": "116309.57",
	//            "takerSide": "sell",
	//            "time": "1753439710374047"
	//        }
	//
	// fetchMyTrades
	//
	//        {
	//            "symbol": "SOL_USDT",
	//            "revisionId": "891839406",
	//            "size": "0.042",
	//            "price": "185.06",
	//            "takerSide": "sell",
	//            "time": "1753773952039342",
	//            "orderId": "3717304929194",
	//            "userSide": "sell",
	//            "quoteFee": "0.00777252",
	//            "arkmFee": "0",
	//            "clientOrderId": ""
	//        }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(trade, "symbol")
	market = this.SafeMarket(marketId, market)
	var timestamp interface{} = this.SafeIntegerProduct(trade, "time", 0.001)
	var quoteFee interface{} = this.SafeNumber(trade, "quoteFee")
	var arkmFee interface{} = this.SafeNumber(trade, "arkmFee")
	var fee interface{} = nil
	if IsTrue(!IsEqual(quoteFee, nil)) {
		fee = map[string]interface{}{
			"cost":     quoteFee,
			"currency": GetValue(market, "quote"),
		}
	} else if IsTrue(!IsEqual(arkmFee, nil)) {
		fee = map[string]interface{}{
			"cost":     arkmFee,
			"currency": "ARKM",
		}
	}
	return this.SafeTrade(map[string]interface{}{
		"info":         trade,
		"id":           this.SafeString(trade, "revisionId"),
		"timestamp":    timestamp,
		"datetime":     this.Iso8601(timestamp),
		"symbol":       GetValue(market, "symbol"),
		"type":         nil,
		"side":         this.SafeString2(trade, "userSide", "takerSide"),
		"takerOrMaker": nil,
		"price":        this.SafeString(trade, "price"),
		"amount":       this.SafeString(trade, "size"),
		"cost":         nil,
		"fee":          fee,
		"order":        this.SafeString(trade, "orderId"),
	}, market)
}

/**
 * @method
 * @name arkmm#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://arkm.com/docs#get/orders/by-client-order-id
 * @param {string} id the order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.clientOrderId] a unique id for the order
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *ArkhamCore) FetchOrder(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		var request interface{} = map[string]interface{}{
			"id": ParseInt(id),
		}

		response := (<-this.V1PrivateGetOrdersId(this.Extend(request, params)))
		PanicOnError(response)

		//
		//    {
		//        "orderId": "3690478767430",
		//        "userId": "2959123",
		//        "subaccountId": "0",
		//        "symbol": "SOL_USDT",
		//        "time": "1753696843913970",
		//        "side": "sell",
		//        "type": "limitGtc",
		//        "size": "0.066",
		//        "price": "293.2",
		//        "postOnly": false,
		//        "reduceOnly": false,
		//        "executedSize": "0",
		//        "status": "booked",
		//        "avgPrice": "0",
		//        "executedNotional": "0",
		//        "creditFeePaid": "0",
		//        "marginBonusFeePaid": "0",
		//        "quoteFeePaid": "0",
		//        "arkmFeePaid": "0",
		//        "revisionId": "887956326",
		//        "lastTime": "1753696843914830",
		//        "clientOrderId": "",
		//        "lastSize": "0",
		//        "lastPrice": "0",
		//        "lastCreditFee": "0",
		//        "lastMarginBonusFee": "0",
		//        "lastQuoteFee": "0",
		//        "lastArkmFee": "0"
		//    }
		//
		ch <- this.ParseOrder(response)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name arkham#fetchClosedOrders
 * @description fetches information on multiple closed orders made by the user
 * @see https://arkm.com/docs#get/orders/history
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch orders for
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *ArkhamCore) FetchClosedOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes11058 := (<-this.LoadMarkets())
		PanicOnError(retRes11058)
		var request interface{} = map[string]interface{}{}
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			AddElementToObject(request, "symbol", GetValue(market, "id"))
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit) // note, API does not work for this param
		}

		response := (<-this.V1PrivateGetOrdersHistory(this.Extend(request, params)))
		PanicOnError(response)

		//
		//     [
		//        {
		//            "orderId": "3690478767430",
		//            "userId": "2959123",
		//            "subaccountId": "0",
		//            "symbol": "SOL_USDT",
		//            "time": "1753696843913970",
		//            "side": "sell",
		//            "type": "limitGtc",
		//            "size": "0.066",
		//            "price": "293.2",
		//            "postOnly": false,
		//            "reduceOnly": false,
		//            "executedSize": "0",
		//            "status": "closed",
		//            "avgPrice": "0",
		//            "executedNotional": "0",
		//            "creditFeePaid": "0",
		//            "marginBonusFeePaid": "0",
		//            "quoteFeePaid": "0",
		//            "arkmFeePaid": "0",
		//            "revisionId": "888084076",
		//            "lastTime": "1753701350088305",
		//            "clientOrderId": "",
		//            "lastSize": "0",
		//            "lastPrice": "0",
		//            "lastCreditFee": "0",
		//            "lastMarginBonusFee": "0",
		//            "lastQuoteFee": "0",
		//            "lastArkmFee": "0"
		//        }
		//    ]
		//
		ch <- this.ParseOrders(response, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name arkham#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://arkm.com/docs#get/orders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch orders for
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *ArkhamCore) FetchOpenOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes11668 := (<-this.LoadMarkets())
		PanicOnError(retRes11668)
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
		}
		var isTriggerOrder interface{} = this.SafeBool(params, "trigger")
		params = this.Omit(params, "trigger")
		var response interface{} = nil
		if IsTrue(isTriggerOrder) {

			response = (<-this.V1PrivateGetTriggerOrders(this.Extend(map[string]interface{}{}, params)))
			PanicOnError(response)
		} else {

			response = (<-this.V1PrivateGetOrders(this.Extend(map[string]interface{}{}, params)))
			PanicOnError(response)
		}

		ch <- this.ParseOrders(response, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name arkham#cancelOrder
 * @description cancels an open order
 * @see https://arkm.com/docs#post/orders/cancel
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *ArkhamCore) CancelOrder(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		var isTriggerOrder interface{} = this.SafeBool(params, "trigger")
		params = this.Omit(params, "trigger")
		var response interface{} = nil
		var request interface{} = map[string]interface{}{}
		var clientOrderId interface{} = this.SafeInteger(params, "clientOrderId")
		if IsTrue(!IsEqual(clientOrderId, nil)) {
			params = this.Omit(params, "clientOrderId")
			AddElementToObject(request, "clientOrderId", clientOrderId)
		} else {
			if IsTrue(isTriggerOrder) {
				AddElementToObject(request, "triggerOrderId", ParseInt(id))
			} else {
				AddElementToObject(request, "orderId", ParseInt(id))
			}
		}
		if IsTrue(isTriggerOrder) {
			if IsTrue(IsEqual(symbol, nil)) {
				panic(ArgumentsRequired(Add(this.Id, " cancelOrder() requires a symbol argument for trigger orders")))
			}
			var market interface{} = this.Market(symbol)
			AddElementToObject(request, "symbol", GetValue(market, "id"))

			response = (<-this.V1PrivatePostTriggerOrdersCancel(this.Extend(request, params)))
			PanicOnError(response)
		} else {

			response = (<-this.V1PrivatePostOrdersCancel(this.Extend(request, params)))
			PanicOnError(response)
		}

		//
		// {"orderId":3691703758327}
		//
		ch <- this.ParseOrder(response)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name arkham#cancelAllOrders
 * @description cancel all open orders in a market
 * @see https://arkm.com/docs#post/orders/cancel/all
 * @param {string} symbol cancel alls open orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *ArkhamCore) CancelAllOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		if IsTrue(!IsEqual(symbol, nil)) {
			panic(BadRequest(Add(this.Id, " cancelAllOrders() does not support a symbol argument, use cancelOrder() or fetchOpenOrders() instead")))
		}
		var isTriggerOrder interface{} = this.SafeBool(params, "trigger")
		params = this.Omit(params, "trigger")
		var response interface{} = nil
		if IsTrue(isTriggerOrder) {

			response = (<-this.V1PrivatePostTriggerOrdersCancelAll(params))
			PanicOnError(response)
		} else {

			response = (<-this.V1PrivatePostOrdersCancelAll(params))
			PanicOnError(response)
		}

		//
		// []  returns an empty array, even when successfully cancels orders
		//
		ch <- this.ParseOrders(response, nil)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name arkham#createOrder
 * @description create a trade order on the exchange
 * @see https://arkm.com/docs#post/orders/new
 * @param {string} symbol unified CCXT market symbol
 * @param {string} type "limit" or "market"
 * @param {string} side "buy" or "sell"
 * @param {float} amount the amount of currency to trade
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.timeInForce] "GTC", "IOC", "FOK", or "PO"
 * @param {float} [params.triggerPrice] price for a trigger (conditional) order
 * @param {float} [params.stopLossPrice] price for a stoploss order
 * @param {float} [params.takeProfitPrice] price for a takeprofit order
 * @param {string} [params.triggerDirection] the direction for trigger orders, 'ascending' or 'descending'
 * @param {string} [params.triggerPriceType] mark, index or last
 * @param {bool} [params.postOnly] true or false whether the order is post-only
 * @param {bool} [params.reduceOnly] true or false whether the order is reduce-only
 * @returns [An order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *ArkhamCore) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		price := GetArg(optionalArgs, 0, nil)
		_ = price
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes13288 := (<-this.LoadMarkets())
		PanicOnError(retRes13288)
		var market interface{} = this.Market(symbol)
		var isTriggerOrder interface{} = !IsEqual(this.SafeNumberN(params, []interface{}{"triggerPrice", "stopLossPrice", "takeProfitPrice"}), nil)
		var request interface{} = this.CreateOrderRequest(symbol, typeVar, side, amount, price, params)
		var response interface{} = nil
		if IsTrue(isTriggerOrder) {

			response = (<-this.V1PrivatePostTriggerOrdersNew(request))
			PanicOnError(response)
		} else {

			response = (<-this.V1PrivatePostOrdersNew(request))
			PanicOnError(response)
		}

		ch <- this.ParseOrder(response, market)
		return nil

	}()
	return ch
}
func (this *ArkhamCore) CreateOrderRequest(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{} {
	price := GetArg(optionalArgs, 0, nil)
	_ = price
	params := GetArg(optionalArgs, 1, map[string]interface{}{})
	_ = params
	var market interface{} = this.Market(symbol)
	symbol = GetValue(market, "symbol")
	var request interface{} = map[string]interface{}{
		"symbol": GetValue(market, "id"),
		"side":   side,
		"size":   this.AmountToPrecision(symbol, amount),
	}
	var isBuy interface{} = (IsEqual(side, "buy"))
	var stopLossPrice interface{} = this.SafeNumber(params, "stopLossPrice")
	var takeProfitPrice interface{} = this.SafeNumber(params, "takeProfitPrice")
	var triggerPriceAny interface{} = this.SafeStringN(params, []interface{}{"triggerPrice", "stopLossPrice", "takeProfitPrice"})
	if IsTrue(!IsEqual(triggerPriceAny, nil)) {
		AddElementToObject(request, "triggerPrice", this.PriceToPrecision(symbol, triggerPriceAny))
		if IsTrue(!IsEqual(stopLossPrice, nil)) {
			AddElementToObject(request, "triggerType", Ternary(IsTrue(isBuy), "stopLoss", "takeProfit"))
		} else if IsTrue(!IsEqual(takeProfitPrice, nil)) {
			AddElementToObject(request, "triggerType", Ternary(IsTrue(isBuy), "takeProfit", "stopLoss"))
		} else {
			var triggerDirection interface{} = this.SafeString(params, "triggerDirection")
			if IsTrue(IsEqual(triggerDirection, nil)) {
				panic(ArgumentsRequired(Add(this.Id, " createOrder() requires a triggerDirection parameter when triggerPrice is specified, must be \"ascending\" or \"descending\"")))
			}
			if IsTrue(!IsEqual(triggerDirection, nil)) {
				if IsTrue(IsEqual(triggerDirection, "ascending")) {
					AddElementToObject(request, "triggerType", Ternary(IsTrue(isBuy), "stopLoss", "takeProfit"))
				} else if IsTrue(IsEqual(triggerDirection, "descending")) {
					AddElementToObject(request, "triggerType", Ternary(IsTrue(isBuy), "takeProfit", "stopLoss"))
				}
			}
		}
		// mandatory triggerPriceType
		if IsTrue(IsEqual(this.SafeString(params, "triggerPriceType"), nil)) {
			AddElementToObject(request, "triggerPriceType", "last") // default
		}
	}
	var isMarketOrder interface{} = (IsEqual(typeVar, "market"))
	var isLimitOrder interface{} = (IsEqual(typeVar, "limit"))
	var isLimitExchangeSpecific interface{} = this.InArray(typeVar, []interface{}{"limitGtc", "limitIoc", "limitFok"})
	var postOnly interface{} = this.IsPostOnly(isMarketOrder, false, params)
	var timeInForce interface{} = this.SafeString(params, "timeInForce")
	params = this.Omit(params, []interface{}{"postOnly", "timeInForce", "triggerPrice", "stopLossPrice", "takeProfitPrice", "triggerDirection"})
	if IsTrue(postOnly) {
		AddElementToObject(request, "postOnly", true)
	}
	if IsTrue(IsTrue(isLimitOrder) || IsTrue(isLimitExchangeSpecific)) {
		AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
		//
		if IsTrue(IsEqual(timeInForce, "IOC")) {
			AddElementToObject(request, "type", "limitIoc")
		} else if IsTrue(IsEqual(timeInForce, "FOK")) {
			AddElementToObject(request, "type", "limitFok")
		} else {
			AddElementToObject(request, "type", "limitGtc")
		}
	} else if IsTrue(isMarketOrder) {
		AddElementToObject(request, "type", "market")
	}
	// we don't need to manually handle `reduceOnly`, `clientOrderId`, `triggerPriceType` here as exchange-specific keyname & values matches
	return this.Extend(request, params)
}
func (this *ArkhamCore) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{} {
	//
	// createOrder
	//
	//    {
	//        "orderId": "3694872060678",
	//        "clientOrderId": "test123",
	//        "symbol": "SOL_USDT",
	//        "subaccountId": "0",
	//        "side": "buy",
	//        "type": "limitGtc",
	//        "size": "0.05",
	//        "price": "170",
	//        "time": "1753710501474043"
	//    }
	//
	// fetchOrder, fetchOpenOrders, fetchClosedOrders
	//
	//    {
	//        "orderId": "3690478767430",
	//        "userId": "2959123",
	//        "subaccountId": "0",
	//        "symbol": "SOL_USDT",
	//        "time": "1753696843913970",
	//        "side": "sell",
	//        "type": "limitGtc",
	//        "size": "0.066",
	//        "price": "293.2",
	//        "postOnly": false,
	//        "reduceOnly": false,
	//        "executedSize": "0",
	//        "status": "booked",
	//        "avgPrice": "0",
	//        "executedNotional": "0",
	//        "creditFeePaid": "0",
	//        "marginBonusFeePaid": "0",
	//        "quoteFeePaid": "0",
	//        "arkmFeePaid": "0",
	//        "revisionId": "887956326",
	//        "lastTime": "1753696843914830",
	//        "clientOrderId": "",
	//        "lastSize": "0",
	//        "lastPrice": "0",
	//        "lastCreditFee": "0",
	//        "lastMarginBonusFee": "0",
	//        "lastQuoteFee": "0",
	//        "lastArkmFee": "0"
	//    }
	//
	// trigger-orders: createOrder
	//
	//    {
	//        "triggerOrderId": "3716436645573",
	//        "symbol": "SOL_USDT_PERP",
	//        "side": "buy",
	//        "type": "limitGtc",
	//        "size": "0.05",
	//        "price": "150"
	//    }
	//
	// trigger-orders: fetchOpenOrders
	//
	//    {
	//            "subaccountId": "0",
	//            "symbol": "SOL_USDT",
	//            "side": "sell",
	//            "type": "market",
	//            "size": "0.045",
	//            "price": "99.9",
	//            "postOnly": false,
	//            "reduceOnly": false,
	//            "time": "1753768103780063",
	//            "triggerOrderId": "3715847222127",
	//            "triggerType": "stopLoss",
	//            "triggerPriceType": "last",
	//            "triggerPrice": "111",
	//            "clientOrderId": "",
	//            "status": "staged"
	//    }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(order, "symbol")
	market = this.SafeMarket(marketId, market)
	var isPostOnly interface{} = this.SafeBool(order, "postOnly")
	var typeRaw interface{} = this.SafeString(order, "type")
	var orderType interface{} = Ternary(IsTrue(isPostOnly), "limit", this.ParseOrderType(typeRaw))
	var timeInForce interface{} = Ternary(IsTrue(isPostOnly), "PO", this.ParseTimeInForce(typeRaw))
	var quoteFeePaid interface{} = this.SafeString(order, "quoteFeePaid")
	var arkmFeePaid interface{} = this.SafeString(order, "arkmFeePaid")
	var fees interface{} = []interface{}{}
	if IsTrue(!IsEqual(quoteFeePaid, nil)) {
		AppendToArray(&fees, map[string]interface{}{
			"cost":     quoteFeePaid,
			"currency": this.SafeString(market, "quote"),
		})
	}
	if IsTrue(!IsEqual(arkmFeePaid, nil)) {
		AppendToArray(&fees, map[string]interface{}{
			"cost":     arkmFeePaid,
			"currency": "ARKM",
		})
	}
	var timestamp interface{} = this.SafeIntegerProduct(order, "time", 0.001)
	return this.SafeOrder(map[string]interface{}{
		"id":                  this.SafeString2(order, "orderId", "triggerOrderId"),
		"clientOrderId":       this.SafeString(order, "clientOrderId"),
		"timestamp":           timestamp,
		"datetime":            this.Iso8601(timestamp),
		"lastTradeTimeStamp":  nil,
		"lastUpdateTimestamp": this.SafeIntegerProduct(order, "lastTime", 0.001),
		"status":              this.ParseOrderStatus(this.SafeString(order, "status")),
		"symbol":              GetValue(market, "symbol"),
		"type":                orderType,
		"timeInForce":         timeInForce,
		"postOnly":            nil,
		"side":                this.SafeString(order, "side"),
		"price":               this.SafeNumber(order, "price"),
		"triggerPrice":        nil,
		"cost":                this.SafeNumber(order, "executedNotional"),
		"average":             this.SafeNumberOmitZero(order, "avgPrice"),
		"amount":              this.SafeNumber(order, "size"),
		"filled":              this.SafeNumber(order, ""),
		"remaining":           nil,
		"trades":              nil,
		"fees":                fees,
		"reduceOnly":          this.SafeBool(order, "reduceOnly"),
		"info":                order,
	}, market)
}
func (this *ArkhamCore) ParseOrderType(typeVar interface{}) interface{} {
	var types interface{} = map[string]interface{}{
		"limitGtc": "limit",
		"limitIoc": "limit",
		"limitFok": "limit",
		"market":   "market",
	}
	return this.SafeStringUpper(types, typeVar, typeVar)
}
func (this *ArkhamCore) ParseTimeInForce(typeVar interface{}) interface{} {
	var types interface{} = map[string]interface{}{
		"limitGtc": "GTC",
		"limitIoc": "IOC",
		"limitFok": "FOK",
		"market":   "IOC",
	}
	return this.SafeStringUpper(types, typeVar, typeVar)
}
func (this *ArkhamCore) ParseOrderStatus(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"new":       "pending",
		"staged":    "open",
		"booked":    "open",
		"taker":     "closed",
		"maker":     "closed",
		"cancelled": "canceled",
		"closed":    "closed",
	}
	return this.SafeString(statuses, status, status)
}

/**
 * @method
 * @name arkham#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://arkm.com/docs#get/trades/time
 * @param {string} [symbol] unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch trades for
 * @param {string} [params.page_token] page_token - used for paging
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func (this *ArkhamCore) FetchMyTrades(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes16028 := (<-this.LoadMarkets())
		PanicOnError(retRes16028)
		var request interface{} = map[string]interface{}{}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}
		// exchange needs to obtain some `from & to` values, otherwise it does not return any result
		var defaultRange interface{} = Multiply(Multiply(Multiply(24, 60), 60), 1000) // default to last 24 hours
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "from", Multiply(since, 1000)) // convert ms to microseconds
		} else {
			AddElementToObject(request, "from", Multiply((Subtract(this.Milliseconds(), defaultRange)), 1000)) // default to last 24 hours
		}
		var until interface{} = this.SafeInteger(params, "until")
		if IsTrue(!IsEqual(until, nil)) {
			params = this.Omit(params, "until")
			AddElementToObject(request, "to", Multiply(until, 1000)) // convert ms to microseconds
		} else {
			AddElementToObject(request, "to", this.Sum(GetValue(request, "from"), Multiply(defaultRange, 1000)))
		}
		requestparamsVariable := this.HandleUntilOption("until", request, params)
		request = GetValue(requestparamsVariable, 0)
		params = GetValue(requestparamsVariable, 1)

		response := (<-this.V1PrivateGetTradesTime(this.Extend(request, params)))
		PanicOnError(response)

		//
		//    [
		//        {
		//            "symbol": "SOL_USDT",
		//            "revisionId": "891839406",
		//            "size": "0.042",
		//            "price": "185.06",
		//            "takerSide": "sell",
		//            "time": "1753773952039342",
		//            "orderId": "3717304929194",
		//            "userSide": "sell",
		//            "quoteFee": "0.00777252",
		//            "arkmFee": "0",
		//            "clientOrderId": ""
		//        },
		//        ...
		//
		ch <- this.ParseTrades(response, nil, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name arkham#fetchAccounts
 * @description fetch all the accounts associated with a profile
 * @see https://arkm.com/docs#get/user
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/#/?id=account-structure} indexed by the account type
 */
func (this *ArkhamCore) FetchAccounts(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes16528 := (<-this.LoadMarkets())
		PanicOnError(retRes16528)
		var request interface{} = map[string]interface{}{}
		var accountId interface{} = nil
		accountIdparamsVariable := this.HandleOptionAndParams(params, "fetchAccounts", "accountId")
		accountId = GetValue(accountIdparamsVariable, 0)
		params = GetValue(accountIdparamsVariable, 1)
		if IsTrue(!IsEqual(accountId, nil)) {
			AddElementToObject(request, "subAccountId", accountId)
		}

		response := (<-this.V1PrivateGetUser(this.Extend(request, params)))
		PanicOnError(response)
		//
		//    {
		//        "id": "2959123",
		//        "email": "xyz@gmail.com",
		//        "username": "t.123",
		//        "requireMFA": true,
		//        "kycVerifiedAt": "1753434515850673",
		//        "pmm": false,
		//        "dmm": false,
		//        "becameVipAt": "0",
		//        "subaccounts": [
		//            {
		//                "id": "0",
		//                "name": "Primary",
		//                "pinned": true,
		//                "isLsp": false,
		//                "futuresEnabled": true,
		//                "payFeesInArkm": false,
		//                "lspSettings": []
		//            }
		//        ],
		//        "settings": {
		//            "autogenDepositAddresses": false,
		//            "hideBalances": false,
		//            "confirmBeforePlaceOrder": false,
		//            "tickerTapeScroll": true,
		//            "updatesFlash": true,
		//            "notifyOrderFills": false,
		//            "notifyAnnouncements": false,
		//            "notifyMarginUsage": false,
		//            "marginUsageThreshold": "0.5",
		//            "notifyWithdrawals": true,
		//            "notifyDeposits": true,
		//            "notifySendEmail": true,
		//            "notifyRebates": true,
		//            "notifyCommissions": true,
		//            "allowSequenceEmails": true,
		//            "language": "en"
		//        },
		//        "airdropKycAt": null
		//    }
		//
		var subAccounts interface{} = this.SafeList(response, "subaccounts", []interface{}{})

		ch <- this.ParseAccounts(subAccounts, params)
		return nil

	}()
	return ch
}
func (this *ArkhamCore) ParseAccount(account interface{}) interface{} {
	//
	//            {
	//                "id": "0",
	//                "name": "Primary",
	//                "pinned": true,
	//                "isLsp": false,
	//                "futuresEnabled": true,
	//                "payFeesInArkm": false,
	//                "lspSettings": []
	//            }
	//
	return map[string]interface{}{
		"id":   this.SafeString(account, "id"),
		"type": nil,
		"code": nil,
		"info": account,
	}
}

/**
 * @method
 * @name arkham#fetchBalance
 * @description query for account info
 * @see https://arkm.com/docs#get/account/balances
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func (this *ArkhamCore) FetchBalance(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes17358 := (<-this.LoadMarkets())
		PanicOnError(retRes17358)

		response := (<-this.V1PrivateGetAccountBalances(params))
		PanicOnError(response)

		//
		//    [
		//        {
		//            "subaccountId": "0",
		//            "symbol": "USDT",
		//            "balance": "19.66494694",
		//            "free": "19.66494694",
		//            "priceUSDT": "1",
		//            "balanceUSDT": "19.66494694",
		//            "freeUSDT": "19.66494694",
		//            "lastUpdateReason": "orderFill",
		//            "lastUpdateTime": "1753773952039342",
		//            "lastUpdateId": "248507437",
		//            "lastUpdateAmount": "7.77252"
		//        },
		//        {
		//            "subaccountId": "0",
		//            "symbol": "SOL",
		//            "balance": "0",
		//            "free": "0",
		//            "priceUSDT": "186.025584673",
		//            "balanceUSDT": "0",
		//            "freeUSDT": "0",
		//            "lastUpdateReason": "orderFill",
		//            "lastUpdateTime": "1753773952039342",
		//            "lastUpdateId": "248507435",
		//            "lastUpdateAmount": "-0.042"
		//        }
		//    ]
		//
		ch <- this.ParseBalance(response)
		return nil

	}()
	return ch
}
func (this *ArkhamCore) ParseBalance(response interface{}) interface{} {
	var timestamp interface{} = this.SafeIntegerProduct(response, "lastUpdateTime", 0.001)
	var result interface{} = map[string]interface{}{
		"info":      response,
		"timestamp": timestamp,
		"datetime":  this.Iso8601(timestamp),
	}
	for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
		var balance interface{} = GetValue(response, i)
		var symbol interface{} = this.SafeString(balance, "symbol")
		var code interface{} = this.SafeCurrencyCode(symbol)
		var account interface{} = this.Account()
		AddElementToObject(account, "total", this.SafeString(balance, "balance"))
		AddElementToObject(account, "free", this.SafeString(balance, "free"))
		AddElementToObject(result, code, account)
	}
	return this.SafeBalance(result)
}

/**
 * @method
 * @name arkham#createDepositAddress
 * @description create a currency deposit address
 * @see https://arkm.com/docs#post/account/deposit/addresses/new
 * @param {string} code unified currency code of the currency for the deposit address
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func (this *ArkhamCore) CreateDepositAddress(code interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes17998 := (<-this.LoadMarkets())
		PanicOnError(retRes17998)
		var networkCode interface{} = nil
		networkCodeparamsVariable := this.HandleNetworkCodeAndParams(params)
		networkCode = GetValue(networkCodeparamsVariable, 0)
		params = GetValue(networkCodeparamsVariable, 1)
		if IsTrue(IsEqual(networkCode, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " createDepositAddress() requires a \"network\" param")))
		}
		var request interface{} = map[string]interface{}{
			"chain": networkCode,
		}

		response := (<-this.V1PrivatePostAccountDepositAddressesNew(this.Extend(request, params)))
		PanicOnError(response)
		//
		//    {
		//        "addresses": "12NauJ26TUT9aYkpId7YdePJJDRMGbAsEMVoTVUvBErV"
		//    }
		//
		var address interface{} = this.SafeString(response, "addresses")

		ch <- this.ParseDepositAddress(address, this.Currency(code))
		return nil

	}()
	return ch
}

/**
 * @method
 * @name arkham#fetchDepositAddressesByNetwork
 * @description fetch the deposit addresses for a currency associated with this account
 * @see https://arkm.com/docs#get/account/deposit/addresses
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary [address structures]{@link https://docs.ccxt.com/#/?id=address-structure}, indexed by the network
 */
func (this *ArkhamCore) FetchDepositAddressesByNetwork(code interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes18288 := (<-this.LoadMarkets())
		PanicOnError(retRes18288)
		var networkCode interface{} = nil
		networkCodeparamsVariable := this.HandleNetworkCodeAndParams(params)
		networkCode = GetValue(networkCodeparamsVariable, 0)
		params = GetValue(networkCodeparamsVariable, 1)
		if IsTrue(IsEqual(networkCode, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchDepositAddressesByNetwork() requires a \"network\" param")))
		}
		var request interface{} = map[string]interface{}{
			"chain": this.NetworkCodeToId(networkCode),
		}

		response := (<-this.V1PrivateGetAccountDepositAddresses(this.Extend(request, params)))
		PanicOnError(response)
		//
		//    {
		//        "addresses": [
		//            "12NauJ26TUT9aYkpId7YdePJJDRMGbAsEMVoTVUvBErV"
		//        ]
		//    }
		//
		var data interface{} = this.SafeList(response, "addresses")
		var parsed interface{} = this.ParseDepositAddresses(data, nil, false, map[string]interface{}{
			"network": networkCode,
		})

		ch <- this.IndexBy(parsed, "network")
		return nil

	}()
	return ch
}
func (this *ArkhamCore) ParseDepositAddress(entry interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     "12NauJ26TUT9aYkpId7YdePJJDRMGbAsEMVoTVUvBErV"
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	return map[string]interface{}{
		"info":     entry,
		"currency": this.SafeString(currency, "code"),
		"network":  nil,
		"address":  entry,
		"tag":      nil,
	}
}

/**
 * @method
 * @name arkham#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account
 * @see https://arkm.com/docs#get/account/deposit/addresses
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func (this *ArkhamCore) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes18738 := (<-this.LoadMarkets())
		PanicOnError(retRes18738)
		var currency interface{} = this.Currency(code)
		var networkCodeAndParams interface{} = this.HandleNetworkCodeAndParams(params)
		var networkCode interface{} = GetValue(networkCodeAndParams, 0)

		indexedAddresses := (<-this.FetchDepositAddressesByNetwork(code, params))
		PanicOnError(indexedAddresses)
		var selectedNetworkCode interface{} = this.SelectNetworkCodeFromUnifiedNetworks(GetValue(currency, "code"), networkCode, indexedAddresses)
		var address interface{} = this.SafeDict(indexedAddresses, selectedNetworkCode)
		if IsTrue(IsEqual(address, nil)) {
			panic(InvalidAddress(Add(Add(this.Id, " fetchDepositAddress() could not find a deposit address for "), code)))
		}

		ch <- address
		return nil

	}()
	return ch
}

/**
 * @method
 * @name arkham#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://arkm.com/docs#get/account/deposits
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func (this *ArkhamCore) FetchDeposits(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes18988 := (<-this.LoadMarkets())
		PanicOnError(retRes18988)
		var request interface{} = map[string]interface{}{}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}

		response := (<-this.V1PrivateGetAccountDeposits(this.Extend(request, params)))
		PanicOnError(response)
		//
		//    [
		//        {
		//            "id": "238644",
		//            "symbol": "SOL",
		//            "amount": "0.104",
		//            "time": "1753436404000000",
		//            "confirmed": true,
		//            "transactionHash": "1DRxbbyePTsMuB82SDf2fG5gLXH5iYnY8TQDstDPLULpLtjMJtF1ug1T4Mf8B6DSb8fp2sb5YtdbyqieZ2tkE1Ve",
		//            "chain": "Solana",
		//            "depositAddress": "12NauJ26TUT9aYkpId7YdePJJDRMGbAsEMVoTVUvBErV",
		//            "price": "180.322010164"
		//        }
		//    ]
		//
		var currency interface{} = nil
		if IsTrue(!IsEqual(code, nil)) {
			currency = this.Currency(code)
		}

		ch <- this.ParseTransactions(response, currency, since, limit)
		return nil

	}()
	return ch
}
func (this *ArkhamCore) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{} {
	//
	//        {
	//            "id": "238644",
	//            "symbol": "SOL",
	//            "amount": "0.104",
	//            "time": "1753436404000000",
	//            "confirmed": true,
	//            "transactionHash": "1DRxbbyePTsMuB82SDf2fG5gLXH5iYnY8TQDstDPLULpLtjMJtF1ug1T4Mf8B6DSb8fp2sb5YtdbyqieZ2tkE1Ve",
	//            "chain": "Solana",
	//            "depositAddress": "12NauJ26TUT9aYkpId7YdePJJDRMGbAsEMVoTVUvBErV",
	//            "price": "180.322010164"
	//        }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var address interface{} = this.SafeString(transaction, "depositAddress")
	var timestamp interface{} = this.SafeIntegerProduct(transaction, "time", 0.001)
	var confirmd interface{} = this.SafeBool(transaction, "confirmed")
	var status interface{} = nil
	if IsTrue(confirmd) {
		status = "ok"
	}
	var currencyId interface{} = this.SafeString(transaction, "symbol")
	var code interface{} = this.SafeCurrencyCode(currencyId, currency)
	return map[string]interface{}{
		"info":        transaction,
		"id":          this.SafeString(transaction, "id"),
		"txid":        this.SafeString(transaction, "transactionHash"),
		"type":        nil,
		"currency":    code,
		"network":     this.NetworkIdToCode(this.SafeString(transaction, "chain")),
		"amount":      this.SafeNumber(transaction, "amount"),
		"status":      status,
		"timestamp":   timestamp,
		"datetime":    this.Iso8601(timestamp),
		"address":     address,
		"addressFrom": nil,
		"addressTo":   address,
		"tag":         nil,
		"tagFrom":     nil,
		"tagTo":       nil,
		"updated":     nil,
		"comment":     nil,
		"fee":         nil,
		"internal":    false,
	}
}

/**
 * @method
 * @name arkham#fetchTradingFees
 * @description fetch the trading fees for multiple markets
 * @see https://arkm.com/docs#get/account/fees
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.subType] "linear" or "inverse"
 * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
 */
func (this *ArkhamCore) FetchTradingFees(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes19838 := (<-this.LoadMarkets())
		PanicOnError(retRes19838)

		response := (<-this.V1PrivateGetAccountFees(params))
		PanicOnError(response)
		//
		// {
		//   "perpMakerFee": "1.23",
		//   "perpTakerFee": "1.23",
		//   "spotMakerFee": "1.23",
		//   "spotTakerFee": "1.23"
		// }
		//
		var symbols interface{} = ObjectKeys(this.Markets)
		var result interface{} = map[string]interface{}{}
		var spotMaker interface{} = this.SafeNumber(response, "spotMakerFee")
		var spotTaker interface{} = this.SafeNumber(response, "spotTakerFee")
		var perpMaker interface{} = this.SafeNumber(response, "perpMakerFee")
		var perpTaker interface{} = this.SafeNumber(response, "perpTakerFee")
		for i := 0; IsLessThan(i, GetArrayLength(symbols)); i++ {
			var symbol interface{} = GetValue(symbols, i)
			var market interface{} = GetValue(this.Markets, symbol)
			AddElementToObject(result, symbol, map[string]interface{}{
				"info":   response,
				"symbol": symbol,
			})
			if IsTrue(GetValue(market, "spot")) {
				AddElementToObject(GetValue(result, symbol), "maker", spotMaker)
				AddElementToObject(GetValue(result, symbol), "taker", spotTaker)
			} else if IsTrue(IsTrue(GetValue(market, "swap")) || IsTrue(GetValue(market, "future"))) {
				AddElementToObject(GetValue(result, symbol), "maker", perpMaker)
				AddElementToObject(GetValue(result, symbol), "taker", perpTaker)
			}
		}

		ch <- result
		return nil

	}()
	return ch
}

/**
 * @method
 * @name arkham#fetchFundingHistory
 * @description fetch the history of funding payments paid and received on this account
 * @see https://arkm.com/docs#get/account/funding-rate-payments
 * @param {string} [symbol] unified market symbol
 * @param {int} [since] the earliest time in ms to fetch funding history for
 * @param {int} [limit] the maximum number of funding history structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object} a [funding history structure]{@link https://docs.ccxt.com/#/?id=funding-history-structure}
 */
func (this *ArkhamCore) FetchFundingHistory(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes20308 := (<-this.LoadMarkets())
		PanicOnError(retRes20308)
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
		}
		var request interface{} = map[string]interface{}{}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}

		response := (<-this.V1PrivateGetAccountFundingRatePayments(this.Extend(request, params)))
		PanicOnError(response)

		//
		//     [
		//         {
		//             "amount": "20.1",
		//             "assetSymbol": "BTC",
		//             "indexPrice": "1.23",
		//             "pairSymbol": "BTC_USDT",
		//             "time": 1704067200000000,
		//             "id": 1,
		//             "subaccountId": 1,
		//             "userId": 1
		//         },
		//         ...
		//     ]
		//
		ch <- this.ParseIncomes(response, market, since, limit)
		return nil

	}()
	return ch
}
func (this *ArkhamCore) ParseIncome(income interface{}, optionalArgs ...interface{}) interface{} {
	//
	//         {
	//             "amount": "20.1",
	//             "assetSymbol": "BTC",
	//             "indexPrice": "1.23",
	//             "pairSymbol": "BTC_USDT",
	//             "time": 1704067200000000,
	//             "id": 1,
	//             "subaccountId": 1,
	//             "userId": 1
	//         }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(income, "pairSymbol")
	var currencyId interface{} = this.SafeString(income, "assetSymbol")
	var timestamp interface{} = this.SafeIntegerProduct(income, "time", 0.001)
	return map[string]interface{}{
		"info":      income,
		"symbol":    this.SafeSymbol(marketId, market),
		"code":      this.SafeCurrencyCode(currencyId),
		"timestamp": timestamp,
		"datetime":  this.Iso8601(timestamp),
		"id":        this.SafeString(income, "id"),
		"amount":    this.SafeNumber(income, "amount"),
	}
}

/**
 * @method
 * @name arkham#fetchLeverage
 * @description fetch the set leverage for a market
 * @see https://arkm.com/docs#get/account/leverage
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [leverage structure]{@link https://docs.ccxt.com/#/?id=leverage-structure}
 */
func (this *ArkhamCore) FetchLeverage(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes20958 := (<-this.LoadMarkets())
		PanicOnError(retRes20958)
		var market interface{} = this.Market(symbol)
		var marketId interface{} = this.SafeString(market, "id")
		var request interface{} = map[string]interface{}{
			"symbol": marketId,
		}

		response := (<-this.V1PrivateGetAccountLeverage(this.Extend(request, params)))
		PanicOnError(response)
		//
		// might be empty if not changed from default value (which is 1x)
		//
		//    [
		//        {
		//            "symbol": "BTC_USDT_PERP",
		//            "leverage": "7"
		//        },
		//        {
		//            "symbol": "ETH_USDT_PERP",
		//            "leverage": "5"
		//        }
		//    ]
		//
		var indexed interface{} = this.IndexBy(response, "symbol")
		var data interface{} = this.SafeDict(indexed, marketId, map[string]interface{}{})

		ch <- this.ParseLeverage(data, market)
		return nil

	}()
	return ch
}
func (this *ArkhamCore) ParseLeverage(leverage interface{}, optionalArgs ...interface{}) interface{} {
	//
	//        {
	//            "symbol": "ETH_USDT_PERP",
	//            "leverage": "5"
	//        }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(leverage, "symbol")
	var leverageNum interface{} = this.SafeNumber(leverage, "leverage") // default leverage is 1 typically
	return map[string]interface{}{
		"info":          leverage,
		"symbol":        this.SafeSymbol(marketId, market),
		"marginMode":    nil,
		"longLeverage":  leverageNum,
		"shortLeverage": leverageNum,
	}
}

/**
 * @method
 * @name arkham#setLeverage
 * @description set the level of leverage for a market
 * @see https://arkm.com/docs#post/account/leverage
 * @param {float} leverage the rate of leverage
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} response from the exchange
 */
func (this *ArkhamCore) SetLeverage(leverage interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " setLeverage() requires a symbol argument")))
		}

		retRes21538 := (<-this.LoadMarkets())
		PanicOnError(retRes21538)
		var market interface{} = this.Market(symbol)
		var leverageString interface{} = this.NumberToString(leverage)
		var marketId interface{} = this.SafeString(market, "id")
		var request interface{} = map[string]interface{}{
			"symbol":   marketId,
			"leverage": leverageString,
		}

		response := (<-this.V1PrivatePostAccountLeverage(this.Extend(request, params)))
		PanicOnError(response)

		//
		// response is just empty string
		//
		ch <- this.ParseLeverage(response, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name arkkm#fetchPositions
 * @description fetch all open positions
 * @see https://arkm.com/docs#get/account/positions
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.standard] whether to fetch standard contract positions
 * @returns {object[]} a list of [position structures]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func (this *ArkhamCore) FetchPositions(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes21798 := (<-this.LoadMarkets())
		PanicOnError(retRes21798)
		symbols = this.MarketSymbols(symbols)

		response := (<-this.V1PrivateGetAccountPositions(params))
		PanicOnError(response)

		//
		//    [
		//        {
		//            "subaccountId": "0",
		//            "symbol": "SOL_USDT_PERP",
		//            "base": "0.037",
		//            "quote": "-6.44614",
		//            "openBuySize": "0",
		//            "openSellSize": "0",
		//            "openBuyNotional": "0",
		//            "openSellNotional": "0",
		//            "lastUpdateReason": "orderFill",
		//            "lastUpdateTime": "1753903829389966",
		//            "lastUpdateId": "250434684",
		//            "lastUpdateBaseDelta": "0.037",
		//            "lastUpdateQuoteDelta": "-6.44614",
		//            "breakEvenPrice": "174.22",
		//            "markPrice": "174.33",
		//            "value": "6.45021",
		//            "pnl": "0.00407",
		//            "initialMargin": "0.645021",
		//            "maintenanceMargin": "0.3870126",
		//            "averageEntryPrice": "174.22"
		//        }
		//    ]
		//
		ch <- this.ParsePositions(response, symbols)
		return nil

	}()
	return ch
}
func (this *ArkhamCore) ParsePosition(position interface{}, optionalArgs ...interface{}) interface{} {
	//
	//        {
	//            "subaccountId": "0",
	//            "symbol": "SOL_USDT_PERP",
	//            "base": "0.037",                             // negative for short position
	//            "quote": "-6.44614",                         // negative for long position
	//            "openBuySize": "0",
	//            "openSellSize": "0",
	//            "openBuyNotional": "0",
	//            "openSellNotional": "0",
	//            "lastUpdateReason": "orderFill",
	//            "lastUpdateTime": "1753903829389966",
	//            "lastUpdateId": "250434684",
	//            "lastUpdateBaseDelta": "0.037",
	//            "lastUpdateQuoteDelta": "-6.44614",
	//            "breakEvenPrice": "174.22",
	//            "markPrice": "174.33",
	//            "value": "6.45021",
	//            "pnl": "0.00407",
	//            "initialMargin": "0.645021",
	//            "maintenanceMargin": "0.3870126",
	//            "averageEntryPrice": "174.22"
	//        }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var base interface{} = this.SafeString(position, "base")
	var baseAbs interface{} = Precise.StringAbs(base)
	var isLong interface{} = Precise.StringGe(base, "0")
	var side interface{} = Ternary(IsTrue(isLong), "long", "short")
	var marketId interface{} = this.SafeString(position, "symbol")
	var notional interface{} = this.SafeString(position, "value")
	return this.SafePosition(map[string]interface{}{
		"info":                        position,
		"id":                          nil,
		"symbol":                      this.SafeSymbol(marketId, market),
		"notional":                    this.ParseNumber(Precise.StringAbs(notional)),
		"marginMode":                  nil,
		"liquidationPrice":            nil,
		"entryPrice":                  this.SafeNumber(position, "averageEntryPrice"),
		"unrealizedPnl":               this.SafeNumber(position, "pnl"),
		"realizedPnl":                 nil,
		"percentage":                  nil,
		"contracts":                   this.ParseNumber(baseAbs),
		"contractSize":                nil,
		"markPrice":                   this.SafeNumber(position, "markPrice"),
		"lastPrice":                   nil,
		"side":                        side,
		"hedged":                      nil,
		"timestamp":                   nil,
		"datetime":                    nil,
		"lastUpdateTimestamp":         this.SafeInteger(position, "lastUpdateTime"),
		"maintenanceMargin":           this.SafeNumber(position, "maintenanceMargin"),
		"maintenanceMarginPercentage": nil,
		"collateral":                  nil,
		"initialMargin":               this.SafeNumber(position, "initialMargin"),
		"initialMarginPercentage":     nil,
		"leverage":                    nil,
		"marginRatio":                 nil,
		"stopLossPrice":               nil,
		"takeProfitPrice":             nil,
	})
}

/**
 * @method
 * @name arkkm#withdraw
 * @description make a withdrawal
 * @see https://arkm.com/docs#post/account/withdraw
 * @see https://arkm.com/docs#get/account/withdrawal/addresses
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func (this *ArkhamCore) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		tag := GetArg(optionalArgs, 0, nil)
		_ = tag
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params)
		tag = GetValue(tagparamsVariable, 0)
		params = GetValue(tagparamsVariable, 1)

		retRes22898 := (<-this.LoadMarkets())
		PanicOnError(retRes22898)

		withdrawalAddresses := (<-this.V1PrivateGetAccountWithdrawalAddresses())
		PanicOnError(withdrawalAddresses)
		//
		//    [
		//        {
		//            "id": "12345",
		//            "chain": "ETH",
		//            "address": "0x743f79D65EA07AA222F4a83c10dee4210A920a6e",
		//            "label": "my_binance",
		//            "createdAt": "1753905200074355",
		//            "updatedAt": "1753905213464278",
		//            "confirmed": true
		//        }
		//    ]
		//
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"symbol":       GetValue(currency, "id"),
			"amount":       this.CurrencyToPrecision(code, amount),
			"subaccountId": this.SafeInteger(params, "subAccountId", 0),
		}
		var networkCode interface{} = nil
		networkCodeparamsVariable := this.HandleNetworkCodeAndParams(params)
		networkCode = GetValue(networkCodeparamsVariable, 0)
		params = GetValue(networkCodeparamsVariable, 1)
		if IsTrue(IsEqual(networkCode, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " withdraw() requires a \"network\" param")))
		}
		var indexedList interface{} = this.GroupBy(withdrawalAddresses, "address")
		if !IsTrue((InOp(indexedList, address))) {
			panic(InvalidAddress(Add(this.Id, " withdraw() requires an address that has been previously added to the whitelisted addresses")))
		}
		var withdrawalObjects interface{} = GetValue(indexedList, address)
		var foundWithdrawalObject interface{} = nil
		for i := 0; IsLessThan(i, GetArrayLength(withdrawalObjects)); i++ {
			var withdrawalObject interface{} = GetValue(withdrawalObjects, i)
			if IsTrue(IsEqual(GetValue(withdrawalObject, "chain"), networkCode)) {
				foundWithdrawalObject = withdrawalObject
				break
			}
		}
		if IsTrue(IsEqual(foundWithdrawalObject, nil)) {
			panic(InvalidAddress(Add(Add(Add(Add(this.Id, " withdraw() can not find whitelisted withdrawal address for "), address), " with network "), networkCode)))
		}
		AddElementToObject(request, "addressId", this.SafeInteger(foundWithdrawalObject, "id"))

		response := (<-this.V1PrivatePostAccountWithdraw(this.Extend(request, params)))
		PanicOnError(response)
		//
		// response is a weird string like:
		//
		//    "1234709779980\\n"
		//
		var responseString interface{} = Replace(response, "\n", "")
		var data interface{} = map[string]interface{}{
			"id": responseString,
		}

		ch <- this.ParseTransaction(data, currency)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name arkham#fetchLeverageTiers
 * @description retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes
 * @see https://arkm.com/docs#get/public/margin-schedules
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [leverage tiers structures]{@link https://docs.ccxt.com/#/?id=leverage-tiers-structure}, indexed by market symbols
 */
func (this *ArkhamCore) FetchLeverageTiers(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes23538 := (<-this.LoadMarkets())
		PanicOnError(retRes23538)
		if IsTrue(IsEqual(symbols, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchLeverageTiers() requires a symbols argument")))
		}
		symbols = this.MarketSymbols(symbols)

		response := (<-this.V1PublicGetMarginSchedules(params))
		PanicOnError(response)

		//
		//    [
		//        {
		//            "name": "A",
		//            "bands": [
		//                {
		//                    "positionLimit": "1000000",
		//                    "leverageRate": "50",
		//                    "marginRate": "0.02",
		//                    "rebate": "0"
		//                },
		//                {
		//                    "positionLimit": "2000000",
		//                    "leverageRate": "25",
		//                    "marginRate": "0.04",
		//                    "rebate": "20000"
		//                },
		//                {
		//                    "positionLimit": "5000000",
		//                    "leverageRate": "20",
		//                    "marginRate": "0.05",
		//                    "rebate": "40000"
		//                }
		//            ]
		//        },
		//        {
		//            "name": "B",
		//            ...
		//
		ch <- this.ParseLeverageTiers(response, symbols)
		return nil

	}()
	return ch
}
func (this *ArkhamCore) ParseLeverageTiers(response interface{}, optionalArgs ...interface{}) interface{} {
	// overloaded method
	symbols := GetArg(optionalArgs, 0, nil)
	_ = symbols
	marketIdKey := GetArg(optionalArgs, 1, nil)
	_ = marketIdKey
	var indexed interface{} = this.IndexBy(response, "name")
	symbols = this.MarketSymbols(symbols)
	var tiers interface{} = map[string]interface{}{}
	for i := 0; IsLessThan(i, GetArrayLength(symbols)); i++ {
		var symbol interface{} = GetValue(symbols, i)
		var market interface{} = this.Market(symbol)
		var marginSchedule interface{} = this.SafeString(GetValue(market, "info"), "marginSchedule")
		if IsTrue(IsEqual(marginSchedule, nil)) {
			panic(BadSymbol(Add(Add(this.Id, " fetchLeverageTiers() could not find marginSchedule for "), symbol)))
		}
		var selectedDict interface{} = this.SafeDict(indexed, marginSchedule, map[string]interface{}{})
		var bands interface{} = this.SafeList(selectedDict, "bands", []interface{}{})
		AddElementToObject(tiers, symbol, this.ParseMarketLeverageTiers(bands, market))
	}
	return tiers
}
func (this *ArkhamCore) ParseMarketLeverageTiers(info interface{}, optionalArgs ...interface{}) interface{} {
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var tiers interface{} = []interface{}{}
	var brackets interface{} = info
	var minNotional interface{} = 0
	for i := 0; IsLessThan(i, GetArrayLength(brackets)); i++ {
		var tier interface{} = GetValue(brackets, i)
		var marketId interface{} = this.SafeString(info, "market")
		market = this.SafeMarket(marketId, market, nil, "swap")
		var maxNotional interface{} = this.SafeNumber(tier, "positionLimit")
		AppendToArray(&tiers, map[string]interface{}{
			"tier":                  this.Sum(i, 1),
			"symbol":                this.SafeSymbol(marketId, market, nil, "swap"),
			"currency":              Ternary(IsTrue(GetValue(market, "linear")), GetValue(market, "base"), GetValue(market, "quote")),
			"minNotional":           minNotional,
			"maxNotional":           maxNotional,
			"maintenanceMarginRate": this.SafeNumber(tier, "marginRate"),
			"maxLeverage":           this.SafeInteger(tier, "leverageRate"),
			"info":                  tier,
		})
		minNotional = maxNotional
	}
	return tiers
}
func (this *ArkhamCore) FindTimeframeByDuration(duration interface{}) interface{} {
	// this method is used to find the timeframe by duration in seconds
	var timeframes interface{} = this.SafeDict(this.Options, "timeframeDurations", map[string]interface{}{})
	var keys interface{} = ObjectKeys(timeframes)
	for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
		var timeframe interface{} = GetValue(keys, i)
		var durationInMicroseconds interface{} = this.SafeInteger(timeframes, timeframe)
		if IsTrue(IsEqual(durationInMicroseconds, duration)) {
			return timeframe
		}
	}
	return nil
}
func (this *ArkhamCore) Sign(path interface{}, optionalArgs ...interface{}) interface{} {
	api := GetArg(optionalArgs, 0, "public")
	_ = api
	method := GetArg(optionalArgs, 1, "GET")
	_ = method
	params := GetArg(optionalArgs, 2, map[string]interface{}{})
	_ = params
	headers := GetArg(optionalArgs, 3, nil)
	_ = headers
	body := GetArg(optionalArgs, 4, nil)
	_ = body
	var typeVar interface{} = this.SafeString(api, 0)
	var access interface{} = this.SafeString(api, 1)
	var accessPart interface{} = Ternary(IsTrue((IsEqual(access, "public"))), Add(access, "/"), "")
	var query interface{} = this.Omit(params, this.ExtractParams(path))
	path = this.ImplodeParams(path, params)
	var url interface{} = Add(Add(Add(GetValue(GetValue(this.Urls, "api"), typeVar), "/"), accessPart), path)
	var queryString interface{} = ""
	if IsTrue(IsEqual(method, "GET")) {
		if IsTrue(GetArrayLength(ObjectKeys(query))) {
			queryString = this.Urlencode(query)
			url = Add(url, Add("?", queryString))
		}
	}
	if IsTrue(IsEqual(access, "private")) {
		this.CheckRequiredCredentials()
		var expires interface{} = Multiply((Add(this.Milliseconds(), this.SafeInteger(this.Options, "requestExpiration", 5000))), 1000) // need macroseconds
		if IsTrue(IsEqual(method, "POST")) {
			body = this.Json(params)
		}
		if IsTrue(!IsEqual(queryString, "")) {
			path = Add(Add(path, "?"), queryString)
		}
		var bodyStr interface{} = Ternary(IsTrue((!IsEqual(body, nil))), body, "")
		var payload interface{} = Add(Add(Add(Add(Add(this.ApiKey, ToString(expires)), ToUpper(method)), "/"), path), bodyStr)
		var decodedSecret interface{} = this.Base64ToBinary(this.Secret)
		var signature interface{} = this.Hmac(this.Encode(payload), decodedSecret, sha256, "base64")
		headers = map[string]interface{}{
			"Content-Type":     "application/json",
			"Accept":           "application/json",
			"Arkham-Api-Key":   this.ApiKey,
			"Arkham-Expires":   ToString(expires),
			"Arkham-Signature": signature,
			"Arkham-Broker-Id": "1001",
		}
	}
	return map[string]interface{}{
		"url":     url,
		"method":  method,
		"body":    body,
		"headers": headers,
	}
}
func (this *ArkhamCore) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{} {
	//
	// error example:
	//
	//    {
	//        "id": "30005",
	//        "name": "InvalidNotional",
	//        "message": "order validation failed: invalid notional: notional 0.25 is less than min notional 1"
	//    }
	//
	var message interface{} = this.SafeString(response, "message")
	if IsTrue(!IsEqual(message, nil)) {
		var errorCode interface{} = this.SafeString(response, "id")
		var feedback interface{} = Add(Add(this.Id, " "), body)
		this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), errorCode, feedback)
		this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), message, feedback)
		this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), message, feedback)
		panic(ExchangeError(Add(Add(this.Id, " "), body)))
	}
	return nil
}

func (this *ArkhamCore) Init(userConfig map[string]interface{}) {
	this.Exchange = Exchange{}
	this.Exchange.DerivedExchange = this
	this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
}
