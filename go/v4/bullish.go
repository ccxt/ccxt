package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type BullishCore struct {
	Exchange
}

func NewBullishCore() *BullishCore {
	p := &BullishCore{}
	setDefaults(p)
	return p
}

func (this *BullishCore) Describe() interface{} {
	return this.DeepExtend(this.Exchange.Describe(), map[string]interface{}{
		"id":        "bullish",
		"name":      "Bullish",
		"countries": []interface{}{"DE"},
		"version":   "v3",
		"rateLimit": 20,
		"pro":       true,
		"has": map[string]interface{}{
			"CORS":                           nil,
			"spot":                           true,
			"margin":                         false,
			"swap":                           false,
			"future":                         false,
			"option":                         false,
			"addMargin":                      false,
			"borrowMargin":                   false,
			"cancelAllOrders":                true,
			"cancelOrder":                    true,
			"cancelOrders":                   false,
			"createDepositAddress":           false,
			"createLimitBuyOrder":            true,
			"createLimitOrder":               true,
			"createLimitSellOrder":           true,
			"createMarketBuyOrder":           true,
			"createMarketOrder":              true,
			"createMarketSellOrder":          true,
			"createOrder":                    true,
			"createPostOnlyOrder":            true,
			"createTriggerOrder":             true,
			"deposit":                        false,
			"editOrder":                      true,
			"fetchAccounts":                  true,
			"fetchBalance":                   true,
			"fetchBidsAsks":                  false,
			"fetchBorrowInterest":            false,
			"fetchBorrowRateHistories":       false,
			"fetchBorrowRateHistory":         true,
			"fetchCanceledAndClosedOrders":   true,
			"fetchCanceledOrders":            true,
			"fetchClosedOrder":               false,
			"fetchClosedOrders":              true,
			"fetchCrossBorrowRate":           false,
			"fetchCrossBorrowRates":          false,
			"fetchCurrencies":                true,
			"fetchDeposit":                   false,
			"fetchDepositAddress":            true,
			"fetchDepositAddresses":          false,
			"fetchDepositAddressesByNetwork": false,
			"fetchDeposits":                  false,
			"fetchDepositsWithdrawals":       true,
			"fetchDepositWithdrawFee":        false,
			"fetchDepositWithdrawFees":       false,
			"fetchFundingHistory":            false,
			"fetchFundingRate":               false,
			"fetchFundingRateHistory":        true,
			"fetchFundingRates":              false,
			"fetchIndexOHLCV":                false,
			"fetchIsolatedBorrowRate":        false,
			"fetchIsolatedBorrowRates":       false,
			"fetchL3OrderBook":               false,
			"fetchLedger":                    false,
			"fetchLeverage":                  false,
			"fetchLeverageTiers":             false,
			"fetchMarketLeverageTiers":       false,
			"fetchMarkets":                   true,
			"fetchMarkOHLCV":                 false,
			"fetchMyTrades":                  true,
			"fetchOHLCV":                     true,
			"fetchOpenInterestHistory":       false,
			"fetchOpenOrder":                 false,
			"fetchOpenOrders":                true,
			"fetchOrder":                     true,
			"fetchOrderBook":                 true,
			"fetchOrderBooks":                false,
			"fetchOrders":                    true,
			"fetchOrderTrades":               true,
			"fetchPosition":                  false,
			"fetchPositionHistory":           false,
			"fetchPositionMode":              false,
			"fetchPositions":                 true,
			"fetchPositionsForSymbol":        false,
			"fetchPositionsHistory":          false,
			"fetchPositionsRisk":             false,
			"fetchPremiumIndexOHLCV":         false,
			"fetchStatus":                    false,
			"fetchTicker":                    true,
			"fetchTickers":                   false,
			"fetchTime":                      true,
			"fetchTrades":                    true,
			"fetchTradingFee":                false,
			"fetchTradingFees":               false,
			"fetchTradingLimits":             false,
			"fetchTransactionFee":            false,
			"fetchTransactionFees":           false,
			"fetchTransactions":              false,
			"fetchTransfers":                 true,
			"fetchWithdrawal":                false,
			"fetchWithdrawals":               false,
			"fetchWithdrawalWhitelist":       false,
			"reduceMargin":                   false,
			"repayMargin":                    false,
			"setLeverage":                    false,
			"setMargin":                      false,
			"setMarginMode":                  false,
			"setPositionMode":                false,
			"signIn":                         true,
			"transfer":                       true,
			"withdraw":                       true,
			"ws":                             true,
		},
		"timeframes": map[string]interface{}{
			"1m":  "1m",
			"5m":  "5m",
			"30m": "30m",
			"1h":  "1h",
			"6h":  "6h",
			"12h": "12h",
			"1d":  "1d",
		},
		"urls": map[string]interface{}{
			"logo": "https://github.com/user-attachments/assets/68f0686b-84f0-4da9-a751-f7089af3a9ed",
			"api": map[string]interface{}{
				"public":  "https://api.exchange.bullish.com/trading-api",
				"private": "https://api.exchange.bullish.com/trading-api",
			},
			"test": map[string]interface{}{
				"public":  "https://api.simnext.bullish-test.com/trading-api",
				"private": "https://api.simnext.bullish-test.com/trading-api",
			},
			"www":      "https://bullish.com/",
			"referral": "",
			"doc":      []interface{}{"https://api.exchange.bullish.com/docs/api/rest/"},
		},
		"api": map[string]interface{}{
			"public": map[string]interface{}{
				"get": map[string]interface{}{
					"v1/nonce":                                 1,
					"v1/time":                                  1,
					"v1/assets":                                1,
					"v1/assets/{symbol}":                       1,
					"v1/markets":                               1,
					"v1/markets/{symbol}":                      1,
					"v1/history/markets/{symbol}":              1,
					"v1/markets/{symbol}/orderbook/hybrid":     1,
					"v1/markets/{symbol}/trades":               1,
					"v1/markets/{symbol}/tick":                 1,
					"v1/markets/{symbol}/candle":               1,
					"v1/history/markets/{symbol}/trades":       1,
					"v1/history/markets/{symbol}/funding-rate": 1,
					"v1/index-prices":                          1,
					"v1/index-prices/{assetSymbol}":            1,
					"v1/expiry-prices/{symbol}":                1,
					"v1/option-ladder":                         1,
					"v1/option-ladder/{symbol}":                1,
				},
			},
			"private": map[string]interface{}{
				"get": map[string]interface{}{
					"v2/orders":                                          1,
					"v2/history/orders":                                  1,
					"v2/orders/{orderId}":                                1,
					"v2/amm-instructions":                                1,
					"v2/amm-instructions/{instructionId}":                1,
					"v1/wallets/transactions":                            1,
					"v1/wallets/limits/{symbol}":                         1,
					"v1/wallets/deposit-instructions/crypto/{symbol}":    1,
					"v1/wallets/withdrawal-instructions/crypto/{symbol}": 1,
					"v1/wallets/deposit-instructions/fiat/{symbol}":      1,
					"v1/wallets/withdrawal-instructions/fiat/{symbol}":   1,
					"v1/wallets/self-hosted/verification-attempts":       1,
					"v1/trades":           5,
					"v1/history/trades":   5,
					"v1/trades/{tradeId}": 5,
					"v1/trades/client-order-id/{clientOrderId}":       1,
					"v1/accounts/asset":                               1,
					"v1/accounts/asset/{symbol}":                      1,
					"v1/users/logout":                                 1,
					"v1/users/hmac/login":                             1,
					"v1/accounts/trading-accounts":                    1,
					"v1/accounts/trading-accounts/{tradingAccountId}": 1,
					"v1/derivatives-positions":                        1,
					"v1/history/derivatives-settlement":               1,
					"v1/history/transfer":                             1,
					"v1/history/borrow-interest":                      1,
					"v2/mmp-configuration":                            1,
					"v2/otc-trades":                                   1,
					"v2/otc-trades/{otcTradeId}":                      1,
					"v2/otc-trades/unconfirmed-trade":                 1,
				},
				"post": map[string]interface{}{
					"v2/orders":                       5,
					"v2/command":                      5,
					"v2/amm-instructions":             1,
					"v1/wallets/withdrawal":           1,
					"v2/users/login":                  1,
					"v1/simulate-portfolio-margin":    1,
					"v1/wallets/self-hosted/initiate": 1,
					"v2/mmp-configuration":            1,
					"v2/otc-trades":                   1,
					"v2/otc-command":                  1,
				},
			},
		},
		"fees": map[string]interface{}{
			"trading": map[string]interface{}{
				"tierBased":  false,
				"percentage": true,
				"taker":      this.ParseNumber("0.001"),
				"maker":      this.ParseNumber("0.001"),
			},
		},
		"precisionMode": TICK_SIZE,
		"options": map[string]interface{}{
			"timeDifference":          0,
			"adjustForTimeDifference": false,
			"networks": map[string]interface{}{
				"BTC":   "BTC",
				"EOS":   "EOS",
				"ERC20": "ETH",
			},
			"defaultNetwork": "ERC20",
			"defaultNetworks": map[string]interface{}{
				"USDC": "ERC20",
			},
			"tradingAccountId": nil,
		},
		"features": map[string]interface{}{
			"default": map[string]interface{}{
				"sandbox": true,
				"createOrder": map[string]interface{}{
					"marginMode":                 false,
					"triggerPrice":               true,
					"triggerPriceType":           nil,
					"triggerDirection":           false,
					"stopLossPrice":              false,
					"takeProfitPrice":            false,
					"attachedStopLossTakeProfit": nil,
					"timeInForce": map[string]interface{}{
						"IOC": true,
						"FOK": true,
						"PO":  true,
						"GTD": false,
					},
					"hedged":                 false,
					"trailing":               false,
					"leverage":               false,
					"marketBuyByCost":        false,
					"marketBuyRequiresPrice": false,
					"selfTradePrevention":    false,
					"iceberg":                false,
				},
				"createOrders": nil,
				"fetchMyTrades": map[string]interface{}{
					"marginMode":     false,
					"limit":          100,
					"daysBack":       90,
					"symbolRequired": false,
					"untilDays":      90,
				},
				"fetchOrder": map[string]interface{}{
					"marginMode":     false,
					"trigger":        false,
					"trailing":       false,
					"symbolRequired": false,
				},
				"fetchOrders": map[string]interface{}{
					"marginMode":     false,
					"limit":          100,
					"daysBack":       90,
					"untilDays":      90,
					"trigger":        false,
					"trailing":       false,
					"symbolRequired": false,
				},
				"fetchOpenOrders": map[string]interface{}{
					"marginMode":     false,
					"limit":          100,
					"daysBack":       90,
					"untilDays":      90,
					"trigger":        false,
					"trailing":       false,
					"symbolRequired": false,
				},
				"fetchCanceledAndClosedOrders": map[string]interface{}{
					"marginMode":     false,
					"limit":          100,
					"daysBack":       90,
					"untilDays":      90,
					"trigger":        false,
					"trailing":       false,
					"symbolRequired": false,
				},
				"fetchClosedOrders": map[string]interface{}{
					"marginMode":       false,
					"limit":            100,
					"daysBack":         1,
					"daysBackCanceled": 1,
					"untilDays":        1,
					"trigger":          false,
					"trailing":         false,
					"symbolRequired":   false,
				},
				"fetchCanceledOrders": map[string]interface{}{
					"marginMode":     false,
					"limit":          100,
					"daysBack":       1,
					"untilDays":      1,
					"trigger":        false,
					"trailing":       false,
					"symbolRequired": false,
				},
				"fetchOHLCV": map[string]interface{}{
					"limit": 1000,
				},
			},
			"spot": map[string]interface{}{
				"extends": "default",
			},
			"swap": map[string]interface{}{
				"linear": map[string]interface{}{
					"extends": "default",
				},
				"inverse": nil,
			},
			"future": map[string]interface{}{
				"linear": map[string]interface{}{
					"extends": "default",
				},
				"inverse": nil,
			},
		},
		"exceptions": map[string]interface{}{
			"exact": map[string]interface{}{
				"1":    BadRequest,
				"5":    InvalidOrder,
				"6":    DuplicateOrderId,
				"13":   BadRequest,
				"15":   BadRequest,
				"18":   BadRequest,
				"1002": BadRequest,
				"2001": BadRequest,
				"2002": BadRequest,
				"2003": BadRequest,
				"2004": BadRequest,
				"2005": ExchangeError,
				"2006": BadRequest,
				"2007": BadRequest,
				"2008": BadRequest,
				"2009": BadSymbol,
				"2010": AuthenticationError,
				"2011": AuthenticationError,
				"2012": BadRequest,
				"2013": InvalidOrder,
				"2015": OperationRejected,
				"2016": BadRequest,
				"2017": BadRequest,
				"2018": BadRequest,
				"2020": PermissionDenied,
				"2021": OperationRejected,
				"2029": InvalidNonce,
				"2035": InvalidNonce,
				"3001": InsufficientFunds,
				"3002": OrderNotFound,
				"3003": PermissionDenied,
				"3004": InsufficientFunds,
				"3005": InsufficientFunds,
				"3006": InsufficientFunds,
				"3007": DuplicateOrderId,
				"3031": BadRequest,
				"3032": BadRequest,
				"3033": PermissionDenied,
				"3034": RateLimitExceeded,
				"3035": RateLimitExceeded,
				"3047": OperationRejected,
				"3048": OperationRejected,
				"3049": OperationRejected,
				"3051": InsufficientFunds,
				"3052": InsufficientFunds,
				"3063": BadRequest,
				"3064": OrderNotFillable,
				"3065": MarketClosed,
				"3066": ExchangeError,
				"3067": MarketClosed,
				"6007": InvalidOrder,
				"6011": InvalidOrder,
				"6012": InvalidOrder,
				"6013": InvalidOrder,
				"8301": ExchangeError,
				"8305": ExchangeError,
				"8306": ExchangeError,
				"8307": ExchangeError,
				"8310": InvalidAddress,
				"8311": BadRequest,
				"8313": BadRequest,
				"8315": OperationRejected,
				"8316": OperationRejected,
				"8317": OperationRejected,
				"8318": NotSupported,
				"8319": NotSupported,
				"8320": InvalidAddress,
				"8322": BadRequest,
				"8327": AuthenticationError,
				"8329": ExchangeError,
				"8331": InvalidAddress,
				"8332": BadRequest,
				"8333": BadRequest,
				"8334": BadRequest,
				"8335": InvalidAddress,
				"8336": InvalidAddress,
				"8399": ExchangeError,
			},
			"broad": map[string]interface{}{
				"HttpInvalidParameterException": BadRequest,
				"UNAUTHORIZED_COMMAND":          AuthenticationError,
				"QUERY_FILTER_ERROR":            BadRequest,
				"INVALID_SYMBOL":                BadSymbol,
			},
		},
	})
}

/**
 * @method
 * @name bullish#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#tag--time
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func (this *BullishCore) FetchTime(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		response := (<-this.PublicGetV1Time(params))
		PanicOnError(response)

		//
		//     {
		//         "datetime": "2025-05-05T20:05:50.999Z",
		//         "timestamp": 1746475550999
		//     }
		//
		ch <- this.SafeInteger(response, "timestamp")
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bullish#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#get-/v1/assets
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func (this *BullishCore) FetchCurrencies(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		response := (<-this.PublicGetV1Assets(params))
		PanicOnError(response)
		//
		//     [
		//         {
		//             "assetId": "72",
		//             "symbol": "BTT1M",
		//             "name": "BitTorrent (millions)",
		//             "precision": "5",
		//             "minBalanceInterest": "0.00000",
		//             "apr": "10.00",
		//             "minFee": "0.00000",
		//             "maxBorrow": "0.00000",
		//             "totalOfferedLoanQuantity": "0.00000",
		//             "loanBorrowedQuantity": "0.00000",
		//             "collateralBands":
		//                 [
		//                     {
		//                         "collateralPercentage": "90.00",
		//                         "bandLimitUSD": "100000.0000"
		//                     },
		//                     {
		//                         "collateralPercentage": "68.00",
		//                         "bandLimitUSD": "300000.0000"
		//                     },
		//                     {
		//                         "collateralPercentage": "25.00",
		//                         "bandLimitUSD": "600000.0000"
		//                     }
		//                 ],
		//             "underlyingAsset":
		//                 {
		//                     "symbol": "BTT1M",
		//                     "assetId": "72",
		//                     "bpmMinReturnStart": "0.9200",
		//                     "bpmMinReturnEnd": "0.9300",
		//                     "bpmMaxReturnStart": "1.0800",
		//                     "bpmMaxReturnEnd": "1.0800",
		//                     "marketRiskFloorPctStart": "2.60",
		//                     "marketRiskFloorPctEnd": "2.50",
		//                     "bpmTransitionDateTimeStart": "2025-05-05T08:00:00.000Z",
		//                     "bpmTransitionDateTimeEnd": "2025-05-08T08:00:00.000Z"
		//                 }
		//         }, ...
		//     ]
		//
		var result interface{} = map[string]interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
			var currency interface{} = GetValue(response, i)
			var id interface{} = this.SafeString(currency, "symbol")
			var code interface{} = this.SafeCurrencyCode(id)
			var name interface{} = this.SafeString(currency, "name")
			var precision interface{} = this.SafeString(currency, "precision")
			AddElementToObject(result, code, map[string]interface{}{
				"id":        id,
				"code":      code,
				"name":      name,
				"active":    nil,
				"deposit":   nil,
				"withdraw":  nil,
				"fee":       this.SafeNumber(currency, "minFee"),
				"precision": this.ParseNumber(this.ParsePrecision(precision)),
				"limits": map[string]interface{}{
					"amount": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
					"withdraw": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
				},
				"networks": map[string]interface{}{},
				"type":     "crypto",
				"info":     currency,
			})
		}

		ch <- result
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bullish#fetchMarkets
 * @description retrieves data on all markets for ace
 * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#get-/v1/markets
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func (this *BullishCore) FetchMarkets(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		if IsTrue(GetValue(this.Options, "adjustForTimeDifference")) {

			retRes55212 := (<-this.LoadTimeDifference())
			PanicOnError(retRes55212)
		}

		response := (<-this.PublicGetV1Markets(params))
		PanicOnError(response)

		ch <- this.ParseMarkets(response)
		return nil

	}()
	return ch
}
func (this *BullishCore) ParseMarket(market interface{}) interface{} {
	//
	//     {
	//         "marketId": "20069",
	//         "symbol": "BTC-USDC-20250516",
	//         "quoteAssetId": "5",
	//         "baseAssetId": "1",
	//         "quoteSymbol": "USDC",
	//         "baseSymbol": "BTC",
	//         "quotePrecision": "4",
	//         "basePrecision": "8",
	//         "pricePrecision": "4",
	//         "quantityPrecision": "8",
	//         "costPrecision": "4",
	//         "minQuantityLimit": "0.00050000",
	//         "maxQuantityLimit": "200.00000000",
	//         "maxPriceLimit": null,
	//         "minPriceLimit": null,
	//         "maxCostLimit": null,
	//         "minCostLimit": null,
	//         "timeZone": "Etc/UTC",
	//         "tickSize": "0.1000",
	//         "liquidityTickSize": "100.0000",
	//         "liquidityPrecision": "4",
	//         "makerFee": "0",
	//         "takerFee": "2",
	//         "roundingCorrectionFactor": "0.00000100",
	//         "makerMinLiquidityAddition": "1000000",
	//         "orderTypes":
	//             [
	//                 "LMT",
	//                 "MKT",
	//                 "STOP_LIMIT",
	//                 "POST_ONLY"
	//             ],
	//         "spotTradingEnabled": true,
	//         "marginTradingEnabled": true,
	//         "marketEnabled": true,
	//         "createOrderEnabled": true,
	//         "cancelOrderEnabled": true,
	//         "liquidityInvestEnabled": true,
	//         "liquidityWithdrawEnabled": true,
	//         "feeTiers":
	//             [
	//                 {
	//                     "feeTierId": "1",
	//                     "staticSpreadFee": "0.00000000",
	//                     "isDislocationEnabled": false
	//                 },
	//                 {
	//                     "feeTierId": "10",
	//                     "staticSpreadFee": "0.00100000",
	//                     "isDislocationEnabled": true
	//                 },
	//                 {
	//                     "feeTierId": "11",
	//                     "staticSpreadFee": "0.00150000",
	//                     "isDislocationEnabled": false
	//                 },
	//                 {
	//                     "feeTierId": "12",
	//                     "staticSpreadFee": "0.00150000",
	//                     "isDislocationEnabled": true
	//                 },
	//                 {
	//                     "feeTierId": "13",
	//                     "staticSpreadFee": "0.00300000",
	//                     "isDislocationEnabled": false
	//                 },
	//                 {
	//                     "feeTierId": "14",
	//                     "staticSpreadFee": "0.00300000",
	//                     "isDislocationEnabled": true
	//                 },
	//                 {
	//                     "feeTierId": "15",
	//                     "staticSpreadFee": "0.00500000",
	//                     "isDislocationEnabled": false
	//                 },
	//                 {
	//                     "feeTierId": "16",
	//                     "staticSpreadFee": "0.00500000",
	//                     "isDislocationEnabled": true
	//                 },
	//                 {
	//                     "feeTierId": "17",
	//                     "staticSpreadFee": "0.01000000",
	//                     "isDislocationEnabled": false
	//                 },
	//                 {
	//                     "feeTierId": "18",
	//                     "staticSpreadFee": "0.01000000",
	//                     "isDislocationEnabled": true
	//                 },
	//                 {
	//                     "feeTierId": "19",
	//                     "staticSpreadFee": "0.01500000",
	//                     "isDislocationEnabled": false
	//                 },
	//                 {
	//                     "feeTierId": "2",
	//                     "staticSpreadFee": "0.00000000",
	//                     "isDislocationEnabled": true
	//                 },
	//                 {
	//                     "feeTierId": "20",
	//                     "staticSpreadFee": "0.01500000",
	//                     "isDislocationEnabled": true
	//                 },
	//                 {
	//                     "feeTierId": "21",
	//                     "staticSpreadFee": "0.02000000",
	//                     "isDislocationEnabled": false
	//                 },
	//                 {
	//                     "feeTierId": "22",
	//                     "staticSpreadFee": "0.02000000",
	//                     "isDislocationEnabled": true
	//                 },
	//                 {
	//                     "feeTierId": "3",
	//                     "staticSpreadFee": "0.00010000",
	//                     "isDislocationEnabled": false
	//                 },
	//                 {
	//                     "feeTierId": "4",
	//                     "staticSpreadFee": "0.00010000",
	//                     "isDislocationEnabled": true
	//                 },
	//                 {
	//                     "feeTierId": "5",
	//                     "staticSpreadFee": "0.00020000",
	//                     "isDislocationEnabled": false
	//                 },
	//                 {
	//                     "feeTierId": "6",
	//                     "staticSpreadFee": "0.00020000",
	//                     "isDislocationEnabled": true
	//                 },
	//                 {
	//                     "feeTierId": "7",
	//                     "staticSpreadFee": "0.00060000",
	//                     "isDislocationEnabled": false
	//                 },
	//                 {
	//                     "feeTierId": "8",
	//                     "staticSpreadFee": "0.00060000",
	//                     "isDislocationEnabled": true
	//                 },
	//                 {
	//                     "feeTierId": "9",
	//                     "staticSpreadFee": "0.00100000",
	//                     "isDislocationEnabled": false
	//                 }
	//             ],
	//         "marketType": "DATED_FUTURE",
	//         "contractMultiplier": "1",
	//         "settlementAssetSymbol": "USDC",
	//         "underlyingQuoteSymbol": "USDC",
	//         "underlyingBaseSymbol": "BTC",
	//         "openInterestLimitUSD": "100000000.0000",
	//         "concentrationRiskPercentage": "100.00",
	//         "concentrationRiskThresholdUSD": "30000000.0000",
	//         "expiryDatetime": "2025-05-16T08:00:00.000Z",
	//         "priceBuffer": "0.1",
	//         "feeGroupId": "4"
	//     }
	//
	// option
	//     {
	//         "marketId": "20997",
	//         "symbol": "BTC-USDC-20260130-160000-P",
	//         "quoteAssetId": "5",
	//         "baseAssetId": "1",
	//         "quoteSymbol": "USDC",
	//         "baseSymbol": "BTC",
	//         "quotePrecision": "4",
	//         "basePrecision": "8",
	//         "pricePrecision": "4",
	//         "quantityPrecision": "8",
	//         "costPrecision": "4",
	//         "minQuantityLimit": "0.00050000",
	//         "maxQuantityLimit": "200.00000000",
	//         "maxPriceLimit": null,
	//         "minPriceLimit": null,
	//         "maxCostLimit": null,
	//         "minCostLimit": null,
	//         "timeZone": "Etc/UTC",
	//         "tickSize": "10.0000",
	//         "makerFee": "0",
	//         "takerFee": "2",
	//         "roundingCorrectionFactor": "0.00000100",
	//         "makerMinLiquidityAddition": "-1",
	//         "orderTypes": [ "LMT", "MKT", "STOP_LIMIT", "POST_ONLY" ],
	//         "spotTradingEnabled": true,
	//         "marginTradingEnabled": true,
	//         "marketEnabled": true,
	//         "createOrderEnabled": true,
	//         "cancelOrderEnabled": true,
	//         "amendOrderEnabled": true,
	//         "marketType": "OPTION",
	//         "contractMultiplier": "1",
	//         "settlementAssetSymbol": "USDC",
	//         "underlyingQuoteSymbol": "USDC",
	//         "underlyingBaseSymbol": "BTC",
	//         "openInterestLimitUSD": "100000000.0000",
	//         "concentrationRiskPercentage": "100.00",
	//         "concentrationRiskThresholdUSD": "30000000.0000",
	//         "expiryDatetime": "2026-01-30T08:00:00.000Z",
	//         "priceBuffer": "0",
	//         "feeGroupId": "10",
	//         "optionStrikePrice": "160000.0000",
	//         "optionType": "PUT",
	//         "premiumCapRatio": "0.1000"
	//     }
	//
	var id interface{} = this.SafeString(market, "symbol")
	var baseId interface{} = this.SafeString(market, "baseSymbol")
	var quoteId interface{} = this.SafeString(market, "quoteSymbol")
	var base interface{} = this.SafeCurrencyCode(baseId)
	var quote interface{} = this.SafeCurrencyCode(quoteId)
	var symbol interface{} = Add(Add(base, "/"), quote)
	var basePrecision interface{} = this.SafeString(market, "basePrecision")
	var quotePrecision interface{} = this.SafeString(market, "quotePrecision")
	var amountPrecision interface{} = this.SafeString(market, "quantityPrecision")
	var pricePrecision interface{} = this.SafeString(market, "pricePrecision")
	var costPrecision interface{} = this.SafeString(market, "costPrecision")
	var minQuantityLimit interface{} = this.SafeString(market, "minQuantityLimit")
	var maxQuantityLimit interface{} = this.SafeString(market, "maxQuantityLimit")
	var minPriceLimit interface{} = this.SafeString(market, "minPriceLimit")
	var maxPriceLimit interface{} = this.SafeString(market, "maxPriceLimit")
	var minCostLimit interface{} = this.SafeString(market, "minCostLimit")
	var maxCostLimit interface{} = this.SafeString(market, "maxCostLimit")
	var settleId interface{} = this.SafeString(market, "settlementAssetSymbol")
	var settle interface{} = this.SafeCurrencyCode(settleId)
	var typeVar interface{} = this.ParseMarketType(this.SafeString(market, "marketType"), "spot")
	var spot interface{} = false
	var swap interface{} = false
	var future interface{} = false
	var option interface{} = false
	var contract interface{} = true
	var linear interface{} = nil
	var inverse interface{} = nil
	var expiryDatetime interface{} = nil
	var contractSize interface{} = nil
	var optionType interface{} = nil
	var strike interface{} = nil
	var margin interface{} = false
	if IsTrue(IsEqual(typeVar, "spot")) {
		spot = true
		contract = false
		margin = this.SafeBool(market, "marginTradingEnabled")
	} else {
		contractSize = this.SafeNumber(market, "contractMultiplier")
		symbol = Add(symbol, Add(":", settle))
		linear = IsEqual(settle, quote)
		inverse = !IsTrue(linear)
		if IsTrue(IsEqual(typeVar, "swap")) {
			swap = true
		} else {
			expiryDatetime = this.SafeString(market, "expiryDatetime")
			var idParts interface{} = Split(id, "-")
			var datePart interface{} = this.SafeString(idParts, 2)
			symbol = Add(symbol, Add("-", datePart))
			if IsTrue(IsEqual(typeVar, "future")) {
				future = true
			} else if IsTrue(IsEqual(typeVar, "option")) {
				option = true
				optionType = this.SafeStringLower(market, "optionType")
				strike = this.ParseToNumeric(this.SafeString(market, "optionStrikePrice"))
				symbol = Add(symbol, Add(Add(Add("-", this.NumberToString(strike)), "-"), this.SafeString(idParts, 4)))
			}
		}
	}
	return this.SafeMarketStructure(map[string]interface{}{
		"id":             id,
		"symbol":         symbol,
		"base":           base,
		"baseId":         baseId,
		"quote":          quote,
		"quoteId":        quoteId,
		"settle":         settle,
		"settleId":       settleId,
		"type":           typeVar,
		"spot":           spot,
		"margin":         margin,
		"swap":           swap,
		"future":         future,
		"option":         option,
		"contract":       contract,
		"linear":         linear,
		"inverse":        inverse,
		"taker":          GetValue(GetValue(this.Fees, "trading"), "taker"),
		"maker":          GetValue(GetValue(this.Fees, "trading"), "maker"),
		"contractSize":   contractSize,
		"expiry":         this.Parse8601(expiryDatetime),
		"expiryDatetime": expiryDatetime,
		"strike":         strike,
		"optionType":     optionType,
		"limits": map[string]interface{}{
			"amount": map[string]interface{}{
				"min": this.ParseNumber(minQuantityLimit),
				"max": this.ParseNumber(maxQuantityLimit),
			},
			"price": map[string]interface{}{
				"min": this.ParseNumber(minPriceLimit),
				"max": this.ParseNumber(maxPriceLimit),
			},
			"cost": map[string]interface{}{
				"min": this.ParseNumber(minCostLimit),
				"max": this.ParseNumber(maxCostLimit),
			},
			"leverage": map[string]interface{}{
				"min": nil,
				"max": nil,
			},
		},
		"precision": map[string]interface{}{
			"amount": this.ParseNumber(this.ParsePrecision(amountPrecision)),
			"price":  this.ParseNumber(this.ParsePrecision(pricePrecision)),
			"cost":   this.ParseNumber(this.ParsePrecision(costPrecision)),
			"base":   this.ParseNumber(this.ParsePrecision(basePrecision)),
			"quote":  this.ParseNumber(this.ParsePrecision(quotePrecision)),
		},
		"active":  this.SafeBool(market, "marketEnabled"),
		"created": nil,
		"info":    market,
	})
}
func (this *BullishCore) ParseMarketType(typeVar interface{}, optionalArgs ...interface{}) interface{} {
	defaultType := GetArg(optionalArgs, 0, nil)
	_ = defaultType
	var types interface{} = map[string]interface{}{
		"SPOT":         "spot",
		"PERPETUAL":    "swap",
		"DATED_FUTURE": "future",
		"OPTION":       "option",
	}
	return this.SafeString(types, typeVar, defaultType)
}

/**
 * @method
 * @name bullish#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#get-/v1/markets/-symbol-/orderbook/hybrid
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return (not used by bullish)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func (this *BullishCore) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		limit := GetArg(optionalArgs, 0, nil)
		_ = limit
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes9098 := (<-this.LoadMarkets())
		PanicOnError(retRes9098)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}

		response := (<-this.PublicGetV1MarketsSymbolOrderbookHybrid(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "bids": [
		//             {
		//                 "price": "1.00000000",
		//                 "priceLevelQuantity": "1.00000000"
		//             }
		//         ],
		//         "asks": [
		//             {
		//                 "price": "1.00000000",
		//                 "priceLevelQuantity": "1.00000000"
		//             }
		//         ],
		//         "datetime": "2021-05-20T01:01:01.000Z",
		//         "timestamp": "1621490985000",
		//         "sequenceNumber": 999
		//     }
		//
		var timestamp interface{} = this.SafeInteger(response, "timestamp")

		ch <- this.ParseOrderBook(response, symbol, timestamp, "bids", "asks", "price", "priceLevelQuantity")
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bullish#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#get-/v1/markets/-symbol-/trades
 * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#get-/v1/history/markets/-symbol-/trades
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch (max 100)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest trade to fetch
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func (this *BullishCore) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		since := GetArg(optionalArgs, 0, nil)
		_ = since
		limit := GetArg(optionalArgs, 1, nil)
		_ = limit
		params := GetArg(optionalArgs, 2, map[string]interface{}{})
		_ = params

		retRes9538 := (<-this.LoadMarkets())
		PanicOnError(retRes9538)
		var maxLimit interface{} = 100
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchFundingRateHistory", "paginate")
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {
			params = this.HandlePaginationParams("fetchTrades", since, params)

			retRes95919 := (<-this.FetchPaginatedCallDynamic("fetchTrades", symbol, since, limit, params, maxLimit))
			PanicOnError(retRes95919)
			ch <- retRes95919
			return nil
		}
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		params = this.HandleSinceAndUntil(since, params)
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "_pageSize", this.GetClosestLimit(limit))
		}

		response := (<-this.PublicGetV1HistoryMarketsSymbolTrades(this.Extend(request, params)))
		PanicOnError(response)

		//
		//     [
		//         {
		//             "tradeId": "100178000000367159",
		//             "symbol": "BTCUSDC",
		//             "price": "103891.8977",
		//             "quantity": "0.00029411",
		//             "quoteAmount": "30.5556",
		//             "side": "BUY",
		//             "isTaker": true,
		//             "createdAtTimestamp": "1747768055826",
		//             "createdAtDatetime": "2025-05-20T19:07:35.826Z"
		//         }, ...
		//     ]
		//
		ch <- this.ParseTrades(response, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bullish#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#get-/v1/history/trades
 * @param {string} [symbol] unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch trades for
 * @param {string} [params.orderId] the order id to fetch trades for
 * @param {string} [params.clientOrderId] the client order id to fetch trades for
 * @param {string} [params.tradingAccountId] the trading account id to fetch trades for
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func (this *BullishCore) FetchMyTrades(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes10048 := (<-promiseAll([]interface{}{this.LoadMarkets(), this.HandleToken()}))
		PanicOnError(retRes10048)

		tradingAccountId := (<-this.LoadAccount(params))
		PanicOnError(tradingAccountId)
		var request interface{} = map[string]interface{}{
			"tradingAccountId": tradingAccountId,
		}
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			AddElementToObject(request, "symbol", GetValue(market, "id"))
		}
		var clientOrderId interface{} = this.SafeString(params, "clientOrderId")
		var response interface{} = nil
		if IsTrue(!IsEqual(clientOrderId, nil)) {

			response = (<-this.PrivateGetV1TradesClientOrderIdClientOrderId(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			var paginate interface{} = false
			paginateparamsVariable := this.HandleOptionAndParams(params, "fetchMyTrades", "paginate")
			paginate = GetValue(paginateparamsVariable, 0)
			params = GetValue(paginateparamsVariable, 1)
			if IsTrue(paginate) {
				params = this.HandlePaginationParams("fetchMyTrades", since, params)

				retRes102323 := (<-this.FetchPaginatedCallDynamic("fetchMyTrades", symbol, since, limit, params, 100))
				PanicOnError(retRes102323)
				ch <- retRes102323
				return nil
			}
			params = this.HandleSinceAndUntil(since, params)
			if IsTrue(!IsEqual(limit, nil)) {
				AddElementToObject(request, "_pageSize", this.GetClosestLimit(limit))
			}
			//
			//     [
			//         {
			//             "baseFee": "0.00000000",
			//             "createdAtDatetime": "2025-05-18T15:57:28.132Z",
			//             "createdAtTimestamp": "1747583848132",
			//             "handle": null,
			//             "isTaker": true,
			//             "orderId": "844242293909618689",
			//             "price": "103942.7048",
			//             "publishedAtTimestamp": "1747769786131",
			//             "quantity": "1.00000000",
			//             "quoteAmount": "103942.7048",
			//             "quoteFee": "0.0000",
			//             "side": "BUY",
			//             "symbol": "BTCUSDC",
			//             "tradeId": "100178000000288892"
			//         }, ...
			//     ]
			//

			response = (<-this.PrivateGetV1HistoryTrades(this.Extend(request, params)))
			PanicOnError(response)
		}

		ch <- this.ParseTrades(response, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bullish#fetchOrderTrades
 * @description fetch all the trades made from a single order
 * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#get-/v1/history/trades
 * @param {string} id order id
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.clientOrderId] the client order id to fetch trades for
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func (this *BullishCore) FetchOrderTrades(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes10688 := (<-this.LoadMarkets())
		PanicOnError(retRes10688)
		var clientOrderId interface{} = this.SafeString(params, "clientOrderId")
		if IsTrue(IsEqual(clientOrderId, nil)) {
			params = this.Extend(map[string]interface{}{
				"orderId": id,
			}, params)
		}

		retRes107315 := (<-this.FetchMyTrades(symbol, since, limit, params))
		PanicOnError(retRes107315)
		ch <- retRes107315
		return nil

	}()
	return ch
}
func (this *BullishCore) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{} {
	//
	// fetchTrades
	//     [
	//         {
	//             "tradeId": "100178000000367159",
	//             "symbol": "BTCUSDC",
	//             "price": "103891.8977",
	//             "quantity": "0.00029411",
	//             "quoteAmount": "30.5556",
	//             "side": "BUY",
	//             "isTaker": true,
	//             "createdAtTimestamp": "1747768055826",
	//             "createdAtDatetime": "2025-05-20T19:07:35.826Z"
	//         }, ...
	//     ]
	//
	//     [
	//         {
	//             "tradeId": "100020000000000060",
	//             "symbol": "BTCUSDC",
	//             "price": "1.00000000",
	//             "quantity": "1.00000000",
	//             "side": "BUY",
	//             "isTaker": true,
	//             "createdAtDatetime": "2021-05-20T01:01:01.000Z",
	//             "createdAtTimestamp": "1621490985000"
	//         }
	//     ]
	//
	// fetchMyTrades
	//     [
	//         {
	//             "baseFee": "0.00000000",
	//             "createdAtDatetime": "2025-05-18T15:57:28.132Z",
	//             "createdAtTimestamp": "1747583848132",
	//             "handle": null,
	//             "isTaker": true,
	//             "orderId": "844242293909618689",
	//             "price": "103942.7048",
	//             "publishedAtTimestamp": "1747769786131",
	//             "quantity": "1.00000000",
	//             "quoteAmount": "103942.7048",
	//             "quoteFee": "0.0000",
	//             "side": "BUY",
	//             "symbol": "BTCUSDC",
	//             "tradeId": "100178000000288892"
	//         }, ...
	//     ]
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(trade, "symbol")
	market = this.SafeMarket(marketId, market)
	var symbol interface{} = GetValue(market, "symbol")
	var timestamp interface{} = this.SafeInteger(trade, "createdAtTimestamp")
	var price interface{} = this.SafeString(trade, "price")
	var amount interface{} = this.SafeString(trade, "quantity")
	var side interface{} = this.SafeStringLower(trade, "side")
	var isTaker interface{} = this.SafeBool(trade, "isTaker")
	var currency interface{} = GetValue(market, "quote")
	var code interface{} = this.SafeCurrencyCode(currency)
	var feeCost interface{} = this.SafeNumber(trade, "quoteFee")
	var fee interface{} = nil
	if IsTrue(!IsEqual(feeCost, nil)) {
		fee = map[string]interface{}{
			"currency": code,
			"cost":     feeCost,
		}
	}
	var takerOrMaker interface{} = nil
	if IsTrue(isTaker) {
		takerOrMaker = "taker"
	} else {
		takerOrMaker = "maker"
	}
	var orderId interface{} = this.SafeString(trade, "orderId")
	return this.SafeTrade(map[string]interface{}{
		"info":         trade,
		"timestamp":    timestamp,
		"datetime":     this.Iso8601(timestamp),
		"symbol":       symbol,
		"id":           this.SafeString(trade, "tradeId"),
		"order":        orderId,
		"type":         nil,
		"takerOrMaker": takerOrMaker,
		"side":         side,
		"price":        price,
		"amount":       amount,
		"cost":         nil,
		"fee":          fee,
	}, market)
}

/**
 * @method
 * @name bullish#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#get-/v1/markets/-symbol-/tick
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func (this *BullishCore) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes11758 := (<-this.LoadMarkets())
		PanicOnError(retRes11758)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}

		response := (<-this.PublicGetV1MarketsSymbolTick(this.Extend(request, params)))
		PanicOnError(response)

		//
		//     {
		//         "createdAtDatetime": "2021-05-20T01:01:01.000Z",
		//         "createdAtTimestamp": "1621490985000",
		//         "high": "1.00000000",
		//         "low": "1.00000000",
		//         "bestBid": "1.00000000",
		//         "bidVolume": "1.00000000",
		//         "bestAsk": "1.00000000",
		//         "askVolume": "1.00000000",
		//         "vwap": "1.00000000",
		//         "open": "1.00000000",
		//         "close": "1.00000000",
		//         "last": "1.00000000",
		//         "change": "1.00000000",
		//         "percentage": "1.00000000",
		//         "average": "1.00000000",
		//         "baseVolume": "1.00000000",
		//         "quoteVolume": "1.00000000",
		//         "bancorPrice": "1.00000000",
		//         "markPrice": "19999.00",
		//         "fundingRate": "0.01",
		//         "openInterest": "100000.32452",
		//         "lastTradeDatetime": "2021-05-20T01:01:01.000Z",
		//         "lastTradeTimestamp": "1621490985000",
		//         "lastTradeQuantity": "1.00000000",
		//         "ammData": [
		//             {
		//                 "feeTierId": "1",
		//                 "bidSpreadFee": "0.00040000",
		//                 "askSpreadFee": "0.00040000",
		//                 "baseReservesQuantity": "245.56257825",
		//                 "quoteReservesQuantity": "3424383.3629",
		//                 "currentPrice": "16856.0000"
		//             }
		//         ]
		//     }
		//
		ch <- this.ParseTicker(response, market)
		return nil

	}()
	return ch
}
func (this *BullishCore) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "createdAtDatetime": "2021-05-20T01:01:01.000Z",
	//         "createdAtTimestamp": "1621490985000",
	//         "high": "1.00000000",
	//         "low": "1.00000000",
	//         "bestBid": "1.00000000",
	//         "bidVolume": "1.00000000",
	//         "bestAsk": "1.00000000",
	//         "askVolume": "1.00000000",
	//         "vwap": "1.00000000",
	//         "open": "1.00000000",
	//         "close": "1.00000000",
	//         "last": "1.00000000",
	//         "change": "1.00000000",
	//         "percentage": "1.00000000",
	//         "average": "1.00000000",
	//         "baseVolume": "1.00000000",
	//         "quoteVolume": "1.00000000",
	//         "bancorPrice": "1.00000000",
	//         "markPrice": "19999.00",
	//         "fundingRate": "0.01",
	//         "openInterest": "100000.32452",
	//         "lastTradeDatetime": "2021-05-20T01:01:01.000Z",
	//         "lastTradeTimestamp": "1621490985000",
	//         "lastTradeQuantity": "1.00000000",
	//         "ammData": [
	//             {
	//                 "feeTierId": "1",
	//                 "bidSpreadFee": "0.00040000",
	//                 "askSpreadFee": "0.00040000",
	//                 "baseReservesQuantity": "245.56257825",
	//                 "quoteReservesQuantity": "3424383.3629",
	//                 "currentPrice": "16856.0000"
	//             }
	//         ]
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(ticker, "symbol")
	market = this.SafeMarket(marketId, market)
	var timestamp interface{} = this.SafeInteger(ticker, "createdAtTimestamp")
	return this.SafeTicker(map[string]interface{}{
		"symbol":        GetValue(market, "symbol"),
		"timestamp":     timestamp,
		"datetime":      this.Iso8601(timestamp),
		"high":          this.SafeString(ticker, "high"),
		"low":           this.SafeString(ticker, "low"),
		"bid":           this.SafeString2(ticker, "bid", "bestBid"),
		"bidVolume":     this.SafeString(ticker, "bidVolume"),
		"ask":           this.SafeString2(ticker, "ask", "bestAsk"),
		"askVolume":     this.SafeString(ticker, "askVolume"),
		"vwap":          this.SafeString(ticker, "vwap"),
		"open":          this.SafeString(ticker, "open"),
		"close":         this.SafeString(ticker, "close"),
		"last":          this.SafeString(ticker, "last"),
		"previousClose": nil,
		"change":        this.SafeString(ticker, "change"),
		"percentage":    this.SafeString(ticker, "percentage"),
		"average":       this.SafeString(ticker, "average"),
		"baseVolume":    this.SafeString(ticker, "baseVolume"),
		"quoteVolume":   this.SafeString(ticker, "quoteVolume"),
		"markPrice":     this.SafeString(ticker, "markPrice"),
		"info":          ticker,
	}, market)
}
func (this *BullishCore) SafeDeterministicCall(method interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		timeframe := GetArg(optionalArgs, 3, nil)
		_ = timeframe
		params := GetArg(optionalArgs, 4, map[string]interface{}{})
		_ = params
		var maxRetries interface{} = nil
		maxRetriesparamsVariable := this.HandleOptionAndParams(params, method, "maxRetries", 3)
		maxRetries = GetValue(maxRetriesparamsVariable, 0)
		params = GetValue(maxRetriesparamsVariable, 1)
		var errors interface{} = 0
		params = this.Omit(params, "until")
		// the exchange returns the most recent data, so we do not need to pass until into paginated calls
		// the correct util value will be calculated inside of the method
		for IsLessThanOrEqual(errors, maxRetries) {

			{
				func(this *BullishCore) (ret_ interface{}) {
					defer func() {
						if e := recover(); e != nil {
							if e == "break" {
								return
							}
							ret_ = func(this *BullishCore) interface{} {
								// catch block:
								if IsTrue(IsInstance(e, RateLimitExceeded)) {
									panic(e)
								}
								errors = Add(errors, 1)
								if IsTrue(IsGreaterThan(errors, maxRetries)) {
									panic(e)
								}
								return nil
							}(this)
						}
					}()
					// try block:
					if IsTrue(IsTrue(timeframe) && IsTrue(!IsEqual(method, "fetchFundingRateHistory"))) {

						retRes129927 := (<-this.CallDynamically(method, symbol, timeframe, since, limit, params))
						PanicOnError(retRes129927)
						ch <- retRes129927
						return nil
					} else {

						retRes130127 := (<-this.CallDynamically(method, symbol, since, limit, params))
						PanicOnError(retRes130127)
						ch <- retRes130127
						return nil
					}

				}(this)

			}
		}

		ch <- []interface{}{}
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bullish#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#get-/v1/markets/-symbol-/candle
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch (max 100)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest entry
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func (this *BullishCore) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		timeframe := GetArg(optionalArgs, 0, "1m")
		_ = timeframe
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes13318 := (<-this.LoadMarkets())
		PanicOnError(retRes13318)
		var market interface{} = this.Market(symbol)
		var maxLimit interface{} = 100
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchOHLCV", "paginate")
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {

			retRes133719 := (<-this.FetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, params, maxLimit))
			PanicOnError(retRes133719)
			ch <- retRes133719
			return nil
		}
		var request interface{} = map[string]interface{}{
			"symbol":     GetValue(market, "id"),
			"timeBucket": this.SafeString(this.Timeframes, timeframe, timeframe),
			"_pageSize":  maxLimit,
		}
		requestparamsVariable := this.HandleUntilOption("createdAtDatetime[lte]", request, params)
		request = GetValue(requestparamsVariable, 0)
		params = GetValue(requestparamsVariable, 1)
		var until interface{} = this.SafeInteger(request, "createdAtDatetime[lte]")
		var duration interface{} = this.ParseTimeframe(timeframe)
		var maxDelta interface{} = Multiply(Multiply(1000, duration), maxLimit)
		var startTime interface{} = since
		// both of since and until are required
		if IsTrue(IsTrue(IsEqual(startTime, nil)) && IsTrue(IsEqual(until, nil))) {
			until = this.Milliseconds()
			startTime = Subtract(until, maxDelta)
		} else if IsTrue(IsEqual(startTime, nil)) {
			startTime = Subtract(until, maxDelta)
		} else if IsTrue(IsEqual(until, nil)) {
			until = this.Sum(startTime, maxDelta)
		}
		AddElementToObject(request, "createdAtDatetime[gte]", this.Iso8601(startTime))
		AddElementToObject(request, "createdAtDatetime[lte]", this.Iso8601(until))

		response := (<-this.PublicGetV1MarketsSymbolCandle(this.Extend(request, params)))
		PanicOnError(response)

		//
		//     [
		//         {
		//             "open": "100846.7490",
		//             "high": "100972.4001",
		//             "low": "100840.8129",
		//             "close": "100972.2602",
		//             "volume": "30.56064890",
		//             "createdAtTimestamp": "1746720540000",
		//             "createdAtDatetime": "2025-05-08T16:09:00.000Z",
		//             "publishedAtTimestamp": "1746720636007"
		//         }, ...
		//     ]
		//
		ch <- this.ParseOHLCVs(response, market, timeframe, since, limit)
		return nil

	}()
	return ch
}
func (this *BullishCore) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{} {
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	return []interface{}{this.SafeInteger(ohlcv, "createdAtTimestamp"), this.SafeNumber(ohlcv, "open"), this.SafeNumber(ohlcv, "high"), this.SafeNumber(ohlcv, "low"), this.SafeNumber(ohlcv, "close"), this.SafeNumber(ohlcv, "volume")}
}

/**
 * @method
 * @name bullish#fetchFundingRateHistory
 * @description fetches historical funding rate prices
 * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#get-/v1/history/markets/-symbol-/funding-rate
 * @param {string} symbol unified symbol of the market to fetch the funding rate history for
 * @param {int} [since] not sent to exchange api, exchange api always returns the most recent data, only used to filter exchange response
 * @param {int} [limit] the maximum amount of funding rate structures to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
 */
func (this *BullishCore) FetchFundingRateHistory(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchFundingRateHistory() requires a symbol argument")))
		}

		retRes14048 := (<-this.LoadMarkets())
		PanicOnError(retRes14048)
		var maxLimit interface{} = 100
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchFundingRateHistory", "paginate")
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {
			params = this.HandlePaginationParams("fetchFundingRateHistory", since, params)

			retRes141019 := (<-this.FetchPaginatedCallDynamic("fetchFundingRateHistory", symbol, since, limit, params, maxLimit))
			PanicOnError(retRes141019)
			ch <- retRes141019
			return nil
		}
		var market interface{} = this.Market(symbol)
		if !IsTrue(GetValue(market, "swap")) {
			panic(BadRequest(Add(this.Id, " fetchFundingRateHistory() supports swap markets only")))
		}
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "_pageSize", this.GetClosestLimit(limit))
		}
		params = this.HandleSinceAndUntil(since, params, "updatedAtDatetime[gte]", "updatedAtDatetime[lte]")

		response := (<-this.PublicGetV1HistoryMarketsSymbolFundingRate(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     [
		//         {
		//             "fundingRate": "0.00125",
		//             "updatedAtDatetime": "2025-05-18T09:06:04.074Z"
		//         },
		//         {
		//             "fundingRate": "0.00125",
		//             "updatedAtDatetime": "2025-05-18T08:59:59.033Z"
		//         }, ...
		//     ]
		//
		var rates interface{} = []interface{}{}
		var result interface{} = this.ToArray(response)
		for i := 0; IsLessThan(i, GetArrayLength(result)); i++ {
			var entry interface{} = GetValue(result, i)
			var datetime interface{} = this.SafeString(entry, "updatedAtDatetime")
			AppendToArray(&rates, map[string]interface{}{
				"info":        entry,
				"symbol":      symbol,
				"fundingRate": this.SafeNumber(entry, "fundingRate"),
				"timestamp":   this.Parse8601(datetime),
				"datetime":    datetime,
			})
		}
		var sorted interface{} = this.SortBy(rates, "timestamp")

		ch <- this.FilterBySymbolSinceLimit(sorted, GetValue(market, "symbol"), since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bullish#fetchOrders
 * @description fetches information on multiple orders made by the user
 * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#tag--orders
 * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#tag--history
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve (5, 25, 50, 100, default is 25)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest order to fetch
 * @param {string} [params.tradingAccountId] the trading account id (mandatory parameter)
 * @param {string} [params.orderId] the id of the order to fetch for
 * @param {string} [params.clientOrderId] the client id of the order to fetch for
 * @param {string} [params.status] filter by order status, 'OPEN', 'CANCELLED', 'CLOSED', 'REJECTED'
 * @param {bool} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *BullishCore) FetchOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes14728 := (<-promiseAll([]interface{}{this.LoadMarkets(), this.HandleToken()}))
		PanicOnError(retRes14728)

		tradingAccountId := (<-this.LoadAccount(params))
		PanicOnError(tradingAccountId)
		var paginate interface{} = this.SafeBool(params, "paginate", false)
		if IsTrue(paginate) {
			params = this.HandlePaginationParams("fetchOrders", since, params)

			retRes147719 := (<-this.FetchPaginatedCallDynamic("fetchOrders", symbol, since, limit, params, 100))
			PanicOnError(retRes147719)
			ch <- retRes147719
			return nil
		}
		var market interface{} = nil
		var request interface{} = map[string]interface{}{
			"tradingAccountId": tradingAccountId,
		}
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			AddElementToObject(request, "symbol", GetValue(market, "id"))
		}
		params = this.HandleSinceAndUntil(since, params)
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "_pageSize", this.GetClosestLimit(limit))
		}
		var method interface{} = "privateGetV2HistoryOrders"
		methodparamsVariable := this.HandleOptionAndParams(params, "fetchOrders", "method", method)
		method = GetValue(methodparamsVariable, 0)
		params = GetValue(methodparamsVariable, 1)
		var response interface{} = nil
		if IsTrue(IsEqual(method, "privateGetV2Orders")) {
			//
			//     [
			//         {
			//             "clientOrderId": "187",
			//             "orderId": "297735387747975680",
			//             "symbol": "BTCUSDC",
			//             "price": "1.00000000",
			//             "averageFillPrice": "1.00000000",
			//             "stopPrice": "1.00000000",
			//             "allowBorrow": false,
			//             "quantity": "1.00000000",
			//             "quantityFilled": "1.00000000",
			//             "quoteAmount": "1.00000000",
			//             "baseFee": "0.00100000",
			//             "quoteFee": "0.0010",
			//             "borrowedBaseQuantity": "1.00000000",
			//             "borrowedQuoteQuantity": "1.00000000",
			//             "isLiquidation": false,
			//             "side": "BUY",
			//             "type": "LMT",
			//             "timeInForce": "GTC",
			//             "status": "OPEN",
			//             "statusReason": "User cancelled",
			//             "statusReasonCode": "1002",
			//             "createdAtDatetime": "2021-05-20T01:01:01.000Z",
			//             "createdAtTimestamp": "1621490985000",
			//         }
			//     ]
			//

			response = (<-this.PrivateGetV2Orders(this.Extend(request, params)))
			PanicOnError(response)
		} else if IsTrue(IsEqual(method, "privateGetV2HistoryOrders")) {

			response = (<-this.PrivateGetV2HistoryOrders(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			panic(BadRequest(Add(this.Id, " fetchOrders() method parameter must be either \"privateGetV2Orders\" or \"privateGetV2HistoryOrders\"")))
		}

		ch <- this.ParseOrders(response, market, since, limit)
		return nil

	}()
	return ch
}
func (this *BullishCore) HandlePaginationParams(method interface{}, optionalArgs ...interface{}) interface{} {
	since := GetArg(optionalArgs, 0, nil)
	_ = since
	params := GetArg(optionalArgs, 1, map[string]interface{}{})
	_ = params
	var ninetyDays interface{} = Multiply(Multiply(Multiply(Multiply(90, 24), 60), 60), 1000)
	var now interface{} = this.Milliseconds()
	var allowedSince interface{} = Subtract(now, ninetyDays)
	if IsTrue(IsTrue((!IsEqual(since, nil))) && IsTrue((IsLessThan(since, allowedSince)))) {
		panic(BadRequest(Add(Add(Add(this.Id, " "), method), "() only allows fetching entries up to 90 days in the past")))
	}
	params = this.Omit(params, "paginate")
	params = this.Extend(params, map[string]interface{}{
		"paginationDirection": "backward",
	})
	var until interface{} = this.SafeInteger(params, "until")
	if IsTrue(IsEqual(until, nil)) {
		params = this.Extend(params, map[string]interface{}{
			"until": now,
		})
	}
	return params
}
func (this *BullishCore) HandleSinceAndUntil(optionalArgs ...interface{}) interface{} {
	since := GetArg(optionalArgs, 0, nil)
	_ = since
	params := GetArg(optionalArgs, 1, map[string]interface{}{})
	_ = params
	sinceKey := GetArg(optionalArgs, 2, "createdAtDatetime[gte]")
	_ = sinceKey
	untilKey := GetArg(optionalArgs, 3, "createdAtDatetime[lte]")
	_ = untilKey
	var until interface{} = this.SafeInteger(params, "until")
	if IsTrue(IsTrue((!IsEqual(since, nil))) || IsTrue((!IsEqual(until, nil)))) {
		var timeDelta interface{} = Multiply(Multiply(Multiply(Multiply(7, 24), 60), 60), 1000) // 7 days
		if IsTrue(IsEqual(since, nil)) {
			since = Subtract(until, timeDelta)
			params = this.Omit(params, "until")
		} else if IsTrue(IsEqual(until, nil)) {
			until = this.Sum(since, timeDelta)
			var now interface{} = this.Milliseconds()
			if IsTrue(IsGreaterThan(until, now)) {
				until = now
			}
		}
		var sinceDate interface{} = this.Iso8601(since)
		var untilDate interface{} = this.Iso8601(until)
		AddElementToObject(params, sinceKey, sinceDate)
		AddElementToObject(params, untilKey, untilDate)
	}
	return params
}
func (this *BullishCore) GetClosestLimit(limit interface{}) interface{} {
	var pageSize interface{} = 5
	if IsTrue(IsTrue((IsGreaterThan(limit, 5))) && IsTrue((IsLessThan(limit, 26)))) {
		pageSize = 25
	} else if IsTrue(IsTrue((IsGreaterThan(limit, 25))) && IsTrue((IsLessThan(limit, 51)))) {
		pageSize = 50
	} else if IsTrue(IsGreaterThan(limit, 50)) {
		pageSize = 100
	}
	return pageSize
}

/**
 * @method
 * @name bullish#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#tag--history
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} params.tradingAccountId the trading account id (mandatory parameter)
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *BullishCore) FetchOpenOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		var request interface{} = map[string]interface{}{
			"status": "OPEN",
		}

		retRes159915 := (<-this.FetchOrders(symbol, since, limit, this.Extend(request, params)))
		PanicOnError(retRes159915)
		ch <- retRes159915
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bullish#fetchCanceledOrders
 * @description fetches information on multiple canceled orders made by the user
 * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#tag--orders
 * @param {string} symbol unified market symbol of the canceled orders
 * @param {int} [since] timestamp in ms of the earliest order
 * @param {int} [limit] the max number of canceled orders to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.tradingAccountId] the trading account id (mandatory parameter)
 * @returns {object} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *BullishCore) FetchCanceledOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		var request interface{} = map[string]interface{}{
			"status": "CANCELLED",
			"method": "privateGetV2Orders",
		}

		retRes161915 := (<-this.FetchOrders(symbol, since, limit, this.Extend(request, params)))
		PanicOnError(retRes161915)
		ch <- retRes161915
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bullish#fetchClosedOrders
 * @description fetches information on multiple closed orders made by the user
 * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#tag--orders
 * @param {string} symbol unified market symbol of the closed orders
 * @param {int} [since] timestamp in ms of the earliest order
 * @param {int} [limit] the max number of closed orders to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} params.tradingAccountId the trading account id (mandatory parameter)
 * @returns {object} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *BullishCore) FetchClosedOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		var request interface{} = map[string]interface{}{
			"status": "CLOSED",
			"method": "privateGetV2Orders",
		}

		retRes163915 := (<-this.FetchOrders(symbol, since, limit, this.Extend(request, params)))
		PanicOnError(retRes163915)
		ch <- retRes163915
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bullish#fetchCanceledAndClosedOrders
 * @description fetches information on multiple canceled orders made by the user
 * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#tag--history
 * @param {string} symbol unified market symbol of the closed orders
 * @param {int} [since] timestamp in ms of the earliest order
 * @param {int} [limit] the max number of closed orders to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.tradingAccountId] the trading account id (mandatory parameter)
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *BullishCore) FetchCanceledAndClosedOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		var request interface{} = map[string]interface{}{
			"status": "CLOSED",
			"method": "privateGetV2HistoryOrders",
		}

		retRes165915 := (<-this.FetchOrders(symbol, since, limit, this.Extend(request, params)))
		PanicOnError(retRes165915)
		ch <- retRes165915
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bullish#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#get-/v2/orders/-orderId-
 * @param {string} id the order id
 * @param {string} [symbol] unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.traidingAccountId] the trading account id (mandatory parameter)
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *BullishCore) FetchOrder(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes16748 := (<-promiseAll([]interface{}{this.LoadMarkets(), this.HandleToken()}))
		PanicOnError(retRes16748)

		tradingAccountId := (<-this.LoadAccount(params))
		PanicOnError(tradingAccountId)
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
		}
		var request interface{} = map[string]interface{}{
			"orderId":          id,
			"tradingAccountId": tradingAccountId,
		}

		response := (<-this.PrivateGetV2OrdersOrderId(this.Extend(request, params)))
		PanicOnError(response)

		//
		//     {
		//         "clientOrderId": "187",
		//         "orderId": "297735387747975680",
		//         "symbol": "BTCUSDC",
		//         "price": "1.00000000",
		//         "averageFillPrice": "1.00000000",
		//         "stopPrice": "1.00000000",
		//         "allowBorrow": false,
		//         "quantity": "1.00000000",
		//         "quantityFilled": "1.00000000",
		//         "quoteAmount": "1.00000000",
		//         "baseFee": "0.00100000",
		//         "quoteFee": "0.0010",
		//         "borrowedBaseQuantity": "1.00000000",
		//         "borrowedQuoteQuantity": "1.00000000",
		//         "isLiquidation": false,
		//         "side": "BUY",
		//         "type": "LMT",
		//         "timeInForce": "GTC",
		//         "status": "OPEN",
		//         "statusReason": "User cancelled",
		//         "statusReasonCode": "1002",
		//         "createdAtDatetime": "2021-05-20T01:01:01.000Z",
		//         "createdAtTimestamp": "1621490985000",
		//     }
		//
		ch <- this.ParseOrder(response, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bullish#createOrder
 * @description create a trade order
 * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#post-/v2/orders
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit' or 'STOP_LIMIT' or 'POST_ONLY'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.clientOrderId] a custom client order id
 * @param {float} [params.triggerPrice] the price at which a stop order is triggered at
 * @param {string} [params.timeInForce] the time in force for the order, either 'GTC' (Good Till Cancelled) or 'IOC' (Immediate or Cancel), default is 'GTC'
 * @param {bool} [params.allowBorrow] if true, the order will be allowed to borrow assets to fulfill the order (default is false)
 * @param {bool} [params.postOnly] if true, the order will only be posted to the order book and not executed immediately (default is false)
 * @param {string} params.traidingAccountId the trading account id (mandatory parameter)
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *BullishCore) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		price := GetArg(optionalArgs, 0, nil)
		_ = price
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes17358 := (<-promiseAll([]interface{}{this.LoadMarkets(), this.HandleToken()}))
		PanicOnError(retRes17358)

		tradingAccountId := (<-this.LoadAccount(params))
		PanicOnError(tradingAccountId)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"commandType":      "V3CreateOrder",
			"symbol":           GetValue(market, "id"),
			"side":             ToUpper(side),
			"quantity":         this.AmountToPrecision(symbol, amount),
			"tradingAccountId": tradingAccountId,
		}
		var isMarketOrder interface{} = (IsTrue((IsEqual(typeVar, "market"))) || IsTrue(IsEqual(typeVar, "MARKET")))
		var postOnly interface{} = false
		postOnlyparamsVariable := this.HandlePostOnly(isMarketOrder, IsEqual(typeVar, "POST_ONLY"), params)
		postOnly = GetValue(postOnlyparamsVariable, 0)
		params = GetValue(postOnlyparamsVariable, 1)
		if IsTrue(postOnly) {
			typeVar = "POST_ONLY"
		}
		var timeInForce interface{} = "GTC" // is mandatory
		timeInForceparamsVariable := this.HandleOptionAndParams(params, "createOrder", "timeInForce", timeInForce)
		timeInForce = GetValue(timeInForceparamsVariable, 0)
		params = GetValue(timeInForceparamsVariable, 1)
		AddElementToObject(params, "timeInForce", ToUpper(timeInForce))
		if !IsTrue(isMarketOrder) {
			AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
		}
		var triggerPrice interface{} = this.SafeString(params, "triggerPrice")
		if IsTrue(!IsEqual(triggerPrice, nil)) {
			if IsTrue(isMarketOrder) {
				panic(NotSupported(Add(this.Id, " createOrder() does not support market trigger orders")))
			}
			AddElementToObject(request, "stopPrice", this.PriceToPrecision(symbol, triggerPrice))
			typeVar = "STOP_LIMIT"
			params = this.Omit(params, "triggerPrice")
		}
		AddElementToObject(request, "type", ToUpper(typeVar))

		response := (<-this.PrivatePostV2Orders(this.Extend(request, params)))
		PanicOnError(response)

		//
		//     {
		//         "message": "Command acknowledged - CreateOrder",
		//         "requestId": "633910976353665024",
		//         "orderId": "633910775316480001",
		//         "clientOrderId": "1234567"
		//     }
		//
		ch <- this.ParseOrder(response, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bullish#editOrder
 * @description edit a trade limit order
 * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#post-/v2/command-amend
 * @param {string} id order id
 * @param {string} [symbol] unified symbol of the market to create an order in
 * @param {string} [type] 'limit' or 'POST_ONLY'
 * @param {string} [side] not used by bullish editOrder
 * @param {float} [amount] how much of the currency you want to trade in units of the base currency
 * @param {float} [price] the price for the order, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.traidingAccountId] the trading account id (mandatory parameter)
 * @param {bool} [params.postOnly] if true, the order will only be posted to the order book and not executed immediately (default is false)
 * @param {string} [params.clientOrderId] a unique identifier for the order, automatically generated if not sent
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *BullishCore) EditOrder(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		amount := GetArg(optionalArgs, 0, nil)
		_ = amount
		price := GetArg(optionalArgs, 1, nil)
		_ = price
		params := GetArg(optionalArgs, 2, map[string]interface{}{})
		_ = params

		retRes17978 := (<-promiseAll([]interface{}{this.LoadMarkets(), this.HandleToken()}))
		PanicOnError(retRes17978)

		tradingAccountId := (<-this.LoadAccount(params))
		PanicOnError(tradingAccountId)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"commandType":      "V1AmendOrder",
			"symbol":           GetValue(market, "id"),
			"tradingAccountId": tradingAccountId,
		}
		var clientOrderId interface{} = this.SafeString(params, "clientOrderId")
		if IsTrue(IsEqual(clientOrderId, nil)) {
			AddElementToObject(request, "orderId", id)
		}
		if IsTrue(!IsEqual(typeVar, nil)) {
			AddElementToObject(request, "type", ToUpper(typeVar))
		}
		var postOnly interface{} = this.SafeBool(params, "postOnly", false)
		if IsTrue(postOnly) {
			params = this.Omit(params, "postOnly")
			AddElementToObject(request, "type", "POST_ONLY")
		}
		if IsTrue(!IsEqual(amount, nil)) {
			AddElementToObject(request, "quantity", this.AmountToPrecision(symbol, amount))
		}
		if IsTrue(!IsEqual(price, nil)) {
			AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
		}

		response := (<-this.PrivatePostV2Command(this.Extend(request, params)))
		PanicOnError(response)

		ch <- this.ParseOrder(response, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bullish#cancelOrder
 * @description cancels an open order
 * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#post-/v2/command-cancellations
 * @param {string} [id] order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} params.commandType the command type, default is 'V3CancelOrder' (mandatory parameter)
 * @param {string} [params.traidingAccountId] the trading account id (mandatory parameter)
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *BullishCore) CancelOrder(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes18408 := (<-promiseAll([]interface{}{this.LoadMarkets(), this.HandleToken()}))
		PanicOnError(retRes18408)

		tradingAccountId := (<-this.LoadAccount(params))
		PanicOnError(tradingAccountId)
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " cancelOrder() requires a symbol argument")))
		}
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol":           GetValue(market, "id"),
			"tradingAccountId": tradingAccountId,
			"commandType":      this.SafeString(params, "commandType", "V3CancelOrder"),
			"orderId":          id,
		}

		response := (<-this.PrivatePostV2Command(this.Extend(request, params)))
		PanicOnError(response)

		//
		//     {
		//         "message": "Command acknowledged - CancelOrder",
		//         "requestId": "844658480774644736",
		//         "orderId": "297735387747975680",
		//         "clientOrderId": null
		//     }
		//
		ch <- this.ParseOrder(response, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bullish#cancelAllOrders
 * @description cancel all open orders in a market
 * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#post-/v2/command-cancellations
 * @param {string} [symbol] alpaca cancelAllOrders cannot setting symbol, it will cancel all open orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} params.traidingAccountId the trading account id (mandatory parameter)
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *BullishCore) CancelAllOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes18758 := (<-promiseAll([]interface{}{this.LoadMarkets(), this.HandleToken()}))
		PanicOnError(retRes18758)

		tradingAccountId := (<-this.LoadAccount(params))
		PanicOnError(tradingAccountId)
		var request interface{} = map[string]interface{}{
			"tradingAccountId": tradingAccountId,
		}
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			AddElementToObject(request, "symbol", GetValue(market, "id"))
			AddElementToObject(request, "commandType", "V1CancelAllOrdersByMarket")
		} else {
			AddElementToObject(request, "commandType", "V1CancelAllOrders")
		}

		response := (<-this.PrivatePostV2Command(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "message": "Command acknowledged - CancelAllOrders",
		//         "requestId": "633900538459062272"
		//     }
		//
		var orders interface{} = []interface{}{response}

		ch <- this.ParseOrders(orders, market)
		return nil

	}()
	return ch
}
func (this *BullishCore) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{} {
	//
	// fetchOrders, fetchOrder
	//     {
	//         "clientOrderId": "187",
	//         "orderId": "297735387747975680",
	//         "symbol": "BTCUSDC",
	//         "price": "1.00000000",
	//         "averageFillPrice": "1.00000000",
	//         "stopPrice": "1.00000000",
	//         "allowBorrow": false,
	//         "quantity": "1.00000000",
	//         "quantityFilled": "1.00000000",
	//         "quoteAmount": "1.00000000",
	//         "baseFee": "0.00100000",
	//         "quoteFee": "0.0010",
	//         "borrowedBaseQuantity": "1.00000000",
	//         "borrowedQuoteQuantity": "1.00000000",
	//         "isLiquidation": false,
	//         "side": "BUY",
	//         "type": "LMT",
	//         "timeInForce": "GTC",
	//         "status": "OPEN",
	//         "statusReason": "User cancelled",
	//         "statusReasonCode": "1002",
	//         "createdAtDatetime": "2021-05-20T01:01:01.000Z",
	//         "createdAtTimestamp": "1621490985000",
	//     }
	//
	// createOrder
	//     {
	//         "message": "Command acknowledged - CreateOrder",
	//         "requestId": "633910976353665024",
	//         "orderId": "633910775316480001",
	//         "clientOrderId": "1234567"
	//     }
	//
	// cancelOrder
	//     {
	//         "message": "Command acknowledged - CancelOrder",
	//         "requestId": "633910976353665024",
	//         "orderId": "633910775316480001"
	//     }
	//
	// cancelAllOrders
	//     {
	//         "message": "Command acknowledged - CancelAllOrders",
	//         "requestId": "633900538459062272"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(order, "symbol")
	if IsTrue(IsEqual(market, nil)) {
		market = this.SafeMarket(marketId)
	}
	var symbol interface{} = this.SafeSymbol(marketId, market)
	var id interface{} = this.SafeString(order, "orderId")
	var timestamp interface{} = this.SafeInteger(order, "createdAtTimestamp")
	var typeVar interface{} = this.SafeString(order, "type")
	var side interface{} = this.SafeStringLower(order, "side")
	var price interface{} = this.SafeString(order, "price")
	var amount interface{} = this.SafeString(order, "quantity")
	var filled interface{} = this.SafeString(order, "quantityFilled")
	var status interface{} = this.ParseOrderStatus(this.SafeString(order, "status"))
	if IsTrue(IsEqual(status, "closed")) {
		var statusReason interface{} = this.SafeString(order, "statusReason")
		if IsTrue(IsEqual(statusReason, "User cancelled")) {
			status = "canceled"
		}
	}
	var timeInForce interface{} = this.SafeString(order, "timeInForce")
	var stopPrice interface{} = this.SafeString(order, "stopPrice")
	var cost interface{} = this.SafeString(order, "quoteAmount")
	var fee interface{} = map[string]interface{}{}
	var quoteFee interface{} = this.SafeNumber(order, "quoteFee")
	if IsTrue(!IsEqual(quoteFee, nil)) {
		AddElementToObject(fee, "cost", quoteFee)
		AddElementToObject(fee, "currency", GetValue(market, "quote"))
	}
	var average interface{} = this.SafeString(order, "averageFillPrice")
	return this.SafeOrder(map[string]interface{}{
		"id":                 id,
		"clientOrderId":      this.SafeString(order, "clientOrderId"),
		"timestamp":          timestamp,
		"datetime":           this.Iso8601(timestamp),
		"lastTradeTimestamp": nil,
		"status":             status,
		"symbol":             symbol,
		"type":               this.ParseOrderType(typeVar),
		"timeInForce":        timeInForce,
		"postOnly":           IsEqual(typeVar, "POST_ONLY"),
		"side":               side,
		"price":              price,
		"triggerPrice":       stopPrice,
		"amount":             amount,
		"filled":             filled,
		"remaining":          nil,
		"cost":               cost,
		"trades":             nil,
		"fee":                fee,
		"info":               order,
		"average":            average,
	}, market)
}
func (this *BullishCore) ParseOrderStatus(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"OPEN":      "open",
		"CLOSED":    "closed",
		"CANCELLED": "canceled",
		"REJECTED":  "rejected",
	}
	return this.SafeString(statuses, status, status)
}
func (this *BullishCore) ParseOrderType(typeVar interface{}) interface{} {
	var types interface{} = map[string]interface{}{
		"LMT":        "limit",
		"MKT":        "market",
		"POST_ONLY":  "limit",
		"STOP_LIMIT": "limit",
	}
	return this.SafeString(types, typeVar, typeVar)
}

/**
 * @method
 * @name bullish#fetchDepositsWithdrawals
 * @description fetch history of deposits and withdrawals
 * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#get-/v1/wallets/transactions
 * @param {string} [code] unified currency code for the currency of the deposit/withdrawals, default is undefined
 * @param {int} [since] timestamp in ms of the earliest deposit/withdrawal, default is undefined
 * @param {int} [limit] max number of deposit/withdrawals to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func (this *BullishCore) FetchDepositsWithdrawals(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes20358 := (<-promiseAll([]interface{}{this.LoadMarkets(), this.HandleToken()}))
		PanicOnError(retRes20358)
		var request interface{} = map[string]interface{}{}
		requestparamsVariable := this.HandleUntilOption("createdAtDatetime[lte]", request, params)
		request = GetValue(requestparamsVariable, 0)
		params = GetValue(requestparamsVariable, 1)
		var until interface{} = this.SafeInteger(request, "createdAtDatetime[lte]")
		if IsTrue(!IsEqual(until, nil)) {
			AddElementToObject(request, "createdAtDatetime[lte]", this.Iso8601(until))
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "createdAtDatetime[gte]", this.Iso8601(since))
		}

		response := (<-this.PrivateGetV1WalletsTransactions(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "data": [
		//             {
		//                 "custodyTransactionId": "0x791fc85f16a84cbd5250d5517ecad497f564d2e5cc54d31466fe70b952fd58da",
		//                 "direction": "DEPOSIT",
		//                 "quantity": "150",
		//                 "symbol": "USDC",
		//                 "fee": "0",
		//                 "memo": "0x34625d5f0b6575503a0669994dea24271bfbd443",
		//                 "createdAtDateTime": "2025-11-04T14:31:17.000Z",
		//                 "updatedAtDateTime": "2025-11-04T14:44:17.500Z",
		//                 "status": "COMPLETE",
		//                 "statusReason": "OK",
		//                 "network": "ETH",
		//                 "transactionDetails": {
		//                     "address": "0x34625d5f0b6575503a0669994dea24271bfbd443",
		//                     "blockchainTxId": "0x791fc85f16a84cbd5250d5517ecad497f564d2e5cc54d31466fe70b952fd58da",
		//                     "swiftUetr": null,
		//                     "sources": [
		//                         {
		//                             "address": "0x2653435d52a5f49551ebb757f25b2c8bb954859b"
		//                         }
		//                     ]
		//                 }
		//             }
		//         ],
		//         "links": {
		//             "previous": null,
		//             "next": null
		//         },
		//         "totalCount": 1
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var currency interface{} = nil
		if IsTrue(!IsEqual(code, nil)) {
			currency = this.Currency(code)
		}

		ch <- this.ParseTransactions(data, currency, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bullish#withdraw
 * @description make a withdrawal
 * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#post-/v1/wallets/withdrawal
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} [tag]
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} params.timestamp the timestamp of the withdrawal request (mandatory)
 * @param {string} params.nonce the nonce of the withdrawal request (mandatory)
 * @param {string} params.network network for withdraw (mandatory)
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func (this *BullishCore) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		tag := GetArg(optionalArgs, 0, nil)
		_ = tag
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes21048 := (<-promiseAll([]interface{}{this.LoadMarkets(), this.HandleToken()}))
		PanicOnError(retRes21048)
		// todo check this method properly
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"command": map[string]interface{}{
				"commandType":   "V1Withdraw",
				"destinationId": address,
				"symbol":        GetValue(currency, "id"),
				"quantity":      this.CurrencyToPrecision(code, amount),
			},
		}
		var networkCode interface{} = nil
		networkCodeparamsVariable := this.HandleNetworkCodeAndParams(params)
		networkCode = GetValue(networkCodeparamsVariable, 0)
		params = GetValue(networkCodeparamsVariable, 1)
		if IsTrue(!IsEqual(networkCode, nil)) {
			AddElementToObject(request, "network", this.NetworkCodeToId(networkCode))
		} else {
			panic(ArgumentsRequired(Add(this.Id, " withdraw() requires a network parameter")))
		}

		response := (<-this.PrivatePostV1WalletsWithdrawal(this.Extend(request, params)))
		PanicOnError(response)

		//
		//     {
		//         "code": "00000",
		//         "msg": "success",
		//         "data": {
		//             "orderId":888291686266343424",
		//             "clientOrderId":"123"
		//         }
		//     }
		//
		ch <- this.ParseTransaction(response, currency)
		return nil

	}()
	return ch
}
func (this *BullishCore) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "custodyTransactionId": "0x791fc85f16a84cbd5250d5517ecad497f564d2e5cc54d31466fe70b952fd58da",
	//         "direction": "DEPOSIT",
	//         "quantity": "150",
	//         "symbol": "USDC",
	//         "fee": "0",
	//         "memo": "0x34625d5f0b6575503a0669994dea24271bfbd443",
	//         "createdAtDateTime": "2025-11-04T14:31:17.000Z",
	//         "updatedAtDateTime": "2025-11-04T14:44:17.500Z",
	//         "status": "COMPLETE",
	//         "statusReason": "OK",
	//         "network": "ETH",
	//         "transactionDetails": {
	//             "address": "0x34625d5f0b6575503a0669994dea24271bfbd443",
	//             "blockchainTxId": "0x791fc85f16a84cbd5250d5517ecad497f564d2e5cc54d31466fe70b952fd58da",
	//             "swiftUetr": null,
	//             "sources": [
	//                 {
	//                     "address": "0x2653435d52a5f49551ebb757f25b2c8bb954859b"
	//                 }
	//             ]
	//         }
	//     }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var id interface{} = this.SafeString(transaction, "custodyTransactionId")
	var typeVar interface{} = this.SafeString(transaction, "direction")
	var timestamp interface{} = this.Parse8601(this.SafeString(transaction, "createdAtDateTime"))
	var updated interface{} = this.Parse8601(this.SafeString(transaction, "updatedAtDateTime"))
	var network interface{} = this.SafeString(transaction, "network")
	var transactionDetails interface{} = this.SafeDict(transaction, "transactionDetails")
	var txid interface{} = this.SafeString(transactionDetails, "blockchainTxId")
	var address interface{} = this.SafeString(transactionDetails, "address")
	var amount interface{} = this.SafeNumber(transaction, "quantity")
	var currencyId interface{} = this.SafeString(transaction, "symbol")
	var code interface{} = this.SafeCurrencyCode(currencyId, currency)
	var status interface{} = this.SafeString(transaction, "status")
	var sources interface{} = this.SafeList(transactionDetails, "sources", []interface{}{})
	var source interface{} = this.SafeDict(sources, 0, map[string]interface{}{})
	var sourceAddress interface{} = this.SafeString(source, "address")
	var fee interface{} = map[string]interface{}{
		"currency": nil,
		"cost":     nil,
		"rate":     nil,
	}
	var feeCost interface{} = this.SafeNumber(transaction, "fee")
	if IsTrue(!IsEqual(feeCost, nil)) {
		AddElementToObject(fee, "cost", feeCost)
		AddElementToObject(fee, "currency", code)
	}
	return map[string]interface{}{
		"id":          id,
		"txid":        txid,
		"timestamp":   timestamp,
		"datetime":    this.Iso8601(timestamp),
		"network":     this.NetworkIdToCode(network),
		"addressFrom": sourceAddress,
		"address":     address,
		"addressTo":   address,
		"amount":      amount,
		"type":        this.ParseTransactionType(typeVar),
		"currency":    code,
		"status":      this.ParseTransactionStatus(status),
		"updated":     updated,
		"tagFrom":     nil,
		"tag":         nil,
		"tagTo":       nil,
		"comment":     nil,
		"internal":    nil,
		"fee":         fee,
		"info":        transaction,
	}
}
func (this *BullishCore) ParseTransactionType(typeVar interface{}) interface{} {
	var types interface{} = map[string]interface{}{
		"DEPOSIT":  "deposit",
		"WITHDRAW": "withdrawal",
	}
	return this.SafeString(types, typeVar, typeVar)
}
func (this *BullishCore) ParseTransactionStatus(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"COMPLETE":  "ok",
		"FAILED":    "failed",
		"PENDING":   "pending",
		"CANCELLED": "canceled",
	}
	return this.SafeString(statuses, status, status)
}
func (this *BullishCore) LoadAccount(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		var tradingAccountId interface{} = nil
		tradingAccountIdparamsVariable := this.HandleOptionAndParams(params, "fetchMyTrades", "tradingAccountId")
		tradingAccountId = GetValue(tradingAccountIdparamsVariable, 0)
		params = GetValue(tradingAccountIdparamsVariable, 1)
		if IsTrue(IsEqual(tradingAccountId, nil)) {

			response := (<-this.PrivateGetV1AccountsTradingAccounts(params))
			PanicOnError(response)
			for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
				var account interface{} = GetValue(response, i)
				var name interface{} = this.SafeString(account, "tradingAccountName")
				if IsTrue(IsEqual(name, "Primary Account")) {
					tradingAccountId = this.SafeString(account, "tradingAccountId")
					break
				}
			}
		}
		if IsTrue(IsEqual(tradingAccountId, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " loadAccount() requires a tradingAccountId parameter in options[\"tradingAccountId\"] or params[\"tradingAccountId\"], fetchAccounts() was not able to find the Primary account")))
		}
		AddElementToObject(this.Options, "tradingAccountId", tradingAccountId)

		ch <- tradingAccountId
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bullish#fetchAccounts
 * @description fetch all the accounts associated with a profile
 * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#tag--trading-accounts
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/#/?id=account-structure} indexed by the account type
 */
func (this *BullishCore) FetchAccounts(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes22598 := (<-promiseAll([]interface{}{this.LoadMarkets(), this.HandleToken()}))
		PanicOnError(retRes22598)

		response := (<-this.PrivateGetV1AccountsTradingAccounts(params))
		PanicOnError(response)

		//
		//     [
		//         {
		//             "defaultedMarginUSD": "0.0000",
		//             "endCustomerId": "222801149768465",
		//             "fullLiquidationMarginUSD": "0.0000",
		//             "initialMarginUSD": "0.0000",
		//             "isBorrowing": "false",
		//             "isConcentrationRiskEnabled": "true",
		//             "isDefaulted": "false",
		//             "isLending": "false",
		//             "isPrimaryAccount": "true",
		//             "liquidationMarginUSD": "0.0000",
		//             "liquidityAddonUSD": "0.0000",
		//             "makerFee": "0.00000000",
		//             "marginProfile": {
		//                 "defaultedMarketRiskMultiplierPct": "50.00",
		//                 "fullLiquidationMarketRiskMultiplierPct": "75.00",
		//                 "initialMarketRiskMultiplierPct": "200.00",
		//                 "liquidationMarketRiskMultiplierPct": "100.00",
		//                 "warningMarketRiskMultiplierPct": "150.00"
		//             },
		//             "marketRiskUSD": "0.0000",
		//             "maxInitialLeverage": "1",
		//             "rateLimitToken": "7fc358f0bad4124528318ff415e24f1ad6e530321827162a5e35d8de8dcfc750",
		//             "riskLimitUSD": "0.0000",
		//             "takerFee": "0.00000002",
		//             "totalBorrowedUSD": "0.0000",
		//             "totalCollateralUSD": "0.0000",
		//             "totalLiabilitiesUSD": "0.0000",
		//             "tradeFeeRate": [
		//                 {
		//                     "feeGroupId": "1",
		//                     "makerFee": "0.00000000",
		//                     "takerFee": "0.00000000"
		//                 },
		//                 {
		//                     "feeGroupId": "2",
		//                     "makerFee": "0.00000000",
		//                     "takerFee": "0.00000000"
		//                 },
		//                 {
		//                     "feeGroupId": "3",
		//                     "makerFee": "0.00000000",
		//                     "takerFee": "0.00000000"
		//                 },
		//                 {
		//                     "feeGroupId": "4",
		//                     "makerFee": "0.00000000",
		//                     "takerFee": "0.00000000"
		//                 },
		//                 {
		//                     "feeGroupId": "5",
		//                     "makerFee": "0.00000000",
		//                     "takerFee": "0.00000000"
		//                 },
		//                 {
		//                     "feeGroupId": "6",
		//                     "makerFee": "0.00000000",
		//                     "takerFee": "0.00000000"
		//                 },
		//                 {
		//                     "feeGroupId": "7",
		//                     "makerFee": "0.00000000",
		//                     "takerFee": "0.00000000"
		//                 },
		//                 {
		//                     "feeGroupId": "8",
		//                     "makerFee": "0.00000000",
		//                     "takerFee": "0.00000000"
		//                 }
		//             ],
		//             "tradingAccountDescription": null,
		//             "tradingAccountId": "111309424211255",
		//             "tradingAccountName": "Primary Account",
		//             "warningMarginUSD": "0.0000"
		//         }
		//     ]
		//
		ch <- this.ParseAccounts(response, params)
		return nil

	}()
	return ch
}
func (this *BullishCore) ParseAccount(account interface{}) interface{} {
	return map[string]interface{}{
		"id":   this.SafeString(account, "tradingAccountId"),
		"type": nil,
		"code": nil,
		"info": account,
	}
}

/**
 * @method
 * @name bullish#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account
 * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#get-/v1/wallets/deposit-instructions/crypto/-symbol-
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.network] network for deposit address
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func (this *BullishCore) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes23638 := (<-promiseAll([]interface{}{this.LoadMarkets(), this.HandleToken()}))
		PanicOnError(retRes23638)
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(currency, "id"),
		}

		response := (<-this.PrivateGetV1WalletsDepositInstructionsCryptoSymbol(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     [
		//         {
		//             "network": "ETH",
		//             "address": "0xc2fc755082d052bb334763b144851a0031999f33",
		//             "symbol": "ETH"
		//         }
		//     ]
		//
		var safeResponse interface{} = this.ToArray(response)
		var length interface{} = GetArrayLength(safeResponse)
		var data interface{} = this.SafeDict(safeResponse, 0, map[string]interface{}{})
		var network interface{} = nil
		networkparamsVariable := this.HandleNetworkCodeAndParams(params)
		network = GetValue(networkparamsVariable, 0)
		params = GetValue(networkparamsVariable, 1)
		var networkDefinedByUser interface{} = !IsEqual(network, nil)
		if IsTrue(IsTrue((IsGreaterThan(length, 1))) || IsTrue((networkDefinedByUser))) {
			// some currencies have multiple networks
			if IsTrue(IsEqual(network, nil)) {
				// use default network if not specified and multiple are available
				network = this.DefaultNetworkCode(code)
			}
			if IsTrue(!IsEqual(network, nil)) {
				// find the entry that matches the network or return first entry if not found and user did not specify a network
				for i := 0; IsLessThan(i, GetArrayLength(safeResponse)); i++ {
					var entry interface{} = this.SafeDict(safeResponse, i, map[string]interface{}{})
					var networkId interface{} = this.SafeString(entry, "network")
					var networkCode interface{} = this.NetworkIdToCode(networkId)
					if IsTrue(IsEqual(network, networkCode)) {
						data = entry
						break
					}
				}
				if IsTrue(networkDefinedByUser) {
					data = map[string]interface{}{} // return an empty structure if the user-defined network was not found
				}
			}
		}

		ch <- this.ParseDepositAddress(data, currency)
		return nil

	}()
	return ch
}
func (this *BullishCore) ParseDepositAddress(depositAddress interface{}, optionalArgs ...interface{}) interface{} {
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var id interface{} = this.SafeString(depositAddress, "symbol")
	var network interface{} = this.SafeString(depositAddress, "network")
	return map[string]interface{}{
		"info":     depositAddress,
		"currency": this.SafeCurrencyCode(id, currency),
		"network":  this.NetworkIdToCode(network),
		"address":  this.SafeString(depositAddress, "address"),
		"tag":      nil,
	}
}

/**
 * @method
 * @name bullish#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#get-/v1/accounts/asset
 * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#get-/v1/accounts/asset/-symbol-
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} params.tradingAccountId the trading account id (mandatory parameter)
 * @param {string} [params.code] unified currency code, default is undefined
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func (this *BullishCore) FetchBalance(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes24338 := (<-promiseAll([]interface{}{this.LoadMarkets(), this.HandleToken()}))
		PanicOnError(retRes24338)

		tradingAccountId := (<-this.LoadAccount(params))
		PanicOnError(tradingAccountId)
		var request interface{} = map[string]interface{}{
			"tradingAccountId": tradingAccountId,
		}
		var response interface{} = nil
		var code interface{} = this.SafeString(params, "code")
		if IsTrue(!IsEqual(code, nil)) {
			AddElementToObject(request, "symbol", GetValue(this.Currency(code), "id"))

			response = (<-this.PrivateGetV1AccountsAssetSymbol(this.Extend(request, params)))
			PanicOnError(response)

			ch <- this.ParseBalanceForSingleCurrency(response, code)
			return nil
		} else {

			response = (<-this.PrivateGetV1AccountsAsset(this.Extend(request, params)))
			PanicOnError(response)

			//
			//     [
			//         {
			//             "assetId": "10",
			//             "assetSymbol": "AAVE",
			//             "availableQuantity": "10000000.00000000",
			//             "borrowedQuantity": "0.00000000",
			//             "loanedQuantity": "0.00000000",
			//             "lockedQuantity": "0.00000000",
			//             "publishedAtTimestamp": "1747942728870",
			//             "tradingAccountId": "111309424211255",
			//             "updatedAtDatetime": "2025-05-13T11:33:08.801Z",
			//             "updatedAtTimestamp": "1747135988801"
			//         }, ...
			//     ]
			//
			ch <- this.ParseBalance(response)
			return nil
		}

	}()
	return ch
}
func (this *BullishCore) ParseBalanceForSingleCurrency(response interface{}, code interface{}) interface{} {
	var result interface{} = map[string]interface{}{
		"info": response,
	}
	var account interface{} = this.Account()
	AddElementToObject(account, "free", this.SafeString(response, "availableQuantity"))
	AddElementToObject(account, "used", this.SafeString(response, "lockedQuantity"))
	AddElementToObject(result, code, account)
	return this.SafeBalance(result)
}
func (this *BullishCore) ParseBalance(response interface{}) interface{} {
	var result interface{} = map[string]interface{}{
		"info": response,
	}
	for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
		var balance interface{} = GetValue(response, i)
		var symbol interface{} = this.SafeString(balance, "assetSymbol")
		var code interface{} = this.SafeCurrencyCode(symbol)
		var account interface{} = this.Account()
		AddElementToObject(account, "total", this.SafeString(balance, "availableQuantity"))
		AddElementToObject(account, "used", this.SafeString(balance, "lockedQuantity"))
		AddElementToObject(result, code, account)
	}
	return this.SafeBalance(result)
}

/**
 * @method
 * @name bullish#fetchPositions
 * @description fetch all open positions
 * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#get-/v1/derivatives-positions
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} params.tradingAccountId the trading account id
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func (this *BullishCore) FetchPositions(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes25028 := (<-promiseAll([]interface{}{this.LoadMarkets(), this.HandleToken()}))
		PanicOnError(retRes25028)

		tradingAccountId := (<-this.LoadAccount(params))
		PanicOnError(tradingAccountId)
		var request interface{} = map[string]interface{}{
			"tradingAccountId": tradingAccountId,
		}

		response := (<-this.PrivateGetV1DerivativesPositions(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     [
		//         {
		//             "tradingAccountId": "111000000000001",
		//             "symbol": "BTC-USDC-PERP",
		//             "side": "BUY",
		//             "quantity": "1.00000000",
		//             "notional": "1.0000",
		//             "entryNotional": "1.0000",
		//             "mtmPnl": "1.0000",
		//             "reportedMtmPnl": "1.0000",
		//             "reportedFundingPnl": "1.0000",
		//             "realizedPnl": "1.0000",
		//             "settlementAssetSymbol": "USDC",
		//             "createdAtDatetime": "2021-05-20T01:01:01.000Z",
		//             "createdAtTimestamp": "1621490985000",
		//             "updatedAtDatetime": "2021-05-20T01:01:01.000Z",
		//             "updatedAtTimestamp": "1621490985000"
		//         }
		//     ]
		//
		var results interface{} = this.ParsePositions(response, symbols)

		ch <- this.FilterByArrayPositions(results, "symbol", symbols, false)
		return nil

	}()
	return ch
}
func (this *BullishCore) ParsePosition(position interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     [
	//         {
	//             "tradingAccountId": "111000000000001",
	//             "symbol": "BTC-USDC-PERP",
	//             "side": "BUY",
	//             "quantity": "1.00000000",
	//             "notional": "1.0000",
	//             "entryNotional": "1.0000",
	//             "mtmPnl": "1.0000",
	//             "reportedMtmPnl": "1.0000",
	//             "reportedFundingPnl": "1.0000",
	//             "realizedPnl": "1.0000",
	//             "settlementAssetSymbol": "USDC",
	//             "createdAtDatetime": "2021-05-20T01:01:01.000Z",
	//             "createdAtTimestamp": "1621490985000",
	//             "updatedAtDatetime": "2021-05-20T01:01:01.000Z",
	//             "updatedAtTimestamp": "1621490985000"
	//         }
	//     ]
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	market = this.SafeMarket(this.SafeString(position, "symbol"), market)
	var symbol interface{} = GetValue(market, "symbol")
	var timestamp interface{} = this.SafeInteger(position, "createdAtTimestamp")
	var side interface{} = this.SafeString(position, "side")
	return this.SafePosition(map[string]interface{}{
		"info":                        position,
		"id":                          nil,
		"symbol":                      symbol,
		"timestamp":                   timestamp,
		"datetime":                    this.Iso8601(timestamp),
		"lastUpdateTimestamp":         this.SafeInteger(position, "updatedAtTimestamp"),
		"hedged":                      nil,
		"side":                        this.ParsePositionSide(side),
		"contracts":                   this.SafeNumber(position, "quantity"),
		"contractSize":                nil,
		"entryPrice":                  nil,
		"markPrice":                   nil,
		"lastPrice":                   nil,
		"notional":                    this.SafeNumber(position, "notional"),
		"leverage":                    nil,
		"collateral":                  nil,
		"initialMargin":               nil,
		"initialMarginPercentage":     nil,
		"maintenanceMargin":           nil,
		"maintenanceMarginPercentage": nil,
		"unrealizedPnl":               nil,
		"liquidationPrice":            nil,
		"marginMode":                  nil,
		"marginRatio":                 nil,
		"percentage":                  nil,
		"stopLossPrice":               nil,
		"takeProfitPrice":             nil,
	})
}
func (this *BullishCore) ParsePositionSide(side interface{}) interface{} {
	var sides interface{} = map[string]interface{}{
		"BUY":  "long",
		"SELL": "short",
	}
	return this.SafeString(sides, side, side)
}

/**
 * @method
 * @name bullish#fetchTransfers
 * @description fetch a history of internal transfers made on an account
 * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#get-/v1/history/transfer
 * @param {string} code unified currency code of the currency transferred
 * @param {int} [since] the earliest time in ms to fetch transfers for
 * @param {int} [limit] the maximum number of transfer structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} params.until the latest time in ms to fetch transfers for (default time now)
 * @param {string} params.tradingAccountId the trading account id
 * @returns {object[]} a list of [transfer structures]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func (this *BullishCore) FetchTransfers(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes26128 := (<-promiseAll([]interface{}{this.LoadMarkets(), this.HandleToken()}))
		PanicOnError(retRes26128)

		tradingAccountId := (<-this.LoadAccount(params))
		PanicOnError(tradingAccountId)
		var maxLimit interface{} = 100
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchTransfers", "paginate")
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {
			params = this.HandlePaginationParams("fetchTransfers", since, params)

			retRes261919 := (<-this.FetchPaginatedCallDynamic("fetchTransfers", code, since, limit, params, maxLimit))
			PanicOnError(retRes261919)
			ch <- retRes261919
			return nil
		}
		var request interface{} = map[string]interface{}{
			"tradingAccountId": tradingAccountId,
		}
		var currency interface{} = nil
		if IsTrue(!IsEqual(code, nil)) {
			currency = this.Currency(code)
			AddElementToObject(request, "assetSymbol", GetValue(currency, "id"))
		}
		var until interface{} = this.SafeInteger(params, "until")
		if IsTrue(IsTrue((IsEqual(since, nil))) && IsTrue((IsEqual(until, nil)))) {
			// since and until are mandatory for this endpoint, set until to now if both are undefined
			var now interface{} = this.Milliseconds()
			params = this.Extend(params, map[string]interface{}{
				"until": now,
			})
		}
		params = this.HandleSinceAndUntil(since, params)
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "_pageSize", this.GetClosestLimit(limit))
		}

		response := (<-this.PrivateGetV1HistoryTransfer(this.Extend(request, params)))
		PanicOnError(response)

		//
		//     [
		//         {
		//             "requestId": "1",
		//             "toTradingAccountId": "111000000000001",
		//             "fromTradingAccountId": "121000000000001",
		//             "assetSymbol": "BTC",
		//             "quantity": "1.00000000",
		//             "status": "CLOSED",
		//             "statusReasonCode": "6002",
		//             "statusReason": "Executed",
		//             "createdAtTimestamp": "1621490985000",
		//             "createdAtDatetime": "2021-05-20T01:01:01.000Z"
		//         }
		//     ]
		//
		ch <- this.ParseTransfers(response, currency, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bullish#transfer
 * @description transfer currency internally between wallets on the same account
 * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#post-/v1/command-commandType-V1TransferAsset
 * @param {string} code unified currency code
 * @param {float} amount amount to transfer
 * @param {string} fromAccount account ID to transfer from
 * @param {string} toAccount account ID to transfer to
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func (this *BullishCore) Transfer(code interface{}, amount interface{}, fromAccount interface{}, toAccount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes26728 := (<-promiseAll([]interface{}{this.LoadMarkets(), this.HandleToken()}))
		PanicOnError(retRes26728)
		// todo check this method properly
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"commandType":          "V2TransferAsset",
			"assetSymbol":          GetValue(currency, "id"),
			"quantity":             this.CurrencyToPrecision(code, amount),
			"fromTradingAccountId": fromAccount,
			"toTradingAccountId":   toAccount,
		}

		response := (<-this.PrivatePostV2Command(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "message": "Command acknowledged - TransferAsset",
		//         "requestId": "633909659774222336"
		//     }
		//
		var transferOptions interface{} = this.SafeDict(this.Options, "transfer", map[string]interface{}{})
		var fillResponseFromRequest interface{} = this.SafeBool(transferOptions, "fillResponseFromRequest", true)
		var transfer interface{} = this.ParseTransfer(response, currency)
		if IsTrue(fillResponseFromRequest) {
			AddElementToObject(transfer, "fromAccount", fromAccount)
			AddElementToObject(transfer, "toAccount", toAccount)
			AddElementToObject(transfer, "amount", amount)
			AddElementToObject(transfer, "currency", code)
		}

		ch <- transfer
		return nil

	}()
	return ch
}
func (this *BullishCore) ParseTransfer(transfer interface{}, optionalArgs ...interface{}) interface{} {
	//
	// fetchTransfers
	//     {
	//         "requestId": "1",
	//         "toTradingAccountId": "111000000000001",
	//         "fromTradingAccountId": "121000000000001",
	//         "assetSymbol": "BTC",
	//         "quantity": "1.00000000",
	//         "status": "CLOSED",
	//         "statusReasonCode": "6002",
	//         "statusReason": "Executed",
	//         "createdAtTimestamp": "1621490985000",
	//         "createdAtDatetime": "2021-05-20T01:01:01.000Z"
	//     }
	//
	// transfer
	//     {
	//         "message": "Command acknowledged - TransferAsset",
	//         "requestId": "633909659774222336"
	//     }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var timestamp interface{} = this.SafeInteger(transfer, "createdAtTimestamp")
	var currencyId interface{} = this.SafeString(transfer, "assetSymbol")
	var status interface{} = this.SafeString(transfer, "status")
	if IsTrue(IsEqual(status, nil)) {
		status = this.SafeString(transfer, "message")
	}
	return map[string]interface{}{
		"id":          this.SafeString(transfer, "requestId"),
		"timestamp":   timestamp,
		"datetime":    this.Iso8601(timestamp),
		"currency":    this.SafeCurrencyCode(currencyId, currency),
		"amount":      this.SafeNumber(transfer, "quantity"),
		"fromAccount": this.SafeString(transfer, "fromTradingAccountId"),
		"toAccount":   this.SafeString(transfer, "toTradingAccountId"),
		"status":      this.ParseTransferStatus(status),
		"info":        transfer,
	}
}
func (this *BullishCore) ParseTransferStatus(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"CLOSED":                               "ok",
		"OPEN":                                 "pending",
		"REJECTED":                             "failed",
		"Command acknowledged - TransferAsset": "ok",
	}
	return this.SafeString(statuses, status, status)
}

/**
 * @method
 * @name bullish#fetchBorrowRateHistory
 * @description retrieves a history of a currencies borrow interest rate at specific time slots
 * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#get-/v1/history/borrow-interest
 * @param {string} code unified currency code
 * @param {int} [since] timestamp for the earliest borrow rate
 * @param {int} [limit] the maximum number of [borrow rate structures]{@link https://docs.ccxt.com/#/?id=borrow-rate-structure} to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} params.until the latest time in ms to fetch entries for
 * @param {string} params.tradingAccountId the trading account id
 * @returns {object[]} an array of [borrow rate structures]{@link https://docs.ccxt.com/#/?id=borrow-rate-structure}
 */
func (this *BullishCore) FetchBorrowRateHistory(code interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		since := GetArg(optionalArgs, 0, nil)
		_ = since
		limit := GetArg(optionalArgs, 1, nil)
		_ = limit
		params := GetArg(optionalArgs, 2, map[string]interface{}{})
		_ = params

		retRes27668 := (<-promiseAll([]interface{}{this.LoadMarkets(), this.HandleToken()}))
		PanicOnError(retRes27668)

		tradingAccountId := (<-this.LoadAccount(params))
		PanicOnError(tradingAccountId)
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"assetSymbol":      GetValue(currency, "id"),
			"tradingAccountId": tradingAccountId,
		}
		var now interface{} = this.Milliseconds()
		var startTimestamp interface{} = since
		requestparamsVariable := this.HandleUntilOption("createdAtDatetime[lte]", request, params)
		request = GetValue(requestparamsVariable, 0)
		params = GetValue(requestparamsVariable, 1)
		var until interface{} = this.SafeInteger(request, "createdAtDatetime[lte]")
		// current endpoint requires both since and until parameters
		if IsTrue(IsEqual(startTimestamp, nil)) {
			startTimestamp = Subtract(now, Multiply(Multiply(Multiply(Multiply(1000, 60), 60), 24), 90)) // Only the last 90 days of data is available for querying
		}
		if IsTrue(IsEqual(until, nil)) {
			until = now
		}
		AddElementToObject(request, "createdAtDatetime[gte]", this.Iso8601(startTimestamp))
		AddElementToObject(request, "createdAtDatetime[lte]", this.Iso8601(until))

		response := (<-this.PrivateGetV1HistoryBorrowInterest(this.Extend(request, params)))
		PanicOnError(response)

		//
		//     [
		//         {
		//             "assetId": "1",
		//             "assetSymbol": "BTC",
		//             "borrowedQuantity": "1.00000000",
		//             "totalBorrowedQuantity": "1.00000000",
		//             "createdAtDatetime": "2020-08-21T08:00:00.000Z",
		//             "createdAtTimestamp": "1621490985000"
		//         }
		//     ]
		//
		ch <- this.ParseBorrowRateHistory(response, code, since, limit)
		return nil

	}()
	return ch
}
func (this *BullishCore) ParseBorrowRate(info interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "assetId": "1",
	//         "assetSymbol": "BTC",
	//         "borrowedQuantity": "1.00000000",
	//         "totalBorrowedQuantity": "1.00000000",
	//         "createdAtDatetime": "2020-08-21T08:00:00.000Z",
	//         "createdAtTimestamp": "1621490985000"
	//     }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var timestamp interface{} = this.SafeInteger(info, "createdAtTimestamp")
	var currencyId interface{} = this.SafeString(info, "assetSymbol")
	return map[string]interface{}{
		"currency":  this.SafeCurrencyCode(currencyId, currency),
		"rate":      this.SafeNumber(info, "borrowedQuantity"),
		"period":    86400000,
		"timestamp": timestamp,
		"datetime":  this.Iso8601(timestamp),
		"info":      info,
	}
}
func (this *BullishCore) GetTimestamp() interface{} {
	return Subtract(this.Milliseconds(), GetValue(this.Options, "timeDifference"))
}
func (this *BullishCore) Sign(path interface{}, optionalArgs ...interface{}) interface{} {
	api := GetArg(optionalArgs, 0, "public")
	_ = api
	method := GetArg(optionalArgs, 1, "GET")
	_ = method
	params := GetArg(optionalArgs, 2, map[string]interface{}{})
	_ = params
	headers := GetArg(optionalArgs, 3, nil)
	_ = headers
	body := GetArg(optionalArgs, 4, nil)
	_ = body
	var request interface{} = this.Omit(params, this.ExtractParams(path))
	var endpoint interface{} = Add("/", this.ImplodeParams(path, params))
	var url interface{} = Add(GetValue(GetValue(this.Urls, "api"), api), endpoint)
	if IsTrue(IsEqual(api, "private")) {
		this.CheckRequiredCredentials()
		var nonce interface{} = ToString(this.Microseconds())
		var timestamp interface{} = ToString(this.GetTimestamp())
		if IsTrue(IsEqual(method, "GET")) {
			var payload interface{} = Add(Add(Add(Add(timestamp, nonce), method), "/trading-api/"), path)
			var signature interface{} = this.Hmac(this.Encode(payload), this.Encode(this.Secret), sha256, "hex")
			headers = map[string]interface{}{
				"BX-TIMESTAMP": timestamp,
				"BX-NONCE":     nonce,
				"BX-SIGNATURE": signature,
			}
		} else if IsTrue(IsEqual(method, "POST")) {
			body = this.Json(params)
			var payload interface{} = Add(Add(Add(Add(Add(timestamp, nonce), method), "/trading-api/"), path), body)
			var digest interface{} = this.Hash(this.Encode(payload), sha256, "hex")
			var signature interface{} = this.Hmac(this.Encode(digest), this.Encode(this.Secret), sha256, "hex")
			headers = map[string]interface{}{
				"BX-TIMESTAMP": timestamp,
				"BX-NONCE":     nonce,
				"BX-SIGNATURE": signature,
				"Content-Type": "application/json",
			}
			AddElementToObject(headers, "Content-Type", "application/json")
			var rateLimitToken interface{} = this.SafeString(request, "rateLimitToken")
			if IsTrue(!IsEqual(rateLimitToken, nil)) {
				AddElementToObject(headers, "BX-RATE-LIMIT-TOKEN", rateLimitToken)
			}
		}
		if IsTrue(IsEqual(path, "v1/users/hmac/login")) {
			AddElementToObject(headers, "BX-PUBLIC-KEY", this.ApiKey)
		} else {
			var token interface{} = this.Token
			if IsTrue((IsEqual(token, nil))) {
				panic(AuthenticationError(Add(this.Id, " requires a token, please call signIn() first")))
			}
			AddElementToObject(headers, "Authorization", Add("Bearer ", token))
		}
	}
	if IsTrue(IsEqual(method, "GET")) {
		var query interface{} = this.Urlencode(request)
		if IsTrue(GetArrayLength(query)) {
			url = Add(url, Add("?", query))
		}
	}
	return map[string]interface{}{
		"url":     url,
		"method":  method,
		"body":    body,
		"headers": headers,
	}
}

/**
 * @method
 * @name bullish#signIn
 * @description sign in, must be called prior to using other authenticated methods
 * @see https://api.exchange.bullish.com/docs/api/rest/trading-api/v2/#overview--add-authenticated-request-header
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns response from exchange
 */
func (this *BullishCore) SignIn(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		response := (<-this.PrivateGetV1UsersHmacLogin(params))
		PanicOnError(response)
		//
		//     {
		//         "authorizer": "113363EFA2CA00007368524E02000000",
		//         "ownerAuthorizer": "113363EFA2CA00007368524E02000000",
		//         "token": "eyJhbGciOiJFUzI1NiJ9.eyJpc3MiOiJiMXgtYXV0aC1zZXJ2aWNlIiwic3ViIjoiNDY0OTc4MzAiLCJleHAiOjE3NDczMzgzNDMsIlNUQUdFIjoiQVVUSEVOVElDQVRFRF9XSVRIX0JMT0NLQ0hBSU4ifQ.5FSyrihzc1wsJqAY8pVX36Y4ZXg3HopLJypPEbHg5bBK8FbL_oLxkj6zM_iOYL2a1x6-ICG0pQjr8hF_k8Yg-w"
		//     }
		//
		var token interface{} = this.SafeString(response, "token")
		var authorizer interface{} = this.SafeString(response, "authorizer")
		AddElementToObject(this.Options, "authorizer", authorizer)
		this.Token = token
		AddElementToObject(this.Options, "tokenExpires", this.Sum(this.Milliseconds(), Multiply(Multiply(Multiply(1000, 60), 60), 24))) // token expires in 24 hours

		ch <- token
		return nil

	}()
	return ch
}
func (this *BullishCore) HandleToken(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		var now interface{} = this.Milliseconds()
		var token interface{} = this.Token
		var tokenExpires interface{} = this.SafeInteger(this.Options, "tokenExpires")
		if IsTrue(IsTrue(IsTrue((IsEqual(token, nil))) || IsTrue((IsEqual(tokenExpires, nil)))) || IsTrue((IsGreaterThan(now, tokenExpires)))) {

			retRes291219 := (<-this.SignIn())
			PanicOnError(retRes291219)
			ch <- retRes291219
			return nil
		} else {

			ch <- this.Token
			return nil
		}

	}()
	return ch
}
func (this *BullishCore) HandleErrors(httpCode interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{} {
	if IsTrue(IsEqual(response, nil)) {
		return nil // fallback to default error handler
	}
	//
	//         {
	//             "type": "HttpInvalidParameterException",
	//             "message": "HTTP_INVALID_PARAMETER: '100m' is not a valid time bucket"
	//         }
	//
	//         {
	//             "message": "Order size outside valid range",
	//             "raw": null,
	//             "errorCode": 6023,
	//             "errorCodeName": "ORDER_SIZE_OUTSIDE_VALID_RANGE"
	//         }
	//
	var code interface{} = this.SafeString(response, "errorCode")
	var typeVar interface{} = this.SafeString(response, "type")
	if IsTrue(IsTrue((IsTrue(IsTrue(!IsEqual(code, nil)) && IsTrue(!IsEqual(code, "0"))) && IsTrue(!IsEqual(code, "1001")))) || IsTrue((IsTrue(!IsEqual(typeVar, nil)) && IsTrue(IsEqual(typeVar, "HttpInvalidParameterException"))))) {
		var message interface{} = ""
		var errorCodeName interface{} = this.SafeString(response, "errorCodeName")
		if IsTrue(!IsEqual(errorCodeName, nil)) {
			message = errorCodeName
		} else {
			message = typeVar
		}
		var feedback interface{} = Add(Add(this.Id, " "), body)
		this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), message, feedback)
		this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), message, feedback)
		this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), code, feedback)
		panic(ExchangeError(feedback))
	}
	return nil
}

func (this *BullishCore) Init(userConfig map[string]interface{}) {
	this.Exchange = Exchange{}
	this.Exchange.DerivedExchange = this
	this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
}
