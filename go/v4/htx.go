package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type HtxCore struct {
	Exchange
}

func NewHtxCore() *HtxCore {
	p := &HtxCore{}
	setDefaults(p)
	return p
}

func (this *HtxCore) Describe() interface{} {
	return this.DeepExtend(this.Exchange.Describe(), map[string]interface{}{
		"id":        "htx",
		"name":      "HTX",
		"countries": []interface{}{"CN"},
		"rateLimit": 100,
		"userAgent": GetValue(this.UserAgents, "chrome100"),
		"certified": true,
		"version":   "v1",
		"hostname":  "api.huobi.pro",
		"pro":       true,
		"has": map[string]interface{}{
			"CORS":                           nil,
			"spot":                           true,
			"margin":                         true,
			"swap":                           true,
			"future":                         true,
			"option":                         nil,
			"addMargin":                      nil,
			"borrowCrossMargin":              true,
			"borrowIsolatedMargin":           true,
			"cancelAllOrders":                true,
			"cancelAllOrdersAfter":           true,
			"cancelOrder":                    true,
			"cancelOrders":                   true,
			"closeAllPositions":              false,
			"closePosition":                  true,
			"createDepositAddress":           nil,
			"createMarketBuyOrderWithCost":   true,
			"createMarketOrderWithCost":      false,
			"createMarketSellOrderWithCost":  false,
			"createOrder":                    true,
			"createOrders":                   true,
			"createReduceOnlyOrder":          false,
			"createStopLimitOrder":           true,
			"createStopLossOrder":            true,
			"createStopMarketOrder":          true,
			"createStopOrder":                true,
			"createTakeProfitOrder":          true,
			"createTrailingPercentOrder":     true,
			"createTriggerOrder":             true,
			"fetchAccounts":                  true,
			"fetchBalance":                   true,
			"fetchBidsAsks":                  nil,
			"fetchBorrowInterest":            true,
			"fetchBorrowRateHistories":       nil,
			"fetchBorrowRateHistory":         nil,
			"fetchCanceledOrders":            nil,
			"fetchClosedOrder":               nil,
			"fetchClosedOrders":              true,
			"fetchCrossBorrowRate":           false,
			"fetchCrossBorrowRates":          false,
			"fetchCurrencies":                true,
			"fetchDeposit":                   nil,
			"fetchDepositAddress":            true,
			"fetchDepositAddresses":          nil,
			"fetchDepositAddressesByNetwork": true,
			"fetchDeposits":                  true,
			"fetchDepositWithdrawFee":        "emulated",
			"fetchDepositWithdrawFees":       true,
			"fetchFundingHistory":            true,
			"fetchFundingRate":               true,
			"fetchFundingRateHistory":        true,
			"fetchFundingRates":              true,
			"fetchIndexOHLCV":                true,
			"fetchIsolatedBorrowRate":        false,
			"fetchIsolatedBorrowRates":       true,
			"fetchL3OrderBook":               nil,
			"fetchLastPrices":                true,
			"fetchLedger":                    true,
			"fetchLedgerEntry":               nil,
			"fetchLeverage":                  false,
			"fetchLeverageTiers":             true,
			"fetchLiquidations":              true,
			"fetchMarginAdjustmentHistory":   false,
			"fetchMarketLeverageTiers":       "emulated",
			"fetchMarkets":                   true,
			"fetchMarkOHLCV":                 true,
			"fetchMyLiquidations":            false,
			"fetchMyTrades":                  true,
			"fetchOHLCV":                     true,
			"fetchOpenInterest":              true,
			"fetchOpenInterestHistory":       true,
			"fetchOpenInterests":             true,
			"fetchOpenOrder":                 nil,
			"fetchOpenOrders":                true,
			"fetchOrder":                     true,
			"fetchOrderBook":                 true,
			"fetchOrderBooks":                nil,
			"fetchOrders":                    true,
			"fetchOrderTrades":               true,
			"fetchPosition":                  true,
			"fetchPositionHistory":           "emulated",
			"fetchPositions":                 true,
			"fetchPositionsHistory":          false,
			"fetchPositionsRisk":             false,
			"fetchPremiumIndexOHLCV":         true,
			"fetchSettlementHistory":         true,
			"fetchStatus":                    true,
			"fetchTicker":                    true,
			"fetchTickers":                   true,
			"fetchTime":                      true,
			"fetchTrades":                    true,
			"fetchTradingFee":                true,
			"fetchTradingFees":               false,
			"fetchTradingLimits":             true,
			"fetchTransactionFee":            nil,
			"fetchTransactionFees":           nil,
			"fetchTransactions":              nil,
			"fetchTransfers":                 nil,
			"fetchWithdrawAddresses":         true,
			"fetchWithdrawal":                nil,
			"fetchWithdrawals":               true,
			"fetchWithdrawalWhitelist":       nil,
			"reduceMargin":                   nil,
			"repayCrossMargin":               true,
			"repayIsolatedMargin":            true,
			"setLeverage":                    true,
			"setMarginMode":                  false,
			"setPositionMode":                true,
			"signIn":                         nil,
			"transfer":                       true,
			"withdraw":                       true,
		},
		"timeframes": map[string]interface{}{
			"1m":  "1min",
			"5m":  "5min",
			"15m": "15min",
			"30m": "30min",
			"1h":  "60min",
			"4h":  "4hour",
			"1d":  "1day",
			"1w":  "1week",
			"1M":  "1mon",
			"1y":  "1year",
		},
		"urls": map[string]interface{}{
			"logo": "https://user-images.githubusercontent.com/1294454/76137448-22748a80-604e-11ea-8069-6e389271911d.jpg",
			"hostnames": map[string]interface{}{
				"contract": "api.hbdm.vn",
				"spot":     "api.huobi.pro",
				"status": map[string]interface{}{
					"spot": "status.huobigroup.com",
					"future": map[string]interface{}{
						"inverse": "status-dm.huobigroup.com",
						"linear":  "status-linear-swap.huobigroup.com",
					},
					"swap": map[string]interface{}{
						"inverse": "status-swap.huobigroup.com",
						"linear":  "status-linear-swap.huobigroup.com",
					},
				},
			},
			"api": map[string]interface{}{
				"status":    "https://{hostname}",
				"contract":  "https://{hostname}",
				"spot":      "https://{hostname}",
				"public":    "https://{hostname}",
				"private":   "https://{hostname}",
				"v2Public":  "https://{hostname}",
				"v2Private": "https://{hostname}",
			},
			"www": "https://www.huobi.com",
			"referral": map[string]interface{}{
				"url":      "https://www.htx.com.vc/invite/en-us/1h?invite_code=6rmm2223",
				"discount": 0.15,
			},
			"doc":  []interface{}{"https://huobiapi.github.io/docs/spot/v1/en/", "https://huobiapi.github.io/docs/dm/v1/en/", "https://huobiapi.github.io/docs/coin_margined_swap/v1/en/", "https://huobiapi.github.io/docs/usdt_swap/v1/en/", "https://www.huobi.com/en-us/opend/newApiPages/"},
			"fees": "https://www.huobi.com/about/fee/",
		},
		"api": map[string]interface{}{
			"v2Public": map[string]interface{}{
				"get": map[string]interface{}{
					"reference/currencies": 1,
					"market-status":        1,
				},
			},
			"v2Private": map[string]interface{}{
				"get": map[string]interface{}{
					"account/ledger":              1,
					"account/withdraw/quota":      1,
					"account/withdraw/address":    1,
					"account/deposit/address":     1,
					"account/repayment":           5,
					"reference/transact-fee-rate": 1,
					"account/asset-valuation":     0.2,
					"point/account":               5,
					"sub-user/user-list":          1,
					"sub-user/user-state":         1,
					"sub-user/account-list":       1,
					"sub-user/deposit-address":    1,
					"sub-user/query-deposit":      1,
					"user/api-key":                1,
					"user/uid":                    1,
					"algo-orders/opening":         1,
					"algo-orders/history":         1,
					"algo-orders/specific":        1,
					"c2c/offers":                  1,
					"c2c/offer":                   1,
					"c2c/transactions":            1,
					"c2c/repayment":               1,
					"c2c/account":                 1,
					"etp/reference":               1,
					"etp/transactions":            5,
					"etp/transaction":             5,
					"etp/rebalance":               1,
					"etp/limit":                   1,
				},
				"post": map[string]interface{}{
					"account/transfer":              1,
					"account/repayment":             5,
					"point/transfer":                5,
					"sub-user/management":           1,
					"sub-user/creation":             1,
					"sub-user/tradable-market":      1,
					"sub-user/transferability":      1,
					"sub-user/api-key-generation":   1,
					"sub-user/api-key-modification": 1,
					"sub-user/api-key-deletion":     1,
					"sub-user/deduct-mode":          1,
					"algo-orders":                   1,
					"algo-orders/cancel-all-after":  1,
					"algo-orders/cancellation":      1,
					"c2c/offer":                     1,
					"c2c/cancellation":              1,
					"c2c/cancel-all":                1,
					"c2c/repayment":                 1,
					"c2c/transfer":                  1,
					"etp/creation":                  5,
					"etp/redemption":                5,
					"etp/{transactId}/cancel":       10,
					"etp/batch-cancel":              50,
				},
			},
			"public": map[string]interface{}{
				"get": map[string]interface{}{
					"common/symbols":     1,
					"common/currencys":   1,
					"common/timestamp":   1,
					"common/exchange":    1,
					"settings/currencys": 1,
				},
			},
			"private": map[string]interface{}{
				"get": map[string]interface{}{
					"account/accounts":               0.2,
					"account/accounts/{id}/balance":  0.2,
					"account/accounts/{sub-uid}":     1,
					"account/history":                4,
					"cross-margin/loan-info":         1,
					"margin/loan-info":               1,
					"fee/fee-rate/get":               1,
					"order/openOrders":               0.4,
					"order/orders":                   0.4,
					"order/orders/{id}":              0.4,
					"order/orders/{id}/matchresults": 0.4,
					"order/orders/getClientOrder":    0.4,
					"order/history":                  1,
					"order/matchresults":             1,
					"query/deposit-withdraw":         1,
					"margin/loan-orders":             0.2,
					"margin/accounts/balance":        0.2,
					"cross-margin/loan-orders":       1,
					"cross-margin/accounts/balance":  1,
					"points/actions":                 1,
					"points/orders":                  1,
					"subuser/aggregate-balance":      10,
					"stable-coin/exchange_rate":      1,
					"stable-coin/quote":              1,
				},
				"post": map[string]interface{}{
					"account/transfer":                     1,
					"futures/transfer":                     1,
					"order/batch-orders":                   0.4,
					"order/orders/place":                   0.2,
					"order/orders/submitCancelClientOrder": 0.2,
					"order/orders/batchCancelOpenOrders":   0.4,
					"order/orders/{id}/submitcancel":       0.2,
					"order/orders/batchcancel":             0.4,
					"dw/withdraw/api/create":               1,
					"dw/withdraw-virtual/{id}/cancel":      1,
					"dw/transfer-in/margin":                10,
					"dw/transfer-out/margin":               10,
					"margin/orders":                        10,
					"margin/orders/{id}/repay":             10,
					"cross-margin/transfer-in":             1,
					"cross-margin/transfer-out":            1,
					"cross-margin/orders":                  1,
					"cross-margin/orders/{id}/repay":       1,
					"stable-coin/exchange":                 1,
					"subuser/transfer":                     10,
				},
			},
			"status": map[string]interface{}{
				"public": map[string]interface{}{
					"spot": map[string]interface{}{
						"get": map[string]interface{}{
							"api/v2/summary.json": 1,
						},
					},
					"future": map[string]interface{}{
						"inverse": map[string]interface{}{
							"get": map[string]interface{}{
								"api/v2/summary.json": 1,
							},
						},
						"linear": map[string]interface{}{
							"get": map[string]interface{}{
								"api/v2/summary.json": 1,
							},
						},
					},
					"swap": map[string]interface{}{
						"inverse": map[string]interface{}{
							"get": map[string]interface{}{
								"api/v2/summary.json": 1,
							},
						},
						"linear": map[string]interface{}{
							"get": map[string]interface{}{
								"api/v2/summary.json": 1,
							},
						},
					},
				},
			},
			"spot": map[string]interface{}{
				"public": map[string]interface{}{
					"get": map[string]interface{}{
						"v2/market-status":                  1,
						"v1/common/symbols":                 1,
						"v1/common/currencys":               1,
						"v2/settings/common/currencies":     1,
						"v2/reference/currencies":           1,
						"v1/common/timestamp":               1,
						"v1/common/exchange":                1,
						"v1/settings/common/chains":         1,
						"v1/settings/common/currencys":      1,
						"v1/settings/common/symbols":        1,
						"v2/settings/common/symbols":        1,
						"v1/settings/common/market-symbols": 1,
						"market/history/candles":            1,
						"market/history/kline":              1,
						"market/detail/merged":              1,
						"market/tickers":                    1,
						"market/detail":                     1,
						"market/depth":                      1,
						"market/trade":                      1,
						"market/history/trade":              1,
						"market/etp":                        1,
						"v2/etp/reference":                  1,
						"v2/etp/rebalance":                  1,
					},
				},
				"private": map[string]interface{}{
					"get": map[string]interface{}{
						"v1/account/accounts":                      0.2,
						"v1/account/accounts/{account-id}/balance": 0.2,
						"v2/account/valuation":                     1,
						"v2/account/asset-valuation":               0.2,
						"v1/account/history":                       4,
						"v2/account/ledger":                        1,
						"v2/point/account":                         5,
						"v2/account/deposit/address":               1,
						"v2/account/withdraw/quota":                1,
						"v2/account/withdraw/address":              1,
						"v2/reference/currencies":                  1,
						"v1/query/deposit-withdraw":                1,
						"v1/query/withdraw/client-order-id":        1,
						"v2/user/api-key":                          1,
						"v2/user/uid":                              1,
						"v2/sub-user/user-list":                    1,
						"v2/sub-user/user-state":                   1,
						"v2/sub-user/account-list":                 1,
						"v2/sub-user/deposit-address":              1,
						"v2/sub-user/query-deposit":                1,
						"v1/subuser/aggregate-balance":             10,
						"v1/account/accounts/{sub-uid}":            1,
						"v1/order/openOrders":                      0.4,
						"v1/order/orders/{order-id}":               0.4,
						"v1/order/orders/getClientOrder":           0.4,
						"v1/order/orders/{order-id}/matchresult":   0.4,
						"v1/order/orders/{order-id}/matchresults":  0.4,
						"v1/order/orders":                          0.4,
						"v1/order/history":                         1,
						"v1/order/matchresults":                    1,
						"v2/reference/transact-fee-rate":           1,
						"v2/algo-orders/opening":                   1,
						"v2/algo-orders/history":                   1,
						"v2/algo-orders/specific":                  1,
						"v1/margin/loan-info":                      1,
						"v1/margin/loan-orders":                    0.2,
						"v1/margin/accounts/balance":               0.2,
						"v1/cross-margin/loan-info":                1,
						"v1/cross-margin/loan-orders":              1,
						"v1/cross-margin/accounts/balance":         1,
						"v2/account/repayment":                     5,
						"v1/stable-coin/quote":                     1,
						"v1/stable_coin/exchange_rate":             1,
						"v2/etp/transactions":                      5,
						"v2/etp/transaction":                       5,
						"v2/etp/limit":                             1,
					},
					"post": map[string]interface{}{
						"v1/account/transfer":                         1,
						"v1/futures/transfer":                         1,
						"v2/point/transfer":                           5,
						"v2/account/transfer":                         1,
						"v1/dw/withdraw/api/create":                   1,
						"v1/dw/withdraw-virtual/{withdraw-id}/cancel": 1,
						"v2/sub-user/deduct-mode":                     1,
						"v2/sub-user/creation":                        1,
						"v2/sub-user/management":                      1,
						"v2/sub-user/tradable-market":                 1,
						"v2/sub-user/transferability":                 1,
						"v2/sub-user/api-key-generation":              1,
						"v2/sub-user/api-key-modification":            1,
						"v2/sub-user/api-key-deletion":                1,
						"v1/subuser/transfer":                         10,
						"v1/trust/user/active/credit":                 10,
						"v1/order/orders/place":                       0.2,
						"v1/order/batch-orders":                       0.4,
						"v1/order/auto/place":                         0.2,
						"v1/order/orders/{order-id}/submitcancel":     0.2,
						"v1/order/orders/submitCancelClientOrder":     0.2,
						"v1/order/orders/batchCancelOpenOrders":       0.4,
						"v1/order/orders/batchcancel":                 0.4,
						"v2/algo-orders/cancel-all-after":             1,
						"v2/algo-orders":                              1,
						"v2/algo-orders/cancellation":                 1,
						"v2/account/repayment":                        5,
						"v1/dw/transfer-in/margin":                    10,
						"v1/dw/transfer-out/margin":                   10,
						"v1/margin/orders":                            10,
						"v1/margin/orders/{order-id}/repay":           10,
						"v1/cross-margin/transfer-in":                 1,
						"v1/cross-margin/transfer-out":                1,
						"v1/cross-margin/orders":                      1,
						"v1/cross-margin/orders/{order-id}/repay":     1,
						"v1/stable-coin/exchange":                     1,
						"v2/etp/creation":                             5,
						"v2/etp/redemption":                           5,
						"v2/etp/{transactId}/cancel":                  10,
						"v2/etp/batch-cancel":                         50,
					},
				},
			},
			"contract": map[string]interface{}{
				"public": map[string]interface{}{
					"get": map[string]interface{}{
						"api/v1/timestamp":                                      1,
						"heartbeat/":                                            1,
						"api/v1/contract_contract_info":                         1,
						"api/v1/contract_index":                                 1,
						"api/v1/contract_query_elements":                        1,
						"api/v1/contract_price_limit":                           1,
						"api/v1/contract_open_interest":                         1,
						"api/v1/contract_delivery_price":                        1,
						"market/depth":                                          1,
						"market/bbo":                                            1,
						"market/history/kline":                                  1,
						"index/market/history/mark_price_kline":                 1,
						"market/detail/merged":                                  1,
						"market/detail/batch_merged":                            1,
						"v2/market/detail/batch_merged":                         1,
						"market/trade":                                          1,
						"market/history/trade":                                  1,
						"api/v1/contract_risk_info":                             1,
						"api/v1/contract_insurance_fund":                        1,
						"api/v1/contract_adjustfactor":                          1,
						"api/v1/contract_his_open_interest":                     1,
						"api/v1/contract_ladder_margin":                         1,
						"api/v1/contract_api_state":                             1,
						"api/v1/contract_elite_account_ratio":                   1,
						"api/v1/contract_elite_position_ratio":                  1,
						"api/v1/contract_liquidation_orders":                    1,
						"api/v1/contract_settlement_records":                    1,
						"index/market/history/index":                            1,
						"index/market/history/basis":                            1,
						"api/v1/contract_estimated_settlement_price":            1,
						"api/v3/contract_liquidation_orders":                    1,
						"swap-api/v1/swap_contract_info":                        1,
						"swap-api/v1/swap_index":                                1,
						"swap-api/v1/swap_query_elements":                       1,
						"swap-api/v1/swap_price_limit":                          1,
						"swap-api/v1/swap_open_interest":                        1,
						"swap-ex/market/depth":                                  1,
						"swap-ex/market/bbo":                                    1,
						"swap-ex/market/history/kline":                          1,
						"index/market/history/swap_mark_price_kline":            1,
						"swap-ex/market/detail/merged":                          1,
						"v2/swap-ex/market/detail/batch_merged":                 1,
						"index/market/history/swap_premium_index_kline":         1,
						"swap-ex/market/detail/batch_merged":                    1,
						"swap-ex/market/trade":                                  1,
						"swap-ex/market/history/trade":                          1,
						"swap-api/v1/swap_risk_info":                            1,
						"swap-api/v1/swap_insurance_fund":                       1,
						"swap-api/v1/swap_adjustfactor":                         1,
						"swap-api/v1/swap_his_open_interest":                    1,
						"swap-api/v1/swap_ladder_margin":                        1,
						"swap-api/v1/swap_api_state":                            1,
						"swap-api/v1/swap_elite_account_ratio":                  1,
						"swap-api/v1/swap_elite_position_ratio":                 1,
						"swap-api/v1/swap_estimated_settlement_price":           1,
						"swap-api/v1/swap_liquidation_orders":                   1,
						"swap-api/v1/swap_settlement_records":                   1,
						"swap-api/v1/swap_funding_rate":                         1,
						"swap-api/v1/swap_batch_funding_rate":                   1,
						"swap-api/v1/swap_historical_funding_rate":              1,
						"swap-api/v3/swap_liquidation_orders":                   1,
						"index/market/history/swap_estimated_rate_kline":        1,
						"index/market/history/swap_basis":                       1,
						"linear-swap-api/v1/swap_contract_info":                 1,
						"linear-swap-api/v1/swap_index":                         1,
						"linear-swap-api/v1/swap_query_elements":                1,
						"linear-swap-api/v1/swap_price_limit":                   1,
						"linear-swap-api/v1/swap_open_interest":                 1,
						"linear-swap-ex/market/depth":                           1,
						"linear-swap-ex/market/bbo":                             1,
						"linear-swap-ex/market/history/kline":                   1,
						"index/market/history/linear_swap_mark_price_kline":     1,
						"linear-swap-ex/market/detail/merged":                   1,
						"linear-swap-ex/market/detail/batch_merged":             1,
						"v2/linear-swap-ex/market/detail/batch_merged":          1,
						"linear-swap-ex/market/trade":                           1,
						"linear-swap-ex/market/history/trade":                   1,
						"linear-swap-api/v1/swap_risk_info":                     1,
						"swap-api/v1/linear-swap-api/v1/swap_insurance_fund":    1,
						"linear-swap-api/v1/swap_adjustfactor":                  1,
						"linear-swap-api/v1/swap_cross_adjustfactor":            1,
						"linear-swap-api/v1/swap_his_open_interest":             1,
						"linear-swap-api/v1/swap_ladder_margin":                 1,
						"linear-swap-api/v1/swap_cross_ladder_margin":           1,
						"linear-swap-api/v1/swap_api_state":                     1,
						"linear-swap-api/v1/swap_cross_transfer_state":          1,
						"linear-swap-api/v1/swap_cross_trade_state":             1,
						"linear-swap-api/v1/swap_elite_account_ratio":           1,
						"linear-swap-api/v1/swap_elite_position_ratio":          1,
						"linear-swap-api/v1/swap_liquidation_orders":            1,
						"linear-swap-api/v1/swap_settlement_records":            1,
						"linear-swap-api/v1/swap_funding_rate":                  1,
						"linear-swap-api/v1/swap_batch_funding_rate":            1,
						"linear-swap-api/v1/swap_historical_funding_rate":       1,
						"linear-swap-api/v3/swap_liquidation_orders":            1,
						"index/market/history/linear_swap_premium_index_kline":  1,
						"index/market/history/linear_swap_estimated_rate_kline": 1,
						"index/market/history/linear_swap_basis":                1,
						"linear-swap-api/v1/swap_estimated_settlement_price":    1,
					},
				},
				"private": map[string]interface{}{
					"get": map[string]interface{}{
						"api/v1/contract_sub_auth_list":                        1,
						"api/v1/contract_api_trading_status":                   1,
						"swap-api/v1/swap_sub_auth_list":                       1,
						"swap-api/v1/swap_api_trading_status":                  1,
						"linear-swap-api/v1/swap_sub_auth_list":                1,
						"linear-swap-api/v1/swap_api_trading_status":           1,
						"linear-swap-api/v1/swap_cross_position_side":          1,
						"linear-swap-api/v1/swap_position_side":                1,
						"linear-swap-api/v3/unified_account_info":              1,
						"linear-swap-api/v3/fix_position_margin_change_record": 1,
						"linear-swap-api/v3/swap_unified_account_type":         1,
						"linear-swap-api/v3/linear_swap_overview_account_info": 1,
						"v5/account/balance":                                   1,
						"v5/account/asset_mode":                                1,
						"v5/trade/position/opens":                              1,
						"v5/trade/order/opens":                                 1,
						"v5/trade/order/details":                               1,
						"v5/trade/order/history":                               1,
						"v5/trade/order":                                       1,
						"v5/position/lever":                                    1,
						"v5/position/mode":                                     1,
						"v5/position/risk/limit":                               1,
						"v5/position/risk/limit_tier":                          1,
						"v5/market/risk/limit":                                 1,
						"v5/market/assets_deduction_currency":                  1,
						"v5/market/multi_assets_margin":                        1,
					},
					"post": map[string]interface{}{
						"api/v1/contract_balance_valuation":                      1,
						"api/v1/contract_account_info":                           1,
						"api/v1/contract_position_info":                          1,
						"api/v1/contract_sub_auth":                               1,
						"api/v1/contract_sub_account_list":                       1,
						"api/v1/contract_sub_account_info_list":                  1,
						"api/v1/contract_sub_account_info":                       1,
						"api/v1/contract_sub_position_info":                      1,
						"api/v1/contract_financial_record":                       1,
						"api/v1/contract_financial_record_exact":                 1,
						"api/v1/contract_user_settlement_records":                1,
						"api/v1/contract_order_limit":                            1,
						"api/v1/contract_fee":                                    1,
						"api/v1/contract_transfer_limit":                         1,
						"api/v1/contract_position_limit":                         1,
						"api/v1/contract_account_position_info":                  1,
						"api/v1/contract_master_sub_transfer":                    1,
						"api/v1/contract_master_sub_transfer_record":             1,
						"api/v1/contract_available_level_rate":                   1,
						"api/v3/contract_financial_record":                       1,
						"api/v3/contract_financial_record_exact":                 1,
						"api/v1/contract-cancel-after":                           1,
						"api/v1/contract_order":                                  1,
						"api/v1/contract_batchorder":                             1,
						"api/v1/contract_cancel":                                 1,
						"api/v1/contract_cancelall":                              1,
						"api/v1/contract_switch_lever_rate":                      30,
						"api/v1/lightning_close_position":                        1,
						"api/v1/contract_order_info":                             1,
						"api/v1/contract_order_detail":                           1,
						"api/v1/contract_openorders":                             1,
						"api/v1/contract_hisorders":                              1,
						"api/v1/contract_hisorders_exact":                        1,
						"api/v1/contract_matchresults":                           1,
						"api/v1/contract_matchresults_exact":                     1,
						"api/v3/contract_hisorders":                              1,
						"api/v3/contract_hisorders_exact":                        1,
						"api/v3/contract_matchresults":                           1,
						"api/v3/contract_matchresults_exact":                     1,
						"api/v1/contract_trigger_order":                          1,
						"api/v1/contract_trigger_cancel":                         1,
						"api/v1/contract_trigger_cancelall":                      1,
						"api/v1/contract_trigger_openorders":                     1,
						"api/v1/contract_trigger_hisorders":                      1,
						"api/v1/contract_tpsl_order":                             1,
						"api/v1/contract_tpsl_cancel":                            1,
						"api/v1/contract_tpsl_cancelall":                         1,
						"api/v1/contract_tpsl_openorders":                        1,
						"api/v1/contract_tpsl_hisorders":                         1,
						"api/v1/contract_relation_tpsl_order":                    1,
						"api/v1/contract_track_order":                            1,
						"api/v1/contract_track_cancel":                           1,
						"api/v1/contract_track_cancelall":                        1,
						"api/v1/contract_track_openorders":                       1,
						"api/v1/contract_track_hisorders":                        1,
						"swap-api/v1/swap_balance_valuation":                     1,
						"swap-api/v1/swap_account_info":                          1,
						"swap-api/v1/swap_position_info":                         1,
						"swap-api/v1/swap_account_position_info":                 1,
						"swap-api/v1/swap_sub_auth":                              1,
						"swap-api/v1/swap_sub_account_list":                      1,
						"swap-api/v1/swap_sub_account_info_list":                 1,
						"swap-api/v1/swap_sub_account_info":                      1,
						"swap-api/v1/swap_sub_position_info":                     1,
						"swap-api/v1/swap_financial_record":                      1,
						"swap-api/v1/swap_financial_record_exact":                1,
						"swap-api/v1/swap_user_settlement_records":               1,
						"swap-api/v1/swap_available_level_rate":                  1,
						"swap-api/v1/swap_order_limit":                           1,
						"swap-api/v1/swap_fee":                                   1,
						"swap-api/v1/swap_transfer_limit":                        1,
						"swap-api/v1/swap_position_limit":                        1,
						"swap-api/v1/swap_master_sub_transfer":                   1,
						"swap-api/v1/swap_master_sub_transfer_record":            1,
						"swap-api/v3/swap_financial_record":                      1,
						"swap-api/v3/swap_financial_record_exact":                1,
						"swap-api/v1/swap-cancel-after":                          1,
						"swap-api/v1/swap_order":                                 1,
						"swap-api/v1/swap_batchorder":                            1,
						"swap-api/v1/swap_cancel":                                1,
						"swap-api/v1/swap_cancelall":                             1,
						"swap-api/v1/swap_lightning_close_position":              1,
						"swap-api/v1/swap_switch_lever_rate":                     30,
						"swap-api/v1/swap_order_info":                            1,
						"swap-api/v1/swap_order_detail":                          1,
						"swap-api/v1/swap_openorders":                            1,
						"swap-api/v1/swap_hisorders":                             1,
						"swap-api/v1/swap_hisorders_exact":                       1,
						"swap-api/v1/swap_matchresults":                          1,
						"swap-api/v1/swap_matchresults_exact":                    1,
						"swap-api/v3/swap_matchresults":                          1,
						"swap-api/v3/swap_matchresults_exact":                    1,
						"swap-api/v3/swap_hisorders":                             1,
						"swap-api/v3/swap_hisorders_exact":                       1,
						"swap-api/v1/swap_trigger_order":                         1,
						"swap-api/v1/swap_trigger_cancel":                        1,
						"swap-api/v1/swap_trigger_cancelall":                     1,
						"swap-api/v1/swap_trigger_openorders":                    1,
						"swap-api/v1/swap_trigger_hisorders":                     1,
						"swap-api/v1/swap_tpsl_order":                            1,
						"swap-api/v1/swap_tpsl_cancel":                           1,
						"swap-api/v1/swap_tpsl_cancelall":                        1,
						"swap-api/v1/swap_tpsl_openorders":                       1,
						"swap-api/v1/swap_tpsl_hisorders":                        1,
						"swap-api/v1/swap_relation_tpsl_order":                   1,
						"swap-api/v1/swap_track_order":                           1,
						"swap-api/v1/swap_track_cancel":                          1,
						"swap-api/v1/swap_track_cancelall":                       1,
						"swap-api/v1/swap_track_openorders":                      1,
						"swap-api/v1/swap_track_hisorders":                       1,
						"linear-swap-api/v1/swap_lever_position_limit":           1,
						"linear-swap-api/v1/swap_cross_lever_position_limit":     1,
						"linear-swap-api/v1/swap_balance_valuation":              1,
						"linear-swap-api/v1/swap_account_info":                   1,
						"linear-swap-api/v1/swap_cross_account_info":             1,
						"linear-swap-api/v1/swap_position_info":                  1,
						"linear-swap-api/v1/swap_cross_position_info":            1,
						"linear-swap-api/v1/swap_account_position_info":          1,
						"linear-swap-api/v1/swap_cross_account_position_info":    1,
						"linear-swap-api/v1/swap_sub_auth":                       1,
						"linear-swap-api/v1/swap_sub_account_list":               1,
						"linear-swap-api/v1/swap_cross_sub_account_list":         1,
						"linear-swap-api/v1/swap_sub_account_info_list":          1,
						"linear-swap-api/v1/swap_cross_sub_account_info_list":    1,
						"linear-swap-api/v1/swap_sub_account_info":               1,
						"linear-swap-api/v1/swap_cross_sub_account_info":         1,
						"linear-swap-api/v1/swap_sub_position_info":              1,
						"linear-swap-api/v1/swap_cross_sub_position_info":        1,
						"linear-swap-api/v1/swap_financial_record":               1,
						"linear-swap-api/v1/swap_financial_record_exact":         1,
						"linear-swap-api/v1/swap_user_settlement_records":        1,
						"linear-swap-api/v1/swap_cross_user_settlement_records":  1,
						"linear-swap-api/v1/swap_available_level_rate":           1,
						"linear-swap-api/v1/swap_cross_available_level_rate":     1,
						"linear-swap-api/v1/swap_order_limit":                    1,
						"linear-swap-api/v1/swap_fee":                            1,
						"linear-swap-api/v1/swap_transfer_limit":                 1,
						"linear-swap-api/v1/swap_cross_transfer_limit":           1,
						"linear-swap-api/v1/swap_position_limit":                 1,
						"linear-swap-api/v1/swap_cross_position_limit":           1,
						"linear-swap-api/v1/swap_master_sub_transfer":            1,
						"linear-swap-api/v1/swap_master_sub_transfer_record":     1,
						"linear-swap-api/v1/swap_transfer_inner":                 1,
						"linear-swap-api/v3/swap_financial_record":               1,
						"linear-swap-api/v3/swap_financial_record_exact":         1,
						"linear-swap-api/v1/swap_order":                          1,
						"linear-swap-api/v1/swap_cross_order":                    1,
						"linear-swap-api/v1/swap_batchorder":                     1,
						"linear-swap-api/v1/swap_cross_batchorder":               1,
						"linear-swap-api/v1/swap_cancel":                         1,
						"linear-swap-api/v1/swap_cross_cancel":                   1,
						"linear-swap-api/v1/swap_cancelall":                      1,
						"linear-swap-api/v1/swap_cross_cancelall":                1,
						"linear-swap-api/v1/swap_switch_lever_rate":              30,
						"linear-swap-api/v1/swap_cross_switch_lever_rate":        30,
						"linear-swap-api/v1/swap_lightning_close_position":       1,
						"linear-swap-api/v1/swap_cross_lightning_close_position": 1,
						"linear-swap-api/v1/swap_order_info":                     1,
						"linear-swap-api/v1/swap_cross_order_info":               1,
						"linear-swap-api/v1/swap_order_detail":                   1,
						"linear-swap-api/v1/swap_cross_order_detail":             1,
						"linear-swap-api/v1/swap_openorders":                     1,
						"linear-swap-api/v1/swap_cross_openorders":               1,
						"linear-swap-api/v1/swap_hisorders":                      1,
						"linear-swap-api/v1/swap_cross_hisorders":                1,
						"linear-swap-api/v1/swap_hisorders_exact":                1,
						"linear-swap-api/v1/swap_cross_hisorders_exact":          1,
						"linear-swap-api/v1/swap_matchresults":                   1,
						"linear-swap-api/v1/swap_cross_matchresults":             1,
						"linear-swap-api/v1/swap_matchresults_exact":             1,
						"linear-swap-api/v1/swap_cross_matchresults_exact":       1,
						"linear-swap-api/v1/linear-cancel-after":                 1,
						"linear-swap-api/v1/swap_switch_position_mode":           1,
						"linear-swap-api/v1/swap_cross_switch_position_mode":     1,
						"linear-swap-api/v3/swap_matchresults":                   1,
						"linear-swap-api/v3/swap_cross_matchresults":             1,
						"linear-swap-api/v3/swap_matchresults_exact":             1,
						"linear-swap-api/v3/swap_cross_matchresults_exact":       1,
						"linear-swap-api/v3/swap_hisorders":                      1,
						"linear-swap-api/v3/swap_cross_hisorders":                1,
						"linear-swap-api/v3/swap_hisorders_exact":                1,
						"linear-swap-api/v3/swap_cross_hisorders_exact":          1,
						"linear-swap-api/v3/fix_position_margin_change":          1,
						"linear-swap-api/v3/swap_switch_account_type":            1,
						"linear-swap-api/v3/linear_swap_fee_switch":              1,
						"linear-swap-api/v1/swap_trigger_order":                  1,
						"linear-swap-api/v1/swap_cross_trigger_order":            1,
						"linear-swap-api/v1/swap_trigger_cancel":                 1,
						"linear-swap-api/v1/swap_cross_trigger_cancel":           1,
						"linear-swap-api/v1/swap_trigger_cancelall":              1,
						"linear-swap-api/v1/swap_cross_trigger_cancelall":        1,
						"linear-swap-api/v1/swap_trigger_openorders":             1,
						"linear-swap-api/v1/swap_cross_trigger_openorders":       1,
						"linear-swap-api/v1/swap_trigger_hisorders":              1,
						"linear-swap-api/v1/swap_cross_trigger_hisorders":        1,
						"linear-swap-api/v1/swap_tpsl_order":                     1,
						"linear-swap-api/v1/swap_cross_tpsl_order":               1,
						"linear-swap-api/v1/swap_tpsl_cancel":                    1,
						"linear-swap-api/v1/swap_cross_tpsl_cancel":              1,
						"linear-swap-api/v1/swap_tpsl_cancelall":                 1,
						"linear-swap-api/v1/swap_cross_tpsl_cancelall":           1,
						"linear-swap-api/v1/swap_tpsl_openorders":                1,
						"linear-swap-api/v1/swap_cross_tpsl_openorders":          1,
						"linear-swap-api/v1/swap_tpsl_hisorders":                 1,
						"linear-swap-api/v1/swap_cross_tpsl_hisorders":           1,
						"linear-swap-api/v1/swap_relation_tpsl_order":            1,
						"linear-swap-api/v1/swap_cross_relation_tpsl_order":      1,
						"linear-swap-api/v1/swap_track_order":                    1,
						"linear-swap-api/v1/swap_cross_track_order":              1,
						"linear-swap-api/v1/swap_track_cancel":                   1,
						"linear-swap-api/v1/swap_cross_track_cancel":             1,
						"linear-swap-api/v1/swap_track_cancelall":                1,
						"linear-swap-api/v1/swap_cross_track_cancelall":          1,
						"linear-swap-api/v1/swap_track_openorders":               1,
						"linear-swap-api/v1/swap_cross_track_openorders":         1,
						"linear-swap-api/v1/swap_track_hisorders":                1,
						"linear-swap-api/v1/swap_cross_track_hisorders":          1,
						"v5/account/asset_mode":                                  1,
						"v5/trade/order":                                         1,
						"v5/trade/batch_orders":                                  1,
						"v5/trade/cancel_order":                                  1,
						"v5/trade/cancel_batch_orders":                           1,
						"v5/trade/cancel_all_orders":                             1,
						"v5/trade/position":                                      1,
						"v5/trade/position_all":                                  1,
						"v5/position/lever":                                      1,
						"v5/position/mode":                                       1,
						"v5/account/fee_deduction_currency":                      1,
					},
				},
			},
		},
		"fees": map[string]interface{}{
			"trading": map[string]interface{}{
				"feeSide":    "get",
				"tierBased":  false,
				"percentage": true,
				"maker":      this.ParseNumber("0.002"),
				"taker":      this.ParseNumber("0.002"),
			},
		},
		"exceptions": map[string]interface{}{
			"broad": map[string]interface{}{
				"contract is restricted of closing positions on API.  Please contact customer service": OnMaintenance,
				"maintain":                  OnMaintenance,
				"API key has no permission": PermissionDenied,
			},
			"exact": map[string]interface{}{
				"403":                             AuthenticationError,
				"1010":                            AccountNotEnabled,
				"1003":                            AuthenticationError,
				"1013":                            BadSymbol,
				"1017":                            OrderNotFound,
				"1034":                            InvalidOrder,
				"1036":                            InvalidOrder,
				"1039":                            InvalidOrder,
				"1041":                            InvalidOrder,
				"1047":                            InsufficientFunds,
				"1048":                            InsufficientFunds,
				"1061":                            OrderNotFound,
				"1051":                            InvalidOrder,
				"1066":                            BadSymbol,
				"1067":                            InvalidOrder,
				"1094":                            InvalidOrder,
				"1220":                            AccountNotEnabled,
				"1303":                            BadRequest,
				"1461":                            InvalidOrder,
				"4007":                            BadRequest,
				"bad-request":                     BadRequest,
				"validation-format-error":         BadRequest,
				"validation-constraints-required": BadRequest,
				"base-date-limit-error":           BadRequest,
				"api-not-support-temp-addr":       PermissionDenied,
				"timeout":                         RequestTimeout,
				"gateway-internal-error":          ExchangeNotAvailable,
				"account-frozen-balance-insufficient-error": InsufficientFunds,
				"invalid-amount":                        InvalidOrder,
				"order-limitorder-amount-min-error":     InvalidOrder,
				"order-limitorder-amount-max-error":     InvalidOrder,
				"order-marketorder-amount-min-error":    InvalidOrder,
				"order-limitorder-price-min-error":      InvalidOrder,
				"order-limitorder-price-max-error":      InvalidOrder,
				"order-limitorder-price-buy-min-error":  InvalidOrder,
				"order-limitorder-price-buy-max-error":  InvalidOrder,
				"order-limitorder-price-sell-min-error": InvalidOrder,
				"order-limitorder-price-sell-max-error": InvalidOrder,
				"order-stop-order-hit-trigger":          InvalidOrder,
				"order-value-min-error":                 InvalidOrder,
				"order-invalid-price":                   InvalidOrder,
				"order-holding-limit-failed":            InvalidOrder,
				"order-orderprice-precision-error":      InvalidOrder,
				"order-etp-nav-price-max-error":         InvalidOrder,
				"order-orderstate-error":                OrderNotFound,
				"order-queryorder-invalid":              OrderNotFound,
				"order-update-error":                    ExchangeNotAvailable,
				"api-signature-check-failed":            AuthenticationError,
				"api-signature-not-valid":               AuthenticationError,
				"base-record-invalid":                   OrderNotFound,
				"base-symbol-trade-disabled":            BadSymbol,
				"base-symbol-error":                     BadSymbol,
				"system-maintenance":                    OnMaintenance,
				"base-request-exceed-frequency-limit":   RateLimitExceeded,
				"rate-too-many-requests":                RateLimitExceeded,
				"invalid symbol":                        BadSymbol,
				"symbol trade not open now":             BadSymbol,
				"require-symbol":                        BadSymbol,
				"invalid-address":                       BadRequest,
				"base-currency-chain-error":             BadRequest,
				"dw-insufficient-balance":               InsufficientFunds,
				"base-withdraw-fee-error":               BadRequest,
				"dw-withdraw-min-limit":                 BadRequest,
				"request limit":                         RateLimitExceeded,
			},
		},
		"precisionMode": TICK_SIZE,
		"options": map[string]interface{}{
			"include_OS_certificates": false,
			"fetchMarkets": map[string]interface{}{
				"types": map[string]interface{}{
					"spot":    true,
					"linear":  true,
					"inverse": true,
				},
			},
			"timeDifference":          0,
			"adjustForTimeDifference": false,
			"fetchOHLCV": map[string]interface{}{
				"useHistoricalEndpointForSpot": true,
			},
			"withdraw": map[string]interface{}{
				"includeFee": false,
			},
			"defaultType":    "spot",
			"defaultSubType": "linear",
			"defaultNetwork": "ERC20",
			"defaultNetworks": map[string]interface{}{
				"ETH":  "ERC20",
				"BTC":  "BTC",
				"USDT": "TRC20",
			},
			"networks": map[string]interface{}{
				"TRC20":     "TRX",
				"BTC":       "BTC",
				"ERC20":     "ETH",
				"SOL":       "SOLANA",
				"HRC20":     "HECO",
				"BEP20":     "BSC",
				"XMR":       "XMR",
				"LTC":       "LTC",
				"XRP":       "XRP",
				"XLM":       "XLM",
				"CRONOS":    "CRO",
				"CRO":       "CRO",
				"GLMR":      "GLMR",
				"POLYGON":   "MATIC",
				"MATIC":     "MATIC",
				"BTT":       "BTT",
				"CUBE":      "CUBE",
				"IOST":      "IOST",
				"NEO":       "NEO",
				"KLAY":      "KLAY",
				"EOS":       "EOS",
				"THETA":     "THETA",
				"NAS":       "NAS",
				"NULS":      "NULS",
				"QTUM":      "QTUM",
				"FTM":       "FTM",
				"CELO":      "CELO",
				"DOGE":      "DOGE",
				"DOGECHAIN": "DOGECHAIN",
				"NEAR":      "NEAR",
				"STEP":      "STEP",
				"BITCI":     "BITCI",
				"CARDANO":   "ADA",
				"ADA":       "ADA",
				"ETC":       "ETC",
				"LUK":       "LUK",
				"MINEPLEX":  "MINEPLEX",
				"DASH":      "DASH",
				"ZEC":       "ZEC",
				"IOTA":      "IOTA",
				"NEON3":     "NEON3",
				"XEM":       "XEM",
				"HC":        "HC",
				"LSK":       "LSK",
				"DCR":       "DCR",
				"BTG":       "BTG",
				"STEEM":     "STEEM",
				"BTS":       "BTS",
				"ICX":       "ICX",
				"WAVES":     "WAVES",
				"CMT":       "CMT",
				"BTM":       "BTM",
				"VET":       "VET",
				"XZC":       "XZC",
				"ACT":       "ACT",
				"SMT":       "SMT",
				"BCD":       "BCD",
				"WAX":       "WAX1",
				"WICC":      "WICC",
				"ELF":       "ELF",
				"ZIL":       "ZIL",
				"ELA":       "ELA",
				"BCX":       "BCX",
				"SBTC":      "SBTC",
				"BIFI":      "BIFI",
				"CTXC":      "CTXC",
				"WAN":       "WAN",
				"POLYX":     "POLYX",
				"PAI":       "PAI",
				"WTC":       "WTC",
				"DGB":       "DGB",
				"XVG":       "XVG",
				"AAC":       "AAC",
				"AE":        "AE",
				"SEELE":     "SEELE",
				"BCV":       "BCV",
				"GRS":       "GRS",
				"ARDR":      "ARDR",
				"NANO":      "NANO",
				"ZEN":       "ZEN",
				"RBTC":      "RBTC",
				"BSV":       "BSV",
				"GAS":       "GAS",
				"XTZ":       "XTZ",
				"LAMB":      "LAMB",
				"CVNT1":     "CVNT1",
				"DOCK":      "DOCK",
				"SC":        "SC",
				"KMD":       "KMD",
				"ETN":       "ETN",
				"TOP":       "TOP",
				"IRIS":      "IRIS",
				"UGAS":      "UGAS",
				"TT":        "TT",
				"NEWTON":    "NEWTON",
				"VSYS":      "VSYS",
				"FSN":       "FSN",
				"BHD":       "BHD",
				"ONE":       "ONE",
				"EM":        "EM",
				"CKB":       "CKB",
				"EOSS":      "EOSS",
				"HIVE":      "HIVE",
				"RVN":       "RVN",
				"DOT":       "DOT",
				"KSM":       "KSM",
				"BAND":      "BAND",
				"OEP4":      "OEP4",
				"NBS":       "NBS",
				"FIS":       "FIS",
				"AR":        "AR",
				"HBAR":      "HBAR",
				"FIL":       "FIL",
				"MASS":      "MASS",
				"KAVA":      "KAVA",
				"XYM":       "XYM",
				"ENJ":       "ENJ",
				"CRUST":     "CRUST",
				"ICP":       "ICP",
				"CSPR":      "CSPR",
				"FLOW":      "FLOW",
				"IOTX":      "IOTX",
				"LAT":       "LAT",
				"APT":       "APT",
				"XCH":       "XCH",
				"MINA":      "MINA",
				"XEC":       "ECASH",
				"XPRT":      "XPRT",
				"CCA":       "ACA",
				"AOTI":      "COTI",
				"AKT":       "AKT",
				"ARS":       "ARS",
				"ASTR":      "ASTR",
				"AZERO":     "AZERO",
				"BLD":       "BLD",
				"BRISE":     "BRISE",
				"CORE":      "CORE",
				"DESO":      "DESO",
				"DFI":       "DFI",
				"EGLD":      "EGLD",
				"ERG":       "ERG",
				"ETHF":      "ETHFAIR",
				"ETHW":      "ETHW",
				"EVMOS":     "EVMOS",
				"FIO":       "FIO",
				"FLR":       "FLR",
				"FINSCHIA":  "FINSCHIA",
				"KMA":       "KMA",
				"KYVE":      "KYVE",
				"MEV":       "MEV",
				"MOVR":      "MOVR",
				"NODL":      "NODL",
				"OAS":       "OAS",
				"OSMO":      "OSMO",
				"PAYCOIN":   "PAYCOIN",
				"POKT":      "POKT",
				"PYG":       "PYG",
				"REI":       "REI",
				"SCRT":      "SCRT",
				"SDN":       "SDN",
				"SEI":       "SEI",
				"SGB":       "SGB",
				"SUI":       "SUI",
				"SXP":       "SOLAR",
				"SYS":       "SYS",
				"TENET":     "TENET",
				"TON":       "TON",
				"UNQ":       "UNQ",
				"UYU":       "UYU",
				"WEMIX":     "WEMIX",
				"XDC":       "XDC",
				"XPLA":      "XPLA",
			},
			"fetchOrdersByStatesMethod":         "spot_private_get_v1_order_orders",
			"createMarketBuyOrderRequiresPrice": true,
			"language":                          "en-US",
			"broker": map[string]interface{}{
				"id": "AA03022abc",
			},
			"accountsByType": map[string]interface{}{
				"spot":    "pro",
				"funding": "pro",
				"future":  "futures",
			},
			"accountsById": map[string]interface{}{
				"spot":            "spot",
				"margin":          "margin",
				"otc":             "otc",
				"point":           "point",
				"super-margin":    "super-margin",
				"investment":      "investment",
				"borrow":          "borrow",
				"grid-trading":    "grid-trading",
				"deposit-earning": "deposit-earning",
				"otc-options":     "otc-options",
			},
			"typesByAccount": map[string]interface{}{
				"pro":     "spot",
				"futures": "future",
			},
			"spot": map[string]interface{}{
				"stopOrderTypes": map[string]interface{}{
					"stop-limit":          true,
					"buy-stop-limit":      true,
					"sell-stop-limit":     true,
					"stop-limit-fok":      true,
					"buy-stop-limit-fok":  true,
					"sell-stop-limit-fok": true,
				},
				"limitOrderTypes": map[string]interface{}{
					"limit":               true,
					"buy-limit":           true,
					"sell-limit":          true,
					"ioc":                 true,
					"buy-ioc":             true,
					"sell-ioc":            true,
					"limit-maker":         true,
					"buy-limit-maker":     true,
					"sell-limit-maker":    true,
					"stop-limit":          true,
					"buy-stop-limit":      true,
					"sell-stop-limit":     true,
					"limit-fok":           true,
					"buy-limit-fok":       true,
					"sell-limit-fok":      true,
					"stop-limit-fok":      true,
					"buy-stop-limit-fok":  true,
					"sell-stop-limit-fok": true,
				},
			},
		},
		"commonCurrencies": map[string]interface{}{
			"NGL":  "GFNGL",
			"GET":  "THEMIS",
			"GTC":  "GAMECOM",
			"HIT":  "HITCHAIN",
			"PNT":  "PENTA",
			"SBTC": "SUPERBITCOIN",
			"SOUL": "SOULSAVER",
			"BIFI": "BITCOINFILE",
			"FUD":  "FTX Users Debt",
		},
		"features": map[string]interface{}{
			"spot": map[string]interface{}{
				"sandbox": true,
				"createOrder": map[string]interface{}{
					"marginMode":                 true,
					"triggerPrice":               true,
					"triggerDirection":           true,
					"triggerPriceType":           nil,
					"stopLossPrice":              false,
					"takeProfitPrice":            false,
					"attachedStopLossTakeProfit": nil,
					"timeInForce": map[string]interface{}{
						"IOC": true,
						"FOK": true,
						"PO":  true,
						"GTD": false,
					},
					"hedged":                 false,
					"trailing":               false,
					"iceberg":                false,
					"selfTradePrevention":    true,
					"leverage":               true,
					"marketBuyByCost":        true,
					"marketBuyRequiresPrice": true,
				},
				"createOrders": map[string]interface{}{
					"max": 10,
				},
				"fetchMyTrades": map[string]interface{}{
					"marginMode":     false,
					"limit":          500,
					"daysBack":       120,
					"untilDays":      2,
					"symbolRequired": false,
				},
				"fetchOrder": map[string]interface{}{
					"marginMode":     false,
					"trigger":        false,
					"trailing":       false,
					"symbolRequired": false,
				},
				"fetchOpenOrders": map[string]interface{}{
					"marginMode":     false,
					"trigger":        true,
					"trailing":       false,
					"limit":          500,
					"symbolRequired": false,
				},
				"fetchOrders": map[string]interface{}{
					"marginMode":     false,
					"trigger":        true,
					"trailing":       false,
					"limit":          500,
					"untilDays":      2,
					"daysBack":       180,
					"symbolRequired": false,
				},
				"fetchClosedOrders": map[string]interface{}{
					"marginMode":       false,
					"trigger":          true,
					"trailing":         false,
					"untilDays":        2,
					"limit":            500,
					"daysBack":         180,
					"daysBackCanceled": Divide(1, 12),
					"symbolRequired":   false,
				},
				"fetchOHLCV": map[string]interface{}{
					"limit": 1000,
				},
			},
			"forDerivatives": map[string]interface{}{
				"extends": "spot",
				"createOrder": map[string]interface{}{
					"stopLossPrice":   true,
					"takeProfitPrice": true,
					"trailing":        true,
					"hedged":          true,
				},
				"createOrders": map[string]interface{}{
					"max": 25,
				},
				"fetchOrder": map[string]interface{}{
					"marginMode": true,
				},
				"fetchOpenOrders": map[string]interface{}{
					"marginMode": true,
					"trigger":    false,
					"trailing":   false,
					"limit":      50,
				},
				"fetchOrders": map[string]interface{}{
					"marginMode": true,
					"trigger":    false,
					"trailing":   false,
					"limit":      50,
					"daysBack":   90,
				},
				"fetchClosedOrders": map[string]interface{}{
					"marginMode":       true,
					"trigger":          false,
					"trailing":         false,
					"untilDays":        2,
					"limit":            50,
					"daysBack":         90,
					"daysBackCanceled": Divide(1, 12),
				},
				"fetchOHLCV": map[string]interface{}{
					"limit": 2000,
				},
			},
			"swap": map[string]interface{}{
				"linear": map[string]interface{}{
					"extends": "forDerivatives",
				},
				"inverse": map[string]interface{}{
					"extends": "forDerivatives",
				},
			},
			"future": map[string]interface{}{
				"linear": map[string]interface{}{
					"extends": "forDerivatives",
				},
				"inverse": map[string]interface{}{
					"extends": "forDerivatives",
				},
			},
		},
	})
}

/**
 * @method
 * @name htx#fetchStatus
 * @description the latest known information on the availability of the exchange API
 * @see https://huobiapi.github.io/docs/spot/v1/en/#get-system-status
 * @see https://huobiapi.github.io/docs/dm/v1/en/#get-system-status
 * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#get-system-status
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#get-system-status
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#query-whether-the-system-is-available  // contractPublicGetHeartbeat
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [status structure]{@link https://docs.ccxt.com/?id=exchange-status-structure}
 */
func (this *HtxCore) FetchStatus(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes14168 := (<-this.LoadMarkets())
		PanicOnError(retRes14168)
		var marketType interface{} = nil
		marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchStatus", nil, params)
		marketType = GetValue(marketTypeparamsVariable, 0)
		params = GetValue(marketTypeparamsVariable, 1)
		var enabledForContracts interface{} = this.HandleOption("fetchStatus", "enableForContracts", false) // temp fix for: https://status-linear-swap.huobigroup.com/api/v2/summary.json
		var response interface{} = nil
		if IsTrue(IsTrue(!IsEqual(marketType, "spot")) && IsTrue(enabledForContracts)) {
			var subType interface{} = this.SafeString(params, "subType", GetValue(this.Options, "defaultSubType"))
			if IsTrue(IsEqual(marketType, "swap")) {
				if IsTrue(IsEqual(subType, "linear")) {

					response = (<-this.StatusPublicSwapLinearGetApiV2SummaryJson())
					PanicOnError(response)
				} else if IsTrue(IsEqual(subType, "inverse")) {

					response = (<-this.StatusPublicSwapInverseGetApiV2SummaryJson())
					PanicOnError(response)
				}
			} else if IsTrue(IsEqual(marketType, "future")) {
				if IsTrue(IsEqual(subType, "linear")) {

					response = (<-this.StatusPublicFutureLinearGetApiV2SummaryJson())
					PanicOnError(response)
				} else if IsTrue(IsEqual(subType, "inverse")) {

					response = (<-this.StatusPublicFutureInverseGetApiV2SummaryJson())
					PanicOnError(response)
				}
			} else if IsTrue(IsEqual(marketType, "contract")) {

				response = (<-this.ContractPublicGetHeartbeat())
				PanicOnError(response)
			}
		} else if IsTrue(IsEqual(marketType, "spot")) {

			response = (<-this.StatusPublicSpotGetApiV2SummaryJson())
			PanicOnError(response)
		}
		//
		// statusPublicSpotGetApiV2SummaryJson, statusPublicSwapInverseGetApiV2SummaryJson, statusPublicFutureLinearGetApiV2SummaryJson, statusPublicFutureInverseGetApiV2SummaryJson
		//
		//      {
		//          "page": {
		//              "id":"mn7l2lw8pz4p",
		//              "name":"Huobi Futures-USDT-margined Swaps",
		//              "url":"https://status-linear-swap.huobigroup.com",
		//              "time_zone":"Asia/Singapore",
		//              "updated_at":"2022-04-29T12:47:21.319+08:00"},
		//              "components": [
		//                  {
		//                      "id":"lrv093qk3yp5",
		//                      "name":"market data",
		//                      "status":"operational",
		//                      "created_at":"2020-10-29T14:08:59.427+08:00",
		//                      "updated_at":"2020-10-29T14:08:59.427+08:00",
		//                      "position":1,"description":null,
		//                      "showcase":false,
		//                      "start_date":null,
		//                      "group_id":null,
		//                      "page_id":"mn7l2lw8pz4p",
		//                      "group":true,
		//                      "only_show_if_degraded":false,
		//                      "components": [
		//                          "82k5jxg7ltxd" // list of related components
		//                      ]
		//                  },
		//              ],
		//              "incidents": [ // empty array if there are no issues
		//                  {
		//                      "id": "rclfxz2g21ly",  // incident id
		//                      "name": "Market data is delayed",  // incident name
		//                      "status": "investigating",  // incident status
		//                      "created_at": "2020-02-11T03:15:01.913Z",  // incident create time
		//                      "updated_at": "2020-02-11T03:15:02.003Z",   // incident update time
		//                      "monitoring_at": null,
		//                      "resolved_at": null,
		//                      "impact": "minor",  // incident impact
		//                      "shortlink": "http://stspg.io/pkvbwp8jppf9",
		//                      "started_at": "2020-02-11T03:15:01.906Z",
		//                      "page_id": "p0qjfl24znv5",
		//                      "incident_updates": [
		//                          {
		//                              "id": "dwfsk5ttyvtb",
		//                              "status": "investigating",
		//                              "body": "Market data is delayed",
		//                              "incident_id": "rclfxz2g21ly",
		//                              "created_at": "2020-02-11T03:15:02.000Z",
		//                              "updated_at": "2020-02-11T03:15:02.000Z",
		//                              "display_at": "2020-02-11T03:15:02.000Z",
		//                              "affected_components": [
		//                                  {
		//                                      "code": "nctwm9tghxh6",
		//                                      "name": "Market data",
		//                                      "old_status": "operational",
		//                                      "new_status": "degraded_performance"
		//                                  }
		//                              ],
		//                              "deliver_notifications": true,
		//                              "custom_tweet": null,
		//                              "tweet_id": null
		//                          }
		//                      ],
		//                      "components": [
		//                          {
		//                              "id": "nctwm9tghxh6",
		//                              "name": "Market data",
		//                              "status": "degraded_performance",
		//                              "created_at": "2020-01-13T09:34:48.284Z",
		//                              "updated_at": "2020-02-11T03:15:01.951Z",
		//                              "position": 8,
		//                              "description": null,
		//                              "showcase": false,
		//                              "group_id": null,
		//                              "page_id": "p0qjfl24znv5",
		//                              "group": false,
		//                              "only_show_if_degraded": false
		//                          }
		//                      ]
		//                  }, ...
		//              ],
		//              "scheduled_maintenances":[ // empty array if there are no scheduled maintenances
		//                  {
		//                      "id": "k7g299zl765l", // incident id
		//                      "name": "Schedule maintenance", // incident name
		//                      "status": "scheduled", // incident status
		//                      "created_at": "2020-02-11T03:16:31.481Z",  // incident create time
		//                      "updated_at": "2020-02-11T03:16:31.530Z",  // incident update time
		//                      "monitoring_at": null,
		//                      "resolved_at": null,
		//                      "impact": "maintenance",  // incident impact
		//                      "shortlink": "http://stspg.io/md4t4ym7nytd",
		//                      "started_at": "2020-02-11T03:16:31.474Z",
		//                      "page_id": "p0qjfl24znv5",
		//                      "incident_updates": [
		//                          {
		//                              "id": "8whgr3rlbld8",
		//                              "status": "scheduled",
		//                              "body": "We will be undergoing scheduled maintenance during this time.",
		//                              "incident_id": "k7g299zl765l",
		//                              "created_at": "2020-02-11T03:16:31.527Z",
		//                              "updated_at": "2020-02-11T03:16:31.527Z",
		//                              "display_at": "2020-02-11T03:16:31.527Z",
		//                              "affected_components": [
		//                                  {
		//                                      "code": "h028tnzw1n5l",
		//                                      "name": "Deposit And Withdraw - Deposit",
		//                                      "old_status": "operational",
		//                                      "new_status": "operational"
		//                                  }
		//                              ],
		//                              "deliver_notifications": true,
		//                              "custom_tweet": null,
		//                              "tweet_id": null
		//                          }
		//                      ],
		//                      "components": [
		//                          {
		//                              "id": "h028tnzw1n5l",
		//                              "name": "Deposit",
		//                              "status": "operational",
		//                              "created_at": "2019-12-05T02:07:12.372Z",
		//                              "updated_at": "2020-02-10T12:34:52.970Z",
		//                              "position": 1,
		//                              "description": null,
		//                              "showcase": false,
		//                              "group_id": "gtd0nyr3pf0k",
		//                              "page_id": "p0qjfl24znv5",
		//                              "group": false,
		//                              "only_show_if_degraded": false
		//                          }
		//                      ],
		//                      "scheduled_for": "2020-02-15T00:00:00.000Z",  // scheduled maintenance start time
		//                      "scheduled_until": "2020-02-15T01:00:00.000Z"  // scheduled maintenance end time
		//                  }
		//              ],
		//              "status": {
		//                  "indicator":"none", // none, minor, major, critical, maintenance
		//                  "description":"all systems operational" // All Systems Operational, Minor Service Outage, Partial System Outage, Partially Degraded Service, Service Under Maintenance
		//              }
		//          }
		//
		//
		// contractPublicGetHeartbeat
		//
		//      {
		//          "status": "ok", // 'ok', 'error'
		//          "data": {
		//              "heartbeat": 1, // future 1: available, 0: maintenance with service suspended
		//              "estimated_recovery_time": null, // estimated recovery time in milliseconds
		//              "swap_heartbeat": 1,
		//              "swap_estimated_recovery_time": null,
		//              "option_heartbeat": 1,
		//              "option_estimated_recovery_time": null,
		//              "linear_swap_heartbeat": 1,
		//              "linear_swap_estimated_recovery_time": null
		//          },
		//          "ts": 1557714418033
		//      }
		//
		var status interface{} = nil
		var updated interface{} = nil
		var url interface{} = nil
		if IsTrue(IsEqual(marketType, "contract")) {
			var statusRaw interface{} = this.SafeString(response, "status")
			if IsTrue(IsEqual(statusRaw, nil)) {
				status = nil
			} else {
				status = Ternary(IsTrue((IsEqual(statusRaw, "ok"))), "ok", "maintenance") // 'ok', 'error'
			}
			updated = this.SafeString(response, "ts")
		} else {
			var statusData interface{} = this.SafeValue(response, "status", map[string]interface{}{})
			var statusRaw interface{} = this.SafeString(statusData, "indicator")
			status = Ternary(IsTrue((IsEqual(statusRaw, "none"))), "ok", "maintenance") // none, minor, major, critical, maintenance
			var pageData interface{} = this.SafeValue(response, "page", map[string]interface{}{})
			var datetime interface{} = this.SafeString(pageData, "updated_at")
			updated = this.Parse8601(datetime)
			url = this.SafeString(pageData, "url")
		}

		ch <- map[string]interface{}{
			"status":  status,
			"updated": updated,
			"eta":     nil,
			"url":     url,
			"info":    response,
		}
		return nil

	}()
	return ch
}

/**
 * @method
 * @name htx#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @see https://huobiapi.github.io/docs/spot/v1/en/#get-current-timestamp
 * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#get-current-system-timestamp
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func (this *HtxCore) FetchTime(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		var options interface{} = this.SafeValue(this.Options, "fetchTime", map[string]interface{}{})
		var defaultType interface{} = this.SafeString(this.Options, "defaultType", "spot")
		var typeVar interface{} = this.SafeString(options, "type", defaultType)
		typeVar = this.SafeString(params, "type", typeVar)
		var response interface{} = nil
		if IsTrue(IsTrue((IsEqual(typeVar, "future"))) || IsTrue((IsEqual(typeVar, "swap")))) {

			response = (<-this.ContractPublicGetApiV1Timestamp(params))
			PanicOnError(response)
		} else {

			response = (<-this.SpotPublicGetV1CommonTimestamp(params))
			PanicOnError(response)
		}

		//
		// spot
		//
		//     {"status":"ok","data":1637504261099}
		//
		// future, swap
		//
		//     {"status":"ok","ts":1637504164707}
		//
		ch <- this.SafeInteger2(response, "data", "ts")
		return nil

	}()
	return ch
}
func (this *HtxCore) ParseTradingFee(fee interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "symbol":"btcusdt",
	//         "actualMakerRate":"0.002",
	//         "actualTakerRate":"0.002",
	//         "takerFeeRate":"0.002",
	//         "makerFeeRate":"0.002"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(fee, "symbol")
	return map[string]interface{}{
		"info":       fee,
		"symbol":     this.SafeSymbol(marketId, market),
		"maker":      this.SafeNumber(fee, "actualMakerRate"),
		"taker":      this.SafeNumber(fee, "actualTakerRate"),
		"percentage": nil,
		"tierBased":  nil,
	}
}

/**
 * @method
 * @name htx#fetchTradingFee
 * @description fetch the trading fees for a market
 * @see https://huobiapi.github.io/docs/spot/v1/en/#get-current-fee-rate-applied-to-the-user
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [fee structure]{@link https://docs.ccxt.com/?id=fee-structure}
 */
func (this *HtxCore) FetchTradingFee(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes16948 := (<-this.LoadMarkets())
		PanicOnError(retRes16948)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbols": GetValue(market, "id"),
		}

		response := (<-this.SpotPrivateGetV2ReferenceTransactFeeRate(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code":200,
		//         "data":[
		//             {
		//                 "symbol":"btcusdt",
		//                 "actualMakerRate":"0.002",
		//                 "actualTakerRate":"0.002",
		//                 "takerFeeRate":"0.002",
		//                 "makerFeeRate":"0.002"
		//             }
		//         ],
		//         "success":true
		//     }
		//
		var data interface{} = this.SafeValue(response, "data", []interface{}{})
		var first interface{} = this.SafeValue(data, 0, map[string]interface{}{})

		ch <- this.ParseTradingFee(first, market)
		return nil

	}()
	return ch
}
func (this *HtxCore) FetchTradingLimits(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		// this method should not be called directly, use loadTradingLimits () instead
		//  by default it will try load withdrawal fees of all currencies (with separate requests)
		//  however if you define symbols = [ 'ETH/BTC', 'LTC/BTC' ] in args it will only load those
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes17248 := (<-this.LoadMarkets())
		PanicOnError(retRes17248)
		if IsTrue(IsEqual(symbols, nil)) {
			symbols = this.Symbols
		}
		var result interface{} = map[string]interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(symbols)); i++ {
			var symbol interface{} = GetValue(symbols, i)
			AddElementToObject(result, symbol, (<-this.FetchTradingLimitsById(this.MarketId(symbol), params)))
		}

		ch <- result
		return nil

	}()
	return ch
}

/**
 * @ignore
 * @method
 * @name htx#fetchTradingLimitsById
 * @see https://huobiapi.github.io/docs/spot/v1/en/#get-current-fee-rate-applied-to-the-user
 * @param {string} id market id
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} the limits object of a market structure
 */
func (this *HtxCore) FetchTradingLimitsById(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		var request interface{} = map[string]interface{}{
			"symbol": id,
		}

		response := (<-this.SpotPublicGetV1CommonExchange(this.Extend(request, params)))
		PanicOnError(response)

		//
		//     { status:   "ok",
		//         "data": {                                  symbol: "aidocbtc",
		//                              "buy-limit-must-less-than":  1.1,
		//                          "sell-limit-must-greater-than":  0.9,
		//                         "limit-order-must-greater-than":  1,
		//                            "limit-order-must-less-than":  5000000,
		//                    "market-buy-order-must-greater-than":  0.0001,
		//                       "market-buy-order-must-less-than":  100,
		//                   "market-sell-order-must-greater-than":  1,
		//                      "market-sell-order-must-less-than":  500000,
		//                       "circuit-break-when-greater-than":  10000,
		//                          "circuit-break-when-less-than":  10,
		//                 "market-sell-order-rate-must-less-than":  0.1,
		//                  "market-buy-order-rate-must-less-than":  0.1        } }
		//
		ch <- this.ParseTradingLimits(this.SafeValue(response, "data", map[string]interface{}{}))
		return nil

	}()
	return ch
}
func (this *HtxCore) ParseTradingLimits(limits interface{}, optionalArgs ...interface{}) interface{} {
	//
	//   {                                "symbol": "aidocbtc",
	//                  "buy-limit-must-less-than":  1.1,
	//              "sell-limit-must-greater-than":  0.9,
	//             "limit-order-must-greater-than":  1,
	//                "limit-order-must-less-than":  5000000,
	//        "market-buy-order-must-greater-than":  0.0001,
	//           "market-buy-order-must-less-than":  100,
	//       "market-sell-order-must-greater-than":  1,
	//          "market-sell-order-must-less-than":  500000,
	//           "circuit-break-when-greater-than":  10000,
	//              "circuit-break-when-less-than":  10,
	//     "market-sell-order-rate-must-less-than":  0.1,
	//      "market-buy-order-rate-must-less-than":  0.1        }
	//
	symbol := GetArg(optionalArgs, 0, nil)
	_ = symbol
	params := GetArg(optionalArgs, 1, map[string]interface{}{})
	_ = params
	return map[string]interface{}{
		"info": limits,
		"limits": map[string]interface{}{
			"amount": map[string]interface{}{
				"min": this.SafeNumber(limits, "limit-order-must-greater-than"),
				"max": this.SafeNumber(limits, "limit-order-must-less-than"),
			},
		},
	}
}
func (this *HtxCore) CostToPrecision(symbol interface{}, cost interface{}) interface{} {
	return this.DecimalToPrecision(cost, TRUNCATE, GetValue(GetValue(GetValue(this.Markets, symbol), "precision"), "cost"), this.PrecisionMode)
}

/**
 * @method
 * @name htx#fetchMarkets
 * @description retrieves data on all markets for huobi
 * @see https://huobiapi.github.io/docs/spot/v1/en/#get-all-supported-trading-symbol-v1-deprecated
 * @see https://huobiapi.github.io/docs/dm/v1/en/#get-contract-info
 * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#query-swap-info
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#general-query-swap-info
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func (this *HtxCore) FetchMarkets(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		if IsTrue(GetValue(this.Options, "adjustForTimeDifference")) {

			retRes181312 := (<-this.LoadTimeDifference())
			PanicOnError(retRes181312)
		}
		var types interface{} = nil
		typesparamsVariable := this.HandleOptionAndParams(params, "fetchMarkets", "types", map[string]interface{}{})
		types = GetValue(typesparamsVariable, 0)
		params = GetValue(typesparamsVariable, 1)
		var allMarkets interface{} = []interface{}{}
		var promises interface{} = []interface{}{}
		var keys interface{} = ObjectKeys(types)
		for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
			var key interface{} = GetValue(keys, i)
			if IsTrue(this.SafeBool(types, key)) {
				if IsTrue(IsEqual(key, "spot")) {
					AppendToArray(&promises, this.FetchMarketsByTypeAndSubType("spot", nil, params))
				} else if IsTrue(IsEqual(key, "linear")) {
					AppendToArray(&promises, this.FetchMarketsByTypeAndSubType(nil, "linear", params))
				} else if IsTrue(IsEqual(key, "inverse")) {
					AppendToArray(&promises, this.FetchMarketsByTypeAndSubType("swap", "inverse", params))
					AppendToArray(&promises, this.FetchMarketsByTypeAndSubType("future", "inverse", params))
				}
			}
		}

		promises = (<-promiseAll(promises))
		PanicOnError(promises)
		for i := 0; IsLessThan(i, GetArrayLength(promises)); i++ {
			allMarkets = this.ArrayConcat(allMarkets, GetValue(promises, i))
		}

		ch <- allMarkets
		return nil

	}()
	return ch
}

/**
 * @ignore
 * @method
 * @name htx#fetchMarketsByTypeAndSubType
 * @description retrieves data on all markets of a certain type and/or subtype
 * @see https://huobiapi.github.io/docs/spot/v1/en/#get-all-supported-trading-symbol-v1-deprecated
 * @see https://huobiapi.github.io/docs/dm/v1/en/#get-contract-info
 * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#query-swap-info
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#general-query-swap-info
 * @param {string} [type] 'spot', 'swap' or 'future'
 * @param {string} [subType] 'linear' or 'inverse'
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func (this *HtxCore) FetchMarketsByTypeAndSubType(typeVar interface{}, subType interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		var isSpot interface{} = (IsEqual(typeVar, "spot"))
		var request interface{} = map[string]interface{}{}
		var response interface{} = nil
		if !IsTrue(isSpot) {
			if IsTrue(IsEqual(subType, "linear")) {
				AddElementToObject(request, "business_type", "all") // override default to fetch all linear markets

				response = (<-this.ContractPublicGetLinearSwapApiV1SwapContractInfo(this.Extend(request, params)))
				PanicOnError(response)
			} else if IsTrue(IsEqual(subType, "inverse")) {
				if IsTrue(IsEqual(typeVar, "future")) {

					response = (<-this.ContractPublicGetApiV1ContractContractInfo(this.Extend(request, params)))
					PanicOnError(response)
				} else if IsTrue(IsEqual(typeVar, "swap")) {

					response = (<-this.ContractPublicGetSwapApiV1SwapContractInfo(this.Extend(request, params)))
					PanicOnError(response)
				}
			}
		} else {

			response = (<-this.SpotPublicGetV1CommonSymbols(this.Extend(request, params)))
			PanicOnError(response)
		}
		//
		// spot
		//
		//     {
		//         "status":"ok",
		//         "data":[
		//             {
		//                 "base-currency":"xrp3s",
		//                 "quote-currency":"usdt",
		//                 "price-precision":4,
		//                 "amount-precision":4,
		//                 "symbol-partition":"innovation",
		//                 "symbol":"xrp3susdt",
		//                 "state":"online",
		//                 "value-precision":8,
		//                 "min-order-amt":0.01,
		//                 "max-order-amt":1616.4353,
		//                 "min-order-value":5,
		//                 "limit-order-min-order-amt":0.01,
		//                 "limit-order-max-order-amt":1616.4353,
		//                 "limit-order-max-buy-amt":1616.4353,
		//                 "limit-order-max-sell-amt":1616.4353,
		//                 "sell-market-min-order-amt":0.01,
		//                 "sell-market-max-order-amt":1616.4353,
		//                 "buy-market-max-order-value":2500,
		//                 "max-order-value":2500,
		//                 "underlying":"xrpusdt",
		//                 "mgmt-fee-rate":0.035000000000000000,
		//                 "charge-time":"23:55:00",
		//                 "rebal-time":"00:00:00",
		//                 "rebal-threshold":-5,
		//                 "init-nav":10.000000000000000000,
		//                 "api-trading":"enabled",
		//                 "tags":"etp,nav,holdinglimit"
		//             },
		//         ]
		//     }
		//
		// inverse (swap & future)
		//
		//     {
		//         "status":"ok",
		//         "data":[
		//             {
		//                 "symbol":"BTC",
		//                 "contract_code":"BTC211126", /// BTC-USD in swap
		//                 "contract_type":"this_week", // only in future
		//                 "contract_size":100,
		//                 "price_tick":0.1,
		//                 "delivery_date":"20211126", // only in future
		//                 "delivery_time":"1637913600000", // empty in swap
		//                 "create_date":"20211112",
		//                 "contract_status":1,
		//                 "settlement_time":"1637481600000" // only in future
		//                 "settlement_date":"16xxxxxxxxxxx" // only in swap
		//             },
		//           ...
		//         ],
		//         "ts":1637474595140
		//     }
		//
		// linear (swap & future)
		//
		//     {
		//         "status":"ok",
		//         "data":[
		//             {
		//                 "symbol":"BTC",
		//                 "contract_code":"BTC-USDT-211231", // or "BTC-USDT" in swap
		//                 "contract_size":0.001,
		//                 "price_tick":0.1,
		//                 "delivery_date":"20211231", // empty in swap
		//                 "delivery_time":"1640937600000", // empty in swap
		//                 "create_date":"20211228",
		//                 "contract_status":1,
		//                 "settlement_date":"1640764800000",
		//                 "support_margin_mode":"cross", // "all" or "cross"
		//                 "business_type":"futures", // "swap" or "futures"
		//                 "pair":"BTC-USDT",
		//                 "contract_type":"this_week", // "swap", "this_week", "next_week", "quarter"
		//                 "trade_partition":"USDT",
		//             }
		//         ],
		//         "ts":1640736207263
		//     }
		//
		var markets interface{} = this.SafeList(response, "data", []interface{}{})
		var numMarkets interface{} = GetArrayLength(markets)
		if IsTrue(IsLessThan(numMarkets, 1)) {
			panic(OperationFailed(Add(Add(this.Id, " fetchMarkets() returned an empty response: "), this.Json(response))))
		}
		var result interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(markets)); i++ {
			var market interface{} = GetValue(markets, i)
			var baseId interface{} = nil
			var quoteId interface{} = nil
			var settleId interface{} = nil
			var id interface{} = nil
			var lowercaseId interface{} = nil
			var contract interface{} = (InOp(market, "contract_code"))
			var spot interface{} = !IsTrue(contract)
			var swap interface{} = false
			var future interface{} = false
			var linear interface{} = nil
			var inverse interface{} = nil
			// check if parsed market is contract
			if IsTrue(contract) {
				id = this.SafeString(market, "contract_code")
				lowercaseId = ToLower(id)
				var delivery_date interface{} = this.SafeString(market, "delivery_date")
				var business_type interface{} = this.SafeString(market, "business_type")
				future = !IsEqual(delivery_date, nil)
				swap = !IsTrue(future)
				linear = !IsEqual(business_type, nil)
				inverse = !IsTrue(linear)
				if IsTrue(swap) {
					typeVar = "swap"
					var parts interface{} = Split(id, "-")
					baseId = this.SafeStringLower(market, "symbol")
					quoteId = this.SafeStringLower(parts, 1)
					settleId = Ternary(IsTrue(inverse), baseId, quoteId)
				} else if IsTrue(future) {
					typeVar = "future"
					baseId = this.SafeStringLower(market, "symbol")
					if IsTrue(inverse) {
						quoteId = "USD"
						settleId = baseId
					} else {
						var pair interface{} = this.SafeString(market, "pair")
						var parts interface{} = Split(pair, "-")
						quoteId = this.SafeStringLower(parts, 1)
						settleId = quoteId
					}
				}
			} else {
				typeVar = "spot"
				baseId = this.SafeString(market, "base-currency")
				quoteId = this.SafeString(market, "quote-currency")
				id = Add(baseId, quoteId)
				lowercaseId = ToLower(id)
			}
			var base interface{} = this.SafeCurrencyCode(baseId)
			var quote interface{} = this.SafeCurrencyCode(quoteId)
			var settle interface{} = this.SafeCurrencyCode(settleId)
			var symbol interface{} = Add(Add(base, "/"), quote)
			var expiry interface{} = nil
			if IsTrue(contract) {
				if IsTrue(inverse) {
					symbol = Add(symbol, Add(":", base))
				} else if IsTrue(linear) {
					symbol = Add(symbol, Add(":", quote))
				}
				if IsTrue(future) {
					expiry = this.SafeInteger(market, "delivery_time")
					symbol = Add(symbol, Add("-", this.Yymmdd(expiry)))
				}
			}
			var contractSize interface{} = this.SafeNumber(market, "contract_size")
			var minCost interface{} = this.SafeNumber(market, "min-order-value")
			var maxAmount interface{} = this.SafeNumber(market, "max-order-amt")
			var minAmount interface{} = this.SafeNumber(market, "min-order-amt")
			if IsTrue(contract) {
				if IsTrue(linear) {
					minAmount = contractSize
				} else if IsTrue(inverse) {
					minCost = contractSize
				}
			}
			var pricePrecision interface{} = nil
			var amountPrecision interface{} = nil
			var costPrecision interface{} = nil
			var maker interface{} = nil
			var taker interface{} = nil
			var active interface{} = nil
			if IsTrue(spot) {
				pricePrecision = this.ParseNumber(this.ParsePrecision(this.SafeString(market, "price-precision")))
				amountPrecision = this.ParseNumber(this.ParsePrecision(this.SafeString(market, "amount-precision")))
				costPrecision = this.ParseNumber(this.ParsePrecision(this.SafeString(market, "value-precision")))
				maker = this.ParseNumber("0.002")
				taker = this.ParseNumber("0.002")
				var state interface{} = this.SafeString(market, "state")
				active = (IsEqual(state, "online"))
			} else {
				pricePrecision = this.SafeNumber(market, "price_tick")
				amountPrecision = this.ParseNumber("1") // other markets have step size of 1 contract
				maker = this.ParseNumber("0.0002")
				taker = this.ParseNumber("0.0005")
				var contractStatus interface{} = this.SafeInteger(market, "contract_status")
				active = (IsEqual(contractStatus, 1))
			}
			var leverageRatio interface{} = this.SafeString(market, "leverage-ratio", "1")
			var superLeverageRatio interface{} = this.SafeString(market, "super-margin-leverage-ratio", "1")
			var hasLeverage interface{} = IsTrue(Precise.StringGt(leverageRatio, "1")) || IsTrue(Precise.StringGt(superLeverageRatio, "1"))
			// 0 Delisting
			// 1 Listing
			// 2 Pending Listing
			// 3 Suspension
			// 4 Suspending of Listing
			// 5 In Settlement
			// 6 Delivering
			// 7 Settlement Completed
			// 8 Delivered
			// 9 Suspending of Trade
			var created interface{} = nil
			var createdDate interface{} = this.SafeString(market, "create_date") // i.e 20230101
			if IsTrue(!IsEqual(createdDate, nil)) {
				var createdArray interface{} = this.StringToCharsArray(createdDate)
				createdDate = Add(Add(Add(Add(Add(Add(Add(Add(Add(Add(GetValue(createdArray, 0), GetValue(createdArray, 1)), GetValue(createdArray, 2)), GetValue(createdArray, 3)), "-"), GetValue(createdArray, 4)), GetValue(createdArray, 5)), "-"), GetValue(createdArray, 6)), GetValue(createdArray, 7)), " 00:00:00")
				created = this.Parse8601(createdDate)
			}
			AppendToArray(&result, map[string]interface{}{
				"id":             id,
				"lowercaseId":    lowercaseId,
				"symbol":         symbol,
				"base":           base,
				"quote":          quote,
				"settle":         settle,
				"baseId":         baseId,
				"quoteId":        quoteId,
				"settleId":       settleId,
				"type":           typeVar,
				"spot":           spot,
				"margin":         (IsTrue(spot) && IsTrue(hasLeverage)),
				"swap":           swap,
				"future":         future,
				"option":         false,
				"active":         active,
				"contract":       contract,
				"linear":         linear,
				"inverse":        inverse,
				"taker":          taker,
				"maker":          maker,
				"contractSize":   contractSize,
				"expiry":         expiry,
				"expiryDatetime": this.Iso8601(expiry),
				"strike":         nil,
				"optionType":     nil,
				"precision": map[string]interface{}{
					"amount": amountPrecision,
					"price":  pricePrecision,
					"cost":   costPrecision,
				},
				"limits": map[string]interface{}{
					"leverage": map[string]interface{}{
						"min":      this.ParseNumber("1"),
						"max":      this.ParseNumber(leverageRatio),
						"superMax": this.ParseNumber(superLeverageRatio),
					},
					"amount": map[string]interface{}{
						"min": minAmount,
						"max": maxAmount,
					},
					"price": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
					"cost": map[string]interface{}{
						"min": minCost,
						"max": nil,
					},
				},
				"created": created,
				"info":    market,
			})
		}

		ch <- result
		return nil

	}()
	return ch
}
func (this *HtxCore) TryGetSymbolFromFutureMarkets(symbolOrMarketId interface{}) interface{} {
	if IsTrue(InOp(this.Markets, symbolOrMarketId)) {
		return symbolOrMarketId
	}
	// only on "future" market type (inverse & linear), market-id differs between "fetchMarkets" and "fetchTicker"
	// so we have to create a mapping
	// - market-id from fetchMarkts:    `BTC-USDT-240419` (linear future) or `BTC240412` (inverse future)
	// - market-id from fetchTciker[s]: `BTC-USDT-CW`     (linear future) or `BTC_CW`    (inverse future)
	if !IsTrue((InOp(this.Options, "futureMarketIdsForSymbols"))) {
		AddElementToObject(this.Options, "futureMarketIdsForSymbols", map[string]interface{}{})
	}
	var futureMarketIdsForSymbols interface{} = this.SafeDict(this.Options, "futureMarketIdsForSymbols", map[string]interface{}{})
	if IsTrue(InOp(futureMarketIdsForSymbols, symbolOrMarketId)) {
		return GetValue(futureMarketIdsForSymbols, symbolOrMarketId)
	}
	var futureMarkets interface{} = this.FilterBy(this.Markets, "future", true)
	var futuresCharsMaps interface{} = map[string]interface{}{
		"this_week":    "CW",
		"next_week":    "NW",
		"quarter":      "CQ",
		"next_quarter": "NQ",
	}
	for i := 0; IsLessThan(i, GetArrayLength(futureMarkets)); i++ {
		var market interface{} = GetValue(futureMarkets, i)
		var info interface{} = this.SafeValue(market, "info", map[string]interface{}{})
		var contractType interface{} = this.SafeString(info, "contract_type")
		var contractSuffix interface{} = GetValue(futuresCharsMaps, contractType)
		// see comment on formats a bit above
		var constructedId interface{} = Ternary(IsTrue(GetValue(market, "linear")), Add(Add(Add(Add(GetValue(market, "base"), "-"), GetValue(market, "quote")), "-"), contractSuffix), Add(Add(GetValue(market, "base"), "_"), contractSuffix))
		if IsTrue(IsEqual(constructedId, symbolOrMarketId)) {
			var symbol interface{} = GetValue(market, "symbol")
			AddElementToObject(GetValue(this.Options, "futureMarketIdsForSymbols"), symbolOrMarketId, symbol)
			return symbol
		}
	}
	// if not found, just save it to avoid unnecessary future iterations
	AddElementToObject(GetValue(this.Options, "futureMarketIdsForSymbols"), symbolOrMarketId, symbolOrMarketId)
	return symbolOrMarketId
}
func (this *HtxCore) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{} {
	//
	// fetchTicker
	//
	//     {
	//         "amount": 26228.672978342216,
	//         "open": 9078.95,
	//         "close": 9146.86,
	//         "high": 9155.41,
	//         "id": 209988544334,
	//         "count": 265846,
	//         "low": 8988.0,
	//         "version": 209988544334,
	//         "ask": [ 9146.87, 0.156134 ],
	//         "vol": 2.3822168242201668E8,
	//         "bid": [ 9146.86, 0.080758 ],
	//     }
	//
	// fetchTickers
	//
	//     {
	//         "symbol": "bhdht",
	//         "open":  2.3938,
	//         "high":  2.4151,
	//         "low":  2.3323,
	//         "close":  2.3909,
	//         "amount":  628.992,
	//         "vol":  1493.71841095,
	//         "count":  2088,
	//         "bid":  2.3643,
	//         "bidSize":  0.7136,
	//         "ask":  2.4061,
	//         "askSize":  0.4156
	//     }
	//
	// watchTikcer - bbo
	//     {
	//         "seqId": 161499562790,
	//         "ask": 16829.51,
	//         "askSize": 0.707776,
	//         "bid": 16829.5,
	//         "bidSize": 1.685945,
	//         "quoteTime": 1671941599612,
	//         "symbol": "btcusdt"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString2(ticker, "symbol", "contract_code")
	var symbol interface{} = this.SafeSymbol(marketId, market)
	symbol = this.TryGetSymbolFromFutureMarkets(symbol)
	var timestamp interface{} = this.SafeInteger2(ticker, "ts", "quoteTime")
	var bid interface{} = nil
	var bidVolume interface{} = nil
	var ask interface{} = nil
	var askVolume interface{} = nil
	if IsTrue(InOp(ticker, "bid")) {
		if IsTrue(IsTrue(!IsEqual(GetValue(ticker, "bid"), nil)) && IsTrue(IsArray(GetValue(ticker, "bid")))) {
			bid = this.SafeString(GetValue(ticker, "bid"), 0)
			bidVolume = this.SafeString(GetValue(ticker, "bid"), 1)
		} else {
			bid = this.SafeString(ticker, "bid")
			bidVolume = this.SafeString(ticker, "bidSize")
		}
	}
	if IsTrue(InOp(ticker, "ask")) {
		if IsTrue(IsTrue(!IsEqual(GetValue(ticker, "ask"), nil)) && IsTrue(IsArray(GetValue(ticker, "ask")))) {
			ask = this.SafeString(GetValue(ticker, "ask"), 0)
			askVolume = this.SafeString(GetValue(ticker, "ask"), 1)
		} else {
			ask = this.SafeString(ticker, "ask")
			askVolume = this.SafeString(ticker, "askSize")
		}
	}
	var open interface{} = this.SafeString(ticker, "open")
	var close interface{} = this.SafeString(ticker, "close")
	var baseVolume interface{} = this.SafeString(ticker, "amount")
	var quoteVolume interface{} = this.SafeString(ticker, "vol")
	return this.SafeTicker(map[string]interface{}{
		"symbol":        symbol,
		"timestamp":     timestamp,
		"datetime":      this.Iso8601(timestamp),
		"high":          this.SafeString(ticker, "high"),
		"low":           this.SafeString(ticker, "low"),
		"bid":           bid,
		"bidVolume":     bidVolume,
		"ask":           ask,
		"askVolume":     askVolume,
		"vwap":          nil,
		"open":          open,
		"close":         close,
		"last":          close,
		"previousClose": nil,
		"change":        nil,
		"percentage":    nil,
		"average":       nil,
		"baseVolume":    baseVolume,
		"quoteVolume":   quoteVolume,
		"info":          ticker,
	}, market)
}

/**
 * @method
 * @name htx#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://huobiapi.github.io/docs/spot/v1/en/#get-latest-aggregated-ticker
 * @see https://huobiapi.github.io/docs/dm/v1/en/#get-market-data-overview
 * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#get-market-data-overview
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#general-get-market-data-overview
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func (this *HtxCore) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes22938 := (<-this.LoadMarkets())
		PanicOnError(retRes22938)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{}
		var response interface{} = nil
		if IsTrue(GetValue(market, "linear")) {
			AddElementToObject(request, "contract_code", GetValue(market, "id"))

			response = (<-this.ContractPublicGetLinearSwapExMarketDetailMerged(this.Extend(request, params)))
			PanicOnError(response)
		} else if IsTrue(GetValue(market, "inverse")) {
			if IsTrue(GetValue(market, "future")) {
				AddElementToObject(request, "symbol", GetValue(market, "id"))

				response = (<-this.ContractPublicGetMarketDetailMerged(this.Extend(request, params)))
				PanicOnError(response)
			} else if IsTrue(GetValue(market, "swap")) {
				AddElementToObject(request, "contract_code", GetValue(market, "id"))

				response = (<-this.ContractPublicGetSwapExMarketDetailMerged(this.Extend(request, params)))
				PanicOnError(response)
			}
		} else {
			AddElementToObject(request, "symbol", GetValue(market, "id"))

			response = (<-this.SpotPublicGetMarketDetailMerged(this.Extend(request, params)))
			PanicOnError(response)
		}
		//
		// spot
		//
		//     {
		//         "status": "ok",
		//         "ch": "market.btcusdt.detail.merged",
		//         "ts": 1583494336669,
		//         "tick": {
		//             "amount": 26228.672978342216,
		//             "open": 9078.95,
		//             "close": 9146.86,
		//             "high": 9155.41,
		//             "id": 209988544334,
		//             "count": 265846,
		//             "low": 8988.0,
		//             "version": 209988544334,
		//             "ask": [ 9146.87, 0.156134 ],
		//             "vol": 2.3822168242201668E8,
		//             "bid": [ 9146.86, 0.080758 ],
		//         }
		//     }
		//
		// future, swap
		//
		//     {
		//         "ch":"market.BTC211126.detail.merged",
		//         "status":"ok",
		//         "tick":{
		//             "amount":"669.3385682049668320322569544150680718474",
		//             "ask":[59117.44,48],
		//             "bid":[59082,48],
		//             "close":"59087.97",
		//             "count":5947,
		//             "high":"59892.62",
		//             "id":1637502670,
		//             "low":"57402.87",
		//             "open":"57638",
		//             "ts":1637502670059,
		//             "vol":"394598"
		//         },
		//         "ts":1637502670059
		//     }
		//
		var tick interface{} = this.SafeValue(response, "tick", map[string]interface{}{})
		var ticker interface{} = this.ParseTicker(tick, market)
		var timestamp interface{} = this.SafeInteger(response, "ts")
		AddElementToObject(ticker, "timestamp", timestamp)
		AddElementToObject(ticker, "datetime", this.Iso8601(timestamp))

		ch <- ticker
		return nil

	}()
	return ch
}

/**
 * @method
 * @name htx#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://huobiapi.github.io/docs/spot/v1/en/#get-latest-tickers-for-all-pairs
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#general-get-a-batch-of-market-data-overview
 * @see https://huobiapi.github.io/docs/dm/v1/en/#get-a-batch-of-market-data-overview
 * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#get-a-batch-of-market-data-overview-v2
 * @param {string[]} [symbols] unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func (this *HtxCore) FetchTickers(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes23768 := (<-this.LoadMarkets())
		PanicOnError(retRes23768)
		symbols = this.MarketSymbols(symbols)
		var first interface{} = this.SafeString(symbols, 0)
		var market interface{} = nil
		if IsTrue(!IsEqual(first, nil)) {
			market = this.Market(first)
		}
		var isSubTypeRequested interface{} = IsTrue((InOp(params, "subType"))) || IsTrue((InOp(params, "business_type")))
		var typeVar interface{} = nil
		var subType interface{} = nil
		typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchTickers", market, params)
		typeVar = GetValue(typeVarparamsVariable, 0)
		params = GetValue(typeVarparamsVariable, 1)
		subTypeparamsVariable := this.HandleSubTypeAndParams("fetchTickers", market, params)
		subType = GetValue(subTypeparamsVariable, 0)
		params = GetValue(subTypeparamsVariable, 1)
		var request interface{} = map[string]interface{}{}
		var isSpot interface{} = (IsEqual(typeVar, "spot"))
		var future interface{} = (IsEqual(typeVar, "future"))
		var swap interface{} = (IsEqual(typeVar, "swap"))
		var linear interface{} = (IsEqual(subType, "linear"))
		var inverse interface{} = (IsEqual(subType, "inverse"))
		var response interface{} = nil
		if IsTrue(!IsTrue(isSpot) || IsTrue(isSubTypeRequested)) {
			if IsTrue(linear) {
				// independently of type, supports calling all linear symbols i.e. fetchTickers(undefined, {subType:'linear'})
				if IsTrue(future) {
					AddElementToObject(request, "business_type", "futures")
				} else if IsTrue(swap) {
					AddElementToObject(request, "business_type", "swap")
				} else {
					AddElementToObject(request, "business_type", "all")
				}

				response = (<-this.ContractPublicGetLinearSwapExMarketDetailBatchMerged(this.Extend(request, params)))
				PanicOnError(response)
			} else if IsTrue(inverse) {
				if IsTrue(future) {

					response = (<-this.ContractPublicGetMarketDetailBatchMerged(this.Extend(request, params)))
					PanicOnError(response)
				} else if IsTrue(swap) {

					response = (<-this.ContractPublicGetSwapExMarketDetailBatchMerged(this.Extend(request, params)))
					PanicOnError(response)
				} else {
					panic(NotSupported(Add(this.Id, " fetchTickers() you have to set params[\"type\"] to either \"swap\" or \"future\" for inverse contracts")))
				}
			} else {
				panic(NotSupported(Add(this.Id, " fetchTickers() you have to set params[\"subType\"] to either \"linear\" or \"inverse\" for contracts")))
			}
		} else {

			response = (<-this.SpotPublicGetMarketTickers(this.Extend(request, params)))
			PanicOnError(response)
		}
		//
		// spot
		//
		//     {
		//         "data":[
		//             {
		//                 "symbol":"hbcbtc",
		//                 "open":5.313E-5,
		//                 "high":5.34E-5,
		//                 "low":5.112E-5,
		//                 "close":5.175E-5,
		//                 "amount":1183.87,
		//                 "vol":0.0618599229,
		//                 "count":205,
		//                 "bid":5.126E-5,
		//                 "bidSize":5.25,
		//                 "ask":5.214E-5,
		//                 "askSize":150.0
		//             },
		//         ],
		//         "status":"ok",
		//         "ts":1639547261293
		//     }
		//
		// linear swap, linear future, inverse swap, inverse future
		//
		//     {
		//         "status":"ok",
		//         "ticks":[
		//             {
		//                 "id":1637504679,
		//                 "ts":1637504679372,
		//                 "ask":[0.10644,100],
		//                 "bid":[0.10624,26],
		//                 "symbol":"TRX_CW",
		//                 "open":"0.10233",
		//                 "close":"0.10644",
		//                 "low":"0.1017",
		//                 "high":"0.10725",
		//                 "amount":"2340267.415144052378486261756692535687481566",
		//                 "count":882,
		//                 "vol":"24706",
		//                 "trade_turnover":"840726.5048", // only in linear futures
		//                 "business_type":"futures", // only in linear futures
		//                 "contract_code":"BTC-USDT-CW", // only in linear futures, instead of 'symbol'
		//             }
		//         ],
		//         "ts":1637504679376
		//     }
		//
		var rawTickers interface{} = this.SafeList2(response, "data", "ticks", []interface{}{})
		var tickers interface{} = this.ParseTickers(rawTickers, symbols, params)

		ch <- this.FilterByArrayTickers(tickers, "symbol", symbols)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name htx#fetchLastPrices
 * @description fetches the last price for multiple markets
 * @see https://www.htx.com/en-us/opend/newApiPages/?id=8cb81024-77b5-11ed-9966-0242ac110003 linear swap & linear future
 * @see https://www.htx.com/en-us/opend/newApiPages/?id=28c2e8fc-77ae-11ed-9966-0242ac110003 inverse future
 * @see https://www.htx.com/en-us/opend/newApiPages/?id=5d517ef5-77b6-11ed-9966-0242ac110003 inverse swap
 * @param {string[]} [symbols] unified symbols of the markets to fetch the last prices
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of lastprices structures
 */
func (this *HtxCore) FetchLastPrices(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes24878 := (<-this.LoadMarkets())
		PanicOnError(retRes24878)
		symbols = this.MarketSymbols(symbols)
		var market interface{} = this.GetMarketFromSymbols(symbols)
		var typeVar interface{} = nil
		var subType interface{} = nil
		subTypeparamsVariable := this.HandleSubTypeAndParams("fetchLastPrices", market, params)
		subType = GetValue(subTypeparamsVariable, 0)
		params = GetValue(subTypeparamsVariable, 1)
		typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchLastPrices", market, params)
		typeVar = GetValue(typeVarparamsVariable, 0)
		params = GetValue(typeVarparamsVariable, 1)
		var response interface{} = nil
		if IsTrue(IsTrue((IsTrue((IsEqual(typeVar, "swap"))) || IsTrue((IsEqual(typeVar, "future"))))) && IsTrue((IsEqual(subType, "linear")))) {

			response = (<-this.ContractPublicGetLinearSwapExMarketTrade(params))
			PanicOnError(response)
		} else if IsTrue(IsTrue((IsEqual(typeVar, "swap"))) && IsTrue((IsEqual(subType, "inverse")))) {

			response = (<-this.ContractPublicGetSwapExMarketTrade(params))
			PanicOnError(response)
		} else if IsTrue(IsTrue((IsEqual(typeVar, "future"))) && IsTrue((IsEqual(subType, "inverse")))) {

			response = (<-this.ContractPublicGetMarketTrade(params))
			PanicOnError(response)
		} else {
			panic(NotSupported(Add(Add(Add(this.Id, " fetchLastPrices() does not support "), typeVar), " markets yet")))
		}
		var tick interface{} = this.SafeValue(response, "tick", map[string]interface{}{})
		var data interface{} = this.SafeList(tick, "data", []interface{}{})

		ch <- this.ParseLastPrices(data, symbols)
		return nil

	}()
	return ch
}
func (this *HtxCore) ParseLastPrice(entry interface{}, optionalArgs ...interface{}) interface{} {
	// example responses are documented in fetchLastPrices
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString2(entry, "symbol", "contract_code")
	market = this.SafeMarket(marketId, market)
	var price interface{} = this.SafeNumber(entry, "price")
	var direction interface{} = this.SafeString(entry, "direction") // "buy" or "sell"
	// group timestamp should not be assigned to the individual trades' times
	return map[string]interface{}{
		"symbol":    GetValue(market, "symbol"),
		"timestamp": nil,
		"datetime":  nil,
		"price":     price,
		"side":      direction,
		"info":      entry,
	}
}

/**
 * @method
 * @name htx#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://huobiapi.github.io/docs/spot/v1/en/#get-market-depth
 * @see https://huobiapi.github.io/docs/dm/v1/en/#get-market-depth
 * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#get-market-depth
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#general-get-market-depth
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func (this *HtxCore) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		limit := GetArg(optionalArgs, 0, nil)
		_ = limit
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes26098 := (<-this.LoadMarkets())
		PanicOnError(retRes26098)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"type": "step0",
		}
		var response interface{} = nil
		if IsTrue(GetValue(market, "linear")) {
			AddElementToObject(request, "contract_code", GetValue(market, "id"))

			response = (<-this.ContractPublicGetLinearSwapExMarketDepth(this.Extend(request, params)))
			PanicOnError(response)
		} else if IsTrue(GetValue(market, "inverse")) {
			if IsTrue(GetValue(market, "future")) {
				AddElementToObject(request, "symbol", GetValue(market, "id"))

				response = (<-this.ContractPublicGetMarketDepth(this.Extend(request, params)))
				PanicOnError(response)
			} else if IsTrue(GetValue(market, "swap")) {
				AddElementToObject(request, "contract_code", GetValue(market, "id"))

				response = (<-this.ContractPublicGetSwapExMarketDepth(this.Extend(request, params)))
				PanicOnError(response)
			}
		} else {
			if IsTrue(!IsEqual(limit, nil)) {
				// Valid depths are 5, 10, 20 or empty https://huobiapi.github.io/docs/spot/v1/en/#get-market-depth
				if IsTrue(IsTrue(IsTrue(IsTrue((!IsEqual(limit, 5))) && IsTrue((!IsEqual(limit, 10)))) && IsTrue((!IsEqual(limit, 20)))) && IsTrue((!IsEqual(limit, 150)))) {
					panic(BadRequest(Add(this.Id, " fetchOrderBook() limit argument must be undefined, 5, 10, 20, or 150, default is 150")))
				}
				// only set the depth if it is not 150
				// 150 is the implicit default on the exchange side for step0 and no orderbook aggregation
				// it is not accepted by the exchange if you set it explicitly
				if IsTrue(!IsEqual(limit, 150)) {
					AddElementToObject(request, "depth", limit)
				}
			}
			AddElementToObject(request, "symbol", GetValue(market, "id"))

			response = (<-this.SpotPublicGetMarketDepth(this.Extend(request, params)))
			PanicOnError(response)
		}
		//
		// spot, future, swap
		//
		//     {
		//         "status": "ok",
		//         "ch": "market.btcusdt.depth.step0",
		//         "ts": 1583474832790,
		//         "tick": {
		//             "bids": [
		//                 [ 9100.290000000000000000, 0.200000000000000000 ],
		//                 [ 9099.820000000000000000, 0.200000000000000000 ],
		//                 [ 9099.610000000000000000, 0.205000000000000000 ],
		//             ],
		//             "asks": [
		//                 [ 9100.640000000000000000, 0.005904000000000000 ],
		//                 [ 9101.010000000000000000, 0.287311000000000000 ],
		//                 [ 9101.030000000000000000, 0.012121000000000000 ],
		//             ],
		//             "ch":"market.BTC-USD.depth.step0",
		//             "ts":1583474832008,
		//             "id":1637554816,
		//             "mrid":121654491624,
		//             "version":104999698781
		//         }
		//     }
		//
		if IsTrue(InOp(response, "tick")) {
			if !IsTrue(GetValue(response, "tick")) {
				panic(BadSymbol(Add(Add(this.Id, " fetchOrderBook() returned empty response: "), this.Json(response))))
			}
			var tick interface{} = this.SafeValue(response, "tick")
			var timestamp interface{} = this.SafeInteger(tick, "ts", this.SafeInteger(response, "ts"))
			var result interface{} = this.ParseOrderBook(tick, symbol, timestamp)
			AddElementToObject(result, "nonce", this.SafeInteger(tick, "version"))

			ch <- result
			return nil
		}
		panic(ExchangeError(Add(Add(this.Id, " fetchOrderBook() returned unrecognized response: "), this.Json(response))))

	}()
	return ch
}
func (this *HtxCore) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{} {
	//
	// spot fetchTrades (public)
	//
	//     {
	//         "amount": 0.010411000000000000,
	//         "trade-id": 102090736910,
	//         "ts": 1583497692182,
	//         "id": 10500517034273194594947,
	//         "price": 9096.050000000000000000,
	//         "direction": "sell"
	//     }
	//
	// spot fetchMyTrades (private)
	//
	//     {
	//          "symbol": "swftcbtc",
	//          "fee-currency": "swftc",
	//          "filled-fees": "0",
	//          "source": "spot-api",
	//          "id": 83789509854000,
	//          "type": "buy-limit",
	//          "order-id": 83711103204909,
	//          'filled-points': "0.005826843283532154",
	//          "fee-deduct-currency": "ht",
	//          'filled-amount': "45941.53",
	//          "price": "0.0000001401",
	//          "created-at": 1597933260729,
	//          "match-id": 100087455560,
	//          "role": "maker",
	//          "trade-id": 100050305348
	//     }
	//
	// linear swap isolated margin fetchOrder details
	//
	//     {
	//         "trade_id": 131560927,
	//         "trade_price": 13059.800000000000000000,
	//         "trade_volume": 1.000000000000000000,
	//         "trade_turnover": 13.059800000000000000,
	//         "trade_fee": -0.005223920000000000,
	//         "created_at": 1603703614715,
	//         "role": "taker",
	//         "fee_asset": "USDT",
	//         "profit": 0,
	//         "real_profit": 0,
	//         "id": "131560927-770334322963152896-1"
	//     }
	//
	// inverse swap cross margin fetchMyTrades
	//
	//     {
	//         "contract_type":"swap",
	//         "pair":"O3-USDT",
	//         "business_type":"swap",
	//         "query_id":652123190,
	//         "match_id":28306009409,
	//         "order_id":941137865226903553,
	//         "symbol":"O3",
	//         "contract_code":"O3-USDT",
	//         "direction":"sell",
	//         "offset":"open",
	//         "trade_volume":100.000000000000000000,
	//         "trade_price":0.398500000000000000,
	//         "trade_turnover":39.850000000000000000,
	//         "trade_fee":-0.007970000000000000,
	//         "offset_profitloss":0E-18,
	//         "create_date":1644426352999,
	//         "role":"Maker",
	//         "order_source":"api",
	//         "order_id_str":"941137865226903553",
	//         "id":"28306009409-941137865226903553-1",
	//         "fee_asset":"USDT",
	//         "margin_mode":"cross",
	//         "margin_account":"USDT",
	//         "real_profit":0E-18,
	//         "trade_partition":"USDT"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString2(trade, "contract_code", "symbol")
	market = this.SafeMarket(marketId, market)
	var symbol interface{} = GetValue(market, "symbol")
	var timestamp interface{} = this.SafeInteger2(trade, "ts", "created-at")
	timestamp = this.SafeInteger2(trade, "created_at", "create_date", timestamp)
	var order interface{} = this.SafeString2(trade, "order-id", "order_id")
	var side interface{} = this.SafeString(trade, "direction")
	var typeVar interface{} = this.SafeString(trade, "type")
	if IsTrue(!IsEqual(typeVar, nil)) {
		var typeParts interface{} = Split(typeVar, "-")
		side = GetValue(typeParts, 0)
		typeVar = GetValue(typeParts, 1)
	}
	var takerOrMaker interface{} = this.SafeStringLower(trade, "role")
	var priceString interface{} = this.SafeString2(trade, "price", "trade_price")
	var amountString interface{} = this.SafeString2(trade, "filled-amount", "amount")
	amountString = this.SafeString(trade, "trade_volume", amountString)
	var costString interface{} = this.SafeString(trade, "trade_turnover")
	var fee interface{} = nil
	var feeCost interface{} = this.SafeString(trade, "filled-fees")
	if IsTrue(IsEqual(feeCost, nil)) {
		feeCost = Precise.StringNeg(this.SafeString(trade, "trade_fee"))
	}
	var feeCurrencyId interface{} = this.SafeString2(trade, "fee-currency", "fee_asset")
	var feeCurrency interface{} = this.SafeCurrencyCode(feeCurrencyId)
	var filledPoints interface{} = this.SafeString(trade, "filled-points")
	if IsTrue(!IsEqual(filledPoints, nil)) {
		if IsTrue(IsTrue((IsEqual(feeCost, nil))) || IsTrue(Precise.StringEquals(feeCost, "0"))) {
			var feeDeductCurrency interface{} = this.SafeString(trade, "fee-deduct-currency")
			if IsTrue(!IsEqual(feeDeductCurrency, nil)) {
				feeCost = filledPoints
				feeCurrency = this.SafeCurrencyCode(feeDeductCurrency)
			}
		}
	}
	if IsTrue(!IsEqual(feeCost, nil)) {
		fee = map[string]interface{}{
			"cost":     feeCost,
			"currency": feeCurrency,
		}
	}
	// htx's multi-market trade-id is a bit complex to parse accordingly.
	// - for `id` which contains hyphen, it would be the unique id, eg. xxxxxx-1, xxxxxx-2 (this happens mostly for contract markets)
	// - otherwise the least priority is given to the `id` key
	var id interface{} = nil
	var safeId interface{} = this.SafeString(trade, "id")
	if IsTrue(IsTrue(!IsEqual(safeId, nil)) && IsTrue(IsGreaterThanOrEqual(GetIndexOf(safeId, "-"), 0))) {
		id = safeId
	} else {
		id = this.SafeStringN(trade, []interface{}{"trade_id", "trade-id", "id"})
	}
	return this.SafeTrade(map[string]interface{}{
		"id":           id,
		"info":         trade,
		"order":        order,
		"timestamp":    timestamp,
		"datetime":     this.Iso8601(timestamp),
		"symbol":       symbol,
		"type":         typeVar,
		"side":         side,
		"takerOrMaker": takerOrMaker,
		"price":        priceString,
		"amount":       amountString,
		"cost":         costString,
		"fee":          fee,
	}, market)
}

/**
 * @method
 * @name htx#fetchOrderTrades
 * @description fetch all the trades made from a single order
 * @see https://huobiapi.github.io/docs/spot/v1/en/#get-the-match-result-of-an-order
 * @param {string} id order id
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
 */
func (this *HtxCore) FetchOrderTrades(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
		}
		var marketType interface{} = nil
		marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchOrderTrades", market, params)
		marketType = GetValue(marketTypeparamsVariable, 0)
		params = GetValue(marketTypeparamsVariable, 1)
		if IsTrue(!IsEqual(marketType, "spot")) {
			panic(NotSupported(Add(this.Id, " fetchOrderTrades() is only supported for spot markets")))
		}

		retRes285815 := (<-this.FetchSpotOrderTrades(id, symbol, since, limit, params))
		PanicOnError(retRes285815)
		ch <- retRes285815
		return nil

	}()
	return ch
}

/**
 * @ignore
 * @method
 * @name htx#fetchOrderTrades
 * @description fetch all the trades made from a single order
 * @see https://huobiapi.github.io/docs/spot/v1/en/#get-the-match-result-of-an-order
 * @param {string} id order id
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
 */
func (this *HtxCore) FetchSpotOrderTrades(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes28758 := (<-this.LoadMarkets())
		PanicOnError(retRes28758)
		var request interface{} = map[string]interface{}{
			"order-id": id,
		}

		response := (<-this.SpotPrivateGetV1OrderOrdersOrderIdMatchresults(this.Extend(request, params)))
		PanicOnError(response)

		ch <- this.ParseTrades(GetValue(response, "data"), nil, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name htx#fetchMyTrades
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#isolated-get-history-match-results-via-multiple-fields-new
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#cross-get-history-match-results-via-multiple-fields-new
 * @see https://huobiapi.github.io/docs/spot/v1/en/#search-match-results
 * @description fetch all trades made by the user
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch trades for
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
 */
func (this *HtxCore) FetchMyTrades(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes28998 := (<-this.LoadMarkets())
		PanicOnError(retRes28998)
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchMyTrades", "paginate")
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {

			retRes290319 := (<-this.FetchPaginatedCallDynamic("fetchMyTrades", symbol, since, limit, params))
			PanicOnError(retRes290319)
			ch <- retRes290319
			return nil
		}
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
		}
		var marketType interface{} = nil
		marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchMyTrades", market, params)
		marketType = GetValue(marketTypeparamsVariable, 0)
		params = GetValue(marketTypeparamsVariable, 1)
		var request interface{} = map[string]interface{}{}
		var response interface{} = nil
		if IsTrue(IsEqual(marketType, "spot")) {
			if IsTrue(!IsEqual(symbol, nil)) {
				market = this.Market(symbol)
				AddElementToObject(request, "symbol", GetValue(market, "id"))
			}
			if IsTrue(!IsEqual(limit, nil)) {
				AddElementToObject(request, "size", limit) // default 100, max 500
			}
			if IsTrue(!IsEqual(since, nil)) {
				AddElementToObject(request, "start-time", since) // a date within 120 days from today
			}
			requestparamsVariable := this.HandleUntilOption("end-time", request, params)
			request = GetValue(requestparamsVariable, 0)
			params = GetValue(requestparamsVariable, 1)

			response = (<-this.SpotPrivateGetV1OrderMatchresults(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			if IsTrue(IsEqual(symbol, nil)) {
				panic(ArgumentsRequired(Add(this.Id, " fetchMyTrades() requires a symbol argument")))
			}
			AddElementToObject(request, "contract", GetValue(market, "id"))
			AddElementToObject(request, "trade_type", 0) // 0 all, 1 open long, 2 open short, 3 close short, 4 close long, 5 liquidate long positions, 6 liquidate short positions
			if IsTrue(!IsEqual(since, nil)) {
				AddElementToObject(request, "start_time", since) // a date within 120 days from today
			}
			requestparamsVariable := this.HandleUntilOption("end_time", request, params)
			request = GetValue(requestparamsVariable, 0)
			params = GetValue(requestparamsVariable, 1)
			if IsTrue(!IsEqual(limit, nil)) {
				AddElementToObject(request, "page_size", limit) // default 100, max 500
			}
			if IsTrue(GetValue(market, "linear")) {
				var marginMode interface{} = nil
				marginModeparamsVariable := this.HandleMarginModeAndParams("fetchMyTrades", params)
				marginMode = GetValue(marginModeparamsVariable, 0)
				params = GetValue(marginModeparamsVariable, 1)
				marginMode = Ternary(IsTrue((IsEqual(marginMode, nil))), "cross", marginMode)
				if IsTrue(IsEqual(marginMode, "isolated")) {

					response = (<-this.ContractPrivatePostLinearSwapApiV3SwapMatchresultsExact(this.Extend(request, params)))
					PanicOnError(response)
				} else if IsTrue(IsEqual(marginMode, "cross")) {

					response = (<-this.ContractPrivatePostLinearSwapApiV3SwapCrossMatchresultsExact(this.Extend(request, params)))
					PanicOnError(response)
				}
			} else if IsTrue(GetValue(market, "inverse")) {
				if IsTrue(IsEqual(marketType, "future")) {
					AddElementToObject(request, "symbol", GetValue(market, "settleId"))

					response = (<-this.ContractPrivatePostApiV3ContractMatchresultsExact(this.Extend(request, params)))
					PanicOnError(response)
				} else if IsTrue(IsEqual(marketType, "swap")) {

					response = (<-this.ContractPrivatePostSwapApiV3SwapMatchresultsExact(this.Extend(request, params)))
					PanicOnError(response)
				} else {
					panic(NotSupported(Add(Add(Add(this.Id, " fetchMyTrades() does not support "), marketType), " markets")))
				}
			}
		}
		//
		// spot
		//
		//     {
		//         "status": "ok",
		//         "data": [
		//             {
		//                 "symbol": "polyusdt",
		//                 "fee-currency": "poly",
		//                 "source": "spot-web",
		//                 "price": "0.338",
		//                 "created-at": 1629443051839,
		//                 "role": "taker",
		//                 "order-id": 345487249132375,
		//                 "match-id": 5014,
		//                 "trade-id": 1085,
		//                 "filled-amount": "147.928994082840236",
		//                 "filled-fees": "0",
		//                 "filled-points": "0.1",
		//                 "fee-deduct-currency": "hbpoint",
		//                 "fee-deduct-state": "done",
		//                 "id": 313288753120940,
		//                 "type": "buy-market"
		//             }
		//         ]
		//     }
		//
		// contracts
		//
		//     {
		//         "status": "ok",
		//         "data": {
		//             "trades": [
		//                 {
		//                     "query_id": 2424420723,
		//                     "match_id": 113891764710,
		//                     "order_id": 773135295142658048,
		//                     "symbol": "ADA",
		//                     "contract_type": "quarter", // swap
		//                     "business_type": "futures", // swap
		//                     "contract_code": "ADA201225",
		//                     "direction": "buy",
		//                     "offset": "open",
		//                     "trade_volume": 1,
		//                     "trade_price": 0.092,
		//                     "trade_turnover": 10,
		//                     "trade_fee": -0.021739130434782608,
		//                     "offset_profitloss": 0,
		//                     "create_date": 1604371703183,
		//                     "role": "Maker",
		//                     "order_source": "web",
		//                     "order_id_str": "773135295142658048",
		//                     "fee_asset": "ADA",
		//                     "margin_mode": "isolated", // cross
		//                     "margin_account": "BTC-USDT",
		//                     "real_profit": 0,
		//                     "id": "113891764710-773135295142658048-1",
		//                     "trade_partition":"USDT",
		//                 }
		//             ],
		//             "remain_size": 15,
		//             "next_id": 2424413094
		//         },
		//         "ts": 1604372202243
		//     }
		//
		var trades interface{} = this.SafeValue(response, "data")
		if !IsTrue(IsArray(trades)) {
			trades = this.SafeValue(trades, "trades")
		}

		ch <- this.ParseTrades(trades, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name htx#fetchTrades
 * @see https://huobiapi.github.io/docs/spot/v1/en/#get-the-most-recent-trades
 * @see https://huobiapi.github.io/docs/dm/v1/en/#query-a-batch-of-trade-records-of-a-contract
 * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#query-a-batch-of-trade-records-of-a-contract
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#general-query-a-batch-of-trade-records-of-a-contract
 * @description get the list of most recent trades for a particular symbol
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func (this *HtxCore) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		since := GetArg(optionalArgs, 0, nil)
		_ = since
		limit := GetArg(optionalArgs, 1, 1000)
		_ = limit
		params := GetArg(optionalArgs, 2, map[string]interface{}{})
		_ = params

		retRes30678 := (<-this.LoadMarkets())
		PanicOnError(retRes30678)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "size", mathMin(limit, 2000)) // max 2000
		}
		var response interface{} = nil
		if IsTrue(GetValue(market, "future")) {
			if IsTrue(GetValue(market, "inverse")) {
				AddElementToObject(request, "symbol", GetValue(market, "id"))

				response = (<-this.ContractPublicGetMarketHistoryTrade(this.Extend(request, params)))
				PanicOnError(response)
			} else if IsTrue(GetValue(market, "linear")) {
				AddElementToObject(request, "contract_code", GetValue(market, "id"))

				response = (<-this.ContractPublicGetLinearSwapExMarketHistoryTrade(this.Extend(request, params)))
				PanicOnError(response)
			}
		} else if IsTrue(GetValue(market, "swap")) {
			AddElementToObject(request, "contract_code", GetValue(market, "id"))
			if IsTrue(GetValue(market, "inverse")) {

				response = (<-this.ContractPublicGetSwapExMarketHistoryTrade(this.Extend(request, params)))
				PanicOnError(response)
			} else if IsTrue(GetValue(market, "linear")) {

				response = (<-this.ContractPublicGetLinearSwapExMarketHistoryTrade(this.Extend(request, params)))
				PanicOnError(response)
			}
		} else {
			AddElementToObject(request, "symbol", GetValue(market, "id"))

			response = (<-this.SpotPublicGetMarketHistoryTrade(this.Extend(request, params)))
			PanicOnError(response)
		}
		//
		//     {
		//         "status": "ok",
		//         "ch": "market.btcusdt.trade.detail",
		//         "ts": 1583497692365,
		//         "data": [
		//             {
		//                 "id": 105005170342,
		//                 "ts": 1583497692182,
		//                 "data": [
		//                     {
		//                         "amount": 0.010411000000000000,
		//                         "trade-id": 102090736910,
		//                         "ts": 1583497692182,
		//                         "id": 10500517034273194594947,
		//                         "price": 9096.050000000000000000,
		//                         "direction": "sell"
		//                     }
		//                 ]
		//             },
		//             // ...
		//         ]
		//     }
		//
		var data interface{} = this.SafeValue(response, "data", []interface{}{})
		var result interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
			var trades interface{} = this.SafeValue(GetValue(data, i), "data", []interface{}{})
			for j := 0; IsLessThan(j, GetArrayLength(trades)); j++ {
				var trade interface{} = this.ParseTrade(GetValue(trades, j), market)
				AppendToArray(&result, trade)
			}
		}
		result = this.SortBy(result, "timestamp")

		ch <- this.FilterBySymbolSinceLimit(result, GetValue(market, "symbol"), since, limit)
		return nil

	}()
	return ch
}
func (this *HtxCore) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "amount":1.2082,
	//         "open":0.025096,
	//         "close":0.025095,
	//         "high":0.025096,
	//         "id":1591515300,
	//         "count":6,
	//         "low":0.025095,
	//         "vol":0.0303205097
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	return []interface{}{this.SafeTimestamp(ohlcv, "id"), this.SafeNumber(ohlcv, "open"), this.SafeNumber(ohlcv, "high"), this.SafeNumber(ohlcv, "low"), this.SafeNumber(ohlcv, "close"), this.SafeNumber(ohlcv, "amount")}
}

/**
 * @method
 * @name htx#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://huobiapi.github.io/docs/spot/v1/en/#get-klines-candles
 * @see https://huobiapi.github.io/docs/dm/v1/en/#get-kline-data
 * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#get-kline-data
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#general-get-kline-data
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @param {string} [params.useHistoricalEndpointForSpot] true/false - whether use the historical candles endpoint for spot markets or default klines endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func (this *HtxCore) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		timeframe := GetArg(optionalArgs, 0, "1m")
		_ = timeframe
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes31748 := (<-this.LoadMarkets())
		PanicOnError(retRes31748)
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchOHLCV", "paginate")
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {

			retRes317819 := (<-this.FetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, params, 1000))
			PanicOnError(retRes317819)
			ch <- retRes317819
			return nil
		}
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"period": this.SafeString(this.Timeframes, timeframe, timeframe),
		}
		var priceType interface{} = this.SafeStringN(params, []interface{}{"priceType", "price"})
		params = this.Omit(params, []interface{}{"priceType", "price"})
		var until interface{} = nil
		untilparamsVariable := this.HandleParamInteger(params, "until")
		until = GetValue(untilparamsVariable, 0)
		params = GetValue(untilparamsVariable, 1)
		var untilSeconds interface{} = Ternary(IsTrue((!IsEqual(until, nil))), this.ParseToInt(Divide(until, 1000)), nil)
		if IsTrue(GetValue(market, "contract")) {
			if IsTrue(!IsEqual(limit, nil)) {
				AddElementToObject(request, "size", mathMin(limit, 2000)) // when using limit: from & to are ignored
			} else {
				limit = 2000 // only used for from/to calculation
			}
			if IsTrue(IsEqual(priceType, nil)) {
				var duration interface{} = this.ParseTimeframe(timeframe)
				var calcualtedEnd interface{} = nil
				if IsTrue(IsEqual(since, nil)) {
					var now interface{} = this.Seconds()
					AddElementToObject(request, "from", Subtract(now, Multiply(duration, (Subtract(limit, 1)))))
					calcualtedEnd = now
				} else {
					var start interface{} = this.ParseToInt(Divide(since, 1000))
					AddElementToObject(request, "from", start)
					calcualtedEnd = this.Sum(start, Multiply(duration, (Subtract(limit, 1))))
				}
				AddElementToObject(request, "to", Ternary(IsTrue((!IsEqual(untilSeconds, nil))), untilSeconds, calcualtedEnd))
			}
		}
		var response interface{} = nil
		if IsTrue(GetValue(market, "future")) {
			if IsTrue(GetValue(market, "inverse")) {
				AddElementToObject(request, "symbol", GetValue(market, "id"))
				if IsTrue(IsEqual(priceType, "mark")) {

					response = (<-this.ContractPublicGetIndexMarketHistoryMarkPriceKline(this.Extend(request, params)))
					PanicOnError(response)
				} else if IsTrue(IsEqual(priceType, "index")) {

					response = (<-this.ContractPublicGetIndexMarketHistoryIndex(this.Extend(request, params)))
					PanicOnError(response)
				} else if IsTrue(IsEqual(priceType, "premiumIndex")) {
					panic(BadRequest(Add(Add(Add(Add(Add(this.Id, " "), GetValue(market, "type")), " has no api endpoint for "), priceType), " kline data")))
				} else {

					response = (<-this.ContractPublicGetMarketHistoryKline(this.Extend(request, params)))
					PanicOnError(response)
				}
			} else if IsTrue(GetValue(market, "linear")) {
				AddElementToObject(request, "contract_code", GetValue(market, "id"))
				if IsTrue(IsEqual(priceType, "mark")) {

					response = (<-this.ContractPublicGetIndexMarketHistoryLinearSwapMarkPriceKline(this.Extend(request, params)))
					PanicOnError(response)
				} else if IsTrue(IsEqual(priceType, "index")) {
					panic(BadRequest(Add(Add(Add(Add(Add(this.Id, " "), GetValue(market, "type")), " has no api endpoint for "), priceType), " kline data")))
				} else if IsTrue(IsEqual(priceType, "premiumIndex")) {

					response = (<-this.ContractPublicGetIndexMarketHistoryLinearSwapPremiumIndexKline(this.Extend(request, params)))
					PanicOnError(response)
				} else {

					response = (<-this.ContractPublicGetLinearSwapExMarketHistoryKline(this.Extend(request, params)))
					PanicOnError(response)
				}
			}
		} else if IsTrue(GetValue(market, "swap")) {
			AddElementToObject(request, "contract_code", GetValue(market, "id"))
			if IsTrue(GetValue(market, "inverse")) {
				if IsTrue(IsEqual(priceType, "mark")) {

					response = (<-this.ContractPublicGetIndexMarketHistorySwapMarkPriceKline(this.Extend(request, params)))
					PanicOnError(response)
				} else if IsTrue(IsEqual(priceType, "index")) {
					panic(BadRequest(Add(Add(Add(Add(Add(this.Id, " "), GetValue(market, "type")), " has no api endpoint for "), priceType), " kline data")))
				} else if IsTrue(IsEqual(priceType, "premiumIndex")) {

					response = (<-this.ContractPublicGetIndexMarketHistorySwapPremiumIndexKline(this.Extend(request, params)))
					PanicOnError(response)
				} else {

					response = (<-this.ContractPublicGetSwapExMarketHistoryKline(this.Extend(request, params)))
					PanicOnError(response)
				}
			} else if IsTrue(GetValue(market, "linear")) {
				if IsTrue(IsEqual(priceType, "mark")) {

					response = (<-this.ContractPublicGetIndexMarketHistoryLinearSwapMarkPriceKline(this.Extend(request, params)))
					PanicOnError(response)
				} else if IsTrue(IsEqual(priceType, "index")) {
					panic(BadRequest(Add(Add(Add(Add(Add(this.Id, " "), GetValue(market, "type")), " has no api endpoint for "), priceType), " kline data")))
				} else if IsTrue(IsEqual(priceType, "premiumIndex")) {

					response = (<-this.ContractPublicGetIndexMarketHistoryLinearSwapPremiumIndexKline(this.Extend(request, params)))
					PanicOnError(response)
				} else {

					response = (<-this.ContractPublicGetLinearSwapExMarketHistoryKline(this.Extend(request, params)))
					PanicOnError(response)
				}
			}
		} else {
			AddElementToObject(request, "symbol", GetValue(market, "id"))
			var useHistorical interface{} = nil
			useHistoricalparamsVariable := this.HandleOptionAndParams(params, "fetchOHLCV", "useHistoricalEndpointForSpot", true)
			useHistorical = GetValue(useHistoricalparamsVariable, 0)
			params = GetValue(useHistoricalparamsVariable, 1)
			if !IsTrue(useHistorical) {
				if IsTrue(!IsEqual(limit, nil)) {
					AddElementToObject(request, "size", mathMin(limit, 2000)) // max 2000
				}

				response = (<-this.SpotPublicGetMarketHistoryKline(this.Extend(request, params)))
				PanicOnError(response)
			} else {
				// "from & to" only available for the this endpoint
				if IsTrue(!IsEqual(since, nil)) {
					AddElementToObject(request, "from", this.ParseToInt(Divide(since, 1000)))
				}
				if IsTrue(!IsEqual(untilSeconds, nil)) {
					AddElementToObject(request, "to", untilSeconds)
				}
				if IsTrue(!IsEqual(limit, nil)) {
					AddElementToObject(request, "size", mathMin(1000, limit)) // max 1000, otherwise default returns 150
				}

				response = (<-this.SpotPublicGetMarketHistoryCandles(this.Extend(request, params)))
				PanicOnError(response)
			}
		}
		//
		//     {
		//         "status":"ok",
		//         "ch":"market.ethbtc.kline.1min",
		//         "ts":1591515374371,
		//         "data":[
		//             {"amount":0.0,"open":0.025095,"close":0.025095,"high":0.025095,"id":1591515360,"count":0,"low":0.025095,"vol":0.0},
		//             {"amount":1.2082,"open":0.025096,"close":0.025095,"high":0.025096,"id":1591515300,"count":6,"low":0.025095,"vol":0.0303205097},
		//             {"amount":0.0648,"open":0.025096,"close":0.025096,"high":0.025096,"id":1591515240,"count":2,"low":0.025096,"vol":0.0016262208},
		//         ]
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseOHLCVs(data, market, timeframe, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name htx#fetchAccounts
 * @description fetch all the accounts associated with a profile
 * @see https://huobiapi.github.io/docs/spot/v1/en/#get-all-accounts-of-the-current-user
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/?id=account-structure} indexed by the account type
 */
func (this *HtxCore) FetchAccounts(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes33128 := (<-this.LoadMarkets())
		PanicOnError(retRes33128)

		response := (<-this.SpotPrivateGetV1AccountAccounts(params))
		PanicOnError(response)
		//
		//     {
		//         "status":"ok",
		//         "data":[
		//             {"id":5202591,"type":"point","subtype":"","state":"working"},
		//             {"id":1528640,"type":"spot","subtype":"","state":"working"},
		//         ]
		//     }
		//
		var data interface{} = this.SafeValue(response, "data")

		ch <- this.ParseAccounts(data)
		return nil

	}()
	return ch
}
func (this *HtxCore) ParseAccount(account interface{}) interface{} {
	//
	//     {
	//         "id": 5202591,
	//         "type": "point",   // spot, margin, otc, point, super-margin, investment, borrow, grid-trading, deposit-earning, otc-options
	//         "subtype": "",     // The corresponding trading symbol (currency pair) the isolated margin is based on, e.g. btcusdt
	//         "state": "working" // working, lock
	//     }
	//
	var typeId interface{} = this.SafeString(account, "type")
	var accountsById interface{} = this.SafeValue(this.Options, "accountsById", map[string]interface{}{})
	var typeVar interface{} = this.SafeValue(accountsById, typeId, typeId)
	return map[string]interface{}{
		"info": account,
		"id":   this.SafeString(account, "id"),
		"type": typeVar,
		"code": nil,
	}
}

/**
 * @method
 * @name htx#fetchAccountIdByType
 * @description fetch all the accounts by a type and marginModeassociated with a profile
 * @see https://huobiapi.github.io/docs/spot/v1/en/#get-all-accounts-of-the-current-user
 * @param {string} type 'spot', 'swap' or 'future
 * @param {string} [marginMode] 'cross' or 'isolated'
 * @param {string} [symbol] unified ccxt market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/?id=account-structure} indexed by the account type
 */
func (this *HtxCore) FetchAccountIdByType(typeVar interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		marginMode := GetArg(optionalArgs, 0, nil)
		_ = marginMode
		symbol := GetArg(optionalArgs, 1, nil)
		_ = symbol
		params := GetArg(optionalArgs, 2, map[string]interface{}{})
		_ = params

		accounts := (<-this.LoadAccounts())
		PanicOnError(accounts)
		var accountId interface{} = this.SafeValue2(params, "accountId", "account-id")
		if IsTrue(!IsEqual(accountId, nil)) {

			ch <- accountId
			return nil
		}
		if IsTrue(IsEqual(typeVar, "spot")) {
			if IsTrue(IsEqual(marginMode, "cross")) {
				typeVar = "super-margin"
			} else if IsTrue(IsEqual(marginMode, "isolated")) {
				typeVar = "margin"
			}
		}
		var marketId interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			marketId = this.MarketId(symbol)
		}
		for i := 0; IsLessThan(i, GetArrayLength(accounts)); i++ {
			var account interface{} = GetValue(accounts, i)
			var info interface{} = this.SafeValue(account, "info")
			var subtype interface{} = this.SafeString(info, "subtype", nil)
			var typeFromAccount interface{} = this.SafeString(account, "type")
			if IsTrue(IsEqual(typeVar, "margin")) {
				if IsTrue(IsEqual(subtype, marketId)) {

					ch <- this.SafeString(account, "id")
					return nil
				}
			} else if IsTrue(IsEqual(typeVar, typeFromAccount)) {

				ch <- this.SafeString(account, "id")
				return nil
			}
		}
		var defaultAccount interface{} = this.SafeValue(accounts, 0, map[string]interface{}{})

		ch <- this.SafeString(defaultAccount, "id")
		return nil

	}()
	return ch
}

/**
 * @method
 * @name htx#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see https://huobiapi.github.io/docs/spot/v1/en/#apiv2-currency-amp-chains
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func (this *HtxCore) FetchCurrencies(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		response := (<-this.SpotPublicGetV2ReferenceCurrencies(params))
		PanicOnError(response)
		//
		//    {
		//        "code": 200,
		//        "data": [
		//            {
		//                "currency": "sxp",
		//                "assetType": "1",
		//                "chains": [
		//                    {
		//                        "chain": "sxp",
		//                        "displayName": "ERC20",
		//                        "baseChain": "ETH",
		//                        "baseChainProtocol": "ERC20",
		//                        "isDynamic": true,
		//                        "numOfConfirmations": "12",
		//                        "numOfFastConfirmations": "12",
		//                        "depositStatus": "allowed",
		//                        "minDepositAmt": "0.23",
		//                        "withdrawStatus": "allowed",
		//                        "minWithdrawAmt": "0.23",
		//                        "withdrawPrecision": "8",
		//                        "maxWithdrawAmt": "227000.000000000000000000",
		//                        "withdrawQuotaPerDay": "227000.000000000000000000",
		//                        "withdrawQuotaPerYear": null,
		//                        "withdrawQuotaTotal": null,
		//                        "withdrawFeeType": "fixed",
		//                        "transactFeeWithdraw": "11.1654",
		//                        "addrWithTag": false,
		//                        "addrDepositTag": false
		//                    }
		//                ],
		//                "instStatus": "normal"
		//            }
		//        ]
		//    }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var result interface{} = map[string]interface{}{}
		AddElementToObject(this.Options, "networkChainIdsByNames", map[string]interface{}{})
		AddElementToObject(this.Options, "networkNamesByChainIds", map[string]interface{}{})
		for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
			var entry interface{} = GetValue(data, i)
			var currencyId interface{} = this.SafeString(entry, "currency")
			var code interface{} = this.SafeCurrencyCode(currencyId)
			var assetType interface{} = this.SafeString(entry, "assetType")
			var typeVar interface{} = Ternary(IsTrue(IsEqual(assetType, "1")), "crypto", "fiat")
			AddElementToObject(GetValue(this.Options, "networkChainIdsByNames"), code, map[string]interface{}{})
			var chains interface{} = this.SafeList(entry, "chains", []interface{}{})
			var networks interface{} = map[string]interface{}{}
			for j := 0; IsLessThan(j, GetArrayLength(chains)); j++ {
				var chainEntry interface{} = GetValue(chains, j)
				var uniqueChainId interface{} = this.SafeString(chainEntry, "chain")             // i.e. usdterc20, trc20usdt ...
				var title interface{} = this.SafeString2(chainEntry, "baseChain", "displayName") // baseChain and baseChainProtocol are together existent or inexistent in entries, but baseChain is preferred. when they are both inexistent, then we use generic displayName
				AddElementToObject(GetValue(GetValue(this.Options, "networkChainIdsByNames"), code), title, uniqueChainId)
				AddElementToObject(GetValue(this.Options, "networkNamesByChainIds"), uniqueChainId, title)
				var networkCode interface{} = this.NetworkIdToCode(uniqueChainId)
				AddElementToObject(networks, networkCode, map[string]interface{}{
					"info":    chainEntry,
					"id":      uniqueChainId,
					"network": networkCode,
					"limits": map[string]interface{}{
						"deposit": map[string]interface{}{
							"min": this.SafeNumber(chainEntry, "minDepositAmt"),
							"max": nil,
						},
						"withdraw": map[string]interface{}{
							"min": this.SafeNumber(chainEntry, "minWithdrawAmt"),
							"max": this.SafeNumber(chainEntry, "maxWithdrawAmt"),
						},
					},
					"active":    nil,
					"deposit":   IsEqual(this.SafeString(chainEntry, "depositStatus"), "allowed"),
					"withdraw":  IsEqual(this.SafeString(chainEntry, "withdrawStatus"), "allowed"),
					"fee":       this.SafeNumber(chainEntry, "transactFeeWithdraw"),
					"precision": this.ParseNumber(this.ParsePrecision(this.SafeString(chainEntry, "withdrawPrecision"))),
				})
			}
			AddElementToObject(result, code, this.SafeCurrencyStructure(map[string]interface{}{
				"info":     entry,
				"code":     code,
				"id":       currencyId,
				"active":   IsEqual(this.SafeString(entry, "instStatus"), "normal"),
				"deposit":  nil,
				"withdraw": nil,
				"fee":      nil,
				"name":     nil,
				"type":     typeVar,
				"limits": map[string]interface{}{
					"amount": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
					"withdraw": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
					"deposit": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
				},
				"precision": nil,
				"networks":  networks,
			}))
		}

		ch <- result
		return nil

	}()
	return ch
}
func (this *HtxCore) NetworkIdToCode(optionalArgs ...interface{}) interface{} {
	// here network-id is provided as a pair of currency & chain (i.e. trc20usdt)
	networkId := GetArg(optionalArgs, 0, nil)
	_ = networkId
	currencyCode := GetArg(optionalArgs, 1, nil)
	_ = currencyCode
	var keys interface{} = ObjectKeys(GetValue(this.Options, "networkNamesByChainIds"))
	var keysLength interface{} = GetArrayLength(keys)
	if IsTrue(IsEqual(keysLength, 0)) {
		panic(ExchangeError(Add(this.Id, " networkIdToCode() - markets need to be loaded at first")))
	}
	var networkTitle interface{} = this.SafeValue(GetValue(this.Options, "networkNamesByChainIds"), networkId, networkId)
	return this.Exchange.NetworkIdToCode(networkTitle)
}
func (this *HtxCore) NetworkCodeToId(networkCode interface{}, optionalArgs ...interface{}) interface{} {
	currencyCode := GetArg(optionalArgs, 0, nil)
	_ = currencyCode
	if IsTrue(IsEqual(currencyCode, nil)) {
		panic(ArgumentsRequired(Add(this.Id, " networkCodeToId() requires a currencyCode argument")))
	}
	var keys interface{} = ObjectKeys(GetValue(this.Options, "networkChainIdsByNames"))
	var keysLength interface{} = GetArrayLength(keys)
	if IsTrue(IsEqual(keysLength, 0)) {
		panic(ExchangeError(Add(this.Id, " networkCodeToId() - markets need to be loaded at first")))
	}
	var uniqueNetworkIds interface{} = this.SafeValue(GetValue(this.Options, "networkChainIdsByNames"), currencyCode, map[string]interface{}{})
	if IsTrue(InOp(uniqueNetworkIds, networkCode)) {
		return GetValue(uniqueNetworkIds, networkCode)
	} else {
		var networkTitle interface{} = this.Exchange.NetworkCodeToId(networkCode)
		return this.SafeValue(uniqueNetworkIds, networkTitle, networkTitle)
	}
}

/**
 * @method
 * @name htx#fetchBalance
 * @see https://huobiapi.github.io/docs/spot/v1/en/#get-account-balance-of-a-specific-account
 * @see https://www.htx.com/en-us/opend/newApiPages/?id=7ec4b429-7773-11ed-9966-0242ac110003
 * @see https://www.htx.com/en-us/opend/newApiPages/?id=10000074-77b7-11ed-9966-0242ac110003
 * @see https://huobiapi.github.io/docs/dm/v1/en/#query-asset-valuation
 * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#query-user-s-account-information
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#isolated-query-user-s-account-information
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#cross-query-user-39-s-account-information
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {bool} [params.unified] provide this parameter if you have a recent account with unified cross+isolated margin account
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/?id=balance-structure}
 */
func (this *HtxCore) FetchBalance(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes35558 := (<-this.LoadMarkets())
		PanicOnError(retRes35558)
		var typeVar interface{} = nil
		typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchBalance", nil, params)
		typeVar = GetValue(typeVarparamsVariable, 0)
		params = GetValue(typeVarparamsVariable, 1)
		var options interface{} = this.SafeValue(this.Options, "fetchBalance", map[string]interface{}{})
		var isUnifiedAccount interface{} = this.SafeValue2(params, "isUnifiedAccount", "unified", false)
		params = this.Omit(params, []interface{}{"isUnifiedAccount", "unified"})
		var request interface{} = map[string]interface{}{}
		var spot interface{} = (IsEqual(typeVar, "spot"))
		var future interface{} = (IsEqual(typeVar, "future"))
		var defaultSubType interface{} = this.SafeString2(this.Options, "defaultSubType", "subType", "linear")
		var subType interface{} = this.SafeString2(options, "defaultSubType", "subType", defaultSubType)
		subType = this.SafeString2(params, "defaultSubType", "subType", subType)
		var inverse interface{} = (IsEqual(subType, "inverse"))
		var linear interface{} = (IsEqual(subType, "linear"))
		var marginMode interface{} = nil
		marginModeparamsVariable := this.HandleMarginModeAndParams("fetchBalance", params)
		marginMode = GetValue(marginModeparamsVariable, 0)
		params = GetValue(marginModeparamsVariable, 1)
		params = this.Omit(params, []interface{}{"defaultSubType", "subType"})
		var isolated interface{} = (IsEqual(marginMode, "isolated"))
		var cross interface{} = (IsEqual(marginMode, "cross"))
		var margin interface{} = IsTrue((IsEqual(typeVar, "margin"))) || IsTrue((IsTrue(spot) && IsTrue((IsTrue(cross) || IsTrue(isolated)))))
		var response interface{} = nil
		if IsTrue(IsTrue(spot) || IsTrue(margin)) {
			if IsTrue(margin) {
				if IsTrue(isolated) {

					response = (<-this.SpotPrivateGetV1MarginAccountsBalance(this.Extend(request, params)))
					PanicOnError(response)
				} else {

					response = (<-this.SpotPrivateGetV1CrossMarginAccountsBalance(this.Extend(request, params)))
					PanicOnError(response)
				}
			} else {

				retRes358416 := (<-this.LoadAccounts())
				PanicOnError(retRes358416)

				accountId := (<-this.FetchAccountIdByType(typeVar, nil, nil, params))
				PanicOnError(accountId)
				AddElementToObject(request, "account-id", accountId)

				response = (<-this.SpotPrivateGetV1AccountAccountsAccountIdBalance(this.Extend(request, params)))
				PanicOnError(response)
			}
		} else if IsTrue(isUnifiedAccount) {

			response = (<-this.ContractPrivateGetLinearSwapApiV3UnifiedAccountInfo(this.Extend(request, params)))
			PanicOnError(response)
		} else if IsTrue(linear) {
			if IsTrue(isolated) {

				response = (<-this.ContractPrivatePostLinearSwapApiV1SwapAccountInfo(this.Extend(request, params)))
				PanicOnError(response)
			} else {

				response = (<-this.ContractPrivatePostLinearSwapApiV1SwapCrossAccountInfo(this.Extend(request, params)))
				PanicOnError(response)
			}
		} else if IsTrue(inverse) {
			if IsTrue(future) {

				response = (<-this.ContractPrivatePostApiV1ContractAccountInfo(this.Extend(request, params)))
				PanicOnError(response)
			} else {

				response = (<-this.ContractPrivatePostSwapApiV1SwapAccountInfo(this.Extend(request, params)))
				PanicOnError(response)
			}
		}
		//
		// spot
		//
		//     {
		//         "status": "ok",
		//         "data": {
		//             "id": 1528640,
		//             "type": "spot",
		//             "state": "working",
		//             "list": [
		//                 { "currency": "lun", "type": "trade", "balance": "0", "seq-num": "0" },
		//                 { "currency": "lun", "type": "frozen", "balance": "0", "seq-num": "0" },
		//                 { "currency": "ht", "type": "frozen", "balance": "0", "seq-num": "145" },
		//             ]
		//         },
		//         "ts":1637644827566
		//     }
		//
		// cross margin
		//
		//     {
		//         "status": "ok",
		//         "data": {
		//             "id": 51015302,
		//             "type": "cross-margin",
		//             "state": "working",
		//             "risk-rate": "2",
		//             "acct-balance-sum": "100",
		//             "debt-balance-sum": "0",
		//             "list": [
		//                 { "currency": "usdt", "type": "trade", "balance": "100" },
		//                 { "currency": "usdt", "type": "frozen", "balance": "0" },
		//                 { "currency": "usdt", "type": "loan-available", "balance": "200" },
		//                 { "currency": "usdt", "type": "transfer-out-available", "balance": "-1" },
		//                 { "currency": "ht", "type": "loan-available", "balance": "36.60724091" },
		//                 { "currency": "ht", "type": "transfer-out-available", "balance": "-1" },
		//                 { "currency": "btc", "type": "trade", "balance": "1168.533000000000000000" },
		//                 { "currency": "btc", "type": "frozen", "balance": "0.000000000000000000" },
		//                 { "currency": "btc", "type": "loan", "balance": "-2.433000000000000000" },
		//                 { "currency": "btc", "type": "interest", "balance": "-0.000533000000000000" },
		//                 { "currency": "btc", "type": "transfer-out-available", "balance": "1163.872174670000000000" },
		//                 { "currency": "btc", "type": "loan-available", "balance": "8161.876538350676000000" }
		//             ]
		//         },
		//         "code": 200
		//     }
		//
		// isolated margin
		//
		//     {
		//         "data": [
		//             {
		//                 "id": 18264,
		//                 "type": "margin",
		//                 "state": "working",
		//                 "symbol": "btcusdt",
		//                 "fl-price": "0",
		//                 "fl-type": "safe",
		//                 "risk-rate": "475.952571086994250554",
		//                 "list": [
		//                     { "currency": "btc","type": "trade","balance": "1168.533000000000000000" },
		//                     { "currency": "btc","type": "frozen","balance": "0.000000000000000000" },
		//                     { "currency": "btc","type": "loan","balance": "-2.433000000000000000" },
		//                     { "currency": "btc","type": "interest","balance": "-0.000533000000000000" },
		//                     { "currency": "btc","type": "transfer-out-available", "balance": "1163.872174670000000000" },
		//                     { "currency": "btc","type": "loan-available", "balance": "8161.876538350676000000" }
		//                 ]
		//             }
		//         ]
		//     }
		//
		// future, swap isolated
		//
		//     {
		//         "status": "ok",
		//         "data": [
		//             {
		//                 "symbol": "BTC",
		//                 "margin_balance": 0,
		//                 "margin_position": 0E-18,
		//                 "margin_frozen": 0,
		//                 "margin_available": 0E-18,
		//                 "profit_real": 0,
		//                 "profit_unreal": 0,
		//                 "risk_rate": null,
		//                 "withdraw_available": 0,
		//                 "liquidation_price": null,
		//                 "lever_rate": 5,
		//                 "adjust_factor": 0.025000000000000000,
		//                 "margin_static": 0,
		//                 "is_debit": 0, // future only
		//                 "contract_code": "BTC-USD", // swap only
		//                 "margin_asset": "USDT", // linear only
		//                 "margin_mode": "isolated", // linear only
		//                 "margin_account": "BTC-USDT" // linear only
		//                 "transfer_profit_ratio": null // inverse only
		//             },
		//         ],
		//         "ts": 1637644827566
		//     }
		//
		// linear cross futures and linear cross swap
		//
		//     {
		//         "status": "ok",
		//         "data": [
		//             {
		//                 "futures_contract_detail": [
		//                     {
		//                         "symbol": "ETH",
		//                         "contract_code": "ETH-USDT-220325",
		//                         "margin_position": 0,
		//                         "margin_frozen": 0,
		//                         "margin_available": 200.000000000000000000,
		//                         "profit_unreal": 0E-18,
		//                         "liquidation_price": null,
		//                         "lever_rate": 5,
		//                         "adjust_factor": 0.060000000000000000,
		//                         "contract_type": "quarter",
		//                         "pair": "ETH-USDT",
		//                         "business_type": "futures"
		//                     },
		//                 ],
		//                 "margin_mode": "cross",
		//                 "margin_account": "USDT",
		//                 "margin_asset": "USDT",
		//                 "margin_balance": 49.874186030200000000,
		//                 "money_in": 50,
		//                 "money_out": 0,
		//                 "margin_static": 49.872786030200000000,
		//                 "margin_position": 6.180000000000000000,
		//                 "margin_frozen": 6.000000000000000000,
		//                 "profit_unreal": 0.001400000000000000,
		//                 "withdraw_available": 37.6927860302,
		//                 "risk_rate": 271.984050521072796934,
		//                 "new_risk_rate": 0.001858676950514399,
		//                 "contract_detail": [
		//                     {
		//                         "symbol": "MANA",
		//                         "contract_code": "MANA-USDT",
		//                         "margin_position": 0,
		//                         "margin_frozen": 0,
		//                         "margin_available": 200.000000000000000000,
		//                         "profit_unreal": 0E-18,
		//                         "liquidation_price": null,
		//                         "lever_rate": 5,
		//                         "adjust_factor": 0.100000000000000000,
		//                         "contract_type": "swap",
		//                         "pair": "MANA-USDT",
		//                         "business_type": "swap"
		//                     },
		//                 ]
		//             }
		//         ],
		//         "ts": 1640915104870
		//     }
		//
		// TODO add balance parsing for linear swap
		//
		var result interface{} = map[string]interface{}{
			"info": response,
		}
		var data interface{} = this.SafeValue(response, "data")
		if IsTrue(IsTrue(spot) || IsTrue(margin)) {
			if IsTrue(isolated) {
				for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
					var entry interface{} = GetValue(data, i)
					var symbol interface{} = this.SafeSymbol(this.SafeString(entry, "symbol"))
					var balances interface{} = this.SafeValue(entry, "list")
					var subResult interface{} = map[string]interface{}{}
					for j := 0; IsLessThan(j, GetArrayLength(balances)); j++ {
						var balance interface{} = GetValue(balances, j)
						var currencyId interface{} = this.SafeString(balance, "currency")
						var code interface{} = this.SafeCurrencyCode(currencyId)
						AddElementToObject(subResult, code, this.ParseMarginBalanceHelper(balance, code, subResult))
					}
					AddElementToObject(result, symbol, this.SafeBalance(subResult))
				}
			} else {
				var balances interface{} = this.SafeValue(data, "list", []interface{}{})
				for i := 0; IsLessThan(i, GetArrayLength(balances)); i++ {
					var balance interface{} = GetValue(balances, i)
					var currencyId interface{} = this.SafeString(balance, "currency")
					var code interface{} = this.SafeCurrencyCode(currencyId)
					AddElementToObject(result, code, this.ParseMarginBalanceHelper(balance, code, result))
				}
				result = this.SafeBalance(result)
			}
		} else if IsTrue(isUnifiedAccount) {
			for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
				var entry interface{} = GetValue(data, i)
				var marginAsset interface{} = this.SafeString(entry, "margin_asset")
				var currencyCode interface{} = this.SafeCurrencyCode(marginAsset)
				if IsTrue(isolated) {
					var isolated_swap interface{} = this.SafeValue(entry, "isolated_swap", map[string]interface{}{})
					for j := 0; IsLessThan(j, GetArrayLength(isolated_swap)); j++ {
						var balance interface{} = GetValue(isolated_swap, j)
						var marketId interface{} = this.SafeString(balance, "contract_code")
						var subBalance interface{} = map[string]interface{}{
							"code": currencyCode,
							"free": this.SafeNumber(balance, "margin_available"),
						}
						var symbol interface{} = this.SafeSymbol(marketId)
						AddElementToObject(result, symbol, subBalance)
						result = this.SafeBalance(result)
					}
				} else {
					var account interface{} = this.Account()
					AddElementToObject(account, "free", this.SafeString(entry, "margin_static"))
					AddElementToObject(account, "used", this.SafeString(entry, "margin_frozen"))
					AddElementToObject(result, currencyCode, account)
					result = this.SafeBalance(result)
				}
			}
		} else if IsTrue(linear) {
			var first interface{} = this.SafeValue(data, 0, map[string]interface{}{})
			if IsTrue(isolated) {
				for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
					var balance interface{} = GetValue(data, i)
					var marketId interface{} = this.SafeString2(balance, "contract_code", "margin_account")
					var market interface{} = this.SafeMarket(marketId)
					var currencyId interface{} = this.SafeString(balance, "margin_asset")
					var currency interface{} = this.SafeCurrency(currencyId)
					var code interface{} = this.SafeString(market, "settle", GetValue(currency, "code"))
					// the exchange outputs positions for delisted markets
					// https://www.huobi.com/support/en-us/detail/74882968522337
					// we skip it if the market was delisted
					if IsTrue(!IsEqual(code, nil)) {
						var account interface{} = this.Account()
						AddElementToObject(account, "free", this.SafeString(balance, "margin_balance"))
						AddElementToObject(account, "used", this.SafeString(balance, "margin_frozen"))
						var accountsByCode interface{} = map[string]interface{}{}
						AddElementToObject(accountsByCode, code, account)
						var symbol interface{} = GetValue(market, "symbol")
						AddElementToObject(result, symbol, this.SafeBalance(accountsByCode))
					}
				}
			} else {
				var account interface{} = this.Account()
				AddElementToObject(account, "free", this.SafeString(first, "withdraw_available"))
				AddElementToObject(account, "total", this.SafeString(first, "margin_balance"))
				var currencyId interface{} = this.SafeString2(first, "margin_asset", "symbol")
				var code interface{} = this.SafeCurrencyCode(currencyId)
				AddElementToObject(result, code, account)
				result = this.SafeBalance(result)
			}
		} else if IsTrue(inverse) {
			for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
				var balance interface{} = GetValue(data, i)
				var currencyId interface{} = this.SafeString(balance, "symbol")
				var code interface{} = this.SafeCurrencyCode(currencyId)
				var account interface{} = this.Account()
				AddElementToObject(account, "free", this.SafeString(balance, "margin_available"))
				AddElementToObject(account, "used", this.SafeString(balance, "margin_frozen"))
				AddElementToObject(result, code, account)
			}
			result = this.SafeBalance(result)
		}

		ch <- result
		return nil

	}()
	return ch
}

/**
 * @method
 * @name htx#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://huobiapi.github.io/docs/spot/v1/en/#get-the-order-detail-of-an-order-based-on-client-order-id
 * @see https://huobiapi.github.io/docs/spot/v1/en/#get-the-order-detail-of-an-order
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#isolated-get-information-of-an-order
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#cross-get-information-of-order
 * @see https://huobiapi.github.io/docs/dm/v1/en/#get-information-of-an-order
 * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#get-information-of-an-order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *HtxCore) FetchOrder(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes38798 := (<-this.LoadMarkets())
		PanicOnError(retRes38798)
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
		}
		var marketType interface{} = nil
		marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchOrder", market, params)
		marketType = GetValue(marketTypeparamsVariable, 0)
		params = GetValue(marketTypeparamsVariable, 1)
		var request interface{} = map[string]interface{}{}
		var response interface{} = nil
		if IsTrue(IsEqual(marketType, "spot")) {
			var clientOrderId interface{} = this.SafeString(params, "clientOrderId")
			if IsTrue(!IsEqual(clientOrderId, nil)) {
				// will be filled below in extend ()
				// they expect clientOrderId instead of client-order-id
				// request['clientOrderId'] = clientOrderId;

				response = (<-this.SpotPrivateGetV1OrderOrdersGetClientOrder(this.Extend(request, params)))
				PanicOnError(response)
			} else {
				AddElementToObject(request, "order-id", id)

				response = (<-this.SpotPrivateGetV1OrderOrdersOrderId(this.Extend(request, params)))
				PanicOnError(response)
			}
		} else {
			if IsTrue(IsEqual(symbol, nil)) {
				panic(ArgumentsRequired(Add(this.Id, " fetchOrder() requires a symbol argument")))
			}
			var clientOrderId interface{} = this.SafeString2(params, "client_order_id", "clientOrderId")
			if IsTrue(IsEqual(clientOrderId, nil)) {
				AddElementToObject(request, "order_id", id)
			} else {
				AddElementToObject(request, "client_order_id", clientOrderId)
				params = this.Omit(params, []interface{}{"client_order_id", "clientOrderId"})
			}
			AddElementToObject(request, "contract_code", GetValue(market, "id"))
			if IsTrue(GetValue(market, "linear")) {
				var marginMode interface{} = nil
				marginModeparamsVariable := this.HandleMarginModeAndParams("fetchOrder", params)
				marginMode = GetValue(marginModeparamsVariable, 0)
				params = GetValue(marginModeparamsVariable, 1)
				marginMode = Ternary(IsTrue((IsEqual(marginMode, nil))), "cross", marginMode)
				if IsTrue(IsEqual(marginMode, "isolated")) {

					response = (<-this.ContractPrivatePostLinearSwapApiV1SwapOrderInfo(this.Extend(request, params)))
					PanicOnError(response)
				} else if IsTrue(IsEqual(marginMode, "cross")) {

					response = (<-this.ContractPrivatePostLinearSwapApiV1SwapCrossOrderInfo(this.Extend(request, params)))
					PanicOnError(response)
				}
			} else if IsTrue(GetValue(market, "inverse")) {
				if IsTrue(IsEqual(marketType, "future")) {
					AddElementToObject(request, "symbol", GetValue(market, "settleId"))

					response = (<-this.ContractPrivatePostApiV1ContractOrderInfo(this.Extend(request, params)))
					PanicOnError(response)
				} else if IsTrue(IsEqual(marketType, "swap")) {

					response = (<-this.ContractPrivatePostSwapApiV1SwapOrderInfo(this.Extend(request, params)))
					PanicOnError(response)
				} else {
					panic(NotSupported(Add(Add(Add(this.Id, " fetchOrder() does not support "), marketType), " markets")))
				}
			}
		}
		//
		// spot
		//
		//     {
		//         "status":"ok",
		//         "data":{
		//             "id":438398393065481,
		//             "symbol":"ethusdt",
		//             "account-id":1528640,
		//             "client-order-id":"AA03022abc2163433e-006b-480e-9ad1-d4781478c5e7",
		//             "amount":"0.100000000000000000",
		//             "price":"3000.000000000000000000",
		//             "created-at":1640549994642,
		//             "type":"buy-limit",
		//             "field-amount":"0.0",
		//             "field-cash-amount":"0.0",
		//             "field-fees":"0.0",
		//             "finished-at":0,
		//             "source":"spot-api",
		//             "state":"submitted",
		//             "canceled-at":0
		//         }
		//     }
		//
		// linear swap cross margin
		//
		//     {
		//         "status":"ok",
		//         "data":[
		//             {
		//                 "business_type":"swap",
		//                 "contract_type":"swap",
		//                 "pair":"BTC-USDT",
		//                 "symbol":"BTC",
		//                 "contract_code":"BTC-USDT",
		//                 "volume":1,
		//                 "price":3000,
		//                 "order_price_type":"limit",
		//                 "order_type":1,
		//                 "direction":"buy",
		//                 "offset":"open",
		//                 "lever_rate":1,
		//                 "order_id":924912513206878210,
		//                 "client_order_id":null,
		//                 "created_at":1640557927189,
		//                 "trade_volume":0,
		//                 "trade_turnover":0,
		//                 "fee":0,
		//                 "trade_avg_price":null,
		//                 "margin_frozen":3.000000000000000000,
		//                 "profit":0,
		//                 "status":3,
		//                 "order_source":"api",
		//                 "order_id_str":"924912513206878210",
		//                 "fee_asset":"USDT",
		//                 "liquidation_type":"0",
		//                 "canceled_at":0,
		//                 "margin_asset":"USDT",
		//                 "margin_account":"USDT",
		//                 "margin_mode":"cross",
		//                 "is_tpsl":0,
		//                 "real_profit":0
		//             }
		//         ],
		//         "ts":1640557982556
		//     }
		//
		// linear swap isolated margin detail
		//
		//     {
		//         "status": "ok",
		//         "data": {
		//             "symbol": "BTC",
		//             "contract_code": "BTC-USDT",
		//             "instrument_price": 0,
		//             "final_interest": 0,
		//             "adjust_value": 0,
		//             "lever_rate": 10,
		//             "direction": "sell",
		//             "offset": "open",
		//             "volume": 1.000000000000000000,
		//             "price": 13059.800000000000000000,
		//             "created_at": 1603703614712,
		//             "canceled_at": 0,
		//             "order_source": "api",
		//             "order_price_type": "opponent",
		//             "margin_frozen": 0,
		//             "profit": 0,
		//             "trades": [
		//                 {
		//                     "trade_id": 131560927,
		//                     "trade_price": 13059.800000000000000000,
		//                     "trade_volume": 1.000000000000000000,
		//                     "trade_turnover": 13.059800000000000000,
		//                     "trade_fee": -0.005223920000000000,
		//                     "created_at": 1603703614715,
		//                     "role": "taker",
		//                     "fee_asset": "USDT",
		//                     "profit": 0,
		//                     "real_profit": 0,
		//                     "id": "131560927-770334322963152896-1"
		//                 }
		//             ],
		//             "total_page": 1,
		//             "current_page": 1,
		//             "total_size": 1,
		//             "liquidation_type": "0",
		//             "fee_asset": "USDT",
		//             "fee": -0.005223920000000000,
		//             "order_id": 770334322963152896,
		//             "order_id_str": "770334322963152896",
		//             "client_order_id": 57012021045,
		//             "order_type": "1",
		//             "status": 6,
		//             "trade_avg_price": 13059.800000000000000000,
		//             "trade_turnover": 13.059800000000000000,
		//             "trade_volume": 1.000000000000000000,
		//             "margin_asset": "USDT",
		//             "margin_mode": "isolated",
		//             "margin_account": "BTC-USDT",
		//             "real_profit": 0,
		//             "is_tpsl": 0
		//         },
		//         "ts": 1603703678477
		//     }
		var order interface{} = this.SafeValue(response, "data")
		if IsTrue(IsArray(order)) {
			order = this.SafeValue(order, 0)
		}

		ch <- this.ParseOrder(order)
		return nil

	}()
	return ch
}
func (this *HtxCore) ParseMarginBalanceHelper(balance interface{}, code interface{}, result interface{}) interface{} {
	var account interface{} = nil
	if IsTrue(InOp(result, code)) {
		account = GetValue(result, code)
	} else {
		account = this.Account()
	}
	if IsTrue(IsEqual(GetValue(balance, "type"), "trade")) {
		AddElementToObject(account, "free", this.SafeString(balance, "balance"))
	}
	if IsTrue(IsEqual(GetValue(balance, "type"), "frozen")) {
		AddElementToObject(account, "used", this.SafeString(balance, "balance"))
	}
	return account
}
func (this *HtxCore) FetchSpotOrdersByStates(states interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		var method interface{} = this.SafeString(this.Options, "fetchOrdersByStatesMethod", "spot_private_get_v1_order_orders") // spot_private_get_v1_order_history
		if IsTrue(IsEqual(method, "spot_private_get_v1_order_orders")) {
			if IsTrue(IsEqual(symbol, nil)) {
				panic(ArgumentsRequired(Add(this.Id, " fetchOrders() requires a symbol argument")))
			}
		}

		retRes40988 := (<-this.LoadMarkets())
		PanicOnError(retRes40988)
		var market interface{} = nil
		var request interface{} = map[string]interface{}{
			"states": states,
		}
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			AddElementToObject(request, "symbol", GetValue(market, "id"))
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "start-time", since) // a window of 48 hours within 180 days
			AddElementToObject(request, "end-time", this.Sum(since, Multiply(Multiply(Multiply(48, 60), 60), 1000)))
		}
		requestparamsVariable := this.HandleUntilOption("end-time", request, params)
		request = GetValue(requestparamsVariable, 0)
		params = GetValue(requestparamsVariable, 1)
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "size", limit)
		}
		var response interface{} = nil
		if IsTrue(IsEqual(method, "spot_private_get_v1_order_orders")) {

			response = (<-this.SpotPrivateGetV1OrderOrders(this.Extend(request, params)))
			PanicOnError(response)
		} else {

			response = (<-this.SpotPrivateGetV1OrderHistory(this.Extend(request, params)))
			PanicOnError(response)
		}
		//
		// spot_private_get_v1_order_orders GET /v1/order/orders
		//
		//     {
		//         "status": "ok",
		//         "data": [
		//             {
		//                 "id": 13997833014,
		//                 "symbol": "ethbtc",
		//                 "account-id": 3398321,
		//                 "client-order-id": "23456",
		//                 "amount": "0.045000000000000000",
		//                 "price": "0.034014000000000000",
		//                 "created-at": 1545836976871,
		//                 "type": "sell-limit",
		//                 "field-amount": "0.045000000000000000",
		//                 "field-cash-amount": "0.001530630000000000",
		//                 "field-fees": "0.000003061260000000",
		//                 "finished-at": 1545837948214,
		//                 "source": "spot-api",
		//                 "state": "filled",
		//                 "canceled-at": 0
		//             }
		//         ]
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseOrders(data, market, since, limit)
		return nil

	}()
	return ch
}
func (this *HtxCore) FetchSpotOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes416615 := (<-this.FetchSpotOrdersByStates("pre-submitted,submitted,partial-filled,filled,partial-canceled,canceled", symbol, since, limit, params))
		PanicOnError(retRes416615)
		ch <- retRes416615
		return nil

	}()
	return ch
}
func (this *HtxCore) FetchClosedSpotOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes417015 := (<-this.FetchSpotOrdersByStates("filled,partial-canceled,canceled", symbol, since, limit, params))
		PanicOnError(retRes417015)
		ch <- retRes417015
		return nil

	}()
	return ch
}
func (this *HtxCore) FetchContractOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchContractOrders() requires a symbol argument")))
		}

		retRes41778 := (<-this.LoadMarkets())
		PanicOnError(retRes41778)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"trade_type": 0,
			"status":     "0",
		}
		var response interface{} = nil
		var trigger interface{} = this.SafeBool2(params, "stop", "trigger")
		var stopLossTakeProfit interface{} = this.SafeValue(params, "stopLossTakeProfit")
		var trailing interface{} = this.SafeBool(params, "trailing", false)
		params = this.Omit(params, []interface{}{"stop", "stopLossTakeProfit", "trailing", "trigger"})
		if IsTrue(IsTrue(IsTrue(trigger) || IsTrue(stopLossTakeProfit)) || IsTrue(trailing)) {
			if IsTrue(!IsEqual(limit, nil)) {
				AddElementToObject(request, "page_size", limit)
			}
			AddElementToObject(request, "contract_code", GetValue(market, "id"))
			AddElementToObject(request, "create_date", 90)
		} else {
			if IsTrue(!IsEqual(since, nil)) {
				AddElementToObject(request, "start_time", since) // max 90 days back
			}
			AddElementToObject(request, "contract", GetValue(market, "id"))
			AddElementToObject(request, "type", 1) // 1:All Orders,2:Order in Finished Status
		}
		requestparamsVariable := this.HandleUntilOption("end_time", request, params)
		request = GetValue(requestparamsVariable, 0)
		params = GetValue(requestparamsVariable, 1)
		if IsTrue(GetValue(market, "linear")) {
			var marginMode interface{} = nil
			marginModeparamsVariable := this.HandleMarginModeAndParams("fetchContractOrders", params)
			marginMode = GetValue(marginModeparamsVariable, 0)
			params = GetValue(marginModeparamsVariable, 1)
			marginMode = Ternary(IsTrue((IsEqual(marginMode, nil))), "cross", marginMode)
			if IsTrue(IsEqual(marginMode, "isolated")) {
				if IsTrue(trigger) {

					response = (<-this.ContractPrivatePostLinearSwapApiV1SwapTriggerHisorders(this.Extend(request, params)))
					PanicOnError(response)
				} else if IsTrue(stopLossTakeProfit) {

					response = (<-this.ContractPrivatePostLinearSwapApiV1SwapTpslHisorders(this.Extend(request, params)))
					PanicOnError(response)
				} else if IsTrue(trailing) {

					response = (<-this.ContractPrivatePostLinearSwapApiV1SwapTrackHisorders(this.Extend(request, params)))
					PanicOnError(response)
				} else {

					response = (<-this.ContractPrivatePostLinearSwapApiV3SwapHisorders(this.Extend(request, params)))
					PanicOnError(response)
				}
			} else if IsTrue(IsEqual(marginMode, "cross")) {
				if IsTrue(trigger) {

					response = (<-this.ContractPrivatePostLinearSwapApiV1SwapCrossTriggerHisorders(this.Extend(request, params)))
					PanicOnError(response)
				} else if IsTrue(stopLossTakeProfit) {

					response = (<-this.ContractPrivatePostLinearSwapApiV1SwapCrossTpslHisorders(this.Extend(request, params)))
					PanicOnError(response)
				} else if IsTrue(trailing) {

					response = (<-this.ContractPrivatePostLinearSwapApiV1SwapCrossTrackHisorders(this.Extend(request, params)))
					PanicOnError(response)
				} else {

					response = (<-this.ContractPrivatePostLinearSwapApiV3SwapCrossHisorders(this.Extend(request, params)))
					PanicOnError(response)
				}
			}
		} else if IsTrue(GetValue(market, "inverse")) {
			if IsTrue(GetValue(market, "swap")) {
				if IsTrue(trigger) {

					response = (<-this.ContractPrivatePostSwapApiV1SwapTriggerHisorders(this.Extend(request, params)))
					PanicOnError(response)
				} else if IsTrue(stopLossTakeProfit) {

					response = (<-this.ContractPrivatePostSwapApiV1SwapTpslHisorders(this.Extend(request, params)))
					PanicOnError(response)
				} else if IsTrue(trailing) {

					response = (<-this.ContractPrivatePostSwapApiV1SwapTrackHisorders(this.Extend(request, params)))
					PanicOnError(response)
				} else {

					response = (<-this.ContractPrivatePostSwapApiV3SwapHisorders(this.Extend(request, params)))
					PanicOnError(response)
				}
			} else if IsTrue(GetValue(market, "future")) {
				AddElementToObject(request, "symbol", GetValue(market, "settleId"))
				if IsTrue(trigger) {

					response = (<-this.ContractPrivatePostApiV1ContractTriggerHisorders(this.Extend(request, params)))
					PanicOnError(response)
				} else if IsTrue(stopLossTakeProfit) {

					response = (<-this.ContractPrivatePostApiV1ContractTpslHisorders(this.Extend(request, params)))
					PanicOnError(response)
				} else if IsTrue(trailing) {

					response = (<-this.ContractPrivatePostApiV1ContractTrackHisorders(this.Extend(request, params)))
					PanicOnError(response)
				} else {

					response = (<-this.ContractPrivatePostApiV3ContractHisorders(this.Extend(request, params)))
					PanicOnError(response)
				}
			}
		}
		//
		// future and swap
		//
		//     {
		//         "code": 200,
		//         "msg": "ok",
		//         "data": [
		//             {
		//                 "direction": "buy",
		//                 "offset": "open",
		//                 "volume": 1.000000000000000000,
		//                 "price": 25000.000000000000000000,
		//                 "profit": 0E-18,
		//                 "pair": "BTC-USDT",
		//                 "query_id": 47403349100,
		//                 "order_id": 1103683465337593856,
		//                 "contract_code": "BTC-USDT-230505",
		//                 "symbol": "BTC",
		//                 "lever_rate": 5,
		//                 "create_date": 1683180243577,
		//                 "order_source": "web",
		//                 "canceled_source": "web",
		//                 "order_price_type": 1,
		//                 "order_type": 1,
		//                 "margin_frozen": 0E-18,
		//                 "trade_volume": 0E-18,
		//                 "trade_turnover": 0E-18,
		//                 "fee": 0E-18,
		//                 "trade_avg_price": 0,
		//                 "status": 7,
		//                 "order_id_str": "1103683465337593856",
		//                 "fee_asset": "USDT",
		//                 "fee_amount": 0,
		//                 "fee_quote_amount": 0,
		//                 "liquidation_type": "0",
		//                 "margin_asset": "USDT",
		//                 "margin_mode": "cross",
		//                 "margin_account": "USDT",
		//                 "update_time": 1683180352034,
		//                 "is_tpsl": 0,
		//                 "real_profit": 0,
		//                 "trade_partition": "USDT",
		//                 "reduce_only": 0,
		//                 "contract_type": "this_week",
		//                 "business_type": "futures"
		//             }
		//         ],
		//         "ts": 1683239909141
		//     }
		//
		// trigger
		//
		//     {
		//         "status": "ok",
		//         "data": {
		//             "orders": [
		//                 {
		//                     "contract_type": "swap",
		//                     "business_type": "swap",
		//                     "pair": "BTC-USDT",
		//                     "symbol": "BTC",
		//                     "contract_code": "BTC-USDT",
		//                     "trigger_type": "le",
		//                     "volume": 1.000000000000000000,
		//                     "order_type": 1,
		//                     "direction": "buy",
		//                     "offset": "open",
		//                     "lever_rate": 1,
		//                     "order_id": 1103670703588327424,
		//                     "order_id_str": "1103670703588327424",
		//                     "relation_order_id": "-1",
		//                     "order_price_type": "limit",
		//                     "status": 6,
		//                     "order_source": "web",
		//                     "trigger_price": 25000.000000000000000000,
		//                     "triggered_price": null,
		//                     "order_price": 24000.000000000000000000,
		//                     "created_at": 1683177200945,
		//                     "triggered_at": null,
		//                     "order_insert_at": 0,
		//                     "canceled_at": 1683179075234,
		//                     "fail_code": null,
		//                     "fail_reason": null,
		//                     "margin_mode": "cross",
		//                     "margin_account": "USDT",
		//                     "update_time": 1683179075958,
		//                     "trade_partition": "USDT",
		//                     "reduce_only": 0
		//                 },
		//             ],
		//             "total_page": 1,
		//             "current_page": 1,
		//             "total_size": 2
		//         },
		//         "ts": 1683239702792
		//     }
		//
		// stop-loss and take-profit
		//
		//     {
		//         "status": "ok",
		//         "data": {
		//             "orders": [
		//                 {
		//                     "contract_type": "swap",
		//                     "business_type": "swap",
		//                     "pair": "BTC-USDT",
		//                     "symbol": "BTC",
		//                     "contract_code": "BTC-USDT",
		//                     "margin_mode": "cross",
		//                     "margin_account": "USDT",
		//                     "volume": 1.000000000000000000,
		//                     "order_type": 1,
		//                     "tpsl_order_type": "sl",
		//                     "direction": "sell",
		//                     "order_id": 1103680386844839936,
		//                     "order_id_str": "1103680386844839936",
		//                     "order_source": "web",
		//                     "trigger_type": "le",
		//                     "trigger_price": 25000.000000000000000000,
		//                     "created_at": 1683179509613,
		//                     "order_price_type": "market",
		//                     "status": 11,
		//                     "source_order_id": null,
		//                     "relation_tpsl_order_id": "-1",
		//                     "canceled_at": 0,
		//                     "fail_code": null,
		//                     "fail_reason": null,
		//                     "triggered_price": null,
		//                     "relation_order_id": "-1",
		//                     "update_time": 1683179968231,
		//                     "order_price": 0E-18,
		//                     "trade_partition": "USDT"
		//                 },
		//             ],
		//             "total_page": 1,
		//             "current_page": 1,
		//             "total_size": 2
		//         },
		//         "ts": 1683229230233
		//     }
		//
		var orders interface{} = this.SafeValue(response, "data")
		if !IsTrue(IsArray(orders)) {
			orders = this.SafeValue(orders, "orders", []interface{}{})
		}

		ch <- this.ParseOrders(orders, market, since, limit)
		return nil

	}()
	return ch
}
func (this *HtxCore) FetchClosedContractOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		var request interface{} = map[string]interface{}{
			"status": "5,6,7",
		}

		retRes441115 := (<-this.FetchContractOrders(symbol, since, limit, this.Extend(request, params)))
		PanicOnError(retRes441115)
		ch <- retRes441115
		return nil

	}()
	return ch
}

/**
 * @method
 * @name htx#fetchOrders
 * @see https://huobiapi.github.io/docs/spot/v1/en/#search-past-orders
 * @see https://huobiapi.github.io/docs/spot/v1/en/#search-historical-orders-within-48-hours
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#isolated-get-history-orders-new
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#cross-get-history-orders-new
 * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#get-history-orders-new
 * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#query-history-orders-via-multiple-fields-new
 * @description fetches information on multiple orders made by the user
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {bool} [params.trigger] *contract only* if the orders are trigger trigger orders or not
 * @param {bool} [params.stopLossTakeProfit] *contract only* if the orders are stop-loss or take-profit orders
 * @param {int} [params.until] the latest time in ms to fetch entries for
 * @param {boolean} [params.trailing] *contract only* set to true if you want to fetch trailing stop orders
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *HtxCore) FetchOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes44358 := (<-this.LoadMarkets())
		PanicOnError(retRes44358)
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
		}
		var marketType interface{} = nil
		marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchOrders", market, params)
		marketType = GetValue(marketTypeparamsVariable, 0)
		params = GetValue(marketTypeparamsVariable, 1)
		var contract interface{} = IsTrue((IsEqual(marketType, "swap"))) || IsTrue((IsEqual(marketType, "future")))
		if IsTrue(IsTrue(contract) && IsTrue((IsEqual(symbol, nil)))) {
			panic(ArgumentsRequired(Add(Add(Add(this.Id, " fetchOrders() requires a symbol argument for "), marketType), " orders")))
		}
		if IsTrue(contract) {

			retRes444719 := (<-this.FetchContractOrders(symbol, since, limit, params))
			PanicOnError(retRes444719)
			ch <- retRes444719
			return nil
		} else {

			retRes444919 := (<-this.FetchSpotOrders(symbol, since, limit, params))
			PanicOnError(retRes444919)
			ch <- retRes444919
			return nil
		}

	}()
	return ch
}

/**
 * @method
 * @name htx#fetchClosedOrders
 * @see https://huobiapi.github.io/docs/spot/v1/en/#search-past-orders
 * @see https://huobiapi.github.io/docs/spot/v1/en/#search-historical-orders-within-48-hours
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#isolated-get-history-orders-new
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#cross-get-history-orders-new
 * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#get-history-orders-new
 * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#query-history-orders-via-multiple-fields-new
 * @description fetches information on multiple closed orders made by the user
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch entries for
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *HtxCore) FetchClosedOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes44728 := (<-this.LoadMarkets())
		PanicOnError(retRes44728)
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchClosedOrders", "paginate")
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {

			retRes447619 := (<-this.FetchPaginatedCallDynamic("fetchClosedOrders", symbol, since, limit, params, 100))
			PanicOnError(retRes447619)
			ch <- retRes447619
			return nil
		}
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
		}
		var marketType interface{} = nil
		marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchClosedOrders", market, params)
		marketType = GetValue(marketTypeparamsVariable, 0)
		params = GetValue(marketTypeparamsVariable, 1)
		if IsTrue(IsEqual(marketType, "spot")) {

			retRes448519 := (<-this.FetchClosedSpotOrders(symbol, since, limit, params))
			PanicOnError(retRes448519)
			ch <- retRes448519
			return nil
		} else {

			retRes448719 := (<-this.FetchClosedContractOrders(symbol, since, limit, params))
			PanicOnError(retRes448719)
			ch <- retRes448719
			return nil
		}

	}()
	return ch
}

/**
 * @method
 * @name htx#fetchOpenOrders
 * @see https://huobiapi.github.io/docs/spot/v1/en/#get-all-open-orders
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#isolated-current-unfilled-order-acquisition
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#cross-current-unfilled-order-acquisition
 * @description fetch all unfilled currently open orders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of open order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {bool} [params.trigger] *contract only* if the orders are trigger trigger orders or not
 * @param {bool} [params.stopLossTakeProfit] *contract only* if the orders are stop-loss or take-profit orders
 * @param {boolean} [params.trailing] *contract only* set to true if you want to fetch trailing stop orders
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *HtxCore) FetchOpenOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes45088 := (<-this.LoadMarkets())
		PanicOnError(retRes45088)
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
		}
		var request interface{} = map[string]interface{}{}
		var marketType interface{} = nil
		marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchOpenOrders", market, params)
		marketType = GetValue(marketTypeparamsVariable, 0)
		params = GetValue(marketTypeparamsVariable, 1)
		var subType interface{} = nil
		subTypeparamsVariable := this.HandleSubTypeAndParams("fetchOpenOrders", market, params, "linear")
		subType = GetValue(subTypeparamsVariable, 0)
		params = GetValue(subTypeparamsVariable, 1)
		var response interface{} = nil
		if IsTrue(IsEqual(marketType, "spot")) {
			if IsTrue(!IsEqual(symbol, nil)) {
				AddElementToObject(request, "symbol", GetValue(market, "id"))
			}
			// todo replace with fetchAccountIdByType
			var accountId interface{} = this.SafeString(params, "account-id")
			if IsTrue(IsEqual(accountId, nil)) {
				// pick the first account

				retRes452716 := (<-this.LoadAccounts())
				PanicOnError(retRes452716)
				for i := 0; IsLessThan(i, GetArrayLength(this.Accounts)); i++ {
					var account interface{} = GetValue(this.Accounts, i)
					if IsTrue(IsEqual(this.SafeString(account, "type"), "spot")) {
						accountId = this.SafeString(account, "id")
						if IsTrue(!IsEqual(accountId, nil)) {
							break
						}
					}
				}
			}
			AddElementToObject(request, "account-id", accountId)
			if IsTrue(!IsEqual(limit, nil)) {
				AddElementToObject(request, "size", limit)
			}
			params = this.Omit(params, "account-id")

			response = (<-this.SpotPrivateGetV1OrderOpenOrders(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			if IsTrue(!IsEqual(symbol, nil)) {
				// throw new ArgumentsRequired (this.id + ' fetchOpenOrders() requires a symbol argument');
				AddElementToObject(request, "contract_code", GetValue(market, "id"))
			}
			if IsTrue(!IsEqual(limit, nil)) {
				AddElementToObject(request, "page_size", limit)
			}
			var trigger interface{} = this.SafeBool2(params, "stop", "trigger")
			var stopLossTakeProfit interface{} = this.SafeValue(params, "stopLossTakeProfit")
			var trailing interface{} = this.SafeBool(params, "trailing", false)
			params = this.Omit(params, []interface{}{"stop", "stopLossTakeProfit", "trailing", "trigger"})
			if IsTrue(IsEqual(subType, "linear")) {
				var marginMode interface{} = nil
				marginModeparamsVariable := this.HandleMarginModeAndParams("fetchOpenOrders", params)
				marginMode = GetValue(marginModeparamsVariable, 0)
				params = GetValue(marginModeparamsVariable, 1)
				marginMode = Ternary(IsTrue((IsEqual(marginMode, nil))), "cross", marginMode)
				if IsTrue(IsEqual(marginMode, "isolated")) {
					if IsTrue(trigger) {

						response = (<-this.ContractPrivatePostLinearSwapApiV1SwapTriggerOpenorders(this.Extend(request, params)))
						PanicOnError(response)
					} else if IsTrue(stopLossTakeProfit) {

						response = (<-this.ContractPrivatePostLinearSwapApiV1SwapTpslOpenorders(this.Extend(request, params)))
						PanicOnError(response)
					} else if IsTrue(trailing) {

						response = (<-this.ContractPrivatePostLinearSwapApiV1SwapTrackOpenorders(this.Extend(request, params)))
						PanicOnError(response)
					} else {

						response = (<-this.ContractPrivatePostLinearSwapApiV1SwapOpenorders(this.Extend(request, params)))
						PanicOnError(response)
					}
				} else if IsTrue(IsEqual(marginMode, "cross")) {
					if IsTrue(trigger) {

						response = (<-this.ContractPrivatePostLinearSwapApiV1SwapCrossTriggerOpenorders(this.Extend(request, params)))
						PanicOnError(response)
					} else if IsTrue(stopLossTakeProfit) {

						response = (<-this.ContractPrivatePostLinearSwapApiV1SwapCrossTpslOpenorders(this.Extend(request, params)))
						PanicOnError(response)
					} else if IsTrue(trailing) {

						response = (<-this.ContractPrivatePostLinearSwapApiV1SwapCrossTrackOpenorders(this.Extend(request, params)))
						PanicOnError(response)
					} else {

						response = (<-this.ContractPrivatePostLinearSwapApiV1SwapCrossOpenorders(this.Extend(request, params)))
						PanicOnError(response)
					}
				}
			} else if IsTrue(IsEqual(subType, "inverse")) {
				if IsTrue(IsEqual(marketType, "swap")) {
					if IsTrue(trigger) {

						response = (<-this.ContractPrivatePostSwapApiV1SwapTriggerOpenorders(this.Extend(request, params)))
						PanicOnError(response)
					} else if IsTrue(stopLossTakeProfit) {

						response = (<-this.ContractPrivatePostSwapApiV1SwapTpslOpenorders(this.Extend(request, params)))
						PanicOnError(response)
					} else if IsTrue(trailing) {

						response = (<-this.ContractPrivatePostSwapApiV1SwapTrackOpenorders(this.Extend(request, params)))
						PanicOnError(response)
					} else {

						response = (<-this.ContractPrivatePostSwapApiV1SwapOpenorders(this.Extend(request, params)))
						PanicOnError(response)
					}
				} else if IsTrue(IsEqual(marketType, "future")) {
					AddElementToObject(request, "symbol", this.SafeString(market, "settleId", "usdt"))
					if IsTrue(trigger) {

						response = (<-this.ContractPrivatePostApiV1ContractTriggerOpenorders(this.Extend(request, params)))
						PanicOnError(response)
					} else if IsTrue(stopLossTakeProfit) {

						response = (<-this.ContractPrivatePostApiV1ContractTpslOpenorders(this.Extend(request, params)))
						PanicOnError(response)
					} else if IsTrue(trailing) {

						response = (<-this.ContractPrivatePostApiV1ContractTrackOpenorders(this.Extend(request, params)))
						PanicOnError(response)
					} else {

						response = (<-this.ContractPrivatePostApiV1ContractOpenorders(this.Extend(request, params)))
						PanicOnError(response)
					}
				}
			}
		}
		//
		// spot
		//
		//     {
		//         "status":"ok",
		//         "data":[
		//             {
		//                 "symbol":"ethusdt",
		//                 "source":"api",
		//                 "amount":"0.010000000000000000",
		//                 "account-id":1528640,
		//                 "created-at":1561597491963,
		//                 "price":"400.000000000000000000",
		//                 "filled-amount":"0.0",
		//                 "filled-cash-amount":"0.0",
		//                 "filled-fees":"0.0",
		//                 "id":38477101630,
		//                 "state":"submitted",
		//                 "type":"sell-limit"
		//             }
		//         ]
		//     }
		//
		// futures
		//
		//     {
		//         "status": "ok",
		//         "data": {
		//             "orders": [
		//                 {
		//                     "symbol": "ADA",
		//                     "contract_code": "ADA201225",
		//                     "contract_type": "quarter",
		//                     "volume": 1,
		//                     "price": 0.0925,
		//                     "order_price_type": "post_only",
		//                     "order_type": 1,
		//                     "direction": "buy",
		//                     "offset": "close",
		//                     "lever_rate": 20,
		//                     "order_id": 773131315209248768,
		//                     "client_order_id": null,
		//                     "created_at": 1604370469629,
		//                     "trade_volume": 0,
		//                     "trade_turnover": 0,
		//                     "fee": 0,
		//                     "trade_avg_price": null,
		//                     "margin_frozen": 0,
		//                     "profit": 0,
		//                     "status": 3,
		//                     "order_source": "web",
		//                     "order_id_str": "773131315209248768",
		//                     "fee_asset": "ADA",
		//                     "liquidation_type": null,
		//                     "canceled_at": null,
		//                     "is_tpsl": 0,
		//                     "update_time": 1606975980467,
		//                     "real_profit": 0
		//                 }
		//             ],
		//             "total_page": 1,
		//             "current_page": 1,
		//             "total_size": 1
		//         },
		//         "ts": 1604370488518
		//     }
		//
		// trigger
		//
		//     {
		//         "status": "ok",
		//         "data": {
		//             "orders": [
		//                 {
		//                     "contract_type": "swap",
		//                     "business_type": "swap",
		//                     "pair": "BTC-USDT",
		//                     "symbol": "BTC",
		//                     "contract_code": "BTC-USDT",
		//                     "trigger_type": "le",
		//                     "volume": 1.000000000000000000,
		//                     "order_type": 1,
		//                     "direction": "buy",
		//                     "offset": "open",
		//                     "lever_rate": 1,
		//                     "order_id": 1103670703588327424,
		//                     "order_id_str": "1103670703588327424",
		//                     "order_source": "web",
		//                     "trigger_price": 25000.000000000000000000,
		//                     "order_price": 24000.000000000000000000,
		//                     "created_at": 1683177200945,
		//                     "order_price_type": "limit",
		//                     "status": 2,
		//                     "margin_mode": "cross",
		//                     "margin_account": "USDT",
		//                     "trade_partition": "USDT",
		//                     "reduce_only": 0
		//                 }
		//             ],
		//             "total_page": 1,
		//             "current_page": 1,
		//             "total_size": 1
		//         },
		//         "ts": 1683177805320
		//     }
		//
		// stop-loss and take-profit
		//
		//     {
		//         "status": "ok",
		//         "data": {
		//             "orders": [
		//                 {
		//                     "contract_type": "swap",
		//                     "business_type": "swap",
		//                     "pair": "BTC-USDT",
		//                     "symbol": "BTC",
		//                     "contract_code": "BTC-USDT",
		//                     "margin_mode": "cross",
		//                     "margin_account": "USDT",
		//                     "volume": 1.000000000000000000,
		//                     "order_type": 1,
		//                     "direction": "sell",
		//                     "order_id": 1103680386844839936,
		//                     "order_id_str": "1103680386844839936",
		//                     "order_source": "web",
		//                     "trigger_type": "le",
		//                     "trigger_price": 25000.000000000000000000,
		//                     "order_price": 0E-18,
		//                     "created_at": 1683179509613,
		//                     "order_price_type": "market",
		//                     "status": 2,
		//                     "tpsl_order_type": "sl",
		//                     "source_order_id": null,
		//                     "relation_tpsl_order_id": "-1",
		//                     "trade_partition": "USDT"
		//                 }
		//             ],
		//             "total_page": 1,
		//             "current_page": 1,
		//             "total_size": 1
		//         },
		//         "ts": 1683179527011
		//     }
		//
		// trailing
		//
		//     {
		//         "status": "ok",
		//         "data": {
		//             "orders": [
		//                 {
		//                     "contract_type": "swap",
		//                     "business_type": "swap",
		//                     "pair": "BTC-USDT",
		//                     "symbol": "BTC",
		//                     "contract_code": "BTC-USDT",
		//                     "volume": 1.000000000000000000,
		//                     "order_type": 1,
		//                     "direction": "sell",
		//                     "offset": "close",
		//                     "lever_rate": 1,
		//                     "order_id": 1192021437253877761,
		//                     "order_id_str": "1192021437253877761",
		//                     "order_source": "api",
		//                     "created_at": 1704241657328,
		//                     "order_price_type": "formula_price",
		//                     "status": 2,
		//                     "callback_rate": 0.050000000000000000,
		//                     "active_price": 50000.000000000000000000,
		//                     "is_active": 0,
		//                     "margin_mode": "cross",
		//                     "margin_account": "USDT",
		//                     "trade_partition": "USDT",
		//                     "reduce_only": 1
		//                 },
		//             ],
		//             "total_page": 1,
		//             "current_page": 1,
		//             "total_size": 2
		//         },
		//         "ts": 1704242440106
		//     }
		//
		var orders interface{} = this.SafeValue(response, "data")
		if !IsTrue(IsArray(orders)) {
			orders = this.SafeValue(orders, "orders", []interface{}{})
		}

		ch <- this.ParseOrders(orders, market, since, limit)
		return nil

	}()
	return ch
}
func (this *HtxCore) ParseOrderStatus(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"partial-filled":   "open",
		"partial-canceled": "canceled",
		"filled":           "closed",
		"canceled":         "canceled",
		"submitted":        "open",
		"created":          "open",
		"1":                "open",
		"2":                "open",
		"3":                "open",
		"4":                "open",
		"5":                "canceled",
		"6":                "closed",
		"7":                "canceled",
		"11":               "canceling",
	}
	return this.SafeString(statuses, status, status)
}
func (this *HtxCore) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{} {
	//
	// spot
	//
	//     {
	//         "id":  13997833014,
	//         "symbol": "ethbtc",
	//         "account-id":  3398321,
	//         "amount": "0.045000000000000000",
	//         "price": "0.034014000000000000",
	//         "created-at":  1545836976871,
	//         "type": "sell-limit",
	//         "field-amount": "0.045000000000000000", // they have fixed it for filled-amount
	//         "field-cash-amount": "0.001530630000000000", // they have fixed it for filled-cash-amount
	//         "field-fees": "0.000003061260000000", // they have fixed it for filled-fees
	//         "finished-at":  1545837948214,
	//         "source": "spot-api",
	//         "state": "filled",
	//         "canceled-at":  0
	//     }
	//
	//     {
	//         "id":  20395337822,
	//         "symbol": "ethbtc",
	//         "account-id":  5685075,
	//         "amount": "0.001000000000000000",
	//         "price": "0.0",
	//         "created-at":  1545831584023,
	//         "type": "buy-market",
	//         "field-amount": "0.029100000000000000", // they have fixed it for filled-amount
	//         "field-cash-amount": "0.000999788700000000", // they have fixed it for filled-cash-amount
	//         "field-fees": "0.000058200000000000", // they have fixed it for filled-fees
	//         "finished-at":  1545831584181,
	//         "source": "spot-api",
	//         "state": "filled",
	//         "canceled-at":  0
	//     }
	//
	// linear swap cross margin createOrder
	//
	//     {
	//         "order_id":924660854912552960,
	//         "order_id_str":"924660854912552960"
	//     }
	//
	// contracts fetchOrder
	//
	//     {
	//         "business_type":"swap",
	//         "contract_type":"swap",
	//         "pair":"BTC-USDT",
	//         "symbol":"BTC",
	//         "contract_code":"BTC-USDT",
	//         "volume":1,
	//         "price":3000,
	//         "order_price_type":"limit",
	//         "order_type":1,
	//         "direction":"buy",
	//         "offset":"open",
	//         "lever_rate":1,
	//         "order_id":924912513206878210,
	//         "client_order_id":null,
	//         "created_at":1640557927189,
	//         "trade_volume":0,
	//         "trade_turnover":0,
	//         "fee":0,
	//         "trade_avg_price":null,
	//         "margin_frozen":3.000000000000000000,
	//         "profit":0,
	//         "status":3,
	//         "order_source":"api",
	//         "order_id_str":"924912513206878210",
	//         "fee_asset":"USDT",
	//         "liquidation_type":"0",
	//         "canceled_at":0,
	//         "margin_asset":"USDT",
	//         "margin_account":"USDT",
	//         "margin_mode":"cross",
	//         "is_tpsl":0,
	//         "real_profit":0
	//     }
	//
	// contracts fetchOrder detailed
	//
	//     {
	//         "symbol": "BTC",
	//         "contract_code": "BTC-USDT",
	//         "instrument_price": 0,
	//         "final_interest": 0,
	//         "adjust_value": 0,
	//         "lever_rate": 10,
	//         "direction": "sell",
	//         "offset": "open",
	//         "volume": 1.000000000000000000,
	//         "price": 13059.800000000000000000,
	//         "created_at": 1603703614712,
	//         "canceled_at": 0,
	//         "order_source": "api",
	//         "order_price_type": "opponent",
	//         "margin_frozen": 0,
	//         "profit": 0,
	//         "trades": [
	//             {
	//                 "trade_id": 131560927,
	//                 "trade_price": 13059.800000000000000000,
	//                 "trade_volume": 1.000000000000000000,
	//                 "trade_turnover": 13.059800000000000000,
	//                 "trade_fee": -0.005223920000000000,
	//                 "created_at": 1603703614715,
	//                 "role": "taker",
	//                 "fee_asset": "USDT",
	//                 "profit": 0,
	//                 "real_profit": 0,
	//                 "id": "131560927-770334322963152896-1"
	//             }
	//         ],
	//         "total_page": 1,
	//         "current_page": 1,
	//         "total_size": 1,
	//         "liquidation_type": "0",
	//         "fee_asset": "USDT",
	//         "fee": -0.005223920000000000,
	//         "order_id": 770334322963152896,
	//         "order_id_str": "770334322963152896",
	//         "client_order_id": 57012021045,
	//         "order_type": "1",
	//         "status": 6,
	//         "trade_avg_price": 13059.800000000000000000,
	//         "trade_turnover": 13.059800000000000000,
	//         "trade_volume": 1.000000000000000000,
	//         "margin_asset": "USDT",
	//         "margin_mode": "isolated",
	//         "margin_account": "BTC-USDT",
	//         "real_profit": 0,
	//         "is_tpsl": 0
	//     }
	//
	// future and swap: fetchOrders
	//
	//     {
	//         "order_id": 773131315209248768,
	//         "contract_code": "ADA201225",
	//         "symbol": "ADA",
	//         "lever_rate": 20,
	//         "direction": "buy",
	//         "offset": "close",
	//         "volume": 1,
	//         "price": 0.0925,
	//         "create_date": 1604370469629,
	//         "update_time": 1603704221118,
	//         "order_source": "web",
	//         "order_price_type": 6,
	//         "order_type": 1,
	//         "margin_frozen": 0,
	//         "profit": 0,
	//         "contract_type": "quarter",
	//         "trade_volume": 0,
	//         "trade_turnover": 0,
	//         "fee": 0,
	//         "trade_avg_price": 0,
	//         "status": 3,
	//         "order_id_str": "773131315209248768",
	//         "fee_asset": "ADA",
	//         "liquidation_type": "0",
	//         "is_tpsl": 0,
	//         "real_profit": 0
	//         "margin_asset": "USDT",
	//         "margin_mode": "cross",
	//         "margin_account": "USDT",
	//         "trade_partition": "USDT", // only in isolated & cross of linear
	//         "reduce_only": "1", // only in isolated & cross of linear
	//         "contract_type": "quarter", // only in cross-margin (inverse & linear)
	//         "pair": "BTC-USDT", // only in cross-margin (inverse & linear)
	//         "business_type": "futures" // only in cross-margin (inverse & linear)
	//     }
	//
	// trigger: fetchOpenOrders
	//
	//     {
	//         "contract_type": "swap",
	//         "business_type": "swap",
	//         "pair": "BTC-USDT",
	//         "symbol": "BTC",
	//         "contract_code": "BTC-USDT",
	//         "trigger_type": "le",
	//         "volume": 1.000000000000000000,
	//         "order_type": 1,
	//         "direction": "buy",
	//         "offset": "open",
	//         "lever_rate": 1,
	//         "order_id": 1103670703588327424,
	//         "order_id_str": "1103670703588327424",
	//         "order_source": "web",
	//         "trigger_price": 25000.000000000000000000,
	//         "order_price": 24000.000000000000000000,
	//         "created_at": 1683177200945,
	//         "order_price_type": "limit",
	//         "status": 2,
	//         "margin_mode": "cross",
	//         "margin_account": "USDT",
	//         "trade_partition": "USDT",
	//         "reduce_only": 0
	//     }
	//
	// stop-loss and take-profit: fetchOpenOrders
	//
	//     {
	//         "contract_type": "swap",
	//         "business_type": "swap",
	//         "pair": "BTC-USDT",
	//         "symbol": "BTC",
	//         "contract_code": "BTC-USDT",
	//         "margin_mode": "cross",
	//         "margin_account": "USDT",
	//         "volume": 1.000000000000000000,
	//         "order_type": 1,
	//         "direction": "sell",
	//         "order_id": 1103680386844839936,
	//         "order_id_str": "1103680386844839936",
	//         "order_source": "web",
	//         "trigger_type": "le",
	//         "trigger_price": 25000.000000000000000000,
	//         "order_price": 0E-18,
	//         "created_at": 1683179509613,
	//         "order_price_type": "market",
	//         "status": 2,
	//         "tpsl_order_type": "sl",
	//         "source_order_id": null,
	//         "relation_tpsl_order_id": "-1",
	//         "trade_partition": "USDT"
	//     }
	//
	// trailing: fetchOpenOrders
	//
	//     {
	//         "contract_type": "swap",
	//         "business_type": "swap",
	//         "pair": "BTC-USDT",
	//         "symbol": "BTC",
	//         "contract_code": "BTC-USDT",
	//         "volume": 1.000000000000000000,
	//         "order_type": 1,
	//         "direction": "sell",
	//         "offset": "close",
	//         "lever_rate": 1,
	//         "order_id": 1192021437253877761,
	//         "order_id_str": "1192021437253877761",
	//         "order_source": "api",
	//         "created_at": 1704241657328,
	//         "order_price_type": "formula_price",
	//         "status": 2,
	//         "callback_rate": 0.050000000000000000,
	//         "active_price": 50000.000000000000000000,
	//         "is_active": 0,
	//         "margin_mode": "cross",
	//         "margin_account": "USDT",
	//         "trade_partition": "USDT",
	//         "reduce_only": 1
	//     }
	//
	// trigger: fetchOrders
	//
	//     {
	//         "contract_type": "swap",
	//         "business_type": "swap",
	//         "pair": "BTC-USDT",
	//         "symbol": "BTC",
	//         "contract_code": "BTC-USDT",
	//         "trigger_type": "le",
	//         "volume": 1.000000000000000000,
	//         "order_type": 1,
	//         "direction": "buy",
	//         "offset": "open",
	//         "lever_rate": 1,
	//         "order_id": 1103670703588327424,
	//         "order_id_str": "1103670703588327424",
	//         "relation_order_id": "-1",
	//         "order_price_type": "limit",
	//         "status": 6,
	//         "order_source": "web",
	//         "trigger_price": 25000.000000000000000000,
	//         "triggered_price": null,
	//         "order_price": 24000.000000000000000000,
	//         "created_at": 1683177200945,
	//         "triggered_at": null,
	//         "order_insert_at": 0,
	//         "canceled_at": 1683179075234,
	//         "fail_code": null,
	//         "fail_reason": null,
	//         "margin_mode": "cross",
	//         "margin_account": "USDT",
	//         "update_time": 1683179075958,
	//         "trade_partition": "USDT",
	//         "reduce_only": 0
	//     }
	//
	// stop-loss and take-profit: fetchOrders
	//
	//     {
	//         "contract_type": "swap",
	//         "business_type": "swap",
	//         "pair": "BTC-USDT",
	//         "symbol": "BTC",
	//         "contract_code": "BTC-USDT",
	//         "margin_mode": "cross",
	//         "margin_account": "USDT",
	//         "volume": 1.000000000000000000,
	//         "order_type": 1,
	//         "tpsl_order_type": "sl",
	//         "direction": "sell",
	//         "order_id": 1103680386844839936,
	//         "order_id_str": "1103680386844839936",
	//         "order_source": "web",
	//         "trigger_type": "le",
	//         "trigger_price": 25000.000000000000000000,
	//         "created_at": 1683179509613,
	//         "order_price_type": "market",
	//         "status": 11,
	//         "source_order_id": null,
	//         "relation_tpsl_order_id": "-1",
	//         "canceled_at": 0,
	//         "fail_code": null,
	//         "fail_reason": null,
	//         "triggered_price": null,
	//         "relation_order_id": "-1",
	//         "update_time": 1683179968231,
	//         "order_price": 0E-18,
	//         "trade_partition": "USDT"
	//     }
	//
	// spot: createOrders
	//
	//     [
	//         {
	//             "order-id": 936847569789079,
	//             "client-order-id": "AA03022abc3a55e82c-0087-4fc2-beac-112fdebb1ee9"
	//         },
	//         {
	//             "client-order-id": "AA03022abcdb3baefb-3cfa-4891-8009-082b3d46ca82",
	//             "err-code": "account-frozen-balance-insufficient-error",
	//             "err-msg": "trade account balance is not enough, left: `89`"
	//         }
	//     ]
	//
	// swap and future: createOrders
	//
	//     [
	//         {
	//             "index": 2,
	//             "err_code": 1047,
	//             "err_msg": "Insufficient margin available."
	//         },
	//         {
	//             "order_id": 1172923090632953857,
	//             "index": 1,
	//             "order_id_str": "1172923090632953857"
	//         }
	//     ]
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var rejectedCreateOrders interface{} = this.SafeString2(order, "err_code", "err-code")
	var status interface{} = this.ParseOrderStatus(this.SafeString2(order, "state", "status"))
	if IsTrue(!IsEqual(rejectedCreateOrders, nil)) {
		status = "rejected"
	}
	var id interface{} = this.SafeStringN(order, []interface{}{"id", "order_id_str", "order-id"})
	var side interface{} = this.SafeString(order, "direction")
	var typeVar interface{} = this.SafeString(order, "order_price_type")
	if IsTrue(InOp(order, "type")) {
		var orderType interface{} = Split(GetValue(order, "type"), "-")
		side = GetValue(orderType, 0)
		typeVar = GetValue(orderType, 1)
	}
	var marketId interface{} = this.SafeString2(order, "contract_code", "symbol")
	market = this.SafeMarket(marketId, market)
	var timestamp interface{} = this.SafeIntegerN(order, []interface{}{"created_at", "created-at", "create_date"})
	var clientOrderId interface{} = this.SafeString2(order, "client_order_id", Add("client-or", "der-id")) // transpiler regex trick for php issue
	var cost interface{} = nil
	var amount interface{} = nil
	if IsTrue(IsTrue((!IsEqual(typeVar, nil))) && IsTrue((IsGreaterThanOrEqual(GetIndexOf(typeVar, "market"), 0)))) {
		cost = this.SafeString(order, "field-cash-amount")
	} else {
		amount = this.SafeString2(order, "volume", "amount")
		cost = this.SafeStringN(order, []interface{}{"filled-cash-amount", "field-cash-amount", "trade_turnover"}) // same typo here
	}
	var filled interface{} = this.SafeStringN(order, []interface{}{"filled-amount", "field-amount", "trade_volume"}) // typo in their API, filled amount
	var price interface{} = this.SafeString2(order, "price", "order_price")
	var feeCost interface{} = this.SafeString2(order, "filled-fees", "field-fees") // typo in their API, filled feeSide
	feeCost = this.SafeString(order, "fee", feeCost)
	var fee interface{} = nil
	if IsTrue(!IsEqual(feeCost, nil)) {
		var feeCurrency interface{} = nil
		var feeCurrencyId interface{} = this.SafeString(order, "fee_asset")
		if IsTrue(!IsEqual(feeCurrencyId, nil)) {
			feeCurrency = this.SafeCurrencyCode(feeCurrencyId)
		} else {
			feeCurrency = Ternary(IsTrue((IsEqual(side, "sell"))), GetValue(market, "quote"), GetValue(market, "base"))
		}
		fee = map[string]interface{}{
			"cost":     feeCost,
			"currency": feeCurrency,
		}
	}
	var average interface{} = this.SafeString(order, "trade_avg_price")
	var trades interface{} = this.SafeValue(order, "trades")
	var reduceOnlyInteger interface{} = this.SafeInteger(order, "reduce_only")
	var reduceOnly interface{} = nil
	if IsTrue(!IsEqual(reduceOnlyInteger, nil)) {
		reduceOnly = Ternary(IsTrue((IsEqual(reduceOnlyInteger, 0))), false, true)
	}
	return this.SafeOrder(map[string]interface{}{
		"info":               order,
		"id":                 id,
		"clientOrderId":      clientOrderId,
		"timestamp":          timestamp,
		"datetime":           this.Iso8601(timestamp),
		"lastTradeTimestamp": nil,
		"symbol":             GetValue(market, "symbol"),
		"type":               typeVar,
		"timeInForce":        nil,
		"postOnly":           nil,
		"side":               side,
		"price":              price,
		"triggerPrice":       this.SafeString2(order, "stop-price", "trigger_price"),
		"average":            average,
		"cost":               cost,
		"amount":             amount,
		"filled":             filled,
		"remaining":          nil,
		"status":             status,
		"reduceOnly":         reduceOnly,
		"fee":                fee,
		"trades":             trades,
	}, market)
}

/**
 * @method
 * @name htx#createMarketBuyOrderWithCost
 * @description create a market buy order by providing the symbol and cost
 * @see https://www.htx.com/en-us/opend/newApiPages/?id=7ec4ee16-7773-11ed-9966-0242ac110003
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {float} cost how much you want to trade in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *HtxCore) CreateMarketBuyOrderWithCost(symbol interface{}, cost interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes52658 := (<-this.LoadMarkets())
		PanicOnError(retRes52658)
		var market interface{} = this.Market(symbol)
		if !IsTrue(GetValue(market, "spot")) {
			panic(NotSupported(Add(this.Id, " createMarketBuyOrderWithCost() supports spot orders only")))
		}
		AddElementToObject(params, "createMarketBuyOrderRequiresPrice", false)

		retRes527115 := (<-this.CreateOrder(symbol, "market", "buy", cost, nil, params))
		PanicOnError(retRes527115)
		ch <- retRes527115
		return nil

	}()
	return ch
}

/**
 * @method
 * @name htx#createTrailingPercentOrder
 * @description create a trailing order by providing the symbol, type, side, amount, price and trailingPercent
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much you want to trade in units of the base currency, or number of contracts
 * @param {float} [price] the price for the order to be filled at, in units of the quote currency, ignored in market orders
 * @param {float} trailingPercent the percent to trail away from the current market price
 * @param {float} trailingTriggerPrice the price to activate a trailing order, default uses the price argument
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *HtxCore) CreateTrailingPercentOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		price := GetArg(optionalArgs, 0, nil)
		_ = price
		trailingPercent := GetArg(optionalArgs, 1, nil)
		_ = trailingPercent
		trailingTriggerPrice := GetArg(optionalArgs, 2, nil)
		_ = trailingTriggerPrice
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(trailingPercent, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " createTrailingPercentOrder() requires a trailingPercent argument")))
		}
		if IsTrue(IsEqual(trailingTriggerPrice, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " createTrailingPercentOrder() requires a trailingTriggerPrice argument")))
		}
		AddElementToObject(params, "trailingPercent", trailingPercent)
		AddElementToObject(params, "trailingTriggerPrice", trailingTriggerPrice)

		retRes529715 := (<-this.CreateOrder(symbol, typeVar, side, amount, price, params))
		PanicOnError(retRes529715)
		ch <- retRes529715
		return nil

	}()
	return ch
}

/**
 * @method
 * @ignore
 * @name htx#createSpotOrderRequest
 * @description helper function to build request
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much you want to trade in units of the base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.timeInForce] supports 'IOC' and 'FOK'
 * @param {float} [params.cost] the quote quantity that can be used as an alternative for the amount for market buy orders
 * @returns {object} request to be sent to the exchange
 */
func (this *HtxCore) CreateSpotOrderRequest(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		price := GetArg(optionalArgs, 0, nil)
		_ = price
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes53168 := (<-this.LoadMarkets())
		PanicOnError(retRes53168)

		retRes53178 := (<-this.LoadAccounts())
		PanicOnError(retRes53178)
		var market interface{} = this.Market(symbol)
		var marginMode interface{} = nil
		marginModeparamsVariable := this.HandleMarginModeAndParams("createOrder", params)
		marginMode = GetValue(marginModeparamsVariable, 0)
		params = GetValue(marginModeparamsVariable, 1)

		accountId := (<-this.FetchAccountIdByType(GetValue(market, "type"), marginMode, symbol))
		PanicOnError(accountId)
		var request interface{} = map[string]interface{}{
			"account-id": accountId,
			"symbol":     GetValue(market, "id"),
		}
		var orderType interface{} = Replace(typeVar, "buy-", "")
		orderType = Replace(orderType, "sell-", "")
		var options interface{} = this.SafeValue(this.Options, GetValue(market, "type"), map[string]interface{}{})
		var triggerPrice interface{} = this.SafeStringN(params, []interface{}{"triggerPrice", "stopPrice", "stop-price"})
		if IsTrue(IsEqual(triggerPrice, nil)) {
			var stopOrderTypes interface{} = this.SafeValue(options, "stopOrderTypes", map[string]interface{}{})
			if IsTrue(InOp(stopOrderTypes, orderType)) {
				panic(ArgumentsRequired(Add(this.Id, " createOrder() requires a triggerPrice for a trigger order")))
			}
		} else {
			var defaultOperator interface{} = Ternary(IsTrue((IsEqual(side, "sell"))), "lte", "gte")
			var stopOperator interface{} = this.SafeString(params, "operator", defaultOperator)
			AddElementToObject(request, "stop-price", this.PriceToPrecision(symbol, triggerPrice))
			AddElementToObject(request, "operator", stopOperator)
			if IsTrue(IsTrue((IsEqual(orderType, "limit"))) || IsTrue((IsEqual(orderType, "limit-fok")))) {
				orderType = Add("stop-", orderType)
			} else if IsTrue(IsTrue((!IsEqual(orderType, "stop-limit"))) && IsTrue((!IsEqual(orderType, "stop-limit-fok")))) {
				panic(NotSupported(Add(Add(Add(this.Id, " createOrder() does not support "), typeVar), " orders")))
			}
		}
		var postOnly interface{} = nil
		postOnlyparamsVariable := this.HandlePostOnly(IsEqual(orderType, "market"), IsEqual(orderType, "limit-maker"), params)
		postOnly = GetValue(postOnlyparamsVariable, 0)
		params = GetValue(postOnlyparamsVariable, 1)
		if IsTrue(postOnly) {
			orderType = "limit-maker"
		}
		var timeInForce interface{} = this.SafeString(params, "timeInForce", "GTC")
		if IsTrue(IsEqual(timeInForce, "FOK")) {
			orderType = Add(orderType, "-fok")
		} else if IsTrue(IsEqual(timeInForce, "IOC")) {
			orderType = "ioc"
		}
		AddElementToObject(request, "type", Add(Add(side, "-"), orderType))
		var clientOrderId interface{} = this.SafeString2(params, "clientOrderId", "client-order-id") // must be 64 chars max and unique within 24 hours
		if IsTrue(IsEqual(clientOrderId, nil)) {
			var broker interface{} = this.SafeValue(this.Options, "broker", map[string]interface{}{})
			var brokerId interface{} = this.SafeString(broker, "id")
			AddElementToObject(request, "client-order-id", Add(brokerId, this.Uuid()))
		} else {
			AddElementToObject(request, "client-order-id", clientOrderId)
		}
		if IsTrue(IsEqual(marginMode, "cross")) {
			AddElementToObject(request, "source", "super-margin-api")
		} else if IsTrue(IsEqual(marginMode, "isolated")) {
			AddElementToObject(request, "source", "margin-api")
		} else if IsTrue(IsEqual(marginMode, "c2c")) {
			AddElementToObject(request, "source", "c2c-margin-api")
		}
		if IsTrue(IsTrue((IsEqual(orderType, "market"))) && IsTrue((IsEqual(side, "buy")))) {
			var quoteAmount interface{} = nil
			var createMarketBuyOrderRequiresPrice interface{} = true
			createMarketBuyOrderRequiresPriceparamsVariable := this.HandleOptionAndParams(params, "createOrder", "createMarketBuyOrderRequiresPrice", true)
			createMarketBuyOrderRequiresPrice = GetValue(createMarketBuyOrderRequiresPriceparamsVariable, 0)
			params = GetValue(createMarketBuyOrderRequiresPriceparamsVariable, 1)
			var cost interface{} = this.SafeNumber(params, "cost")
			params = this.Omit(params, "cost")
			if IsTrue(!IsEqual(cost, nil)) {
				quoteAmount = this.AmountToPrecision(symbol, cost)
			} else if IsTrue(createMarketBuyOrderRequiresPrice) {
				if IsTrue(IsEqual(price, nil)) {
					panic(InvalidOrder(Add(this.Id, " createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend in the amount argument")))
				} else {
					// despite that cost = amount * price is in quote currency and should have quote precision
					// the exchange API requires the cost supplied in 'amount' to be of base precision
					// more about it here:
					// https://github.com/ccxt/ccxt/pull/4395
					// https://github.com/ccxt/ccxt/issues/7611
					// we use amountToPrecision here because the exchange requires cost in base precision
					var amountString interface{} = this.NumberToString(amount)
					var priceString interface{} = this.NumberToString(price)
					quoteAmount = this.AmountToPrecision(symbol, Precise.StringMul(amountString, priceString))
				}
			} else {
				quoteAmount = this.AmountToPrecision(symbol, amount)
			}
			AddElementToObject(request, "amount", quoteAmount)
		} else {
			AddElementToObject(request, "amount", this.AmountToPrecision(symbol, amount))
		}
		var limitOrderTypes interface{} = this.SafeValue(options, "limitOrderTypes", map[string]interface{}{})
		if IsTrue(InOp(limitOrderTypes, orderType)) {
			AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
		}
		params = this.Omit(params, []interface{}{"triggerPrice", "stopPrice", "stop-price", "clientOrderId", "client-order-id", "operator", "timeInForce"})

		ch <- this.Extend(request, params)
		return nil

	}()
	return ch
}
func (this *HtxCore) CreateContractOrderRequest(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{} {
	/**
	 * @method
	 * @ignore
	 * @name htx#createContractOrderRequest
	 * @description helper function to build request
	 * @param {string} symbol unified symbol of the market to create an order in
	 * @param {string} type 'market' or 'limit'
	 * @param {string} side 'buy' or 'sell'
	 * @param {float} amount how much you want to trade in units of the base currency
	 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
	 * @param {object} [params] extra parameters specific to the exchange API endpoint
	 * @param {string} [params.timeInForce] supports 'IOC' and 'FOK'
	 * @param {float} [params.trailingPercent] *contract only* the percent to trail away from the current market price
	 * @param {float} [params.trailingTriggerPrice] *contract only* the price to trigger a trailing order, default uses the price argument
	 * @returns {object} request to be sent to the exchange
	 */
	price := GetArg(optionalArgs, 0, nil)
	_ = price
	params := GetArg(optionalArgs, 1, map[string]interface{}{})
	_ = params
	var market interface{} = this.Market(symbol)
	var request interface{} = map[string]interface{}{
		"contract_code": GetValue(market, "id"),
		"volume":        this.AmountToPrecision(symbol, amount),
		"direction":     side,
	}
	var postOnly interface{} = nil
	postOnlyparamsVariable := this.HandlePostOnly(IsEqual(typeVar, "market"), IsEqual(typeVar, "post_only"), params)
	postOnly = GetValue(postOnlyparamsVariable, 0)
	params = GetValue(postOnlyparamsVariable, 1)
	if IsTrue(postOnly) {
		typeVar = "post_only"
	}
	var timeInForce interface{} = this.SafeString(params, "timeInForce", "GTC")
	if IsTrue(IsEqual(timeInForce, "FOK")) {
		typeVar = "fok"
	} else if IsTrue(IsEqual(timeInForce, "IOC")) {
		typeVar = "ioc"
	}
	var triggerPrice interface{} = this.SafeNumberN(params, []interface{}{"triggerPrice", "stopPrice", "trigger_price"})
	var stopLossTriggerPrice interface{} = this.SafeNumber2(params, "stopLossPrice", "sl_trigger_price")
	var takeProfitTriggerPrice interface{} = this.SafeNumber2(params, "takeProfitPrice", "tp_trigger_price")
	var trailingPercent interface{} = this.SafeString2(params, "trailingPercent", "callback_rate")
	var trailingTriggerPrice interface{} = this.SafeNumber(params, "trailingTriggerPrice", price)
	var isTrailingPercentOrder interface{} = !IsEqual(trailingPercent, nil)
	var isTrigger interface{} = !IsEqual(triggerPrice, nil)
	var isStopLossTriggerOrder interface{} = !IsEqual(stopLossTriggerPrice, nil)
	var isTakeProfitTriggerOrder interface{} = !IsEqual(takeProfitTriggerPrice, nil)
	if IsTrue(isTrigger) {
		var triggerType interface{} = this.SafeString2(params, "triggerType", "trigger_type", "le")
		AddElementToObject(request, "trigger_type", triggerType)
		AddElementToObject(request, "trigger_price", this.PriceToPrecision(symbol, triggerPrice))
		if IsTrue(!IsEqual(price, nil)) {
			AddElementToObject(request, "order_price", this.PriceToPrecision(symbol, price))
		}
	} else if IsTrue(IsTrue(isStopLossTriggerOrder) || IsTrue(isTakeProfitTriggerOrder)) {
		if IsTrue(isStopLossTriggerOrder) {
			AddElementToObject(request, "sl_order_price_type", typeVar)
			AddElementToObject(request, "sl_trigger_price", this.PriceToPrecision(symbol, stopLossTriggerPrice))
			if IsTrue(!IsEqual(price, nil)) {
				AddElementToObject(request, "sl_order_price", this.PriceToPrecision(symbol, price))
			}
		} else {
			AddElementToObject(request, "tp_order_price_type", typeVar)
			AddElementToObject(request, "tp_trigger_price", this.PriceToPrecision(symbol, takeProfitTriggerPrice))
			if IsTrue(!IsEqual(price, nil)) {
				AddElementToObject(request, "tp_order_price", this.PriceToPrecision(symbol, price))
			}
		}
	} else if IsTrue(isTrailingPercentOrder) {
		var trailingPercentString interface{} = Precise.StringDiv(trailingPercent, "100")
		AddElementToObject(request, "callback_rate", this.ParseToNumeric(trailingPercentString))
		AddElementToObject(request, "active_price", trailingTriggerPrice)
		AddElementToObject(request, "order_price_type", this.SafeString(params, "order_price_type", "formula_price"))
	} else {
		var clientOrderId interface{} = this.SafeInteger2(params, "client_order_id", "clientOrderId")
		if IsTrue(!IsEqual(clientOrderId, nil)) {
			AddElementToObject(request, "client_order_id", clientOrderId)
			params = this.Omit(params, []interface{}{"clientOrderId"})
		}
		if IsTrue(IsTrue(IsTrue(IsTrue(IsEqual(typeVar, "limit")) || IsTrue(IsEqual(typeVar, "ioc"))) || IsTrue(IsEqual(typeVar, "fok"))) || IsTrue(IsEqual(typeVar, "post_only"))) {
			if IsTrue(!IsEqual(price, nil)) {
				AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
			}
		}
	}
	var reduceOnly interface{} = this.SafeBool2(params, "reduceOnly", "reduce_only", false)
	if IsTrue(!IsTrue(isStopLossTriggerOrder) && !IsTrue(isTakeProfitTriggerOrder)) {
		if IsTrue(reduceOnly) {
			AddElementToObject(request, "reduce_only", 1)
		}
		AddElementToObject(request, "lever_rate", this.SafeIntegerN(params, []interface{}{"leverRate", "lever_rate", "leverage"}, 1))
		if !IsTrue(isTrailingPercentOrder) {
			AddElementToObject(request, "order_price_type", typeVar)
		}
	}
	var hedged interface{} = this.SafeBool(params, "hedged", false)
	if IsTrue(hedged) {
		if IsTrue(reduceOnly) {
			AddElementToObject(request, "offset", "close")
		} else {
			AddElementToObject(request, "offset", "open")
		}
	}
	var broker interface{} = this.SafeValue(this.Options, "broker", map[string]interface{}{})
	var brokerId interface{} = this.SafeString(broker, "id")
	AddElementToObject(request, "channel_code", brokerId)
	params = this.Omit(params, []interface{}{"reduceOnly", "triggerPrice", "stopPrice", "stopLossPrice", "takeProfitPrice", "triggerType", "leverRate", "timeInForce", "leverage", "trailingPercent", "trailingTriggerPrice", "hedged"})
	return this.Extend(request, params)
}

/**
 * @method
 * @name htx#createOrder
 * @description create a trade order
 * @see https://huobiapi.github.io/docs/spot/v1/en/#place-a-new-order                   // spot, margin
 * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#place-an-order        // coin-m swap
 * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#place-trigger-order   // coin-m swap trigger
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#cross-place-an-order           // usdt-m swap cross
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#cross-place-trigger-order      // usdt-m swap cross trigger
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#isolated-place-an-order        // usdt-m swap isolated
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#isolated-place-trigger-order   // usdt-m swap isolated trigger
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#isolated-set-a-take-profit-and-stop-loss-order-for-an-existing-position
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#cross-set-a-take-profit-and-stop-loss-order-for-an-existing-position
 * @see https://huobiapi.github.io/docs/dm/v1/en/#place-an-order                        // coin-m futures
 * @see https://huobiapi.github.io/docs/dm/v1/en/#place-trigger-order                   // coin-m futures contract trigger
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much you want to trade in units of the base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {float} [params.triggerPrice] the price a trigger order is triggered at
 * @param {string} [params.triggerType] *contract trigger orders only* ge: greater than or equal to, le: less than or equal to
 * @param {float} [params.stopLossPrice] *contract only* the price a stop-loss order is triggered at
 * @param {float} [params.takeProfitPrice] *contract only* the price a take-profit order is triggered at
 * @param {string} [params.operator] *spot and margin only* gte or lte, trigger price condition
 * @param {string} [params.offset] *contract only* 'both' (linear only), 'open', or 'close', required in hedge mode and for inverse markets
 * @param {bool} [params.postOnly] *contract only* true or false
 * @param {int} [params.leverRate] *contract only* required for all contract orders except tpsl, leverage greater than 20x requires prior approval of high-leverage agreement
 * @param {string} [params.timeInForce] supports 'IOC' and 'FOK'
 * @param {float} [params.cost] *spot market buy only* the quote quantity that can be used as an alternative for the amount
 * @param {float} [params.trailingPercent] *contract only* the percent to trail away from the current market price
 * @param {float} [params.trailingTriggerPrice] *contract only* the price to trigger a trailing order, default uses the price argument
 * @param {bool} [params.hedged] *contract only* true for hedged mode, false for one way mode, default is false
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *HtxCore) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		price := GetArg(optionalArgs, 0, nil)
		_ = price
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes55618 := (<-this.LoadMarkets())
		PanicOnError(retRes55618)
		var market interface{} = this.Market(symbol)
		var triggerPrice interface{} = this.SafeNumberN(params, []interface{}{"triggerPrice", "stopPrice", "trigger_price"})
		var stopLossTriggerPrice interface{} = this.SafeNumber2(params, "stopLossPrice", "sl_trigger_price")
		var takeProfitTriggerPrice interface{} = this.SafeNumber2(params, "takeProfitPrice", "tp_trigger_price")
		var trailingPercent interface{} = this.SafeNumber(params, "trailingPercent")
		var isTrailingPercentOrder interface{} = !IsEqual(trailingPercent, nil)
		var isTrigger interface{} = !IsEqual(triggerPrice, nil)
		var isStopLossTriggerOrder interface{} = !IsEqual(stopLossTriggerPrice, nil)
		var isTakeProfitTriggerOrder interface{} = !IsEqual(takeProfitTriggerPrice, nil)
		var response interface{} = nil
		if IsTrue(GetValue(market, "spot")) {
			if IsTrue(isTrailingPercentOrder) {
				panic(NotSupported(Add(this.Id, " createOrder() does not support trailing orders for spot markets")))
			}

			spotRequest := (<-this.CreateSpotOrderRequest(symbol, typeVar, side, amount, price, params))
			PanicOnError(spotRequest)

			response = (<-this.SpotPrivatePostV1OrderOrdersPlace(spotRequest))
			PanicOnError(response)
		} else {
			var contractRequest interface{} = this.CreateContractOrderRequest(symbol, typeVar, side, amount, price, params)
			if IsTrue(GetValue(market, "linear")) {
				var marginMode interface{} = nil
				marginModecontractRequestVariable := this.HandleMarginModeAndParams("createOrder", contractRequest)
				marginMode = GetValue(marginModecontractRequestVariable, 0)
				contractRequest = GetValue(marginModecontractRequestVariable, 1)
				marginMode = Ternary(IsTrue((IsEqual(marginMode, nil))), "cross", marginMode)
				if IsTrue(IsEqual(marginMode, "isolated")) {
					if IsTrue(isTrigger) {

						response = (<-this.ContractPrivatePostLinearSwapApiV1SwapTriggerOrder(contractRequest))
						PanicOnError(response)
					} else if IsTrue(IsTrue(isStopLossTriggerOrder) || IsTrue(isTakeProfitTriggerOrder)) {

						response = (<-this.ContractPrivatePostLinearSwapApiV1SwapTpslOrder(contractRequest))
						PanicOnError(response)
					} else if IsTrue(isTrailingPercentOrder) {

						response = (<-this.ContractPrivatePostLinearSwapApiV1SwapTrackOrder(contractRequest))
						PanicOnError(response)
					} else {

						response = (<-this.ContractPrivatePostLinearSwapApiV1SwapOrder(contractRequest))
						PanicOnError(response)
					}
				} else if IsTrue(IsEqual(marginMode, "cross")) {
					if IsTrue(isTrigger) {

						response = (<-this.ContractPrivatePostLinearSwapApiV1SwapCrossTriggerOrder(contractRequest))
						PanicOnError(response)
					} else if IsTrue(IsTrue(isStopLossTriggerOrder) || IsTrue(isTakeProfitTriggerOrder)) {

						response = (<-this.ContractPrivatePostLinearSwapApiV1SwapCrossTpslOrder(contractRequest))
						PanicOnError(response)
					} else if IsTrue(isTrailingPercentOrder) {

						response = (<-this.ContractPrivatePostLinearSwapApiV1SwapCrossTrackOrder(contractRequest))
						PanicOnError(response)
					} else {

						response = (<-this.ContractPrivatePostLinearSwapApiV1SwapCrossOrder(contractRequest))
						PanicOnError(response)
					}
				}
			} else if IsTrue(GetValue(market, "inverse")) {
				var offset interface{} = this.SafeString(params, "offset")
				if IsTrue(IsEqual(offset, nil)) {
					panic(ArgumentsRequired(Add(this.Id, " createOrder () requires an extra parameter params[\"offset\"] to be set to \"open\" or \"close\" when placing orders in inverse markets")))
				}
				if IsTrue(GetValue(market, "swap")) {
					if IsTrue(isTrigger) {

						response = (<-this.ContractPrivatePostSwapApiV1SwapTriggerOrder(contractRequest))
						PanicOnError(response)
					} else if IsTrue(IsTrue(isStopLossTriggerOrder) || IsTrue(isTakeProfitTriggerOrder)) {

						response = (<-this.ContractPrivatePostSwapApiV1SwapTpslOrder(contractRequest))
						PanicOnError(response)
					} else if IsTrue(isTrailingPercentOrder) {

						response = (<-this.ContractPrivatePostSwapApiV1SwapTrackOrder(contractRequest))
						PanicOnError(response)
					} else {

						response = (<-this.ContractPrivatePostSwapApiV1SwapOrder(contractRequest))
						PanicOnError(response)
					}
				} else if IsTrue(GetValue(market, "future")) {
					if IsTrue(isTrigger) {

						response = (<-this.ContractPrivatePostApiV1ContractTriggerOrder(contractRequest))
						PanicOnError(response)
					} else if IsTrue(IsTrue(isStopLossTriggerOrder) || IsTrue(isTakeProfitTriggerOrder)) {

						response = (<-this.ContractPrivatePostApiV1ContractTpslOrder(contractRequest))
						PanicOnError(response)
					} else if IsTrue(isTrailingPercentOrder) {

						response = (<-this.ContractPrivatePostApiV1ContractTrackOrder(contractRequest))
						PanicOnError(response)
					} else {

						response = (<-this.ContractPrivatePostApiV1ContractOrder(contractRequest))
						PanicOnError(response)
					}
				}
			}
		}
		//
		// spot
		//
		//     {"status":"ok","data":"438398393065481"}
		//
		// swap and future
		//
		//     {
		//         "status": "ok",
		//         "data": {
		//             "order_id": 924660854912552960,
		//             "order_id_str": "924660854912552960"
		//         },
		//         "ts": 1640497927185
		//     }
		//
		// stop-loss and take-profit
		//
		//     {
		//         "status": "ok",
		//         "data": {
		//             "tp_order": {
		//                 "order_id": 1101494204040163328,
		//                 "order_id_str": "1101494204040163328"
		//             },
		//             "sl_order": null
		//         },
		//         "ts": :1682658283024
		//     }
		//
		var data interface{} = nil
		var result interface{} = nil
		if IsTrue(GetValue(market, "spot")) {

			ch <- this.SafeOrder(map[string]interface{}{
				"info":               response,
				"id":                 this.SafeString(response, "data"),
				"timestamp":          nil,
				"datetime":           nil,
				"lastTradeTimestamp": nil,
				"status":             nil,
				"symbol":             nil,
				"type":               typeVar,
				"side":               side,
				"price":              price,
				"amount":             amount,
				"filled":             nil,
				"remaining":          nil,
				"cost":               nil,
				"trades":             nil,
				"fee":                nil,
				"clientOrderId":      nil,
				"average":            nil,
			}, market)
			return nil
		} else if IsTrue(isStopLossTriggerOrder) {
			data = this.SafeValue(response, "data", map[string]interface{}{})
			result = this.SafeValue(data, "sl_order", map[string]interface{}{})
		} else if IsTrue(isTakeProfitTriggerOrder) {
			data = this.SafeValue(response, "data", map[string]interface{}{})
			result = this.SafeValue(data, "tp_order", map[string]interface{}{})
		} else {
			result = this.SafeValue(response, "data", map[string]interface{}{})
		}

		ch <- this.ParseOrder(result, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name htx#createOrders
 * @description create a list of trade orders
 * @see https://huobiapi.github.io/docs/spot/v1/en/#place-a-batch-of-orders
 * @see https://huobiapi.github.io/docs/dm/v1/en/#place-a-batch-of-orders
 * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#place-a-batch-of-orders
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#isolated-place-a-batch-of-orders
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#cross-place-a-batch-of-orders
 * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *HtxCore) CreateOrders(orders interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes57128 := (<-this.LoadMarkets())
		PanicOnError(retRes57128)
		var ordersRequests interface{} = []interface{}{}
		var symbol interface{} = nil
		var market interface{} = nil
		var marginMode interface{} = nil
		for i := 0; IsLessThan(i, GetArrayLength(orders)); i++ {
			var rawOrder interface{} = GetValue(orders, i)
			var marketId interface{} = this.SafeString(rawOrder, "symbol")
			if IsTrue(IsEqual(symbol, nil)) {
				symbol = marketId
			} else {
				if IsTrue(!IsEqual(symbol, marketId)) {
					panic(BadRequest(Add(this.Id, " createOrders() requires all orders to have the same symbol")))
				}
			}
			var typeVar interface{} = this.SafeString(rawOrder, "type")
			var side interface{} = this.SafeString(rawOrder, "side")
			var amount interface{} = this.SafeValue(rawOrder, "amount")
			var price interface{} = this.SafeValue(rawOrder, "price")
			var orderParams interface{} = this.SafeValue(rawOrder, "params", map[string]interface{}{})
			var marginResult interface{} = this.HandleMarginModeAndParams("createOrders", orderParams)
			var currentMarginMode interface{} = GetValue(marginResult, 0)
			if IsTrue(!IsEqual(currentMarginMode, nil)) {
				if IsTrue(IsEqual(marginMode, nil)) {
					marginMode = currentMarginMode
				} else {
					if IsTrue(!IsEqual(marginMode, currentMarginMode)) {
						panic(BadRequest(Add(this.Id, " createOrders() requires all orders to have the same margin mode (isolated or cross)")))
					}
				}
			}
			market = this.Market(symbol)
			var orderRequest interface{} = nil
			if IsTrue(GetValue(market, "spot")) {

				orderRequest = (<-this.CreateSpotOrderRequest(marketId, typeVar, side, amount, price, orderParams))
				PanicOnError(orderRequest)
			} else {
				orderRequest = this.CreateContractOrderRequest(marketId, typeVar, side, amount, price, orderParams)
			}
			orderRequest = this.Omit(orderRequest, "marginMode")
			AppendToArray(&ordersRequests, orderRequest)
		}
		var request interface{} = map[string]interface{}{}
		var response interface{} = nil
		if IsTrue(GetValue(market, "spot")) {

			response = (<-this.PrivatePostOrderBatchOrders(ordersRequests))
			PanicOnError(response)
		} else {
			AddElementToObject(request, "orders_data", ordersRequests)
			if IsTrue(GetValue(market, "linear")) {
				marginMode = Ternary(IsTrue((IsEqual(marginMode, nil))), "cross", marginMode)
				if IsTrue(IsEqual(marginMode, "isolated")) {

					response = (<-this.ContractPrivatePostLinearSwapApiV1SwapBatchorder(request))
					PanicOnError(response)
				} else if IsTrue(IsEqual(marginMode, "cross")) {

					response = (<-this.ContractPrivatePostLinearSwapApiV1SwapCrossBatchorder(request))
					PanicOnError(response)
				}
			} else if IsTrue(GetValue(market, "inverse")) {
				if IsTrue(GetValue(market, "swap")) {

					response = (<-this.ContractPrivatePostSwapApiV1SwapBatchorder(request))
					PanicOnError(response)
				} else if IsTrue(GetValue(market, "future")) {

					response = (<-this.ContractPrivatePostApiV1ContractBatchorder(request))
					PanicOnError(response)
				}
			}
		}
		//
		// spot
		//
		//     {
		//         "status": "ok",
		//         "data": [
		//             {
		//                 "order-id": 936847569789079,
		//                 "client-order-id": "AA03022abc3a55e82c-0087-4fc2-beac-112fdebb1ee9"
		//             },
		//             {
		//                 "client-order-id": "AA03022abcdb3baefb-3cfa-4891-8009-082b3d46ca82",
		//                 "err-code": "account-frozen-balance-insufficient-error",
		//                 "err-msg": "trade account balance is not enough, left: `89`"
		//             }
		//         ]
		//     }
		//
		// swap and future
		//
		//     {
		//         "status": "ok",
		//         "data": {
		//             "errors": [
		//                 {
		//                     "index": 2,
		//                     "err_code": 1047,
		//                     "err_msg": "Insufficient margin available."
		//                 }
		//             ],
		//             "success": [
		//                 {
		//                     "order_id": 1172923090632953857,
		//                     "index": 1,
		//                     "order_id_str": "1172923090632953857"
		//                 }
		//             ]
		//         },
		//         "ts": 1699688256671
		//     }
		//
		var result interface{} = nil
		if IsTrue(GetValue(market, "spot")) {
			result = this.SafeValue(response, "data", []interface{}{})
		} else {
			var data interface{} = this.SafeValue(response, "data", map[string]interface{}{})
			var success interface{} = this.SafeValue(data, "success", []interface{}{})
			var errors interface{} = this.SafeValue(data, "errors", []interface{}{})
			result = this.ArrayConcat(success, errors)
		}

		ch <- this.ParseOrders(result, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name htx#cancelOrder
 * @description cancels an open order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] *contract only* if the order is a trigger trigger order or not
 * @param {boolean} [params.stopLossTakeProfit] *contract only* if the order is a stop-loss or take-profit order
 * @param {boolean} [params.trailing] *contract only* set to true if you want to cancel a trailing order
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *HtxCore) CancelOrder(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes58408 := (<-this.LoadMarkets())
		PanicOnError(retRes58408)
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
		}
		var marketType interface{} = nil
		marketTypeparamsVariable := this.HandleMarketTypeAndParams("cancelOrder", market, params)
		marketType = GetValue(marketTypeparamsVariable, 0)
		params = GetValue(marketTypeparamsVariable, 1)
		var request interface{} = map[string]interface{}{}
		var response interface{} = nil
		if IsTrue(IsEqual(marketType, "spot")) {
			var clientOrderId interface{} = this.SafeString2(params, "client-order-id", "clientOrderId")
			if IsTrue(IsEqual(clientOrderId, nil)) {
				AddElementToObject(request, "order-id", id)

				response = (<-this.SpotPrivatePostV1OrderOrdersOrderIdSubmitcancel(this.Extend(request, params)))
				PanicOnError(response)
			} else {
				AddElementToObject(request, "client-order-id", clientOrderId)
				params = this.Omit(params, []interface{}{"client-order-id", "clientOrderId"})

				response = (<-this.SpotPrivatePostV1OrderOrdersSubmitCancelClientOrder(this.Extend(request, params)))
				PanicOnError(response)
			}
		} else {
			if IsTrue(IsEqual(symbol, nil)) {
				panic(ArgumentsRequired(Add(this.Id, " cancelOrder() requires a symbol argument")))
			}
			var clientOrderId interface{} = this.SafeString2(params, "client_order_id", "clientOrderId")
			if IsTrue(IsEqual(clientOrderId, nil)) {
				AddElementToObject(request, "order_id", id)
			} else {
				AddElementToObject(request, "client_order_id", clientOrderId)
				params = this.Omit(params, []interface{}{"client_order_id", "clientOrderId"})
			}
			if IsTrue(GetValue(market, "future")) {
				AddElementToObject(request, "symbol", GetValue(market, "settleId"))
			} else {
				AddElementToObject(request, "contract_code", GetValue(market, "id"))
			}
			var trigger interface{} = this.SafeBool2(params, "stop", "trigger")
			var stopLossTakeProfit interface{} = this.SafeValue(params, "stopLossTakeProfit")
			var trailing interface{} = this.SafeBool(params, "trailing", false)
			params = this.Omit(params, []interface{}{"stop", "stopLossTakeProfit", "trailing", "trigger"})
			if IsTrue(GetValue(market, "linear")) {
				var marginMode interface{} = nil
				marginModeparamsVariable := this.HandleMarginModeAndParams("cancelOrder", params)
				marginMode = GetValue(marginModeparamsVariable, 0)
				params = GetValue(marginModeparamsVariable, 1)
				marginMode = Ternary(IsTrue((IsEqual(marginMode, nil))), "cross", marginMode)
				if IsTrue(IsEqual(marginMode, "isolated")) {
					if IsTrue(trigger) {

						response = (<-this.ContractPrivatePostLinearSwapApiV1SwapTriggerCancel(this.Extend(request, params)))
						PanicOnError(response)
					} else if IsTrue(stopLossTakeProfit) {

						response = (<-this.ContractPrivatePostLinearSwapApiV1SwapTpslCancel(this.Extend(request, params)))
						PanicOnError(response)
					} else if IsTrue(trailing) {

						response = (<-this.ContractPrivatePostLinearSwapApiV1SwapTrackCancel(this.Extend(request, params)))
						PanicOnError(response)
					} else {

						response = (<-this.ContractPrivatePostLinearSwapApiV1SwapCancel(this.Extend(request, params)))
						PanicOnError(response)
					}
				} else if IsTrue(IsEqual(marginMode, "cross")) {
					if IsTrue(trigger) {

						response = (<-this.ContractPrivatePostLinearSwapApiV1SwapCrossTriggerCancel(this.Extend(request, params)))
						PanicOnError(response)
					} else if IsTrue(stopLossTakeProfit) {

						response = (<-this.ContractPrivatePostLinearSwapApiV1SwapCrossTpslCancel(this.Extend(request, params)))
						PanicOnError(response)
					} else if IsTrue(trailing) {

						response = (<-this.ContractPrivatePostLinearSwapApiV1SwapCrossTrackCancel(this.Extend(request, params)))
						PanicOnError(response)
					} else {

						response = (<-this.ContractPrivatePostLinearSwapApiV1SwapCrossCancel(this.Extend(request, params)))
						PanicOnError(response)
					}
				}
			} else if IsTrue(GetValue(market, "inverse")) {
				if IsTrue(GetValue(market, "swap")) {
					if IsTrue(trigger) {

						response = (<-this.ContractPrivatePostSwapApiV1SwapTriggerCancel(this.Extend(request, params)))
						PanicOnError(response)
					} else if IsTrue(stopLossTakeProfit) {

						response = (<-this.ContractPrivatePostSwapApiV1SwapTpslCancel(this.Extend(request, params)))
						PanicOnError(response)
					} else if IsTrue(trailing) {

						response = (<-this.ContractPrivatePostSwapApiV1SwapTrackCancel(this.Extend(request, params)))
						PanicOnError(response)
					} else {

						response = (<-this.ContractPrivatePostSwapApiV1SwapCancel(this.Extend(request, params)))
						PanicOnError(response)
					}
				} else if IsTrue(GetValue(market, "future")) {
					if IsTrue(trigger) {

						response = (<-this.ContractPrivatePostApiV1ContractTriggerCancel(this.Extend(request, params)))
						PanicOnError(response)
					} else if IsTrue(stopLossTakeProfit) {

						response = (<-this.ContractPrivatePostApiV1ContractTpslCancel(this.Extend(request, params)))
						PanicOnError(response)
					} else if IsTrue(trailing) {

						response = (<-this.ContractPrivatePostApiV1ContractTrackCancel(this.Extend(request, params)))
						PanicOnError(response)
					} else {

						response = (<-this.ContractPrivatePostApiV1ContractCancel(this.Extend(request, params)))
						PanicOnError(response)
					}
				}
			} else {
				panic(NotSupported(Add(Add(Add(this.Id, " cancelOrder() does not support "), marketType), " markets")))
			}
		}

		//
		// spot
		//
		//     {
		//         "status": "ok",
		//         "data": "10138899000",
		//     }
		//
		// future and swap
		//
		//     {
		//         "status": "ok",
		//         "data": {
		//             "errors": [],
		//             "successes": "924660854912552960"
		//         },
		//         "ts": 1640504486089
		//     }
		//
		ch <- this.Extend(this.ParseOrder(response, market), map[string]interface{}{
			"id":     id,
			"status": "canceled",
		})
		return nil

	}()
	return ch
}

/**
 * @method
 * @name htx#cancelOrders
 * @description cancel multiple orders
 * @param {string[]} ids order ids
 * @param {string} symbol unified market symbol, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {bool} [params.trigger] *contract only* if the orders are trigger trigger orders or not
 * @param {bool} [params.stopLossTakeProfit] *contract only* if the orders are stop-loss or take-profit orders
 * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *HtxCore) CancelOrders(ids interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes59788 := (<-this.LoadMarkets())
		PanicOnError(retRes59788)
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
		}
		var marketType interface{} = nil
		marketTypeparamsVariable := this.HandleMarketTypeAndParams("cancelOrders", market, params)
		marketType = GetValue(marketTypeparamsVariable, 0)
		params = GetValue(marketTypeparamsVariable, 1)
		var request interface{} = map[string]interface{}{}
		var response interface{} = nil
		if IsTrue(IsEqual(marketType, "spot")) {
			var clientOrderIds interface{} = this.SafeValue2(params, "client-order-id", "clientOrderId")
			clientOrderIds = this.SafeValue2(params, "client-order-ids", "clientOrderIds", clientOrderIds)
			if IsTrue(IsEqual(clientOrderIds, nil)) {
				if IsTrue(IsString(clientOrderIds)) {
					AddElementToObject(request, "order-ids", []interface{}{ids})
				} else {
					AddElementToObject(request, "order-ids", ids)
				}
			} else {
				if IsTrue(IsString(clientOrderIds)) {
					AddElementToObject(request, "client-order-ids", []interface{}{clientOrderIds})
				} else {
					AddElementToObject(request, "client-order-ids", clientOrderIds)
				}
				params = this.Omit(params, []interface{}{"client-order-id", "client-order-ids", "clientOrderId", "clientOrderIds"})
			}

			response = (<-this.SpotPrivatePostV1OrderOrdersBatchcancel(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			if IsTrue(IsEqual(symbol, nil)) {
				panic(ArgumentsRequired(Add(this.Id, " cancelOrders() requires a symbol argument")))
			}
			var clientOrderIds interface{} = this.SafeString2(params, "client_order_id", "clientOrderId")
			clientOrderIds = this.SafeString2(params, "client_order_ids", "clientOrderIds", clientOrderIds)
			if IsTrue(IsEqual(clientOrderIds, nil)) {
				AddElementToObject(request, "order_id", Join(ids, ","))
			} else {
				AddElementToObject(request, "client_order_id", clientOrderIds)
				params = this.Omit(params, []interface{}{"client_order_id", "client_order_ids", "clientOrderId", "clientOrderIds"})
			}
			if IsTrue(GetValue(market, "future")) {
				AddElementToObject(request, "symbol", GetValue(market, "settleId"))
			} else {
				AddElementToObject(request, "contract_code", GetValue(market, "id"))
			}
			var trigger interface{} = this.SafeBool2(params, "stop", "trigger")
			var stopLossTakeProfit interface{} = this.SafeValue(params, "stopLossTakeProfit")
			params = this.Omit(params, []interface{}{"stop", "stopLossTakeProfit", "trigger"})
			if IsTrue(GetValue(market, "linear")) {
				var marginMode interface{} = nil
				marginModeparamsVariable := this.HandleMarginModeAndParams("cancelOrders", params)
				marginMode = GetValue(marginModeparamsVariable, 0)
				params = GetValue(marginModeparamsVariable, 1)
				marginMode = Ternary(IsTrue((IsEqual(marginMode, nil))), "cross", marginMode)
				if IsTrue(IsEqual(marginMode, "isolated")) {
					if IsTrue(trigger) {

						response = (<-this.ContractPrivatePostLinearSwapApiV1SwapTriggerCancel(this.Extend(request, params)))
						PanicOnError(response)
					} else if IsTrue(stopLossTakeProfit) {

						response = (<-this.ContractPrivatePostLinearSwapApiV1SwapTpslCancel(this.Extend(request, params)))
						PanicOnError(response)
					} else {

						response = (<-this.ContractPrivatePostLinearSwapApiV1SwapCancel(this.Extend(request, params)))
						PanicOnError(response)
					}
				} else if IsTrue(IsEqual(marginMode, "cross")) {
					if IsTrue(trigger) {

						response = (<-this.ContractPrivatePostLinearSwapApiV1SwapCrossTriggerCancel(this.Extend(request, params)))
						PanicOnError(response)
					} else if IsTrue(stopLossTakeProfit) {

						response = (<-this.ContractPrivatePostLinearSwapApiV1SwapCrossTpslCancel(this.Extend(request, params)))
						PanicOnError(response)
					} else {

						response = (<-this.ContractPrivatePostLinearSwapApiV1SwapCrossCancel(this.Extend(request, params)))
						PanicOnError(response)
					}
				}
			} else if IsTrue(GetValue(market, "inverse")) {
				if IsTrue(GetValue(market, "swap")) {
					if IsTrue(trigger) {

						response = (<-this.ContractPrivatePostSwapApiV1SwapTriggerCancel(this.Extend(request, params)))
						PanicOnError(response)
					} else if IsTrue(stopLossTakeProfit) {

						response = (<-this.ContractPrivatePostSwapApiV1SwapTpslCancel(this.Extend(request, params)))
						PanicOnError(response)
					} else {

						response = (<-this.ContractPrivatePostSwapApiV1SwapCancel(this.Extend(request, params)))
						PanicOnError(response)
					}
				} else if IsTrue(GetValue(market, "future")) {
					if IsTrue(trigger) {

						response = (<-this.ContractPrivatePostApiV1ContractTriggerCancel(this.Extend(request, params)))
						PanicOnError(response)
					} else if IsTrue(stopLossTakeProfit) {

						response = (<-this.ContractPrivatePostApiV1ContractTpslCancel(this.Extend(request, params)))
						PanicOnError(response)
					} else {

						response = (<-this.ContractPrivatePostApiV1ContractCancel(this.Extend(request, params)))
						PanicOnError(response)
					}
				}
			} else {
				panic(NotSupported(Add(Add(Add(this.Id, " cancelOrders() does not support "), marketType), " markets")))
			}
		}
		//
		// spot
		//
		//     {
		//         "status": "ok",
		//         "data": {
		//             "success": [
		//                 "5983466"
		//             ],
		//             "failed": [
		//                 {
		//                     "err-msg": "Incorrect order state",
		//                     "order-state": 7,
		//                     "order-id": "",
		//                     "err-code": "order-orderstate-error",
		//                     "client-order-id": "first"
		//                 },
		//                 {
		//                     "err-msg": "Incorrect order state",
		//                     "order-state": 7,
		//                     "order-id": "",
		//                     "err-code": "order-orderstate-error",
		//                     "client-order-id": "second"
		//                 },
		//                 {
		//                     "err-msg": "The record is not found.",
		//                     "order-id": "",
		//                     "err-code": "base-not-found",
		//                     "client-order-id": "third"
		//                 }
		//             ]
		//         }
		//     }
		//
		// future and swap
		//
		//     {
		//         "status": "ok",
		//         "data": {
		//             "errors": [
		//                 {
		//                     "order_id": "769206471845261312",
		//                     "err_code": 1061,
		//                     "err_msg": "This order doesnt exist."
		//                 }
		//             ],
		//             "successes": "773120304138219520"
		//         },
		//         "ts": 1604367997451
		//     }
		//
		var data interface{} = this.SafeDict(response, "data")

		ch <- this.ParseCancelOrders(data)
		return nil

	}()
	return ch
}
func (this *HtxCore) ParseCancelOrders(orders interface{}) interface{} {
	//
	//    {
	//        "success": [
	//            "5983466"
	//        ],
	//        "failed": [
	//            {
	//                "err-msg": "Incorrect order state",
	//                "order-state": 7,
	//                "order-id": "",
	//                "err-code": "order-orderstate-error",
	//                "client-order-id": "first"
	//            },
	//            ...
	//        ]
	//    }
	//
	//    {
	//        "errors": [
	//            {
	//                "order_id": "769206471845261312",
	//                "err_code": 1061,
	//                "err_msg": "This order doesnt exist."
	//            }
	//        ],
	//        "successes": "1258075374411399168,1258075393254871040"
	//    }
	//
	var successes interface{} = this.SafeString(orders, "successes")
	var success interface{} = nil
	if IsTrue(!IsEqual(successes, nil)) {
		success = Split(successes, ",")
	} else {
		success = this.SafeList(orders, "success", []interface{}{})
	}
	var failed interface{} = this.SafeList2(orders, "errors", "failed", []interface{}{})
	var result interface{} = []interface{}{}
	for i := 0; IsLessThan(i, GetArrayLength(success)); i++ {
		var order interface{} = GetValue(success, i)
		AppendToArray(&result, this.SafeOrder(map[string]interface{}{
			"info":   order,
			"id":     order,
			"status": "canceled",
		}))
	}
	for i := 0; IsLessThan(i, GetArrayLength(failed)); i++ {
		var order interface{} = GetValue(failed, i)
		AppendToArray(&result, this.SafeOrder(map[string]interface{}{
			"info":          order,
			"id":            this.SafeString2(order, "order-id", "order_id"),
			"status":        "failed",
			"clientOrderId": this.SafeString(order, "client-order-id"),
		}))
	}
	return result
}

/**
 * @method
 * @name htx#cancelAllOrders
 * @description cancel all open orders
 * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] *contract only* if the orders are trigger trigger orders or not
 * @param {boolean} [params.stopLossTakeProfit] *contract only* if the orders are stop-loss or take-profit orders
 * @param {boolean} [params.trailing] *contract only* set to true if you want to cancel all trailing orders
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *HtxCore) CancelAllOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes62028 := (<-this.LoadMarkets())
		PanicOnError(retRes62028)
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
		}
		var marketType interface{} = nil
		marketTypeparamsVariable := this.HandleMarketTypeAndParams("cancelAllOrders", market, params)
		marketType = GetValue(marketTypeparamsVariable, 0)
		params = GetValue(marketTypeparamsVariable, 1)
		var request interface{} = map[string]interface{}{}
		var response interface{} = nil
		if IsTrue(IsEqual(marketType, "spot")) {
			if IsTrue(!IsEqual(symbol, nil)) {
				AddElementToObject(request, "symbol", GetValue(market, "id"))
			}

			response = (<-this.SpotPrivatePostV1OrderOrdersBatchCancelOpenOrders(this.Extend(request, params)))
			PanicOnError(response)
			//
			//     {
			//         "code": 200,
			//         "data": {
			//             "success-count": 2,
			//             "failed-count": 0,
			//             "next-id": 5454600
			//         }
			//     }
			//
			var data interface{} = this.SafeDict(response, "data")

			ch <- []interface{}{this.SafeOrder(map[string]interface{}{
				"info": data,
			})}
			return nil
		} else {
			if IsTrue(IsEqual(symbol, nil)) {
				panic(ArgumentsRequired(Add(this.Id, " cancelAllOrders() requires a symbol argument")))
			}
			if IsTrue(GetValue(market, "future")) {
				AddElementToObject(request, "symbol", GetValue(market, "settleId"))
			}
			AddElementToObject(request, "contract_code", GetValue(market, "id"))
			var trigger interface{} = this.SafeBool2(params, "stop", "trigger")
			var stopLossTakeProfit interface{} = this.SafeValue(params, "stopLossTakeProfit")
			var trailing interface{} = this.SafeBool(params, "trailing", false)
			params = this.Omit(params, []interface{}{"stop", "stopLossTakeProfit", "trailing", "trigger"})
			if IsTrue(GetValue(market, "linear")) {
				var marginMode interface{} = nil
				marginModeparamsVariable := this.HandleMarginModeAndParams("cancelAllOrders", params)
				marginMode = GetValue(marginModeparamsVariable, 0)
				params = GetValue(marginModeparamsVariable, 1)
				marginMode = Ternary(IsTrue((IsEqual(marginMode, nil))), "cross", marginMode)
				if IsTrue(IsEqual(marginMode, "isolated")) {
					if IsTrue(trigger) {

						response = (<-this.ContractPrivatePostLinearSwapApiV1SwapTriggerCancelall(this.Extend(request, params)))
						PanicOnError(response)
					} else if IsTrue(stopLossTakeProfit) {

						response = (<-this.ContractPrivatePostLinearSwapApiV1SwapTpslCancelall(this.Extend(request, params)))
						PanicOnError(response)
					} else if IsTrue(trailing) {

						response = (<-this.ContractPrivatePostLinearSwapApiV1SwapTrackCancelall(this.Extend(request, params)))
						PanicOnError(response)
					} else {

						response = (<-this.ContractPrivatePostLinearSwapApiV1SwapCancelall(this.Extend(request, params)))
						PanicOnError(response)
					}
				} else if IsTrue(IsEqual(marginMode, "cross")) {
					if IsTrue(trigger) {

						response = (<-this.ContractPrivatePostLinearSwapApiV1SwapCrossTriggerCancelall(this.Extend(request, params)))
						PanicOnError(response)
					} else if IsTrue(stopLossTakeProfit) {

						response = (<-this.ContractPrivatePostLinearSwapApiV1SwapCrossTpslCancelall(this.Extend(request, params)))
						PanicOnError(response)
					} else if IsTrue(trailing) {

						response = (<-this.ContractPrivatePostLinearSwapApiV1SwapCrossTrackCancelall(this.Extend(request, params)))
						PanicOnError(response)
					} else {

						response = (<-this.ContractPrivatePostLinearSwapApiV1SwapCrossCancelall(this.Extend(request, params)))
						PanicOnError(response)
					}
				}
			} else if IsTrue(GetValue(market, "inverse")) {
				if IsTrue(GetValue(market, "swap")) {
					if IsTrue(trigger) {

						response = (<-this.ContractPrivatePostSwapApiV1SwapTriggerCancelall(this.Extend(request, params)))
						PanicOnError(response)
					} else if IsTrue(stopLossTakeProfit) {

						response = (<-this.ContractPrivatePostSwapApiV1SwapTpslCancelall(this.Extend(request, params)))
						PanicOnError(response)
					} else if IsTrue(trailing) {

						response = (<-this.ContractPrivatePostSwapApiV1SwapTrackCancelall(this.Extend(request, params)))
						PanicOnError(response)
					} else {

						response = (<-this.ContractPrivatePostSwapApiV1SwapCancelall(this.Extend(request, params)))
						PanicOnError(response)
					}
				} else if IsTrue(GetValue(market, "future")) {
					if IsTrue(trigger) {

						response = (<-this.ContractPrivatePostApiV1ContractTriggerCancelall(this.Extend(request, params)))
						PanicOnError(response)
					} else if IsTrue(stopLossTakeProfit) {

						response = (<-this.ContractPrivatePostApiV1ContractTpslCancelall(this.Extend(request, params)))
						PanicOnError(response)
					} else if IsTrue(trailing) {

						response = (<-this.ContractPrivatePostApiV1ContractTrackCancelall(this.Extend(request, params)))
						PanicOnError(response)
					} else {

						response = (<-this.ContractPrivatePostApiV1ContractCancelall(this.Extend(request, params)))
						PanicOnError(response)
					}
				}
			} else {
				panic(NotSupported(Add(Add(Add(this.Id, " cancelAllOrders() does not support "), marketType), " markets")))
			}
			//
			//     {
			//         "status": "ok",
			//         "data": {
			//             "errors": [],
			//             "successes": "1104754904426696704"
			//         },
			//         "ts": "1683435723755"
			//     }
			//
			var data interface{} = this.SafeDict(response, "data")

			ch <- this.ParseCancelOrders(data)
			return nil
		}

	}()
	return ch
}

/**
 * @method
 * @name htx#cancelAllOrdersAfter
 * @description dead man's switch, cancel all orders after the given timeout
 * @see https://huobiapi.github.io/docs/spot/v1/en/#dead-man-s-switch
 * @param {number} timeout time in milliseconds, 0 represents cancel the timer
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} the api result
 */
func (this *HtxCore) CancelAllOrdersAfter(timeout interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes63328 := (<-this.LoadMarkets())
		PanicOnError(retRes63328)
		var request interface{} = map[string]interface{}{
			"timeout": Ternary(IsTrue((IsGreaterThan(timeout, 0))), this.ParseToInt(Divide(timeout, 1000)), 0),
		}

		response := (<-this.V2PrivatePostAlgoOrdersCancelAllAfter(this.Extend(request, params)))
		PanicOnError(response)

		//
		//     {
		//         "code": 200,
		//         "message": "success",
		//         "data": {
		//             "currentTime": 1630491627230,
		//             "triggerTime": 1630491637230
		//         }
		//     }
		//
		ch <- response
		return nil

	}()
	return ch
}
func (this *HtxCore) ParseDepositAddress(depositAddress interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "currency": "usdt",
	//         "address": "0xf7292eb9ba7bc50358e27f0e025a4d225a64127b",
	//         "addressTag": "",
	//         "chain": "usdterc20", // trc20usdt, hrc20usdt, usdt, algousdt
	//     }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var address interface{} = this.SafeString(depositAddress, "address")
	var tag interface{} = this.SafeString(depositAddress, "addressTag")
	var currencyId interface{} = this.SafeString(depositAddress, "currency")
	currency = this.SafeCurrency(currencyId, currency)
	var code interface{} = this.SafeCurrencyCode(currencyId, currency)
	var note interface{} = this.SafeString(depositAddress, "note")
	var networkId interface{} = this.SafeString(depositAddress, "chain")
	this.CheckAddress(address)
	return map[string]interface{}{
		"currency": code,
		"address":  address,
		"tag":      tag,
		"network":  this.NetworkIdToCode(networkId),
		"note":     note,
		"info":     depositAddress,
	}
}

/**
 * @method
 * @see https://www.htx.com/en-us/opend/newApiPages/?id=7ec50029-7773-11ed-9966-0242ac110003
 * @name htx#fetchDepositAddressesByNetwork
 * @description fetch a dictionary of addresses for a currency, indexed by network
 * @param {string} code unified currency code of the currency for the deposit address
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [address structures]{@link https://docs.ccxt.com/?id=address-structure} indexed by the network
 */
func (this *HtxCore) FetchDepositAddressesByNetwork(code interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes63878 := (<-this.LoadMarkets())
		PanicOnError(retRes63878)
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"currency": GetValue(currency, "id"),
		}

		response := (<-this.SpotPrivateGetV2AccountDepositAddress(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": 200,
		//         "data": [
		//             {
		//                 "currency": "eth",
		//                 "address": "0xf7292eb9ba7bc50358e27f0e025a4d225a64127b",
		//                 "addressTag": "",
		//                 "chain": "eth"
		//             }
		//         ]
		//     }
		//
		var data interface{} = this.SafeValue(response, "data", []interface{}{})
		var parsed interface{} = this.ParseDepositAddresses(data, []interface{}{GetValue(currency, "code")}, false)

		ch <- this.IndexBy(parsed, "network")
		return nil

	}()
	return ch
}

/**
 * @method
 * @name htx#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account
 * @see https://www.htx.com/en-us/opend/newApiPages/?id=7ec50029-7773-11ed-9966-0242ac110003
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/?id=address-structure}
 */
func (this *HtxCore) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes64218 := (<-this.LoadMarkets())
		PanicOnError(retRes64218)
		var currency interface{} = this.Currency(code)
		networkCodeparamsOmitedVariable := this.HandleNetworkCodeAndParams(params)
		networkCode := GetValue(networkCodeparamsOmitedVariable, 0)
		paramsOmited := GetValue(networkCodeparamsOmitedVariable, 1)

		indexedAddresses := (<-this.FetchDepositAddressesByNetwork(code, paramsOmited))
		PanicOnError(indexedAddresses)
		var selectedNetworkCode interface{} = this.SelectNetworkCodeFromUnifiedNetworks(GetValue(currency, "code"), networkCode, indexedAddresses)

		ch <- GetValue(indexedAddresses, selectedNetworkCode)
		return nil

	}()
	return ch
}
func (this *HtxCore) FetchWithdrawAddresses(code interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		note := GetArg(optionalArgs, 0, nil)
		_ = note
		networkCode := GetArg(optionalArgs, 1, nil)
		_ = networkCode
		params := GetArg(optionalArgs, 2, map[string]interface{}{})
		_ = params

		retRes64308 := (<-this.LoadMarkets())
		PanicOnError(retRes64308)
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"currency": GetValue(currency, "id"),
		}

		response := (<-this.SpotPrivateGetV2AccountWithdrawAddress(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": 200,
		//         "data": [
		//             {
		//                 "currency": "eth",
		//                 "chain": "eth"
		//                 "note": "Binance - TRC20",
		//                 "addressTag": "",
		//                 "address": "0xf7292eb9ba7bc50358e27f0e025a4d225a64127b",
		//             }
		//         ]
		//     }
		//
		var data interface{} = this.SafeValue(response, "data", []interface{}{})
		var allAddresses interface{} = this.ParseDepositAddresses(data, []interface{}{GetValue(currency, "code")}, false) // cjg: to do remove this weird object or array ambiguity
		var addresses interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(allAddresses)); i++ {
			var address interface{} = GetValue(allAddresses, i)
			var noteMatch interface{} = IsTrue((IsEqual(note, nil))) || IsTrue((IsEqual(GetValue(address, "note"), note)))
			var networkMatch interface{} = IsTrue((IsEqual(networkCode, nil))) || IsTrue((IsEqual(GetValue(address, "network"), networkCode)))
			if IsTrue(IsTrue(noteMatch) && IsTrue(networkMatch)) {
				AppendToArray(&addresses, address)
			}
		}

		ch <- addresses
		return nil

	}()
	return ch
}

/**
 * @method
 * @name htx#fetchDeposits
 * @see https://www.htx.com/en-us/opend/newApiPages/?id=7ec4f050-7773-11ed-9966-0242ac110003
 * @description fetch all deposits made to an account
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/?id=transaction-structure}
 */
func (this *HtxCore) FetchDeposits(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		if IsTrue(IsTrue(IsEqual(limit, nil)) || IsTrue(IsGreaterThan(limit, 100))) {
			limit = 100
		}

		retRes64798 := (<-this.LoadMarkets())
		PanicOnError(retRes64798)
		var currency interface{} = nil
		if IsTrue(!IsEqual(code, nil)) {
			currency = this.Currency(code)
		}
		var request interface{} = map[string]interface{}{
			"type":   "deposit",
			"direct": "next",
			"from":   0,
		}
		if IsTrue(!IsEqual(currency, nil)) {
			AddElementToObject(request, "currency", GetValue(currency, "id"))
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "size", limit) // max 100
		}

		response := (<-this.SpotPrivateGetV1QueryDepositWithdraw(this.Extend(request, params)))
		PanicOnError(response)

		//
		//    {
		//         "status": "ok",
		//         "data": [
		//             {
		//                 "id": "75115912",
		//                 "type": "deposit",
		//                 "sub-type": "NORMAL",
		//                 "request-id": "trc20usdt-a2e229a44ef2a948c874366230bb56aa73631cc0a03d177bd8b4c9d38262d7ff-200",
		//                 "currency": "usdt",
		//                 "chain": "trc20usdt",
		//                 "tx-hash": "a2e229a44ef2a948c874366230bb56aa73631cc0a03d177bd8b4c9d38262d7ff",
		//                 "amount": "12.000000000000000000",
		//                 "from-addr-tag": "",
		//                 "address-id": "0",
		//                 "address": "TRFTd1FxepQE6CnpwzUEMEbFaLm5bJK67s",
		//                 "address-tag": "",
		//                 "fee": "0",
		//                 "state": "safe",
		//                 "wallet-confirm": "2",
		//                 "created-at": "1621843808662",
		//                 "updated-at": "1621843857137"
		//             },
		//         ]
		//     }
		//
		ch <- this.ParseTransactions(GetValue(response, "data"), currency, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name htx#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @see https://huobiapi.github.io/docs/spot/v1/en/#search-for-existed-withdraws-and-deposits
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawals structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/?id=transaction-structure}
 */
func (this *HtxCore) FetchWithdrawals(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		if IsTrue(IsTrue(IsEqual(limit, nil)) || IsTrue(IsGreaterThan(limit, 100))) {
			limit = 100
		}

		retRes65408 := (<-this.LoadMarkets())
		PanicOnError(retRes65408)
		var currency interface{} = nil
		if IsTrue(!IsEqual(code, nil)) {
			currency = this.Currency(code)
		}
		var request interface{} = map[string]interface{}{
			"type":   "withdraw",
			"direct": "next",
			"from":   0,
		}
		if IsTrue(!IsEqual(currency, nil)) {
			AddElementToObject(request, "currency", GetValue(currency, "id"))
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "size", limit) // max 100
		}

		response := (<-this.SpotPrivateGetV1QueryDepositWithdraw(this.Extend(request, params)))
		PanicOnError(response)

		//
		//    {
		//         "status": "ok",
		//         "data": [
		//             {
		//                 "id": "61335312",
		//                 "type": "withdraw",
		//                 "sub-type": "NORMAL",
		//                 "currency": "usdt",
		//                 "chain": "trc20usdt",
		//                 "tx-hash": "30a3111f2fead74fae45c6218ca3150fc33cab2aa59cfe41526b96aae79ce4ec",
		//                 "amount": "12.000000000000000000",
		//                 "from-addr-tag": "",
		//                 "address-id": "27321591",
		//                 "address": "TRf5JacJQRsF4Nm2zu11W6maDGeiEWQu9e",
		//                 "address-tag": "",
		//                 "fee": "1.000000000000000000",
		//                 "state": "confirmed",
		//                 "created-at": "1621852316553",
		//                 "updated-at": "1621852467041"
		//             },
		//         ]
		//     }
		//
		ch <- this.ParseTransactions(GetValue(response, "data"), currency, since, limit)
		return nil

	}()
	return ch
}
func (this *HtxCore) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{} {
	//
	// fetchDeposits
	//
	//     {
	//         "id": "75115912",
	//         "type": "deposit",
	//         "sub-type": "NORMAL",
	//         "request-id": "trc20usdt-a2e229a44ef2a948c874366230bb56aa73631cc0a03d177bd8b4c9d38262d7ff-200",
	//         "currency": "usdt",
	//         "chain": "trc20usdt",
	//         "tx-hash": "a2e229a44ef2a948c874366230bb56aa73631cc0a03d177bd8b4c9d38262d7ff",
	//         "amount": "2849.000000000000000000",
	//         "from-addr-tag": "",
	//         "address-id": "0",
	//         "address": "TRFTd1FxepQE6CnpwzUEMEbFaLm5bJK67s",
	//         "address-tag": "",
	//         "fee": "0",
	//         "state": "safe",
	//         "wallet-confirm": "2",
	//         "created-at": "1621843808662",
	//         "updated-at": "1621843857137"
	//     },
	//
	// fetchWithdrawals
	//
	//     {
	//         "id": "61335312",
	//         "type": "withdraw",
	//         "sub-type": "NORMAL",
	//         "currency": "usdt",
	//         "chain": "trc20usdt",
	//         "tx-hash": "30a3111f2fead74fae45c6218ca3150fc33cab2aa59cfe41526b96aae79ce4ec",
	//         "amount": "12.000000000000000000",
	//         "from-addr-tag": "",
	//         "address-id": "27321591",
	//         "address": "TRf5JacJQRsF4Nm2zu11W6maDGeiEWQu9e",
	//         "address-tag": "",
	//         "fee": "1.000000000000000000",
	//         "state": "confirmed",
	//         "created-at": "1621852316553",
	//         "updated-at": "1621852467041"
	//     }
	//
	// withdraw
	//
	//     {
	//         "status": "ok",
	//         "data": "99562054"
	//     }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var timestamp interface{} = this.SafeInteger(transaction, "created-at")
	var code interface{} = this.SafeCurrencyCode(this.SafeString(transaction, "currency"))
	var typeVar interface{} = this.SafeString(transaction, "type")
	if IsTrue(IsEqual(typeVar, "withdraw")) {
		typeVar = "withdrawal"
	}
	var feeCost interface{} = this.SafeString(transaction, "fee")
	if IsTrue(!IsEqual(feeCost, nil)) {
		feeCost = Precise.StringAbs(feeCost)
	}
	var networkId interface{} = this.SafeString(transaction, "chain")
	var txHash interface{} = this.SafeString(transaction, "tx-hash")
	if IsTrue(IsTrue(IsEqual(networkId, "ETH")) && IsTrue(IsLessThan(GetIndexOf(txHash, "0x"), 0))) {
		txHash = Add("0x", txHash)
	}
	var subType interface{} = this.SafeString(transaction, "sub-type")
	var internal interface{} = IsEqual(subType, "FAST")
	return map[string]interface{}{
		"info":        transaction,
		"id":          this.SafeString2(transaction, "id", "data"),
		"txid":        txHash,
		"timestamp":   timestamp,
		"datetime":    this.Iso8601(timestamp),
		"network":     this.NetworkIdToCode(networkId),
		"address":     this.SafeString(transaction, "address"),
		"addressTo":   nil,
		"addressFrom": nil,
		"tag":         this.SafeString(transaction, "address-tag"),
		"tagTo":       nil,
		"tagFrom":     nil,
		"type":        typeVar,
		"amount":      this.SafeNumber(transaction, "amount"),
		"currency":    code,
		"status":      this.ParseTransactionStatus(this.SafeString(transaction, "state")),
		"updated":     this.SafeInteger(transaction, "updated-at"),
		"comment":     nil,
		"internal":    internal,
		"fee": map[string]interface{}{
			"currency": code,
			"cost":     this.ParseNumber(feeCost),
			"rate":     nil,
		},
	}
}
func (this *HtxCore) ParseTransactionStatus(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"unknown":         "failed",
		"confirming":      "pending",
		"confirmed":       "ok",
		"safe":            "ok",
		"orphan":          "failed",
		"submitted":       "pending",
		"canceled":        "canceled",
		"reexamine":       "pending",
		"reject":          "failed",
		"pass":            "pending",
		"wallet-reject":   "failed",
		"confirm-error":   "failed",
		"repealed":        "failed",
		"wallet-transfer": "pending",
		"pre-transfer":    "pending",
		"verifying":       "pending",
	}
	return this.SafeString(statuses, status, status)
}

/**
 * @method
 * @name htx#withdraw
 * @see https://www.htx.com/en-us/opend/newApiPages/?id=7ec4cc41-7773-11ed-9966-0242ac110003
 * @description make a withdrawal
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/?id=transaction-structure}
 */
func (this *HtxCore) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		tag := GetArg(optionalArgs, 0, nil)
		_ = tag
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params)
		tag = GetValue(tagparamsVariable, 0)
		params = GetValue(tagparamsVariable, 1)

		retRes67198 := (<-this.LoadMarkets())
		PanicOnError(retRes67198)
		this.CheckAddress(address)
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"address":  address,
			"currency": ToLower(GetValue(currency, "id")),
		}
		if IsTrue(!IsEqual(tag, nil)) {
			AddElementToObject(request, "addr-tag", tag) // only for XRP?
		}
		var networkCode interface{} = nil
		networkCodeparamsVariable := this.HandleNetworkCodeAndParams(params)
		networkCode = GetValue(networkCodeparamsVariable, 0)
		params = GetValue(networkCodeparamsVariable, 1)
		if IsTrue(!IsEqual(networkCode, nil)) {
			AddElementToObject(request, "chain", this.NetworkCodeToId(networkCode, code))
		}
		amount = ParseFloat(this.CurrencyToPrecision(code, amount, networkCode))
		var withdrawOptions interface{} = this.SafeValue(this.Options, "withdraw", map[string]interface{}{})
		if IsTrue(this.SafeBool(withdrawOptions, "includeFee", false)) {
			var fee interface{} = this.SafeNumber(params, "fee")
			if IsTrue(IsEqual(fee, nil)) {

				currencies := (<-this.FetchCurrencies())
				PanicOnError(currencies)
				this.Currencies = this.MapToSafeMap(this.DeepExtend(this.Currencies, currencies))
				var targetNetwork interface{} = this.SafeValue(GetValue(currency, "networks"), networkCode, map[string]interface{}{})
				fee = this.SafeNumber(targetNetwork, "fee")
				if IsTrue(IsEqual(fee, nil)) {
					panic(ArgumentsRequired(Add(this.Id, " withdraw() function can not find withdraw fee for chosen network. You need to re-load markets with \"exchange.loadMarkets(true)\", or provide the \"fee\" parameter")))
				}
			}
			// fee needs to be deducted from whole amount
			var feeString interface{} = this.CurrencyToPrecision(code, fee, networkCode)
			params = this.Omit(params, "fee")
			var amountString interface{} = this.NumberToString(amount)
			var amountSubtractedString interface{} = Precise.StringSub(amountString, feeString)
			var amountSubtracted interface{} = ParseFloat(amountSubtractedString)
			AddElementToObject(request, "fee", ParseFloat(feeString))
			amount = ParseFloat(this.CurrencyToPrecision(code, amountSubtracted, networkCode))
		}
		AddElementToObject(request, "amount", amount)

		response := (<-this.SpotPrivatePostV1DwWithdrawApiCreate(this.Extend(request, params)))
		PanicOnError(response)

		//
		//     {
		//         "status": "ok",
		//         "data": "99562054"
		//     }
		//
		ch <- this.ParseTransaction(response, currency)
		return nil

	}()
	return ch
}
func (this *HtxCore) ParseTransfer(transfer interface{}, optionalArgs ...interface{}) interface{} {
	//
	// transfer
	//
	//     {
	//         "data": 12345,
	//         "status": "ok"
	//     }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var id interface{} = this.SafeString(transfer, "data")
	var code interface{} = this.SafeCurrencyCode(nil, currency)
	return map[string]interface{}{
		"info":        transfer,
		"id":          id,
		"timestamp":   nil,
		"datetime":    nil,
		"currency":    code,
		"amount":      nil,
		"fromAccount": nil,
		"toAccount":   nil,
		"status":      nil,
	}
}

/**
 * @method
 * @name htx#transfer
 * @description transfer currency internally between wallets on the same account
 * @see https://huobiapi.github.io/docs/dm/v1/en/#transfer-margin-between-spot-account-and-future-account
 * @see https://huobiapi.github.io/docs/spot/v1/en/#transfer-fund-between-spot-account-and-future-contract-account
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#general-transfer-margin-between-spot-account-and-usdt-margined-contracts-account
 * @see https://huobiapi.github.io/docs/spot/v1/en/#transfer-asset-from-spot-trading-account-to-cross-margin-account-cross
 * @see https://huobiapi.github.io/docs/spot/v1/en/#transfer-asset-from-spot-trading-account-to-isolated-margin-account-isolated
 * @see https://huobiapi.github.io/docs/spot/v1/en/#transfer-asset-from-cross-margin-account-to-spot-trading-account-cross
 * @see https://huobiapi.github.io/docs/spot/v1/en/#transfer-asset-from-isolated-margin-account-to-spot-trading-account-isolated
 * @param {string} code unified currency code
 * @param {float} amount amount to transfer
 * @param {string} fromAccount account to transfer from 'spot', 'future', 'swap'
 * @param {string} toAccount account to transfer to 'spot', 'future', 'swap'
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.symbol] used for isolated margin transfer
 * @param {string} [params.subType] 'linear' or 'inverse', only used when transfering to/from swap accounts
 * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/?id=transfer-structure}
 */
func (this *HtxCore) Transfer(code interface{}, amount interface{}, fromAccount interface{}, toAccount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes68128 := (<-this.LoadMarkets())
		PanicOnError(retRes68128)
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"currency": GetValue(currency, "id"),
			"amount":   ParseFloat(this.CurrencyToPrecision(code, amount)),
		}
		var subType interface{} = nil
		subTypeparamsVariable := this.HandleSubTypeAndParams("transfer", nil, params)
		subType = GetValue(subTypeparamsVariable, 0)
		params = GetValue(subTypeparamsVariable, 1)
		var fromAccountId interface{} = this.ConvertTypeToAccount(fromAccount)
		var toAccountId interface{} = this.ConvertTypeToAccount(toAccount)
		var toCross interface{} = IsEqual(toAccountId, "cross")
		var fromCross interface{} = IsEqual(fromAccountId, "cross")
		var toIsolated interface{} = this.InArray(toAccountId, this.Ids)
		var fromIsolated interface{} = this.InArray(fromAccountId, this.Ids)
		var fromSpot interface{} = IsEqual(fromAccountId, "pro")
		var toSpot interface{} = IsEqual(toAccountId, "pro")
		if IsTrue(IsTrue(fromSpot) && IsTrue(toSpot)) {
			panic(BadRequest(Add(Add(Add(Add(this.Id, " transfer () cannot make a transfer between "), fromAccount), " and "), toAccount)))
		}
		var fromOrToFuturesAccount interface{} = IsTrue((IsEqual(fromAccountId, "futures"))) || IsTrue((IsEqual(toAccountId, "futures")))
		var response interface{} = nil
		if IsTrue(fromOrToFuturesAccount) {
			var typeVar interface{} = Add(Add(fromAccountId, "-to-"), toAccountId)
			typeVar = this.SafeString(params, "type", typeVar)
			AddElementToObject(request, "type", typeVar)

			response = (<-this.SpotPrivatePostV1FuturesTransfer(this.Extend(request, params)))
			PanicOnError(response)
		} else if IsTrue(IsTrue(fromSpot) && IsTrue(toCross)) {

			response = (<-this.PrivatePostCrossMarginTransferIn(this.Extend(request, params)))
			PanicOnError(response)
		} else if IsTrue(IsTrue(fromCross) && IsTrue(toSpot)) {

			response = (<-this.PrivatePostCrossMarginTransferOut(this.Extend(request, params)))
			PanicOnError(response)
		} else if IsTrue(IsTrue(fromSpot) && IsTrue(toIsolated)) {
			AddElementToObject(request, "symbol", toAccountId)

			response = (<-this.PrivatePostDwTransferInMargin(this.Extend(request, params)))
			PanicOnError(response)
		} else if IsTrue(IsTrue(fromIsolated) && IsTrue(toSpot)) {
			AddElementToObject(request, "symbol", fromAccountId)

			response = (<-this.PrivatePostDwTransferOutMargin(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			if IsTrue(IsEqual(subType, "linear")) {
				if IsTrue(IsTrue((IsEqual(fromAccountId, "swap"))) || IsTrue((IsEqual(fromAccount, "linear-swap")))) {
					fromAccountId = "linear-swap"
				} else {
					toAccountId = "linear-swap"
				}
				// check if cross-margin or isolated
				var symbol interface{} = this.SafeString(params, "symbol")
				params = this.Omit(params, "symbol")
				if IsTrue(!IsEqual(symbol, nil)) {
					symbol = this.MarketId(symbol)
					AddElementToObject(request, "margin-account", symbol)
				} else {
					AddElementToObject(request, "margin-account", "USDT") // cross-margin
				}
			}
			AddElementToObject(request, "from", Ternary(IsTrue(fromSpot), "spot", fromAccountId))
			AddElementToObject(request, "to", Ternary(IsTrue(toSpot), "spot", toAccountId))

			response = (<-this.V2PrivatePostAccountTransfer(this.Extend(request, params)))
			PanicOnError(response)
		}

		//
		//    {
		//        "code": "200",
		//        "data": "660150061",
		//        "message": "Succeed",
		//        "success": true,
		//        "print-log": true
		//    }
		//
		ch <- this.ParseTransfer(response, currency)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name htx#fetchIsolatedBorrowRates
 * @description fetch the borrow interest rates of all currencies
 * @see https://huobiapi.github.io/docs/spot/v1/en/#get-loan-interest-rate-and-quota-isolated
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [isolated borrow rate structures]{@link https://docs.ccxt.com/?id=isolated-borrow-rate-structure}
 */
func (this *HtxCore) FetchIsolatedBorrowRates(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes68908 := (<-this.LoadMarkets())
		PanicOnError(retRes68908)

		response := (<-this.SpotPrivateGetV1MarginLoanInfo(params))
		PanicOnError(response)
		//
		// {
		//     "status": "ok",
		//     "data": [
		//         {
		//             "symbol": "1inchusdt",
		//             "currencies": [
		//                 {
		//                     "currency": "1inch",
		//                     "interest-rate": "0.00098",
		//                     "min-loan-amt": "90.000000000000000000",
		//                     "max-loan-amt": "1000.000000000000000000",
		//                     "loanable-amt": "0.0",
		//                     "actual-rate": "0.00098"
		//                 },
		//                 {
		//                     "currency": "usdt",
		//                     "interest-rate": "0.00098",
		//                     "min-loan-amt": "100.000000000000000000",
		//                     "max-loan-amt": "1000.000000000000000000",
		//                     "loanable-amt": "0.0",
		//                     "actual-rate": "0.00098"
		//                 }
		//             ]
		//         },
		//         ...
		//     ]
		// }
		//
		var data interface{} = this.SafeValue(response, "data", []interface{}{})

		ch <- this.ParseIsolatedBorrowRates(data)
		return nil

	}()
	return ch
}
func (this *HtxCore) ParseIsolatedBorrowRate(info interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "symbol": "1inchusdt",
	//         "currencies": [
	//             {
	//                 "currency": "1inch",
	//                 "interest-rate": "0.00098",
	//                 "min-loan-amt": "90.000000000000000000",
	//                 "max-loan-amt": "1000.000000000000000000",
	//                 "loanable-amt": "0.0",
	//                 "actual-rate": "0.00098"
	//             },
	//             {
	//                 "currency": "usdt",
	//                 "interest-rate": "0.00098",
	//                 "min-loan-amt": "100.000000000000000000",
	//                 "max-loan-amt": "1000.000000000000000000",
	//                 "loanable-amt": "0.0",
	//                 "actual-rate": "0.00098"
	//             }
	//         ]
	//     },
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(info, "symbol")
	var symbol interface{} = this.SafeSymbol(marketId, market)
	var currencies interface{} = this.SafeValue(info, "currencies", []interface{}{})
	var baseData interface{} = this.SafeValue(currencies, 0)
	var quoteData interface{} = this.SafeValue(currencies, 1)
	var baseId interface{} = this.SafeString(baseData, "currency")
	var quoteId interface{} = this.SafeString(quoteData, "currency")
	return map[string]interface{}{
		"symbol":    symbol,
		"base":      this.SafeCurrencyCode(baseId),
		"baseRate":  this.SafeNumber(baseData, "actual-rate"),
		"quote":     this.SafeCurrencyCode(quoteId),
		"quoteRate": this.SafeNumber(quoteData, "actual-rate"),
		"period":    86400000,
		"timestamp": nil,
		"datetime":  nil,
		"info":      info,
	}
}

/**
 * @method
 * @name htx#fetchFundingRateHistory
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#general-query-historical-funding-rate
 * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#query-historical-funding-rate
 * @description fetches historical funding rate prices
 * @param {string} symbol unified symbol of the market to fetch the funding rate history for
 * @param {int} [since] not used by huobi, but filtered internally by ccxt
 * @param {int} [limit] not used by huobi, but filtered internally by ccxt
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/?id=funding-rate-history-structure}
 */
func (this *HtxCore) FetchFundingRateHistory(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchFundingRateHistory() requires a symbol argument")))
		}
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchFundingRateHistory", "paginate")
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {

			retRes698919 := (<-this.FetchPaginatedCallCursor("fetchFundingRateHistory", symbol, since, limit, params, "current_page", "page_index", 1, 50))
			PanicOnError(retRes698919)
			ch <- retRes698919
			return nil
		}

		retRes69918 := (<-this.LoadMarkets())
		PanicOnError(retRes69918)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"contract_code": GetValue(market, "id"),
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "page_size", limit)
		} else {
			AddElementToObject(request, "page_size", 50) // max
		}
		var response interface{} = nil
		if IsTrue(GetValue(market, "inverse")) {

			response = (<-this.ContractPublicGetSwapApiV1SwapHistoricalFundingRate(this.Extend(request, params)))
			PanicOnError(response)
		} else if IsTrue(GetValue(market, "linear")) {

			response = (<-this.ContractPublicGetLinearSwapApiV1SwapHistoricalFundingRate(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			panic(NotSupported(Add(this.Id, " fetchFundingRateHistory() supports inverse and linear swaps only")))
		}
		//
		// {
		//     "status": "ok",
		//     "data": {
		//         "total_page": 62,
		//         "current_page": 1,
		//         "total_size": 1237,
		//         "data": [
		//             {
		//                 "avg_premium_index": "-0.000208064395065541",
		//                 "funding_rate": "0.000100000000000000",
		//                 "realized_rate": "0.000100000000000000",
		//                 "funding_time": "1638921600000",
		//                 "contract_code": "BTC-USDT",
		//                 "symbol": "BTC",
		//                 "fee_asset": "USDT"
		//             },
		//         ]
		//     },
		//     "ts": 1638939294277
		// }
		//
		var data interface{} = this.SafeValue(response, "data")
		var cursor interface{} = this.SafeValue(data, "current_page")
		var result interface{} = this.SafeValue(data, "data", []interface{}{})
		var rates interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(result)); i++ {
			var entry interface{} = GetValue(result, i)
			AddElementToObject(entry, "current_page", cursor)
			var marketId interface{} = this.SafeString(entry, "contract_code")
			var symbolInner interface{} = this.SafeSymbol(marketId)
			var timestamp interface{} = this.SafeInteger(entry, "funding_time")
			AppendToArray(&rates, map[string]interface{}{
				"info":        entry,
				"symbol":      symbolInner,
				"fundingRate": this.SafeNumber(entry, "funding_rate"),
				"timestamp":   timestamp,
				"datetime":    this.Iso8601(timestamp),
			})
		}
		var sorted interface{} = this.SortBy(rates, "timestamp")

		ch <- this.FilterBySymbolSinceLimit(sorted, GetValue(market, "symbol"), since, limit)
		return nil

	}()
	return ch
}
func (this *HtxCore) ParseFundingRate(contract interface{}, optionalArgs ...interface{}) interface{} {
	//
	// {
	//      "status": "ok",
	//      "data": {
	//         "estimated_rate": "0.000100000000000000",
	//         "funding_rate": "0.000100000000000000",
	//         "contract_code": "BCH-USD",
	//         "symbol": "BCH",
	//         "fee_asset": "BCH",
	//         "funding_time": "1639094400000",
	//         "next_funding_time": "1639123200000"
	//     },
	//     "ts": 1639085854775
	// }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var nextFundingRate interface{} = this.SafeNumber(contract, "estimated_rate")
	var fundingTimestamp interface{} = this.SafeInteger(contract, "funding_time")
	var nextFundingTimestamp interface{} = this.SafeInteger(contract, "next_funding_time")
	var fundingTimeString interface{} = this.SafeString(contract, "funding_time")
	var nextFundingTimeString interface{} = this.SafeString(contract, "next_funding_time")
	var millisecondsInterval interface{} = Precise.StringSub(nextFundingTimeString, fundingTimeString)
	var marketId interface{} = this.SafeString(contract, "contract_code")
	var symbol interface{} = this.SafeSymbol(marketId, market)
	return map[string]interface{}{
		"info":                     contract,
		"symbol":                   symbol,
		"markPrice":                nil,
		"indexPrice":               nil,
		"interestRate":             nil,
		"estimatedSettlePrice":     nil,
		"timestamp":                nil,
		"datetime":                 nil,
		"fundingRate":              this.SafeNumber(contract, "funding_rate"),
		"fundingTimestamp":         fundingTimestamp,
		"fundingDatetime":          this.Iso8601(fundingTimestamp),
		"nextFundingRate":          nextFundingRate,
		"nextFundingTimestamp":     nextFundingTimestamp,
		"nextFundingDatetime":      this.Iso8601(nextFundingTimestamp),
		"previousFundingRate":      nil,
		"previousFundingTimestamp": nil,
		"previousFundingDatetime":  nil,
		"interval":                 this.ParseFundingInterval(millisecondsInterval),
	}
}
func (this *HtxCore) ParseFundingInterval(interval interface{}) interface{} {
	var intervals interface{} = map[string]interface{}{
		"3600000":  "1h",
		"14400000": "4h",
		"28800000": "8h",
		"57600000": "16h",
		"86400000": "24h",
	}
	return this.SafeString(intervals, interval, interval)
}

/**
 * @method
 * @name htx#fetchFundingRate
 * @description fetch the current funding rate
 * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#query-funding-rate
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#general-query-funding-rate
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/?id=funding-rate-structure}
 */
func (this *HtxCore) FetchFundingRate(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes71218 := (<-this.LoadMarkets())
		PanicOnError(retRes71218)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"contract_code": GetValue(market, "id"),
		}
		var response interface{} = nil
		if IsTrue(GetValue(market, "inverse")) {

			response = (<-this.ContractPublicGetSwapApiV1SwapFundingRate(this.Extend(request, params)))
			PanicOnError(response)
		} else if IsTrue(GetValue(market, "linear")) {

			response = (<-this.ContractPublicGetLinearSwapApiV1SwapFundingRate(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			panic(NotSupported(Add(this.Id, " fetchFundingRate() supports inverse and linear swaps only")))
		}
		//
		// {
		//     "status": "ok",
		//     "data": {
		//         "estimated_rate": "0.000100000000000000",
		//         "funding_rate": "0.000100000000000000",
		//         "contract_code": "BTC-USDT",
		//         "symbol": "BTC",
		//         "fee_asset": "USDT",
		//         "funding_time": "1603699200000",
		//         "next_funding_time": "1603728000000"
		//     },
		//     "ts": 1603696494714
		// }
		//
		var result interface{} = this.SafeValue(response, "data", map[string]interface{}{})

		ch <- this.ParseFundingRate(result, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name htx#fetchFundingRates
 * @description fetch the funding rate for multiple markets
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#general-query-a-batch-of-funding-rate
 * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#query-a-batch-of-funding-rate
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/?id=funding-rates-structure}, indexed by market symbols
 */
func (this *HtxCore) FetchFundingRates(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes71648 := (<-this.LoadMarkets())
		PanicOnError(retRes71648)
		symbols = this.MarketSymbols(symbols)
		var defaultSubType interface{} = this.SafeString(this.Options, "defaultSubType", "linear")
		var subType interface{} = nil
		subTypeparamsVariable := this.HandleOptionAndParams(params, "fetchFundingRates", "subType", defaultSubType)
		subType = GetValue(subTypeparamsVariable, 0)
		params = GetValue(subTypeparamsVariable, 1)
		if IsTrue(!IsEqual(symbols, nil)) {
			var firstSymbol interface{} = this.SafeString(symbols, 0)
			var market interface{} = this.Market(firstSymbol)
			var isLinear interface{} = GetValue(market, "linear")
			subType = Ternary(IsTrue(isLinear), "linear", "inverse")
		}
		var request interface{} = map[string]interface{}{}
		var response interface{} = nil
		if IsTrue(IsEqual(subType, "linear")) {

			response = (<-this.ContractPublicGetLinearSwapApiV1SwapBatchFundingRate(this.Extend(request, params)))
			PanicOnError(response)
		} else if IsTrue(IsEqual(subType, "inverse")) {

			response = (<-this.ContractPublicGetSwapApiV1SwapBatchFundingRate(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			panic(NotSupported(Add(this.Id, " fetchFundingRates() not support this market type")))
		}
		//
		//     {
		//         "status": "ok",
		//         "data": [
		//             {
		//                 "estimated_rate": "0.000100000000000000",
		//                 "funding_rate": "0.000100000000000000",
		//                 "contract_code": "MANA-USDT",
		//                 "symbol": "MANA",
		//                 "fee_asset": "USDT",
		//                 "funding_time": "1643356800000",
		//                 "next_funding_time": "1643385600000",
		//                 "trade_partition":"USDT"
		//             },
		//         ],
		//         "ts": 1643346173103
		//     }
		//
		var data interface{} = this.SafeValue(response, "data", []interface{}{})

		ch <- this.ParseFundingRates(data, symbols)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name htx#fetchBorrowInterest
 * @description fetch the interest owed by the user for borrowing currency for margin trading
 * @see https://huobiapi.github.io/docs/spot/v1/en/#search-past-margin-orders-cross
 * @see https://huobiapi.github.io/docs/spot/v1/en/#search-past-margin-orders-isolated
 * @param {string} code unified currency code
 * @param {string} symbol unified market symbol when fetch interest in isolated markets
 * @param {int} [since] the earliest time in ms to fetch borrrow interest for
 * @param {int} [limit] the maximum number of structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [borrow interest structures]{@link https://docs.ccxt.com/?id=borrow-interest-structure}
 */
func (this *HtxCore) FetchBorrowInterest(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		symbol := GetArg(optionalArgs, 1, nil)
		_ = symbol
		since := GetArg(optionalArgs, 2, nil)
		_ = since
		limit := GetArg(optionalArgs, 3, nil)
		_ = limit
		params := GetArg(optionalArgs, 4, map[string]interface{}{})
		_ = params

		retRes72228 := (<-this.LoadMarkets())
		PanicOnError(retRes72228)
		var marginMode interface{} = nil
		marginModeparamsVariable := this.HandleMarginModeAndParams("fetchBorrowInterest", params)
		marginMode = GetValue(marginModeparamsVariable, 0)
		params = GetValue(marginModeparamsVariable, 1)
		marginMode = Ternary(IsTrue((IsEqual(marginMode, nil))), "cross", marginMode)
		var request interface{} = map[string]interface{}{}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "start-date", this.Yyyymmdd(since))
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "size", limit)
		}
		var market interface{} = nil
		var response interface{} = nil
		if IsTrue(IsEqual(marginMode, "isolated")) {
			if IsTrue(!IsEqual(symbol, nil)) {
				market = this.Market(symbol)
				AddElementToObject(request, "symbol", GetValue(market, "id"))
			}

			response = (<-this.PrivateGetMarginLoanOrders(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			if IsTrue(!IsEqual(code, nil)) {
				var currency interface{} = this.Currency(code)
				AddElementToObject(request, "currency", GetValue(currency, "id"))
			}

			response = (<-this.PrivateGetCrossMarginLoanOrders(this.Extend(request, params)))
			PanicOnError(response)
		}
		//
		//    {
		//        "status":"ok",
		//        "data":[
		//            {
		//                "loan-balance":"0.100000000000000000",
		//                "interest-balance":"0.000200000000000000",
		//                "loan-amount":"0.100000000000000000",
		//                "accrued-at":1511169724531,
		//                "interest-amount":"0.000200000000000000",
		//                "filled-points":"0.2",
		//                "filled-ht":"0.2",
		//                "currency":"btc",
		//                "id":394,
		//                "state":"accrual",
		//                "account-id":17747,
		//                "user-id":119913,
		//                "created-at":1511169724531
		//            }
		//        ]
		//    }
		//
		var data interface{} = this.SafeValue(response, "data")
		var interest interface{} = this.ParseBorrowInterests(data, market)

		ch <- this.FilterByCurrencySinceLimit(interest, code, since, limit)
		return nil

	}()
	return ch
}
func (this *HtxCore) ParseBorrowInterest(info interface{}, optionalArgs ...interface{}) interface{} {
	// isolated
	//    {
	//        "interest-rate":"0.000040830000000000",
	//        "user-id":35930539,
	//        "account-id":48916071,
	//        "updated-at":1649320794195,
	//        "deduct-rate":"1",
	//        "day-interest-rate":"0.000980000000000000",
	//        "hour-interest-rate":"0.000040830000000000",
	//        "loan-balance":"100.790000000000000000",
	//        "interest-balance":"0.004115260000000000",
	//        "loan-amount":"100.790000000000000000",
	//        "paid-coin":"0.000000000000000000",
	//        "accrued-at":1649320794148,
	//        "created-at":1649320794148,
	//        "interest-amount":"0.004115260000000000",
	//        "deduct-amount":"0",
	//        "deduct-currency":"",
	//        "paid-point":"0.000000000000000000",
	//        "currency":"usdt",
	//        "symbol":"ltcusdt",
	//        "id":20242721,
	//    }
	//
	// cross
	//   {
	//       "id":3416576,
	//       "user-id":35930539,
	//       "account-id":48956839,
	//       "currency":"usdt",
	//       "loan-amount":"102",
	//       "loan-balance":"102",
	//       "interest-amount":"0.00416466",
	//       "interest-balance":"0.00416466",
	//       "created-at":1649322735333,
	//       "accrued-at":1649322735382,
	//       "state":"accrual",
	//       "filled-points":"0",
	//       "filled-ht":"0"
	//   }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(info, "symbol")
	var marginMode interface{} = Ternary(IsTrue((IsEqual(marketId, nil))), "cross", "isolated")
	market = this.SafeMarket(marketId)
	var symbol interface{} = this.SafeString(market, "symbol")
	var timestamp interface{} = this.SafeInteger(info, "accrued-at")
	return map[string]interface{}{
		"info":           info,
		"symbol":         symbol,
		"currency":       this.SafeCurrencyCode(this.SafeString(info, "currency")),
		"interest":       this.SafeNumber(info, "interest-amount"),
		"interestRate":   this.SafeNumber(info, "interest-rate"),
		"amountBorrowed": this.SafeNumber(info, "loan-amount"),
		"marginMode":     marginMode,
		"timestamp":      timestamp,
		"datetime":       this.Iso8601(timestamp),
	}
}
func (this *HtxCore) Nonce() interface{} {
	return Subtract(this.Milliseconds(), GetValue(this.Options, "timeDifference"))
}
func (this *HtxCore) Sign(path interface{}, optionalArgs ...interface{}) interface{} {
	api := GetArg(optionalArgs, 0, "public")
	_ = api
	method := GetArg(optionalArgs, 1, "GET")
	_ = method
	params := GetArg(optionalArgs, 2, map[string]interface{}{})
	_ = params
	headers := GetArg(optionalArgs, 3, nil)
	_ = headers
	body := GetArg(optionalArgs, 4, nil)
	_ = body
	var url interface{} = "/"
	var query interface{} = this.Omit(params, this.ExtractParams(path))
	if IsTrue(IsString(api)) {
		// signing implementation for the old endpoints
		if IsTrue(IsTrue((IsEqual(api, "public"))) || IsTrue((IsEqual(api, "private")))) {
			url = Add(url, this.Version)
		} else if IsTrue(IsTrue((IsEqual(api, "v2Public"))) || IsTrue((IsEqual(api, "v2Private")))) {
			url = Add(url, "v2")
		}
		url = Add(url, Add("/", this.ImplodeParams(path, params)))
		if IsTrue(IsTrue(IsEqual(api, "private")) || IsTrue(IsEqual(api, "v2Private"))) {
			this.CheckRequiredCredentials()
			var timestamp interface{} = this.Ymdhms(this.Nonce(), "T")
			var request interface{} = map[string]interface{}{
				"SignatureMethod":  "HmacSHA256",
				"SignatureVersion": "2",
				"AccessKeyId":      this.ApiKey,
				"Timestamp":        timestamp,
			}
			if IsTrue(!IsEqual(method, "POST")) {
				request = this.Extend(request, query)
			}
			var sortedRequest interface{} = this.Keysort(request)
			var auth interface{} = this.Urlencode(sortedRequest, true) // true is a go only requirment
			// unfortunately, PHP demands double quotes for the escaped newline symbol
			var payload interface{} = Join([]interface{}{method, this.Hostname, url, auth}, "\n") // eslint-disable-line quotes
			var signature interface{} = this.Hmac(this.Encode(payload), this.Encode(this.Secret), sha256, "base64")
			auth = Add(auth, Add("&", this.Urlencode(map[string]interface{}{
				"Signature": signature,
			})))
			url = Add(url, Add("?", auth))
			if IsTrue(IsEqual(method, "POST")) {
				body = this.Json(query)
				headers = map[string]interface{}{
					"Content-Type": "application/json",
				}
			} else {
				headers = map[string]interface{}{
					"Content-Type": "application/x-www-form-urlencoded",
				}
			}
		} else {
			if IsTrue(GetArrayLength(ObjectKeys(query))) {
				url = Add(url, Add("?", this.Urlencode(query)))
			}
		}
		url = Add(this.ImplodeParams(GetValue(GetValue(this.Urls, "api"), api), map[string]interface{}{
			"hostname": this.Hostname,
		}), url)
	} else {
		// signing implementation for the new endpoints
		// const [ type, access ] = api;
		var typeVar interface{} = this.SafeString(api, 0)
		var access interface{} = this.SafeString(api, 1)
		var levelOneNestedPath interface{} = this.SafeString(api, 2)
		var levelTwoNestedPath interface{} = this.SafeString(api, 3)
		var hostname interface{} = nil
		var hostnames interface{} = this.SafeValue(GetValue(this.Urls, "hostnames"), typeVar)
		if IsTrue(!IsString(hostnames)) {
			hostnames = this.SafeValue(hostnames, levelOneNestedPath)
			if IsTrue(IsTrue((!IsString(hostnames))) && IsTrue((!IsEqual(levelTwoNestedPath, nil)))) {
				hostnames = this.SafeValue(hostnames, levelTwoNestedPath)
			}
		}
		hostname = hostnames
		url = Add(url, this.ImplodeParams(path, params))
		if IsTrue(IsEqual(access, "public")) {
			if IsTrue(GetArrayLength(ObjectKeys(query))) {
				url = Add(url, Add("?", this.Urlencode(query)))
			}
		} else if IsTrue(IsEqual(access, "private")) {
			this.CheckRequiredCredentials()
			if IsTrue(IsEqual(method, "POST")) {
				var options interface{} = this.SafeValue(this.Options, "broker", map[string]interface{}{})
				var id interface{} = this.SafeString(options, "id", "AA03022abc")
				if IsTrue(IsTrue(IsEqual(GetIndexOf(path, "cancel"), OpNeg(1))) && IsTrue(EndsWith(path, "order"))) {
					// swap order placement
					var channelCode interface{} = this.SafeString(params, "channel_code")
					if IsTrue(IsEqual(channelCode, nil)) {
						AddElementToObject(params, "channel_code", id)
					}
				} else if IsTrue(EndsWith(path, "orders/place")) {
					// spot order placement
					var clientOrderId interface{} = this.SafeString(params, "client-order-id")
					if IsTrue(IsEqual(clientOrderId, nil)) {
						AddElementToObject(params, "client-order-id", Add(id, this.Uuid()))
					}
				}
			}
			var timestamp interface{} = this.Ymdhms(this.Nonce(), "T")
			var request interface{} = map[string]interface{}{
				"SignatureMethod":  "HmacSHA256",
				"SignatureVersion": "2",
				"AccessKeyId":      this.ApiKey,
				"Timestamp":        timestamp,
			}
			// sorting needs such flow exactly, before urlencoding (more at: https://github.com/ccxt/ccxt/issues/24930 )
			request = this.Keysort(request)
			if IsTrue(!IsEqual(method, "POST")) {
				var sortedQuery interface{} = this.Keysort(query)
				request = this.Extend(request, sortedQuery)
			}
			var auth interface{} = Replace(this.Urlencode(request, true), "%2c", "%2C") // in c# it manually needs to be uppercased
			// unfortunately, PHP demands double quotes for the escaped newline symbol
			var payload interface{} = Join([]interface{}{method, hostname, url, auth}, "\n") // eslint-disable-line quotes
			var signature interface{} = this.Hmac(this.Encode(payload), this.Encode(this.Secret), sha256, "base64")
			auth = Add(auth, Add("&", this.Urlencode(map[string]interface{}{
				"Signature": signature,
			})))
			url = Add(url, Add("?", auth))
			if IsTrue(IsEqual(method, "POST")) {
				body = this.Json(query)
				if IsTrue(IsEqual(GetArrayLength(body), 2)) {
					body = "{}"
				}
				headers = map[string]interface{}{
					"Content-Type": "application/json",
				}
			} else {
				headers = map[string]interface{}{
					"Content-Type": "application/x-www-form-urlencoded",
				}
			}
		}
		url = Add(this.ImplodeParams(GetValue(GetValue(this.Urls, "api"), typeVar), map[string]interface{}{
			"hostname": hostname,
		}), url)
	}
	return map[string]interface{}{
		"url":     url,
		"method":  method,
		"body":    body,
		"headers": headers,
	}
}
func (this *HtxCore) HandleErrors(httpCode interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{} {
	if IsTrue(IsEqual(response, nil)) {
		return nil // fallback to default error handler
	}
	if IsTrue(InOp(response, "status")) {
		//
		//     {"status":"error","err-code":"o-amount-min-error","err-msg":"limit order amount error, min: `0.001`","data":null}
		//     {"status":"ok","data":{"errors":[{"order_id":"1349442392365359104","err_code":1061,"err_msg":"The order does not exist."}],"successes":""},"ts":1741773744526}
		//
		var status interface{} = this.SafeString(response, "status")
		if IsTrue(IsEqual(status, "error")) {
			var code interface{} = this.SafeString2(response, "err-code", "err_code")
			var feedback interface{} = Add(Add(this.Id, " "), body)
			this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), body, feedback)
			this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), code, feedback)
			var message interface{} = this.SafeString2(response, "err-msg", "err_msg")
			this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), message, feedback)
			panic(ExchangeError(feedback))
		}
	}
	if IsTrue(InOp(response, "code")) {
		// {code: '1003', message: 'invalid signature'}
		var feedback interface{} = Add(Add(this.Id, " "), body)
		var code interface{} = this.SafeString(response, "code")
		this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), code, feedback)
	}
	var data interface{} = this.SafeDict(response, "data")
	var errorsList interface{} = this.SafeList(data, "errors")
	if IsTrue(!IsEqual(errorsList, nil)) {
		var first interface{} = this.SafeDict(errorsList, 0)
		var errcode interface{} = this.SafeString(first, "err_code")
		var errmessage interface{} = this.SafeString(first, "err_msg")
		var feedBack interface{} = Add(Add(this.Id, " "), body)
		this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), errcode, feedBack)
		this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), errmessage, feedBack)
	}
	return nil
}

/**
 * @method
 * @name htx#fetchFundingHistory
 * @description fetch the history of funding payments paid and received on this account
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#general-query-account-financial-records-via-multiple-fields-new   // linear swaps
 * @see https://huobiapi.github.io/docs/dm/v1/en/#query-financial-records-via-multiple-fields-new                          // coin-m futures
 * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#query-financial-records-via-multiple-fields-new          // coin-m swaps
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch funding history for
 * @param {int} [limit] the maximum number of funding history structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding history structure]{@link https://docs.ccxt.com/?id=funding-history-structure}
 */
func (this *HtxCore) FetchFundingHistory(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes75208 := (<-this.LoadMarkets())
		PanicOnError(retRes75208)
		var market interface{} = this.Market(symbol)
		marketTypequeryVariable := this.HandleMarketTypeAndParams("fetchFundingHistory", market, params)
		marketType := GetValue(marketTypequeryVariable, 0)
		query := GetValue(marketTypequeryVariable, 1)
		var request interface{} = map[string]interface{}{
			"type": "30,31",
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "start_date", since)
		}
		var response interface{} = nil
		if IsTrue(IsEqual(marketType, "swap")) {
			AddElementToObject(request, "contract", GetValue(market, "id"))
			if IsTrue(GetValue(market, "linear")) {
				//
				//    {
				//        "status": "ok",
				//        "data": {
				//           "financial_record": [
				//               {
				//                   "id": "1320088022",
				//                   "type": "30",
				//                   "amount": "0.004732510000000000",
				//                   "ts": "1641168019321",
				//                   "contract_code": "BTC-USDT",
				//                   "asset": "USDT",
				//                   "margin_account": "BTC-USDT",
				//                   "face_margin_account": ''
				//               },
				//           ],
				//           "remain_size": "0",
				//           "next_id": null
				//        },
				//        "ts": "1641189898425"
				//    }
				//
				var marginMode interface{} = nil
				marginModeparamsVariable := this.HandleMarginModeAndParams("fetchFundingHistory", params)
				marginMode = GetValue(marginModeparamsVariable, 0)
				params = GetValue(marginModeparamsVariable, 1)
				marginMode = Ternary(IsTrue((IsEqual(marginMode, nil))), "cross", marginMode)
				if IsTrue(IsEqual(marginMode, "isolated")) {
					AddElementToObject(request, "mar_acct", GetValue(market, "id"))
				} else {
					AddElementToObject(request, "mar_acct", GetValue(market, "quoteId"))
				}

				response = (<-this.ContractPrivatePostLinearSwapApiV3SwapFinancialRecordExact(this.Extend(request, query)))
				PanicOnError(response)
			} else {
				//
				//     {
				//         "code": 200,
				//         "msg": "",
				//         "data": [
				//             {
				//                 "query_id": 138798248,
				//                 "id": 117840,
				//                 "type": 5,
				//                 "amount": -0.024464850000000000,
				//                 "ts": 1638758435635,
				//                 "contract_code": "BTC-USDT-211210",
				//                 "asset": "USDT",
				//                 "margin_account": "USDT",
				//                 "face_margin_account": ""
				//             }
				//         ],
				//         "ts": 1604312615051
				//     }
				//

				response = (<-this.ContractPrivatePostSwapApiV3SwapFinancialRecordExact(this.Extend(request, query)))
				PanicOnError(response)
			}
		} else {
			AddElementToObject(request, "symbol", GetValue(market, "id"))

			response = (<-this.ContractPrivatePostApiV3ContractFinancialRecordExact(this.Extend(request, query)))
			PanicOnError(response)
		}
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseIncomes(data, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name htx#setLeverage
 * @description set the level of leverage for a market
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#isolated-switch-leverage
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#cross-switch-leverage
 * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#switch-leverage
 * @see https://huobiapi.github.io/docs/dm/v1/en/#switch-leverage  // Coin-m futures
 * @param {float} leverage the rate of leverage
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} response from the exchange
 */
func (this *HtxCore) SetLeverage(leverage interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " setLeverage() requires a symbol argument")))
		}

		retRes76128 := (<-this.LoadMarkets())
		PanicOnError(retRes76128)
		var market interface{} = this.Market(symbol)
		marketTypequeryVariable := this.HandleMarketTypeAndParams("setLeverage", market, params)
		marketType := GetValue(marketTypequeryVariable, 0)
		query := GetValue(marketTypequeryVariable, 1)
		var request interface{} = map[string]interface{}{
			"lever_rate": leverage,
		}
		if IsTrue(IsTrue(IsEqual(marketType, "future")) && IsTrue(GetValue(market, "inverse"))) {
			AddElementToObject(request, "symbol", GetValue(market, "settleId"))
		} else {
			AddElementToObject(request, "contract_code", GetValue(market, "id"))
		}
		var response interface{} = nil
		if IsTrue(GetValue(market, "linear")) {
			var marginMode interface{} = nil
			marginModeparamsVariable := this.HandleMarginModeAndParams("setLeverage", params)
			marginMode = GetValue(marginModeparamsVariable, 0)
			params = GetValue(marginModeparamsVariable, 1)
			marginMode = Ternary(IsTrue((IsEqual(marginMode, nil))), "cross", marginMode)
			if IsTrue(IsEqual(marginMode, "isolated")) {

				response = (<-this.ContractPrivatePostLinearSwapApiV1SwapSwitchLeverRate(this.Extend(request, query)))
				PanicOnError(response)
			} else if IsTrue(IsEqual(marginMode, "cross")) {

				response = (<-this.ContractPrivatePostLinearSwapApiV1SwapCrossSwitchLeverRate(this.Extend(request, query)))
				PanicOnError(response)
			} else {
				panic(NotSupported(Add(this.Id, " setLeverage() not support this market type")))
			}
		} else {
			if IsTrue(IsEqual(marketType, "future")) {

				response = (<-this.ContractPrivatePostApiV1ContractSwitchLeverRate(this.Extend(request, query)))
				PanicOnError(response)
			} else if IsTrue(IsEqual(marketType, "swap")) {

				response = (<-this.ContractPrivatePostSwapApiV1SwapSwitchLeverRate(this.Extend(request, query)))
				PanicOnError(response)
			} else {
				panic(NotSupported(Add(this.Id, " setLeverage() not support this market type")))
			}
		}

		ch <- response
		return nil

	}()
	return ch
}
func (this *HtxCore) ParseIncome(income interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//       "id": "1667161118",
	//       "symbol": "BTC",
	//       "type": "31",
	//       "amount": "-2.11306593188E-7",
	//       "ts": "1641139308983",
	//       "contract_code": "BTC-USD"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(income, "contract_code")
	var symbol interface{} = this.SafeSymbol(marketId, market)
	var amount interface{} = this.SafeNumber(income, "amount")
	var timestamp interface{} = this.SafeInteger(income, "ts")
	var id interface{} = this.SafeString(income, "id")
	var currencyId interface{} = this.SafeString2(income, "symbol", "asset")
	var code interface{} = this.SafeCurrencyCode(currencyId)
	return map[string]interface{}{
		"info":      income,
		"symbol":    symbol,
		"code":      code,
		"timestamp": timestamp,
		"datetime":  this.Iso8601(timestamp),
		"id":        id,
		"amount":    amount,
	}
}
func (this *HtxCore) ParsePosition(position interface{}, optionalArgs ...interface{}) interface{} {
	//
	//    {
	//        "symbol": "BTC",
	//        "contract_code": "BTC-USDT",
	//        "volume": "1.000000000000000000",
	//        "available": "1.000000000000000000",
	//        "frozen": "0E-18",
	//        "cost_open": "47162.000000000000000000",
	//        "cost_hold": "47151.300000000000000000",
	//        "profit_unreal": "0.007300000000000000",
	//        "profit_rate": "-0.000144183876850008",
	//        "lever_rate": "2",
	//        "position_margin": "23.579300000000000000",
	//        "direction": "buy",
	//        "profit": "-0.003400000000000000",
	//        "last_price": "47158.6",
	//        "margin_asset": "USDT",
	//        "margin_mode": "isolated",
	//        "margin_account": "BTC-USDT",
	//        "margin_balance": "24.973020070000000000",
	//        "margin_position": "23.579300000000000000",
	//        "margin_frozen": "0",
	//        "margin_available": "1.393720070000000000",
	//        "profit_real": "0E-18",
	//        "risk_rate": "1.044107779705080303",
	//        "withdraw_available": "1.386420070000000000000000000000000000",
	//        "liquidation_price": "22353.229148614609571788",
	//        "adjust_factor": "0.015000000000000000",
	//        "margin_static": "24.965720070000000000"
	//    }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	market = this.SafeMarket(this.SafeString(position, "contract_code"))
	var symbol interface{} = GetValue(market, "symbol")
	var contracts interface{} = this.SafeString(position, "volume")
	var contractSize interface{} = this.SafeValue(market, "contractSize")
	var contractSizeString interface{} = this.NumberToString(contractSize)
	var entryPrice interface{} = this.SafeNumber(position, "cost_open")
	var initialMargin interface{} = this.SafeString(position, "position_margin")
	var rawSide interface{} = this.SafeString(position, "direction")
	var side interface{} = Ternary(IsTrue((IsEqual(rawSide, "buy"))), "long", "short")
	var unrealizedProfit interface{} = this.SafeNumber(position, "profit_unreal")
	var marginMode interface{} = this.SafeString(position, "margin_mode")
	var leverage interface{} = this.SafeString(position, "lever_rate")
	var percentage interface{} = Precise.StringMul(this.SafeString(position, "profit_rate"), "100")
	var lastPrice interface{} = this.SafeString(position, "last_price")
	var faceValue interface{} = Precise.StringMul(contracts, contractSizeString)
	var notional interface{} = nil
	if IsTrue(GetValue(market, "linear")) {
		notional = Precise.StringMul(faceValue, lastPrice)
	} else {
		notional = Precise.StringDiv(faceValue, lastPrice)
		marginMode = "cross"
	}
	var intialMarginPercentage interface{} = Precise.StringDiv(initialMargin, notional)
	var collateral interface{} = this.SafeString(position, "margin_balance")
	var liquidationPrice interface{} = this.SafeNumber(position, "liquidation_price")
	var adjustmentFactor interface{} = this.SafeString(position, "adjust_factor")
	var maintenanceMarginPercentage interface{} = Precise.StringDiv(adjustmentFactor, leverage)
	var maintenanceMargin interface{} = Precise.StringMul(maintenanceMarginPercentage, notional)
	var marginRatio interface{} = Precise.StringDiv(maintenanceMargin, collateral)
	return this.SafePosition(map[string]interface{}{
		"info":                        position,
		"id":                          nil,
		"symbol":                      symbol,
		"contracts":                   this.ParseNumber(contracts),
		"contractSize":                contractSize,
		"entryPrice":                  entryPrice,
		"collateral":                  this.ParseNumber(collateral),
		"side":                        side,
		"unrealizedPnl":               unrealizedProfit,
		"leverage":                    this.ParseNumber(leverage),
		"percentage":                  this.ParseNumber(percentage),
		"marginMode":                  marginMode,
		"notional":                    this.ParseNumber(notional),
		"markPrice":                   nil,
		"lastPrice":                   nil,
		"liquidationPrice":            liquidationPrice,
		"initialMargin":               this.ParseNumber(initialMargin),
		"initialMarginPercentage":     this.ParseNumber(intialMarginPercentage),
		"maintenanceMargin":           this.ParseNumber(maintenanceMargin),
		"maintenanceMarginPercentage": this.ParseNumber(maintenanceMarginPercentage),
		"marginRatio":                 this.ParseNumber(marginRatio),
		"timestamp":                   nil,
		"datetime":                    nil,
		"hedged":                      nil,
		"lastUpdateTimestamp":         nil,
		"stopLossPrice":               nil,
		"takeProfitPrice":             nil,
	})
}

/**
 * @method
 * @name htx#fetchPositions
 * @description fetch all open positions
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#cross-query-user-39-s-position-information
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#isolated-query-user-s-position-information
 * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#query-user-s-position-information
 * @see https://huobiapi.github.io/docs/dm/v1/en/#query-user-s-position-information
 * @param {string[]} [symbols] list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.subType] 'linear' or 'inverse'
 * @param {string} [params.type] *inverse only* 'future', or 'swap'
 * @param {string} [params.marginMode] *linear only* 'cross' or 'isolated'
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/?id=position-structure}
 */
func (this *HtxCore) FetchPositions(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes78118 := (<-this.LoadMarkets())
		PanicOnError(retRes78118)
		symbols = this.MarketSymbols(symbols)
		var market interface{} = nil
		if IsTrue(!IsEqual(symbols, nil)) {
			var symbolsLength interface{} = GetArrayLength(symbols)
			if IsTrue(IsGreaterThan(symbolsLength, 0)) {
				var first interface{} = this.SafeString(symbols, 0)
				market = this.Market(first)
			}
		}
		var marginMode interface{} = nil
		marginModeparamsVariable := this.HandleMarginModeAndParams("fetchPositions", params, "cross")
		marginMode = GetValue(marginModeparamsVariable, 0)
		params = GetValue(marginModeparamsVariable, 1)
		var subType interface{} = nil
		subTypeparamsVariable := this.HandleSubTypeAndParams("fetchPositions", market, params, "linear")
		subType = GetValue(subTypeparamsVariable, 0)
		params = GetValue(subTypeparamsVariable, 1)
		var marketType interface{} = nil
		marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchPositions", market, params)
		marketType = GetValue(marketTypeparamsVariable, 0)
		params = GetValue(marketTypeparamsVariable, 1)
		if IsTrue(IsEqual(marketType, "spot")) {
			marketType = "future"
		}
		var response interface{} = nil
		if IsTrue(IsEqual(subType, "linear")) {
			if IsTrue(IsEqual(marginMode, "isolated")) {

				response = (<-this.ContractPrivatePostLinearSwapApiV1SwapPositionInfo(params))
				PanicOnError(response)
			} else if IsTrue(IsEqual(marginMode, "cross")) {

				response = (<-this.ContractPrivatePostLinearSwapApiV1SwapCrossPositionInfo(params))
				PanicOnError(response)
			} else {
				panic(NotSupported(Add(this.Id, " fetchPositions() not support this market type")))
			}
		} else {
			if IsTrue(IsEqual(marketType, "future")) {

				response = (<-this.ContractPrivatePostApiV1ContractPositionInfo(params))
				PanicOnError(response)
			} else if IsTrue(IsEqual(marketType, "swap")) {

				response = (<-this.ContractPrivatePostSwapApiV1SwapPositionInfo(params))
				PanicOnError(response)
			} else {
				panic(NotSupported(Add(this.Id, " fetchPositions() not support this market type")))
			}
		}
		var data interface{} = this.SafeValue(response, "data", []interface{}{})
		var timestamp interface{} = this.SafeInteger(response, "ts")
		var result interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
			var position interface{} = GetValue(data, i)
			var parsed interface{} = this.ParsePosition(position)
			AppendToArray(&result, this.Extend(parsed, map[string]interface{}{
				"timestamp": timestamp,
				"datetime":  this.Iso8601(timestamp),
			}))
		}

		ch <- this.FilterByArrayPositions(result, "symbol", symbols, false)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name htx#fetchPosition
 * @description fetch data on a single open contract trade position
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#cross-query-assets-and-positions
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#isolated-query-assets-and-positions
 * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#query-assets-and-positions
 * @see https://huobiapi.github.io/docs/dm/v1/en/#query-assets-and-positions
 * @param {string} symbol unified market symbol of the market the position is held in, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [position structure]{@link https://docs.ccxt.com/?id=position-structure}
 */
func (this *HtxCore) FetchPosition(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes79528 := (<-this.LoadMarkets())
		PanicOnError(retRes79528)
		var market interface{} = this.Market(symbol)
		var marginMode interface{} = nil
		marginModeparamsVariable := this.HandleMarginModeAndParams("fetchPosition", params)
		marginMode = GetValue(marginModeparamsVariable, 0)
		params = GetValue(marginModeparamsVariable, 1)
		marginMode = Ternary(IsTrue((IsEqual(marginMode, nil))), "cross", marginMode)
		marketTypequeryVariable := this.HandleMarketTypeAndParams("fetchPosition", market, params)
		marketType := GetValue(marketTypequeryVariable, 0)
		query := GetValue(marketTypequeryVariable, 1)
		var request interface{} = map[string]interface{}{}
		if IsTrue(IsTrue(GetValue(market, "future")) && IsTrue(GetValue(market, "inverse"))) {
			AddElementToObject(request, "symbol", GetValue(market, "settleId"))
		} else {
			if IsTrue(IsEqual(marginMode, "cross")) {
				AddElementToObject(request, "margin_account", "USDT") // only allowed value
			}
			AddElementToObject(request, "contract_code", GetValue(market, "id"))
		}
		var response interface{} = nil
		if IsTrue(GetValue(market, "linear")) {
			if IsTrue(IsEqual(marginMode, "isolated")) {

				response = (<-this.ContractPrivatePostLinearSwapApiV1SwapAccountPositionInfo(this.Extend(request, query)))
				PanicOnError(response)
			} else if IsTrue(IsEqual(marginMode, "cross")) {

				response = (<-this.ContractPrivatePostLinearSwapApiV1SwapCrossAccountPositionInfo(this.Extend(request, query)))
				PanicOnError(response)
			} else {
				panic(NotSupported(Add(this.Id, " fetchPosition() not support this market type")))
			}
		} else {
			if IsTrue(IsEqual(marketType, "future")) {

				response = (<-this.ContractPrivatePostApiV1ContractAccountPositionInfo(this.Extend(request, query)))
				PanicOnError(response)
			} else if IsTrue(IsEqual(marketType, "swap")) {

				response = (<-this.ContractPrivatePostSwapApiV1SwapAccountPositionInfo(this.Extend(request, query)))
				PanicOnError(response)
			} else {
				panic(NotSupported(Add(this.Id, " setLeverage() not support this market type")))
			}
		}
		var data interface{} = this.SafeValue(response, "data")
		var account interface{} = nil
		if IsTrue(IsEqual(marginMode, "cross")) {
			account = data
		} else {
			account = this.SafeValue(data, 0)
		}
		var omitted interface{} = this.Omit(account, []interface{}{"positions"})
		var positions interface{} = this.SafeValue(account, "positions")
		var position interface{} = nil
		if IsTrue(IsTrue(GetValue(market, "future")) && IsTrue(GetValue(market, "inverse"))) {
			for i := 0; IsLessThan(i, GetArrayLength(positions)); i++ {
				var entry interface{} = GetValue(positions, i)
				if IsTrue(IsEqual(GetValue(entry, "contract_code"), GetValue(market, "id"))) {
					position = entry
					break
				}
			}
		} else {
			position = this.SafeValue(positions, 0)
		}
		var timestamp interface{} = this.SafeInteger(response, "ts")
		var parsed interface{} = this.ParsePosition(this.Extend(position, omitted))
		AddElementToObject(parsed, "timestamp", timestamp)
		AddElementToObject(parsed, "datetime", this.Iso8601(timestamp))

		ch <- parsed
		return nil

	}()
	return ch
}
func (this *HtxCore) ParseLedgerEntryType(typeVar interface{}) interface{} {
	var types interface{} = map[string]interface{}{
		"trade":         "trade",
		"etf":           "trade",
		"transact-fee":  "fee",
		"fee-deduction": "fee",
		"transfer":      "transfer",
		"credit":        "credit",
		"liquidation":   "trade",
		"interest":      "credit",
		"deposit":       "deposit",
		"withdraw":      "withdrawal",
		"withdraw-fee":  "fee",
		"exchange":      "exchange",
		"other-types":   "transfer",
		"rebate":        "rebate",
	}
	return this.SafeString(types, typeVar, typeVar)
}
func (this *HtxCore) ParseLedgerEntry(item interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "accountId": 10000001,
	//         "currency": "usdt",
	//         "transactAmt": 10.000000000000000000,
	//         "transactType": "transfer",
	//         "transferType": "margin-transfer-out",
	//         "transactId": 0,
	//         "transactTime": 1629882331066,
	//         "transferer": 28483123,
	//         "transferee": 13496526
	//     }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var currencyId interface{} = this.SafeString(item, "currency")
	var code interface{} = this.SafeCurrencyCode(currencyId, currency)
	currency = this.SafeCurrency(currencyId, currency)
	var id interface{} = this.SafeString(item, "transactId")
	var transferType interface{} = this.SafeString(item, "transferType")
	var timestamp interface{} = this.SafeInteger(item, "transactTime")
	var account interface{} = this.SafeString(item, "accountId")
	return this.SafeLedgerEntry(map[string]interface{}{
		"info":             item,
		"id":               id,
		"direction":        this.SafeString(item, "direction"),
		"account":          account,
		"referenceId":      id,
		"referenceAccount": account,
		"type":             this.ParseLedgerEntryType(transferType),
		"currency":         code,
		"amount":           this.SafeNumber(item, "transactAmt"),
		"timestamp":        timestamp,
		"datetime":         this.Iso8601(timestamp),
		"before":           nil,
		"after":            nil,
		"status":           nil,
		"fee":              nil,
	}, currency)
}

/**
 * @method
 * @name htx#fetchLedger
 * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
 * @see https://huobiapi.github.io/docs/spot/v1/en/#get-account-history
 * @param {string} [code] unified currency code, default is undefined
 * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
 * @param {int} [limit] max number of ledger entries to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch entries for
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/?id=ledger-entry-structure}
 */
func (this *HtxCore) FetchLedger(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes82738 := (<-this.LoadMarkets())
		PanicOnError(retRes82738)
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchLedger", "paginate")
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {

			retRes827719 := (<-this.FetchPaginatedCallDynamic("fetchLedger", code, since, limit, params, 500))
			PanicOnError(retRes827719)
			ch <- retRes827719
			return nil
		}

		accountId := (<-this.FetchAccountIdByType("spot", nil, nil, params))
		PanicOnError(accountId)
		var request interface{} = map[string]interface{}{
			"accountId": accountId,
		}
		var currency interface{} = nil
		if IsTrue(!IsEqual(code, nil)) {
			currency = this.Currency(code)
			AddElementToObject(request, "currency", GetValue(currency, "id"))
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit) // max 500
		}
		requestparamsVariable := this.HandleUntilOption("endTime", request, params)
		request = GetValue(requestparamsVariable, 0)
		params = GetValue(requestparamsVariable, 1)

		response := (<-this.SpotPrivateGetV2AccountLedger(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": 200,
		//         "message": "success",
		//         "data": [
		//             {
		//                 "accountId": 10000001,
		//                 "currency": "usdt",
		//                 "transactAmt": 10.000000000000000000,
		//                 "transactType": "transfer",
		//                 "transferType": "margin-transfer-out",
		//                 "transactId": 0,
		//                 "transactTime": 1629882331066,
		//                 "transferer": 28483123,
		//                 "transferee": 13496526
		//             },
		//             {
		//                 "accountId": 10000001,
		//                 "currency": "usdt",
		//                 "transactAmt": -10.000000000000000000,
		//                 "transactType": "transfer",
		//                 "transferType": "margin-transfer-in",
		//                 "transactId": 0,
		//                 "transactTime": 1629882096562,
		//                 "transferer": 13496526,
		//                 "transferee": 28483123
		//             }
		//         ],
		//         "nextId": 1624316679,
		//         "ok": true
		//     }
		//
		var data interface{} = this.SafeValue(response, "data", []interface{}{})

		ch <- this.ParseLedger(data, currency, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name htx#fetchLeverageTiers
 * @description retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [leverage tiers structures]{@link https://docs.ccxt.com/?id=leverage-tiers-structure}, indexed by market symbols
 */
func (this *HtxCore) FetchLeverageTiers(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes83488 := (<-this.LoadMarkets())
		PanicOnError(retRes83488)

		response := (<-this.ContractPublicGetLinearSwapApiV1SwapAdjustfactor(params))
		PanicOnError(response)
		//
		//    {
		//        "status": "ok",
		//        "data": [
		//            {
		//                "symbol": "MANA",
		//                "contract_code": "MANA-USDT",
		//                "margin_mode": "isolated",
		//                "trade_partition": "USDT",
		//                "list": [
		//                    {
		//                        "lever_rate": 75,
		//                        "ladders": [
		//                            {
		//                                "ladder": 0,
		//                                "min_size": 0,
		//                                "max_size": 999,
		//                                "adjust_factor": 0.7
		//                            },
		//                            ...
		//                        ]
		//                    }
		//                    ...
		//                ]
		//            },
		//            ...
		//        ]
		//    }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseLeverageTiers(data, symbols, "contract_code")
		return nil

	}()
	return ch
}
func (this *HtxCore) ParseMarketLeverageTiers(info interface{}, optionalArgs ...interface{}) interface{} {
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var currencyId interface{} = this.SafeString(info, "trade_partition")
	var marketId interface{} = this.SafeString(info, "contract_code")
	var tiers interface{} = []interface{}{}
	var brackets interface{} = this.SafeList(info, "list", []interface{}{})
	for i := 0; IsLessThan(i, GetArrayLength(brackets)); i++ {
		var item interface{} = GetValue(brackets, i)
		var leverage interface{} = this.SafeString(item, "lever_rate")
		var ladders interface{} = this.SafeList(item, "ladders", []interface{}{})
		for k := 0; IsLessThan(k, GetArrayLength(ladders)); k++ {
			var bracket interface{} = GetValue(ladders, k)
			var adjustFactor interface{} = this.SafeString(bracket, "adjust_factor")
			AppendToArray(&tiers, map[string]interface{}{
				"tier":                  this.SafeInteger(bracket, "ladder"),
				"symbol":                this.SafeSymbol(marketId, market, nil, "swap"),
				"currency":              this.SafeCurrencyCode(currencyId),
				"minNotional":           this.SafeNumber(bracket, "min_size"),
				"maxNotional":           this.SafeNumber(bracket, "max_size"),
				"maintenanceMarginRate": this.ParseNumber(Precise.StringDiv(adjustFactor, leverage)),
				"maxLeverage":           this.ParseNumber(leverage),
				"info":                  bracket,
			})
		}
	}
	return tiers
}

/**
 * @method
 * @name htx#fetchOpenInterestHistory
 * @description Retrieves the open interest history of a currency
 * @see https://huobiapi.github.io/docs/dm/v1/en/#query-information-on-open-interest
 * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#query-information-on-open-interest
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#general-query-information-on-open-interest
 * @param {string} symbol Unified CCXT market symbol
 * @param {string} timeframe '1h', '4h', '12h', or '1d'
 * @param {int} [since] Not used by huobi api, but response parsed by CCXT
 * @param {int} [limit] Default48Data Range [1,200]
 * @param {object} [params] Exchange specific parameters
 * @param {int} [params.amount_type] *required* Open interest unit. 1-cont2-cryptocurrency
 * @param {int} [params.pair] eg BTC-USDT *Only for USDT-M*
 * @returns {object} an array of [open interest structures]{@link https://docs.ccxt.com/?id=open-interest-structure}
 */
func (this *HtxCore) FetchOpenInterestHistory(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		timeframe := GetArg(optionalArgs, 0, "1h")
		_ = timeframe
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		if IsTrue(IsTrue(IsTrue(IsTrue(!IsEqual(timeframe, "1h")) && IsTrue(!IsEqual(timeframe, "4h"))) && IsTrue(!IsEqual(timeframe, "12h"))) && IsTrue(!IsEqual(timeframe, "1d"))) {
			panic(BadRequest(Add(this.Id, " fetchOpenInterestHistory cannot only use the 1h, 4h, 12h and 1d timeframe")))
		}

		retRes84308 := (<-this.LoadMarkets())
		PanicOnError(retRes84308)
		var timeframes interface{} = map[string]interface{}{
			"1h":  "60min",
			"4h":  "4hour",
			"12h": "12hour",
			"1d":  "1day",
		}
		var market interface{} = this.Market(symbol)
		var amountType interface{} = this.SafeInteger2(params, "amount_type", "amountType", 2)
		var request interface{} = map[string]interface{}{
			"period":      GetValue(timeframes, timeframe),
			"amount_type": amountType,
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "size", limit)
		}
		var response interface{} = nil
		if IsTrue(GetValue(market, "future")) {
			AddElementToObject(request, "contract_type", this.SafeString(GetValue(market, "info"), "contract_type"))
			AddElementToObject(request, "symbol", GetValue(market, "baseId")) // currency code on coin-m futures
			// coin-m futures

			response = (<-this.ContractPublicGetApiV1ContractHisOpenInterest(this.Extend(request, params)))
			PanicOnError(response)
		} else if IsTrue(GetValue(market, "linear")) {
			AddElementToObject(request, "contract_type", "swap")
			AddElementToObject(request, "contract_code", GetValue(market, "id"))
			AddElementToObject(request, "contract_code", GetValue(market, "id"))
			// USDT-M

			response = (<-this.ContractPublicGetLinearSwapApiV1SwapHisOpenInterest(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			AddElementToObject(request, "contract_code", GetValue(market, "id"))
			// coin-m swaps

			response = (<-this.ContractPublicGetSwapApiV1SwapHisOpenInterest(this.Extend(request, params)))
			PanicOnError(response)
		}
		//
		//  contractPublicGetlinearSwapApiV1SwapHisOpenInterest
		//    {
		//        "status": "ok",
		//        "data": {
		//            "symbol": "BTC",
		//            "tick": [
		//                {
		//                    "volume": "4385.4350000000000000",
		//                    "amount_type": "2",
		//                    "ts": "1648220400000",
		//                    "value": "194059884.1850000000000000"
		//                },
		//                ...
		//            ],
		//            "contract_code": "BTC-USDT",
		//            "business_type": "swap",
		//            "pair": "BTC-USDT",
		//            "contract_type": "swap",
		//            "trade_partition": "USDT"
		//        },
		//        "ts": "1648223733007"
		//    }
		//
		//  contractPublicGetSwapApiV1SwapHisOpenInterest
		//    {
		//        "status": "ok",
		//        "data": {
		//            "symbol": "CRV",
		//            "tick": [
		//                {
		//                    "volume": 19174.0000000000000000,
		//                    "amount_type": 1,
		//                    "ts": 1648224000000
		//                },
		//                ...
		//            ],
		//            "contract_code": "CRV-USD"
		//        },
		//        "ts": 1648226554260
		//    }
		//
		//  contractPublicGetApiV1ContractHisOpenInterest
		//    {
		//         "status": "ok",
		//         "data": {
		//             "symbol": "BTC",
		//             "contract_type": "this_week",
		//             "tick": [
		//                {
		//                     "volume": "48419.0000000000000000",
		//                     "amount_type": 1,
		//                     "ts": 1648224000000
		//                },
		//                ...
		//            ]
		//        },
		//        "ts": 1648227062944
		//    }
		//
		var data interface{} = this.SafeValue(response, "data")
		var tick interface{} = this.SafeList(data, "tick")

		ch <- this.ParseOpenInterestsHistory(tick, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name htx#fetchOpenInterests
 * @description Retrieves the open interest for a list of symbols
 * @see https://huobiapi.github.io/docs/dm/v1/en/#get-contract-open-interest-information
 * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#get-swap-open-interest-information
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#general-get-swap-open-interest-information
 * @param {string[]} [symbols] a list of unified CCXT market symbols
 * @param {object} [params] exchange specific parameters
 * @returns {object[]} a list of [open interest structures]{@link https://docs.ccxt.com/?id=open-interest-structure}
 */
func (this *HtxCore) FetchOpenInterests(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes85408 := (<-this.LoadMarkets())
		PanicOnError(retRes85408)
		symbols = this.MarketSymbols(symbols)
		var market interface{} = nil
		if IsTrue(!IsEqual(symbols, nil)) {
			var symbolsLength interface{} = GetArrayLength(symbols)
			if IsTrue(IsGreaterThan(symbolsLength, 0)) {
				var first interface{} = this.SafeString(symbols, 0)
				market = this.Market(first)
			}
		}
		var request interface{} = map[string]interface{}{}
		var subType interface{} = nil
		subTypeparamsVariable := this.HandleSubTypeAndParams("fetchPositions", market, params, "linear")
		subType = GetValue(subTypeparamsVariable, 0)
		params = GetValue(subTypeparamsVariable, 1)
		var marketType interface{} = nil
		marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchPositions", market, params)
		marketType = GetValue(marketTypeparamsVariable, 0)
		params = GetValue(marketTypeparamsVariable, 1)
		var response interface{} = nil
		if IsTrue(IsEqual(marketType, "future")) {

			response = (<-this.ContractPublicGetApiV1ContractOpenInterest(this.Extend(request, params)))
			PanicOnError(response)
		} else if IsTrue(IsEqual(subType, "inverse")) {

			response = (<-this.ContractPublicGetSwapApiV1SwapOpenInterest(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			AddElementToObject(request, "contract_type", "swap")

			response = (<-this.ContractPublicGetLinearSwapApiV1SwapOpenInterest(this.Extend(request, params)))
			PanicOnError(response)
		}
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseOpenInterests(data, symbols)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name htx#fetchOpenInterest
 * @description Retrieves the open interest of a currency
 * @see https://huobiapi.github.io/docs/dm/v1/en/#get-contract-open-interest-information
 * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#get-swap-open-interest-information
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#general-get-swap-open-interest-information
 * @param {string} symbol Unified CCXT market symbol
 * @param {object} [params] exchange specific parameters
 * @returns {object} an open interest structure{@link https://docs.ccxt.com/?id=open-interest-structure}
 */
func (this *HtxCore) FetchOpenInterest(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes86378 := (<-this.LoadMarkets())
		PanicOnError(retRes86378)
		var market interface{} = this.Market(symbol)
		if !IsTrue(GetValue(market, "contract")) {
			panic(BadRequest(Add(this.Id, " fetchOpenInterest() supports contract markets only")))
		}
		if IsTrue(GetValue(market, "option")) {
			panic(NotSupported(Add(this.Id, " fetchOpenInterest() does not currently support option markets")))
		}
		var request interface{} = map[string]interface{}{
			"contract_code": GetValue(market, "id"),
		}
		var response interface{} = nil
		if IsTrue(GetValue(market, "future")) {
			AddElementToObject(request, "contract_type", this.SafeString(GetValue(market, "info"), "contract_type"))
			AddElementToObject(request, "symbol", GetValue(market, "baseId"))
			// COIN-M futures

			response = (<-this.ContractPublicGetApiV1ContractOpenInterest(this.Extend(request, params)))
			PanicOnError(response)
		} else if IsTrue(GetValue(market, "linear")) {
			AddElementToObject(request, "contract_type", "swap")
			// USDT-M

			response = (<-this.ContractPublicGetLinearSwapApiV1SwapOpenInterest(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			// COIN-M swaps

			response = (<-this.ContractPublicGetSwapApiV1SwapOpenInterest(this.Extend(request, params)))
			PanicOnError(response)
		}
		//
		// USDT-M contractPublicGetLinearSwapApiV1SwapOpenInterest
		//
		//     {
		//         "status": "ok",
		//         "data": [
		//             {
		//                 "volume": 7192610.000000000000000000,
		//                 "amount": 7192.610000000000000000,
		//                 "symbol": "BTC",
		//                 "value": 134654290.332000000000000000,
		//                 "contract_code": "BTC-USDT",
		//                 "trade_amount": 70692.804,
		//                 "trade_volume": 70692804,
		//                 "trade_turnover": 1379302592.9518,
		//                 "business_type": "swap",
		//                 "pair": "BTC-USDT",
		//                 "contract_type": "swap",
		//                 "trade_partition": "USDT"
		//             }
		//         ],
		//         "ts": 1664336503144
		//     }
		//
		// COIN-M Swap contractPublicGetSwapApiV1SwapOpenInterest
		//
		//     {
		//         "status": "ok",
		//         "data": [
		//             {
		//                 "volume": 518018.000000000000000000,
		//                 "amount": 2769.675777407074725180,
		//                 "symbol": "BTC",
		//                 "contract_code": "BTC-USD",
		//                 "trade_amount": 9544.4032080046491323463688602729806842458,
		//                 "trade_volume": 1848448,
		//                 "trade_turnover": 184844800.000000000000000000
		//             }
		//         ],
		//         "ts": 1664337226028
		//     }
		//
		// COIN-M Futures contractPublicGetApiV1ContractOpenInterest
		//
		//     {
		//         "status": "ok",
		//         "data": [
		//             {
		//                 "volume": 118850.000000000000000000,
		//                 "amount": 635.502025211544374189,
		//                 "symbol": "BTC",
		//                 "contract_type": "this_week",
		//                 "contract_code": "BTC220930",
		//                 "trade_amount": 1470.9400749347598691119206024033947897351,
		//                 "trade_volume": 286286,
		//                 "trade_turnover": 28628600.000000000000000000
		//             }
		//         ],
		//         "ts": 1664337928805
		//     }
		//
		var data interface{} = this.SafeValue(response, "data", []interface{}{})
		var openInterest interface{} = this.ParseOpenInterest(GetValue(data, 0), market)
		var timestamp interface{} = this.SafeInteger(response, "ts")
		AddElementToObject(openInterest, "timestamp", timestamp)
		AddElementToObject(openInterest, "datetime", this.Iso8601(timestamp))

		ch <- openInterest
		return nil

	}()
	return ch
}
func (this *HtxCore) ParseOpenInterest(interest interface{}, optionalArgs ...interface{}) interface{} {
	//
	// fetchOpenInterestHistory
	//
	//    {
	//        "volume": "4385.4350000000000000",
	//        "amount_type": "2",
	//        "ts": "1648220400000",
	//        "value": "194059884.1850000000000000"
	//    }
	//
	// fetchOpenInterest: USDT-M
	//
	//     {
	//         "volume": 7192610.000000000000000000,
	//         "amount": 7192.610000000000000000,
	//         "symbol": "BTC",
	//         "value": 134654290.332000000000000000,
	//         "contract_code": "BTC-USDT",
	//         "trade_amount": 70692.804,
	//         "trade_volume": 70692804,
	//         "trade_turnover": 1379302592.9518,
	//         "business_type": "swap",
	//         "pair": "BTC-USDT",
	//         "contract_type": "swap",
	//         "trade_partition": "USDT"
	//     }
	//
	// fetchOpenInterest: COIN-M Swap
	//
	//     {
	//         "volume": 518018.000000000000000000,
	//         "amount": 2769.675777407074725180,
	//         "symbol": "BTC",
	//         "contract_code": "BTC-USD",
	//         "trade_amount": 9544.4032080046491323463688602729806842458,
	//         "trade_volume": 1848448,
	//         "trade_turnover": 184844800.000000000000000000
	//     }
	//
	// fetchOpenInterest: COIN-M Futures
	//
	//     {
	//         "volume": 118850.000000000000000000,
	//         "amount": 635.502025211544374189,
	//         "symbol": "BTC",
	//         "contract_type": "this_week",
	//         "contract_code": "BTC220930",
	//         "trade_amount": 1470.9400749347598691119206024033947897351,
	//         "trade_volume": 286286,
	//         "trade_turnover": 28628600.000000000000000000
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var timestamp interface{} = this.SafeInteger(interest, "ts")
	var amount interface{} = this.SafeNumber(interest, "volume")
	var value interface{} = this.SafeNumber(interest, "value")
	var marketId interface{} = this.SafeString(interest, "contract_code")
	return this.SafeOpenInterest(map[string]interface{}{
		"symbol":             this.SafeSymbol(marketId, market),
		"baseVolume":         amount,
		"quoteVolume":        value,
		"openInterestAmount": amount,
		"openInterestValue":  value,
		"timestamp":          timestamp,
		"datetime":           this.Iso8601(timestamp),
		"info":               interest,
	}, market)
}

/**
 * @method
 * @name htx#borrowIsolatedMargin
 * @description create a loan to borrow margin
 * @see https://huobiapi.github.io/docs/spot/v1/en/#request-a-margin-loan-isolated
 * @see https://huobiapi.github.io/docs/spot/v1/en/#request-a-margin-loan-cross
 * @param {string} symbol unified market symbol, required for isolated margin
 * @param {string} code unified currency code of the currency to borrow
 * @param {float} amount the amount to borrow
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/?id=margin-loan-structure}
 */
func (this *HtxCore) BorrowIsolatedMargin(symbol interface{}, code interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes88138 := (<-this.LoadMarkets())
		PanicOnError(retRes88138)
		var currency interface{} = this.Currency(code)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"currency": GetValue(currency, "id"),
			"amount":   this.CurrencyToPrecision(code, amount),
			"symbol":   GetValue(market, "id"),
		}

		response := (<-this.PrivatePostMarginOrders(this.Extend(request, params)))
		PanicOnError(response)
		//
		// Isolated
		//
		//     {
		//         "data": 1000
		//     }
		//
		var transaction interface{} = this.ParseMarginLoan(response, currency)

		ch <- this.Extend(transaction, map[string]interface{}{
			"amount": amount,
			"symbol": symbol,
		})
		return nil

	}()
	return ch
}

/**
 * @method
 * @name htx#borrowCrossMargin
 * @description create a loan to borrow margin
 * @see https://huobiapi.github.io/docs/spot/v1/en/#request-a-margin-loan-isolated
 * @see https://huobiapi.github.io/docs/spot/v1/en/#request-a-margin-loan-cross
 * @param {string} code unified currency code of the currency to borrow
 * @param {float} amount the amount to borrow
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/?id=margin-loan-structure}
 */
func (this *HtxCore) BorrowCrossMargin(code interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes88488 := (<-this.LoadMarkets())
		PanicOnError(retRes88488)
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"currency": GetValue(currency, "id"),
			"amount":   this.CurrencyToPrecision(code, amount),
		}

		response := (<-this.PrivatePostCrossMarginOrders(this.Extend(request, params)))
		PanicOnError(response)
		//
		// Cross
		//
		//     {
		//         "status": "ok",
		//         "data": null
		//     }
		//
		var transaction interface{} = this.ParseMarginLoan(response, currency)

		ch <- this.Extend(transaction, map[string]interface{}{
			"amount": amount,
		})
		return nil

	}()
	return ch
}

/**
 * @method
 * @name htx#repayIsolatedMargin
 * @description repay borrowed margin and interest
 * @see https://huobiapi.github.io/docs/spot/v1/en/#repay-margin-loan-cross-isolated
 * @param {string} symbol unified market symbol
 * @param {string} code unified currency code of the currency to repay
 * @param {float} amount the amount to repay
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/?id=margin-loan-structure}
 */
func (this *HtxCore) RepayIsolatedMargin(symbol interface{}, code interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes88818 := (<-this.LoadMarkets())
		PanicOnError(retRes88818)
		var currency interface{} = this.Currency(code)

		accountId := (<-this.FetchAccountIdByType("spot", "isolated", symbol, params))
		PanicOnError(accountId)
		var request interface{} = map[string]interface{}{
			"currency":  GetValue(currency, "id"),
			"amount":    this.CurrencyToPrecision(code, amount),
			"accountId": accountId,
		}

		response := (<-this.V2PrivatePostAccountRepayment(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code":200,
		//         "data": [
		//             {
		//                 "repayId":1174424,
		//                 "repayTime":1600747722018
		//             }
		//         ]
		//     }
		//
		var data interface{} = this.SafeValue(response, "Data", []interface{}{})
		var loan interface{} = this.SafeValue(data, 0)
		var transaction interface{} = this.ParseMarginLoan(loan, currency)

		ch <- this.Extend(transaction, map[string]interface{}{
			"amount": amount,
			"symbol": symbol,
		})
		return nil

	}()
	return ch
}

/**
 * @method
 * @name htx#repayCrossMargin
 * @description repay borrowed margin and interest
 * @see https://huobiapi.github.io/docs/spot/v1/en/#repay-margin-loan-cross-isolated
 * @param {string} code unified currency code of the currency to repay
 * @param {float} amount the amount to repay
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/?id=margin-loan-structure}
 */
func (this *HtxCore) RepayCrossMargin(code interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes89218 := (<-this.LoadMarkets())
		PanicOnError(retRes89218)
		var currency interface{} = this.Currency(code)

		accountId := (<-this.FetchAccountIdByType("spot", "cross", nil, params))
		PanicOnError(accountId)
		var request interface{} = map[string]interface{}{
			"currency":  GetValue(currency, "id"),
			"amount":    this.CurrencyToPrecision(code, amount),
			"accountId": accountId,
		}

		response := (<-this.V2PrivatePostAccountRepayment(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code":200,
		//         "data": [
		//             {
		//                 "repayId":1174424,
		//                 "repayTime":1600747722018
		//             }
		//         ]
		//     }
		//
		var data interface{} = this.SafeValue(response, "Data", []interface{}{})
		var loan interface{} = this.SafeValue(data, 0)
		var transaction interface{} = this.ParseMarginLoan(loan, currency)

		ch <- this.Extend(transaction, map[string]interface{}{
			"amount": amount,
		})
		return nil

	}()
	return ch
}
func (this *HtxCore) ParseMarginLoan(info interface{}, optionalArgs ...interface{}) interface{} {
	//
	// borrowMargin cross
	//
	//     {
	//         "status": "ok",
	//         "data": null
	//     }
	//
	// borrowMargin isolated
	//
	//     {
	//         "data": 1000
	//     }
	//
	// repayMargin
	//
	//     {
	//         "repayId":1174424,
	//         "repayTime":1600747722018
	//     }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var timestamp interface{} = this.SafeInteger(info, "repayTime")
	return map[string]interface{}{
		"id":        this.SafeString2(info, "repayId", "data"),
		"currency":  this.SafeCurrencyCode(nil, currency),
		"amount":    nil,
		"symbol":    nil,
		"timestamp": timestamp,
		"datetime":  this.Iso8601(timestamp),
		"info":      info,
	}
}

/**
 * @method
 * @name htx#fetchSettlementHistory
 * @description Fetches historical settlement records
 * @see https://huobiapi.github.io/docs/dm/v1/en/#query-historical-settlement-records-of-the-platform-interface
 * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#query-historical-settlement-records-of-the-platform-interface
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#general-query-historical-settlement-records-of-the-platform-interface
 * @param {string} symbol unified symbol of the market to fetch the settlement history for
 * @param {int} [since] timestamp in ms, value range = current time - 90 daysdefault = current time - 90 days
 * @param {int} [limit] page items, default 20, shall not exceed 50
 * @param {object} [params] exchange specific params
 * @param {int} [params.until] timestamp in ms, value range = start_time -> current timedefault = current time
 * @param {int} [params.page_index] page index, default page 1 if not filled
 * @param {int} [params.code] unified currency code, can be used when symbol is undefined
 * @returns {object[]} a list of [settlement history objects]{@link https://docs.ccxt.com/?id=settlement-history-structure}
 */
func (this *HtxCore) FetchSettlementHistory(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchSettlementHistory() requires a symbol argument")))
		}
		var until interface{} = this.SafeInteger(params, "until")
		params = this.Omit(params, []interface{}{"until"})
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{}
		if IsTrue(GetValue(market, "future")) {
			AddElementToObject(request, "symbol", GetValue(market, "baseId"))
		} else {
			AddElementToObject(request, "contract_code", GetValue(market, "id"))
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "start_at", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "page_size", limit)
		}
		if IsTrue(!IsEqual(until, nil)) {
			AddElementToObject(request, "end_at", until)
		}
		var response interface{} = nil
		if IsTrue(GetValue(market, "swap")) {
			if IsTrue(GetValue(market, "linear")) {

				response = (<-this.ContractPublicGetLinearSwapApiV1SwapSettlementRecords(this.Extend(request, params)))
				PanicOnError(response)
			} else {

				response = (<-this.ContractPublicGetSwapApiV1SwapSettlementRecords(this.Extend(request, params)))
				PanicOnError(response)
			}
		} else {

			response = (<-this.ContractPublicGetApiV1ContractSettlementRecords(this.Extend(request, params)))
			PanicOnError(response)
		}
		//
		// linear swap, coin-m swap
		//
		//    {
		//        "status": "ok",
		//        "data": {
		//        "total_page": 14,
		//        "current_page": 1,
		//        "total_size": 270,
		//        "settlement_record": [
		//            {
		//                "symbol": "ADA",
		//                "contract_code": "ADA-USDT",
		//                "settlement_time": 1652313600000,
		//                "clawback_ratio": 0E-18,
		//                "settlement_price": 0.512303000000000000,
		//                "settlement_type": "settlement",
		//                "business_type": "swap",
		//                "pair": "ADA-USDT",
		//                "trade_partition": "USDT"
		//            },
		//            ...
		//        ],
		//        "ts": 1652338693256
		//    }
		//
		// coin-m future
		//
		//    {
		//        "status": "ok",
		//        "data": {
		//            "total_page": 5,
		//            "current_page": 1,
		//            "total_size": 90,
		//            "settlement_record": [
		//                {
		//                    "symbol": "FIL",
		//                    "settlement_time": 1652342400000,
		//                    "clawback_ratio": 0E-18,
		//                    "list": [
		//                        {
		//                            "contract_code": "FIL220513",
		//                            "settlement_price": 7.016000000000000000,
		//                            "settlement_type": "settlement"
		//                        },
		//                        ...
		//                    ]
		//                },
		//            ]
		//        }
		//    }
		//
		var data interface{} = this.SafeValue(response, "data")
		var settlementRecord interface{} = this.SafeValue(data, "settlement_record")
		var settlements interface{} = this.ParseSettlements(settlementRecord, market)

		ch <- this.SortBy(settlements, "timestamp")
		return nil

	}()
	return ch
}

/**
 * @method
 * @name htx#fetchDepositWithdrawFees
 * @description fetch deposit and withdraw fees
 * @see https://huobiapi.github.io/docs/spot/v1/en/#get-all-supported-currencies-v2
 * @param {string[]|undefined} codes list of unified currency codes
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [fees structures]{@link https://docs.ccxt.com/?id=fee-structure}
 */
func (this *HtxCore) FetchDepositWithdrawFees(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		codes := GetArg(optionalArgs, 0, nil)
		_ = codes
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes90998 := (<-this.LoadMarkets())
		PanicOnError(retRes90998)

		response := (<-this.SpotPublicGetV2ReferenceCurrencies(params))
		PanicOnError(response)
		//
		//    {
		//        "code": 200,
		//        "data": [
		//            {
		//                "currency": "sxp",
		//                "assetType": "1",
		//                "chains": [
		//                    {
		//                        "chain": "sxp",
		//                        "displayName": "ERC20",
		//                        "baseChain": "ETH",
		//                        "baseChainProtocol": "ERC20",
		//                        "isDynamic": true,
		//                        "numOfConfirmations": "12",
		//                        "numOfFastConfirmations": "12",
		//                        "depositStatus": "allowed",
		//                        "minDepositAmt": "0.23",
		//                        "withdrawStatus": "allowed",
		//                        "minWithdrawAmt": "0.23",
		//                        "withdrawPrecision": "8",
		//                        "maxWithdrawAmt": "227000.000000000000000000",
		//                        "withdrawQuotaPerDay": "227000.000000000000000000",
		//                        "withdrawQuotaPerYear": null,
		//                        "withdrawQuotaTotal": null,
		//                        "withdrawFeeType": "fixed",
		//                        "transactFeeWithdraw": "11.1653",
		//                        "addrWithTag": false,
		//                        "addrDepositTag": false
		//                    }
		//                ],
		//                "instStatus": "normal"
		//            }
		//        ]
		//    }
		//
		var data interface{} = this.SafeList(response, "data")

		ch <- this.ParseDepositWithdrawFees(data, codes, "currency")
		return nil

	}()
	return ch
}
func (this *HtxCore) ParseDepositWithdrawFee(fee interface{}, optionalArgs ...interface{}) interface{} {
	//
	//            {
	//              "currency": "sxp",
	//              "assetType": "1",
	//              "chains": [
	//                  {
	//                      "chain": "sxp",
	//                      "displayName": "ERC20",
	//                      "baseChain": "ETH",
	//                      "baseChainProtocol": "ERC20",
	//                      "isDynamic": true,
	//                      "numOfConfirmations": "12",
	//                      "numOfFastConfirmations": "12",
	//                      "depositStatus": "allowed",
	//                      "minDepositAmt": "0.23",
	//                      "withdrawStatus": "allowed",
	//                      "minWithdrawAmt": "0.23",
	//                      "withdrawPrecision": "8",
	//                      "maxWithdrawAmt": "227000.000000000000000000",
	//                      "withdrawQuotaPerDay": "227000.000000000000000000",
	//                      "withdrawQuotaPerYear": null,
	//                      "withdrawQuotaTotal": null,
	//                      "withdrawFeeType": "fixed",
	//                      "transactFeeWithdraw": "11.1653",
	//                      "addrWithTag": false,
	//                      "addrDepositTag": false
	//                  }
	//              ],
	//              "instStatus": "normal"
	//          }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var chains interface{} = this.SafeValue(fee, "chains", []interface{}{})
	var result interface{} = this.DepositWithdrawFee(fee)
	for j := 0; IsLessThan(j, GetArrayLength(chains)); j++ {
		var chainEntry interface{} = GetValue(chains, j)
		var networkId interface{} = this.SafeString(chainEntry, "chain")
		var withdrawFeeType interface{} = this.SafeString(chainEntry, "withdrawFeeType")
		var networkCode interface{} = this.NetworkIdToCode(networkId)
		var withdrawFee interface{} = nil
		var withdrawResult interface{} = nil
		if IsTrue(IsEqual(withdrawFeeType, "fixed")) {
			withdrawFee = this.SafeNumber(chainEntry, "transactFeeWithdraw")
			withdrawResult = map[string]interface{}{
				"fee":        withdrawFee,
				"percentage": false,
			}
		} else {
			withdrawFee = this.SafeNumber(chainEntry, "transactFeeRateWithdraw")
			withdrawResult = map[string]interface{}{
				"fee":        withdrawFee,
				"percentage": true,
			}
		}
		AddElementToObject(GetValue(result, "networks"), networkCode, map[string]interface{}{
			"withdraw": withdrawResult,
			"deposit": map[string]interface{}{
				"fee":        nil,
				"percentage": nil,
			},
		})
		result = this.AssignDefaultDepositWithdrawFees(result, currency)
	}
	return result
}
func (this *HtxCore) ParseSettlements(settlements interface{}, market interface{}) interface{} {
	//
	// linear swap, coin-m swap, fetchSettlementHistory
	//
	//    [
	//        {
	//            "symbol": "ADA",
	//            "contract_code": "ADA-USDT",
	//            "settlement_time": 1652313600000,
	//            "clawback_ratio": 0E-18,
	//            "settlement_price": 0.512303000000000000,
	//            "settlement_type": "settlement",
	//            "business_type": "swap",
	//            "pair": "ADA-USDT",
	//            "trade_partition": "USDT"
	//        },
	//        ...
	//    ]
	//
	// coin-m future, fetchSettlementHistory
	//
	//    [
	//        {
	//            "symbol": "FIL",
	//            "settlement_time": 1652342400000,
	//            "clawback_ratio": 0E-18,
	//            "list": [
	//                {
	//                    "contract_code": "FIL220513",
	//                    "settlement_price": 7.016000000000000000,
	//                    "settlement_type": "settlement"
	//                },
	//                ...
	//            ]
	//        },
	//    ]
	//
	var result interface{} = []interface{}{}
	for i := 0; IsLessThan(i, GetArrayLength(settlements)); i++ {
		var settlement interface{} = GetValue(settlements, i)
		var list interface{} = this.SafeValue(settlement, "list")
		if IsTrue(!IsEqual(list, nil)) {
			var timestamp interface{} = this.SafeInteger(settlement, "settlement_time")
			var timestampDetails interface{} = map[string]interface{}{
				"timestamp": timestamp,
				"datetime":  this.Iso8601(timestamp),
			}
			for j := 0; IsLessThan(j, GetArrayLength(list)); j++ {
				var item interface{} = GetValue(list, j)
				var parsedSettlement interface{} = this.ParseSettlement(item, market)
				AppendToArray(&result, this.Extend(parsedSettlement, timestampDetails))
			}
		} else {
			AppendToArray(&result, this.ParseSettlement(GetValue(settlements, i), market))
		}
	}
	return result
}
func (this *HtxCore) ParseSettlement(settlement interface{}, market interface{}) interface{} {
	//
	// linear swap, coin-m swap, fetchSettlementHistory
	//
	//    {
	//        "symbol": "ADA",
	//        "contract_code": "ADA-USDT",
	//        "settlement_time": 1652313600000,
	//        "clawback_ratio": 0E-18,
	//        "settlement_price": 0.512303000000000000,
	//        "settlement_type": "settlement",
	//        "business_type": "swap",
	//        "pair": "ADA-USDT",
	//        "trade_partition": "USDT"
	//    }
	//
	// coin-m future, fetchSettlementHistory
	//
	//    {
	//        "contract_code": "FIL220513",
	//        "settlement_price": 7.016000000000000000,
	//        "settlement_type": "settlement"
	//    }
	//
	var timestamp interface{} = this.SafeInteger(settlement, "settlement_time")
	var marketId interface{} = this.SafeString(settlement, "contract_code")
	return map[string]interface{}{
		"info":      settlement,
		"symbol":    this.SafeSymbol(marketId, market),
		"price":     this.SafeNumber(settlement, "settlement_price"),
		"timestamp": timestamp,
		"datetime":  this.Iso8601(timestamp),
	}
}

/**
 * @method
 * @name htx#fetchLiquidations
 * @description retrieves the public liquidations of a trading pair
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#general-query-liquidation-orders-new
 * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#query-liquidation-orders-new
 * @see https://huobiapi.github.io/docs/dm/v1/en/#query-liquidation-order-information-new
 * @param {string} symbol unified CCXT market symbol
 * @param {int} [since] the earliest time in ms to fetch liquidations for
 * @param {int} [limit] the maximum number of liquidation structures to retrieve
 * @param {object} [params] exchange specific parameters for the huobi api endpoint
 * @param {int} [params.until] timestamp in ms of the latest liquidation
 * @param {int} [params.tradeType] default 0, linear swap 0: all liquidated orders, 5: liquidated longs; 6: liquidated shorts, inverse swap and future 0: filled liquidated orders, 5: liquidated close orders, 6: liquidated open orders
 * @returns {object} an array of [liquidation structures]{@link https://docs.ccxt.com/?id=liquidation-structure}
 */
func (this *HtxCore) FetchLiquidations(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		since := GetArg(optionalArgs, 0, nil)
		_ = since
		limit := GetArg(optionalArgs, 1, nil)
		_ = limit
		params := GetArg(optionalArgs, 2, map[string]interface{}{})
		_ = params

		retRes93178 := (<-this.LoadMarkets())
		PanicOnError(retRes93178)
		var market interface{} = this.Market(symbol)
		var tradeType interface{} = this.SafeInteger(params, "trade_type", 0)
		var request interface{} = map[string]interface{}{
			"trade_type": tradeType,
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "start_time", since)
		}
		requestparamsVariable := this.HandleUntilOption("end_time", request, params)
		request = GetValue(requestparamsVariable, 0)
		params = GetValue(requestparamsVariable, 1)
		var response interface{} = nil
		if IsTrue(GetValue(market, "swap")) {
			AddElementToObject(request, "contract", GetValue(market, "id"))
			if IsTrue(GetValue(market, "linear")) {

				response = (<-this.ContractPublicGetLinearSwapApiV3SwapLiquidationOrders(this.Extend(request, params)))
				PanicOnError(response)
			} else {

				response = (<-this.ContractPublicGetSwapApiV3SwapLiquidationOrders(this.Extend(request, params)))
				PanicOnError(response)
			}
		} else if IsTrue(GetValue(market, "future")) {
			AddElementToObject(request, "symbol", GetValue(market, "id"))

			response = (<-this.ContractPublicGetApiV3ContractLiquidationOrders(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			panic(NotSupported(Add(Add(Add(this.Id, " fetchLiquidations() does not support "), GetValue(market, "type")), " orders")))
		}
		//
		//     {
		//         "code": 200,
		//         "msg": "",
		//         "data": [
		//             {
		//                 "query_id": 452057,
		//                 "contract_code": "BTC-USDT-211210",
		//                 "symbol": "USDT",
		//                 "direction": "sell",
		//                 "offset": "close",
		//                 "volume": 479.000000000000000000,
		//                 "price": 51441.700000000000000000,
		//                 "created_at": 1638593647864,
		//                 "amount": 0.479000000000000000,
		//                 "trade_turnover": 24640.574300000000000000,
		//                 "business_type": "futures",
		//                 "pair": "BTC-USDT"
		//             }
		//         ],
		//         "ts": 1604312615051
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseLiquidations(data, market, since, limit)
		return nil

	}()
	return ch
}
func (this *HtxCore) ParseLiquidation(liquidation interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "query_id": 452057,
	//         "contract_code": "BTC-USDT-211210",
	//         "symbol": "USDT",
	//         "direction": "sell",
	//         "offset": "close",
	//         "volume": 479.000000000000000000,
	//         "price": 51441.700000000000000000,
	//         "created_at": 1638593647864,
	//         "amount": 0.479000000000000000,
	//         "trade_turnover": 24640.574300000000000000,
	//         "business_type": "futures",
	//         "pair": "BTC-USDT"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(liquidation, "contract_code")
	var timestamp interface{} = this.SafeInteger(liquidation, "created_at")
	return this.SafeLiquidation(map[string]interface{}{
		"info":         liquidation,
		"symbol":       this.SafeSymbol(marketId, market),
		"contracts":    this.SafeNumber(liquidation, "volume"),
		"contractSize": this.SafeNumber(market, "contractSize"),
		"price":        this.SafeNumber(liquidation, "price"),
		"side":         this.SafeStringLower(liquidation, "direction"),
		"baseValue":    this.SafeNumber(liquidation, "amount"),
		"quoteValue":   this.SafeNumber(liquidation, "trade_turnover"),
		"timestamp":    timestamp,
		"datetime":     this.Iso8601(timestamp),
	})
}

/**
 * @method
 * @name htx#closePositions
 * @description closes open positions for a contract market, requires 'amount' in params, unlike other exchanges
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#isolated-place-lightning-close-order  // USDT-M (isolated)
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#cross-place-lightning-close-position  // USDT-M (cross)
 * @see https://huobiapi.github.io/docs/coin_margined_swap/v1/en/#place-lightning-close-order  // Coin-M swap
 * @see https://huobiapi.github.io/docs/dm/v1/en/#place-flash-close-order                      // Coin-M futures
 * @param {string} symbol unified CCXT market symbol
 * @param {string} side 'buy' or 'sell', the side of the closing order, opposite side as position side
 * @param {object} [params] extra parameters specific to the okx api endpoint
 * @param {string} [params.clientOrderId] client needs to provide unique API and have to maintain the API themselves afterwards. [1, 9223372036854775807]
 * @param {object} [params.marginMode] 'cross' or 'isolated', required for linear markets
 *
 * EXCHANGE SPECIFIC PARAMETERS
 * @param {number} [params.amount] order quantity
 * @param {string} [params.order_price_type] 'lightning' by default, 'lightning_fok': lightning fok type, 'lightning_ioc': lightning ioc type 'market' by default, 'market': market order type, 'lightning_fok': lightning
 * @returns {object} [an order structure]{@link https://docs.ccxt.com/?id=position-structure}
 */
func (this *HtxCore) ClosePosition(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		side := GetArg(optionalArgs, 0, nil)
		_ = side
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes94218 := (<-this.LoadMarkets())
		PanicOnError(retRes94218)
		var market interface{} = this.Market(symbol)
		var clientOrderId interface{} = this.SafeString(params, "clientOrderId")
		if !IsTrue(GetValue(market, "contract")) {
			panic(BadRequest(Add(this.Id, " closePosition() symbol supports contract markets only")))
		}
		this.CheckRequiredArgument("closePosition", side, "side")
		var request interface{} = map[string]interface{}{
			"contract_code": GetValue(market, "id"),
			"direction":     side,
		}
		if IsTrue(!IsEqual(clientOrderId, nil)) {
			AddElementToObject(request, "client_order_id", clientOrderId)
		}
		if IsTrue(GetValue(market, "inverse")) {
			var amount interface{} = this.SafeString2(params, "volume", "amount")
			if IsTrue(IsEqual(amount, nil)) {
				panic(ArgumentsRequired(Add(this.Id, " closePosition () requires an extra argument params[\"amount\"] for inverse markets")))
			}
			AddElementToObject(request, "volume", this.AmountToPrecision(symbol, amount))
		}
		params = this.Omit(params, []interface{}{"clientOrderId", "volume", "amount"})
		var response interface{} = nil
		if IsTrue(GetValue(market, "inverse")) {
			if IsTrue(GetValue(market, "swap")) {

				response = (<-this.ContractPrivatePostSwapApiV1SwapLightningClosePosition(this.Extend(request, params)))
				PanicOnError(response)
			} else {

				response = (<-this.ContractPrivatePostApiV1LightningClosePosition(this.Extend(request, params)))
				PanicOnError(response)
			}
		} else {
			var marginMode interface{} = nil
			marginModeparamsVariable := this.HandleMarginModeAndParams("closePosition", params, "cross")
			marginMode = GetValue(marginModeparamsVariable, 0)
			params = GetValue(marginModeparamsVariable, 1)
			if IsTrue(IsEqual(marginMode, "cross")) {

				response = (<-this.ContractPrivatePostLinearSwapApiV1SwapCrossLightningClosePosition(this.Extend(request, params)))
				PanicOnError(response)
			} else {

				response = (<-this.ContractPrivatePostLinearSwapApiV1SwapLightningClosePosition(this.Extend(request, params)))
				PanicOnError(response)
			}
		}

		ch <- this.ParseOrder(response, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name htx#setPositionMode
 * @description set hedged to true or false
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#isolated-switch-position-mode
 * @see https://huobiapi.github.io/docs/usdt_swap/v1/en/#cross-switch-position-mode
 * @param {bool} hedged set to true to for hedged mode, must be set separately for each market in isolated margin mode, only valid for linear markets
 * @param {string} [symbol] unified market symbol, required for isolated margin mode
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] "cross" (default) or "isolated"
 * @returns {object} response from the exchange
 */
func (this *HtxCore) SetPositionMode(hedged interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes94758 := (<-this.LoadMarkets())
		PanicOnError(retRes94758)
		var posMode interface{} = Ternary(IsTrue(hedged), "dual_side", "single_side")
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
		}
		var marginMode interface{} = nil
		marginModeparamsVariable := this.HandleMarginModeAndParams("setPositionMode", params, "cross")
		marginMode = GetValue(marginModeparamsVariable, 0)
		params = GetValue(marginModeparamsVariable, 1)
		var request interface{} = map[string]interface{}{
			"position_mode": posMode,
		}
		var response interface{} = nil
		if IsTrue(IsTrue((!IsEqual(market, nil))) && IsTrue((GetValue(market, "inverse")))) {
			panic(BadRequest(Add(this.Id, " setPositionMode can only be used for linear markets")))
		}
		if IsTrue(IsEqual(marginMode, "isolated")) {
			if IsTrue(IsEqual(symbol, nil)) {
				panic(ArgumentsRequired(Add(this.Id, " setPositionMode requires a symbol argument for isolated margin mode")))
			}
			AddElementToObject(request, "margin_account", GetValue(market, "id"))

			response = (<-this.ContractPrivatePostLinearSwapApiV1SwapSwitchPositionMode(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			AddElementToObject(request, "margin_account", "USDT")

			response = (<-this.ContractPrivatePostLinearSwapApiV1SwapCrossSwitchPositionMode(this.Extend(request, params)))
			PanicOnError(response)
		}

		ch <- response
		return nil

	}()
	return ch
}

func (this *HtxCore) Init(userConfig map[string]interface{}) {
	this.Exchange = Exchange{}
	this.Exchange.DerivedExchange = this
	this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
}
