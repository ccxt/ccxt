package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type coinmate struct {
    Exchange

}

func NewCoinmateCore() coinmate {
   p := coinmate{}
   setDefaults(&p)
   return p
}

func  (this *coinmate) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "coinmate",
        "name": "CoinMate",
        "countries": []interface{}{"GB", "CZ", "EU"},
        "rateLimit": 600,
        "has": map[string]interface{} {
            "CORS": true,
            "spot": true,
            "margin": false,
            "swap": false,
            "future": false,
            "option": false,
            "addMargin": false,
            "cancelOrder": true,
            "closeAllPositions": false,
            "closePosition": false,
            "createOrder": true,
            "createReduceOnlyOrder": false,
            "fetchBalance": true,
            "fetchBorrowRateHistories": false,
            "fetchBorrowRateHistory": false,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchDepositsWithdrawals": true,
            "fetchFundingHistory": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchIndexOHLCV": false,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchLeverage": false,
            "fetchLeverageTiers": false,
            "fetchMarginMode": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMyTrades": true,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrders": true,
            "fetchPosition": false,
            "fetchPositionHistory": false,
            "fetchPositionMode": false,
            "fetchPositions": false,
            "fetchPositionsForSymbol": false,
            "fetchPositionsHistory": false,
            "fetchPositionsRisk": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTrades": true,
            "fetchTradingFee": true,
            "fetchTradingFees": false,
            "fetchTransactions": "emulated",
            "reduceMargin": false,
            "setLeverage": false,
            "setMarginMode": false,
            "setPositionMode": false,
            "transfer": false,
            "withdraw": true,
        },
        "urls": map[string]interface{} {
            "logo": "https://user-images.githubusercontent.com/51840849/87460806-1c9f3f00-c616-11ea-8c46-a77018a8f3f4.jpg",
            "api": map[string]interface{} {
                "rest": "https://coinmate.io/api",
            },
            "www": "https://coinmate.io",
            "fees": "https://coinmate.io/fees",
            "doc": []interface{}{"https://coinmate.docs.apiary.io", "https://coinmate.io/developers"},
            "referral": "https://coinmate.io?referral=YTFkM1RsOWFObVpmY1ZjMGREQmpTRnBsWjJJNVp3PT0",
        },
        "requiredCredentials": map[string]interface{} {
            "apiKey": true,
            "secret": true,
            "uid": true,
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": []interface{}{"orderBook", "ticker", "tickerAll", "products", "transactions", "tradingPairs"},
            },
            "private": map[string]interface{} {
                "post": []interface{}{"balances", "bitcoinCashWithdrawal", "bitcoinCashDepositAddresses", "bitcoinDepositAddresses", "bitcoinWithdrawal", "bitcoinWithdrawalFees", "buyInstant", "buyLimit", "cancelOrder", "cancelOrderWithInfo", "createVoucher", "dashDepositAddresses", "dashWithdrawal", "ethereumWithdrawal", "ethereumDepositAddresses", "litecoinWithdrawal", "litecoinDepositAddresses", "openOrders", "order", "orderHistory", "orderById", "pusherAuth", "redeemVoucher", "replaceByBuyLimit", "replaceByBuyInstant", "replaceBySellLimit", "replaceBySellInstant", "rippleDepositAddresses", "rippleWithdrawal", "sellInstant", "sellLimit", "transactionHistory", "traderFees", "tradeHistory", "transfer", "transferHistory", "unconfirmedBitcoinDeposits", "unconfirmedBitcoinCashDeposits", "unconfirmedDashDeposits", "unconfirmedEthereumDeposits", "unconfirmedLitecoinDeposits", "unconfirmedRippleDeposits", "cancelAllOpenOrders", "withdrawVirtualCurrency", "virtualCurrencyDepositAddresses", "unconfirmedVirtualCurrencyDeposits", "adaWithdrawal", "adaDepositAddresses", "unconfirmedAdaDeposits", "solWithdrawal", "solDepositAddresses", "unconfirmedSolDeposits"},
            },
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "tierBased": true,
                "percentage": true,
                "taker": this.ParseNumber("0.006"),
                "maker": this.ParseNumber("0.004"),
                "tiers": map[string]interface{} {
                    "taker": []interface{}{[]interface{}{this.ParseNumber("0"), this.ParseNumber("0.006")}, []interface{}{this.ParseNumber("10000"), this.ParseNumber("0.003")}, []interface{}{this.ParseNumber("100000"), this.ParseNumber("0.0023")}, []interface{}{this.ParseNumber("250000"), this.ParseNumber("0.0021")}, []interface{}{this.ParseNumber("500000"), this.ParseNumber("0.0018")}, []interface{}{this.ParseNumber("1000000"), this.ParseNumber("0.0015")}, []interface{}{this.ParseNumber("3000000"), this.ParseNumber("0.0012")}, []interface{}{this.ParseNumber("15000000"), this.ParseNumber("0.001")}},
                    "maker": []interface{}{[]interface{}{this.ParseNumber("0"), this.ParseNumber("0.004")}, []interface{}{this.ParseNumber("10000"), this.ParseNumber("0.002")}, []interface{}{this.ParseNumber("100000"), this.ParseNumber("0.0012")}, []interface{}{this.ParseNumber("250000"), this.ParseNumber("0.0009")}, []interface{}{this.ParseNumber("500000"), this.ParseNumber("0.0005")}, []interface{}{this.ParseNumber("1000000"), this.ParseNumber("0.0003")}, []interface{}{this.ParseNumber("3000000"), this.ParseNumber("0.0002")}, []interface{}{this.ParseNumber("15000000"), this.ParseNumber("-0.0004")}},
                },
            },
        },
        "options": map[string]interface{} {
            "withdraw": map[string]interface{} {
                "fillResponsefromRequest": true,
                "methods": map[string]interface{} {
                    "BTC": "privatePostBitcoinWithdrawal",
                    "LTC": "privatePostLitecoinWithdrawal",
                    "BCH": "privatePostBitcoinCashWithdrawal",
                    "ETH": "privatePostEthereumWithdrawal",
                    "XRP": "privatePostRippleWithdrawal",
                    "DASH": "privatePostDashWithdrawal",
                    "DAI": "privatePostDaiWithdrawal",
                    "ADA": "privatePostAdaWithdrawal",
                    "SOL": "privatePostSolWithdrawal",
                },
            },
        },
        "features": map[string]interface{} {
            "spot": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": true,
                    "triggerPriceType": nil,
                    "triggerDirection": false,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": true,
                        "FOK": false,
                        "PO": true,
                        "GTD": false,
                    },
                    "hedged": false,
                    "trailing": true,
                    "leverage": false,
                    "marketBuyByCost": false,
                    "marketBuyRequiresPrice": false,
                    "selfTradePrevention": false,
                    "iceberg": true,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": 1000,
                    "daysBack": 100000,
                    "untilDays": 100000,
                    "symbolRequired": false,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": nil,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": nil,
                    "untilDays": nil,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchClosedOrders": nil,
                "fetchOHLCV": nil,
            },
            "swap": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "No order with given ID": OrderNotFound,
            },
            "broad": map[string]interface{} {
                "Not enough account balance available": InsufficientFunds,
                "Incorrect order ID": InvalidOrder,
                "Minimum Order Size ": InvalidOrder,
                "max allowed precision": InvalidOrder,
                "TOO MANY REQUESTS": RateLimitExceeded,
                "Access denied.": AuthenticationError,
            },
        },
        "precisionMode": TICK_SIZE,
    })
}
/**
 * @method
 * @name coinmate#fetchMarkets
 * @description retrieves data on all markets for coinmate
 * @see https://coinmate.docs.apiary.io/#reference/trading-pairs/get-trading-pairs/get
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *coinmate) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetTradingPairs(params))
            PanicOnError(response)
            //
            //     {
            //         "error":false,
            //         "errorMessage":null,
            //         "data": [
            //             {
            //                 "name":"BTC_EUR",
            //                 "firstCurrency":"BTC",
            //                 "secondCurrency":"EUR",
            //                 "priceDecimals":2,
            //                 "lotDecimals":8,
            //                 "minAmount":0.0002,
            //                 "tradesWebSocketChannelId":"trades-BTC_EUR",
            //                 "orderBookWebSocketChannelId":"order_book-BTC_EUR",
            //                 "tradeStatisticsWebSocketChannelId":"statistics-BTC_EUR"
            //             },
            //         ]
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", []interface{}{})
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
                var market interface{} = GetValue(data, i)
                var id interface{} = this.SafeString(market, "name")
                var baseId interface{} = this.SafeString(market, "firstCurrency")
                var quoteId interface{} = this.SafeString(market, "secondCurrency")
                var base interface{} = this.SafeCurrencyCode(baseId)
                var quote interface{} = this.SafeCurrencyCode(quoteId)
                var symbol interface{} = Add(Add(base, "/"), quote)
                AppendToArray(&result,map[string]interface{} {
                    "id": id,
                    "symbol": symbol,
                    "base": base,
                    "quote": quote,
                    "settle": nil,
                    "baseId": baseId,
                    "quoteId": quoteId,
                    "settleId": nil,
                    "type": "spot",
                    "spot": true,
                    "margin": false,
                    "swap": false,
                    "future": false,
                    "option": false,
                    "active": nil,
                    "contract": false,
                    "linear": nil,
                    "inverse": nil,
                    "contractSize": nil,
                    "expiry": nil,
                    "expiryDatetime": nil,
                    "strike": nil,
                    "optionType": nil,
                    "precision": map[string]interface{} {
                        "amount": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "lotDecimals"))),
                        "price": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "priceDecimals"))),
                    },
                    "limits": map[string]interface{} {
                        "leverage": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "amount": map[string]interface{} {
                            "min": this.SafeNumber(market, "minAmount"),
                            "max": nil,
                        },
                        "price": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "cost": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                    },
                    "created": nil,
                    "info": market,
                })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *coinmate) ParseBalance(response interface{}) interface{}  {
    var balances interface{} = this.SafeValue(response, "data", map[string]interface{} {})
    var result interface{} = map[string]interface{} {
        "info": response,
    }
    var currencyIds interface{} = ObjectKeys(balances)
    for i := 0; IsLessThan(i, GetArrayLength(currencyIds)); i++ {
        var currencyId interface{} = GetValue(currencyIds, i)
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var balance interface{} = this.SafeValue(balances, currencyId)
        var account interface{} = this.Account()
        AddElementToObject(account, "free", this.SafeString(balance, "available"))
        AddElementToObject(account, "used", this.SafeString(balance, "reserved"))
        AddElementToObject(account, "total", this.SafeString(balance, "balance"))
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name coinmate#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://coinmate.docs.apiary.io/#reference/balance/get-balances/post
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *coinmate) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes4158 := (<-this.LoadMarkets())
            PanicOnError(retRes4158)
        
            response:= (<-this.PrivatePostBalances(params))
            PanicOnError(response)
        
            ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinmate#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://coinmate.docs.apiary.io/#reference/order-book/get-order-book/get
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *coinmate) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes4318 := (<-this.LoadMarkets())
            PanicOnError(retRes4318)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "currencyPair": GetValue(market, "id"),
                "groupByPriceLimit": "False",
            }
        
            response:= (<-this.PublicGetOrderBook(this.Extend(request, params)))
            PanicOnError(response)
            var orderbook interface{} = GetValue(response, "data")
            var timestamp interface{} = this.SafeTimestamp(orderbook, "timestamp")
        
            ch <- this.ParseOrderBook(orderbook, GetValue(market, "symbol"), timestamp, "bids", "asks", "price", "amount")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinmate#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://coinmate.docs.apiary.io/#reference/ticker/get-ticker/get
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *coinmate) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes4538 := (<-this.LoadMarkets())
            PanicOnError(retRes4538)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "currencyPair": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetTicker(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "error": false,
            //         "errorMessage": null,
            //         "data": {
            //             "last": 0.55105,
            //             "high": 0.56439,
            //             "low": 0.54358,
            //             "amount": 37038.993381,
            //             "bid": 0.54595,
            //             "ask": 0.55324,
            //             "change": 3.03659243,
            //             "open": 0.53481,
            //             "timestamp": 1708074779
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data")
        
            ch <- this.ParseTicker(data, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinmate#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://coinmate.docs.apiary.io/#reference/ticker/get-ticker-all/get
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *coinmate) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes4908 := (<-this.LoadMarkets())
            PanicOnError(retRes4908)
            symbols = this.MarketSymbols(symbols)
        
            response:= (<-this.PublicGetTickerAll(params))
            PanicOnError(response)
            //
            //     {
            //         "error": false,
            //         "errorMessage": null,
            //         "data": {
            //             "LTC_BTC": {
            //                 "last": "0.001337",
            //                 "high": "0.001348",
            //                 "low": "0.001332",
            //                 "amount": "34.75472959",
            //                 "bid": "0.001348",
            //                 "ask": "0.001356",
            //                 "change": "-0.74239050",
            //                 "open": "0.001347",
            //                 "timestamp": "1708074485"
            //             }
            //         }
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
            var keys interface{} = ObjectKeys(data)
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
                var market interface{} = this.Market(GetValue(keys, i))
                var ticker interface{} = this.ParseTicker(this.SafeValue(data, GetValue(keys, i)), market)
                AddElementToObject(result, GetValue(market, "symbol"), ticker)
            }
        
            ch <- this.FilterByArrayTickers(result, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *coinmate) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "last": "0.001337",
    //         "high": "0.001348",
    //         "low": "0.001332",
    //         "amount": "34.75472959",
    //         "bid": "0.001348",
    //         "ask": "0.001356",
    //         "change": "-0.74239050",
    //         "open": "0.001347",
    //         "timestamp": "1708074485"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeTimestamp(ticker, "timestamp")
    var last interface{} = this.SafeNumber(ticker, "last")
    return this.SafeTicker(map[string]interface{} {
        "symbol": GetValue(market, "symbol"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeNumber(ticker, "high"),
        "low": this.SafeNumber(ticker, "low"),
        "bid": this.SafeNumber(ticker, "bid"),
        "bidVolume": nil,
        "ask": this.SafeNumber(ticker, "ask"),
        "vwap": nil,
        "askVolume": nil,
        "open": nil,
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": nil,
        "percentage": nil,
        "average": nil,
        "baseVolume": this.SafeNumber(ticker, "amount"),
        "quoteVolume": nil,
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name coinmate#fetchDepositsWithdrawals
 * @description fetch history of deposits and withdrawals
 * @see https://coinmate.docs.apiary.io/#reference/transfers/get-transfer-history/post
 * @param {string} [code] unified currency code for the currency of the deposit/withdrawals, default is undefined
 * @param {int} [since] timestamp in ms of the earliest deposit/withdrawal, default is undefined
 * @param {int} [limit] max number of deposit/withdrawals to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *coinmate) FetchDepositsWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes5758 := (<-this.LoadMarkets())
            PanicOnError(retRes5758)
            var request interface{} = map[string]interface{} {
                "limit": 1000,
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "timestampFrom", since)
            }
            if IsTrue(!IsEqual(code, nil)) {
                var currency interface{} = this.Currency(code)
                AddElementToObject(request, "currency", GetValue(currency, "id"))
            }
        
            response:= (<-this.PrivatePostTransferHistory(this.Extend(request, params)))
            PanicOnError(response)
            var items interface{} = GetValue(response, "data")
        
            ch <- this.ParseTransactions(items, nil, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *coinmate) ParseTransactionStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "COMPLETED": "ok",
        "WAITING": "pending",
        "SENT": "pending",
        "CREATED": "pending",
        "OK": "ok",
        "NEW": "pending",
        "CANCELED": "canceled",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *coinmate) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // deposits
    //
    //     {
    //         "transactionId": 1862815,
    //         "timestamp": 1516803982388,
    //         "amountCurrency": "LTC",
    //         "amount": 1,
    //         "fee": 0,
    //         "walletType": "LTC",
    //         "transferType": "DEPOSIT",
    //         "transferStatus": "COMPLETED",
    //         "txid":
    //         "ccb9255dfa874e6c28f1a64179769164025329d65e5201849c2400abd6bce245",
    //         "destination": "LQrtSKA6LnhcwRrEuiborQJnjFF56xqsFn",
    //         "destinationTag": null
    //     }
    //
    // withdrawals
    //
    //     {
    //         "transactionId": 2140966,
    //         "timestamp": 1519314282976,
    //         "amountCurrency": "EUR",
    //         "amount": 8421.7228,
    //         "fee": 16.8772,
    //         "walletType": "BANK_WIRE",
    //         "transferType": "WITHDRAWAL",
    //         "transferStatus": "COMPLETED",
    //         "txid": null,
    //         "destination": null,
    //         "destinationTag": null
    //     }
    //
    // withdraw
    //
    //     {
    //         "id": 2132583,
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var timestamp interface{} = this.SafeInteger(transaction, "timestamp")
    var currencyId interface{} = this.SafeString(transaction, "amountCurrency")
    var code interface{} = this.SafeCurrencyCode(currencyId, currency)
    return map[string]interface{} {
        "info": transaction,
        "id": this.SafeString2(transaction, "transactionId", "id"),
        "txid": this.SafeString(transaction, "txid"),
        "type": this.SafeStringLower(transaction, "transferType"),
        "currency": code,
        "network": this.SafeString(transaction, "walletType"),
        "amount": this.SafeNumber(transaction, "amount"),
        "status": this.ParseTransactionStatus(this.SafeString(transaction, "transferStatus")),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "address": this.SafeString(transaction, "destination"),
        "addressFrom": nil,
        "addressTo": nil,
        "tag": this.SafeString(transaction, "destinationTag"),
        "tagFrom": nil,
        "tagTo": nil,
        "updated": nil,
        "comment": nil,
        "internal": nil,
        "fee": map[string]interface{} {
            "cost": this.SafeNumber(transaction, "fee"),
            "currency": code,
            "rate": nil,
        },
    }
}
/**
 * @method
 * @name coinmate#withdraw
 * @description make a withdrawal
 * @see https://coinmate.docs.apiary.io/#reference/bitcoin-withdrawal-and-deposit/withdraw-bitcoins/post
 * @see https://coinmate.docs.apiary.io/#reference/litecoin-withdrawal-and-deposit/withdraw-litecoins/post
 * @see https://coinmate.docs.apiary.io/#reference/ethereum-withdrawal-and-deposit/withdraw-ethereum/post
 * @see https://coinmate.docs.apiary.io/#reference/ripple-withdrawal-and-deposit/withdraw-ripple/post
 * @see https://coinmate.docs.apiary.io/#reference/cardano-withdrawal-and-deposit/withdraw-cardano/post
 * @see https://coinmate.docs.apiary.io/#reference/solana-withdrawal-and-deposit/withdraw-solana/post
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *coinmate) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params);
            tag = GetValue(tagparamsVariable,0);
            params = GetValue(tagparamsVariable,1)
            this.CheckAddress(address)
        
            retRes6998 := (<-this.LoadMarkets())
            PanicOnError(retRes6998)
            var currency interface{} = this.Currency(code)
            var withdrawOptions interface{} = this.SafeValue(this.Options, "withdraw", map[string]interface{} {})
            var methods interface{} = this.SafeValue(withdrawOptions, "methods", map[string]interface{} {})
            var method interface{} = this.SafeString(methods, code)
            if IsTrue(IsEqual(method, nil)) {
                var allowedCurrencies interface{} = ObjectKeys(methods)
                panic(ExchangeError(Add(Add(this.Id, " withdraw() only allows withdrawing the following currencies: "), Join(allowedCurrencies, ", "))))
            }
            var request interface{} = map[string]interface{} {
                "amount": this.CurrencyToPrecision(code, amount),
                "address": address,
            }
            if IsTrue(!IsEqual(tag, nil)) {
                AddElementToObject(request, "destinationTag", tag)
            }
        
            response:= (<-this.callDynamically(method, this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "error": false,
            //         "errorMessage": null,
            //         "data": {
            //             "id": "9e0a37fc-4ab4-4b9d-b9e7-c9c8f7c4c8e0"
            //         }
            //     }
            //
            var data interface{} = this.SafeValue(response, "data")
            var transaction interface{} = this.ParseTransaction(data, currency)
            var fillResponseFromRequest interface{} = this.SafeBool(withdrawOptions, "fillResponseFromRequest", true)
            if IsTrue(fillResponseFromRequest) {
                AddElementToObject(transaction, "amount", amount)
                AddElementToObject(transaction, "currency", code)
                AddElementToObject(transaction, "address", address)
                AddElementToObject(transaction, "tag", tag)
                AddElementToObject(transaction, "type", "withdrawal")
                AddElementToObject(transaction, "status", "pending")
            }
        
            ch <- transaction
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinmate#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://coinmate.docs.apiary.io/#reference/trade-history/get-trade-history/post
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *coinmate) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes7518 := (<-this.LoadMarkets())
            PanicOnError(retRes7518)
            if IsTrue(IsEqual(limit, nil)) {
                limit = 1000
            }
            var request interface{} = map[string]interface{} {
                "limit": limit,
            }
            if IsTrue(!IsEqual(symbol, nil)) {
                var market interface{} = this.Market(symbol)
                AddElementToObject(request, "currencyPair", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "timestampFrom", since)
            }
        
            response:= (<-this.PrivatePostTradeHistory(this.Extend(request, params)))
            PanicOnError(response)
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTrades(data, nil, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *coinmate) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchMyTrades (private)
    //
    //     {
    //         "transactionId": 2671819,
    //         "createdTimestamp": 1529649127605,
    //         "currencyPair": "LTC_BTC",
    //         "type": "BUY",
    //         "orderType": "LIMIT",
    //         "orderId": 101810227,
    //         "amount": 0.01,
    //         "price": 0.01406,
    //         "fee": 0,
    //         "feeType": "MAKER"
    //     }
    //
    // fetchTrades (public)
    //
    //     {
    //         "timestamp":1561598833416,
    //         "transactionId":"4156303",
    //         "price":10950.41,
    //         "amount":0.004,
    //         "currencyPair":"BTC_EUR",
    //         "tradeType":"BUY"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(trade, "currencyPair")
    market = this.SafeMarket(marketId, market, "_")
    var priceString interface{} = this.SafeString(trade, "price")
    var amountString interface{} = this.SafeString(trade, "amount")
    var side interface{} = this.SafeStringLower2(trade, "type", "tradeType")
    var typeVar interface{} = this.SafeStringLower(trade, "orderType")
    var orderId interface{} = this.SafeString(trade, "orderId")
    var id interface{} = this.SafeString(trade, "transactionId")
    var timestamp interface{} = this.SafeInteger2(trade, "timestamp", "createdTimestamp")
    var fee interface{} = nil
    var feeCostString interface{} = this.SafeString(trade, "fee")
    if IsTrue(!IsEqual(feeCostString, nil)) {
        fee = map[string]interface{} {
            "cost": feeCostString,
            "currency": GetValue(market, "quote"),
        }
    }
    var takerOrMaker interface{} = this.SafeString(trade, "feeType")
    takerOrMaker = Ternary(IsTrue((IsEqual(takerOrMaker, "MAKER"))), "maker", "taker")
    return this.SafeTrade(map[string]interface{} {
        "id": id,
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": GetValue(market, "symbol"),
        "type": typeVar,
        "side": side,
        "order": orderId,
        "takerOrMaker": takerOrMaker,
        "price": priceString,
        "amount": amountString,
        "cost": nil,
        "fee": fee,
    }, market)
}
/**
 * @method
 * @name coinmate#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://coinmate.docs.apiary.io/#reference/transactions/transactions/get
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *coinmate) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes8468 := (<-this.LoadMarkets())
            PanicOnError(retRes8468)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "currencyPair": GetValue(market, "id"),
                "minutesIntoHistory": 10,
            }
        
            response:= (<-this.PublicGetTransactions(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "error":false,
            //         "errorMessage":null,
            //         "data":[
            //             {
            //                 "timestamp":1561598833416,
            //                 "transactionId":"4156303",
            //                 "price":10950.41,
            //                 "amount":0.004,
            //                 "currencyPair":"BTC_EUR",
            //                 "tradeType":"BUY"
            //             }
            //         ]
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTrades(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinmate#fetchTradingFee
 * @description fetch the trading fees for a market
 * @see https://coinmate.docs.apiary.io/#reference/trader-fees/get-trading-fees/post
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func  (this *coinmate) FetchTradingFee(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes8838 := (<-this.LoadMarkets())
            PanicOnError(retRes8838)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "currencyPair": GetValue(market, "id"),
            }
        
            response:= (<-this.PrivatePostTraderFees(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "error": false,
            //         "errorMessage": null,
            //         "data": { maker: '0.3', taker: "0.35", timestamp: "1646253217815" }
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
            var makerString interface{} = this.SafeString(data, "maker")
            var takerString interface{} = this.SafeString(data, "taker")
            var maker interface{} = this.ParseNumber(Precise.StringDiv(makerString, "100"))
            var taker interface{} = this.ParseNumber(Precise.StringDiv(takerString, "100"))
        
            ch <- map[string]interface{} {
                "info": data,
                "symbol": GetValue(market, "symbol"),
                "maker": maker,
                "taker": taker,
                "percentage": true,
                "tierBased": true,
            }
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinmate#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://coinmate.docs.apiary.io/#reference/order/get-open-orders/post
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinmate) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PrivatePostOpenOrders(this.Extend(map[string]interface{} {}, params)))
            PanicOnError(response)
            var extension interface{} = map[string]interface{} {
                "status": "open",
            }
        
            ch <- this.ParseOrders(GetValue(response, "data"), nil, since, limit, extension)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinmate#fetchOrders
 * @description fetches information on multiple orders made by the user
 * @see https://coinmate.docs.apiary.io/#reference/order/order-history/post
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinmate) FetchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchOrders() requires a symbol argument")))
            }
        
            retRes9438 := (<-this.LoadMarkets())
            PanicOnError(retRes9438)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "currencyPair": GetValue(market, "id"),
            }
            // offset param that appears in other parts of the API doesn't appear to be supported here
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.PrivatePostOrderHistory(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseOrders(GetValue(response, "data"), market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *coinmate) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "FILLED": "closed",
        "CANCELLED": "canceled",
        "PARTIALLY_FILLED": "open",
        "OPEN": "open",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *coinmate) ParseOrderType(typeVar interface{}) interface{}  {
    var types interface{} = map[string]interface{} {
        "LIMIT": "limit",
        "MARKET": "market",
    }
    return this.SafeString(types, typeVar, typeVar)
}
func  (this *coinmate) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // limit sell
    //
    //     {
    //         "id": 781246605,
    //         "timestamp": 1584480015133,
    //         "trailingUpdatedTimestamp": null,
    //         "type": "SELL",
    //         "currencyPair": "ETH_BTC",
    //         "price": 0.0345,
    //         "amount": 0.01,
    //         "stopPrice": null,
    //         "originalStopPrice": null,
    //         "marketPriceAtLastUpdate": null,
    //         "marketPriceAtOrderCreation": null,
    //         "orderTradeType": "LIMIT",
    //         "hidden": false,
    //         "trailing": false,
    //         "clientOrderId": null
    //     }
    //
    // limit buy
    //
    //     {
    //         "id": 67527001,
    //         "timestamp": 1517931722613,
    //         "trailingUpdatedTimestamp": null,
    //         "type": "BUY",
    //         "price": 5897.24,
    //         "remainingAmount": 0.002367,
    //         "originalAmount": 0.1,
    //         "stopPrice": null,
    //         "originalStopPrice": null,
    //         "marketPriceAtLastUpdate": null,
    //         "marketPriceAtOrderCreation": null,
    //         "status": "CANCELLED",
    //         "orderTradeType": "LIMIT",
    //         "hidden": false,
    //         "avgPrice": null,
    //         "trailing": false,
    //     }
    //
    // cancelOrder
    //
    //    {
    //        "success": true,
    //        "remainingAmount": 0.1
    //    }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeString(order, "id")
    var timestamp interface{} = this.SafeInteger(order, "timestamp")
    var side interface{} = this.SafeStringLower(order, "type")
    var priceString interface{} = this.SafeString(order, "price")
    var amountString interface{} = this.SafeString(order, "originalAmount")
    var remainingString interface{} = this.SafeString2(order, "remainingAmount", "amount")
    var status interface{} = this.ParseOrderStatus(this.SafeString(order, "status"))
    var typeVar interface{} = this.ParseOrderType(this.SafeString(order, "orderTradeType"))
    var averageString interface{} = this.SafeString(order, "avgPrice")
    var marketId interface{} = this.SafeString(order, "currencyPair")
    var symbol interface{} = this.SafeSymbol(marketId, market, "_")
    var clientOrderId interface{} = this.SafeString(order, "clientOrderId")
    return this.SafeOrder(map[string]interface{} {
        "id": id,
        "clientOrderId": clientOrderId,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "symbol": symbol,
        "type": typeVar,
        "timeInForce": nil,
        "postOnly": nil,
        "side": side,
        "price": priceString,
        "triggerPrice": this.SafeNumber(order, "stopPrice"),
        "amount": amountString,
        "cost": nil,
        "average": averageString,
        "filled": nil,
        "remaining": remainingString,
        "status": status,
        "trades": nil,
        "info": order,
        "fee": nil,
    }, market)
}
/**
 * @method
 * @name coinmate#createOrder
 * @description create a trade order
 * @see https://coinmate.docs.apiary.io/#reference/order/buy-limit-order/post
 * @see https://coinmate.docs.apiary.io/#reference/order/sell-limit-order/post
 * @see https://coinmate.docs.apiary.io/#reference/order/buy-instant-order/post
 * @see https://coinmate.docs.apiary.io/#reference/order/sell-instant-order/post
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinmate) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes10788 := (<-this.LoadMarkets())
            PanicOnError(retRes10788)
            var method interface{} = Add("privatePost", this.Capitalize(side))
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "currencyPair": GetValue(market, "id"),
            }
            if IsTrue(IsEqual(typeVar, "market")) {
                if IsTrue(IsEqual(side, "buy")) {
                    AddElementToObject(request, "total", this.AmountToPrecision(symbol, amount)) // amount in fiat
                } else {
                    AddElementToObject(request, "amount", this.AmountToPrecision(symbol, amount)) // amount in fiat
                }
                method = Add(method, "Instant")
            } else {
                AddElementToObject(request, "amount", this.AmountToPrecision(symbol, amount)) // amount in crypto
                AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
                method = Add(method, this.Capitalize(typeVar))
            }
        
            response:= (<-this.callDynamically(method, this.Extend(request, params)))
            PanicOnError(response)
            var id interface{} = this.SafeString(response, "data")
        
            ch <- this.SafeOrder(map[string]interface{} {
                "info": response,
                "id": id,
            }, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinmate#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://coinmate.docs.apiary.io/#reference/order/get-order-by-orderid/post
 * @see https://coinmate.docs.apiary.io/#reference/order/get-order-by-clientorderid/post
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinmate) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes11168 := (<-this.LoadMarkets())
            PanicOnError(retRes11168)
            var request interface{} = map[string]interface{} {
                "orderId": id,
            }
            var market interface{} = nil
            if IsTrue(symbol) {
                market = this.Market(symbol)
            }
        
            response:= (<-this.PrivatePostOrderById(this.Extend(request, params)))
            PanicOnError(response)
            var data interface{} = this.SafeDict(response, "data")
        
            ch <- this.ParseOrder(data, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinmate#cancelOrder
 * @description cancels an open order
 * @see https://coinmate.docs.apiary.io/#reference/order/cancel-order/post
 * @param {string} id order id
 * @param {string} symbol not used by coinmate cancelOrder ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinmate) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    //   {"error":false,"errorMessage":null,"data":{"success":true,"remainingAmount":0.01}}
            symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "orderId": id,
            }
        
            response:= (<-this.PrivatePostCancelOrderWithInfo(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "error": false,
            //        "errorMessage": null,
            //        "data": {
            //          "success": true,
            //          "remainingAmount": 0.1
            //        }
            //    }
            //
            var data interface{} = this.SafeDict(response, "data")
        
            ch <- this.ParseOrder(data)
            return nil
        
            }()
            return ch
        }
func  (this *coinmate) Nonce() interface{}  {
    return this.Milliseconds()
}
func  (this *coinmate) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var url interface{} = Add(Add(GetValue(GetValue(this.Urls, "api"), "rest"), "/"), path)
    if IsTrue(IsEqual(api, "public")) {
        if IsTrue(GetArrayLength(ObjectKeys(params))) {
            url = Add(url, Add("?", this.Urlencode(params)))
        }
    } else {
        this.CheckRequiredCredentials()
        var nonce interface{} = ToString(this.Nonce())
        var auth interface{} = Add(Add(nonce, this.Uid), this.ApiKey)
        var signature interface{} = this.Hmac(this.Encode(auth), this.Encode(this.Secret), sha256)
        body = this.Urlencode(this.Extend(map[string]interface{} {
            "clientId": this.Uid,
            "nonce": nonce,
            "publicKey": this.ApiKey,
            "signature": ToUpper(signature),
        }, params))
        headers = map[string]interface{} {
            "Content-Type": "application/x-www-form-urlencoded",
        }
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *coinmate) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsEqual(response, nil)) {
        return nil  // fallback to default error handler
    }
    //
    //     {"error":true,"errorMessage":"Api internal error","data":null}
    //     {"error":true,"errorMessage":"Access denied.","data":null}
    //
    var errorMessage interface{} = this.SafeString(response, "errorMessage")
    if IsTrue(!IsEqual(errorMessage, nil)) {
        var feedback interface{} = Add(Add(this.Id, " "), body)
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), errorMessage, feedback)
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), errorMessage, feedback)
        panic(ExchangeError(feedback))
    }
    return nil
}


func (this *coinmate) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
