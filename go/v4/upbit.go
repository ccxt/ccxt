package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type upbit struct {
    Exchange

}

func NewUpbitCore() upbit {
   p := upbit{}
   setDefaults(&p)
   return p
}

func  (this *upbit) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "upbit",
        "name": "Upbit",
        "countries": []interface{}{"KR"},
        "version": "v1",
        "rateLimit": 1000,
        "pro": true,
        "has": map[string]interface{} {
            "CORS": true,
            "spot": true,
            "margin": nil,
            "swap": false,
            "future": false,
            "option": false,
            "cancelOrder": true,
            "createDepositAddress": true,
            "createMarketBuyOrderWithCost": true,
            "createMarketOrder": true,
            "createMarketOrderWithCost": false,
            "createMarketSellOrderWithCost": false,
            "createOrder": true,
            "fetchBalance": true,
            "fetchCanceledOrders": true,
            "fetchClosedOrders": true,
            "fetchDeposit": true,
            "fetchDepositAddress": true,
            "fetchDepositAddresses": true,
            "fetchDepositAddressesByNetwork": false,
            "fetchDeposits": true,
            "fetchFundingHistory": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchIndexOHLCV": false,
            "fetchMarginMode": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMyTrades": false,
            "fetchOHLCV": true,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrderBooks": true,
            "fetchOrders": false,
            "fetchPositionMode": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTrades": true,
            "fetchTradingFee": true,
            "fetchTradingFees": false,
            "fetchTransactions": false,
            "fetchWithdrawal": true,
            "fetchWithdrawals": true,
            "transfer": false,
            "withdraw": true,
        },
        "timeframes": map[string]interface{} {
            "1m": "minutes",
            "3m": "minutes",
            "5m": "minutes",
            "10m": "minutes",
            "15m": "minutes",
            "30m": "minutes",
            "1h": "minutes",
            "4h": "minutes",
            "1d": "days",
            "1w": "weeks",
            "1M": "months",
        },
        "hostname": "api.upbit.com",
        "urls": map[string]interface{} {
            "logo": "https://user-images.githubusercontent.com/1294454/49245610-eeaabe00-f423-11e8-9cba-4b0aed794799.jpg",
            "api": map[string]interface{} {
                "public": "https://{hostname}",
                "private": "https://{hostname}",
            },
            "www": "https://upbit.com",
            "doc": "https://docs.upbit.com/docs/%EC%9A%94%EC%B2%AD-%EC%88%98-%EC%A0%9C%ED%95%9C",
            "fees": "https://upbit.com/service_center/guide",
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": []interface{}{"market/all", "candles/{timeframe}", "candles/{timeframe}/{unit}", "candles/minutes/{unit}", "candles/minutes/1", "candles/minutes/3", "candles/minutes/5", "candles/minutes/10", "candles/minutes/15", "candles/minutes/30", "candles/minutes/60", "candles/minutes/240", "candles/days", "candles/weeks", "candles/months", "trades/ticks", "ticker", "orderbook"},
            },
            "private": map[string]interface{} {
                "get": []interface{}{"accounts", "orders/chance", "order", "orders", "orders/closed", "orders/open", "orders/uuids", "withdraws", "withdraw", "withdraws/chance", "deposits", "deposit", "deposits/coin_addresses", "deposits/coin_address"},
                "post": []interface{}{"orders", "withdraws/coin", "withdraws/krw", "deposits/generate_coin_address"},
                "delete": []interface{}{"order"},
            },
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "tierBased": false,
                "percentage": true,
                "maker": this.ParseNumber("0.0025"),
                "taker": this.ParseNumber("0.0025"),
            },
            "funding": map[string]interface{} {
                "tierBased": false,
                "percentage": false,
                "withdraw": map[string]interface{} {},
                "deposit": map[string]interface{} {},
            },
        },
        "features": map[string]interface{} {
            "spot": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": false,
                    "triggerPriceType": nil,
                    "triggerDirection": false,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": true,
                        "FOK": true,
                        "PO": false,
                        "GTD": false,
                    },
                    "hedged": false,
                    "leverage": false,
                    "marketBuyByCost": false,
                    "marketBuyRequiresPrice": false,
                    "selfTradePrevention": false,
                    "trailing": false,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": nil,
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": true,
                    "limit": 100,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOrders": nil,
                "fetchClosedOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 1000,
                    "daysBack": 100000,
                    "daysBackCanceled": 1,
                    "untilDays": 7,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOHLCV": map[string]interface{} {
                    "limit": 200,
                },
            },
            "swap": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "precisionMode": TICK_SIZE,
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "This key has expired.": AuthenticationError,
                "Missing request parameter error. Check the required parameters!": BadRequest,
                "side is missing, side does not have a valid value": InvalidOrder,
            },
            "broad": map[string]interface{} {
                "thirdparty_agreement_required": PermissionDenied,
                "out_of_scope": PermissionDenied,
                "order_not_found": OrderNotFound,
                "insufficient_funds": InsufficientFunds,
                "invalid_access_key": AuthenticationError,
                "jwt_verification": AuthenticationError,
                "create_ask_error": ExchangeError,
                "create_bid_error": ExchangeError,
                "volume_too_large": InvalidOrder,
                "invalid_funds": InvalidOrder,
            },
        },
        "options": map[string]interface{} {
            "createMarketBuyOrderRequiresPrice": true,
            "fetchTickersMaxLength": 4096,
            "fetchOrderBooksMaxLength": 4096,
            "tradingFeesByQuoteCurrency": map[string]interface{} {
                "KRW": 0.0005,
            },
        },
        "commonCurrencies": map[string]interface{} {
            "TON": "Tokamak Network",
        },
    })
}
func  (this *upbit) FetchCurrency(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    // this method is for retrieving funding fees and limits per currency
            // it requires private access and API keys properly set up
            params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes2698 := (<-this.LoadMarkets())
            PanicOnError(retRes2698)
            var currency interface{} = this.Currency(code)
        
                retRes27115 :=  (<-this.FetchCurrencyById(GetValue(currency, "id"), params))
                PanicOnError(retRes27115)
                ch <- retRes27115
                return nil
        
            }()
            return ch
        }
func  (this *upbit) FetchCurrencyById(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    // this method is for retrieving funding fees and limits per currency
            // it requires private access and API keys properly set up
            params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "currency": id,
            }
        
            response:= (<-this.PrivateGetWithdrawsChance(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "member_level": {
            //             "security_level": 3,
            //             "fee_level": 0,
            //             "email_verified": true,
            //             "identity_auth_verified": true,
            //             "bank_account_verified": true,
            //             "kakao_pay_auth_verified": false,
            //             "locked": false,
            //             "wallet_locked": false
            //         },
            //         "currency": {
            //             "code": "BTC",
            //             "withdraw_fee": "0.0005",
            //             "is_coin": true,
            //             "wallet_state": "working",
            //             "wallet_support": [ "deposit", "withdraw" ]
            //         },
            //         "account": {
            //             "currency": "BTC",
            //             "balance": "10.0",
            //             "locked": "0.0",
            //             "avg_krw_buy_price": "8042000",
            //             "modified": false
            //         },
            //         "withdraw_limit": {
            //             "currency": "BTC",
            //             "minimum": null,
            //             "onetime": null,
            //             "daily": "10.0",
            //             "remaining_daily": "10.0",
            //             "remaining_daily_krw": "0.0",
            //             "fixed": null,
            //             "can_withdraw": true
            //         }
            //     }
            //
            var memberInfo interface{} = this.SafeValue(response, "member_level", map[string]interface{} {})
            var currencyInfo interface{} = this.SafeValue(response, "currency", map[string]interface{} {})
            var withdrawLimits interface{} = this.SafeValue(response, "withdraw_limit", map[string]interface{} {})
            var canWithdraw interface{} = this.SafeValue(withdrawLimits, "can_withdraw")
            var walletState interface{} = this.SafeString(currencyInfo, "wallet_state")
            var walletLocked interface{} = this.SafeValue(memberInfo, "wallet_locked")
            var locked interface{} = this.SafeValue(memberInfo, "locked")
            var active interface{} = true
            if IsTrue(IsTrue((!IsEqual(canWithdraw, nil))) && !IsTrue(canWithdraw)) {
                active = false
            } else if IsTrue(!IsEqual(walletState, "working")) {
                active = false
            } else if IsTrue(IsTrue((!IsEqual(walletLocked, nil))) && IsTrue(walletLocked)) {
                active = false
            } else if IsTrue(IsTrue((!IsEqual(locked, nil))) && IsTrue(locked)) {
                active = false
            }
            var maxOnetimeWithdrawal interface{} = this.SafeString(withdrawLimits, "onetime")
            var maxDailyWithdrawal interface{} = this.SafeString(withdrawLimits, "daily", maxOnetimeWithdrawal)
            var remainingDailyWithdrawal interface{} = this.SafeString(withdrawLimits, "remaining_daily", maxDailyWithdrawal)
            var maxWithdrawLimit interface{} = nil
            if IsTrue(Precise.StringGt(remainingDailyWithdrawal, "0")) {
                maxWithdrawLimit = remainingDailyWithdrawal
            } else {
                maxWithdrawLimit = maxDailyWithdrawal
            }
            var currencyId interface{} = this.SafeString(currencyInfo, "code")
            var code interface{} = this.SafeCurrencyCode(currencyId)
        
            ch <- map[string]interface{} {
                "info": response,
                "id": currencyId,
                "code": code,
                "name": code,
                "active": active,
                "fee": this.SafeNumber(currencyInfo, "withdraw_fee"),
                "precision": nil,
                "limits": map[string]interface{} {
                    "withdraw": map[string]interface{} {
                        "min": this.SafeNumber(withdrawLimits, "minimum"),
                        "max": this.ParseNumber(maxWithdrawLimit),
                    },
                },
            }
            return nil
        
            }()
            return ch
        }
func  (this *upbit) FetchMarket(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    // this method is for retrieving trading fees and limits per market
            // it requires private access and API keys properly set up
            params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes3678 := (<-this.LoadMarkets())
            PanicOnError(retRes3678)
            var market interface{} = this.Market(symbol)
        
                retRes36915 :=  (<-this.FetchMarketById(GetValue(market, "id"), params))
                PanicOnError(retRes36915)
                ch <- retRes36915
                return nil
        
            }()
            return ch
        }
func  (this *upbit) FetchMarketById(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    // this method is for retrieving trading fees and limits per market
            // it requires private access and API keys properly set up
            params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "market": id,
            }
        
            response:= (<-this.PrivateGetOrdersChance(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "bid_fee": "0.0015",
            //         "ask_fee": "0.0015",
            //         "market": {
            //             "id": "KRW-BTC",
            //             "name": "BTC/KRW",
            //             "order_types": [ "limit" ],
            //             "order_sides": [ "ask", "bid" ],
            //             "bid": { "currency": "KRW", "price_unit": null, "min_total": 1000 },
            //             "ask": { "currency": "BTC", "price_unit": null, "min_total": 1000 },
            //             "max_total": "100000000.0",
            //             "state": "active",
            //         },
            //         "bid_account": {
            //             "currency": "KRW",
            //             "balance": "0.0",
            //             "locked": "0.0",
            //             "avg_buy_price": "0",
            //             "avg_buy_price_modified": false,
            //             "unit_currency": "KRW",
            //         },
            //         "ask_account": {
            //             "currency": "BTC",
            //             "balance": "10.0",
            //             "locked": "0.0",
            //             "avg_buy_price": "8042000",
            //             "avg_buy_price_modified": false,
            //             "unit_currency": "KRW",
            //         }
            //     }
            //
            var marketInfo interface{} = this.SafeValue(response, "market")
            var bid interface{} = this.SafeValue(marketInfo, "bid")
            var ask interface{} = this.SafeValue(marketInfo, "ask")
            var marketId interface{} = this.SafeString(marketInfo, "id")
            var baseId interface{} = this.SafeString(ask, "currency")
            var quoteId interface{} = this.SafeString(bid, "currency")
            var base interface{} = this.SafeCurrencyCode(baseId)
            var quote interface{} = this.SafeCurrencyCode(quoteId)
            var state interface{} = this.SafeString(marketInfo, "state")
            var bidFee interface{} = this.SafeString(response, "bid_fee")
            var askFee interface{} = this.SafeString(response, "ask_fee")
            var fee interface{} = this.ParseNumber(Precise.StringMax(bidFee, askFee))
        
            ch <- this.SafeMarketStructure(map[string]interface{} {
                "id": marketId,
                "symbol": Add(Add(base, "/"), quote),
                "base": base,
                "quote": quote,
                "settle": nil,
                "baseId": baseId,
                "quoteId": quoteId,
                "settleId": nil,
                "type": "spot",
                "spot": true,
                "margin": false,
                "swap": false,
                "future": false,
                "option": false,
                "active": (IsEqual(state, "active")),
                "contract": false,
                "linear": nil,
                "inverse": nil,
                "taker": fee,
                "maker": fee,
                "contractSize": nil,
                "expiry": nil,
                "expiryDatetime": nil,
                "strike": nil,
                "optionType": nil,
                "precision": map[string]interface{} {
                    "amount": this.ParseNumber("1e-8"),
                    "price": this.ParseNumber("1e-8"),
                },
                "limits": map[string]interface{} {
                    "leverage": map[string]interface{} {
                        "min": nil,
                        "max": nil,
                    },
                    "amount": map[string]interface{} {
                        "min": this.SafeNumber(ask, "min_total"),
                        "max": nil,
                    },
                    "price": map[string]interface{} {
                        "min": nil,
                        "max": nil,
                    },
                    "cost": map[string]interface{} {
                        "min": this.SafeNumber(bid, "min_total"),
                        "max": this.SafeNumber(marketInfo, "max_total"),
                    },
                    "info": response,
                },
            })
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name upbit#fetchMarkets
 * @see https://docs.upbit.com/reference/%EB%A7%88%EC%BC%93-%EC%BD%94%EB%93%9C-%EC%A1%B0%ED%9A%8C
 * @description retrieves data on all markets for upbit
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *upbit) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetMarketAll(params))
            PanicOnError(response)
        
                //
            //    [
            //        {
            //            "market": "KRW-BTC",
            //            "korean_name": "비트코인",
            //            "english_name": "Bitcoin"
            //        },
            //        ...,
            //    ]
            //
        ch <- this.ParseMarkets(response)
            return nil
        
            }()
            return ch
        }
func  (this *upbit) ParseMarket(market interface{}) interface{}  {
    var id interface{} = this.SafeString(market, "market")
    quoteIdbaseIdVariable := Split(id, "-");
    quoteId := GetValue(quoteIdbaseIdVariable,0);
    baseId := GetValue(quoteIdbaseIdVariable,1)
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    return this.SafeMarketStructure(map[string]interface{} {
        "id": id,
        "symbol": Add(Add(base, "/"), quote),
        "base": base,
        "quote": quote,
        "settle": nil,
        "baseId": baseId,
        "quoteId": quoteId,
        "settleId": nil,
        "type": "spot",
        "spot": true,
        "margin": false,
        "swap": false,
        "future": false,
        "option": false,
        "active": true,
        "contract": false,
        "linear": nil,
        "inverse": nil,
        "taker": this.SafeNumber(GetValue(this.Options, "tradingFeesByQuoteCurrency"), quote, GetValue(GetValue(this.Fees, "trading"), "taker")),
        "maker": this.SafeNumber(GetValue(this.Options, "tradingFeesByQuoteCurrency"), quote, GetValue(GetValue(this.Fees, "trading"), "maker")),
        "contractSize": nil,
        "expiry": nil,
        "expiryDatetime": nil,
        "strike": nil,
        "optionType": nil,
        "precision": map[string]interface{} {
            "price": this.ParseNumber("1e-8"),
            "amount": this.ParseNumber("1e-8"),
        },
        "limits": map[string]interface{} {
            "leverage": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "amount": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "price": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "cost": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
        },
        "created": nil,
        "info": market,
    })
}
func  (this *upbit) ParseBalance(response interface{}) interface{}  {
    var result interface{} = map[string]interface{} {
        "info": response,
        "timestamp": nil,
        "datetime": nil,
    }
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        var balance interface{} = GetValue(response, i)
        var currencyId interface{} = this.SafeString(balance, "currency")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        AddElementToObject(account, "free", this.SafeString(balance, "balance"))
        AddElementToObject(account, "used", this.SafeString(balance, "locked"))
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name upbit#fetchBalance
 * @see https://docs.upbit.com/reference/%EC%A0%84%EC%B2%B4-%EA%B3%84%EC%A2%8C-%EC%A1%B0%ED%9A%8C
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *upbit) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes5838 := (<-this.LoadMarkets())
            PanicOnError(retRes5838)
        
            response:= (<-this.PrivateGetAccounts(params))
            PanicOnError(response)
        
                //
            //     [ {          currency: "BTC",
            //                   "balance": "0.005",
            //                    "locked": "0.0",
            //         "avg_krw_buy_price": "7446000",
            //                  "modified":  false     },
            //       {          currency: "ETH",
            //                   "balance": "0.1",
            //                    "locked": "0.0",
            //         "avg_krw_buy_price": "250000",
            //                  "modified":  false    }   ]
            //
        ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name upbit#fetchOrderBooks
 * @see https://docs.upbit.com/reference/%ED%98%B8%EA%B0%80-%EC%A0%95%EB%B3%B4-%EC%A1%B0%ED%9A%8C
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data for multiple markets
 * @param {string[]|undefined} symbols list of unified market symbols, all symbols fetched if undefined, default is undefined
 * @param {int} [limit] not used by upbit fetchOrderBooks ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbol
 */
func  (this *upbit) FetchOrderBooks(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes6118 := (<-this.LoadMarkets())
            PanicOnError(retRes6118)
            var ids interface{} = nil
            if IsTrue(IsEqual(symbols, nil)) {
                ids = Join(this.Ids, ",")
                // max URL length is 2083 symbols, including http schema, hostname, tld, etc...
                if IsTrue(IsGreaterThan(GetArrayLength(ids), GetValue(this.Options, "fetchOrderBooksMaxLength"))) {
                    var numIds interface{} =             GetArrayLength(this.Ids)
                    panic(ExchangeError(Add(Add(Add(Add(Add(Add(Add(this.Id, " fetchOrderBooks() has "), ToString(numIds)), " symbols ("), ToString(GetArrayLength(ids))), " characters) exceeding max URL length ("), ToString(GetValue(this.Options, "fetchOrderBooksMaxLength"))), " characters), you are required to specify a list of symbols in the first argument to fetchOrderBooks")))
                }
            } else {
                ids = this.MarketIds(symbols)
                ids = Join(ids, ",")
            }
            var request interface{} = map[string]interface{} {
                "markets": ids,
            }
        
            response:= (<-this.PublicGetOrderbook(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     [ {          market:   "BTC-ETH",
            //               "timestamp":    1542899030043,
            //          "total_ask_size":    109.57065201,
            //          "total_bid_size":    125.74430631,
            //         "orderbook_units": [ { ask_price: 0.02926679,
            //                              "bid_price": 0.02919904,
            //                               "ask_size": 4.20293961,
            //                               "bid_size": 11.65043576 },
            //                            ...,
            //                            { ask_price: 0.02938209,
            //                              "bid_price": 0.0291231,
            //                               "ask_size": 0.05135782,
            //                               "bid_size": 13.5595     }   ] },
            //       {          market:   "KRW-BTC",
            //               "timestamp":    1542899034662,
            //          "total_ask_size":    12.89790974,
            //          "total_bid_size":    4.88395783,
            //         "orderbook_units": [ { ask_price: 5164000,
            //                              "bid_price": 5162000,
            //                               "ask_size": 2.57606495,
            //                               "bid_size": 0.214       },
            //                            ...,
            //                            { ask_price: 5176000,
            //                              "bid_price": 5152000,
            //                               "ask_size": 2.752,
            //                               "bid_size": 0.4650305 }    ] }   ]
            //
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
                var orderbook interface{} = GetValue(response, i)
                var marketId interface{} = this.SafeString(orderbook, "market")
                var symbol interface{} = this.SafeSymbol(marketId, nil, "-")
                var timestamp interface{} = this.SafeInteger(orderbook, "timestamp")
                AddElementToObject(result, symbol, map[string]interface{} {
            "symbol": symbol,
            "bids": this.SortBy(this.ParseBidsAsks(GetValue(orderbook, "orderbook_units"), "bid_price", "bid_size"), 0, true),
            "asks": this.SortBy(this.ParseBidsAsks(GetValue(orderbook, "orderbook_units"), "ask_price", "ask_size"), 0),
            "timestamp": timestamp,
            "datetime": this.Iso8601(timestamp),
            "nonce": nil,
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name upbit#fetchOrderBook
 * @see https://docs.upbit.com/reference/%ED%98%B8%EA%B0%80-%EC%A0%95%EB%B3%B4-%EC%A1%B0%ED%9A%8C
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *upbit) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            orderbooks:= (<-this.FetchOrderBooks([]interface{}{symbol}, limit, params))
            PanicOnError(orderbooks)
        
            ch <- this.SafeValue(orderbooks, symbol)
            return nil
        
            }()
            return ch
        }
func  (this *upbit) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //       {                market: "BTC-ETH",
    //                    "trade_date": "20181122",
    //                    "trade_time": "104543",
    //                "trade_date_kst": "20181122",
    //                "trade_time_kst": "194543",
    //               "trade_timestamp":  1542883543096,
    //                 "opening_price":  0.02976455,
    //                    "high_price":  0.02992577,
    //                     "low_price":  0.02934283,
    //                   "trade_price":  0.02947773,
    //            "prev_closing_price":  0.02966,
    //                        "change": "FALL",
    //                  "change_price":  0.00018227,
    //                   "change_rate":  0.0061453136,
    //           "signed_change_price":  -0.00018227,
    //            "signed_change_rate":  -0.0061453136,
    //                  "trade_volume":  1.00000005,
    //               "acc_trade_price":  100.95825586,
    //           "acc_trade_price_24h":  289.58650166,
    //              "acc_trade_volume":  3409.85311036,
    //          "acc_trade_volume_24h":  9754.40510513,
    //         "highest_52_week_price":  0.12345678,
    //          "highest_52_week_date": "2018-02-01",
    //          "lowest_52_week_price":  0.023936,
    //           "lowest_52_week_date": "2017-12-08",
    //                     "timestamp":  1542883543813  }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger(ticker, "trade_timestamp")
    var marketId interface{} = this.SafeString2(ticker, "market", "code")
    market = this.SafeMarket(marketId, market, "-")
    var last interface{} = this.SafeString(ticker, "trade_price")
    return this.SafeTicker(map[string]interface{} {
        "symbol": GetValue(market, "symbol"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeString(ticker, "high_price"),
        "low": this.SafeString(ticker, "low_price"),
        "bid": nil,
        "bidVolume": nil,
        "ask": nil,
        "askVolume": nil,
        "vwap": nil,
        "open": this.SafeString(ticker, "opening_price"),
        "close": last,
        "last": last,
        "previousClose": this.SafeString(ticker, "prev_closing_price"),
        "change": this.SafeString(ticker, "signed_change_price"),
        "percentage": this.SafeString(ticker, "signed_change_rate"),
        "average": nil,
        "baseVolume": this.SafeString(ticker, "acc_trade_volume_24h"),
        "quoteVolume": this.SafeString(ticker, "acc_trade_price_24h"),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name upbit#fetchTickers
 * @see https://docs.upbit.com/reference/ticker%ED%98%84%EC%9E%AC%EA%B0%80-%EC%A0%95%EB%B3%B4
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *upbit) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes7568 := (<-this.LoadMarkets())
            PanicOnError(retRes7568)
            symbols = this.MarketSymbols(symbols)
            var ids interface{} = nil
            if IsTrue(IsEqual(symbols, nil)) {
                ids = Join(this.Ids, ",")
                // max URL length is 2083 symbols, including http schema, hostname, tld, etc...
                if IsTrue(IsGreaterThan(GetArrayLength(ids), GetValue(this.Options, "fetchTickersMaxLength"))) {
                    var numIds interface{} =             GetArrayLength(this.Ids)
                    panic(ExchangeError(Add(Add(Add(this.Id, " fetchTickers() has "), ToString(numIds)), " symbols exceeding max URL length, you are required to specify a list of symbols in the first argument to fetchTickers")))
                }
            } else {
                ids = this.MarketIds(symbols)
                ids = Join(ids, ",")
            }
            var request interface{} = map[string]interface{} {
                "markets": ids,
            }
        
            response:= (<-this.PublicGetTicker(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     [ {                market: "BTC-ETH",
            //                    "trade_date": "20181122",
            //                    "trade_time": "104543",
            //                "trade_date_kst": "20181122",
            //                "trade_time_kst": "194543",
            //               "trade_timestamp":  1542883543097,
            //                 "opening_price":  0.02976455,
            //                    "high_price":  0.02992577,
            //                     "low_price":  0.02934283,
            //                   "trade_price":  0.02947773,
            //            "prev_closing_price":  0.02966,
            //                        "change": "FALL",
            //                  "change_price":  0.00018227,
            //                   "change_rate":  0.0061453136,
            //           "signed_change_price":  -0.00018227,
            //            "signed_change_rate":  -0.0061453136,
            //                  "trade_volume":  1.00000005,
            //               "acc_trade_price":  100.95825586,
            //           "acc_trade_price_24h":  289.58650166,
            //              "acc_trade_volume":  3409.85311036,
            //          "acc_trade_volume_24h":  9754.40510513,
            //         "highest_52_week_price":  0.12345678,
            //          "highest_52_week_date": "2018-02-01",
            //          "lowest_52_week_price":  0.023936,
            //           "lowest_52_week_date": "2017-12-08",
            //                     "timestamp":  1542883543813  } ]
            //
            var result interface{} = map[string]interface{} {}
            for t := 0; IsLessThan(t, GetArrayLength(response)); t++ {
                var ticker interface{} = this.ParseTicker(GetValue(response, t))
                var symbol interface{} = GetValue(ticker, "symbol")
                AddElementToObject(result, symbol, ticker)
            }
        
            ch <- this.FilterByArrayTickers(result, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name upbit#fetchTicker
 * @see https://docs.upbit.com/reference/ticker%ED%98%84%EC%9E%AC%EA%B0%80-%EC%A0%95%EB%B3%B4
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *upbit) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            tickers:= (<-this.FetchTickers([]interface{}{symbol}, params))
            PanicOnError(tickers)
        
            ch <- this.SafeValue(tickers, symbol)
            return nil
        
            }()
            return ch
        }
func  (this *upbit) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTrades
    //
    //       {             market: "BTC-ETH",
    //             "trade_date_utc": "2018-11-22",
    //             "trade_time_utc": "13:55:24",
    //                  "timestamp":  1542894924397,
    //                "trade_price":  0.02914289,
    //               "trade_volume":  0.20074397,
    //         "prev_closing_price":  0.02966,
    //               "change_price":  -0.00051711,
    //                    "ask_bid": "ASK",
    //              "sequential_id":  15428949259430000 }
    //
    // fetchOrder trades
    //
    //         {
    //             "market": "KRW-BTC",
    //             "uuid": "78162304-1a4d-4524-b9e6-c9a9e14d76c3",
    //             "price": "101000.0",
    //             "volume": "0.77368323",
    //             "funds": "78142.00623",
    //             "ask_fee": "117.213009345",
    //             "bid_fee": "117.213009345",
    //             "created_at": "2018-04-05T14:09:15+09:00",
    //             "side": "bid",
    //         }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeString2(trade, "sequential_id", "uuid")
    var orderId interface{} = nil
    var timestamp interface{} = this.SafeInteger(trade, "timestamp")
    if IsTrue(IsEqual(timestamp, nil)) {
        timestamp = this.Parse8601(this.SafeString(trade, "created_at"))
    }
    var side interface{} = nil
    var askOrBid interface{} = this.SafeStringLower2(trade, "ask_bid", "side")
    if IsTrue(IsEqual(askOrBid, "ask")) {
        side = "sell"
    } else if IsTrue(IsEqual(askOrBid, "bid")) {
        side = "buy"
    }
    var cost interface{} = this.SafeString(trade, "funds")
    var price interface{} = this.SafeString2(trade, "trade_price", "price")
    var amount interface{} = this.SafeString2(trade, "trade_volume", "volume")
    var marketId interface{} = this.SafeString2(trade, "market", "code")
    market = this.SafeMarket(marketId, market, "-")
    var fee interface{} = nil
    var feeCost interface{} = this.SafeString(trade, Add(askOrBid, "_fee"))
    if IsTrue(!IsEqual(feeCost, nil)) {
        fee = map[string]interface{} {
            "currency": GetValue(market, "quote"),
            "cost": feeCost,
        }
    }
    return this.SafeTrade(map[string]interface{} {
        "id": id,
        "info": trade,
        "order": orderId,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": GetValue(market, "symbol"),
        "type": nil,
        "side": side,
        "takerOrMaker": nil,
        "price": price,
        "amount": amount,
        "cost": cost,
        "fee": fee,
    }, market)
}
/**
 * @method
 * @name upbit#fetchTrades
 * @see https://docs.upbit.com/reference/%EC%B5%9C%EA%B7%BC-%EC%B2%B4%EA%B2%B0-%EB%82%B4%EC%97%AD
 * @description get the list of most recent trades for a particular symbol
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *upbit) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes9098 := (<-this.LoadMarkets())
            PanicOnError(retRes9098)
            var market interface{} = this.Market(symbol)
            if IsTrue(IsEqual(limit, nil)) {
                limit = 200
            }
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
                "count": limit,
            }
        
            response:= (<-this.PublicGetTradesTicks(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [ {             market: "BTC-ETH",
            //             "trade_date_utc": "2018-11-22",
            //             "trade_time_utc": "13:55:24",
            //                  "timestamp":  1542894924397,
            //                "trade_price":  0.02914289,
            //               "trade_volume":  0.20074397,
            //         "prev_closing_price":  0.02966,
            //               "change_price":  -0.00051711,
            //                    "ask_bid": "ASK",
            //              "sequential_id":  15428949259430000 },
            //       {             market: "BTC-ETH",
            //             "trade_date_utc": "2018-11-22",
            //             "trade_time_utc": "13:03:10",
            //                  "timestamp":  1542891790123,
            //                "trade_price":  0.02917,
            //               "trade_volume":  7.392,
            //         "prev_closing_price":  0.02966,
            //               "change_price":  -0.00049,
            //                    "ask_bid": "ASK",
            //              "sequential_id":  15428917910540000 }  ]
            //
        ch <- this.ParseTrades(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name upbit#fetchTradingFee
 * @see https://docs.upbit.com/reference/%EC%A3%BC%EB%AC%B8-%EA%B0%80%EB%8A%A5-%EC%A0%95%EB%B3%B4
 * @description fetch the trading fees for a market
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func  (this *upbit) FetchTradingFee(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes9548 := (<-this.LoadMarkets())
            PanicOnError(retRes9548)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
            }
        
            response:= (<-this.PrivateGetOrdersChance(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "bid_fee": "0.0005",
            //         "ask_fee": "0.0005",
            //         "maker_bid_fee": "0.0005",
            //         "maker_ask_fee": "0.0005",
            //         "market": {
            //             "id": "KRW-BTC",
            //             "name": "BTC/KRW",
            //             "order_types": [ "limit" ],
            //             "order_sides": [ "ask", "bid" ],
            //             "bid": { "currency": "KRW", "price_unit": null, "min_total": 5000 },
            //             "ask": { "currency": "BTC", "price_unit": null, "min_total": 5000 },
            //             "max_total": "1000000000.0",
            //             "state": "active"
            //         },
            //         "bid_account": {
            //             "currency": "KRW",
            //             "balance": "0.34202414",
            //             "locked": "4999.99999922",
            //             "avg_buy_price": "0",
            //             "avg_buy_price_modified": true,
            //             "unit_currency": "KRW"
            //         },
            //         "ask_account": {
            //             "currency": "BTC",
            //             "balance": "0.00048",
            //             "locked": "0.0",
            //             "avg_buy_price": "20870000",
            //             "avg_buy_price_modified": false,
            //             "unit_currency": "KRW"
            //         }
            //     }
            //
            var askFee interface{} = this.SafeString(response, "ask_fee")
            var bidFee interface{} = this.SafeString(response, "bid_fee")
            var taker interface{} = Precise.StringMax(askFee, bidFee)
            var makerAskFee interface{} = this.SafeString(response, "maker_ask_fee")
            var makerBidFee interface{} = this.SafeString(response, "maker_bid_fee")
            var maker interface{} = Precise.StringMax(makerAskFee, makerBidFee)
        
            ch <- map[string]interface{} {
                "info": response,
                "symbol": symbol,
                "maker": this.ParseNumber(maker),
                "taker": this.ParseNumber(taker),
                "percentage": true,
                "tierBased": false,
            }
            return nil
        
            }()
            return ch
        }
func  (this *upbit) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "market": "BTC-ETH",
    //         "candle_date_time_utc": "2018-11-22T13:47:00",
    //         "candle_date_time_kst": "2018-11-22T22:47:00",
    //         "opening_price": 0.02915963,
    //         "high_price": 0.02915963,
    //         "low_price": 0.02915448,
    //         "trade_price": 0.02915448,
    //         "timestamp": 1542894473674,
    //         "candle_acc_trade_price": 0.0981629437535248,
    //         "candle_acc_trade_volume": 3.36693173,
    //         "unit": 1
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.Parse8601(this.SafeString(ohlcv, "candle_date_time_utc")), this.SafeNumber(ohlcv, "opening_price"), this.SafeNumber(ohlcv, "high_price"), this.SafeNumber(ohlcv, "low_price"), this.SafeNumber(ohlcv, "trade_price"), this.SafeNumber(ohlcv, "candle_acc_trade_volume")}
}
/**
 * @method
 * @name upbit#fetchOHLCV
 * @see https://docs.upbit.com/reference/%EB%B6%84minute-%EC%BA%94%EB%93%A4-1
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *upbit) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes10498 := (<-this.LoadMarkets())
            PanicOnError(retRes10498)
            var market interface{} = this.Market(symbol)
            var timeframePeriod interface{} = this.ParseTimeframe(timeframe)
            var timeframeValue interface{} = this.SafeString(this.Timeframes, timeframe, timeframe)
            if IsTrue(IsEqual(limit, nil)) {
                limit = 200
            }
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
                "timeframe": timeframeValue,
                "count": limit,
            }
            var response interface{} = nil
            if IsTrue(!IsEqual(since, nil)) {
                // convert `since` to `to` value
                AddElementToObject(request, "to", this.Iso8601(this.Sum(since, Multiply(Multiply(timeframePeriod, limit), 1000))))
            }
            if IsTrue(IsEqual(timeframeValue, "minutes")) {
                var numMinutes interface{} = MathRound(Divide(timeframePeriod, 60))
                AddElementToObject(request, "unit", numMinutes)
                
        response = (<-this.PublicGetCandlesTimeframeUnit(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PublicGetCandlesTimeframe(this.Extend(request, params)))
                PanicOnError(response)
            }
        
                //
            //     [
            //         {
            //             "market": "BTC-ETH",
            //             "candle_date_time_utc": "2018-11-22T13:47:00",
            //             "candle_date_time_kst": "2018-11-22T22:47:00",
            //             "opening_price": 0.02915963,
            //             "high_price": 0.02915963,
            //             "low_price": 0.02915448,
            //             "trade_price": 0.02915448,
            //             "timestamp": 1542894473674,
            //             "candle_acc_trade_price": 0.0981629437535248,
            //             "candle_acc_trade_volume": 3.36693173,
            //             "unit": 1
            //         },
            //         {
            //             "market": "BTC-ETH",
            //             "candle_date_time_utc": "2018-11-22T10:06:00",
            //             "candle_date_time_kst": "2018-11-22T19:06:00",
            //             "opening_price": 0.0294,
            //             "high_price": 0.02940882,
            //             "low_price": 0.02934283,
            //             "trade_price": 0.02937354,
            //             "timestamp": 1542881219276,
            //             "candle_acc_trade_price": 0.0762597110943884,
            //             "candle_acc_trade_volume": 2.5949617,
            //             "unit": 1
            //         }
            //     ]
            //
        ch <- this.ParseOHLCVs(response, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name upbit#createOrder
 * @description create a trade order
 * @see https://docs.upbit.com/reference/%EC%A3%BC%EB%AC%B8%ED%95%98%EA%B8%B0
 * @see https://global-docs.upbit.com/reference/order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much you want to trade in units of the base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {float} [params.cost] for market buy orders, the quote quantity that can be used as an alternative for the amount
 * @param {string} [params.timeInForce] 'IOC' or 'FOK'
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *upbit) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes11238 := (<-this.LoadMarkets())
            PanicOnError(retRes11238)
            var market interface{} = this.Market(symbol)
            var orderSide interface{} = nil
            if IsTrue(IsEqual(side, "buy")) {
                orderSide = "bid"
            } else if IsTrue(IsEqual(side, "sell")) {
                orderSide = "ask"
            } else {
                panic(InvalidOrder(Add(this.Id, " createOrder() allows buy or sell side only!")))
            }
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
                "side": orderSide,
            }
            if IsTrue(IsEqual(typeVar, "limit")) {
                AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
            }
            if IsTrue(IsTrue((IsEqual(typeVar, "market"))) && IsTrue((IsEqual(side, "buy")))) {
                // for market buy it requires the amount of quote currency to spend
                var quoteAmount interface{} = nil
                var createMarketBuyOrderRequiresPrice interface{} = true
                createMarketBuyOrderRequiresPriceparamsVariable := this.HandleOptionAndParams(params, "createOrder", "createMarketBuyOrderRequiresPrice", true);
                createMarketBuyOrderRequiresPrice = GetValue(createMarketBuyOrderRequiresPriceparamsVariable,0);
                params = GetValue(createMarketBuyOrderRequiresPriceparamsVariable,1)
                var cost interface{} = this.SafeNumber(params, "cost")
                params = this.Omit(params, "cost")
                if IsTrue(!IsEqual(cost, nil)) {
                    quoteAmount = this.CostToPrecision(symbol, cost)
                } else if IsTrue(createMarketBuyOrderRequiresPrice) {
                    if IsTrue(IsEqual(price, nil)) {
                        panic(InvalidOrder(Add(this.Id, " createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend (quote quantity) in the amount argument")))
                    } else {
                        var amountString interface{} = this.NumberToString(amount)
                        var priceString interface{} = this.NumberToString(price)
                        var costRequest interface{} = Precise.StringMul(amountString, priceString)
                        quoteAmount = this.CostToPrecision(symbol, costRequest)
                    }
                } else {
                    quoteAmount = this.CostToPrecision(symbol, amount)
                }
                AddElementToObject(request, "ord_type", "price")
                AddElementToObject(request, "price", quoteAmount)
            } else {
                AddElementToObject(request, "ord_type", typeVar)
                AddElementToObject(request, "volume", this.AmountToPrecision(symbol, amount))
            }
            var clientOrderId interface{} = this.SafeString2(params, "clientOrderId", "identifier")
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                AddElementToObject(request, "identifier", clientOrderId)
            }
            if IsTrue(!IsEqual(typeVar, "market")) {
                var timeInForce interface{} = this.SafeStringLower2(params, "timeInForce", "time_in_force")
                params = this.Omit(params, "timeInForce")
                if IsTrue(!IsEqual(timeInForce, nil)) {
                    AddElementToObject(request, "time_in_force", timeInForce)
                }
            }
            params = this.Omit(params, []interface{}{"clientOrderId", "identifier"})
        
            response:= (<-this.PrivatePostOrders(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "uuid": "cdd92199-2897-4e14-9448-f923320408ad",
            //         "side": "bid",
            //         "ord_type": "limit",
            //         "price": "100.0",
            //         "avg_price": "0.0",
            //         "state": "wait",
            //         "market": "KRW-BTC",
            //         "created_at": "2018-04-10T15:42:23+09:00",
            //         "volume": "0.01",
            //         "remaining_volume": "0.01",
            //         "reserved_fee": "0.0015",
            //         "remaining_fee": "0.0015",
            //         "paid_fee": "0.0",
            //         "locked": "1.0015",
            //         "executed_volume": "0.0",
            //         "trades_count": 0
            //     }
            //
        ch <- this.ParseOrder(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name upbit#cancelOrder
 * @see https://docs.upbit.com/reference/%EC%A3%BC%EB%AC%B8-%EC%B7%A8%EC%86%8C
 * @description cancels an open order
 * @param {string} id order id
 * @param {string} symbol not used by upbit cancelOrder ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *upbit) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes12148 := (<-this.LoadMarkets())
            PanicOnError(retRes12148)
            var request interface{} = map[string]interface{} {
                "uuid": id,
            }
        
            response:= (<-this.PrivateDeleteOrder(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "uuid": "cdd92199-2897-4e14-9448-f923320408ad",
            //         "side": "bid",
            //         "ord_type": "limit",
            //         "price": "100.0",
            //         "state": "wait",
            //         "market": "KRW-BTC",
            //         "created_at": "2018-04-10T15:42:23+09:00",
            //         "volume": "0.01",
            //         "remaining_volume": "0.01",
            //         "reserved_fee": "0.0015",
            //         "remaining_fee": "0.0015",
            //         "paid_fee": "0.0",
            //         "locked": "1.0015",
            //         "executed_volume": "0.0",
            //         "trades_count": 0
            //     }
            //
        ch <- this.ParseOrder(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name upbit#fetchDeposits
 * @see https://docs.upbit.com/reference/%EC%9E%85%EA%B8%88-%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EC%A1%B0%ED%9A%8C
 * @description fetch all deposits made to an account
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *upbit) FetchDeposits(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes12538 := (<-this.LoadMarkets())
            PanicOnError(retRes12538)
            var request interface{} = map[string]interface{} {}
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "currency", GetValue(currency, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit) // default is 100
            }
        
            response:= (<-this.PrivateGetDeposits(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "type": "deposit",
            //             "uuid": "94332e99-3a87-4a35-ad98-28b0c969f830",
            //             "currency": "KRW",
            //             "txid": "9e37c537-6849-4c8b-a134-57313f5dfc5a",
            //             "state": "ACCEPTED",
            //             "created_at": "2017-12-08T15:38:02+09:00",
            //             "done_at": "2017-12-08T15:38:02+09:00",
            //             "amount": "100000.0",
            //             "fee": "0.0"
            //         },
            //         ...,
            //     ]
            //
        ch <- this.ParseTransactions(response, currency, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name upbit#fetchDeposit
 * @description fetch information on a deposit
 * @see https://global-docs.upbit.com/reference/individual-deposit-inquiry
 * @param {string} id the unique id for the deposit
 * @param {string} [code] unified currency code of the currency deposited
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.txid] withdrawal transaction id, the id argument is reserved for uuid
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *upbit) FetchDeposit(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes12988 := (<-this.LoadMarkets())
            PanicOnError(retRes12988)
            var request interface{} = map[string]interface{} {
                "uuid": id,
            }
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "currency", GetValue(currency, "id"))
            }
        
            response:= (<-this.PrivateGetDeposit(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "type": "deposit",
            //         "uuid": "7f54527e-2eee-4268-860e-fd8b9d7fe3c7",
            //         "currency": "ADA",
            //         "net_type": "ADA",
            //         "txid": "99795bbfeca91eaa071068bb659b33eeb65d8aaff2551fdf7c78f345d188952b",
            //         "state": "ACCEPTED",
            //         "created_at": "2023-12-12T04:58:41Z",
            //         "done_at": "2023-12-12T05:31:50Z",
            //         "amount": "35.72344",
            //         "fee": "0.0",
            //         "transaction_type": "default"
            //     }
            //
        ch <- this.ParseTransaction(response, currency)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name upbit#fetchWithdrawals
 * @see https://docs.upbit.com/reference/%EC%A0%84%EC%B2%B4-%EC%B6%9C%EA%B8%88-%EC%A1%B0%ED%9A%8C
 * @description fetch all withdrawals made from an account
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawals structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *upbit) FetchWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes13388 := (<-this.LoadMarkets())
            PanicOnError(retRes13388)
            var request interface{} = map[string]interface{} {}
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "currency", GetValue(currency, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit) // default is 100
            }
        
            response:= (<-this.PrivateGetWithdraws(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "type": "withdraw",
            //             "uuid": "9f432943-54e0-40b7-825f-b6fec8b42b79",
            //             "currency": "BTC",
            //             "txid": null,
            //             "state": "processing",
            //             "created_at": "2018-04-13T11:24:01+09:00",
            //             "done_at": null,
            //             "amount": "0.01",
            //             "fee": "0.0",
            //             "krw_amount": "80420.0"
            //         },
            //         ...,
            //     ]
            //
        ch <- this.ParseTransactions(response, currency, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name upbit#fetchWithdrawal
 * @description fetch data on a currency withdrawal via the withdrawal id
 * @see https://global-docs.upbit.com/reference/individual-withdrawal-inquiry
 * @param {string} id the unique id for the withdrawal
 * @param {string} [code] unified currency code of the currency withdrawn
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.txid] withdrawal transaction id, the id argument is reserved for uuid
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *upbit) FetchWithdrawal(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes13838 := (<-this.LoadMarkets())
            PanicOnError(retRes13838)
            var request interface{} = map[string]interface{} {
                "uuid": id,
            }
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "currency", GetValue(currency, "id"))
            }
        
            response:= (<-this.PrivateGetWithdraw(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "type": "withdraw",
            //         "uuid": "95ef274b-23a6-4de4-95b0-5cbef4ca658f",
            //         "currency": "ADA",
            //         "net_type": "ADA",
            //         "txid": "b1528f149297a71671b86636f731f8fdb0ff53da0f1d8c19093d59df96f34583",
            //         "state": "DONE",
            //         "created_at": "2023-12-14T02:46:52Z",
            //         "done_at": "2023-12-14T03:10:11Z",
            //         "amount": "35.22344",
            //         "fee": "0.5",
            //         "transaction_type": "default"
            //     }
            //
        ch <- this.ParseTransaction(response, currency)
            return nil
        
            }()
            return ch
        }
func  (this *upbit) ParseTransactionStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "submitting": "pending",
        "submitted": "pending",
        "almost_accepted": "pending",
        "rejected": "failed",
        "accepted": "ok",
        "processing": "pending",
        "done": "ok",
        "canceled": "canceled",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *upbit) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchDeposits, fetchDeposit
    //
    //     {
    //         "type": "deposit",
    //         "uuid": "94332e99-3a87-4a35-ad98-28b0c969f830",
    //         "currency": "KRW",
    //         "txid": "9e37c537-6849-4c8b-a134-57313f5dfc5a",
    //         "state": "ACCEPTED",
    //         "created_at": "2017-12-08T15:38:02+09:00",
    //         "done_at": "2017-12-08T15:38:02+09:00",
    //         "amount": "100000.0",
    //         "fee": "0.0"
    //     }
    //
    // fetchWithdrawals, fetchWithdrawal
    //
    //     {
    //         "type": "withdraw",
    //         "uuid": "9f432943-54e0-40b7-825f-b6fec8b42b79",
    //         "currency": "BTC",
    //         "txid": "cd81e9b45df8da29f936836e58c907a106057e454a45767a7b06fcb19b966bba",
    //         "state": "processing",
    //         "created_at": "2018-04-13T11:24:01+09:00",
    //         "done_at": null,
    //         "amount": "0.01",
    //         "fee": "0.0",
    //         "krw_amount": "80420.0"
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var address interface{} = nil // not present in the data structure received from the exchange
    var tag interface{} = nil // not present in the data structure received from the exchange
    var updatedRaw interface{} = this.SafeString(transaction, "done_at")
    var timestamp interface{} = this.Parse8601(this.SafeString(transaction, "created_at", updatedRaw))
    var typeVar interface{} = this.SafeString(transaction, "type")
    if IsTrue(IsEqual(typeVar, "withdraw")) {
        typeVar = "withdrawal"
    }
    var currencyId interface{} = this.SafeString(transaction, "currency")
    var code interface{} = this.SafeCurrencyCode(currencyId, currency)
    return map[string]interface{} {
        "info": transaction,
        "id": this.SafeString(transaction, "uuid"),
        "currency": code,
        "amount": this.SafeNumber(transaction, "amount"),
        "network": nil,
        "address": address,
        "addressTo": nil,
        "addressFrom": nil,
        "tag": tag,
        "tagTo": nil,
        "tagFrom": nil,
        "status": this.ParseTransactionStatus(this.SafeStringLower(transaction, "state")),
        "type": typeVar,
        "updated": this.Parse8601(updatedRaw),
        "txid": this.SafeString(transaction, "txid"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "internal": nil,
        "comment": nil,
        "fee": map[string]interface{} {
            "currency": code,
            "cost": this.SafeNumber(transaction, "fee"),
        },
    }
}
func  (this *upbit) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "wait": "open",
        "done": "closed",
        "cancel": "canceled",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *upbit) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "uuid": "a08f09b1-1718-42e2-9358-f0e5e083d3ee",
    //         "side": "bid",
    //         "ord_type": "limit",
    //         "price": "17417000.0",
    //         "state": "done",
    //         "market": "KRW-BTC",
    //         "created_at": "2018-04-05T14:09:14+09:00",
    //         "volume": "1.0",
    //         "remaining_volume": "0.0",
    //         "reserved_fee": "26125.5",
    //         "remaining_fee": "25974.0",
    //         "paid_fee": "151.5",
    //         "locked": "17341974.0",
    //         "executed_volume": "1.0",
    //         "trades_count": 2,
    //         "trades": [
    //             {
    //                 "market": "KRW-BTC",
    //                 "uuid": "78162304-1a4d-4524-b9e6-c9a9e14d76c3",
    //                 "price": "101000.0",
    //                 "volume": "0.77368323",
    //                 "funds": "78142.00623",
    //                 "ask_fee": "117.213009345",
    //                 "bid_fee": "117.213009345",
    //                 "created_at": "2018-04-05T14:09:15+09:00",
    //                 "side": "bid",
    //             },
    //             {
    //                 "market": "KRW-BTC",
    //                 "uuid": "f73da467-c42f-407d-92fa-e10d86450a20",
    //                 "price": "101000.0",
    //                 "volume": "0.22631677",
    //                 "funds": "22857.99377",
    //                 "ask_fee": "34.286990655", // missing in market orders
    //                 "bid_fee": "34.286990655", // missing in market orders
    //                 "created_at": "2018-04-05T14:09:15+09:00", // missing in market orders
    //                 "side": "bid",
    //             },
    //         ],
    //     }
    //
    // fetchOpenOrders, fetchClosedOrders, fetchCanceledOrders
    //
    //     {
    //         "uuid": "637fd66-d019-4d77-bee6-8e0cff28edd9",
    //         "side": "ask",
    //         "ord_type": "limit",
    //         "price": "1.5",
    //         "state": "wait",
    //         "market": "SGD-XRP",
    //         "created_at": "2024-06-05T09:37:10Z",
    //         "volume": "10",
    //         "remaining_volume": "10",
    //         "reserved_fee": "0",
    //         "remaining_fee": "0",
    //         "paid_fee": "0",
    //         "locked": "10",
    //         "executed_volume": "0",
    //         "executed_funds": "0",
    //         "trades_count": 0,
    //         "time_in_force": "ioc"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeString(order, "uuid")
    var side interface{} = this.SafeString(order, "side")
    if IsTrue(IsEqual(side, "bid")) {
        side = "buy"
    } else {
        side = "sell"
    }
    var typeVar interface{} = this.SafeString(order, "ord_type")
    var timestamp interface{} = this.Parse8601(this.SafeString(order, "created_at"))
    var status interface{} = this.ParseOrderStatus(this.SafeString(order, "state"))
    var lastTradeTimestamp interface{} = nil
    var price interface{} = this.SafeString(order, "price")
    var amount interface{} = this.SafeString(order, "volume")
    var remaining interface{} = this.SafeString(order, "remaining_volume")
    var filled interface{} = this.SafeString(order, "executed_volume")
    var cost interface{} = nil
    if IsTrue(IsEqual(typeVar, "price")) {
        typeVar = "market"
        cost = price
        price = nil
    }
    var average interface{} = nil
    var fee interface{} = nil
    var feeCost interface{} = this.SafeString(order, "paid_fee")
    var marketId interface{} = this.SafeString(order, "market")
    market = this.SafeMarket(marketId, market)
    var trades interface{} = this.SafeValue(order, "trades", []interface{}{})
    trades = this.ParseTrades(trades, market, nil, nil, map[string]interface{} {
        "order": id,
        "type": typeVar,
    })
    var numTrades interface{} =     GetArrayLength(trades)
    if IsTrue(IsGreaterThan(numTrades, 0)) {
        // the timestamp in fetchOrder trades is missing
        lastTradeTimestamp = GetValue(GetValue(trades, Subtract(numTrades, 1)), "timestamp")
        var getFeesFromTrades interface{} = false
        if IsTrue(IsEqual(feeCost, nil)) {
            getFeesFromTrades = true
            feeCost = "0"
        }
        cost = "0"
        for i := 0; IsLessThan(i, numTrades); i++ {
            var trade interface{} = GetValue(trades, i)
            cost = Precise.StringAdd(cost, this.SafeString(trade, "cost"))
            if IsTrue(getFeesFromTrades) {
                var tradeFee interface{} = this.SafeValue(GetValue(trades, i), "fee", map[string]interface{} {})
                var tradeFeeCost interface{} = this.SafeString(tradeFee, "cost")
                if IsTrue(!IsEqual(tradeFeeCost, nil)) {
                    feeCost = Precise.StringAdd(feeCost, tradeFeeCost)
                }
            }
        }
        average = Precise.StringDiv(cost, filled)
    }
    if IsTrue(!IsEqual(feeCost, nil)) {
        fee = map[string]interface{} {
            "currency": GetValue(market, "quote"),
            "cost": feeCost,
        }
    }
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": id,
        "clientOrderId": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": lastTradeTimestamp,
        "symbol": GetValue(market, "symbol"),
        "type": typeVar,
        "timeInForce": this.SafeStringUpper(order, "time_in_force"),
        "postOnly": nil,
        "side": side,
        "price": price,
        "triggerPrice": nil,
        "cost": this.ParseNumber(cost),
        "average": this.ParseNumber(average),
        "amount": amount,
        "filled": filled,
        "remaining": remaining,
        "status": status,
        "fee": fee,
        "trades": trades,
    })
}
/**
 * @method
 * @name upbit#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://global-docs.upbit.com/reference/open-order
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of open order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.state] default is 'wait', set to 'watch' for stop limit orders
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *upbit) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes16668 := (<-this.LoadMarkets())
            PanicOnError(retRes16668)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "market", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.PrivateGetOrdersOpen(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "uuid": "637fd66-d019-4d77-bee6-8e0cff28edd9",
            //             "side": "ask",
            //             "ord_type": "limit",
            //             "price": "1.5",
            //             "state": "wait",
            //             "market": "SGD-XRP",
            //             "created_at": "2024-06-05T09:37:10Z",
            //             "volume": "10",
            //             "remaining_volume": "10",
            //             "reserved_fee": "0",
            //             "remaining_fee": "0",
            //             "paid_fee": "0",
            //             "locked": "10",
            //             "executed_volume": "0",
            //             "executed_funds": "0",
            //             "trades_count": 0
            //         }
            //     ]
            //
        ch <- this.ParseOrders(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name upbit#fetchClosedOrders
 * @description fetches information on multiple closed orders made by the user
 * @see https://global-docs.upbit.com/reference/closed-order
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest order
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *upbit) FetchClosedOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes17158 := (<-this.LoadMarkets())
            PanicOnError(retRes17158)
            var request interface{} = map[string]interface{} {
                "state": "done",
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "market", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_time", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            requestparamsVariable := this.HandleUntilOption("end_time", request, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
        
            response:= (<-this.PrivateGetOrdersClosed(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "uuid": "637fd66-d019-4d77-bee6-8e0cff28edd9",
            //             "side": "ask",
            //             "ord_type": "limit",
            //             "price": "1.5",
            //             "state": "done",
            //             "market": "SGD-XRP",
            //             "created_at": "2024-06-05T09:37:10Z",
            //             "volume": "10",
            //             "remaining_volume": "10",
            //             "reserved_fee": "0",
            //             "remaining_fee": "0",
            //             "paid_fee": "0",
            //             "locked": "10",
            //             "executed_volume": "0",
            //             "executed_funds": "0",
            //             "trades_count": 0,
            //             "time_in_force": "ioc"
            //         }
            //     ]
            //
        ch <- this.ParseOrders(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name upbit#fetchCanceledOrders
 * @description fetches information on multiple canceled orders made by the user
 * @see https://global-docs.upbit.com/reference/closed-order
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] timestamp in ms of the earliest order, default is undefined
 * @param {int} [limit] max number of orders to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest order
 * @returns {object} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *upbit) FetchCanceledOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes17718 := (<-this.LoadMarkets())
            PanicOnError(retRes17718)
            var request interface{} = map[string]interface{} {
                "state": "cancel",
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "market", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_time", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            requestparamsVariable := this.HandleUntilOption("end_time", request, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
        
            response:= (<-this.PrivateGetOrdersClosed(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "uuid": "637fd66-d019-4d77-bee6-8e0cff28edd9",
            //             "side": "ask",
            //             "ord_type": "limit",
            //             "price": "1.5",
            //             "state": "cancel",
            //             "market": "SGD-XRP",
            //             "created_at": "2024-06-05T09:37:10Z",
            //             "volume": "10",
            //             "remaining_volume": "10",
            //             "reserved_fee": "0",
            //             "remaining_fee": "0",
            //             "paid_fee": "0",
            //             "locked": "10",
            //             "executed_volume": "0",
            //             "executed_funds": "0",
            //             "trades_count": 0,
            //             "time_in_force": "ioc"
            //         }
            //     ]
            //
        ch <- this.ParseOrders(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name upbit#fetchOrder
 * @see https://docs.upbit.com/reference/%EA%B0%9C%EB%B3%84-%EC%A3%BC%EB%AC%B8-%EC%A1%B0%ED%9A%8C
 * @description fetches information on an order made by the user
 * @param {string} id order id
 * @param {string} symbol not used by upbit fetchOrder
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *upbit) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes18258 := (<-this.LoadMarkets())
            PanicOnError(retRes18258)
            var request interface{} = map[string]interface{} {
                "uuid": id,
            }
        
            response:= (<-this.PrivateGetOrder(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "uuid": "a08f09b1-1718-42e2-9358-f0e5e083d3ee",
            //         "side": "bid",
            //         "ord_type": "limit",
            //         "price": "17417000.0",
            //         "state": "done",
            //         "market": "KRW-BTC",
            //         "created_at": "2018-04-05T14:09:14+09:00",
            //         "volume": "1.0",
            //         "remaining_volume": "0.0",
            //         "reserved_fee": "26125.5",
            //         "remaining_fee": "25974.0",
            //         "paid_fee": "151.5",
            //         "locked": "17341974.0",
            //         "executed_volume": "1.0",
            //         "trades_count": 2,
            //         "trades": [
            //             {
            //                 "market": "KRW-BTC",
            //                 "uuid": "78162304-1a4d-4524-b9e6-c9a9e14d76c3",
            //                 "price": "101000.0",
            //                 "volume": "0.77368323",
            //                 "funds": "78142.00623",
            //                 "ask_fee": "117.213009345",
            //                 "bid_fee": "117.213009345",
            //                 "created_at": "2018-04-05T14:09:15+09:00",
            //                 "side": "bid"
            //             },
            //             {
            //                 "market": "KRW-BTC",
            //                 "uuid": "f73da467-c42f-407d-92fa-e10d86450a20",
            //                 "price": "101000.0",
            //                 "volume": "0.22631677",
            //                 "funds": "22857.99377",
            //                 "ask_fee": "34.286990655",
            //                 "bid_fee": "34.286990655",
            //                 "created_at": "2018-04-05T14:09:15+09:00",
            //                 "side": "bid"
            //             }
            //         ]
            //     }
            //
        ch <- this.ParseOrder(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name upbit#fetchDepositAddresses
 * @see https://docs.upbit.com/reference/%EC%A0%84%EC%B2%B4-%EC%9E%85%EA%B8%88-%EC%A3%BC%EC%86%8C-%EC%A1%B0%ED%9A%8C
 * @description fetch deposit addresses for multiple currencies and chain types
 * @param {string[]|undefined} codes list of unified currency codes, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [address structures]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *upbit) FetchDepositAddresses(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    codes := GetArg(optionalArgs, 0, nil)
            _ = codes
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes18868 := (<-this.LoadMarkets())
            PanicOnError(retRes18868)
        
            response:= (<-this.PrivateGetDepositsCoinAddresses(params))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "currency": "BTC",
            //             "deposit_address": "3EusRwybuZUhVDeHL7gh3HSLmbhLcy7NqD",
            //             "secondary_address": null
            //         },
            //         {
            //             "currency": "ETH",
            //             "deposit_address": "0x0d73e0a482b8cf568976d2e8688f4a899d29301c",
            //             "secondary_address": null
            //         },
            //         {
            //             "currency": "XRP",
            //             "deposit_address": "rN9qNpgnBaZwqCg8CvUZRPqCcPPY7wfWep",
            //             "secondary_address": "3057887915"
            //         }
            //     ]
            //
        ch <- this.ParseDepositAddresses(response, codes)
            return nil
        
            }()
            return ch
        }
func  (this *upbit) ParseDepositAddress(depositAddress interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        currency: 'XRP',
    //        net_type: 'XRP',
    //        deposit_address: 'raQwCVAJVqjrVm1Nj5SFRcX8i22BhdC9WA',
    //        secondary_address: '167029435'
    //    }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var address interface{} = this.SafeString(depositAddress, "deposit_address")
    var tag interface{} = this.SafeString(depositAddress, "secondary_address")
    var currencyId interface{} = this.SafeString(depositAddress, "currency")
    var code interface{} = this.SafeCurrencyCode(currencyId)
    var networkId interface{} = this.SafeString(depositAddress, "net_type")
    this.CheckAddress(address)
    return map[string]interface{} {
        "info": depositAddress,
        "currency": code,
        "network": this.NetworkIdToCode(networkId),
        "address": address,
        "tag": tag,
    }
}
/**
 * @method
 * @name upbit#fetchDepositAddress
 * @see https://docs.upbit.com/reference/%EC%A0%84%EC%B2%B4-%EC%9E%85%EA%B8%88-%EC%A3%BC%EC%86%8C-%EC%A1%B0%ED%9A%8C
 * @description fetch the deposit address for a currency associated with this account
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} params.network deposit chain, can view all chains via this.publicGetWalletAssets, default is eth, unless the currency has a default chain within this.options['networks']
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *upbit) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes19458 := (<-this.LoadMarkets())
            PanicOnError(retRes19458)
            var currency interface{} = this.Currency(code)
            var networkCode interface{} = nil
            networkCodeparamsVariable := this.HandleNetworkCodeAndParams(params);
            networkCode = GetValue(networkCodeparamsVariable,0);
            params = GetValue(networkCodeparamsVariable,1)
            if IsTrue(IsEqual(networkCode, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchDepositAddress requires params[\"network\"]")))
            }
        
            response:= (<-this.PrivateGetDepositsCoinAddress(this.Extend(map[string]interface{} {
            "currency": GetValue(currency, "id"),
            "net_type": this.NetworkCodeToId(networkCode, GetValue(currency, "code")),
        }, params)))
            PanicOnError(response)
        
                //
            //    {
            //        currency: 'XRP',
            //        net_type: 'XRP',
            //        deposit_address: 'raQwCVAJVqjrVm1Nj5SFRcX8i22BhdC9WA',
            //        secondary_address: '167029435'
            //    }
            //
        ch <- this.ParseDepositAddress(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name upbit#createDepositAddress
 * @see https://docs.upbit.com/reference/%EC%9E%85%EA%B8%88-%EC%A3%BC%EC%86%8C-%EC%83%9D%EC%84%B1-%EC%9A%94%EC%B2%AD
 * @description create a currency deposit address
 * @param {string} code unified currency code of the currency for the deposit address
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *upbit) CreateDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes19778 := (<-this.LoadMarkets())
            PanicOnError(retRes19778)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "currency": GetValue(currency, "id"),
            }
            // https://github.com/ccxt/ccxt/issues/6452
        
            response:= (<-this.PrivatePostDepositsGenerateCoinAddress(this.Extend(request, params)))
            PanicOnError(response)
            //
            // https://docs.upbit.com/v1.0/reference#%EC%9E%85%EA%B8%88-%EC%A3%BC%EC%86%8C-%EC%83%9D%EC%84%B1-%EC%9A%94%EC%B2%AD
            // can be any of the two responses:
            //
            //     {
            //         "success" : true,
            //         "message" : "Creating BTC deposit address."
            //     }
            //
            //     {
            //         "currency": "BTC",
            //         "deposit_address": "3EusRwybuZUhVDeHL7gh3HSLmbhLcy7NqD",
            //         "secondary_address": null
            //     }
            //
            var message interface{} = this.SafeString(response, "message")
            if IsTrue(!IsEqual(message, nil)) {
                panic(AddressPending(Add(Add(Add(this.Id, " is generating "), code), " deposit address, call fetchDepositAddress or createDepositAddress one more time later to retrieve the generated address")))
            }
        
            ch <- this.ParseDepositAddress(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name upbit#withdraw
 * @see https://docs.upbit.com/reference/디지털자산-출금하기
 * @see https://docs.upbit.com/reference/%EC%9B%90%ED%99%94-%EC%B6%9C%EA%B8%88%ED%95%98%EA%B8%B0
 * @description make a withdrawal
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *upbit) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params);
            tag = GetValue(tagparamsVariable,0);
            params = GetValue(tagparamsVariable,1)
        
            retRes20218 := (<-this.LoadMarkets())
            PanicOnError(retRes20218)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "amount": amount,
            }
            var response interface{} = nil
            if IsTrue(!IsEqual(code, "KRW")) {
                this.CheckAddress(address)
                // 2023-05-23 Change to required parameters for digital assets
                var network interface{} = this.SafeStringUpper2(params, "network", "net_type")
                if IsTrue(IsEqual(network, nil)) {
                    panic(ArgumentsRequired(Add(this.Id, " withdraw() requires a network argument")))
                }
                params = this.Omit(params, []interface{}{"network"})
                AddElementToObject(request, "net_type", network)
                AddElementToObject(request, "currency", GetValue(currency, "id"))
                AddElementToObject(request, "address", address)
                if IsTrue(!IsEqual(tag, nil)) {
                    AddElementToObject(request, "secondary_address", tag)
                }
                params = this.Omit(params, "network")
                
        response = (<-this.PrivatePostWithdrawsCoin(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PrivatePostWithdrawsKrw(this.Extend(request, params)))
                PanicOnError(response)
            }
        
                //
            //     {
            //         "type": "withdraw",
            //         "uuid": "9f432943-54e0-40b7-825f-b6fec8b42b79",
            //         "currency": "BTC",
            //         "txid": "ebe6937b-130e-4066-8ac6-4b0e67f28adc",
            //         "state": "processing",
            //         "created_at": "2018-04-13T11:24:01+09:00",
            //         "done_at": null,
            //         "amount": "0.01",
            //         "fee": "0.0",
            //         "krw_amount": "80420.0"
            //     }
            //
        ch <- this.ParseTransaction(response)
            return nil
        
            }()
            return ch
        }
func  (this *upbit) Nonce() interface{}  {
    return this.Milliseconds()
}
func  (this *upbit) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var url interface{} = this.ImplodeParams(GetValue(GetValue(this.Urls, "api"), api), map[string]interface{} {
        "hostname": this.Hostname,
    })
    url = Add(url, Add(Add(Add("/", this.Version), "/"), this.ImplodeParams(path, params)))
    var query interface{} = this.Omit(params, this.ExtractParams(path))
    if IsTrue(!IsEqual(method, "POST")) {
        if IsTrue(GetArrayLength(ObjectKeys(query))) {
            url = Add(url, Add("?", this.Urlencode(query)))
        }
    }
    if IsTrue(IsEqual(api, "private")) {
        this.CheckRequiredCredentials()
        headers = map[string]interface{} {}
        var nonce interface{} = this.Uuid()
        var request interface{} = map[string]interface{} {
            "access_key": this.ApiKey,
            "nonce": nonce,
        }
        var hasQuery interface{} =         GetArrayLength(ObjectKeys(query))
        var auth interface{} = nil
        if IsTrue(IsTrue((!IsEqual(method, "GET"))) && IsTrue((!IsEqual(method, "DELETE")))) {
            body = this.Json(params)
            AddElementToObject(headers, "Content-Type", "application/json")
        }
        if IsTrue(hasQuery) {
            auth = this.Rawencode(query)
        }
        if IsTrue(!IsEqual(auth, nil)) {
            var hash interface{} = this.Hash(this.Encode(auth), sha512)
            AddElementToObject(request, "query_hash", hash)
            AddElementToObject(request, "query_hash_alg", "SHA512")
        }
        var token interface{} = Jwt(request, this.Encode(this.Secret), sha256)
        AddElementToObject(headers, "Authorization", Add("Bearer ", token))
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *upbit) HandleErrors(httpCode interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsEqual(response, nil)) {
        return nil  // fallback to default error handler
    }
    //
    //   { 'error': { 'message': "Missing request parameter error. Check the required parameters!", 'name': 400 } },
    //   { 'error': { 'message': "side is missing, side does not have a valid value", 'name': "validation_error" } },
    //   { 'error': { 'message': "개인정보 제 3자 제공 동의가 필요합니다.", 'name': "thirdparty_agreement_required" } },
    //   { 'error': { 'message': "권한이 부족합니다.", 'name': "out_of_scope" } },
    //   { 'error': { 'message': "주문을 찾지 못했습니다.", 'name': "order_not_found" } },
    //   { 'error': { 'message': "주문가능한 금액(ETH)이 부족합니다.", 'name': "insufficient_funds_ask" } },
    //   { 'error': { 'message': "주문가능한 금액(BTC)이 부족합니다.", 'name': "insufficient_funds_bid" } },
    //   { 'error': { 'message': "잘못된 엑세스 키입니다.", 'name': "invalid_access_key" } },
    //   { 'error': { 'message': "Jwt 토큰 검증에 실패했습니다.", 'name': "jwt_verification" } }
    //
    var error interface{} = this.SafeValue(response, "error")
    if IsTrue(!IsEqual(error, nil)) {
        var message interface{} = this.SafeString(error, "message")
        var name interface{} = this.SafeString(error, "name")
        var feedback interface{} = Add(Add(this.Id, " "), body)
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), message, feedback)
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), name, feedback)
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), message, feedback)
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), name, feedback)
        panic(ExchangeError(feedback))
    }
    return nil
}


func (this *upbit) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
