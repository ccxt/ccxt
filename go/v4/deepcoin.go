package ccxt


// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type DeepcoinCore struct {
    Exchange

}

func NewDeepcoinCore() *DeepcoinCore {
    p := &DeepcoinCore{}
    setDefaults(p)
    return p
}

func  (this *DeepcoinCore) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "deepcoin",
        "name": "deepcoin",
        "version": "v1",
        "countries": []interface{}{"SG"},
        "rateLimit": 1000,
        "pro": false,
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": false,
            "swap": true,
            "future": false,
            "option": false,
            "cancelOrder": true,
            "createOrder": true,
            "fetchBalance": true,
            "fetchClosedOrders": true,
            "fetchMarkets": true,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchTicker": true,
            "fetchTickers": true,
        },
        "timeframes": map[string]interface{} {
            "1m": "1m",
            "3m": "3m",
            "5m": "5m",
            "15m": "15m",
            "30m": "30m",
            "1H": "1H",
            "2H": "2H",
            "4H": "4H",
            "12H": "12H",
            "1D": "1D",
            "1W": "1W",
            "1M": "1M",
            "1Y": "1Y",
        },
        "urls": map[string]interface{} {
            "logo": "https://www.deepcoin.com/static/images/nav-logo-black-7ad2482d753feb3.svg",
            "api": map[string]interface{} {
                "v1": map[string]interface{} {
                    "public": "https://api.deepcoin.com",
                    "private": "https://test-api.goodtest.cc",
                },
            },
            "www": "https://www.deepcoin.com",
            "doc": "https://www.deepcoin.com/en/docs",
        },
        "precisionMode": TICK_SIZE,
        "api": map[string]interface{} {
            "v1": map[string]interface{} {
                "private": map[string]interface{} {
                    "post": []interface{}{"deepcoin/trade/cancel-order", "deepcoin/trade/order"},
                    "get": []interface{}{"deepcoin/trade/orders-pending", "deepcoin/trade/orders-history", "deepcoin/trade/order", "deepcoin/trade/fills", "deepcoin/account/balances"},
                },
                "public": map[string]interface{} {
                    "get": []interface{}{"deepcoin/market/instruments", "deepcoin/market/tickers", "deepcoin/market/books", "deepcoin/market/candles"},
                },
            },
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {},
        },
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {},
            "broad": map[string]interface{} {},
        },
    })
}
func  (this *DeepcoinCore) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    /**
            * @method
            * @name deepcoin#fetchMyTrades
            * @description fetch all trades made by the user
            * @see https://www.deepcoin.com/en/docs#deepcoin-trade-fills
            * @param {string} symbol unified market symbol
            * @param {int} [since] the earliest time in ms to fetch trades for
            * @param {int} [limit] the maximum number of trades structures to retrieve
            * @param {string} [params.instType] Instrument type. 'SPOT' or 'SWAP', 'SPOT' by default
            * @param {object} [params] extra parameters specific to the exchange API endpoint
            * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
            */
            symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes1408 := (<-this.LoadMarkets())
            PanicOnError(retRes1408)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var request interface{} = map[string]interface{} {
                "instType": this.SafeString(params, "instType", "SPOT"),
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "begin", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.V1PrivateGetDeepcoinTradeFills(this.Extend(request, params)))
            PanicOnError(response)
            var result interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTrades(result, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *DeepcoinCore) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    /**
            * @method
            * @name deepcoin#fetchBalance
            * @description query for balance and get the amount of funds available for trading or funds locked in orders
            * @param {string} [params.instType] Instrument type. 'SPOT' or 'SWAP', 'SPOT' by default
            * @param {object} [params.ccy] currency, eg:'USDT'
            * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
            */
            params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "instType": this.SafeString(params, "instType", "SPOT"),
            }
        
            response:= (<-this.V1PrivateGetDeepcoinAccountBalances(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
func  (this *DeepcoinCore) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    /**
            * @method
            * @name deepcoin#fetchOrder
            * @description fetches information on an order made by the user
            * @param {string} symbol unified market symbol
            * @param {object} [params] extra parameters specific to the exchange API endpoint
            * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
            */
            symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchOrder() requires a symbol argument")))
            }
        
            retRes1878 := (<-this.LoadMarkets())
            PanicOnError(retRes1878)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "instId": GetValue(market, "id"),
                "ordId": id,
            }
        
            response:= (<-this.V1PrivateGetDeepcoinTradeOrder(this.Extend(request, params)))
            PanicOnError(response)
            var data interface{} = this.SafeList(response, "data", []interface{}{})
            if IsTrue(IsEqual(GetArrayLength(data), 0)) {
        
                ch <- this.SafeOrder(map[string]interface{} {})
                return nil
            }
        
            ch <- this.ParseOrder(this.Extend(request, params, GetValue(data, 0)))
            return nil
        
            }()
            return ch
        }
func  (this *DeepcoinCore) FetchClosedOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    /**
            * @method
            * @name delta#fetchOpenOrders
            * @description fetch all unfilled currently open orders
            * @see https://www.deepcoin.com/en/docs#deepcoin-trade-orders-history
            * @param {string} symbol unified market symbol
            * @param {int} [since] the earliest time in ms to fetch open orders for
            * @param {int} [limit] the maximum number of open order structures to retrieve
            * @param {string} [params.instType] Instrument type. 'SPOT' or 'SWAP', 'SPOT' by default
            * @param {string} [params.ordType] Order type. 'market': Market order,'limit': Limit order,'post_only': Post-only order
            * @param {string} [params.state] State. 'live' or 'partially_filled'
            * @param {string} [params.after] Pagination of data to return records earlier than the requested ordId, eg:"1000314896749646
            * @param {string} [params.before] Pagination of data to return records newer than the requested ordId, eg:"1000314896749646
            * @param {object} [params.ordId] order id
            * @param {object} [params] extra parameters specific to the exchange API endpoint
            * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
            */
            symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "instType": this.SafeString(params, "instType", "SPOT"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.V1PrivateGetDeepcoinTradeOrdersHistory(this.Extend(request, params)))
            PanicOnError(response)
            var data interface{} = this.SafeList(response, "data", []interface{}{})
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
                AppendToArray(&result, this.ParseOrder(this.Extend(request, params, GetValue(data, i))))
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *DeepcoinCore) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    /**
            * @method
            * @name deepcoin#fetchOpenOrders
            * @description fetch all unfilled currently open orders
            * @see https://www.deepcoin.com/en/docs#deepcoin-trade-orders-pending
            * @param {string} symbol unified market symbol
            * @param {int} [since] the earliest time in ms to fetch open orders for
            * @param {int} [limit] the maximum number of open order structures to retrieve
            * @param {string} [params.instType] Instrument type. 'SPOT' or 'SWAP', 'SPOT' by default
            * @param {string} [params.ordType] Order type. 'market': Market order,'limit': Limit order,'post_only': Post-only order
            * @param {string} [params.state] State. 'live' or 'partially_filled'
            * @param {string} [params.after] Pagination of data to return records earlier than the requested ordId, eg:"1000314896749646
            * @param {string} [params.before] Pagination of data to return records newer than the requested ordId, eg:"1000314896749646
            * @param {object} [params] extra parameters specific to the exchange API endpoint
            * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
            */
            symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var ordType interface{} = this.SafeString(params, "ordType")
            var state interface{} = this.SafeString(params, "state")
            var after interface{} = this.SafeString(params, "after")
            var before interface{} = this.SafeString(params, "before")
            var request interface{} = map[string]interface{} {
                "instType": this.SafeString(params, "instType", "SPOT"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            if IsTrue(!IsEqual(ordType, nil)) {
                AddElementToObject(request, "ordType", ordType)
            }
            if IsTrue(!IsEqual(state, nil)) {
                AddElementToObject(request, "state", state)
            }
            if IsTrue(!IsEqual(after, nil)) {
                AddElementToObject(request, "after", after)
            }
            if IsTrue(!IsEqual(before, nil)) {
                AddElementToObject(request, "before", before)
            }
        
            response:= (<-this.V1PrivateGetDeepcoinTradeOrdersPending(this.Extend(request, params)))
            PanicOnError(response)
            var data interface{} = this.SafeList(response, "data", []interface{}{})
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
                AppendToArray(&result, this.ParseOrder(this.Extend(request, params, GetValue(data, i))))
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *DeepcoinCore) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    /**
            * @method
            * @name deepcoin#fetchOHLCV
            * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
            * @see https://www.deepcoin.com/en/docs#deepcoin-market-candles
            * @param {string} symbol unified symbol of the market to fetch OHLCV data for
            * @param {string} timeframe the length of time each candle represents
            * @param {int} [since] timestamp in ms of the earliest candle to fetch
            * @param {int} [limit] the maximum amount of candles to fetch
            * @param {object} [params] extra parameters specific to the exchange API endpoint
            * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume(base units)
            */
            timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes2958 := (<-this.LoadMarkets())
            PanicOnError(retRes2958)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "instId": GetValue(market, "id"),
                "bar": this.SafeString(this.Timeframes, timeframe, timeframe),
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "before", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.V1PublicGetDeepcoinMarketCandles(this.Extend(request, params)))
            PanicOnError(response)
            var result interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseOHLCVs(result, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *DeepcoinCore) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    /**
            * @method
            * @name deepcoin#fetchOrderBook
            * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
            * @see https://www.deepcoin.com/en/docs#deepcoin-market-books
            * @param {string} symbol unified symbol of the market to fetch the order book for
            * @param {int} [limit] the maximum amount of order book entries to return
            * @param {object} [params] extra parameters specific to the exchange API endpoint
            * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
            */
            limit := GetArg(optionalArgs, 0, 10)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes3238 := (<-this.LoadMarkets())
            PanicOnError(retRes3238)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "instId": GetValue(market, "id"),
                "sz": limit,
            }
        
            response:= (<-this.V1PublicGetDeepcoinMarketBooks(this.Extend(request, params)))
            PanicOnError(response)
            var result interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseOrderBook(result, GetValue(market, "symbol"), nil)
            return nil
        
            }()
            return ch
        }
func  (this *DeepcoinCore) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    /**
            * @method
            * @name deepcoin#fetchTicker
            * @description fetches price tickers for multiple data, statistical information calculated over the past 24 hours for each market
            * @see https://www.deepcoin.com/en/docs#deepcoin-market-tickers
            * @param {string} symbol unified symbol of the market to fetch the ticker for
            * @param {object} [params] extra parameters specific to the exchange API endpoint
            * @returns {object} a dictionary of [ticker structures]{@link https://www.deepcoin.com/en/docs#deepcoin-market-tickers}
            */
            params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes3448 := (<-this.LoadMarkets())
            PanicOnError(retRes3448)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "instType": this.MarketTypeToInstType(GetValue(market, "type")),
                "instId": GetValue(market, "id"),
            }
        
            response:= (<-this.V1PublicGetDeepcoinMarketTickers(this.Extend(request, params)))
            PanicOnError(response)
            var tickers interface{} = this.SafeList(response, "data", []interface{}{})
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(tickers)); i++ {
                var ticker interface{} = this.ParseTicker(GetValue(tickers, i))
                AddElementToObject(result, GetValue(ticker, "symbol"), ticker)
            }
            result = this.FilterByArrayTickers(result, "symbol", []interface{}{symbol})
        
            ch <- GetValue(result, symbol)
            return nil
        
            }()
            return ch
        }
func  (this *DeepcoinCore) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    /**
            * @method
            * @name deepcoin#fetchTickers
            * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
            * @see https://www.deepcoin.com/en/docs#deepcoin-market-tickers
            * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
            * @param {object} [params] extra parameters specific to the exchange API endpoint
            * @returns {object} a dictionary of [ticker structures]{@link https://www.deepcoin.com/en/docs#deepcoin-market-tickers}
            */
            symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "instType": this.SafeString(params, "instType", "SPOT"),
            }
        
            retRes3748 := (<-this.LoadMarkets())
            PanicOnError(retRes3748)
            symbols = this.MarketSymbols(symbols)
        
            response:= (<-this.V1PublicGetDeepcoinMarketTickers(this.Extend(request, params)))
            PanicOnError(response)
            var tickers interface{} = this.SafeList(response, "data", []interface{}{})
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(tickers)); i++ {
                var ticker interface{} = this.ParseTicker(GetValue(tickers, i))
                var symbol interface{} = GetValue(ticker, "symbol")
                AddElementToObject(result, symbol, ticker)
            }
        
            ch <- this.FilterByArrayTickers(result, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *DeepcoinCore) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    /**
            * @method
            * @name deepcoin#fetchMarkets
            * @description retrieves data on all markets for deepcoin
            * @see https://www.deepcoin.com/en/docs#deepcoin-market-instruments
            * @param {string} [params.uly] Underlying. Only applicable to SWAP
            * @param {string} [params.instId] Instrument ID
            * @returns {object[]} an array of objects representing market data
            */
            params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var instTypes interface{} = []interface{}{"SPOT", "SWAP"}
            var result interface{} = []interface{}{}
            for j := 0; IsLessThan(j, GetArrayLength(instTypes)); j++ {
                var request interface{} = map[string]interface{} {
                    "instType": GetValue(instTypes, j),
                }
        
                response:= (<-this.V1PublicGetDeepcoinMarketInstruments(this.Extend(request, params)))
                PanicOnError(response)
                var markets interface{} = this.SafeList(response, "data", []interface{}{})
                for i := 0; IsLessThan(i, GetArrayLength(markets)); i++ {
                    AppendToArray(&result, this.ParseMarket(GetValue(markets, i)))
                }
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *DeepcoinCore) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    /**
            * @method
            * @name whitebit#createOrder
            * @description create a trade order
            * @see https://www.deepcoin.com/en/docs#deepcoin-trade-order
            * @param {string} symbol unified symbol of the market to create an order in
            * @param {string} type 'market' or 'limit'
            * @param {string} side 'buy' or 'sell'
            * @param {float} amount how much of currency you want to trade in units of base currency
            * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
            * @param {string} [params.tdMode] Margin mode 'cross', isolated Non-Margin mode 'cash', 'cash' by default
            * @param {string} [params.ccy] Margin currency. Only applicable to cross MARGIN orders in Single-currency margin. eg:'USDT'
            * @param {string} [params.clOrdId] client order id as assigned by the client, A combination of case-sensitive alphanumerics, all numbers, or all letters of up to 32 characters
            * @param {string} [params.ccy] Margin currency. Only applicable to cross MARGIN orders in Single-currency margin. eg:'USDT'
            * @param {string} [params.tag]  Order tag. A combination of case-sensitive alphanumerics, all numbers, or all letters of up to 16 characters
            * @param {string} [params.posSide] Position side. 'long' or 'short'
            * @param {string} [params.mrgPosition] Margin position. 'merge' or 'split'
            * @param {string} [params.closePosId] Waiting for closing split margin positions. Required in split margin mode. eg:'1001063717138767'
            * @param {string} [params.reduceOnly] Whether the order can only reduce the position size. Valid options: 'true' or 'false'. The default value is 'false'. Only applicable to MARGIN orders, and FUTURES/SWAP orders in net mode Only applicable to Single-currency margin and Multi-currency margin
            * @param {string} [params.tgtCcy] Quantity type. 'base_ccy': Base currency, 'quote_ccy': Quote currency, Only applicable to SPOT Market Orders Default is 'quote_ccy' for buy, 'base_ccy' for sell
            * @param {object} [params] extra parameters specific to the exchange API endpoint
            * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
            */
            price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes4368 := (<-this.LoadMarkets())
            PanicOnError(retRes4368)
            var market interface{} = this.Market(symbol)
            var tdMode interface{} = this.SafeString(params, "tdMode", "cash")
            var request interface{} = map[string]interface{} {
                "instId": GetValue(market, "id"),
                "side": side,
                "sz": amount,
                "tdMode": tdMode,
                "ordType": typeVar,
                "px": price,
            }
        
            response:= (<-this.V1PrivatePostDeepcoinTradeOrder(this.Extend(request, params)))
            PanicOnError(response)
            var result interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseOrder(this.Extend(request, params, result))
            return nil
        
            }()
            return ch
        }
func  (this *DeepcoinCore) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    /**
            * @method
            * @name deepcoin#cancelOrder
            * @description cancels an open order
            * @see https://www.deepcoin.com/en/docs#deepcoin-trade-cancel-order
            * @param {string} id order id
            * @param {string} symbol unified symbol of the market the order was made in
            * @param {string} [params.clOrdId] client order id as assigned by the client, A combination of case-sensitive alphanumerics, all numbers, or all letters of up to 32 characters.
            * @param {object} [params] extra parameters specific to the exchange API endpoint
            * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
            */
            symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " cancelOrder() requires a symbol argument")))
            }
        
            retRes4678 := (<-this.LoadMarkets())
            PanicOnError(retRes4678)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "instId": GetValue(market, "id"),
                "ordId": id,
            }
        
            response:= (<-this.V1PrivatePostDeepcoinTradeCancelOrder(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseOrder(response)
            return nil
        
            }()
            return ch
        }
func  (this *DeepcoinCore) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var orderId interface{} = this.SafeString(trade, "ordId")
    var timestamp interface{} = this.SafeNumber(trade, "ts")
    var fee interface{} = map[string]interface{} {
        "cost": this.SafeString(trade, "fee"),
        "currency": this.SafeString(trade, "feeCcy"),
    }
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "id": orderId,
        "order": orderId,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": this.SafeStringUpper(trade, "instId"),
        "type": nil,
        "side": this.SafeString(trade, "side"),
        "price": this.SafeNumber(trade, "fillPx"),
        "amount": this.SafeNumber(trade, "fillSz"),
        "cost": nil,
        "takerOrMaker": this.SafeStringUpper(trade, "execType"),
        "fee": fee,
    }, market)
}
func  (this *DeepcoinCore) ParseBalance(response interface{}) interface{}  {
    var balances interface{} = this.SafeList(response, "data", []interface{}{})
    var result interface{} = map[string]interface{} {
        "info": balances,
    }
    for i := 0; IsLessThan(i, GetArrayLength(balances)); i++ {
        var balance interface{} = GetValue(balances, i)
        var code interface{} = this.SafeString(balance, "ccy")
        var account interface{} = this.Account()
        AddElementToObject(account, "total", this.SafeString(balance, "bal"))
        AddElementToObject(account, "free", this.SafeString(balance, "availBal"))
        AddElementToObject(account, "used", this.SafeString(balance, "frozenBal"))
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
func  (this *DeepcoinCore) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeNumber(ticker, "ts", 0.001)
    // const last = this.safeString (ticker, 'close');
    return this.SafeTicker(map[string]interface{} {
        "info": ticker,
        "symbol": this.SafeStringUpper(ticker, "instId"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeNumber(ticker, "high24h"),
        "low": this.SafeNumber(ticker, "low24h"),
        "bid": this.SafeNumber(ticker, "bidPx"),
        "bidVolume": this.SafeNumber(ticker, "bidSz"),
        "ask": this.SafeNumber(ticker, "askPx"),
        "askVolume": this.SafeNumber(ticker, "askSz"),
        "vwap": nil,
        "open": this.SafeString(ticker, "open24h"),
        "close": this.SafeNumber(ticker, "last"),
        "last": this.SafeNumber(ticker, "last"),
        "previousClose": nil,
        "baseVolume": this.SafeNumber(ticker, "volCcy24h"),
        "quoteVolume": this.SafeNumber(ticker, "vol24h"),
    }, market)
}
func  (this *DeepcoinCore) ParseMarket(market interface{}) interface{}  {
    var instType interface{} = this.SafeString(market, "instType")
    var id interface{} = this.SafeString(market, "instId")
    var isSpot interface{} = false
    var isSwap interface{} = false
    var isContract interface{} = false
    var typeVar interface{} = nil
    if IsTrue(IsEqual(instType, "SPOT")) {
        isSpot = true
        typeVar = "spot"
    } else if IsTrue(IsEqual(instType, "SWAP")) {
        isSwap = true
        isContract = true
        typeVar = "swap"
    }
    // const uly = this.safeString (market, 'uly');
    var base interface{} = this.SafeStringUpper(market, "baseCcy")
    var quote interface{} = this.SafeStringUpper(market, "quoteCcy")
    var state interface{} = this.SafeString(market, "state")
    var active interface{} = IsEqual(state, "live")
    var contractSize interface{} = this.SafeNumber(market, "ctVal")
    var settle interface{} = this.SafeString(market, "ctValCcy")
    var created interface{} = this.SafeNumber(market, "listTime")
    var maxLever interface{} = this.SafeNumber(market, "lever")
    var minSz interface{} = this.SafeNumber(market, "minSz")
    var ctType interface{} = this.SafeString(market, "ctType")
    // const alias = this.safeString (market, 'alias');
    // const maxLmtSz = this.safeString (market, 'maxLmtSz');
    // const maxMktSz = this.safeString (market, 'maxMktSz');
    var pricePrecision interface{} = this.SafeNumber(market, "tickSz")
    var amountPrecision interface{} = this.SafeNumber(market, "lotSz")
    return map[string]interface{} {
        "info": market,
        "id": id,
        "symbol": this.SafeStringUpper(market, "instId"),
        "base": base,
        "quote": quote,
        "baseId": base,
        "quoteId": quote,
        "active": active,
        "type": typeVar,
        "spot": isSpot,
        "margin": nil,
        "future": nil,
        "swap": isSwap,
        "option": nil,
        "contract": isContract,
        "settle": settle,
        "settleId": settle,
        "contractSize": contractSize,
        "linear": IsEqual(ctType, "linear"),
        "inverse": IsEqual(ctType, "inverse"),
        "expiry": nil,
        "expiryDatetime": nil,
        "strike": nil,
        "optionType": nil,
        "taker": nil,
        "maker": nil,
        "percentage": nil,
        "tierBased": nil,
        "feeSide": nil,
        "precision": map[string]interface{} {
            "price": pricePrecision,
            "amount": amountPrecision,
            "cost": nil,
        },
        "limits": map[string]interface{} {
            "amount": map[string]interface{} {
                "min": minSz,
                "max": nil,
            },
            "price": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "cost": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "leverage": map[string]interface{} {
                "min": nil,
                "max": maxLever,
            },
        },
        "created": created,
    }
}
func  (this *DeepcoinCore) ParseStatus(state interface{}) interface{}  {
    if IsTrue(IsTrue(IsEqual(state, "live")) || IsTrue(IsEqual(state, "partially_filled"))) {
        return "open"
    } else if IsTrue(IsEqual(state, "filled")) {
        return "closed"
    } else if IsTrue(IsEqual(state, "canceled")) {
        return "canceled"
    } else {
        return nil
    }
}
func  (this *DeepcoinCore) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeNumber(order, "cTime")
    var lastTradeTimestamp interface{} = this.SafeNumber(order, "fillTime")
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": this.SafeString(order, "ordId"),
        "symbol": this.SafeStringUpper(order, "instId"),
        "clientOrderId": this.SafeString(order, "clOrdId"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": lastTradeTimestamp,
        "status": this.ParseStatus(this.SafeString(order, "state")),
        "timeInForce": nil,
        "side": this.SafeString(order, "side"),
        "type": this.SafeString(order, "ordType"),
        "price": this.SafeNumber(order, "px"),
        "average": this.SafeNumber(order, "avgPx"),
        "amount": this.SafeNumber(order, "sz"),
        "filled": this.SafeNumber(order, "accFillSz"),
        "remaining": nil,
        "cost": nil,
        "fee": map[string]interface{} {
            "currency": this.SafeString(order, "feeCcy"),
            "cost": this.SafeNumber(order, "fee"),
        },
        "postOnly": IsEqual(this.SafeString(order, "ordType"), "post_only"),
        "trades": nil,
    })
}
func  (this *DeepcoinCore) MarketTypeToInstType(typeVar interface{}) interface{}  {
    return ToUpper(typeVar)
}
func  (this *DeepcoinCore) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var version interface{} = this.SafeValue(api, 0)
    var accessibility interface{} = this.SafeValue(api, 1)
    var query interface{} = this.Urlencode(params)
    var timestamp interface{} = this.Iso8601(this.Milliseconds())
    var url interface{} = Add(Add(GetValue(GetValue(GetValue(this.Urls, "api"), version), accessibility), "/"), path)
    var payload interface{} = Add(Add(Add(timestamp, method), "/"), path)
    if IsTrue(IsEqual(method, "GET")) {
        url = Add(url, Add("?", query))
        payload = Add(payload, Add("?", query))
    } else if IsTrue(IsEqual(method, "POST")) {
        body = this.Json(params)
        payload = Add(payload, body)
    }
    if IsTrue(IsEqual(accessibility, "private")) {
        var secret interface{} = this.Secret
        var signature interface{} = this.Hmac(this.Encode(payload), this.Encode(secret), sha256, "base64")
        headers = map[string]interface{} {
            "Content-Type": "application/json",
            "DC-ACCESS-KEY": this.ApiKey,
            "DC-ACCESS-SIGN": signature,
            "DC-ACCESS-TIMESTAMP": timestamp,
            "DC-ACCESS-PASSPHRASE": this.Password,
        }
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *DeepcoinCore) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsEqual(response, nil)) {
        return nil
    }
    var errorCode interface{} = this.SafeString2(response, "sCode", "code")
    var errorMsg interface{} = this.SafeString2(response, "sMsg", "msg")
    if IsTrue(IsTrue(!IsEqual(errorCode, nil)) && IsTrue(!IsEqual(errorCode, "0"))) {
        var feedback interface{} = Add(Add(this.Id, " "), body)
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), errorCode, feedback)
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), errorMsg, feedback)
        panic(ExchangeError(feedback))
    }
    return nil
}


func (this *DeepcoinCore) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.DerivedExchange = this
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
}
