package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type DeepcoinCore struct {
	Exchange
}

func NewDeepcoinCore() *DeepcoinCore {
	p := &DeepcoinCore{}
	setDefaults(p)
	return p
}

func (this *DeepcoinCore) Describe() interface{} {
	return this.DeepExtend(this.Exchange.Describe(), map[string]interface{}{
		"id":        "deepcoin",
		"name":      "DeepCoin",
		"countries": []interface{}{"SG"},
		"rateLimit": 200,
		"version":   "v1",
		"certified": false,
		"pro":       true,
		"has": map[string]interface{}{
			"CORS":                                 nil,
			"spot":                                 true,
			"margin":                               true,
			"swap":                                 true,
			"future":                               false,
			"option":                               false,
			"addMargin":                            false,
			"cancelAllOrders":                      true,
			"cancelAllOrdersAfter":                 false,
			"cancelOrder":                          true,
			"cancelOrders":                         true,
			"cancelWithdraw":                       false,
			"closePosition":                        true,
			"createConvertTrade":                   false,
			"createDepositAddress":                 false,
			"createLimitBuyOrder":                  true,
			"createLimitOrder":                     true,
			"createLimitSellOrder":                 true,
			"createMarketBuyOrder":                 true,
			"createMarketBuyOrderWithCost":         true,
			"createMarketOrder":                    true,
			"createMarketOrderWithCost":            true,
			"createMarketSellOrder":                true,
			"createMarketSellOrderWithCost":        true,
			"createOrder":                          true,
			"createOrders":                         false,
			"createOrderWithTakeProfitAndStopLoss": true,
			"createPostOnlyOrder":                  true,
			"createReduceOnlyOrder":                true,
			"createStopLossOrder":                  false,
			"createTakeProfitOrder":                false,
			"createTrailingAmountOrder":            false,
			"createTrailingPercentOrder":           false,
			"createTriggerOrder":                   true,
			"editOrder":                            true,
			"fetchAccounts":                        false,
			"fetchBalance":                         true,
			"fetchCanceledAndClosedOrders":         true,
			"fetchCanceledOrders":                  true,
			"fetchClosedOrder":                     true,
			"fetchClosedOrders":                    true,
			"fetchConvertCurrencies":               false,
			"fetchConvertQuote":                    false,
			"fetchConvertTrade":                    false,
			"fetchConvertTradeHistory":             false,
			"fetchCurrencies":                      false,
			"fetchDepositAddress":                  true,
			"fetchDepositAddresses":                true,
			"fetchDeposits":                        true,
			"fetchDepositsWithdrawals":             false,
			"fetchDepositWithdrawFees":             false,
			"fetchFundingHistory":                  false,
			"fetchFundingRate":                     true,
			"fetchFundingRateHistory":              true,
			"fetchFundingRates":                    true,
			"fetchIndexOHLCV":                      true,
			"fetchLedger":                          true,
			"fetchLeverage":                        false,
			"fetchLeverageTiers":                   false,
			"fetchMarginAdjustmentHistory":         false,
			"fetchMarginMode":                      false,
			"fetchMarkets":                         true,
			"fetchMarkOHLCV":                       true,
			"fetchMyTrades":                        true,
			"fetchOHLCV":                           true,
			"fetchOpenInterest":                    false,
			"fetchOpenInterestHistory":             false,
			"fetchOpenOrder":                       true,
			"fetchOpenOrders":                      true,
			"fetchOrder":                           false,
			"fetchOrderBook":                       true,
			"fetchOrders":                          false,
			"fetchOrderTrades":                     true,
			"fetchPosition":                        true,
			"fetchPositionHistory":                 false,
			"fetchPositionMode":                    false,
			"fetchPositions":                       true,
			"fetchPositionsForSymbol":              true,
			"fetchPositionsHistory":                true,
			"fetchPremiumIndexOHLCV":               false,
			"fetchStatus":                          false,
			"fetchTicker":                          false,
			"fetchTickers":                         true,
			"fetchTime":                            false,
			"fetchTrades":                          true,
			"fetchTradingFee":                      false,
			"fetchTradingFees":                     false,
			"fetchTransactions":                    false,
			"fetchTransfers":                       false,
			"fetchWithdrawals":                     true,
			"reduceMargin":                         false,
			"sandbox":                              false,
			"setLeverage":                          true,
			"setMargin":                            false,
			"setMarginMode":                        false,
			"setPositionMode":                      false,
			"transfer":                             true,
			"withdraw":                             false,
		},
		"timeframes": map[string]interface{}{
			"1m":  "1m",
			"5m":  "5m",
			"15m": "15m",
			"30m": "30m",
			"1h":  "1H",
			"4h":  "4H",
			"12h": "12H",
			"1d":  "1D",
			"1w":  "1W",
			"1M":  "1M",
			"1y":  "1Y",
		},
		"urls": map[string]interface{}{
			"logo": "https://github.com/user-attachments/assets/ddf3e178-c3b6-409d-8f9f-af8b7cf80454",
			"api": map[string]interface{}{
				"public":  "https://api.deepcoin.com",
				"private": "https://api.deepcoin.com",
			},
			"www": "https://www.deepcoin.com/",
			"doc": "https://www.deepcoin.com/docs",
			"referral": map[string]interface{}{
				"url":      "https://s.deepcoin.com/UzkyODgy",
				"discount": 0.1,
			},
		},
		"api": map[string]interface{}{
			"public": map[string]interface{}{
				"get": map[string]interface{}{
					"deepcoin/market/books":                         1,
					"deepcoin/market/candles":                       1,
					"deepcoin/market/instruments":                   1,
					"deepcoin/market/tickers":                       1,
					"deepcoin/market/index-candles":                 1,
					"deepcoin/market/trades":                        1,
					"deepcoin/market/mark-price-candles":            1,
					"deepcoin/market/step-margin":                   5,
					"deepcoin/trade/funding-rate":                   5,
					"deepcoin/trade/fund-rate/current-funding-rate": 5,
					"deepcoin/trade/fund-rate/history":              5,
				},
			},
			"private": map[string]interface{}{
				"get": map[string]interface{}{
					"deepcoin/account/balances":                5,
					"deepcoin/account/bills":                   5,
					"deepcoin/account/positions":               5,
					"deepcoin/trade/fills":                     5,
					"deepcoin/trade/orderByID":                 5,
					"deepcoin/trade/finishOrderByID":           5,
					"deepcoin/trade/orders-history":            5,
					"deepcoin/trade/v2/orders-pending":         5,
					"deepcoin/trade/trigger-orders-pending":    5,
					"deepcoin/trade/trigger-orders-history":    5,
					"deepcoin/copytrading/support-contracts":   5,
					"deepcoin/copytrading/leader-position":     5,
					"deepcoin/copytrading/estimate-profit":     5,
					"deepcoin/copytrading/history-profit":      5,
					"deepcoin/copytrading/follower-rank":       5,
					"deepcoin/internal-transfer/support":       5,
					"deepcoin/internal-transfer/history-order": 5,
					"deepcoin/rebate/config":                   5,
					"deepcoin/agents/users":                    5,
					"deepcoin/agents/users/rebate-list":        5,
					"deepcoin/agents/users/rebates":            5,
					"deepcoin/asset/deposit-list":              5,
					"deepcoin/asset/withdraw-list":             5,
					"deepcoin/asset/recharge-chain-list":       5,
					"deepcoin/listenkey/acquire":               5,
					"deepcoin/listenkey/extend":                5,
				},
				"post": map[string]interface{}{
					"deepcoin/account/set-leverage":        5,
					"deepcoin/trade/order":                 5,
					"deepcoin/trade/replace-order":         5,
					"deepcoin/trade/cancel-order":          5,
					"deepcoin/trade/batch-cancel-order":    5,
					"deepcoin/trade/cancel-trigger-order":  Divide(1, 6),
					"deepcoin/trade/swap/cancel-all":       5,
					"deepcoin/trade/trigger-order":         5,
					"deepcoin/trade/batch-close-position":  5,
					"deepcoin/trade/replace-order-sltp":    5,
					"deepcoin/trade/close-position-by-ids": 5,
					"deepcoin/copytrading/leader-settings": 5,
					"deepcoin/copytrading/set-contracts":   5,
					"deepcoin/internal-transfer":           5,
					"deepcoin/rebate/config":               5,
					"deepcoin/asset/transfer":              5,
				},
			},
		},
		"fees": map[string]interface{}{
			"trading": map[string]interface{}{
				"taker": this.ParseNumber("0.0015"),
				"maker": this.ParseNumber("0.0010"),
			},
		},
		"features": map[string]interface{}{
			"spot": map[string]interface{}{
				"sandbox": false,
				"createOrder": map[string]interface{}{
					"marginMode":   true,
					"triggerPrice": true,
					"triggerPriceType": map[string]interface{}{
						"last":  true,
						"mark":  false,
						"index": false,
					},
					"triggerDirection": false,
					"stopLossPrice":    true,
					"takeProfitPrice":  true,
					"attachedStopLossTakeProfit": map[string]interface{}{
						"triggerPriceType": map[string]interface{}{
							"last":  false,
							"mark":  false,
							"index": false,
						},
						"price": true,
					},
					"timeInForce": map[string]interface{}{
						"IOC": true,
						"FOK": true,
						"PO":  true,
						"GTD": false,
					},
					"hedged":                 true,
					"trailing":               false,
					"marketBuyRequiresPrice": false,
				},
				"createOrders": nil,
				"fetchMyTrades": map[string]interface{}{
					"marginMode":     false,
					"limit":          100,
					"daysBack":       60,
					"untilDays":      nil,
					"symbolRequired": true,
				},
				"fetchOrder": nil,
				"fetchOpenOrders": map[string]interface{}{
					"marginMode":     false,
					"limit":          100,
					"trigger":        true,
					"trailing":       false,
					"symbolRequired": true,
				},
				"fetchOrders": nil,
				"fetchClosedOrders": map[string]interface{}{
					"marginMode":       false,
					"limit":            100,
					"daysBack":         nil,
					"daysBackCanceled": nil,
					"untilDays":        nil,
					"trigger":          true,
					"trailing":         false,
					"symbolRequired":   true,
				},
				"fetchOHLCV": map[string]interface{}{
					"limit": 300,
				},
			},
			"swap": map[string]interface{}{
				"linear": map[string]interface{}{
					"extends": "spot",
				},
				"inverse": map[string]interface{}{
					"extends": "spot",
				},
			},
		},
		"requiredCredentials": map[string]interface{}{
			"apiKey":   true,
			"secret":   true,
			"password": true,
		},
		"precisionMode": TICK_SIZE,
		"options": map[string]interface{}{
			"recvWindow": 5000,
			"defaultNetworks": map[string]interface{}{
				"ETH":  "ERC20",
				"USDT": "TRC20",
				"USDC": "ERC20",
			},
			"networks": map[string]interface{}{
				"ERC20": "ERC20",
				"TRC20": "TRC20",
				"ARB":   "ARBITRUM",
				"BSC":   "BSC(BEP20)",
				"SOL":   "SOL",
				"BTC":   "Bitcoin",
				"ADA":   "Cardano",
			},
			"networksById": map[string]interface{}{},
			"fetchMarkets": map[string]interface{}{
				"types": []interface{}{"spot", "swap"},
			},
			"timeInForce": map[string]interface{}{
				"GTC": "GTC",
				"IOC": "IOC",
				"PO":  "PO",
			},
			"exchangeType": map[string]interface{}{
				"spot": "SPOT",
				"swap": "SWAP",
				"SPOT": "SPOT",
				"SWAP": "SWAP",
			},
			"accountsByType": map[string]interface{}{
				"spot":    1,
				"fund":    2,
				"rebate":  3,
				"inverse": 5,
				"linear":  7,
				"demo":    10,
			},
		},
		"commonCurrencies": map[string]interface{}{},
		"exceptions": map[string]interface{}{
			"exact": map[string]interface{}{
				"24":                OrderNotFound,
				"31":                InsufficientFunds,
				"36":                InsufficientFunds,
				"44":                BadRequest,
				"49":                InvalidOrder,
				"194":               InvalidOrder,
				"195":               InvalidOrder,
				"199":               BadRequest,
				"100010":            InsufficientFunds,
				"unsupportedAction": BadRequest,
				"localIDNotExist":   BadRequest,
			},
			"broad": map[string]interface{}{
				"no available":                            NotSupported,
				"field is required":                       ArgumentsRequired,
				"not in acceptable range":                 BadRequest,
				"subscription cluster does not \"exist\"": BadRequest,
				"must be equal or lesser than":            BadRequest,
			},
		},
	})
}
func (this *DeepcoinCore) HandleMarketTypeAndParams(methodName interface{}, optionalArgs ...interface{}) interface{} {
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	params := GetArg(optionalArgs, 1, map[string]interface{}{})
	_ = params
	defaultValue := GetArg(optionalArgs, 2, nil)
	_ = defaultValue
	var instType interface{} = this.SafeString(params, "instType")
	params = this.Omit(params, "instType")
	var typeVar interface{} = this.SafeString(params, "type")
	if IsTrue(IsTrue((IsEqual(typeVar, nil))) && IsTrue((!IsEqual(instType, nil)))) {
		params = this.Extend(params, map[string]interface{}{
			"type": instType,
		})
	}
	return this.Exchange.HandleMarketTypeAndParams(methodName, market, params, defaultValue)
}
func (this *DeepcoinCore) ConvertToInstrumentType(typeVar interface{}) interface{} {
	var exchangeTypes interface{} = this.SafeDict(this.Options, "exchangeType", map[string]interface{}{})
	return this.SafeString(exchangeTypes, typeVar, typeVar)
}

/**
 * @method
 * @name deepcoin#fetchMarkets
 * @see https://www.deepcoin.com/docs/DeepCoinMarket/getBaseInfo
 * @description retrieves data on all markets for okcoin
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func (this *DeepcoinCore) FetchMarkets(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		var types interface{} = []interface{}{"spot", "swap"}
		var fetchMarketsOption interface{} = this.SafeDict(this.Options, "fetchMarkets")
		if IsTrue(!IsEqual(fetchMarketsOption, nil)) {
			types = this.SafeList(fetchMarketsOption, "types", types)
		} else {
			types = this.SafeList(this.Options, "fetchMarkets", types) // backward-support
		}
		var promises interface{} = []interface{}{}
		var result interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(types)); i++ {
			AppendToArray(&promises, this.FetchMarketsByType(GetValue(types, i), params))
		}

		promises = (<-promiseAll(promises))
		PanicOnError(promises)
		for i := 0; IsLessThan(i, GetArrayLength(promises)); i++ {
			result = this.ArrayConcat(result, GetValue(promises, i))
		}

		ch <- result
		return nil

	}()
	return ch
}
func (this *DeepcoinCore) FetchMarketsByType(typeVar interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		var request interface{} = map[string]interface{}{
			"instType": this.ConvertToInstrumentType(typeVar),
		}

		response := (<-this.PublicGetDeepcoinMarketInstruments(this.Extend(request, params)))
		PanicOnError(response)
		//
		// spot
		//
		//     {
		//         "code": "0",
		//         "msg": "",
		//         "data": [
		//             {
		//                 "instType": "SPOT",
		//                 "instId": "A-USDT",
		//                 "uly": "",
		//                 "baseCcy": "A",
		//                 "quoteCcy": "USDT",
		//                 "ctVal": "1",
		//                 "ctValCcy": "",
		//                 "listTime": "0",
		//                 "lever": "1",
		//                 "tickSz": "0.0001",
		//                 "lotSz": "0.001",
		//                 "minSz": "0.5",
		//                 "ctType": "",
		//                 "alias": "",
		//                 "state": "live",
		//                 "maxLmtSz": "7692307",
		//                 "maxMktSz": "7692307"
		//             }
		//         ]
		//     }
		//
		var dataResponse interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseMarkets(dataResponse)
		return nil

	}()
	return ch
}
func (this *DeepcoinCore) ParseMarket(market interface{}) interface{} {
	//
	// spot markets
	//
	//     {
	//         "instType": "SPOT",
	//         "instId": "A-USDT",
	//         "uly": "",
	//         "baseCcy": "A",
	//         "quoteCcy": "USDT",
	//         "ctVal": "1",
	//         "ctValCcy": "",
	//         "listTime": "0",
	//         "lever": "1",
	//         "tickSz": "0.0001",
	//         "lotSz": "0.001",
	//         "minSz": "0.5",
	//         "ctType": "",
	//         "alias": "",
	//         "state": "live",
	//         "maxLmtSz": "7692307",
	//         "maxMktSz": "7692307"
	//     }
	//
	// swap markets
	//
	//     {
	//         "instType": "SWAP",
	//         "instId": "ZORA-USDT-SWAP",
	//         "uly": "",
	//         "baseCcy": "ZORA",
	//         "quoteCcy": "USDT",
	//         "ctVal": "1",
	//         "ctValCcy": "",
	//         "listTime": "0",
	//         "lever": "20",
	//         "tickSz": "0.00001",
	//         "lotSz": "1",
	//         "minSz": "1685",
	//         "ctType": "",
	//         "alias": "",
	//         "state": "live",
	//         "maxLmtSz": "10000000",
	//         "maxMktSz": "10000000"
	//     }
	//
	var id interface{} = this.SafeString(market, "instId")
	var typeVar interface{} = this.SafeStringLower(market, "instType")
	var spot interface{} = (IsEqual(typeVar, "spot"))
	var swap interface{} = (IsEqual(typeVar, "swap"))
	var baseId interface{} = this.SafeString(market, "baseCcy")
	var quoteId interface{} = this.SafeString(market, "quoteCcy", "")
	var settleId interface{} = nil
	var settle interface{} = nil
	var base interface{} = this.SafeCurrencyCode(baseId)
	var quote interface{} = this.SafeCurrencyCode(quoteId)
	var symbol interface{} = Add(Add(base, "/"), quote)
	var isLinear interface{} = nil
	if IsTrue(swap) {
		isLinear = (!IsEqual(quoteId, "USD"))
		settleId = Ternary(IsTrue(isLinear), quoteId, baseId)
		settle = this.SafeCurrencyCode(settleId)
		symbol = Add(Add(symbol, ":"), settle)
	}
	var fees interface{} = this.SafeDict2(this.Fees, typeVar, "trading", map[string]interface{}{})
	var maxLeverage interface{} = this.SafeString(market, "lever", "1")
	maxLeverage = Precise.StringMax(maxLeverage, "1")
	var maxMarketSize interface{} = this.SafeString(market, "maxMktSz")
	var maxLimitSize interface{} = this.SafeString(market, "maxLmtSz")
	var maxAmount interface{} = this.ParseNumber(Precise.StringMax(maxMarketSize, maxLimitSize))
	var state interface{} = this.SafeString(market, "state")
	return this.Extend(fees, map[string]interface{}{
		"id":             id,
		"symbol":         symbol,
		"base":           base,
		"quote":          quote,
		"settle":         settle,
		"baseId":         baseId,
		"quoteId":        quoteId,
		"settleId":       settleId,
		"type":           typeVar,
		"spot":           spot,
		"margin":         IsTrue(spot) && IsTrue((Precise.StringGt(maxLeverage, "1"))),
		"swap":           swap,
		"future":         false,
		"option":         false,
		"active":         IsEqual(state, "live"),
		"contract":       swap,
		"linear":         isLinear,
		"inverse":        Ternary(IsTrue(swap), (!IsTrue(isLinear)), nil),
		"contractSize":   Ternary(IsTrue(swap), this.SafeNumber(market, "ctVal"), nil),
		"expiry":         nil,
		"expiryDatetime": nil,
		"strike":         nil,
		"optionType":     nil,
		"created":        nil,
		"precision": map[string]interface{}{
			"amount": this.SafeNumber(market, "lotSz"),
			"price":  this.SafeNumber(market, "tickSz"),
		},
		"limits": map[string]interface{}{
			"leverage": map[string]interface{}{
				"min": this.ParseNumber("1"),
				"max": this.ParseNumber(maxLeverage),
			},
			"amount": map[string]interface{}{
				"min": this.SafeNumber(market, "minSz"),
				"max": maxAmount,
			},
			"price": map[string]interface{}{
				"min": nil,
				"max": nil,
			},
			"cost": map[string]interface{}{
				"min": nil,
				"max": nil,
			},
		},
		"info": market,
	})
}
func (this *DeepcoinCore) SetMarkets(markets interface{}, optionalArgs ...interface{}) interface{} {
	currencies := GetArg(optionalArgs, 0, nil)
	_ = currencies
	markets = this.Exchange.SetMarkets(markets, currencies)
	var symbols interface{} = ObjectKeys(markets)
	for i := 0; IsLessThan(i, GetArrayLength(symbols)); i++ {
		var symbol interface{} = GetValue(symbols, i)
		var market interface{} = GetValue(markets, symbol)
		if IsTrue(GetValue(market, "swap")) {
			var additionalId interface{} = Add(GetValue(market, "baseId"), GetValue(market, "quoteId"))
			AddElementToObject(this.Markets_by_id, additionalId, []interface{}{market}) // some endpoints return swap market id as base+quote
		}
	}
	return this.Markets
}

/**
 * @method
 * @name deepcoin#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://www.deepcoin.com/docs/DeepCoinMarket/marketBooks
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func (this *DeepcoinCore) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		limit := GetArg(optionalArgs, 0, nil)
		_ = limit
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes5968 := (<-this.LoadMarkets())
		PanicOnError(retRes5968)
		var market interface{} = this.Market(symbol)
		if IsTrue(IsEqual(limit, nil)) {
			limit = 400
		}
		var request interface{} = map[string]interface{}{
			"instId": GetValue(market, "id"),
			"sz":     limit,
		}

		response := (<-this.PublicGetDeepcoinMarketBooks(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "0",
		//         "msg": "",
		//         "data": {
		//             "bids": [
		//                 ["3732.21", "99.6"],
		//                 ["3732.2", "54.7"]
		//             ],
		//             "asks": [
		//                 ["3732.22", "85.1"],
		//                 ["3732.23", "49.4"]
		//             ]
		//         }
		//     }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})

		ch <- this.ParseOrderBook(data, symbol, nil, "bids", "asks", 0, 1)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name deepcoin#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://www.deepcoin.com/docs/DeepCoinMarket/getKlineData
 * @see https://www.deepcoin.com/docs/DeepCoinMarket/getIndexKlineData
 * @see https://www.deepcoin.com/docs/DeepCoinMarket/getMarkKlineData
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest candle to fetch
 * @param {string} [params.price] "mark" or "index" for mark price and index price candles
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func (this *DeepcoinCore) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		timeframe := GetArg(optionalArgs, 0, "1m")
		_ = timeframe
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes6448 := (<-this.LoadMarkets())
		PanicOnError(retRes6448)
		var maxLimit interface{} = 300
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchOHLCV", "paginate", false)
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {
			params = this.Extend(params, map[string]interface{}{
				"calculateUntil": true,
			})

			retRes65019 := (<-this.FetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, params, maxLimit))
			PanicOnError(retRes65019)
			ch <- retRes65019
			return nil
		}
		var market interface{} = this.Market(symbol)
		var price interface{} = this.SafeString(params, "price")
		params = this.Omit(params, "price")
		var bar interface{} = this.SafeString(this.Timeframes, timeframe, timeframe)
		var request interface{} = map[string]interface{}{
			"instId": GetValue(market, "id"),
			"bar":    bar,
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}
		var until interface{} = this.SafeInteger(params, "until")
		if IsTrue(!IsEqual(until, nil)) {
			AddElementToObject(request, "after", until)
			params = this.Omit(params, "until")
		}
		var calculateUntil interface{} = this.SafeBool(params, "calculateUntil", false)
		if IsTrue(calculateUntil) {
			params = this.Omit(params, "calculateUntil")
			if IsTrue(!IsEqual(since, nil)) {
				// the exchange do not have a since param for this endpoint
				// we canlculate until (after) for correct pagination
				var duration interface{} = this.ParseTimeframe(timeframe)
				var numberOfCandles interface{} = Ternary(IsTrue((IsEqual(limit, nil))), maxLimit, limit)
				var endTime interface{} = Add(since, Multiply((Multiply(duration, numberOfCandles)), 1000))
				if IsTrue(!IsEqual(until, nil)) {
					endTime = mathMin(endTime, until)
				}
				var now interface{} = this.Milliseconds()
				AddElementToObject(request, "after", mathMin(endTime, now))
			}
		}
		var response interface{} = nil
		if IsTrue(IsEqual(price, "mark")) {

			response = (<-this.PublicGetDeepcoinMarketMarkPriceCandles(this.Extend(request, params)))
			PanicOnError(response)
		} else if IsTrue(IsEqual(price, "index")) {

			response = (<-this.PublicGetDeepcoinMarketIndexCandles(this.Extend(request, params)))
			PanicOnError(response)
		} else {

			response = (<-this.PublicGetDeepcoinMarketCandles(this.Extend(request, params)))
			PanicOnError(response)
		}
		//
		//     {
		//         "code": "0",
		//         "msg": "",
		//         "data":[
		//             [
		//                 "1760221800000",
		//                 "3739.08",
		//                 "3741.95",
		//                 "3737.75",
		//                 "3740.1",
		//                 "2849",
		//                 "1065583.744"
		//             ],
		//             [
		//                 "1760221740000",
		//                 "3742.36",
		//                 "3743.01",
		//                 "3736.83",
		//                 "3739.08",
		//                 "2723",
		//                 "1018290.723"
		//             ]
		//         ]
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseOHLCVs(data, market, timeframe, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name deepcoin#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://www.deepcoin.com/docs/DeepCoinMarket/getMarketTickers
 * @param {string[]} [symbols] unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func (this *DeepcoinCore) FetchTickers(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes7328 := (<-this.LoadMarkets())
		PanicOnError(retRes7328)
		symbols = this.MarketSymbols(symbols)
		var market interface{} = this.GetMarketFromSymbols(symbols)
		var marketType interface{} = nil
		marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchTickers", market, params)
		marketType = GetValue(marketTypeparamsVariable, 0)
		params = GetValue(marketTypeparamsVariable, 1)
		var request interface{} = map[string]interface{}{
			"instType": this.ConvertToInstrumentType(marketType),
		}

		response := (<-this.PublicGetDeepcoinMarketTickers(this.Extend(request, params)))
		PanicOnError(response)
		var tickers interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseTickers(tickers, symbols)
		return nil

	}()
	return ch
}
func (this *DeepcoinCore) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "instType": "SWAP",
	//         "instId": "BTC-USD-SWAP",
	//         "last": "114113.3",
	//         "lastSz": "",
	//         "askPx": "114113.5",
	//         "askSz": "56280",
	//         "bidPx": "114113.2",
	//         "bidSz": "63220",
	//         "open24h": "113214.7",
	//         "high24h": "116039.2",
	//         "low24h": "113214.7",
	//         "volCcy24h": "73.31475724",
	//         "vol24h": "8406739",
	//         "sodUtc0": "",
	//         "sodUtc8": "",
	//         "ts": "1760367816000"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var timestamp interface{} = this.SafeInteger(ticker, "ts")
	var marketId interface{} = this.SafeString(ticker, "instId")
	market = this.SafeMarket(marketId, market, "-")
	var symbol interface{} = GetValue(market, "symbol")
	var last interface{} = this.SafeString(ticker, "last")
	var open interface{} = this.SafeString(ticker, "open24h")
	var quoteVolume interface{} = this.SafeString(ticker, "volCcy24h")
	var baseVolume interface{} = this.SafeString(ticker, "vol24h")
	if IsTrue(IsTrue(GetValue(market, "swap")) && IsTrue(GetValue(market, "inverse"))) {
		var temp interface{} = baseVolume
		baseVolume = quoteVolume
		quoteVolume = temp
	}
	var high interface{} = this.SafeString(ticker, "high24h")
	var low interface{} = this.SafeString(ticker, "low24h")
	return this.SafeTicker(map[string]interface{}{
		"symbol":        symbol,
		"timestamp":     timestamp,
		"datetime":      this.Iso8601(timestamp),
		"high":          high,
		"low":           low,
		"bid":           this.SafeString(ticker, "bidPx"),
		"bidVolume":     this.SafeString(ticker, "bidSz"),
		"ask":           this.SafeString(ticker, "askPx"),
		"askVolume":     this.SafeString(ticker, "askSz"),
		"vwap":          nil,
		"open":          open,
		"close":         last,
		"last":          last,
		"previousClose": nil,
		"change":        nil,
		"percentage":    nil,
		"average":       nil,
		"baseVolume":    baseVolume,
		"quoteVolume":   quoteVolume,
		"markPrice":     nil,
		"indexPrice":    nil,
		"info":          ticker,
	}, market)
}

/**
 * @method
 * @name deepcoin#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://www.deepcoin.com/docs/DeepCoinMarket/getTrades
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch (default 100, max 500)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func (this *DeepcoinCore) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		since := GetArg(optionalArgs, 0, nil)
		_ = since
		limit := GetArg(optionalArgs, 1, nil)
		_ = limit
		params := GetArg(optionalArgs, 2, map[string]interface{}{})
		_ = params

		retRes8198 := (<-this.LoadMarkets())
		PanicOnError(retRes8198)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"instId": GetValue(market, "id"),
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit) // default 100, max 500
		}
		var productGroup interface{} = this.GetProductGroupFromMarket(market)
		AddElementToObject(request, "productGroup", productGroup)

		response := (<-this.PublicGetDeepcoinMarketTrades(this.Extend(request, params)))
		PanicOnError(response)
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseTrades(data, market, since, limit)
		return nil

	}()
	return ch
}
func (this *DeepcoinCore) GetProductGroupFromMarket(market interface{}) interface{} {
	var productGroup interface{} = "Spot"
	if IsTrue(GetValue(market, "swap")) {
		if IsTrue(GetValue(market, "linear")) {
			productGroup = "SwapU"
		} else {
			productGroup = "Swap"
		}
	}
	return productGroup
}
func (this *DeepcoinCore) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{} {
	//
	// public fetchTrades
	//
	//     {
	//         "instId": "ETH-USDT",
	//         "tradeId": "1001056388761321",
	//         "px": "4095.66",
	//         "sz": "0.01311251",
	//         "side": "sell",
	//         "ts": "1760367870000"
	//     }
	//
	// private fetchMyTrades
	//     {
	//         "instType": "SPOT",
	//         "instId": "ETH-USDT",
	//         "tradeId": "1001056429613610",
	//         "ordId": "1001435238208686",
	//         "clOrdId": "",
	//         "billId": "10010564296136101",
	//         "tag": "",
	//         "fillPx": "3791.15",
	//         "fillSz": "0.004",
	//         "side": "sell",
	//         "posSide": "",
	//         "execType": "",
	//         "feeCcy": "USDT",
	//         "fee": "0.0151646",
	//         "ts": "1760704540000"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(trade, "instId")
	market = this.SafeMarket(marketId, market)
	var timestamp interface{} = this.SafeInteger(trade, "ts")
	var side interface{} = this.SafeString(trade, "side")
	var execType interface{} = this.SafeString(trade, "execType")
	var fee interface{} = nil
	var feeCost interface{} = this.SafeString(trade, "fee")
	if IsTrue(!IsEqual(feeCost, nil)) {
		var feeCurrencyId interface{} = this.SafeString(trade, "feeCcy")
		var feeCurrencyCode interface{} = this.SafeCurrencyCode(feeCurrencyId)
		fee = map[string]interface{}{
			"cost":     feeCost,
			"currency": feeCurrencyCode,
		}
	}
	return this.SafeTrade(map[string]interface{}{
		"info":         trade,
		"timestamp":    timestamp,
		"datetime":     this.Iso8601(timestamp),
		"symbol":       GetValue(market, "symbol"),
		"id":           this.SafeString(trade, "tradeId"),
		"order":        this.SafeString(trade, "ordId"),
		"type":         nil,
		"takerOrMaker": this.ParseTakerOrMaker(execType),
		"side":         side,
		"price":        this.SafeString2(trade, "fillPx", "px"),
		"amount":       this.SafeString2(trade, "fillSz", "sz"),
		"cost":         nil,
		"fee":          fee,
	}, market)
}
func (this *DeepcoinCore) ParseTakerOrMaker(execType interface{}) interface{} {
	var types interface{} = map[string]interface{}{
		"T": "taker",
		"M": "maker",
	}
	return this.SafeString(types, execType, execType)
}

/**
 * @method
 * @name deepcoin#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://www.deepcoin.com/docs/DeepCoinAccount/getAccountBalance
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.type] "spot" or "swap", the market type for the balance
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/?id=balance-structure}
 */
func (this *DeepcoinCore) FetchBalance(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes9288 := (<-this.LoadMarkets())
		PanicOnError(retRes9288)
		var marketType interface{} = "spot"
		marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchBalance", nil, params, marketType)
		marketType = GetValue(marketTypeparamsVariable, 0)
		params = GetValue(marketTypeparamsVariable, 1)
		var request interface{} = map[string]interface{}{
			"instType": this.ConvertToInstrumentType(marketType),
		}

		response := (<-this.PrivateGetDeepcoinAccountBalances(this.Extend(request, params)))
		PanicOnError(response)

		ch <- this.ParseBalance(response)
		return nil

	}()
	return ch
}
func (this *DeepcoinCore) ParseBalance(response interface{}) interface{} {
	//
	//     {
	//         "code": "0",
	//         "msg": "",
	//         "data": [
	//             {
	//                 "ccy": "USDT",
	//                 "bal": "74",
	//                 "frozenBal": "0",
	//                 "availBal": "74"
	//             }
	//         ]
	//     }
	//
	var result interface{} = map[string]interface{}{
		"info":      response,
		"timestamp": nil,
		"datetime":  nil,
	}
	var balances interface{} = this.SafeList(response, "data", []interface{}{})
	for i := 0; IsLessThan(i, GetArrayLength(balances)); i++ {
		var balance interface{} = GetValue(balances, i)
		var symbol interface{} = this.SafeString(balance, "ccy")
		var code interface{} = this.SafeCurrencyCode(symbol)
		var account interface{} = this.Account()
		AddElementToObject(account, "total", this.SafeString(balance, "bal"))
		AddElementToObject(account, "used", this.SafeString(balance, "frozenBal"))
		AddElementToObject(account, "free", this.SafeString(balance, "availBal"))
		AddElementToObject(result, code, account)
	}
	return this.SafeBalance(result)
}

/**
 * @method
 * @name deepcoin#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://www.deepcoin.com/docs/assets/deposit
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch entries for
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/?id=transaction-structure}
 */
func (this *DeepcoinCore) FetchDeposits(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes9868 := (<-this.LoadMarkets())
		PanicOnError(retRes9868)
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchDeposits", "paginate", false)
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {

			retRes99019 := (<-this.FetchPaginatedCallCursor("fetchDeposits", code, since, limit, params, "code", nil, 1, 50))
			PanicOnError(retRes99019)
			ch <- retRes99019
			return nil
		}
		var request interface{} = map[string]interface{}{}
		var currency interface{} = nil
		if IsTrue(!IsEqual(code, nil)) {
			currency = this.Currency(code)
			AddElementToObject(request, "coin", GetValue(currency, "id"))
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "size", limit)
		}
		var until interface{} = this.SafeInteger(params, "until")
		if IsTrue(!IsEqual(until, nil)) {
			AddElementToObject(request, "endTime", until)
			params = this.Omit(params, "until")
		}

		response := (<-this.PrivateGetDeepcoinAssetDepositList(this.Extend(request, params)))
		PanicOnError(response)
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		var items interface{} = this.SafeList(data, "data", []interface{}{})
		var transactionParams interface{} = map[string]interface{}{
			"type": "deposit",
		}

		ch <- this.ParseTransactions(items, currency, since, limit, transactionParams)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name deepcoin#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @see https://www.deepcoin.com/docs/assets/withdraw
 * @param {string} code unified currency code of the currency transferred
 * @param {int} [since] the earliest time in ms to fetch transfers for (default 24 hours ago)
 * @param {int} [limit] the maximum number of transfer structures to retrieve (default 50, max 200)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch transfers for (default time now)
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/?id=transaction-structure}
 */
func (this *DeepcoinCore) FetchWithdrawals(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes10328 := (<-this.LoadMarkets())
		PanicOnError(retRes10328)
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchDeposits", "paginate", false)
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {

			retRes103619 := (<-this.FetchPaginatedCallCursor("fetchDeposits", code, since, limit, params, "code", nil, 1, 50))
			PanicOnError(retRes103619)
			ch <- retRes103619
			return nil
		}
		var request interface{} = map[string]interface{}{}
		var currency interface{} = nil
		if IsTrue(!IsEqual(code, nil)) {
			currency = this.Currency(code)
			AddElementToObject(request, "coin", GetValue(currency, "id"))
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "size", limit)
		}
		var until interface{} = this.SafeInteger(params, "until")
		if IsTrue(!IsEqual(until, nil)) {
			AddElementToObject(request, "endTime", until)
			params = this.Omit(params, "until")
		}

		response := (<-this.PrivateGetDeepcoinAssetWithdrawList(this.Extend(request, params)))
		PanicOnError(response)
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		var items interface{} = this.SafeList(data, "data", []interface{}{})
		var transactionParams interface{} = map[string]interface{}{
			"type": "withdrawal",
		}

		ch <- this.ParseTransactions(items, currency, since, limit, transactionParams)
		return nil

	}()
	return ch
}
func (this *DeepcoinCore) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{} {
	//
	// fetchDeposits
	//     {
	//         "createTime": 1760368656,
	//         "txHash": "03fe3244d89e794586222413c61779380da9e9fe5baaa253c38d01a4199a3499",
	//         "chainName": "TRC20",
	//         "amount": "149",
	//         "coin": "USDT",
	//         "status": "succeed"
	//     }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var txid interface{} = this.SafeString(transaction, "txHash")
	var currencyId interface{} = this.SafeString(transaction, "coin")
	var code interface{} = this.SafeCurrencyCode(currencyId, currency)
	var amount interface{} = this.SafeNumber(transaction, "amount")
	var timestamp interface{} = this.SafeTimestamp(transaction, "createTime")
	var networkId interface{} = this.SafeString(transaction, "chainName")
	var network interface{} = this.NetworkIdToCode(networkId)
	var status interface{} = this.ParseTransactionStatus(this.SafeString(transaction, "status"))
	return map[string]interface{}{
		"info":        transaction,
		"id":          nil,
		"currency":    code,
		"amount":      amount,
		"network":     network,
		"addressFrom": nil,
		"addressTo":   nil,
		"address":     this.SafeString(transaction, "address"),
		"tagFrom":     nil,
		"tagTo":       nil,
		"tag":         nil,
		"status":      status,
		"type":        nil,
		"updated":     nil,
		"txid":        txid,
		"timestamp":   timestamp,
		"datetime":    this.Iso8601(timestamp),
		"internal":    nil,
		"comment":     nil,
		"fee": map[string]interface{}{
			"currency": nil,
			"cost":     nil,
		},
	}
}
func (this *DeepcoinCore) ParseTransactionStatus(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"confirming": "pending",
		"succeed":    "ok",
	}
	return this.SafeString(statuses, status, status)
}

/**
 * @method
 * @name deepcoin#fetchDepositAddresses
 * @description fetch deposit addresses for multiple currencies and chain types
 * @see https://www.deepcoin.com/docs/assets/chainlist
 * @param {string[]|undefined} codes list of unified currency codes, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [address structures]{@link https://docs.ccxt.com/?id=address-structure}
 */
func (this *DeepcoinCore) FetchDepositAddresses(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		codes := GetArg(optionalArgs, 0, nil)
		_ = codes
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes11298 := (<-this.LoadMarkets())
		PanicOnError(retRes11298)
		if IsTrue(IsEqual(codes, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchDepositAddresses requires a list with one currency code")))
		}
		var length interface{} = GetArrayLength(codes)
		if IsTrue(!IsEqual(length, 1)) {
			panic(NotSupported(Add(this.Id, " fetchDepositAddresses requires a list with one currency code")))
		}
		var code interface{} = GetValue(codes, 0)
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"currency_id": GetValue(currency, "id"),
			"lang":        "en",
		}

		response := (<-this.PrivateGetDeepcoinAssetRechargeChainList(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "0",
		//         "msg": "",
		//         "data": {
		//             "list": [
		//                 {
		//                     "chain": "TRC20",
		//                     "state": 1,
		//                     "remind": "Only support deposits and withdrawals via TRC20 network. If you send it via other address by mistake, it will not be credited and will result in the permanent loss of your deposit.",
		//                     "inNotice": "",
		//                     "actLogo": "",
		//                     "address": "TNJYDW9Bk87VwfA6s7FtxURLEMHesQbYgF",
		//                     "hasMemo": false,
		//                     "memo": "",
		//                     "estimatedTime": 1,
		//                     "fastConfig": {
		//                         "fastLimitNum": 0,
		//                         "fastBlock": 10,
		//                         "realBlock": 1
		//                     }
		//                 }
		//             ]
		//         }
		//     }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		var list interface{} = this.SafeList(data, "list", []interface{}{})
		var additionalParams interface{} = map[string]interface{}{
			"currency": code,
		}

		ch <- this.ParseDepositAddresses(list, codes, false, additionalParams)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name deepcoin#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account
 * @see https://www.deepcoin.com/docs/assets/chainlist
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.network] unified network code for deposit chain
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/?id=address-structure}
 */
func (this *DeepcoinCore) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes11898 := (<-this.LoadMarkets())
		PanicOnError(retRes11898)
		var network interface{} = this.SafeString(params, "network")
		var defaultNetworks interface{} = this.SafeDict(this.Options, "defaultNetworks", map[string]interface{}{})
		var defaultNetwork interface{} = this.SafeString(defaultNetworks, code)
		network = Ternary(IsTrue(network), network, defaultNetwork)
		if IsTrue(!IsEqual(network, nil)) {
			params = this.Omit(params, "network")
		}

		addressess := (<-this.FetchDepositAddresses([]interface{}{code}, params))
		PanicOnError(addressess)
		var length interface{} = GetArrayLength(addressess)
		var address interface{} = this.SafeDict(addressess, 0, map[string]interface{}{})
		if IsTrue(IsTrue((!IsEqual(network, nil))) && IsTrue((IsGreaterThan(length, 1)))) {
			for i := 0; IsLessThan(i, length); i++ {
				var entry interface{} = GetValue(addressess, i)
				if IsTrue(IsEqual(GetValue(entry, "network"), network)) {
					address = entry
				}
			}
		}

		ch <- address
		return nil

	}()
	return ch
}
func (this *DeepcoinCore) ParseDepositAddress(response interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "chain": "TRC20",
	//         "state": 1,
	//         "remind": "Only support deposits and withdrawals via TRC20 network. If you send it via other address by mistake, it will not be credited and will result in the permanent loss of your deposit.",
	//         "inNotice": "",
	//         "actLogo": "",
	//         "address": "TNJYDW9Bk87VwfA6s7FtxURLEMHesQbYgF",
	//         "hasMemo": false,
	//         "memo": "",
	//         "estimatedTime": 1,
	//         "fastConfig": {
	//             "fastLimitNum": 0,
	//             "fastBlock": 10,
	//             "realBlock": 1
	//         }
	//     }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var chain interface{} = this.SafeString(response, "chain")
	var address interface{} = this.SafeString(response, "address")
	this.CheckAddress(address)
	return map[string]interface{}{
		"info":     response,
		"currency": nil,
		"network":  this.NetworkIdToCode(chain),
		"address":  address,
		"tag":      this.SafeString(response, "memo"),
	}
}

/**
 * @method
 * @name deepcoin#fetchLedger
 * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
 * @see https://www.deepcoin.com/docs/DeepCoinAccount/getAccountBills
 * @param {string} [code] unified currency code
 * @param {int} [since] timestamp in ms of the earliest ledger entry
 * @param {int} [limit] max number of ledger entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest ledger entry
 * @param {string} [params.type] 'spot' or 'swap', the market type for the ledger (default 'spot')
 * @returns {object[]} a list of [ledger structures]{@link https://docs.ccxt.com/?id=ledger}
 */
func (this *DeepcoinCore) FetchLedger(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes12568 := (<-this.LoadMarkets())
		PanicOnError(retRes12568)
		var marketType interface{} = "spot"
		marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchLedger", nil, params, marketType)
		marketType = GetValue(marketTypeparamsVariable, 0)
		params = GetValue(marketTypeparamsVariable, 1)
		var request interface{} = map[string]interface{}{
			"instType": this.ConvertToInstrumentType(marketType),
		}
		var currency interface{} = nil
		if IsTrue(!IsEqual(code, nil)) {
			currency = this.Currency(code)
			AddElementToObject(request, "ccy", GetValue(currency, "id"))
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "after", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}
		var until interface{} = this.SafeInteger(params, "until")
		if IsTrue(!IsEqual(until, nil)) {
			AddElementToObject(request, "before", until)
			params = this.Omit(params, "until")
		}

		response := (<-this.PrivateGetDeepcoinAccountBills(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "0",
		//         "msg": "",
		//         "data": [
		//             {
		//                 "billId": "1001044652247714",
		//                 "ccy": "USDT",
		//                 "clientId": "",
		//                 "balChg": "-0.03543537",
		//                 "bal": "72.41881427",
		//                 "type": "5",
		//                 "ts": "1761047448000"
		//             },
		//             {
		//                 "billId": "1001044652258368",
		//                 "ccy": "DOGE",
		//                 "clientId": "",
		//                 "balChg": "76",
		//                 "bal": "76",
		//                 "type": "2",
		//                 "ts": "1761051006000"
		//             }
		//         ]
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseLedger(data, currency, since, limit)
		return nil

	}()
	return ch
}
func (this *DeepcoinCore) ParseLedgerEntry(item interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "billId": "1001044652247714",
	//         "ccy": "USDT",
	//         "clientId": "",
	//         "balChg": "-0.03543537",
	//         "bal": "72.41881427",
	//         "type": "5",
	//         "ts": "1761047448000"
	//     }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var timestamp interface{} = this.SafeInteger(item, "ts")
	var change interface{} = this.SafeString(item, "balChg")
	var amount interface{} = Precise.StringAbs(change)
	var direction interface{} = Ternary(IsTrue(Precise.StringLt(change, "0")), "out", "in")
	var currencyId interface{} = this.SafeString(item, "ccy")
	currency = this.SafeCurrency(currencyId, currency)
	var typeVar interface{} = this.SafeString(item, "type")
	return this.SafeLedgerEntry(map[string]interface{}{
		"info":             item,
		"id":               this.SafeString(item, "billId"),
		"direction":        direction,
		"account":          nil,
		"referenceAccount": nil,
		"referenceId":      nil,
		"type":             this.ParseLedgerEntryType(typeVar),
		"currency":         GetValue(currency, "code"),
		"amount":           amount,
		"timestamp":        timestamp,
		"datetime":         this.Iso8601(timestamp),
		"before":           nil,
		"after":            this.SafeString(item, "bal"),
		"status":           nil,
		"fee":              nil,
	}, currency)
}
func (this *DeepcoinCore) ParseLedgerEntryType(typeVar interface{}) interface{} {
	var ledgerType interface{} = map[string]interface{}{
		"1": "trade",
		"2": "trade",
		"3": "transfer",
		"4": "transfer",
		"5": "fee",
	}
	return this.SafeString(ledgerType, typeVar, typeVar)
}

/**
 * @method
 * @name deepcoin#transfer
 * @description transfer currency internally between wallets on the same account
 * @see https://www.deepcoin.com/docs/assets/transfer
 * @param {string} code unified currency code
 * @param {float} amount amount to transfer
 * @param {string} fromAccount account to transfer from ('spot', 'inverse', 'linear', 'fund', 'rebate' or 'demo')
 * @param {string} toAccount account to transfer to ('spot', 'inverse', 'linear', 'fund', 'rebate' or 'demo')
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.userId] user id
 * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/?id=transfer-structure}
 */
func (this *DeepcoinCore) Transfer(code interface{}, amount interface{}, fromAccount interface{}, toAccount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		var userId interface{} = nil
		userIdparamsVariable := this.HandleOptionAndParams(params, "transfer", "userId")
		userId = GetValue(userIdparamsVariable, 0)
		params = GetValue(userIdparamsVariable, 1)
		userId = Ternary(IsTrue(userId), userId, this.SafeString(params, "uid"))
		if IsTrue(IsEqual(userId, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " transfer() requires a userId parameter")))
		}

		retRes13788 := (<-this.LoadMarkets())
		PanicOnError(retRes13788)
		var currency interface{} = this.Currency(code)
		var accountsByType interface{} = this.SafeDict(this.Options, "accountsByType", map[string]interface{}{})
		var fromId interface{} = this.SafeString(accountsByType, fromAccount, fromAccount)
		var toId interface{} = this.SafeString(accountsByType, toAccount, toAccount)
		var request interface{} = map[string]interface{}{
			"currency_id": GetValue(currency, "id"),
			"amount":      this.CurrencyToPrecision(code, amount),
			"from_id":     fromId,
			"to_id":       toId,
			"uid":         userId,
		}

		response := (<-this.PrivatePostDeepcoinAssetTransfer(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "0",
		//         "msg": "",
		//         "data": {
		//             "retCode": 0,
		//             "retMsg": "",
		//             "retData": {}
		//         }
		//     }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		var transfer interface{} = this.ParseTransfer(data, currency)
		var transferOptions interface{} = this.SafeDict(this.Options, "transfer", map[string]interface{}{})
		var fillResponseFromRequest interface{} = this.SafeBool(transferOptions, "fillResponseFromRequest", true)
		if IsTrue(fillResponseFromRequest) {
			AddElementToObject(transfer, "fromAccount", fromAccount)
			AddElementToObject(transfer, "toAccount", toAccount)
			AddElementToObject(transfer, "amount", amount)
		}

		ch <- transfer
		return nil

	}()
	return ch
}
func (this *DeepcoinCore) ParseTransfer(transfer interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "retCode": 0,
	//         "retMsg": "",
	//         "retData": {}
	//     }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var status interface{} = this.SafeString(transfer, "retCode")
	var currencyCode interface{} = this.SafeCurrencyCode(nil, currency)
	return map[string]interface{}{
		"info":        transfer,
		"id":          nil,
		"timestamp":   nil,
		"datetime":    nil,
		"currency":    currencyCode,
		"amount":      nil,
		"fromAccount": nil,
		"toAccount":   nil,
		"status":      this.ParseTransferStatus(status),
	}
}
func (this *DeepcoinCore) ParseTransferStatus(status interface{}) interface{} {
	if IsTrue(IsEqual(status, "0")) {
		return "ok"
	}
	return "failed"
}

/**
 * @method
 * @name deepcoin#createOrder
 * @description create a trade order
 * @see https://www.deepcoin.com/docs/DeepCoinTrade/order
 * @see https://www.deepcoin.com/docs/DeepCoinTrade/triggerOrder
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.clientOrderId] a unique id for the order
 * @param {string} [params.timeInForce] *non trigger orders only* 'GTC' (Good Till Cancel), 'IOC' (Immediate Or Cancel) or 'PO' (Post Only)
 * @param {bool} [params.postOnly] *non trigger orders only* true to place a post only order
 * @param {bool} [params.reduceOnly] *non trigger orders only* a mark to reduce the position size for margin, swap and future orders
 * @param {float} [params.triggerPrice] the price a trigger order is triggered at
 * @param {float} [params.stopLoss.triggerPrice] the price that a stop loss order is triggered at
 * @param {float} [params.takeProfit.triggerPrice] the price that a take profit order is triggered at
 * @param {string} [params.positionSide] if position mode is one-way: set to 'net', if position mode is hedge-mode: set to 'long' or 'short'
 * @param {bool} [params.hedged] *swap only* true for hedged mode, false for one way mode
 * @param {string} [params.marginMode] *swap only*'cross' or 'isolated', the default is 'cash' for spot and 'cross' for swap
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *DeepcoinCore) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		price := GetArg(optionalArgs, 0, nil)
		_ = price
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes14698 := (<-this.LoadMarkets())
		PanicOnError(retRes14698)
		var market interface{} = this.Market(symbol)
		var triggerPrice interface{} = this.SafeString(params, "triggerPrice")
		var request interface{} = this.CreateOrderRequest(symbol, typeVar, side, amount, price, params)
		var response interface{} = nil
		if IsTrue(!IsEqual(triggerPrice, nil)) {
			// trigger orders

			response = (<-this.PrivatePostDeepcoinTradeTriggerOrder(request))
			PanicOnError(response)
		} else {
			// regular orders
			//
			//     {
			//         "code": "0",
			//         "msg": "",
			//         "data": {
			//             "ordId": "1001434570213727",
			//             "clOrdId": "",
			//             "tag": "",
			//             "sCode": "0",
			//             "sMsg": ""
			//         }
			//     }
			//

			response = (<-this.PrivatePostDeepcoinTradeOrder(request))
			PanicOnError(response)
		}
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})

		ch <- this.ParseOrder(data, market)
		return nil

	}()
	return ch
}
func (this *DeepcoinCore) CreateOrderRequest(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{} {
	/**
	 * @method
	 * @ignore
	 * @name deepcoin#createOrderRequest
	 * @description helper function to build request
	 */
	price := GetArg(optionalArgs, 0, nil)
	_ = price
	params := GetArg(optionalArgs, 1, map[string]interface{}{})
	_ = params
	var market interface{} = this.Market(symbol)
	var triggerPrice interface{} = this.SafeString(params, "triggerPrice")
	// const isTriggerOrder = (triggerPrice !== undefined) || this.safeString2 (params, 'stopLossPrice', 'takeProfitPrice') !== undefined;
	var isTriggerOrder interface{} = (!IsEqual(triggerPrice, nil))
	var cost interface{} = this.SafeString(params, "cost")
	if IsTrue(!IsEqual(cost, nil)) {
		if IsTrue(!IsTrue(GetValue(market, "spot")) || IsTrue((!IsEqual(triggerPrice, nil)))) {
			panic(BadRequest(Add(this.Id, " createOrder() accepts a cost parameter for spot non-trigger market orders only")))
		}
	}
	if IsTrue(isTriggerOrder) {
		return this.CreateTriggerOrderRequest(symbol, typeVar, side, amount, price, params)
	} else {
		return this.CreateRegularOrderRequest(symbol, typeVar, side, amount, price, params)
	}
}
func (this *DeepcoinCore) CreateRegularOrderRequest(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{} {
	/**
	 * @method
	 * @ignore
	 * @name deepcoin#createRegularOrderRequest
	 * @description helper function to build request
	 * @param {string} symbol unified symbol of the market to create an order in
	 * @param {string} type 'market' or 'limit'
	 * @param {string} side 'buy' or 'sell'
	 * @param {float} amount how much you want to trade in units of the base currency
	 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
	 * @param {object} [params] extra parameters specific to the exchange API endpoint
	 * @param {float} [params.cost] *spot only* the cost of the order in units of the quote currency, for market orders only
	 * @param {string} [params.clientOrderId] a unique id for the order
	 * @param {string} [params.timeInForce] 'GTC' (Good Till Cancel), 'IOC' (Immediate Or Cancel) or 'PO' (Post Only)
	 * @param {bool} [params.postOnly] true to place a post only order
	 * @param {bool} [params.reduceOnly] a mark to reduce the position size for margin and swap orders
	 * @param {float} [params.stopLossPrice] the price that a stop loss order is triggered at
	 * @param {float} [params.takeProfitPrice] the price that a take profit order is triggered at
	 * @param {string} [params.marginMode] *swap only* 'cross' or 'isolated', the default is 'cash' for spot and 'cross' for swap
	 * @param {string} [params.mrgPosition] *swap only* 'merge' or 'split', the default is 'merge'
	 */
	price := GetArg(optionalArgs, 0, nil)
	_ = price
	params := GetArg(optionalArgs, 1, map[string]interface{}{})
	_ = params
	var market interface{} = this.Market(symbol)
	var orderType interface{} = typeVar
	orderTypeparamsVariable := this.HandleTypePostOnlyAndTimeInForce(typeVar, params)
	orderType = GetValue(orderTypeparamsVariable, 0)
	params = GetValue(orderTypeparamsVariable, 1)
	var request interface{} = map[string]interface{}{
		"instId":  GetValue(market, "id"),
		"side":    side,
		"ordType": orderType,
	}
	var clientOrderId interface{} = this.SafeString(params, "clientOrderId")
	if IsTrue(!IsEqual(clientOrderId, nil)) {
		AddElementToObject(request, "clOrdId", clientOrderId)
		params = this.Omit(params, "clientOrderId")
	}
	var stopLoss interface{} = this.SafeDict(params, "stopLoss", map[string]interface{}{})
	var stopLossPrice interface{} = this.SafeString(stopLoss, "triggerPrice")
	if IsTrue(!IsEqual(stopLossPrice, nil)) {
		params = this.Omit(params, []interface{}{"stopLoss"})
		AddElementToObject(request, "slTriggerPx", this.PriceToPrecision(symbol, stopLossPrice))
	}
	var takeProfit interface{} = this.SafeDict(params, "takeProfit", map[string]interface{}{})
	var takeProfitPrice interface{} = this.SafeString(takeProfit, "triggerPrice")
	if IsTrue(!IsEqual(takeProfitPrice, nil)) {
		params = this.Omit(params, []interface{}{"takeProfit"})
		AddElementToObject(request, "tpTriggerPx", this.PriceToPrecision(symbol, takeProfitPrice))
	}
	var isMarketOrder interface{} = (IsEqual(typeVar, "market"))
	if IsTrue(!IsEqual(price, nil)) {
		if IsTrue(isMarketOrder) {
			panic(BadRequest(Add(this.Id, " createOrder() does not require a price argument for market orders")))
		}
		AddElementToObject(request, "px", this.PriceToPrecision(symbol, price))
	} else if !IsTrue(isMarketOrder) {
		panic(BadRequest(Add(this.Id, " createOrder() requires a price argument for limit orders")))
	}
	if IsTrue(GetValue(market, "spot")) {
		var cost interface{} = this.SafeString(params, "cost")
		if IsTrue(!IsEqual(cost, nil)) {
			if !IsTrue(isMarketOrder) {
				panic(BadRequest(Add(this.Id, " createOrder() accepts a cost parameter for spot market orders only")))
			}
			params = this.Omit(params, "cost")
			AddElementToObject(request, "sz", this.CostToPrecision(symbol, cost))
			AddElementToObject(request, "tgtCcy", "quote_ccy")
		} else {
			AddElementToObject(request, "sz", this.AmountToPrecision(symbol, amount))
			AddElementToObject(request, "tgtCcy", "base_ccy")
		}
		AddElementToObject(request, "side", side)
		AddElementToObject(request, "tdMode", "cash")
	} else {
		AddElementToObject(request, "sz", this.AmountToPrecision(symbol, amount))
		var marginMode interface{} = "cross"
		marginModeparamsVariable := this.HandleMarginModeAndParams("createOrder", params, marginMode)
		marginMode = GetValue(marginModeparamsVariable, 0)
		params = GetValue(marginModeparamsVariable, 1)
		AddElementToObject(request, "tdMode", marginMode)
		var mrgPosition interface{} = "merge"
		mrgPositionparamsVariable := this.HandleOptionAndParams(params, "createOrder", "mrgPosition", mrgPosition)
		mrgPosition = GetValue(mrgPositionparamsVariable, 0)
		params = GetValue(mrgPositionparamsVariable, 1)
		AddElementToObject(request, "mrgPosition", mrgPosition)
		var posSide interface{} = nil
		var reduceOnly interface{} = this.SafeBool(params, "reduceOnly", false)
		if IsTrue(reduceOnly) {
			if IsTrue(IsEqual(side, "buy")) {
				posSide = "short"
			} else if IsTrue(IsEqual(side, "sell")) {
				posSide = "long"
			}
		} else {
			if IsTrue(IsEqual(side, "buy")) {
				posSide = "long"
			} else if IsTrue(IsEqual(side, "sell")) {
				posSide = "short"
			}
		}
		AddElementToObject(request, "posSide", posSide)
	}
	return this.Extend(request, params)
}
func (this *DeepcoinCore) CreateTriggerOrderRequest(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{} {
	/**
	 * @method
	 * @ignore
	 * @name deepcoin#createTriggerOrderRequest
	 * @description helper function to build request
	 * @param {string} symbol unified symbol of the market to create an order in
	 * @param {string} type 'market' or 'limit'
	 * @param {string} side 'buy' or 'sell'
	 * @param {float} amount how much you want to trade in units of the base currency
	 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
	 * @param {object} [params] extra parameters specific to the exchange API endpoint
	 * @param {bool} [params.reduceOnly] a mark to reduce the position size for margin orders
	 * @param {string} [params.marginMode] *swap only* 'cross' or 'isolated', the default is 'cash' for spot and 'cross' for swap
	 */
	price := GetArg(optionalArgs, 0, nil)
	_ = price
	params := GetArg(optionalArgs, 1, map[string]interface{}{})
	_ = params
	var market interface{} = this.Market(symbol)
	var request interface{} = map[string]interface{}{
		"instId":       GetValue(market, "id"),
		"productGroup": this.Capitalize(GetValue(market, "type")),
		"sz":           this.AmountToPrecision(symbol, amount),
		"side":         side,
		"orderType":    typeVar,
	}
	var triggerPrice interface{} = this.SafeString(params, "triggerPrice")
	// const takeProfitPrice = this.safeString (params, 'takeProfitPrice');
	// const stopLossPrice = this.safeString (params, 'stopLossPrice');
	// const isTpOrSlOrder = (takeProfitPrice !== undefined) || (stopLossPrice !== undefined);
	// if (isTpOrSlOrder) {
	//     if (takeProfitPrice !== undefined) {
	//         request['triggerPrice'] = this.priceToPrecision (symbol, takeProfitPrice);
	//     } else {
	//         request['triggerPrice'] = this.priceToPrecision (symbol, stopLossPrice);
	//     }
	// } else {
	AddElementToObject(request, "triggerPrice", this.PriceToPrecision(symbol, triggerPrice))
	// }
	if IsTrue(!IsEqual(price, nil)) {
		AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
	} else if IsTrue(IsEqual(typeVar, "limit")) {
		panic(ArgumentsRequired(Add(this.Id, " createOrder() requires a price argument for limit trigger orders")))
	}
	var marginMode interface{} = "cross"
	marginModeparamsVariable := this.HandleMarginModeAndParams("createOrder", params, marginMode)
	marginMode = GetValue(marginModeparamsVariable, 0)
	params = GetValue(marginModeparamsVariable, 1)
	var isCrossMargin interface{} = 1
	if IsTrue(IsEqual(marginMode, "isolated")) {
		isCrossMargin = 0
	}
	var reduceOnly interface{} = this.SafeBool(params, "reduceOnly", false)
	params = this.Omit(params, "reduceOnly")
	AddElementToObject(request, "isCrossMargin", isCrossMargin)
	AddElementToObject(request, "tdMode", marginMode)
	if IsTrue(GetValue(market, "swap")) {
		if IsTrue(reduceOnly) {
			if IsTrue(IsEqual(side, "buy")) {
				AddElementToObject(request, "posSide", "short")
			} else if IsTrue(IsEqual(side, "sell")) {
				AddElementToObject(request, "posSide", "long")
			}
		} else {
			if IsTrue(IsEqual(side, "buy")) {
				AddElementToObject(request, "posSide", "long")
			} else if IsTrue(IsEqual(side, "sell")) {
				AddElementToObject(request, "posSide", "short")
			}
		}
	}
	var mrgPosition interface{} = "merge"
	mrgPositionparamsVariable := this.HandleOptionAndParams(params, "createOrder", "mrgPosition", mrgPosition)
	mrgPosition = GetValue(mrgPositionparamsVariable, 0)
	params = GetValue(mrgPositionparamsVariable, 1)
	AddElementToObject(request, "mrgPosition", mrgPosition)
	return this.Extend(request, params)
}
func (this *DeepcoinCore) HandleTypePostOnlyAndTimeInForce(typeVar interface{}, params interface{}) interface{} {
	var postOnly interface{} = false
	postOnlyparamsVariable := this.HandlePostOnly(IsEqual(typeVar, "market"), IsEqual(typeVar, "post_only"), params)
	postOnly = GetValue(postOnlyparamsVariable, 0)
	params = GetValue(postOnlyparamsVariable, 1)
	if IsTrue(postOnly) {
		typeVar = "post_only"
	}
	var timeInForce interface{} = this.HandleTimeInForce(params)
	params = this.Omit(params, "timeInForce")
	if IsTrue(IsTrue((!IsEqual(timeInForce, nil))) && IsTrue((IsEqual(timeInForce, "IOC")))) {
		typeVar = "ioc"
	}
	return []interface{}{typeVar, params}
}

/**
 * @method
 * @name deepcoin#createMarketOrderWithCost
 * @description create a market order by providing the symbol, side and cost
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} side 'buy' or 'sell'
 * @param {float} cost how much you want to trade in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *DeepcoinCore) CreateMarketOrderWithCost(symbol interface{}, side interface{}, cost interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		params = this.Extend(params, map[string]interface{}{
			"cost": cost,
		})

		retRes173715 := (<-this.CreateOrder(symbol, "market", side, 0, nil, params))
		PanicOnError(retRes173715)
		ch <- retRes173715
		return nil

	}()
	return ch
}

/**
 * @method
 * @name deepcoin#createMarketBuyOrderWithCost
 * @description create a market buy order by providing the symbol and cost
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {float} cost how much you want to trade in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *DeepcoinCore) CreateMarketBuyOrderWithCost(symbol interface{}, cost interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		params = this.Extend(params, map[string]interface{}{
			"cost": cost,
		})

		retRes175115 := (<-this.CreateOrder(symbol, "market", "buy", 0, nil, params))
		PanicOnError(retRes175115)
		ch <- retRes175115
		return nil

	}()
	return ch
}

/**
 * @method
 * @name deepcoin#createMarketSellOrderWithCost
 * @description create a market sell order by providing the symbol and cost
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {float} cost how much you want to trade in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *DeepcoinCore) CreateMarketSellOrderWithCost(symbol interface{}, cost interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		params = this.Extend(params, map[string]interface{}{
			"cost": cost,
		})

		retRes176515 := (<-this.CreateOrder(symbol, "market", "sell", 0, nil, params))
		PanicOnError(retRes176515)
		ch <- retRes176515
		return nil

	}()
	return ch
}

/**
 * @method
 * @name deepcoin#fetchClosedOrder
 * @description fetches information on a closed order made by the user
 * @see https://www.deepcoin.com/docs/DeepCoinTrade/finishOrderByID
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *DeepcoinCore) FetchClosedOrder(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes17798 := (<-this.LoadMarkets())
		PanicOnError(retRes17798)
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchClosedOrder() requires a symbol argument")))
		}
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"instId": GetValue(market, "id"),
			"ordId":  id,
		}

		response := (<-this.PrivateGetDeepcoinTradeFinishOrderByID(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "0",
		//         "msg": "",
		//         "data": [
		//             {
		//                 "instType": "SPOT",
		//                 "instId": "ETH-USDT",
		//                 "tgtCcy": "",
		//                 "ccy": "",
		//                 "ordId": "1001434573319675",
		//                 "clOrdId": "",
		//                 "tag": "",
		//                 "px": "4056.620000000000",
		//                 "sz": "0.004000",
		//                 "pnl": "0.000000",
		//                 "ordType": "market",
		//                 "side": "buy",
		//                 "posSide": "",
		//                 "tdMode": "cash",
		//                 "accFillSz": "0.004000",
		//                 "fillPx": "",
		//                 "tradeId": "",
		//                 "fillSz": "0.004000",
		//                 "fillTime": "1760619119000",
		//                 "avgPx": "",
		//                 "state": "filled",
		//                 "lever": "1.000000",
		//                 "tpTriggerPx": "",
		//                 "tpTriggerPxType": "",
		//                 "tpOrdPx": "",
		//                 "slTriggerPx": "",
		//                 "slTriggerPxType": "",
		//                 "slOrdPx": "",
		//                 "feeCcy": "USDT",
		//                 "fee": "0.000004",
		//                 "rebateCcy": "",
		//                 "source": "",
		//                 "rebate": "",
		//                 "category": "normal",
		//                 "uTime": "1760619119000",
		//                 "cTime": "1760619119000"
		//             }
		//         ]
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var entry interface{} = this.SafeDict(data, 0, map[string]interface{}{})

		ch <- this.ParseOrder(entry, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name deepcoin#fetchOpenOrder
 * @description fetch an open order by it's id
 * @see https://www.deepcoin.com/docs/DeepCoinTrade/orderByID
 * @param {string} id order id
 * @param {string} symbol unified market symbol, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *DeepcoinCore) FetchOpenOrder(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes18518 := (<-this.LoadMarkets())
		PanicOnError(retRes18518)
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchClosedOrder() requires a symbol argument")))
		}
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"instId": GetValue(market, "id"),
			"ordId":  id,
		}

		response := (<-this.PrivateGetDeepcoinTradeOrderByID(this.Extend(request, params)))
		PanicOnError(response)
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var length interface{} = GetArrayLength(data)
		if IsTrue(IsEqual(length, 0)) {

			return nil
		}
		var entry interface{} = this.SafeDict(data, 0, map[string]interface{}{})

		ch <- this.ParseOrder(entry, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name deepcoin#fetchCanceledAndClosedOrders
 * @see https://www.deepcoin.com/docs/DeepCoinTrade/ordersHistory
 * @see https://www.deepcoin.com/docs/DeepCoinTrade/triggerOrdersHistory
 * @description fetches information on multiple canceled and closed orders made by the user
 * @param {string} [symbol] unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {bool} [params.trigger] whether to fetch trigger/algo orders (default false)
 * @param {string} [params.type] *non trigger orders only* 'spot' or 'swap', the market type for the orders
 * @param {string} [params.state] *non trigger orders only* 'canceled' or 'filled', the order state to filter by
 * @param {string} [params.OrderType] *trigger orders only* 'limit' or 'market'
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *DeepcoinCore) FetchCanceledAndClosedOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes18888 := (<-this.LoadMarkets())
		PanicOnError(retRes18888)
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchCanceledAndClosedOrders", "paginate")
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {

			retRes189219 := (<-this.FetchPaginatedCallDynamic("fetchCanceledAndClosedOrders", symbol, since, limit, params))
			PanicOnError(retRes189219)
			ch <- retRes189219
			return nil
		}
		var trigger interface{} = this.SafeBool(params, "trigger", false)
		var methodName interface{} = "fetchCanceledAndClosedOrders"
		methodNameparamsVariable := this.HandleParamString(params, "methodName", methodName)
		methodName = GetValue(methodNameparamsVariable, 0)
		params = GetValue(methodNameparamsVariable, 1)
		var market interface{} = nil
		var request interface{} = map[string]interface{}{}
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			AddElementToObject(request, "instId", GetValue(market, "id"))
		}
		var marketType interface{} = "spot"
		marketTypeparamsVariable := this.HandleMarketTypeAndParams(methodName, market, params, marketType)
		marketType = GetValue(marketTypeparamsVariable, 0)
		params = GetValue(marketTypeparamsVariable, 1)
		AddElementToObject(request, "instType", this.ConvertToInstrumentType(marketType))
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit) // default 100
		}
		var response interface{} = nil
		if IsTrue(trigger) {
			if IsTrue(!IsEqual(methodName, "fetchCanceledAndClosedOrders")) {
				panic(BadRequest(Add(Add(Add(this.Id, " "), methodName), "() does not support trigger orders")))
			}
			if IsTrue(IsEqual(market, nil)) {
				panic(ArgumentsRequired(Add(this.Id, " fetchCanceledAndClosedOrders() requires a symbol argument for trigger orders")))
			}
			params = this.Omit(params, "trigger")
			//
			//     {
			//         "code": "0",
			//         "msg": "",
			//         "data": [
			//             {
			//                 "instType": "SWAP",
			//                 "instId": "DOGE-USDT-SWAP",
			//                 "ordId": "1001110510915416",
			//                 "px": "0",
			//                 "sz": "76",
			//                 "triggerPx": "0",
			//                 "triggerPxType": "last",
			//                 "ordType": "TPSL",
			//                 "side": "sell",
			//                 "posSide": "long",
			//                 "tdMode": "cross",
			//                 "lever": "2",
			//                 "triggerTime": "0",
			//                 "uTime": "1761059366000",
			//                 "cTime": "1761059218",
			//                 "errorCode": "0",
			//                 "errorMsg": ""
			//             }
			//         ]
			//     }
			//

			response = (<-this.PrivateGetDeepcoinTradeTriggerOrdersHistory(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			//
			//     {
			//         "code": "0",
			//         "msg": "",
			//         "data": [
			//             {
			//                 "instType": "SPOT",
			//                 "instId": "ETH-USDT",
			//                 "tgtCcy": "",
			//                 "ccy": "",
			//                 "ordId": "1001434573319675",
			//                 "clOrdId": "",
			//                 "tag": "",
			//                 "px": "4056.620000000000",
			//                 "sz": "0.004000",
			//                 "pnl": "0.000000",
			//                 "ordType": "market",
			//                 "side": "buy",
			//                 "posSide": "",
			//                 "tdMode": "cash",
			//                 "accFillSz": "0.004000",
			//                 "fillPx": "",
			//                 "tradeId": "",
			//                 "fillSz": "0.004000",
			//                 "fillTime": "1760619119000",
			//                 "avgPx": "",
			//                 "state": "filled",
			//                 "lever": "1.000000",
			//                 "tpTriggerPx": "",
			//                 "tpTriggerPxType": "",
			//                 "tpOrdPx": "",
			//                 "slTriggerPx": "",
			//                 "slTriggerPxType": "",
			//                 "slOrdPx": "",
			//                 "feeCcy": "USDT",
			//                 "fee": "0.000004",
			//                 "rebateCcy": "",
			//                 "source": "",
			//                 "rebate": "",
			//                 "category": "normal",
			//                 "uTime": "1760619119000",
			//                 "cTime": "1760619119000"
			//             }
			//         ]
			//     }
			//

			response = (<-this.PrivateGetDeepcoinTradeOrdersHistory(this.Extend(request, params)))
			PanicOnError(response)
		}
		// todo handle with since, until and pagination
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseOrders(data, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name deepcoin#fetchCanceledOrders
 * @description fetches information on multiple canceled orders made by the user
 * @see https://www.deepcoin.com/docs/DeepCoinTrade/ordersHistory
 * @param {string} symbol unified market symbol of the market the orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.type] 'spot' or 'swap', the market type for the orders
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *DeepcoinCore) FetchCanceledOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		var methodName interface{} = "fetchCanceledOrders"
		params = this.Extend(params, map[string]interface{}{
			"methodName": methodName,
		})
		params = this.Extend(params, map[string]interface{}{
			"state": "canceled",
		})

		retRes201615 := (<-this.FetchCanceledAndClosedOrders(symbol, since, limit, params))
		PanicOnError(retRes201615)
		ch <- retRes201615
		return nil

	}()
	return ch
}

/**
 * @method
 * @name deepcoin#fetchClosedOrders
 * @description fetches information on multiple closed orders made by the user
 * @see https://www.deepcoin.com/docs/DeepCoinTrade/ordersHistory
 * @param {string} symbol unified market symbol of the market the orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.type] 'spot' or 'swap', the market type for the orders
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *DeepcoinCore) FetchClosedOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		var methodName interface{} = "fetchClosedOrders"
		params = this.Extend(params, map[string]interface{}{
			"methodName": methodName,
		})
		params = this.Extend(params, map[string]interface{}{
			"state": "filled",
		})

		retRes203515 := (<-this.FetchCanceledAndClosedOrders(symbol, since, limit, params))
		PanicOnError(retRes203515)
		ch <- retRes203515
		return nil

	}()
	return ch
}

/**
 * @method
 * @name deepcoin#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://www.deepcoin.com/docs/DeepCoinTrade/ordersPendingV2
 * @see https://www.deepcoin.com/docs/DeepCoinTrade/triggerOrdersPending
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {bool} [params.trigger] whether to fetch trigger/algo orders (default false)
 * @param {int} [params.index] *non trigger orders only* pagination index, default is 1
 * @param {string} [params.orderType] *trigger orders only* 'limit' or 'market'
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *DeepcoinCore) FetchOpenOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes20548 := (<-this.LoadMarkets())
		PanicOnError(retRes20548)
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchOpenOrders() requires a symbol argument")))
		}
		var market interface{} = this.Market(symbol)
		var index interface{} = this.SafeInteger(params, "index", 1) // todo add pagination handling
		var request interface{} = map[string]interface{}{
			"instId": GetValue(market, "id"),
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}
		var trigger interface{} = this.SafeBool(params, "trigger", false)
		var response interface{} = nil
		if IsTrue(trigger) {
			params = this.Omit(params, "trigger")
			AddElementToObject(request, "instType", this.ConvertToInstrumentType(GetValue(market, "type")))
			//
			//     {
			//         "code": "0",
			//         "msg": "",
			//         "data": [
			//             {
			//                 "instType": "SPOT",
			//                 "instId": "DOGE-USDT",
			//                 "ordId": "1001442305797142",
			//                 "triggerPx": "0.01",
			//                 "ordPx": "0.01",
			//                 "sz": "20",
			//                 "ordType": "",
			//                 "side": "buy",
			//                 "posSide": "",
			//                 "tdMode": "cash",
			//                 "triggerOrderType": "Conditional",
			//                 "triggerPxType": "last",
			//                 "lever": "",
			//                 "slPrice": "",
			//                 "slTriggerPrice": "",
			//                 "tpPrice": "",
			//                 "tpTriggerPrice": "",
			//                 "closeSLTriggerPrice": "",
			//                 "closeTPTriggerPrice": "",
			//                 "cTime": "1761814167000",
			//                 "uTime": "1761814167000"
			//             }
			//         ]
			//     }
			//

			response = (<-this.PrivateGetDeepcoinTradeTriggerOrdersPending(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			AddElementToObject(request, "index", index)
			//
			//     {
			//         "code": "0",
			//         "msg": "",
			//         "data": [
			//             {
			//                 "instType": "SPOT",
			//                 "instId": "ETH-USDT",
			//                 "tgtCcy": "",
			//                 "ccy": "",
			//                 "ordId": "1001435158096314",
			//                 "clOrdId": "",
			//                 "tag": "",
			//                 "px": "1000.000000000000",
			//                 "sz": "0.004000",
			//                 "pnl": "0.000000",
			//                 "ordType": "limit",
			//                 "side": "buy",
			//                 "posSide": "",
			//                 "tdMode": "cash",
			//                 "accFillSz": "0.000000",
			//                 "fillPx": "",
			//                 "tradeId": "",
			//                 "fillSz": "0.000000",
			//                 "fillTime": "1760695267000",
			//                 "avgPx": "",
			//                 "state": "live",
			//                 "lever": "1",
			//                 "tpTriggerPx": "",
			//                 "tpTriggerPxType": "",
			//                 "tpOrdPx": "",
			//                 "slTriggerPx": "",
			//                 "slTriggerPxType": "",
			//                 "slOrdPx": "",
			//                 "feeCcy": "USDT",
			//                 "fee": "0.000000",
			//                 "rebateCcy": "",
			//                 "source": "",
			//                 "rebate": "",
			//                 "category": "normal",
			//                 "uTime": "1760695267000",
			//                 "cTime": "1760695267000"
			//             }
			//         ]
			//     }
			//

			response = (<-this.PrivateGetDeepcoinTradeV2OrdersPending(this.Extend(request, params)))
			PanicOnError(response)
		}
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseOrders(data, market, since, limit, map[string]interface{}{
			"status": "open",
		})
		return nil

	}()
	return ch
}

/**
 * @method
 * @name deepcoin#cancelOrder
 * @description cancels an open order
 * @see https://www.deepcoin.com/docs/DeepCoinTrade/cancelOrder
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {bool} [params.trigger] whether the order is a trigger/algo order (default false)
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *DeepcoinCore) CancelOrder(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes21698 := (<-this.LoadMarkets())
		PanicOnError(retRes21698)
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " cancelOrder() requires a symbol argument")))
		}
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"instId": GetValue(market, "id"),
			"ordId":  id,
		}
		var response interface{} = nil
		var trigger interface{} = this.SafeBool(params, "trigger", false)
		if IsTrue(trigger) {
			params = this.Omit(params, "trigger")

			response = (<-this.PrivatePostDeepcoinTradeCancelTriggerOrder(this.Extend(request, params)))
			PanicOnError(response)
		} else {

			response = (<-this.PrivatePostDeepcoinTradeCancelOrder(this.Extend(request, params)))
			PanicOnError(response)
		}
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})

		ch <- this.ParseOrder(data, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name deepcoin#cancelAllOrders
 * @description cancel all open orders in a market
 * @see https://www.deepcoin.com/docs/DeepCoinTrade/cancelAllOrder
 * @param {string} symbol unified market symbol of the market to cancel orders in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] *swap only* 'cross' or 'isolated', the default is 'cash' for spot and 'cross' for swap
 * @param {bool} [params.merged] *swap only* true for merged positions, false for split positions (default true)
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *DeepcoinCore) CancelAllOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes22028 := (<-this.LoadMarkets())
		PanicOnError(retRes22028)
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " cancelAllOrders() requires a symbol argument")))
		}
		var market interface{} = this.Market(symbol)
		if IsTrue(GetValue(market, "spot")) {
			panic(NotSupported(Add(this.Id, " cancelAllOrders() is not supported for spot markets")))
		}
		var productGroup interface{} = this.GetProductGroupFromMarket(market)
		var marginMode interface{} = this.SafeString(params, "marginMode")
		var encodedMarginMode interface{} = 1
		if IsTrue(!IsEqual(marginMode, nil)) {
			params = this.Omit(params, "marginMode")
			if IsTrue(IsEqual(marginMode, "isolated")) {
				encodedMarginMode = 0
			}
		}
		var merged interface{} = true
		mergedparamsVariable := this.HandleOptionAndParams(params, "cancelAllOrders", "merged", merged)
		merged = GetValue(mergedparamsVariable, 0)
		params = GetValue(mergedparamsVariable, 1)
		var request interface{} = map[string]interface{}{
			"InstrumentID":  GetValue(market, "id"),
			"ProductGroup":  productGroup,
			"IsCrossMargin": encodedMarginMode,
			"IsMergeMode":   Ternary(IsTrue(merged), 1, 0),
		}

		response := (<-this.PrivatePostDeepcoinTradeSwapCancelAll(this.Extend(request, params)))
		PanicOnError(response)
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseOrders(data, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name deepcoin#editOrder
 * @description edit a trade order
 * @see https://www.deepcoin.com/docs/DeepCoinTrade/replaceOrder
 * @see https://www.deepcoin.com/docs/DeepCoinTrade/replaceTPSL
 * @param {string} id cancel order id
 * @param {string} [symbol] unified symbol of the market to create an order in (not used in deepcoin editOrder)
 * @param {string} [type] 'market' or 'limit' (not used in deepcoin editOrder)
 * @param {string} [side] 'buy' or 'sell' (not used in deepcoin editOrder)
 * @param {float} [amount] how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {float} [params.stopLossPrice] the price that a stop loss order is triggered at
 * @param {float} [params.takeProfitPrice] the price that a take profit order is triggered at
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *DeepcoinCore) EditOrder(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		amount := GetArg(optionalArgs, 0, nil)
		_ = amount
		price := GetArg(optionalArgs, 1, nil)
		_ = price
		params := GetArg(optionalArgs, 2, map[string]interface{}{})
		_ = params

		retRes22508 := (<-this.LoadMarkets())
		PanicOnError(retRes22508)
		var request interface{} = map[string]interface{}{
			"OrderSysID": id,
		}
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			if IsTrue(GetValue(market, "spot")) {
				panic(NotSupported(Add(this.Id, " editOrder() is not supported for spot markets")))
			}
			symbol = GetValue(market, "symbol")
		}
		var stopLossPrice interface{} = this.SafeNumber(params, "stopLossPrice")
		var takeProfitPrice interface{} = this.SafeNumber(params, "takeProfitPrice")
		var isTPSL interface{} = IsTrue((!IsEqual(stopLossPrice, nil))) || IsTrue((!IsEqual(takeProfitPrice, nil)))
		var response interface{} = nil
		if IsTrue(isTPSL) {
			if IsTrue(IsTrue((!IsEqual(price, nil))) || IsTrue((!IsEqual(amount, nil)))) {
				panic(BadRequest(Add(this.Id, " editOrder() with stopLossPrice or takeProfitPrice cannot have price or amount. Either use stopLossPrice/takeProfitPrice or price/amount to edit order.")))
			}
			if IsTrue(!IsEqual(stopLossPrice, nil)) {
				AddElementToObject(request, "slTriggerPx", Ternary(IsTrue(symbol), this.PriceToPrecision(symbol, stopLossPrice), this.NumberToString(stopLossPrice)))
			}
			if IsTrue(!IsEqual(takeProfitPrice, nil)) {
				AddElementToObject(request, "tpTriggerPx", Ternary(IsTrue(symbol), this.PriceToPrecision(symbol, takeProfitPrice), this.NumberToString(takeProfitPrice)))
			}
			params = this.Omit(params, []interface{}{"stopLossPrice", "takeProfitPrice"})

			response = (<-this.PrivatePostDeepcoinTradeReplaceOrderSltp(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			if IsTrue(!IsEqual(price, nil)) {
				if IsTrue(!IsEqual(symbol, nil)) {
					AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
				} else {
					AddElementToObject(request, "price", this.NumberToString(price))
				}
			}
			if IsTrue(!IsEqual(amount, nil)) {
				if IsTrue(!IsEqual(symbol, nil)) {
					AddElementToObject(request, "volume", this.AmountToPrecision(symbol, amount))
				} else {
					AddElementToObject(request, "volume", this.NumberToString(amount))
				}
			}

			response = (<-this.PrivatePostDeepcoinTradeReplaceOrder(this.Extend(request, params)))
			PanicOnError(response)
		}
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})

		ch <- this.ParseOrder(data)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name deepcoin#cancelOrders
 * @description cancel multiple orders
 * @param {string[]} ids order ids
 * @param {string} [symbol] unified market symbol, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *DeepcoinCore) CancelOrders(ids interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes23098 := (<-this.LoadMarkets())
		PanicOnError(retRes23098)
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			if IsTrue(GetValue(market, "spot")) {
				panic(NotSupported(Add(this.Id, " cancelOrders() is not supported for spot markets")))
			}
		}
		var request interface{} = map[string]interface{}{
			"OrderSysIDs": ids,
		}

		response := (<-this.PrivatePostDeepcoinTradeBatchCancelOrder(this.Extend(request, params)))
		PanicOnError(response)
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseOrders(data, market)
		return nil

	}()
	return ch
}
func (this *DeepcoinCore) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{} {
	//
	// regular order
	//     {
	//         "instType": "SPOT",
	//         "instId": "ETH-USDT",
	//         "tgtCcy": "",
	//         "ccy": "",
	//         "ordId": "1001434573319675",
	//         "clOrdId": "",
	//         "tag": "",
	//         "px": "4056.620000000000",
	//         "sz": "0.004000",
	//         "pnl": "0.000000",
	//         "ordType": "market",
	//         "side": "buy",
	//         "posSide": "",
	//         "tdMode": "cash",
	//         "accFillSz": "0.004000",
	//         "fillPx": "",
	//         "tradeId": "",
	//         "fillSz": "0.004000",
	//         "fillTime": "1760619119000",
	//         "avgPx": "",
	//         "state": "filled",
	//         "lever": "1.000000",
	//         "tpTriggerPx": "",
	//         "tpTriggerPxType": "",
	//         "tpOrdPx": "",
	//         "slTriggerPx": "",
	//         "slTriggerPxType": "",
	//         "slOrdPx": "",
	//         "feeCcy": "USDT",
	//         "fee": "0.000004",
	//         "rebateCcy": "",
	//         "source": "",
	//         "rebate": "",
	//         "category": "normal",
	//         "uTime": "1760619119000",
	//         "cTime": "1760619119000"
	//     }
	//
	// trigger order
	//     {
	//         "instType": "SPOT",
	//         "instId": "DOGE-USDT",
	//         "ordId": "1001442305797142",
	//         "triggerPx": "0.01",
	//         "ordPx": "0.01",
	//         "sz": "20",
	//         "ordType": "",
	//         "side": "buy",
	//         "posSide": "",
	//         "tdMode": "cash",
	//         "triggerOrderType": "Conditional",
	//         "triggerPxType": "last",
	//         "lever": "",
	//         "slPrice": "",
	//         "slTriggerPrice": "",
	//         "tpPrice": "",
	//         "tpTriggerPrice": "",
	//         "closeSLTriggerPrice": "",
	//         "closeTPTriggerPrice": "",
	//         "cTime": "1761814167000",
	//         "uTime": "1761814167000"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(order, "instId")
	market = this.SafeMarket(marketId, market)
	var timestamp interface{} = this.SafeInteger(order, "cTime")
	var timestampString interface{} = this.SafeString(order, "cTime", "")
	if IsTrue(IsLessThan(GetLength(timestampString), 13)) {
		timestamp = this.SafeTimestamp(order, "cTime")
	}
	var state interface{} = this.SafeString(order, "state")
	var orderType interface{} = this.SafeString(order, "ordType")
	var average interface{} = this.SafeString(order, "avgPx")
	if IsTrue(IsEqual(average, "")) {
		average = nil
	}
	var feeCurrencyId interface{} = this.SafeString(order, "feeCcy")
	var fee interface{} = nil
	if IsTrue(!IsEqual(feeCurrencyId, nil)) {
		var feeCost interface{} = this.SafeString(order, "fee")
		fee = map[string]interface{}{
			"cost":     this.ParseNumber(feeCost),
			"currency": this.SafeCurrencyCode(feeCurrencyId),
		}
	}
	return this.SafeOrder(map[string]interface{}{
		"id":                  this.SafeString(order, "ordId"),
		"clientOrderId":       this.SafeString(order, "clOrdId"),
		"datetime":            this.Iso8601(timestamp),
		"timestamp":           timestamp,
		"lastTradeTimestamp":  nil,
		"lastUpdateTimestamp": this.SafeInteger(order, "uTime"),
		"status":              this.ParseOrderStatus(state),
		"symbol":              GetValue(market, "symbol"),
		"type":                this.ParseOrderType(orderType),
		"timeInForce":         this.ParseOrderTimeInForce(orderType),
		"side":                this.SafeString(order, "side"),
		"price":               this.SafeString2(order, "px", "ordPx"),
		"average":             average,
		"amount":              this.SafeString(order, "sz"),
		"filled":              this.SafeString(order, "accFillSz"),
		"remaining":           nil,
		"triggerPrice":        this.OmitZero(this.SafeString(order, "triggerPx")),
		"takeProfitPrice":     this.SafeString2(order, "tpTriggerPx", "tpTriggerPrice"),
		"stopLossPrice":       this.SafeString2(order, "slTriggerPx", "slTriggerPrice"),
		"cost":                nil,
		"trades":              nil,
		"fee":                 fee,
		"reduceOnly":          nil,
		"postOnly":            Ternary(IsTrue(orderType), (IsEqual(orderType, "post_only")), nil),
		"info":                order,
	}, market)
}
func (this *DeepcoinCore) ParseOrderStatus(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"live":             "open",
		"filled":           "closed",
		"canceled":         "canceled",
		"partially_filled": "open",
	}
	return this.SafeString(statuses, status, status)
}
func (this *DeepcoinCore) ParseOrderType(typeVar interface{}) interface{} {
	var types interface{} = map[string]interface{}{
		"limit":     "limit",
		"market":    "market",
		"post_only": "limit",
		"ioc":       "market",
		"TPSL":      "market",
	}
	return this.SafeString(types, typeVar, typeVar)
}
func (this *DeepcoinCore) ParseOrderTimeInForce(typeVar interface{}) interface{} {
	var timeInForces interface{} = map[string]interface{}{
		"post_only": "PO",
		"ioc":       "IOC",
		"limit":     "GTC",
		"market":    "GTC",
	}
	return this.SafeString(timeInForces, typeVar, typeVar)
}

/**
 * @method
 * @description fetch open positions for a single market
 * @name deepcoin#fetchPositionsForSymbol
 * @see https://www.deepcoin.com/docs/DeepCoinAccount/accountPositions
 * @description fetch all open positions for specific symbol
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/?id=position-structure}
 */
func (this *DeepcoinCore) FetchPositionsForSymbol(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes24858 := (<-this.LoadMarkets())
		PanicOnError(retRes24858)
		var market interface{} = this.Market(symbol)
		var instrumentType interface{} = this.ConvertToInstrumentType(GetValue(market, "type"))
		var request interface{} = map[string]interface{}{
			"instType": instrumentType,
			"instId":   GetValue(market, "id"),
		}

		response := (<-this.PrivateGetDeepcoinAccountPositions(this.Extend(request, params)))
		PanicOnError(response)
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParsePositions(data, []interface{}{GetValue(market, "symbol")})
		return nil

	}()
	return ch
}

/**
 * @method
 * @name deepcoin#fetchPositions
 * @description fetch all open positions
 * @see https://www.deepcoin.com/docs/DeepCoinAccount/accountPositions
 * @param {string[]} [symbols] list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/?id=position-structure}
 */
func (this *DeepcoinCore) FetchPositions(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes25078 := (<-this.LoadMarkets())
		PanicOnError(retRes25078)
		symbols = this.MarketSymbols(symbols, nil, true, true)
		var marketType interface{} = "swap"
		var market interface{} = nil
		if IsTrue(!IsEqual(symbols, nil)) {
			var firstSymbol interface{} = this.SafeString(symbols, 0)
			market = this.Market(firstSymbol)
		}
		marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchPositions", market, params, marketType)
		marketType = GetValue(marketTypeparamsVariable, 0)
		params = GetValue(marketTypeparamsVariable, 1)
		var instrumentType interface{} = this.ConvertToInstrumentType(marketType)
		var request interface{} = map[string]interface{}{
			"instType": instrumentType,
		}

		response := (<-this.PrivateGetDeepcoinAccountPositions(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "0",
		//         "msg": "",
		//         "data": [
		//             {
		//                 "instType": "SWAP",
		//                 "mgnMode": "cross",
		//                 "instId": "DOGE-USDT-SWAP",
		//                 "posId": "1001110099878275",
		//                 "posSide": "long",
		//                 "pos": "20",
		//                 "avgPx": "0.18408",
		//                 "lever": "75",
		//                 "liqPx": "0.00001",
		//                 "useMargin": "0.049088",
		//                 "mrgPosition": "merge",
		//                 "ccy": "USDT",
		//                 "uTime": "1760709419000",
		//                 "cTime": "1760709419000"
		//             }
		//         ]
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParsePositions(data, symbols)
		return nil

	}()
	return ch
}
func (this *DeepcoinCore) ParsePosition(position interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "instType": "SWAP",
	//         "mgnMode": "cross",
	//         "instId": "DOGE-USDT-SWAP",
	//         "posId": "1001110099878275",
	//         "posSide": "long",
	//         "pos": "20",
	//         "avgPx": "0.18408",
	//         "lever": "75",
	//         "liqPx": "0.00001",
	//         "useMargin": "0.049088",
	//         "mrgPosition": "merge",
	//         "ccy": "USDT",
	//         "uTime": "1760709419000",
	//         "cTime": "1760709419000"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(position, "instId")
	market = this.SafeMarket(marketId, market)
	var timestamp interface{} = this.SafeInteger(position, "cTime")
	return this.SafePosition(map[string]interface{}{
		"symbol":                      GetValue(market, "symbol"),
		"id":                          this.SafeString(position, "posId"),
		"timestamp":                   timestamp,
		"datetime":                    this.Iso8601(timestamp),
		"contracts":                   this.SafeString(position, "pos"),
		"contractSize":                nil,
		"side":                        this.SafeString(position, "posSide"),
		"notional":                    nil,
		"leverage":                    this.OmitZero(this.SafeString(position, "lever")),
		"unrealizedPnl":               nil,
		"realizedPnl":                 nil,
		"collateral":                  nil,
		"entryPrice":                  this.SafeString(position, "avgPx"),
		"markPrice":                   nil,
		"liquidationPrice":            this.SafeString(position, "liqPx"),
		"marginMode":                  this.SafeString(position, "mgnMode"),
		"hedged":                      true,
		"maintenanceMargin":           this.SafeString(position, "useMargin"),
		"maintenanceMarginPercentage": nil,
		"initialMargin":               nil,
		"initialMarginPercentage":     nil,
		"marginRatio":                 nil,
		"lastUpdateTimestamp":         this.SafeInteger(position, "uTime"),
		"lastPrice":                   nil,
		"stopLossPrice":               nil,
		"takeProfitPrice":             nil,
		"percentage":                  nil,
		"info":                        position,
	})
}

/**
 * @method
 * @name deepcoin#setLeverage
 * @description set the level of leverage for a market
 * @see https://www.deepcoin.com/docs/DeepCoinAccount/accountSetLeverage
 * @param {float} leverage the rate of leverage
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] 'cross' or 'isolated' (default is cross)
 * @param {string} [params.mrgPosition] 'merge' or 'split', default is merge
 * @returns {object} response from the exchange
 */
func (this *DeepcoinCore) SetLeverage(leverage interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " setLeverage() requires a symbol argument")))
		}
		// WARNING: THIS WILL INCREASE LIQUIDATION PRICE FOR OPEN ISOLATED LONG POSITIONS
		// AND DECREASE LIQUIDATION PRICE FOR OPEN ISOLATED SHORT POSITIONS
		if IsTrue(IsLessThan(leverage, 1)) {
			panic(BadRequest(Add(this.Id, " setLeverage() leverage should be minimum 1")))
		}

		retRes26248 := (<-this.LoadMarkets())
		PanicOnError(retRes26248)
		var market interface{} = this.Market(symbol)
		var marginMode interface{} = "cross"
		marginModeparamsVariable := this.HandleMarginModeAndParams("setLeverage", params, marginMode)
		marginMode = GetValue(marginModeparamsVariable, 0)
		params = GetValue(marginModeparamsVariable, 1)
		if IsTrue(IsTrue((!IsEqual(marginMode, "cross"))) && IsTrue((!IsEqual(marginMode, "isolated")))) {
			panic(BadRequest(Add(this.Id, " setLeverage() requires a marginMode parameter that must be either cross or isolated")))
		}
		var mrgPosition interface{} = "merge"
		mrgPositionparamsVariable := this.HandleOptionAndParams(params, "setLeverage", "mrgPosition", mrgPosition)
		mrgPosition = GetValue(mrgPositionparamsVariable, 0)
		params = GetValue(mrgPositionparamsVariable, 1)
		if IsTrue(IsTrue(!IsEqual(mrgPosition, "merge")) && IsTrue(!IsEqual(mrgPosition, "split"))) {
			panic(BadRequest(Add(this.Id, " setLeverage() mrgPosition parameter must be either merge or split")))
		}
		var request interface{} = map[string]interface{}{
			"lever":       leverage,
			"mgnMode":     marginMode,
			"instId":      GetValue(market, "id"),
			"mrgPosition": mrgPosition,
		}

		response := (<-this.PrivatePostDeepcoinAccountSetLeverage(this.Extend(request, params)))
		PanicOnError(response)

		//
		//     {
		//         code: '0',
		//         msg: '',
		//         data: {
		//             instId: 'ETH-USDT-SWAP',
		//             lever: '2',
		//             mgnMode: 'cross',
		//             mrgPosition: 'merge',
		//             sCode: '0',
		//             sMsg: ''
		//         }
		//     }
		//
		ch <- response
		return nil

	}()
	return ch
}

/**
 * @method
 * @name deepcoin#fetchFundingRates
 * @description fetch the funding rate for multiple markets
 * @see https://www.deepcoin.com/docs/DeepCoinTrade/currentFundRate
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.subType] "linear" or "inverse"
 * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/?id=funding-rates-structure}, indexed by market symbols
 */
func (this *DeepcoinCore) FetchFundingRates(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes26718 := (<-this.LoadMarkets())
		PanicOnError(retRes26718)
		symbols = this.MarketSymbols(symbols, "swap", true, true, true)
		var subType interface{} = "linear"
		var firstMarket interface{} = nil
		if IsTrue(!IsEqual(symbols, nil)) {
			var firstSymbol interface{} = this.SafeString(symbols, 0)
			firstMarket = this.Market(firstSymbol)
		}
		subTypeparamsVariable := this.HandleSubTypeAndParams("fetchFundingRates", firstMarket, params, subType)
		subType = GetValue(subTypeparamsVariable, 0)
		params = GetValue(subTypeparamsVariable, 1)
		var instType interface{} = "SwapU"
		if IsTrue(IsEqual(subType, "inverse")) {
			instType = "Swap"
		} else if IsTrue(!IsEqual(subType, "linear")) {
			panic(BadRequest(Add(this.Id, " fetchFundingRates() subType parameter must be either linear or inverse")))
		}
		var request interface{} = map[string]interface{}{
			"instType": instType,
		}

		response := (<-this.PublicGetDeepcoinTradeFundRateCurrentFundingRate(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "0",
		//         "msg": "",
		//         "data": {
		//             "current_fund_rates": [
		//                 {
		//                     "instrumentId": "SPKUSDT",
		//                     "fundingRate": 0.00005
		//                 },
		//                 {
		//                     "instrumentId": "LAUNCHCOINUSDT",
		//                     "fundingRate": 0.00005
		//                 }
		//             ]
		//         }
		//     }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		var rates interface{} = this.SafeList(data, "current_fund_rates", []interface{}{})

		ch <- this.ParseFundingRates(rates, symbols)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name deepcoin#fetchFundingRate
 * @description fetch the current funding rate
 * @see https://www.deepcoin.com/docs/DeepCoinTrade/currentFundRate
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/?id=funding-rate-structure}
 */
func (this *DeepcoinCore) FetchFundingRate(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes27238 := (<-this.LoadMarkets())
		PanicOnError(retRes27238)
		var market interface{} = this.Market(symbol)
		if !IsTrue(GetValue(market, "swap")) {
			panic(ExchangeError(Add(this.Id, " fetchFundingRate() is only valid for swap markets")))
		}
		var request interface{} = map[string]interface{}{
			"instId":   GetValue(market, "id"),
			"instType": this.GetProductGroupFromMarket(market),
		}

		response := (<-this.PublicGetDeepcoinTradeFundRateCurrentFundingRate(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "0",
		//         "msg": "",
		//         "data": {
		//             "current_fund_rates": [
		//                 {
		//                     "instrumentId": "ETHUSDT",
		//                     "fundingRate": 0.0000402356250176
		//                 }
		//             ]
		//         }
		//     }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		var rates interface{} = this.SafeList(data, "current_fund_rates", []interface{}{})
		var entry interface{} = this.SafeDict(rates, 0, map[string]interface{}{})

		ch <- this.ParseFundingRate(entry, market)
		return nil

	}()
	return ch
}
func (this *DeepcoinCore) ParseFundingRate(contract interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "instrumentId": "ETHUSDT",
	//         "fundingRate": 0.0000402356250176
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString2(contract, "instrumentId", "instrumentID")
	var symbol interface{} = this.SafeSymbol(marketId, market)
	return map[string]interface{}{
		"info":                     contract,
		"symbol":                   symbol,
		"markPrice":                nil,
		"indexPrice":               nil,
		"interestRate":             nil,
		"estimatedSettlePrice":     nil,
		"timestamp":                nil,
		"datetime":                 nil,
		"fundingRate":              this.SafeNumber(contract, "fundingRate"),
		"fundingTimestamp":         nil,
		"fundingDatetime":          nil,
		"nextFundingRate":          nil,
		"nextFundingTimestamp":     nil,
		"nextFundingDatetime":      nil,
		"previousFundingRate":      nil,
		"previousFundingTimestamp": nil,
		"previousFundingDatetime":  nil,
		"interval":                 nil,
	}
}

/**
 * @method
 * @name deepcoin#fetchFundingRateHistory
 * @description fetches historical funding rate prices
 * @see https://www.deepcoin.com/docs/DeepCoinTrade/fundingRateHistory
 * @param {string} symbol unified symbol of the market to fetch the funding rate history for
 * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
 * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/?id=funding-rate-history-structure} to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.page] pagination page number
 * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/?id=funding-rate-history-structure}
 */
func (this *DeepcoinCore) FetchFundingRateHistory(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchFundingRateHistory() requires a symbol argument")))
		}

		retRes28008 := (<-this.LoadMarkets())
		PanicOnError(retRes28008)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"instId": GetValue(market, "id"),
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "size", limit) // default 20, max 100
		}

		response := (<-this.PublicGetDeepcoinTradeFundRateHistory(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "0",
		//         "msg": "",
		//         "data": {
		//             "rows": [
		//                 {
		//                     "instrumentID": "ETHUSD",
		//                     "rate": "0.00046493",
		//                     "CreateTime": 1760860800,
		//                     "ratePeriodSec": 0
		//                 },
		//                 {
		//                     "instrumentID": "ETHUSD",
		//                     "rate": "0.00047949",
		//                     "CreateTime": 1760832000,
		//                     "ratePeriodSec": 0
		//                 }
		//             ]
		//         }
		//     }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		var rows interface{} = this.SafeList(data, "rows", []interface{}{})

		ch <- this.ParseFundingRateHistories(rows, market, since, limit)
		return nil

	}()
	return ch
}
func (this *DeepcoinCore) ParseFundingRateHistory(info interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "instrumentID": "ETHUSD",
	//         "rate": "0.00047949",
	//         "CreateTime": 1760832000,
	//         "ratePeriodSec": 0
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var timestamp interface{} = this.SafeTimestamp(info, "CreateTime")
	var instrumentID interface{} = this.SafeString2(info, "instrumentID", "instrumentId")
	market = this.SafeMarket(instrumentID, market, nil, "swap")
	return map[string]interface{}{
		"info":        info,
		"symbol":      GetValue(market, "symbol"),
		"fundingRate": this.SafeNumber(info, "rate"),
		"timestamp":   timestamp,
		"datetime":    this.Iso8601(timestamp),
	}
}

/**
 * @method
 * @name deepcoin#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://www.deepcoin.com/docs/DeepCoinTrade/tradeFills
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest trade to fetch
 * @param {string} [params.type] 'spot' or 'swap', the market type for the trades (default is 'spot')
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
 */
func (this *DeepcoinCore) FetchMyTrades(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes28728 := (<-this.LoadMarkets())
		PanicOnError(retRes28728)
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchMyTrades", "paginate")
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {

			retRes287619 := (<-this.FetchPaginatedCallDynamic("fetchMyTrades", symbol, since, limit, params))
			PanicOnError(retRes287619)
			ch <- retRes287619
			return nil
		}
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
		}
		var marketType interface{} = "spot"
		marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchMyTrades", market, params, marketType)
		marketType = GetValue(marketTypeparamsVariable, 0)
		params = GetValue(marketTypeparamsVariable, 1)
		var request interface{} = map[string]interface{}{
			"instType": this.ConvertToInstrumentType(marketType),
		}
		if IsTrue(!IsEqual(market, nil)) {
			AddElementToObject(request, "instId", GetValue(market, "id"))
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "begin", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit) // default 100, max 100
		}
		var until interface{} = this.SafeInteger(params, "until")
		if IsTrue(!IsEqual(until, nil)) {
			params = this.Omit(params, "until")
			AddElementToObject(request, "end", until)
		}

		response := (<-this.PrivateGetDeepcoinTradeFills(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "0",
		//         "msg": "",
		//         "data": [
		//             {
		//                 "instType": "SPOT",
		//                 "instId": "ETH-USDT",
		//                 "tradeId": "1001056429613610",
		//                 "ordId": "1001435238208686",
		//                 "clOrdId": "",
		//                 "billId": "10010564296136101",
		//                 "tag": "",
		//                 "fillPx": "3791.15",
		//                 "fillSz": "0.004",
		//                 "side": "sell",
		//                 "posSide": "",
		//                 "execType": "",
		//                 "feeCcy": "USDT",
		//                 "fee": "0.0151646",
		//                 "ts": "1760704540000"
		//             }
		//         ]
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseTrades(data, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name deepcoin#fetchOrderTrades
 * @description fetch all the trades made from a single order
 * @see https://www.deepcoin.com/docs/DeepCoinTrade/tradeFills
 * @param {string} id order id
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.type] 'spot' or 'swap', the market type for the trades
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
 */
func (this *DeepcoinCore) FetchOrderTrades(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes29458 := (<-this.LoadMarkets())
		PanicOnError(retRes29458)
		var marketType interface{} = this.SafeString(params, "type")
		if IsTrue(IsTrue(IsEqual(symbol, nil)) && IsTrue(IsEqual(marketType, nil))) {
			panic(ArgumentsRequired(Add(this.Id, " fetchOrderTrades requires a symbol argument or a market type in the params")))
		}
		params = this.Extend(map[string]interface{}{
			"ordId": id,
		}, params)

		retRes295115 := (<-this.FetchMyTrades(symbol, since, limit, params))
		PanicOnError(retRes295115)
		ch <- retRes295115
		return nil

	}()
	return ch
}

/**
 * @method
 * @name deepcoin#closePosition
 * @description closes open positions for a market
 * @see https://www.deepcoin.com/docs/DeepCoinTrade/batchClosePosition
 * @see https://www.deepcoin.com/docs/DeepCoinTrade/closePositionByIds
 * @param {string} symbol Unified CCXT market symbol
 * @param {string} [side] not used by deepcoin
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string|undefined} [params.positionId] the id of the position you would like to close
 * @param {string[]|undefined} [params.positionIds] list of position ids to close (for batch closing)
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *DeepcoinCore) ClosePosition(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		side := GetArg(optionalArgs, 0, nil)
		_ = side
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes29688 := (<-this.LoadMarkets())
		PanicOnError(retRes29688)
		var market interface{} = this.Market(symbol)
		var productGroup interface{} = this.GetProductGroupFromMarket(market)
		var positionId interface{} = this.SafeString(params, "positionId")
		var positionIds interface{} = this.SafeList(params, "positionIds")
		var request interface{} = map[string]interface{}{
			"instId":       GetValue(market, "id"),
			"productGroup": productGroup,
		}
		var response interface{} = nil
		if IsTrue(IsTrue(IsEqual(positionId, nil)) && IsTrue(IsEqual(positionIds, nil))) {

			response = (<-this.PrivatePostDeepcoinTradeBatchClosePosition(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			if IsTrue(!IsEqual(positionId, nil)) {
				params = this.Omit(params, "positionId")
				AddElementToObject(request, "positionIds", []interface{}{positionId})
			}

			response = (<-this.PrivatePostDeepcoinTradeClosePositionByIds(this.Extend(request, params)))
			PanicOnError(response)
		}
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseOrder(data, market)
		return nil

	}()
	return ch
}
func (this *DeepcoinCore) Sign(path interface{}, optionalArgs ...interface{}) interface{} {
	api := GetArg(optionalArgs, 0, "public")
	_ = api
	method := GetArg(optionalArgs, 1, "GET")
	_ = method
	params := GetArg(optionalArgs, 2, map[string]interface{}{})
	_ = params
	headers := GetArg(optionalArgs, 3, nil)
	_ = headers
	body := GetArg(optionalArgs, 4, nil)
	_ = body
	var requestPath interface{} = path
	if IsTrue(IsEqual(method, "GET")) {
		var query interface{} = this.Urlencode(params)
		if IsTrue(GetArrayLength(query)) {
			requestPath = Add(requestPath, Add("?", query))
		}
	}
	var url interface{} = Add(Add(GetValue(GetValue(this.Urls, "api"), api), "/"), requestPath)
	if IsTrue(IsEqual(api, "private")) {
		this.CheckRequiredCredentials()
		var timestamp interface{} = this.Milliseconds()
		var dateTime interface{} = this.Iso8601(timestamp)
		var payload interface{} = Add(Add(Add(dateTime, method), "/"), requestPath)
		headers = map[string]interface{}{
			"DC-ACCESS-KEY":        this.ApiKey,
			"DC-ACCESS-TIMESTAMP":  dateTime,
			"DC-ACCESS-PASSPHRASE": this.Password,
			"appid":                "200103",
		}
		if IsTrue(!IsEqual(method, "GET")) {
			body = this.Json(params)
			AddElementToObject(headers, "Content-Type", "application/json")
			payload = Add(payload, body)
		}
		var signature interface{} = this.Hmac(this.Encode(payload), this.Encode(this.Secret), sha256, "base64")
		AddElementToObject(headers, "DC-ACCESS-SIGN", signature)
	}
	return map[string]interface{}{
		"url":     url,
		"method":  method,
		"body":    body,
		"headers": headers,
	}
}
func (this *DeepcoinCore) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{} {
	var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
	var msg interface{} = this.SafeString(response, "msg")
	var messageCode interface{} = this.SafeString(response, "code")
	var sCode interface{} = this.SafeString(data, "sCode")
	var sMsg interface{} = this.SafeString(data, "sMsg")
	var errorCode interface{} = this.SafeString(data, "errorCode")
	if IsTrue(IsTrue(IsTrue((!IsEqual(msg, nil))) && IsTrue((IsEqual(msg, "")))) && IsTrue((!IsEqual(sMsg, nil)))) {
		msg = sMsg
	}
	var errorList interface{} = this.SafeList(data, "errorList")
	if IsTrue(!IsEqual(errorList, nil)) {
		for i := 0; IsLessThan(i, GetArrayLength(errorList)); i++ {
			var entry interface{} = this.SafeDict(errorList, i, map[string]interface{}{})
			errorCode = this.SafeString(entry, "errorCode")
		}
	}
	var feedback interface{} = Add(Add(this.Id, " "), body)
	if IsTrue(IsTrue((IsEqual(sCode, nil))) && IsTrue((!IsEqual(errorCode, nil)))) {
		sCode = errorCode
	}
	var retCode interface{} = this.SafeString(data, "retCode")
	if IsTrue(IsTrue((IsEqual(sCode, nil))) && IsTrue((!IsEqual(retCode, nil)))) {
		sCode = retCode
	}
	if IsTrue(IsTrue(IsTrue((!IsEqual(code, 200))) || IsTrue((!IsEqual(messageCode, "0")))) || IsTrue((IsTrue(!IsEqual(sCode, nil)) && IsTrue(!IsEqual(sCode, "0"))))) {
		this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), messageCode, feedback)
		this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), sCode, feedback)
		this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), msg, feedback)
		this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), msg, feedback)
		panic(ExchangeError(feedback))
	} else {
		var list interface{} = this.SafeList(data, "list", []interface{}{})
		if IsTrue(IsTrue((InOp(data, "list"))) && IsTrue((IsEqual(list, nil)))) {
			panic(NullResponse(feedback))
		}
	}
	return nil
}

func (this *DeepcoinCore) Init(userConfig map[string]interface{}) {
	this.Exchange = Exchange{}
	this.Exchange.DerivedExchange = this
	this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
}
