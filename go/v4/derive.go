package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type derive struct {
    Exchange

}

func NewDeriveCore() derive {
   p := derive{}
   setDefaults(&p)
   return p
}

func  (this *derive) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "derive",
        "name": "derive",
        "countries": []interface{}{},
        "version": "v1",
        "rateLimit": 50,
        "certified": false,
        "pro": true,
        "dex": true,
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": false,
            "margin": false,
            "swap": false,
            "future": false,
            "option": false,
            "addMargin": false,
            "borrowCrossMargin": false,
            "borrowIsolatedMargin": false,
            "cancelAllOrders": true,
            "cancelAllOrdersAfter": false,
            "cancelOrder": true,
            "cancelOrders": false,
            "cancelOrdersForSymbols": false,
            "closeAllPositions": false,
            "closePosition": false,
            "createMarketBuyOrderWithCost": false,
            "createMarketOrderWithCost": false,
            "createMarketSellOrderWithCost": false,
            "createOrder": true,
            "createOrders": false,
            "createReduceOnlyOrder": false,
            "createStopOrder": false,
            "createTriggerOrder": false,
            "editOrder": true,
            "fetchAccounts": false,
            "fetchBalance": true,
            "fetchBorrowInterest": false,
            "fetchBorrowRateHistories": false,
            "fetchBorrowRateHistory": false,
            "fetchCanceledAndClosedOrders": false,
            "fetchCanceledOrders": true,
            "fetchClosedOrders": true,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchCurrencies": true,
            "fetchDepositAddress": false,
            "fetchDepositAddresses": false,
            "fetchDeposits": true,
            "fetchDepositWithdrawFee": "emulated",
            "fetchDepositWithdrawFees": false,
            "fetchFundingHistory": true,
            "fetchFundingRate": true,
            "fetchFundingRateHistory": true,
            "fetchFundingRates": false,
            "fetchIndexOHLCV": false,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchLedger": true,
            "fetchLeverage": false,
            "fetchLeverageTiers": false,
            "fetchLiquidations": false,
            "fetchMarginMode": nil,
            "fetchMarketLeverageTiers": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMyLiquidations": false,
            "fetchMyTrades": true,
            "fetchOHLCV": false,
            "fetchOpenInterest": false,
            "fetchOpenInterestHistory": false,
            "fetchOpenInterests": false,
            "fetchOpenOrders": true,
            "fetchOrder": false,
            "fetchOrderBook": false,
            "fetchOrders": true,
            "fetchOrderTrades": true,
            "fetchPosition": false,
            "fetchPositionMode": false,
            "fetchPositions": true,
            "fetchPositionsRisk": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchTicker": true,
            "fetchTickers": false,
            "fetchTime": true,
            "fetchTrades": true,
            "fetchTradingFee": false,
            "fetchTradingFees": false,
            "fetchTransfer": false,
            "fetchTransfers": false,
            "fetchWithdrawal": false,
            "fetchWithdrawals": true,
            "reduceMargin": false,
            "repayCrossMargin": false,
            "repayIsolatedMargin": false,
            "sandbox": true,
            "setLeverage": false,
            "setMarginMode": false,
            "setPositionMode": false,
            "transfer": false,
            "withdraw": false,
        },
        "timeframes": map[string]interface{} {
            "1m": "1m",
            "3m": "3m",
            "5m": "5m",
            "15m": "15m",
            "30m": "30m",
            "1h": "1h",
            "2h": "2h",
            "4h": "4h",
            "8h": "8h",
            "12h": "12h",
            "1d": "1d",
            "3d": "3d",
            "1w": "1w",
            "1M": "1M",
        },
        "hostname": "derive.xyz",
        "urls": map[string]interface{} {
            "logo": "https://github.com/user-attachments/assets/f835b95f-033a-43dd-b6bb-24e698fc498c",
            "api": map[string]interface{} {
                "public": "https://api.lyra.finance/public",
                "private": "https://api.lyra.finance/private",
            },
            "test": map[string]interface{} {
                "public": "https://api-demo.lyra.finance/public",
                "private": "https://api-demo.lyra.finance/private",
            },
            "www": "https://www.derive.xyz/",
            "doc": "https://docs.derive.xyz/docs/",
            "fees": "https://docs.derive.xyz/reference/fees-1/",
            "referral": "https://www.derive.xyz/invite/3VB0B",
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": []interface{}{"get_all_currencies"},
                "post": []interface{}{"build_register_session_key_tx", "register_session_key", "deregister_session_key", "login", "statistics", "get_all_currencies", "get_currency", "get_instrument", "get_all_instruments", "get_instruments", "get_ticker", "get_latest_signed_feeds", "get_option_settlement_prices", "get_spot_feed_history", "get_spot_feed_history_candles", "get_funding_rate_history", "get_trade_history", "get_option_settlement_history", "get_liquidation_history", "get_interest_rate_history", "get_transaction", "get_margin", "margin_watch", "validate_invite_code", "get_points", "get_all_points", "get_points_leaderboard", "get_descendant_tree", "get_tree_roots", "get_swell_percent_points", "get_vault_assets", "get_etherfi_effective_balances", "get_kelp_effective_balances", "get_bridge_balances", "get_ethena_participants", "get_vault_share", "get_vault_statistics", "get_vault_balances", "estimate_integrator_points", "create_subaccount_debug", "deposit_debug", "withdraw_debug", "send_quote_debug", "execute_quote_debug", "get_invite_code", "register_invite", "get_time", "get_live_incidents", "get_maker_programs", "get_maker_program_scores"},
            },
            "private": map[string]interface{} {
                "post": []interface{}{"get_account", "create_subaccount", "get_subaccount", "get_subaccounts", "get_all_portfolios", "change_subaccount_label", "get_notificationsv", "update_notifications", "deposit", "withdraw", "transfer_erc20", "transfer_position", "transfer_positions", "order", "replace", "order_debug", "get_order", "get_orders", "get_open_orders", "cancel", "cancel_by_label", "cancel_by_nonce", "cancel_by_instrument", "cancel_all", "cancel_trigger_order", "get_order_history", "get_trade_history", "get_deposit_history", "get_withdrawal_history", "send_rfq", "cancel_rfq", "cancel_batch_rfqs", "get_rfqs", "poll_rfqs", "send_quote", "cancel_quote", "cancel_batch_quotes", "get_quotes", "poll_quotes", "execute_quote", "rfq_get_best_quote", "get_margin", "get_collaterals", "get_positions", "get_option_settlement_history", "get_subaccount_value_history", "expired_and_cancelled_history", "get_funding_history", "get_interest_history", "get_erc20_transfer_history", "get_liquidation_history", "liquidate", "get_liquidator_history", "session_keys", "edit_session_key", "register_scoped_session_key", "get_mmp_config", "set_mmp_config", "reset_mmp", "set_cancel_on_disconnect", "get_invite_code", "register_invite"},
            },
        },
        "fees": map[string]interface{} {},
        "requiredCredentials": map[string]interface{} {
            "apiKey": false,
            "secret": false,
            "walletAddress": true,
            "privateKey": true,
        },
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "-32000": RateLimitExceeded,
                "-32100": RateLimitExceeded,
                "-32700": BadRequest,
                "-32600": BadRequest,
                "-32601": BadRequest,
                "-32602": InvalidOrder,
                "-32603": InvalidOrder,
                "9000": InvalidOrder,
                "10000": BadRequest,
                "10001": BadRequest,
                "10002": BadRequest,
                "10003": BadRequest,
                "10004": InvalidOrder,
                "10005": BadRequest,
                "10006": BadRequest,
                "10007": BadRequest,
                "10008": BadRequest,
                "10009": BadRequest,
                "10010": InvalidOrder,
                "10011": InsufficientFunds,
                "10012": InsufficientFunds,
                "10013": ExchangeError,
                "10014": ExchangeError,
                "11000": InsufficientFunds,
                "11002": InvalidOrder,
                "11003": InvalidOrder,
                "11004": InvalidOrder,
                "11005": InvalidOrder,
                "11006": OrderNotFound,
                "11007": InvalidOrder,
                "11008": InvalidOrder,
                "11009": InvalidOrder,
                "11010": InvalidOrder,
                "11011": InvalidOrder,
                "11012": InvalidOrder,
                "11013": InvalidOrder,
                "11014": InvalidOrder,
                "11015": InvalidOrder,
                "11016": InvalidOrder,
                "11017": InvalidOrder,
                "11018": InvalidOrder,
                "11019": InvalidOrder,
                "11020": InsufficientFunds,
                "11021": InvalidOrder,
                "11022": InvalidOrder,
                "11023": InvalidOrder,
                "11024": InvalidOrder,
                "11025": InvalidOrder,
                "11026": BadRequest,
                "11027": InvalidOrder,
                "11028": InvalidOrder,
                "11050": InvalidOrder,
                "11051": InvalidOrder,
                "11052": InvalidOrder,
                "11053": InvalidOrder,
                "11054": InvalidOrder,
                "11055": InvalidOrder,
                "11100": InvalidOrder,
                "11101": InvalidOrder,
                "11102": InvalidOrder,
                "11103": InvalidOrder,
                "11104": InvalidOrder,
                "11105": InvalidOrder,
                "11106": InvalidOrder,
                "11107": InvalidOrder,
                "11200": InvalidOrder,
                "11201": InvalidOrder,
                "11202": InvalidOrder,
                "11203": InvalidOrder,
                "12000": InvalidOrder,
                "12001": InvalidOrder,
                "12002": BadRequest,
                "12003": BadRequest,
                "13000": BadRequest,
                "14000": BadRequest,
                "14001": InvalidOrder,
                "14002": BadRequest,
                "14008": BadRequest,
                "14009": BadRequest,
                "14010": BadRequest,
                "14011": BadRequest,
                "14012": BadRequest,
                "14013": BadRequest,
                "14014": InvalidOrder,
                "14015": BadRequest,
                "14016": BadRequest,
                "14017": BadRequest,
                "14018": BadRequest,
                "14019": BadRequest,
                "14020": BadRequest,
                "14021": BadRequest,
                "14022": AuthenticationError,
                "14023": InvalidOrder,
                "14024": BadRequest,
                "14025": BadRequest,
                "14026": BadRequest,
                "14027": AuthenticationError,
                "14028": BadRequest,
                "14029": AuthenticationError,
                "14030": BadRequest,
                "14031": AuthenticationError,
                "14032": BadRequest,
                "16000": AuthenticationError,
                "16001": AuthenticationError,
                "16100": AuthenticationError,
                "17000": BadRequest,
                "17001": BadRequest,
                "17002": BadRequest,
                "17003": BadRequest,
                "17004": BadRequest,
                "17005": BadRequest,
                "17006": BadRequest,
                "17007": BadRequest,
                "18000": BadRequest,
                "18001": BadRequest,
                "18002": BadRequest,
                "18003": BadRequest,
                "18004": BadRequest,
                "18005": BadRequest,
                "18006": BadRequest,
                "18007": BadRequest,
                "19000": BadRequest,
            },
            "broad": map[string]interface{} {},
        },
        "precisionMode": TICK_SIZE,
        "commonCurrencies": map[string]interface{} {},
        "options": map[string]interface{} {
            "deriveWalletAddress": "",
            "id": "0x0ad42b8e602c2d3d475ae52d678cf63d84ab2749",
        },
    })
}
func  (this *derive) SetSandboxMode(enable interface{})  {
    this.Exchange.SetSandboxMode(enable)
    AddElementToObject(this.Options, "sandboxMode", enable)
}
/**
 * @method
 * @name derive#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @see https://docs.derive.xyz/reference/post_public-get-time
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func  (this *derive) FetchTime(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicPostGetTime(params))
            PanicOnError(response)
        
                //
            // {
            //     "result": 1735846536758,
            //     "id": "f1c03d21-f886-4c5a-9a9d-33dd06f180f0"
            // }
            //
        ch <- this.SafeInteger(response, "result")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name derive#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see https://docs.derive.xyz/reference/post_public-get-all-currencies
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func  (this *derive) FetchCurrencies(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var result interface{} = map[string]interface{} {}
        
            tokenResponse:= (<-this.PublicGetGetAllCurrencies(params))
            PanicOnError(tokenResponse)
            //
            // {
            //     "result": [
            //         {
            //             "currency": "USDC",
            //             "spot_price": "1.000066413299999872",
            //             "spot_price_24h": "1.000327785299999872"
            //         }
            //     ],
            //     "id": "7e07fe1d-0ab4-4d2b-9e22-b65ce9e232dc"
            // }
            //
            var currencies interface{} = this.SafeList(tokenResponse, "result", []interface{}{})
            for i := 0; IsLessThan(i, GetArrayLength(currencies)); i++ {
                var currency interface{} = GetValue(currencies, i)
                var currencyId interface{} = this.SafeString(currency, "currency")
                var code interface{} = this.SafeCurrencyCode(currencyId)
                AddElementToObject(result, code, map[string]interface{} {
            "id": currencyId,
            "name": nil,
            "code": code,
            "precision": nil,
            "active": nil,
            "fee": nil,
            "networks": nil,
            "deposit": nil,
            "withdraw": nil,
            "limits": map[string]interface{} {
                "deposit": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
                "withdraw": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
            },
            "info": currency,
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name derive#fetchMarkets
 * @description retrieves data on all markets for bybit
 * @see https://docs.derive.xyz/reference/post_public-get-all-instruments
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *derive) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var spotMarketsPromise interface{} = this.FetchSpotMarkets(params)
            var swapMarketsPromise interface{} = this.FetchSwapMarkets(params)
            var optionMarketsPromise interface{} = this.FetchOptionMarkets(params)
            spotMarketsswapMarketsoptionMarketsVariable := (<-promiseAll([]interface{}{spotMarketsPromise, swapMarketsPromise, optionMarketsPromise}));
            spotMarkets := GetValue(spotMarketsswapMarketsoptionMarketsVariable,0);
            swapMarkets := GetValue(spotMarketsswapMarketsoptionMarketsVariable,1);
            optionMarkets := GetValue(spotMarketsswapMarketsoptionMarketsVariable,2)
            //
            // {
            //     "result": {
            //         "instruments": [
            //             {
            //                 "instrument_type": "perp",
            //                 "instrument_name": "BTC-PERP",
            //                 "scheduled_activation": 1701840228,
            //                 "scheduled_deactivation": 9223372036854776000,
            //                 "is_active": true,
            //                 "tick_size": "0.1",
            //                 "minimum_amount": "0.01",
            //                 "maximum_amount": "10000",
            //                 "amount_step": "0.001",
            //                 "mark_price_fee_rate_cap": "0",
            //                 "maker_fee_rate": "0.00005",
            //                 "taker_fee_rate": "0.0003",
            //                 "base_fee": "0.1",
            //                 "base_currency": "BTC",
            //                 "quote_currency": "USD",
            //                 "option_details": null,
            //                 "perp_details": {
            //                     "index": "BTC-USD",
            //                     "max_rate_per_hour": "0.004",
            //                     "min_rate_per_hour": "-0.004",
            //                     "static_interest_rate": "0.0000125",
            //                     "aggregate_funding": "10538.574363381759146829",
            //                     "funding_rate": "0.0000125"
            //                 },
            //                 "erc20_details": null,
            //                 "base_asset_address": "0xDBa83C0C654DB1cd914FA2710bA743e925B53086",
            //                 "base_asset_sub_id": "0",
            //                 "pro_rata_fraction": "0",
            //                 "fifo_min_allocation": "0",
            //                 "pro_rata_amount_step": "0.1"
            //             }
            //         ],
            //         "pagination": {
            //             "num_pages": 1,
            //             "count": 1
            //         }
            //     },
            //     "id": "a06bc0b2-8e78-4536-a21f-f785f225b5a5"
            // }
            //
            var result interface{} = this.ArrayConcat(spotMarkets, swapMarkets)
            result = this.ArrayConcat(result, optionMarkets)
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *derive) FetchSpotMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "expired": false,
                "instrument_type": "erc20",
            }
        
            response:= (<-this.PublicPostGetAllInstruments(this.Extend(request, params)))
            PanicOnError(response)
            var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
            var data interface{} = this.SafeList(result, "instruments", []interface{}{})
        
            ch <- this.ParseMarkets(data)
            return nil
        
            }()
            return ch
        }
func  (this *derive) FetchSwapMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "expired": false,
                "instrument_type": "perp",
            }
        
            response:= (<-this.PublicPostGetAllInstruments(this.Extend(request, params)))
            PanicOnError(response)
            var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
            var data interface{} = this.SafeList(result, "instruments", []interface{}{})
        
            ch <- this.ParseMarkets(data)
            return nil
        
            }()
            return ch
        }
func  (this *derive) FetchOptionMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "expired": false,
                "instrument_type": "option",
            }
        
            response:= (<-this.PublicPostGetAllInstruments(this.Extend(request, params)))
            PanicOnError(response)
            var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
            var data interface{} = this.SafeList(result, "instruments", []interface{}{})
        
            ch <- this.ParseMarkets(data)
            return nil
        
            }()
            return ch
        }
func  (this *derive) ParseMarket(market interface{}) interface{}  {
    var typeVar interface{} = this.SafeString(market, "instrument_type")
    var marketType interface{} = nil
    var spot interface{} = false
    var margin interface{} = true
    var swap interface{} = false
    var option interface{} = false
    var linear interface{} = nil
    var baseId interface{} = this.SafeString(market, "base_currency")
    var quoteId interface{} = this.SafeString(market, "quote_currency")
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    var marketId interface{} = this.SafeString(market, "instrument_name")
    var symbol interface{} = Add(Add(base, "/"), quote)
    var settleId interface{} = nil
    var settle interface{} = nil
    var expiry interface{} = nil
    var strike interface{} = nil
    var optionType interface{} = nil
    var optionLetter interface{} = nil
    if IsTrue(IsEqual(typeVar, "erc20")) {
        spot = true
        marketType = "spot"
    } else if IsTrue(IsEqual(typeVar, "perp")) {
        margin = false
        settleId = "USDC"
        settle = this.SafeCurrencyCode(settleId)
        symbol = Add(Add(Add(Add(base, "/"), quote), ":"), settle)
        swap = true
        linear = true
        marketType = "swap"
    } else if IsTrue(IsEqual(typeVar, "option")) {
        settleId = "USDC"
        settle = this.SafeCurrencyCode(settleId)
        margin = false
        option = true
        marketType = "option"
        var optionDetails interface{} = this.SafeDict(market, "option_details")
        expiry = this.SafeTimestamp(optionDetails, "expiry")
        strike = this.SafeInteger(optionDetails, "strike")
        optionLetter = this.SafeString(optionDetails, "option_type")
        symbol = Add(Add(Add(Add(Add(Add(Add(Add(Add(Add(base, "/"), quote), ":"), settle), "-"), this.Yymmdd(expiry)), "-"), this.NumberToString(strike)), "-"), optionLetter)
        if IsTrue(IsEqual(optionLetter, "P")) {
            optionType = "put"
        } else {
            optionType = "call"
        }
    }
    return this.SafeMarketStructure(map[string]interface{} {
        "id": marketId,
        "symbol": symbol,
        "base": base,
        "quote": quote,
        "settle": settle,
        "baseId": baseId,
        "quoteId": quoteId,
        "settleId": settleId,
        "type": marketType,
        "spot": spot,
        "margin": margin,
        "swap": swap,
        "future": false,
        "option": option,
        "active": this.SafeBool(market, "is_active"),
        "contract": (IsTrue(swap) || IsTrue(option)),
        "linear": linear,
        "inverse": nil,
        "contractSize": Ternary(IsTrue((spot)), nil, 1),
        "expiry": expiry,
        "expiryDatetime": this.Iso8601(expiry),
        "taker": this.SafeNumber(market, "taker_fee_rate"),
        "maker": this.SafeNumber(market, "maker_fee_rate"),
        "strike": strike,
        "optionType": optionType,
        "precision": map[string]interface{} {
            "amount": this.SafeNumber(market, "amount_step"),
            "price": this.SafeNumber(market, "tick_size"),
        },
        "limits": map[string]interface{} {
            "leverage": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "amount": map[string]interface{} {
                "min": this.SafeNumber(market, "minimum_amount"),
                "max": this.SafeNumber(market, "maximum_amount"),
            },
            "price": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "cost": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
        },
        "created": nil,
        "info": market,
    })
}
/**
 * @method
 * @name derive#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://docs.derive.xyz/reference/post_public-get-ticker
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *derive) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes7098 := (<-this.LoadMarkets())
            PanicOnError(retRes7098)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "instrument_name": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicPostGetTicker(this.Extend(request, params)))
            PanicOnError(response)
            //
            // spot
            //
            // {
            //     "result": {
            //         "instrument_type": "perp",
            //         "instrument_name": "BTC-PERP",
            //         "scheduled_activation": 1701840228,
            //         "scheduled_deactivation": 9223372036854776000,
            //         "is_active": true,
            //         "tick_size": "0.1",
            //         "minimum_amount": "0.01",
            //         "maximum_amount": "10000",
            //         "amount_step": "0.001",
            //         "mark_price_fee_rate_cap": "0",
            //         "maker_fee_rate": "0.00005",
            //         "taker_fee_rate": "0.0003",
            //         "base_fee": "0.1",
            //         "base_currency": "BTC",
            //         "quote_currency": "USD",
            //         "option_details": null,
            //         "perp_details": {
            //             "index": "BTC-USD",
            //             "max_rate_per_hour": "0.004",
            //             "min_rate_per_hour": "-0.004",
            //             "static_interest_rate": "0.0000125",
            //             "aggregate_funding": "10512.580833189805742522",
            //             "funding_rate": "-0.000022223906766867"
            //         },
            //         "erc20_details": null,
            //         "base_asset_address": "0xDBa83C0C654DB1cd914FA2710bA743e925B53086",
            //         "base_asset_sub_id": "0",
            //         "pro_rata_fraction": "0",
            //         "fifo_min_allocation": "0",
            //         "pro_rata_amount_step": "0.1",
            //         "best_ask_amount": "0.012",
            //         "best_ask_price": "99567.9",
            //         "best_bid_amount": "0.129",
            //         "best_bid_price": "99554.5",
            //         "five_percent_bid_depth": "11.208",
            //         "five_percent_ask_depth": "11.42",
            //         "option_pricing": null,
            //         "index_price": "99577.2",
            //         "mark_price": "99543.642926357933902181684970855712890625",
            //         "stats": {
            //             "contract_volume": "464.712",
            //             "num_trades": "10681",
            //             "open_interest": "72.804739389481989861",
            //             "high": "99519.1",
            //             "low": "97254.1",
            //             "percent_change": "0.0128",
            //             "usd_change": "1258.1"
            //         },
            //         "timestamp": 1736140984000,
            //         "min_price": "97591.2",
            //         "max_price": "101535.1"
            //     },
            //     "id": "bbd7c271-c2be-48f7-b93a-26cf6d4cb79f"
            // }
            //
            var data interface{} = this.SafeDict(response, "result", map[string]interface{} {})
        
            ch <- this.ParseTicker(data, market)
            return nil
        
            }()
            return ch
        }
func  (this *derive) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // {
    //     "instrument_type": "perp",
    //     "instrument_name": "BTC-PERP",
    //     "scheduled_activation": 1701840228,
    //     "scheduled_deactivation": 9223372036854776000,
    //     "is_active": true,
    //     "tick_size": "0.1",
    //     "minimum_amount": "0.01",
    //     "maximum_amount": "10000",
    //     "amount_step": "0.001",
    //     "mark_price_fee_rate_cap": "0",
    //     "maker_fee_rate": "0.00005",
    //     "taker_fee_rate": "0.0003",
    //     "base_fee": "0.1",
    //     "base_currency": "BTC",
    //     "quote_currency": "USD",
    //     "option_details": null,
    //     "perp_details": {
    //         "index": "BTC-USD",
    //         "max_rate_per_hour": "0.004",
    //         "min_rate_per_hour": "-0.004",
    //         "static_interest_rate": "0.0000125",
    //         "aggregate_funding": "10512.580833189805742522",
    //         "funding_rate": "-0.000022223906766867"
    //     },
    //     "erc20_details": null,
    //     "base_asset_address": "0xDBa83C0C654DB1cd914FA2710bA743e925B53086",
    //     "base_asset_sub_id": "0",
    //     "pro_rata_fraction": "0",
    //     "fifo_min_allocation": "0",
    //     "pro_rata_amount_step": "0.1",
    //     "best_ask_amount": "0.012",
    //     "best_ask_price": "99567.9",
    //     "best_bid_amount": "0.129",
    //     "best_bid_price": "99554.5",
    //     "five_percent_bid_depth": "11.208",
    //     "five_percent_ask_depth": "11.42",
    //     "option_pricing": null,
    //     "index_price": "99577.2",
    //     "mark_price": "99543.642926357933902181684970855712890625",
    //     "stats": {
    //         "contract_volume": "464.712",
    //         "num_trades": "10681",
    //         "open_interest": "72.804739389481989861",
    //         "high": "99519.1",
    //         "low": "97254.1",
    //         "percent_change": "0.0128",
    //         "usd_change": "1258.1"
    //     },
    //     "timestamp": 1736140984000,
    //     "min_price": "97591.2",
    //     "max_price": "101535.1"
    // }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(ticker, "instrument_name")
    var timestamp interface{} = this.SafeIntegerOmitZero(ticker, "timestamp")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var stats interface{} = this.SafeDict(ticker, "stats")
    var change interface{} = this.SafeString(stats, "percent_change")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeString(stats, "high"),
        "low": this.SafeString(stats, "low"),
        "bid": this.SafeString(ticker, "best_bid_price"),
        "bidVolume": this.SafeString(ticker, "best_bid_amount"),
        "ask": this.SafeString(ticker, "best_ask_price"),
        "askVolume": this.SafeString(ticker, "best_ask_amount"),
        "vwap": nil,
        "open": nil,
        "close": nil,
        "last": nil,
        "previousClose": nil,
        "change": change,
        "percentage": Precise.StringMul(change, "100"),
        "average": nil,
        "baseVolume": nil,
        "quoteVolume": nil,
        "indexPrice": this.SafeString(ticker, "index_price"),
        "markPrice": this.SafeString(ticker, "mark_price"),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name derive#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://docs.derive.xyz/reference/post_public-get-trade-history
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch trades for
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *derive) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes8798 := (<-this.LoadMarkets())
            PanicOnError(retRes8798)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "instrument_name", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                if IsTrue(IsGreaterThan(limit, 1000)) {
                    limit = 1000
                }
                AddElementToObject(request, "page_size", limit) // default 100, max 1000
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "from_timestamp", since)
            }
            var until interface{} = this.SafeInteger(params, "until")
            params = this.Omit(params, []interface{}{"until"})
            if IsTrue(!IsEqual(until, nil)) {
                AddElementToObject(request, "to_timestamp", until)
            }
        
            response:= (<-this.PublicPostGetTradeHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "result": {
            //         "trades": [
            //             {
            //                 "trade_id": "9dbc88b0-f0c4-4439-9cc1-4e6409d4eafb",
            //                 "instrument_name": "BTC-PERP",
            //                 "timestamp": 1736153910930,
            //                 "trade_price": "98995.3",
            //                 "trade_amount": "0.033",
            //                 "mark_price": "98990.875914388161618263",
            //                 "index_price": "99038.050611100001501184",
            //                 "direction": "sell",
            //                 "quote_id": null,
            //                 "wallet": "0x88B6BB87fbFac92a34F8155aaA35c87B5b166fA9",
            //                 "subaccount_id": 8250,
            //                 "tx_status": "settled",
            //                 "tx_hash": "0x020bd735b312f867f17f8cc254946d87cfe9f2c8ff3605035d8129082eb73723",
            //                 "trade_fee": "0.980476701049890015",
            //                 "liquidity_role": "taker",
            //                 "realized_pnl": "-2.92952402688793509",
            //                 "realized_pnl_excl_fees": "-1.949047325838045075"
            //             }
            //         ],
            //         "pagination": {
            //             "num_pages": 598196,
            //             "count": 598196
            //         }
            //     },
            //     "id": "b8539544-6975-4497-8163-5e51a38e4aa7"
            // }
            //
            var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
            var data interface{} = this.SafeList(result, "trades", []interface{}{})
        
            ch <- this.ParseTrades(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *derive) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // {
    //     "subaccount_id": 130837,
    //     "order_id": "30c48194-8d48-43ac-ad00-0d5ba29eddc9",
    //     "instrument_name": "BTC-PERP",
    //     "direction": "sell",
    //     "label": "test1234",
    //     "quote_id": null,
    //     "trade_id": "f8a30740-488c-4c2d-905d-e17057bafde1",
    //     "timestamp": 1738065303708,
    //     "mark_price": "102740.137375457314192317",
    //     "index_price": "102741.553409299981533184",
    //     "trade_price": "102700.6",
    //     "trade_amount": "0.01",
    //     "liquidity_role": "taker",
    //     "realized_pnl": "0",
    //     "realized_pnl_excl_fees": "0",
    //     "is_transfer": false,
    //     "tx_status": "settled",
    //     "trade_fee": "1.127415534092999815",
    //     "tx_hash": "0xc55df1f07330faf86579bd8a6385391fbe9e73089301149d8550e9d29c9ead74",
    //     "transaction_id": "e18b9426-3fa5-41bb-99d3-8b54fb4d51bb"
    // }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(trade, "instrument_name")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var timestamp interface{} = this.SafeInteger(trade, "timestamp")
    var fee interface{} = map[string]interface{} {
        "currency": "USDC",
        "cost": this.SafeString(trade, "trade_fee"),
    }
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "id": this.SafeString(trade, "trade_id"),
        "order": this.SafeString(trade, "order_id"),
        "symbol": symbol,
        "side": this.SafeStringLower(trade, "direction"),
        "type": nil,
        "takerOrMaker": this.SafeString(trade, "liquidity_role"),
        "price": this.SafeString(trade, "trade_price"),
        "amount": this.SafeString(trade, "trade_amount"),
        "cost": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "fee": fee,
    }, market)
}
/**
 * @method
 * @name derive#fetchFundingRateHistory
 * @description fetches historical funding rate prices
 * @see https://docs.derive.xyz/reference/post_public-get-funding-rate-history
 * @param {string} symbol unified symbol of the market to fetch the funding rate history for
 * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
 * @param {int} [limit] the maximum amount of funding rate structures to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
 */
func  (this *derive) FetchFundingRateHistory(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes9998 := (<-this.LoadMarkets())
            PanicOnError(retRes9998)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "instrument_name": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_timestamp", since)
            }
            var until interface{} = this.SafeInteger(params, "until")
            params = this.Omit(params, []interface{}{"until"})
            if IsTrue(!IsEqual(until, nil)) {
                AddElementToObject(request, "to_timestamp", until)
            }
        
            response:= (<-this.PublicPostGetFundingRateHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "result": {
            //         "funding_rate_history": [
            //             {
            //                 "timestamp": 1736215200000,
            //                 "funding_rate": "-0.000020014"
            //             }
            //         ]
            //     },
            //     "id": "3200ab8d-0080-42f0-8517-c13e3d9201d8"
            // }
            //
            var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
            var data interface{} = this.SafeList(result, "funding_rate_history", []interface{}{})
            var rates interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
                var entry interface{} = GetValue(data, i)
                var timestamp interface{} = this.SafeInteger(entry, "timestamp")
                AppendToArray(&rates,map[string]interface{} {
                    "info": entry,
                    "symbol": GetValue(market, "symbol"),
                    "fundingRate": this.SafeNumber(entry, "funding_rate"),
                    "timestamp": timestamp,
                    "datetime": this.Iso8601(timestamp),
                })
            }
            var sorted interface{} = this.SortBy(rates, "timestamp")
        
            ch <- this.FilterBySymbolSinceLimit(sorted, GetValue(market, "symbol"), since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name derive#fetchFundingRate
 * @description fetch the current funding rate
 * @see https://docs.derive.xyz/reference/post_public-get-funding-rate-history
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
 */
func  (this *derive) FetchFundingRate(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.FetchFundingRateHistory(symbol, nil, 1, params))
            PanicOnError(response)
            //
            // [
            //     {
            //         "info": {
            //             "timestamp": 1736157600000,
            //             "funding_rate": "-0.000008872"
            //         },
            //         "symbol": "BTC/USD:USDC",
            //         "fundingRate": -0.000008872,
            //         "timestamp": 1736157600000,
            //         "datetime": "2025-01-06T10:00:00.000Z"
            //     }
            // ]
            //
            var data interface{} = this.SafeDict(response, 0)
        
            ch <- this.ParseFundingRate(data)
            return nil
        
            }()
            return ch
        }
func  (this *derive) ParseFundingRate(contract interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var symbol interface{} = this.SafeString(contract, "symbol")
    var fundingTimestamp interface{} = this.SafeInteger(contract, "timestamp")
    return map[string]interface{} {
        "info": contract,
        "symbol": symbol,
        "markPrice": nil,
        "indexPrice": nil,
        "interestRate": nil,
        "estimatedSettlePrice": nil,
        "timestamp": nil,
        "datetime": nil,
        "fundingRate": this.SafeNumber(contract, "fundingRate"),
        "fundingTimestamp": fundingTimestamp,
        "fundingDatetime": this.Iso8601(fundingTimestamp),
        "nextFundingRate": nil,
        "nextFundingTimestamp": nil,
        "nextFundingDatetime": nil,
        "previousFundingRate": nil,
        "previousFundingTimestamp": nil,
        "previousFundingDatetime": nil,
        "interval": nil,
    }
}
func  (this *derive) HashOrderMessage(order interface{}) interface{}  {
    var accountHash interface{} = this.Hash(this.EthAbiEncode([]interface{}{"bytes32", "uint256", "uint256", "address", "bytes32", "uint256", "address", "address"}, order), keccak, "binary")
    var sandboxMode interface{} = this.SafeBool(this.Options, "sandboxMode", false)
    var DOMAIN_SEPARATOR interface{} = Ternary(IsTrue((sandboxMode)), "9bcf4dc06df5d8bf23af818d5716491b995020f377d3b7b64c29ed14e3dd1105", "d96e5f90797da7ec8dc4e276260c7f3f87fedf68775fbe1ef116e996fc60441b")
    var binaryDomainSeparator interface{} = this.Base16ToBinary(DOMAIN_SEPARATOR)
    var prefix interface{} = this.Base16ToBinary("1901")
    return this.Hash(this.BinaryConcat(prefix, binaryDomainSeparator, accountHash), keccak, "hex")
}
func  (this *derive) SignOrder(order interface{}, privateKey interface{}) interface{}  {
    var hashOrder interface{} = this.HashOrderMessage(order)
    return this.SignHash(Slice(hashOrder, OpNeg(64), nil), Slice(privateKey, OpNeg(64), nil))
}
func  (this *derive) HashMessage(message interface{}) interface{}  {
    var binaryMessage interface{} = this.Encode(message)
    var binaryMessageLength interface{} = this.BinaryLength(binaryMessage)
    var x19 interface{} = this.Base16ToBinary("19")
    var newline interface{} = this.Base16ToBinary("0a")
    var prefix interface{} = this.BinaryConcat(x19, this.Encode("Ethereum Signed Message:"), newline, this.Encode(this.NumberToString(binaryMessageLength)))
    return Add("0x", this.Hash(this.BinaryConcat(prefix, binaryMessage), keccak, "hex"))
}
func  (this *derive) SignHash(hash interface{}, privateKey interface{}) interface{}  {
    this.CheckRequiredCredentials()
    var signature interface{} = Ecdsa(Slice(hash, OpNeg(64), nil), Slice(privateKey, OpNeg(64), nil), secp256k1, nil)
    var r interface{} = GetValue(signature, "r")
    var s interface{} = GetValue(signature, "s")
    var v interface{} = this.IntToBase16(this.Sum(27, GetValue(signature, "v")))
    return Add(Add(Add("0x", PadStart(r, 64, "0")), PadStart(s, 64, "0")), v)
}
func  (this *derive) SignMessage(message interface{}, privateKey interface{}) interface{}  {
    return this.SignHash(this.HashMessage(message), Slice(privateKey, OpNeg(64), nil))
}
func  (this *derive) ParseUnits(num interface{}, optionalArgs ...interface{}) interface{}  {
    dec := GetArg(optionalArgs, 0, "1000000000000000000")
    _ = dec
    return Precise.StringMul(num, dec)
}
/**
 * @method
 * @name derive#createOrder
 * @description create a trade order
 * @see https://docs.derive.xyz/reference/post_private-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.subaccount_id] *required* the subaccount id
 * @param {float} [params.triggerPrice] The price a trigger order is triggered at
 * @param {object} [params.takeProfit] *takeProfit object in params* containing the triggerPrice at which the attached take profit order will be triggered (perpetual swap markets only)
 * @param {float} [params.takeProfit.triggerPrice] take profit trigger price
 * @param {object} [params.stopLoss] *stopLoss object in params* containing the triggerPrice at which the attached stop loss order will be triggered (perpetual swap markets only)
 * @param {float} [params.stopLoss.triggerPrice] stop loss trigger price
 * @param {float} [params.max_fee] *required* the maximum fee you are willing to pay for the order
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *derive) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes11618 := (<-this.LoadMarkets())
            PanicOnError(retRes11618)
            var market interface{} = this.Market(symbol)
            if IsTrue(IsEqual(price, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " createOrder() requires a price argument")))
            }
            var subaccountId interface{} = nil
            subaccountIdparamsVariable := this.HandleDeriveSubaccountId("createOrder", params);
            subaccountId = GetValue(subaccountIdparamsVariable,0);
            params = GetValue(subaccountIdparamsVariable,1)
            var test interface{} = this.SafeBool(params, "test", false)
            var reduceOnly interface{} = this.SafeBool2(params, "reduceOnly", "reduce_only")
            var timeInForce interface{} = this.SafeStringLower2(params, "timeInForce", "time_in_force")
            var postOnly interface{} = this.SafeBool(params, "postOnly")
            var orderType interface{} = ToLower(typeVar)
            var orderSide interface{} = ToLower(side)
            var nonce interface{} = this.Milliseconds()
            // Order signature expiry must be between 2592000 and 7776000 sec from now
            var signatureExpiry interface{} = this.SafeInteger(params, "signature_expiry_sec", Add(this.Seconds(), 7776000))
            var ACTION_TYPEHASH interface{} = this.Base16ToBinary("4d7a9f27c403ff9c0f19bce61d76d82f9aa29f8d6d4b0c5474607d9770d1af17")
            var sandboxMode interface{} = this.SafeBool(this.Options, "sandboxMode", false)
            var TRADE_MODULE_ADDRESS interface{} = Ternary(IsTrue((sandboxMode)), "0x87F2863866D85E3192a35A73b388BD625D83f2be", "0xB8D20c2B7a1Ad2EE33Bc50eF10876eD3035b5e7b")
            var priceString interface{} = this.NumberToString(price)
            var maxFee interface{} = nil
            maxFeeparamsVariable := this.HandleOptionAndParams(params, "createOrder", "max_fee");
            maxFee = GetValue(maxFeeparamsVariable,0);
            params = GetValue(maxFeeparamsVariable,1)
            if IsTrue(IsEqual(maxFee, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " createOrder() requires a max_fee argument in params")))
            }
            var maxFeeString interface{} = this.NumberToString(maxFee)
            var amountString interface{} = this.NumberToString(amount)
            var tradeModuleDataHash interface{} = this.Hash(this.EthAbiEncode([]interface{}{"address", "uint", "int", "int", "uint", "uint", "bool"}, []interface{}{GetValue(GetValue(market, "info"), "base_asset_address"), this.ParseToNumeric(GetValue(GetValue(market, "info"), "base_asset_sub_id")), this.ConvertToBigInt(this.ParseUnits(priceString)), this.ConvertToBigInt(this.ParseUnits(this.AmountToPrecision(symbol, amountString))), this.ConvertToBigInt(this.ParseUnits(maxFeeString)), subaccountId, IsEqual(orderSide, "buy")}), keccak, "binary")
            var deriveWalletAddress interface{} = nil
            deriveWalletAddressparamsVariable := this.HandleDeriveWalletAddress("createOrder", params);
            deriveWalletAddress = GetValue(deriveWalletAddressparamsVariable,0);
            params = GetValue(deriveWalletAddressparamsVariable,1)
            var signature interface{} = this.SignOrder([]interface{}{ACTION_TYPEHASH, subaccountId, nonce, TRADE_MODULE_ADDRESS, tradeModuleDataHash, signatureExpiry, deriveWalletAddress, this.WalletAddress}, this.PrivateKey)
            var request interface{} = map[string]interface{} {
                "instrument_name": GetValue(market, "id"),
                "direction": orderSide,
                "order_type": orderType,
                "nonce": nonce,
                "amount": amountString,
                "limit_price": priceString,
                "max_fee": maxFeeString,
                "subaccount_id": subaccountId,
                "signature_expiry_sec": signatureExpiry,
                "referral_code": this.SafeString(this.Options, "id", "0x0ad42b8e602c2d3d475ae52d678cf63d84ab2749"),
                "signer": this.WalletAddress,
            }
            if IsTrue(!IsEqual(reduceOnly, nil)) {
                AddElementToObject(request, "reduce_only", reduceOnly)
                if IsTrue(IsTrue(reduceOnly) && IsTrue(postOnly)) {
                    panic(InvalidOrder(Add(this.Id, " cannot use reduce only with post only time in force")))
                }
            }
            if IsTrue(!IsEqual(postOnly, nil)) {
                AddElementToObject(request, "time_in_force", "post_only")
            } else if IsTrue(!IsEqual(timeInForce, nil)) {
                AddElementToObject(request, "time_in_force", timeInForce)
            }
            var stopLoss interface{} = this.SafeValue(params, "stopLoss")
            var takeProfit interface{} = this.SafeValue(params, "takeProfit")
            var triggerPriceType interface{} = this.SafeString(params, "trigger_price_type", "mark")
            if IsTrue(!IsEqual(stopLoss, nil)) {
                var stopLossPrice interface{} = this.SafeString(stopLoss, "triggerPrice", stopLoss)
                AddElementToObject(request, "trigger_price", stopLossPrice)
                AddElementToObject(request, "trigger_type", "stoploss")
                AddElementToObject(request, "trigger_price_type", triggerPriceType)
            } else if IsTrue(!IsEqual(takeProfit, nil)) {
                var takeProfitPrice interface{} = this.SafeString(takeProfit, "triggerPrice", takeProfit)
                AddElementToObject(request, "trigger_price", takeProfitPrice)
                AddElementToObject(request, "trigger_type", "takeprofit")
                AddElementToObject(request, "trigger_price_type", triggerPriceType)
            }
            var clientOrderId interface{} = this.SafeString(params, "clientOrderId")
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                AddElementToObject(request, "label", clientOrderId)
            }
            AddElementToObject(request, "signature", signature)
            params = this.Omit(params, []interface{}{"reduceOnly", "reduce_only", "timeInForce", "time_in_force", "postOnly", "test", "clientOrderId", "stopPrice", "triggerPrice", "trigger_price", "stopLoss", "takeProfit", "trigger_price_type"})
            var response interface{} = nil
            if IsTrue(test) {
                
        response = (<-this.PrivatePostOrderDebug(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PrivatePostOrder(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            // {
            //     "result": {
            //         "raw_data": {
            //             "subaccount_id": 130837,
            //             "nonce": 1736923517552,
            //             "module": "0x87F2863866D85E3192a35A73b388BD625D83f2be",
            //             "expiry": 86400,
            //             "owner": "0x108b9aF9279a525b8A8AeAbE7AC2bA925Bc50075",
            //             "signer": "0x108b9aF9279a525b8A8AeAbE7AC2bA925Bc50075",
            //             "signature": "0xaa4f42b2f3da33c668fa703ea872d4c3a6b55aca66025b5119e3bebb6679fe2e2794638db51dcace21fc39a498047835994f07eb59f311bb956ce057e66793d1c",
            //             "data": {
            //                 "asset": "0xAFB6Bb95cd70D5367e2C39e9dbEb422B9815339D",
            //                 "sub_id": 0,
            //                 "limit_price": "10000",
            //                 "desired_amount": "0.001",
            //                 "worst_fee": "0",
            //                 "recipient_id": 130837,
            //                 "is_bid": true,
            //                 "trade_id": ""
            //             }
            //         },
            //         "encoded_data": "0x000000000000000000000000afb6bb95cd70d5367e2c39e9dbeb422b9815339d000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000021e19e0c9bab240000000000000000000000000000000000000000000000000000000038d7ea4c680000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001ff150000000000000000000000000000000000000000000000000000000000000001",
            //         "encoded_data_hashed": "0xe88fb416bc54dba2d288988f1a82fee40fd792ed555b3471b5f6b4b810d279b4",
            //         "action_hash": "0x273a0befb3751fa991edc7ed73582456c3b50ae964d458c8f472e932fb6a0069",
            //         "typed_data_hash": "0x123e2d2f3d5b2473b4e260f51c6459d6bf904e5db8f042a3ea63be8d55329ce9"
            //     },
            //     "id": "f851c8c4-dddf-4b77-93cf-aeddd0966f29"
            // }
            // {
            //     "result": {
            //         "order": {
            //             "subaccount_id": 130837,
            //             "order_id": "96349ebb-7d46-43ae-81c7-7ab390444293",
            //             "instrument_name": "BTC-PERP",
            //             "direction": "buy",
            //             "label": "",
            //             "quote_id": null,
            //             "creation_timestamp": 1737467576257,
            //             "last_update_timestamp": 1737467576257,
            //             "limit_price": "10000",
            //             "amount": "0.01",
            //             "filled_amount": "0",
            //             "average_price": "0",
            //             "order_fee": "0",
            //             "order_type": "limit",
            //             "time_in_force": "gtc",
            //             "order_status": "open",
            //             "max_fee": "210",
            //             "signature_expiry_sec": 1737468175989,
            //             "nonce": 1737467575989,
            //             "signer": "0x30CB7B06AdD6749BbE146A6827502B8f2a79269A",
            //             "signature": "0xd1ca49df1fa06bd805bb59b132ff6c0de29bf973a3e01705abe0a01cc956e4945ed9eb99ab68f3df4c037908113cac5a5bfc3a954a0b7103cdab285962fa6a51c",
            //             "cancel_reason": "",
            //             "mmp": false,
            //             "is_transfer": false,
            //             "replaced_order_id": null,
            //             "trigger_type": null,
            //             "trigger_price_type": null,
            //             "trigger_price": null,
            //             "trigger_reject_message": null
            //         },
            //         "trades": []
            //     },
            //     "id": "397087fa-0125-42af-bfc3-f66166f9fb55"
            // }
            //
            var result interface{} = this.SafeDict(response, "result")
            var rawOrder interface{} = this.SafeDict(result, "raw_data")
            if IsTrue(IsEqual(rawOrder, nil)) {
                rawOrder = this.SafeDict(result, "order")
            }
            var order interface{} = this.ParseOrder(rawOrder, market)
            AddElementToObject(order, "type", typeVar)
        
            ch <- order
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name derive#editOrder
 * @description edit a trade order
 * @see https://docs.derive.xyz/reference/post_private-replace
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.subaccount_id] *required* the subaccount id
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *derive) EditOrder(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    amount := GetArg(optionalArgs, 0, nil)
            _ = amount
            price := GetArg(optionalArgs, 1, nil)
            _ = price
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes13548 := (<-this.LoadMarkets())
            PanicOnError(retRes13548)
            var market interface{} = this.Market(symbol)
            var subaccountId interface{} = nil
            subaccountIdparamsVariable := this.HandleDeriveSubaccountId("editOrder", params);
            subaccountId = GetValue(subaccountIdparamsVariable,0);
            params = GetValue(subaccountIdparamsVariable,1)
            var reduceOnly interface{} = this.SafeBool2(params, "reduceOnly", "reduce_only")
            var timeInForce interface{} = this.SafeStringLower2(params, "timeInForce", "time_in_force")
            var postOnly interface{} = this.SafeBool(params, "postOnly")
            var orderType interface{} = ToLower(typeVar)
            var orderSide interface{} = ToLower(side)
            var nonce interface{} = this.Milliseconds()
            var signatureExpiry interface{} = this.SafeNumber(params, "signature_expiry_sec", Add(this.Seconds(), 7776000))
            // TODO: subaccount id / trade module address
            var ACTION_TYPEHASH interface{} = this.Base16ToBinary("4d7a9f27c403ff9c0f19bce61d76d82f9aa29f8d6d4b0c5474607d9770d1af17")
            var sandboxMode interface{} = this.SafeBool(this.Options, "sandboxMode", false)
            var TRADE_MODULE_ADDRESS interface{} = Ternary(IsTrue((sandboxMode)), "0x87F2863866D85E3192a35A73b388BD625D83f2be", "0xB8D20c2B7a1Ad2EE33Bc50eF10876eD3035b5e7b")
            var priceString interface{} = this.NumberToString(price)
            var maxFeeString interface{} = this.SafeString(params, "max_fee", "0")
            var amountString interface{} = this.NumberToString(amount)
            var tradeModuleDataHash interface{} = this.Hash(this.EthAbiEncode([]interface{}{"address", "uint", "int", "int", "uint", "uint", "bool"}, []interface{}{GetValue(GetValue(market, "info"), "base_asset_address"), this.ParseToNumeric(GetValue(GetValue(market, "info"), "base_asset_sub_id")), this.ConvertToBigInt(this.ParseUnits(priceString)), this.ConvertToBigInt(this.ParseUnits(this.AmountToPrecision(symbol, amountString))), this.ConvertToBigInt(this.ParseUnits(maxFeeString)), subaccountId, IsEqual(orderSide, "buy")}), keccak, "binary")
            var deriveWalletAddress interface{} = nil
            deriveWalletAddressparamsVariable := this.HandleDeriveWalletAddress("editOrder", params);
            deriveWalletAddress = GetValue(deriveWalletAddressparamsVariable,0);
            params = GetValue(deriveWalletAddressparamsVariable,1)
            var signature interface{} = this.SignOrder([]interface{}{ACTION_TYPEHASH, subaccountId, nonce, TRADE_MODULE_ADDRESS, tradeModuleDataHash, signatureExpiry, deriveWalletAddress, this.WalletAddress}, this.PrivateKey)
            var request interface{} = map[string]interface{} {
                "instrument_name": GetValue(market, "id"),
                "order_id_to_cancel": id,
                "direction": orderSide,
                "order_type": orderType,
                "nonce": nonce,
                "amount": amountString,
                "limit_price": priceString,
                "max_fee": maxFeeString,
                "subaccount_id": subaccountId,
                "signature_expiry_sec": signatureExpiry,
                "signer": this.WalletAddress,
            }
            if IsTrue(!IsEqual(reduceOnly, nil)) {
                AddElementToObject(request, "reduce_only", reduceOnly)
                if IsTrue(IsTrue(reduceOnly) && IsTrue(postOnly)) {
                    panic(InvalidOrder(Add(this.Id, " cannot use reduce only with post only time in force")))
                }
            }
            if IsTrue(!IsEqual(postOnly, nil)) {
                AddElementToObject(request, "time_in_force", "post_only")
            } else if IsTrue(!IsEqual(timeInForce, nil)) {
                AddElementToObject(request, "time_in_force", timeInForce)
            }
            var clientOrderId interface{} = this.SafeString(params, "clientOrderId")
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                AddElementToObject(request, "label", clientOrderId)
            }
            AddElementToObject(request, "signature", signature)
            params = this.Omit(params, []interface{}{"reduceOnly", "reduce_only", "timeInForce", "time_in_force", "postOnly", "clientOrderId"})
        
            response:= (<-this.PrivatePostReplace(this.Extend(request, params)))
            PanicOnError(response)
            //
            //   {
            //     "result":
            //       {
            //         "cancelled_order":
            //           {
            //             "subaccount_id": 130837,
            //             "order_id": "c2337704-f1af-437d-91c8-dddb9d6bac59",
            //             "instrument_name": "BTC-PERP",
            //             "direction": "buy",
            //             "label": "test1234",
            //             "quote_id": null,
            //             "creation_timestamp": 1737539743959,
            //             "last_update_timestamp": 1737539764234,
            //             "limit_price": "10000",
            //             "amount": "0.01",
            //             "filled_amount": "0",
            //             "average_price": "0",
            //             "order_fee": "0",
            //             "order_type": "limit",
            //             "time_in_force": "post_only",
            //             "order_status": "cancelled",
            //             "max_fee": "211",
            //             "signature_expiry_sec": 1737540343631,
            //             "nonce": 1737539743631,
            //             "signer": "0x30CB7B06AdD6749BbE146A6827502B8f2a79269A",
            //             "signature": "0xdb669e18f407a3efa816b79c0dd3bac1c651d4dbf3caad4db67678ce9b81c76378d787a08143a30707eb0827ce4626640767c9f174358df1b90611bd6d1391711b",
            //             "cancel_reason": "user_request",
            //             "mmp": false,
            //             "is_transfer": false,
            //             "replaced_order_id": null,
            //             "trigger_type": null,
            //             "trigger_price_type": null,
            //             "trigger_price": null,
            //             "trigger_reject_message": null,
            //           },
            //         "order":
            //           {
            //             "subaccount_id": 130837,
            //             "order_id": "97af0902-813f-4892-a54b-797e5689db05",
            //             "instrument_name": "BTC-PERP",
            //             "direction": "buy",
            //             "label": "test1234",
            //             "quote_id": null,
            //             "creation_timestamp": 1737539764154,
            //             "last_update_timestamp": 1737539764154,
            //             "limit_price": "10000",
            //             "amount": "0.01",
            //             "filled_amount": "0",
            //             "average_price": "0",
            //             "order_fee": "0",
            //             "order_type": "limit",
            //             "time_in_force": "post_only",
            //             "order_status": "open",
            //             "max_fee": "211",
            //             "signature_expiry_sec": 1737540363890,
            //             "nonce": 1737539763890,
            //             "signer": "0x30CB7B06AdD6749BbE146A6827502B8f2a79269A",
            //             "signature": "0xef2c459ab4797cbbd7d97b47678ff172542af009bac912bf53e7879cf92eb1aa6b1a6cf40bf0928684f5394942fb424cc2db71eac0eaf7226a72480034332f291c",
            //             "cancel_reason": "",
            //             "mmp": false,
            //             "is_transfer": false,
            //             "replaced_order_id": "c2337704-f1af-437d-91c8-dddb9d6bac59",
            //             "trigger_type": null,
            //             "trigger_price_type": null,
            //             "trigger_price": null,
            //             "trigger_reject_message": null,
            //           },
            //         "trades": [],
            //         "create_order_error": null,
            //       },
            //     "id": "fb19e991-15f6-4c80-a20c-917e762a1a38",
            //   }
            //
            var result interface{} = this.SafeDict(response, "result")
            var rawOrder interface{} = this.SafeDict(result, "order")
            var order interface{} = this.ParseOrder(rawOrder, market)
        
            ch <- order
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name derive#cancelOrder
 * @see https://docs.derive.xyz/reference/post_private-cancel
 * @description cancels an open order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] whether the order is a trigger/algo order
 * @param {string} [params.subaccount_id] *required* the subaccount id
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *derive) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " cancelOrder() requires a symbol argument")))
            }
        
            retRes15228 := (<-this.LoadMarkets())
            PanicOnError(retRes15228)
            var market interface{} = this.Market(symbol)
            var isTrigger interface{} = this.SafeBool2(params, "trigger", "stop", false)
            var subaccountId interface{} = nil
            subaccountIdparamsVariable := this.HandleDeriveSubaccountId("cancelOrder", params);
            subaccountId = GetValue(subaccountIdparamsVariable,0);
            params = GetValue(subaccountIdparamsVariable,1)
            params = this.Omit(params, []interface{}{"trigger", "stop"})
            var request interface{} = map[string]interface{} {
                "instrument_name": GetValue(market, "id"),
                "subaccount_id": subaccountId,
            }
            var clientOrderIdUnified interface{} = this.SafeString(params, "clientOrderId")
            var clientOrderIdExchangeSpecific interface{} = this.SafeString(params, "label", clientOrderIdUnified)
            var isByClientOrder interface{} = !IsEqual(clientOrderIdExchangeSpecific, nil)
            var response interface{} = nil
            if IsTrue(isByClientOrder) {
                AddElementToObject(request, "label", clientOrderIdExchangeSpecific)
                params = this.Omit(params, []interface{}{"clientOrderId", "label"})
                
        response = (<-this.PrivatePostCancelByLabel(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                AddElementToObject(request, "order_id", id)
                if IsTrue(isTrigger) {
                    
        response = (<-this.PrivatePostCancelTriggerOrder(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.PrivatePostCancel(this.Extend(request, params)))
                    PanicOnError(response)
                }
            }
            //
            // {
            //     "result": {
            //         "subaccount_id": 130837,
            //         "order_id": "de4f30b6-0dcb-4df6-9222-c1a27f1ad80d",
            //         "instrument_name": "BTC-PERP",
            //         "direction": "buy",
            //         "label": "test1234",
            //         "quote_id": null,
            //         "creation_timestamp": 1737540100989,
            //         "last_update_timestamp": 1737540574696,
            //         "limit_price": "10000",
            //         "amount": "0.01",
            //         "filled_amount": "0",
            //         "average_price": "0",
            //         "order_fee": "0",
            //         "order_type": "limit",
            //         "time_in_force": "post_only",
            //         "order_status": "cancelled",
            //         "max_fee": "211",
            //         "signature_expiry_sec": 1737540700726,
            //         "nonce": 1737540100726,
            //         "signer": "0x30CB7B06AdD6749BbE146A6827502B8f2a79269A",
            //         "signature": "0x9cd1a6e32a0699929e4e090c08c548366b1353701ec56e02d5cdf37fc89bd19b7b29e00e57e8383bb6336d73019027a7e2a4364f40859e7a949115024c7f199a1b",
            //         "cancel_reason": "user_request",
            //         "mmp": false,
            //         "is_transfer": false,
            //         "replaced_order_id": "4ccc89ba-3c3d-4047-8900-0aa5fb4ef706",
            //         "trigger_type": null,
            //         "trigger_price_type": null,
            //         "trigger_price": null,
            //         "trigger_reject_message": null
            //     },
            //     "id": "cef61e2a-cb13-4779-8e6b-535361981fad"
            // }
            //
            // {
            //     "result": {
            //         "cancelled_orders": 1
            //     },
            //     "id": "674e075e-1e8a-4a47-99ff-75efbdd2370f"
            // }
            //
            var extendParams interface{} = map[string]interface{} {
                "symbol": symbol,
            }
            var order interface{} = this.SafeDict(response, "result")
            if IsTrue(isByClientOrder) {
                AddElementToObject(extendParams, "client_order_id", clientOrderIdExchangeSpecific)
            }
        
            ch <- this.Extend(this.ParseOrder(order, market), extendParams)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name derive#cancelAllOrders
 * @see https://docs.derive.xyz/reference/post_private-cancel-by-instrument
 * @see https://docs.derive.xyz/reference/post_private-cancel-all
 * @description cancel all open orders in a market
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.subaccount_id] *required* the subaccount id
 * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *derive) CancelAllOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes16118 := (<-this.LoadMarkets())
            PanicOnError(retRes16118)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var subaccountId interface{} = nil
            subaccountIdparamsVariable := this.HandleDeriveSubaccountId("cancelAllOrders", params);
            subaccountId = GetValue(subaccountIdparamsVariable,0);
            params = GetValue(subaccountIdparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "subaccount_id": subaccountId,
            }
            var response interface{} = nil
            if IsTrue(!IsEqual(market, nil)) {
                AddElementToObject(request, "instrument_name", GetValue(market, "id"))
                
        response = (<-this.PrivatePostCancelByInstrument(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PrivatePostCancelAll(this.Extend(request, params)))
                PanicOnError(response)
            }
        
                //
            // {
            //     "result": {
            //         "cancelled_orders": 0
            //     },
            //     "id": "9d633799-2098-4559-b547-605bb6f4d8f4"
            // }
            //
            // {
            //     "id": "45548646-c74f-4ca2-9de4-551e6de49afa",
            //     "result": "ok"
            // }
            //
        ch <- response
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name derive#fetchOrders
 * @description fetches information on multiple orders made by the user
 * @see https://docs.derive.xyz/reference/post_private-get-orders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.paginate] set to true if you want to fetch orders with pagination
 * @param {boolean} [params.trigger] whether the order is a trigger/algo order
 * @param {string} [params.subaccount_id] *required* the subaccount id
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *derive) FetchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes16598 := (<-this.LoadMarkets())
            PanicOnError(retRes16598)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchOrders", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes166319 :=  (<-this.FetchPaginatedCallIncremental("fetchOrders", symbol, since, limit, params, "page", 500))
                    PanicOnError(retRes166319)
                    ch <- retRes166319
                    return nil
            }
            var isTrigger interface{} = this.SafeBool2(params, "trigger", "stop", false)
            params = this.Omit(params, []interface{}{"trigger", "stop"})
            var subaccountId interface{} = nil
            subaccountIdparamsVariable := this.HandleDeriveSubaccountId("fetchOrders", params);
            subaccountId = GetValue(subaccountIdparamsVariable,0);
            params = GetValue(subaccountIdparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "subaccount_id": subaccountId,
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "instrument_name", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "page_size", limit)
            } else {
                AddElementToObject(request, "page_size", 500)
            }
            if IsTrue(isTrigger) {
                AddElementToObject(request, "status", "untriggered")
            }
        
            response:= (<-this.PrivatePostGetOrders(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "result": {
            //         "subaccount_id": 130837,
            //         "orders": [
            //             {
            //                 "subaccount_id": 130837,
            //                 "order_id": "63a80cb8-387b-472b-a838-71cd9513c365",
            //                 "instrument_name": "BTC-PERP",
            //                 "direction": "buy",
            //                 "label": "test1234",
            //                 "quote_id": null,
            //                 "creation_timestamp": 1737551053207,
            //                 "last_update_timestamp": 1737551053207,
            //                 "limit_price": "10000",
            //                 "amount": "0.01",
            //                 "filled_amount": "0",
            //                 "average_price": "0",
            //                 "order_fee": "0",
            //                 "order_type": "limit",
            //                 "time_in_force": "post_only",
            //                 "order_status": "open",
            //                 "max_fee": "211",
            //                 "signature_expiry_sec": 1737551652765,
            //                 "nonce": 1737551052765,
            //                 "signer": "0x30CB7B06AdD6749BbE146A6827502B8f2a79269A",
            //                 "signature": "0x35535ccb1bcad509ecc435c79e966174db6403fc9aeee1e237d08a941014c57b59279dfe4be39e081f9921a53eaad59cb2a151d9f52f2d05fc47e6280254952e1c",
            //                 "cancel_reason": "",
            //                 "mmp": false,
            //                 "is_transfer": false,
            //                 "replaced_order_id": null,
            //                 "trigger_type": null,
            //                 "trigger_price_type": null,
            //                 "trigger_price": null,
            //                 "trigger_reject_message": null
            //             }
            //         ],
            //         "pagination": {
            //             "num_pages": 1,
            //             "count": 1
            //         }
            //     },
            //     "id": "e5a88d4f-7ac7-40cd-aec9-e0e8152b8b92"
            // }
            //
            var data interface{} = this.SafeValue(response, "result")
            var page interface{} = this.SafeInteger(params, "page")
            if IsTrue(!IsEqual(page, nil)) {
                var pagination interface{} = this.SafeDict(data, "pagination")
                var currentPage interface{} = this.SafeInteger(pagination, "num_pages")
                if IsTrue(IsGreaterThan(page, currentPage)) {
        
                    ch <- []interface{}{}
                    return nil
                }
            }
            var orders interface{} = this.SafeList(data, "orders")
        
            ch <- this.ParseOrders(orders, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name derive#fetchOpenOrders
 * @description fetches information on multiple orders made by the user
 * @see https://docs.derive.xyz/reference/post_private-get-orders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.paginate] set to true if you want to fetch orders with pagination
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *derive) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes17578 := (<-this.LoadMarkets())
            PanicOnError(retRes17578)
            var extendedParams interface{} = this.Extend(params, map[string]interface{} {
                "status": "open",
            })
        
                retRes175915 :=  (<-this.FetchOrders(symbol, since, limit, extendedParams))
                PanicOnError(retRes175915)
                ch <- retRes175915
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name derive#fetchClosedOrders
 * @description fetches information on multiple orders made by the user
 * @see https://docs.derive.xyz/reference/post_private-get-orders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.paginate] set to true if you want to fetch orders with pagination
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *derive) FetchClosedOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes17758 := (<-this.LoadMarkets())
            PanicOnError(retRes17758)
            var extendedParams interface{} = this.Extend(params, map[string]interface{} {
                "status": "filled",
            })
        
                retRes177715 :=  (<-this.FetchOrders(symbol, since, limit, extendedParams))
                PanicOnError(retRes177715)
                ch <- retRes177715
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name derive#fetchCanceledOrders
 * @description fetches information on multiple canceled orders made by the user
 * @see https://docs.derive.xyz/reference/post_private-get-orders
 * @param {string} symbol unified market symbol of the market the orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *derive) FetchCanceledOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes17938 := (<-this.LoadMarkets())
            PanicOnError(retRes17938)
            var extendedParams interface{} = this.Extend(params, map[string]interface{} {
                "status": "cancelled",
            })
        
                retRes179515 :=  (<-this.FetchOrders(symbol, since, limit, extendedParams))
                PanicOnError(retRes179515)
                ch <- retRes179515
                return nil
        
            }()
            return ch
        }
func  (this *derive) ParseTimeInForce(timeInForce interface{}) interface{}  {
    var timeInForces interface{} = map[string]interface{} {
        "ioc": "IOC",
        "fok": "FOK",
        "gtc": "GTC",
        "post_only": "PO",
    }
    return this.SafeString(timeInForces, timeInForce, nil)
}
func  (this *derive) ParseOrderStatus(status interface{}) interface{}  {
    if IsTrue(!IsEqual(status, nil)) {
        var statuses interface{} = map[string]interface{} {
            "open": "open",
            "untriggered": "open",
            "filled": "closed",
            "cancelled": "canceled",
            "expired": "rejected",
        }
        return this.SafeString(statuses, status, status)
    }
    return status
}
func  (this *derive) ParseOrder(rawOrder interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // {
    //     "subaccount_id": 130837,
    //     "nonce": 1736923517552,
    //     "module": "0x87F2863866D85E3192a35A73b388BD625D83f2be",
    //     "expiry": 86400,
    //     "owner": "0x108b9aF9279a525b8A8AeAbE7AC2bA925Bc50075",
    //     "signer": "0x108b9aF9279a525b8A8AeAbE7AC2bA925Bc50075",
    //     "signature": "0xaa4f42b2f3da33c668fa703ea872d4c3a6b55aca66025b5119e3bebb6679fe2e2794638db51dcace21fc39a498047835994f07eb59f311bb956ce057e66793d1c",
    //     "data": {
    //         "asset": "0xAFB6Bb95cd70D5367e2C39e9dbEb422B9815339D",
    //         "sub_id": 0,
    //         "limit_price": "10000",
    //         "desired_amount": "0.001",
    //         "worst_fee": "0",
    //         "recipient_id": 130837,
    //         "is_bid": true,
    //         "trade_id": ""
    //     }
    // }
    // {
    //     "subaccount_id": 130837,
    //     "order_id": "96349ebb-7d46-43ae-81c7-7ab390444293",
    //     "instrument_name": "BTC-PERP",
    //     "direction": "buy",
    //     "label": "",
    //     "quote_id": null,
    //     "creation_timestamp": 1737467576257,
    //     "last_update_timestamp": 1737467576257,
    //     "limit_price": "10000",
    //     "amount": "0.01",
    //     "filled_amount": "0",
    //     "average_price": "0",
    //     "order_fee": "0",
    //     "order_type": "limit",
    //     "time_in_force": "gtc",
    //     "order_status": "open",
    //     "max_fee": "210",
    //     "signature_expiry_sec": 1737468175989,
    //     "nonce": 1737467575989,
    //     "signer": "0x30CB7B06AdD6749BbE146A6827502B8f2a79269A",
    //     "signature": "0xd1ca49df1fa06bd805bb59b132ff6c0de29bf973a3e01705abe0a01cc956e4945ed9eb99ab68f3df4c037908113cac5a5bfc3a954a0b7103cdab285962fa6a51c",
    //     "cancel_reason": "",
    //     "mmp": false,
    //     "is_transfer": false,
    //     "replaced_order_id": null,
    //     "trigger_type": null,
    //     "trigger_price_type": null,
    //     "trigger_price": null,
    //     "trigger_reject_message": null
    // }
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var order interface{} = this.SafeDict(rawOrder, "data")
    if IsTrue(IsEqual(order, nil)) {
        order = rawOrder
    }
    var timestamp interface{} = this.SafeInteger(rawOrder, "nonce")
    var orderId interface{} = this.SafeString(order, "order_id")
    var marketId interface{} = this.SafeString(order, "instrument_name")
    if IsTrue(!IsEqual(marketId, nil)) {
        market = this.SafeMarket(marketId, market)
    }
    var symbol interface{} = GetValue(market, "symbol")
    var price interface{} = this.SafeString(order, "limit_price")
    var average interface{} = this.SafeString(order, "average_price")
    var amount interface{} = this.SafeString(order, "desired_amount")
    var filled interface{} = this.SafeString(order, "filled_amount")
    var fee interface{} = this.SafeString(order, "order_fee")
    var orderType interface{} = this.SafeStringLower(order, "order_type")
    var isBid interface{} = this.SafeBool(order, "is_bid")
    var side interface{} = this.SafeString(order, "direction")
    if IsTrue(IsEqual(side, nil)) {
        if IsTrue(isBid) {
            side = "buy"
        } else {
            side = "sell"
        }
    }
    var triggerType interface{} = this.SafeString(order, "trigger_type")
    var stopLossPrice interface{} = nil
    var takeProfitPrice interface{} = nil
    var triggerPrice interface{} = nil
    if IsTrue(!IsEqual(triggerType, nil)) {
        triggerPrice = this.SafeString(order, "trigger_price")
        if IsTrue(IsEqual(triggerType, "stoploss")) {
            stopLossPrice = triggerPrice
        } else {
            takeProfitPrice = triggerPrice
        }
    }
    var lastUpdateTimestamp interface{} = this.SafeInteger(rawOrder, "last_update_timestamp")
    var status interface{} = this.SafeString(order, "order_status")
    var timeInForce interface{} = this.SafeString(order, "time_in_force")
    return this.SafeOrder(map[string]interface{} {
        "id": orderId,
        "clientOrderId": this.SafeString(order, "label"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "lastUpdateTimestamp": lastUpdateTimestamp,
        "status": this.ParseOrderStatus(status),
        "symbol": symbol,
        "type": orderType,
        "timeInForce": this.ParseTimeInForce(timeInForce),
        "postOnly": nil,
        "reduceOnly": this.SafeBool(order, "reduce_only"),
        "side": side,
        "price": price,
        "triggerPrice": triggerPrice,
        "takeProfitPrice": takeProfitPrice,
        "stopLossPrice": stopLossPrice,
        "average": average,
        "amount": amount,
        "filled": filled,
        "remaining": nil,
        "cost": nil,
        "trades": nil,
        "fee": map[string]interface{} {
            "cost": fee,
            "currency": "USDC",
        },
        "info": order,
    }, market)
}
/**
 * @method
 * @name derive#fetchOrderTrades
 * @description fetch all the trades made from a single order
 * @see https://docs.derive.xyz/reference/post_private-get-trade-history
 * @param {string} id order id
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.subaccount_id] *required* the subaccount id
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *derive) FetchOrderTrades(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes19618 := (<-this.LoadMarkets())
            PanicOnError(retRes19618)
            var subaccountId interface{} = nil
            subaccountIdparamsVariable := this.HandleDeriveSubaccountId("fetchOrderTrades", params);
            subaccountId = GetValue(subaccountIdparamsVariable,0);
            params = GetValue(subaccountIdparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "order_id": id,
                "subaccount_id": subaccountId,
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "instrument_name", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "page_size", limit)
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "from_timestamp", since)
            }
        
            response:= (<-this.PrivatePostGetTradeHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "result": {
            //         "subaccount_id": 130837,
            //         "trades": [
            //             {
            //                 "subaccount_id": 130837,
            //                 "order_id": "30c48194-8d48-43ac-ad00-0d5ba29eddc9",
            //                 "instrument_name": "BTC-PERP",
            //                 "direction": "sell",
            //                 "label": "test1234",
            //                 "quote_id": null,
            //                 "trade_id": "f8a30740-488c-4c2d-905d-e17057bafde1",
            //                 "timestamp": 1738065303708,
            //                 "mark_price": "102740.137375457314192317",
            //                 "index_price": "102741.553409299981533184",
            //                 "trade_price": "102700.6",
            //                 "trade_amount": "0.01",
            //                 "liquidity_role": "taker",
            //                 "realized_pnl": "0",
            //                 "realized_pnl_excl_fees": "0",
            //                 "is_transfer": false,
            //                 "tx_status": "settled",
            //                 "trade_fee": "1.127415534092999815",
            //                 "tx_hash": "0xc55df1f07330faf86579bd8a6385391fbe9e73089301149d8550e9d29c9ead74",
            //                 "transaction_id": "e18b9426-3fa5-41bb-99d3-8b54fb4d51bb"
            //             }
            //         ],
            //         "pagination": {
            //             "num_pages": 1,
            //             "count": 1
            //         }
            //     },
            //     "id": "a16f798c-a121-44e2-b77e-c38a063f8a99"
            // }
            //
            var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
            var trades interface{} = this.SafeList(result, "trades", []interface{}{})
        
            ch <- this.ParseTrades(trades, market, since, limit, params)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name derive#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://docs.derive.xyz/reference/post_private-get-trade-history
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.paginate] set to true if you want to fetch trades with pagination
 * @param {string} [params.subaccount_id] *required* the subaccount id
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *derive) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes20358 := (<-this.LoadMarkets())
            PanicOnError(retRes20358)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchMyTrades", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes203919 :=  (<-this.FetchPaginatedCallIncremental("fetchMyTrades", symbol, since, limit, params, "page", 500))
                    PanicOnError(retRes203919)
                    ch <- retRes203919
                    return nil
            }
            var subaccountId interface{} = nil
            subaccountIdparamsVariable := this.HandleDeriveSubaccountId("fetchMyTrades", params);
            subaccountId = GetValue(subaccountIdparamsVariable,0);
            params = GetValue(subaccountIdparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "subaccount_id": subaccountId,
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "instrument_name", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "page_size", limit)
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "from_timestamp", since)
            }
        
            response:= (<-this.PrivatePostGetTradeHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "result": {
            //         "subaccount_id": 130837,
            //         "trades": [
            //             {
            //                 "subaccount_id": 130837,
            //                 "order_id": "30c48194-8d48-43ac-ad00-0d5ba29eddc9",
            //                 "instrument_name": "BTC-PERP",
            //                 "direction": "sell",
            //                 "label": "test1234",
            //                 "quote_id": null,
            //                 "trade_id": "f8a30740-488c-4c2d-905d-e17057bafde1",
            //                 "timestamp": 1738065303708,
            //                 "mark_price": "102740.137375457314192317",
            //                 "index_price": "102741.553409299981533184",
            //                 "trade_price": "102700.6",
            //                 "trade_amount": "0.01",
            //                 "liquidity_role": "taker",
            //                 "realized_pnl": "0",
            //                 "realized_pnl_excl_fees": "0",
            //                 "is_transfer": false,
            //                 "tx_status": "settled",
            //                 "trade_fee": "1.127415534092999815",
            //                 "tx_hash": "0xc55df1f07330faf86579bd8a6385391fbe9e73089301149d8550e9d29c9ead74",
            //                 "transaction_id": "e18b9426-3fa5-41bb-99d3-8b54fb4d51bb"
            //             }
            //         ],
            //         "pagination": {
            //             "num_pages": 1,
            //             "count": 1
            //         }
            //     },
            //     "id": "a16f798c-a121-44e2-b77e-c38a063f8a99"
            // }
            //
            var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
            var page interface{} = this.SafeInteger(params, "page")
            if IsTrue(!IsEqual(page, nil)) {
                var pagination interface{} = this.SafeDict(result, "pagination")
                var currentPage interface{} = this.SafeInteger(pagination, "num_pages")
                if IsTrue(IsGreaterThan(page, currentPage)) {
        
                    ch <- []interface{}{}
                    return nil
                }
            }
            var trades interface{} = this.SafeList(result, "trades", []interface{}{})
        
            ch <- this.ParseTrades(trades, market, since, limit, params)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name derive#fetchPositions
 * @description fetch all open positions
 * @see https://docs.derive.xyz/reference/post_private-get-positions
 * @param {string[]} [symbols] not used by kraken fetchPositions ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.subaccount_id] *required* the subaccount id
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *derive) FetchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes21188 := (<-this.LoadMarkets())
            PanicOnError(retRes21188)
            var subaccountId interface{} = nil
            subaccountIdparamsVariable := this.HandleDeriveSubaccountId("fetchPositions", params);
            subaccountId = GetValue(subaccountIdparamsVariable,0);
            params = GetValue(subaccountIdparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "subaccount_id": subaccountId,
            }
            params = this.Omit(params, []interface{}{"subaccount_id"})
        
            response:= (<-this.PrivatePostGetPositions(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "result": {
            //         "subaccount_id": 130837,
            //         "positions": [
            //             {
            //                 "instrument_type": "perp",
            //                 "instrument_name": "BTC-PERP",
            //                 "amount": "-0.02",
            //                 "average_price": "102632.9105389869500088",
            //                 "realized_pnl": "0",
            //                 "unrealized_pnl": "-2.6455959784245548835819950103759765625",
            //                 "total_fees": "2.255789220260999824",
            //                 "average_price_excl_fees": "102745.7",
            //                 "realized_pnl_excl_fees": "0",
            //                 "unrealized_pnl_excl_fees": "-0.3898067581635550595819950103759765625",
            //                 "net_settlements": "-4.032902047219498639",
            //                 "cumulative_funding": "-0.004677736347850093",
            //                 "pending_funding": "0",
            //                 "mark_price": "102765.190337908177752979099750518798828125",
            //                 "index_price": "102767.657193800017641472",
            //                 "delta": "1",
            //                 "gamma": "0",
            //                 "vega": "0",
            //                 "theta": "0",
            //                 "mark_value": "1.38730606879471451975405216217041015625",
            //                 "maintenance_margin": "-101.37788426911356509663164615631103515625",
            //                 "initial_margin": "-132.2074413704858670826070010662078857421875",
            //                 "open_orders_margin": "264.116085900726830004714429378509521484375",
            //                 "leverage": "8.6954476205089299495699106539379941746377322586618",
            //                 "liquidation_price": "109125.705451984322280623018741607666015625",
            //                 "creation_timestamp": 1738065303840
            //             }
            //         ]
            //     },
            //     "id": "167350f1-d9fc-41d4-9797-1c78f83fda8e"
            // }
            //
            var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
            var positions interface{} = this.SafeList(result, "positions", []interface{}{})
        
            ch <- this.ParsePositions(positions, symbols)
            return nil
        
            }()
            return ch
        }
func  (this *derive) ParsePosition(position interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // {
    //     "instrument_type": "perp",
    //     "instrument_name": "BTC-PERP",
    //     "amount": "-0.02",
    //     "average_price": "102632.9105389869500088",
    //     "realized_pnl": "0",
    //     "unrealized_pnl": "-2.6455959784245548835819950103759765625",
    //     "total_fees": "2.255789220260999824",
    //     "average_price_excl_fees": "102745.7",
    //     "realized_pnl_excl_fees": "0",
    //     "unrealized_pnl_excl_fees": "-0.3898067581635550595819950103759765625",
    //     "net_settlements": "-4.032902047219498639",
    //     "cumulative_funding": "-0.004677736347850093",
    //     "pending_funding": "0",
    //     "mark_price": "102765.190337908177752979099750518798828125",
    //     "index_price": "102767.657193800017641472",
    //     "delta": "1",
    //     "gamma": "0",
    //     "vega": "0",
    //     "theta": "0",
    //     "mark_value": "1.38730606879471451975405216217041015625",
    //     "maintenance_margin": "-101.37788426911356509663164615631103515625",
    //     "initial_margin": "-132.2074413704858670826070010662078857421875",
    //     "open_orders_margin": "264.116085900726830004714429378509521484375",
    //     "leverage": "8.6954476205089299495699106539379941746377322586618",
    //     "liquidation_price": "109125.705451984322280623018741607666015625",
    //     "creation_timestamp": 1738065303840
    // }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var contract interface{} = this.SafeString(position, "instrument_name")
    market = this.SafeMarket(contract, market)
    var size interface{} = this.SafeString(position, "amount")
    var side interface{} = nil
    if IsTrue(Precise.StringGt(size, "0")) {
        side = "long"
    } else {
        side = "short"
    }
    var contractSize interface{} = this.SafeString(market, "contractSize")
    var markPrice interface{} = this.SafeString(position, "mark_price")
    var timestamp interface{} = this.SafeInteger(position, "creation_timestamp")
    var unrealisedPnl interface{} = this.SafeString(position, "unrealized_pnl")
    size = Precise.StringAbs(size)
    var notional interface{} = Precise.StringMul(size, markPrice)
    return this.SafePosition(map[string]interface{} {
        "info": position,
        "id": nil,
        "symbol": this.SafeString(market, "symbol"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastUpdateTimestamp": nil,
        "initialMargin": this.SafeString(position, "initial_margin"),
        "initialMarginPercentage": nil,
        "maintenanceMargin": this.SafeString(position, "maintenance_margin"),
        "maintenanceMarginPercentage": nil,
        "entryPrice": nil,
        "notional": this.ParseNumber(notional),
        "leverage": this.SafeNumber(position, "leverage"),
        "unrealizedPnl": this.ParseNumber(unrealisedPnl),
        "contracts": this.ParseNumber(size),
        "contractSize": this.ParseNumber(contractSize),
        "marginRatio": nil,
        "liquidationPrice": this.SafeNumber(position, "liquidation_price"),
        "markPrice": this.ParseNumber(markPrice),
        "lastPrice": nil,
        "collateral": nil,
        "marginMode": nil,
        "side": side,
        "percentage": nil,
        "hedged": nil,
        "stopLossPrice": nil,
        "takeProfitPrice": nil,
    })
}
/**
 * @method
 * @name derive#fetchFundingHistory
 * @description fetch the history of funding payments paid and received on this account
 * @see https://docs.derive.xyz/reference/post_private-get-funding-history
 * @param {string} [symbol] unified market symbol
 * @param {int} [since] the earliest time in ms to fetch funding history for
 * @param {int} [limit] the maximum number of funding history structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object} a [funding history structure]{@link https://docs.ccxt.com/#/?id=funding-history-structure}
 */
func  (this *derive) FetchFundingHistory(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes22598 := (<-this.LoadMarkets())
            PanicOnError(retRes22598)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchFundingHistory", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes226319 :=  (<-this.FetchPaginatedCallIncremental("fetchFundingHistory", symbol, since, limit, params, "page", 500))
                    PanicOnError(retRes226319)
                    ch <- retRes226319
                    return nil
            }
            var subaccountId interface{} = nil
            subaccountIdparamsVariable := this.HandleDeriveSubaccountId("fetchFundingHistory", params);
            subaccountId = GetValue(subaccountIdparamsVariable,0);
            params = GetValue(subaccountIdparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "subaccount_id": subaccountId,
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "instrument_name", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_timestamp", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "page_size", limit)
            }
        
            response:= (<-this.PrivatePostGetFundingHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "result": {
            //         "events": [
            //             {
            //                 "instrument_name": "BTC-PERP",
            //                 "timestamp": 1738066618272,
            //                 "funding": "-0.004677736347850093",
            //                 "pnl": "-0.944081615774632967"
            //             },
            //             {
            //                 "instrument_name": "BTC-PERP",
            //                 "timestamp": 1738066617964,
            //                 "funding": "0",
            //                 "pnl": "-0.437556413479249408"
            //             },
            //             {
            //                 "instrument_name": "BTC-PERP",
            //                 "timestamp": 1738065307565,
            //                 "funding": "0",
            //                 "pnl": "-0.39547479770461644"
            //             }
            //         ],
            //         "pagination": {
            //             "num_pages": 1,
            //             "count": 3
            //         }
            //     },
            //     "id": "524b817f-2108-467f-8795-511066f4acec"
            // }
            //
            var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
            var page interface{} = this.SafeInteger(params, "page")
            if IsTrue(!IsEqual(page, nil)) {
                var pagination interface{} = this.SafeDict(result, "pagination")
                var currentPage interface{} = this.SafeInteger(pagination, "num_pages")
                if IsTrue(IsGreaterThan(page, currentPage)) {
        
                    ch <- []interface{}{}
                    return nil
                }
            }
            var events interface{} = this.SafeList(result, "events", []interface{}{})
        
            ch <- this.ParseIncomes(events, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *derive) ParseIncome(income interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // {
    //     "instrument_name": "BTC-PERP",
    //     "timestamp": 1738065307565,
    //     "funding": "0",
    //     "pnl": "-0.39547479770461644"
    // }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(income, "instrument_name")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var rate interface{} = this.SafeString(income, "funding")
    var code interface{} = this.SafeCurrencyCode("USDC")
    var timestamp interface{} = this.SafeInteger(income, "timestamp")
    return map[string]interface{} {
        "info": income,
        "symbol": symbol,
        "code": code,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "id": nil,
        "amount": nil,
        "rate": rate,
    }
}
/**
 * @method
 * @name derive#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://docs.derive.xyz/reference/post_private-get-all-portfolios
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *derive) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes23618 := (<-this.LoadMarkets())
            PanicOnError(retRes23618)
            var deriveWalletAddress interface{} = nil
            deriveWalletAddressparamsVariable := this.HandleDeriveWalletAddress("fetchBalance", params);
            deriveWalletAddress = GetValue(deriveWalletAddressparamsVariable,0);
            params = GetValue(deriveWalletAddressparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "wallet": deriveWalletAddress,
            }
        
            response:= (<-this.PrivatePostGetAllPortfolios(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "result": [{
            //             "subaccount_id": 130837,
            //             "label": "",
            //             "currency": "all",
            //             "margin_type": "SM",
            //             "is_under_liquidation": false,
            //             "positions_value": "0",
            //             "collaterals_value": "318.0760325000001103035174310207366943359375",
            //             "subaccount_value": "318.0760325000001103035174310207366943359375",
            //             "positions_maintenance_margin": "0",
            //             "positions_initial_margin": "0",
            //             "collaterals_maintenance_margin": "238.557024375000082727638073265552520751953125",
            //             "collaterals_initial_margin": "190.845619500000083235136116854846477508544921875",
            //             "maintenance_margin": "238.557024375000082727638073265552520751953125",
            //             "initial_margin": "190.845619500000083235136116854846477508544921875",
            //             "open_orders_margin": "0",
            //             "projected_margin_change": "0",
            //             "open_orders": [],
            //             "positions": [],
            //             "collaterals": [
            //                 {
            //                     "asset_type": "erc20",
            //                     "asset_name": "ETH",
            //                     "currency": "ETH",
            //                     "amount": "0.1",
            //                     "mark_price": "3180.760325000000438272",
            //                     "mark_value": "318.0760325000001103035174310207366943359375",
            //                     "cumulative_interest": "0",
            //                     "pending_interest": "0",
            //                     "initial_margin": "190.845619500000083235136116854846477508544921875",
            //                     "maintenance_margin": "238.557024375000082727638073265552520751953125",
            //                     "realized_pnl": "0",
            //                     "average_price": "3184.891931",
            //                     "unrealized_pnl": "-0.413161",
            //                     "total_fees": "0",
            //                     "average_price_excl_fees": "3184.891931",
            //                     "realized_pnl_excl_fees": "0",
            //                     "unrealized_pnl_excl_fees": "-0.413161",
            //                     "open_orders_margin": "0",
            //                     "creation_timestamp": 1736860533493
            //                 }
            //             ]
            //     }],
            //     "id": "27b9a64e-3379-4ce6-a126-9fb941c4a970"
            // }
            //
            var result interface{} = this.SafeList(response, "result")
        
            ch <- this.ParseBalance(result)
            return nil
        
            }()
            return ch
        }
func  (this *derive) ParseBalance(response interface{}) interface{}  {
    var result interface{} = map[string]interface{} {
        "info": response,
    }
    // TODO:
    // checked multiple subaccounts
    // checked balance after open orders / positions
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        var subaccount interface{} = GetValue(response, i)
        var collaterals interface{} = this.SafeList(subaccount, "collaterals", []interface{}{})
        for j := 0; IsLessThan(j, GetArrayLength(collaterals)); j++ {
            var balance interface{} = GetValue(collaterals, j)
            var code interface{} = this.SafeCurrencyCode(this.SafeString(balance, "currency"))
            var account interface{} = this.Account()
            AddElementToObject(account, "total", this.SafeString(balance, "amount"))
            AddElementToObject(result, code, account)
        }
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name derive#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://docs.derive.xyz/reference/post_private-get-deposit-history
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.subaccount_id] *required* the subaccount id
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *derive) FetchDeposits(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes24548 := (<-this.LoadMarkets())
            PanicOnError(retRes24548)
            var subaccountId interface{} = nil
            subaccountIdparamsVariable := this.HandleDeriveSubaccountId("fetchDeposits", params);
            subaccountId = GetValue(subaccountIdparamsVariable,0);
            params = GetValue(subaccountIdparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "subaccount_id": subaccountId,
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_timestamp", since)
            }
        
            response:= (<-this.PrivatePostGetDepositHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "result": {
            //         "events": [
            //             {
            //                 "timestamp": 1736860533599,
            //                 "transaction_id": "f2069395-ec00-49f5-925a-87202a5d240f",
            //                 "asset": "ETH",
            //                 "amount": "0.1",
            //                 "tx_status": "settled",
            //                 "tx_hash": "0xeda21a315c59302a19c42049b4cef05a10b685302b6cc3edbaf49102d91166d4",
            //                 "error_log": {}
            //             }
            //         ]
            //     },
            //     "id": "ceebc730-22ab-40cd-9941-33ceb2a74389"
            // }
            //
            var currency interface{} = this.SafeCurrency(code)
            var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
            var events interface{} = this.SafeList(result, "events")
        
            ch <- this.ParseTransactions(events, currency, since, limit, params)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name derive#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @see https://docs.derive.xyz/reference/post_private-get-withdrawal-history
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawals structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.subaccount_id] *required* the subaccount id
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *derive) FetchWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes25018 := (<-this.LoadMarkets())
            PanicOnError(retRes25018)
            var subaccountId interface{} = nil
            subaccountIdparamsVariable := this.HandleDeriveSubaccountId("fetchWithdrawals", params);
            subaccountId = GetValue(subaccountIdparamsVariable,0);
            params = GetValue(subaccountIdparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "subaccount_id": subaccountId,
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_timestamp", since)
            }
        
            response:= (<-this.PrivatePostGetWithdrawalHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "result": {
            //         "events": [
            //             {
            //                 "timestamp": 1736860533599,
            //                 "transaction_id": "f2069395-ec00-49f5-925a-87202a5d240f",
            //                 "asset": "ETH",
            //                 "amount": "0.1",
            //                 "tx_status": "settled",
            //                 "tx_hash": "0xeda21a315c59302a19c42049b4cef05a10b685302b6cc3edbaf49102d91166d4",
            //                 "error_log": {}
            //             }
            //         ]
            //     },
            //     "id": "ceebc730-22ab-40cd-9941-33ceb2a74389"
            // }
            //
            var currency interface{} = this.SafeCurrency(code)
            var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
            var events interface{} = this.SafeList(result, "events")
        
            ch <- this.ParseTransactions(events, currency, since, limit, params)
            return nil
        
            }()
            return ch
        }
func  (this *derive) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // {
    //     "timestamp": 1736860533599,
    //     "transaction_id": "f2069395-ec00-49f5-925a-87202a5d240f",
    //     "asset": "ETH",
    //     "amount": "0.1",
    //     "tx_status": "settled",
    //     "tx_hash": "0xeda21a315c59302a19c42049b4cef05a10b685302b6cc3edbaf49102d91166d4",
    //     "error_log": {}
    // }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var code interface{} = this.SafeString(transaction, "asset")
    var timestamp interface{} = this.SafeInteger(transaction, "timestamp")
    var txId interface{} = this.SafeString(transaction, "tx_hash")
    if IsTrue(IsEqual(txId, "0x0")) {
        txId = nil
    }
    return map[string]interface{} {
        "info": transaction,
        "id": nil,
        "txid": txId,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "address": nil,
        "addressFrom": nil,
        "addressTo": nil,
        "tag": nil,
        "tagFrom": nil,
        "tagTo": nil,
        "type": nil,
        "amount": this.SafeNumber(transaction, "amount"),
        "currency": code,
        "status": this.ParseTransactionStatus(this.SafeString(transaction, "tx_status")),
        "updated": nil,
        "comment": nil,
        "internal": nil,
        "fee": nil,
        "network": nil,
    }
}
func  (this *derive) ParseTransactionStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "settled": "ok",
        "reverted": "failed",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *derive) HandleDeriveSubaccountId(methodName interface{}, params interface{}) interface{}  {
    var derivesubAccountId interface{} = nil
    derivesubAccountIdparamsVariable := this.HandleOptionAndParams(params, methodName, "subaccount_id");
    derivesubAccountId = GetValue(derivesubAccountIdparamsVariable,0);
    params = GetValue(derivesubAccountIdparamsVariable,1)
    if IsTrue(IsTrue((!IsEqual(derivesubAccountId, nil))) && IsTrue((!IsEqual(derivesubAccountId, "")))) {
        AddElementToObject(this.Options, "subaccount_id", derivesubAccountId) // saving in options
        return []interface{}{derivesubAccountId, params}
    }
    var optionsWallet interface{} = this.SafeString(this.Options, "subaccount_id")
    if IsTrue(!IsEqual(optionsWallet, nil)) {
        return []interface{}{optionsWallet, params}
    }
    panic(ArgumentsRequired(Add(Add(Add(this.Id, " "), methodName), "() requires a subaccount_id parameter inside \\'params\\' or exchange.options[\\'subaccount_id\\']=ID.")))
}
func  (this *derive) HandleDeriveWalletAddress(methodName interface{}, params interface{}) interface{}  {
    var deriveWalletAddress interface{} = nil
    deriveWalletAddressparamsVariable := this.HandleOptionAndParams(params, methodName, "deriveWalletAddress");
    deriveWalletAddress = GetValue(deriveWalletAddressparamsVariable,0);
    params = GetValue(deriveWalletAddressparamsVariable,1)
    if IsTrue(IsTrue((!IsEqual(deriveWalletAddress, nil))) && IsTrue((!IsEqual(deriveWalletAddress, "")))) {
        AddElementToObject(this.Options, "deriveWalletAddress", deriveWalletAddress) // saving in options
        return []interface{}{deriveWalletAddress, params}
    }
    var optionsWallet interface{} = this.SafeString(this.Options, "deriveWalletAddress")
    if IsTrue(!IsEqual(optionsWallet, nil)) {
        return []interface{}{optionsWallet, params}
    }
    panic(ArgumentsRequired(Add(Add(Add(this.Id, " "), methodName), "() requires a deriveWalletAddress parameter inside \\'params\\' or exchange.options[\\'deriveWalletAddress\\'] = ADDRESS, the address can find in HOME => Developers tab.")))
}
func  (this *derive) HandleErrors(httpCode interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if !IsTrue(response) {
        return nil  // fallback to default error handler
    }
    var error interface{} = this.SafeDict(response, "error")
    if IsTrue(!IsEqual(error, nil)) {
        var errorCode interface{} = this.SafeString(error, "code")
        var feedback interface{} = Add(Add(this.Id, " "), this.Json(response))
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), body, feedback)
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), errorCode, feedback)
        panic(ExchangeError(feedback))
    }
    return nil
}
func  (this *derive) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var url interface{} = Add(Add(GetValue(GetValue(this.Urls, "api"), api), "/"), path)
    if IsTrue(IsEqual(method, "POST")) {
        headers = map[string]interface{} {
            "Content-Type": "application/json",
        }
        if IsTrue(IsEqual(api, "private")) {
            var now interface{} = ToString(this.Milliseconds())
            var signature interface{} = this.SignMessage(now, this.PrivateKey)
            AddElementToObject(headers, "X-LyraWallet", this.SafeString(this.Options, "deriveWalletAddress"))
            AddElementToObject(headers, "X-LyraTimestamp", now)
            AddElementToObject(headers, "X-LyraSignature", signature)
        }
        body = this.Json(params)
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}


func (this *derive) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.DerivedExchange = this
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
}
