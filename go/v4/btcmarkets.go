package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type btcmarkets struct {
    Exchange

}

func NewBtcmarketsCore() btcmarkets {
   p := btcmarkets{}
   setDefaults(&p)
   return p
}

func  (this *btcmarkets) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "btcmarkets",
        "name": "BTC Markets",
        "countries": []interface{}{"AU"},
        "rateLimit": 1000,
        "version": "v3",
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": false,
            "swap": false,
            "future": false,
            "option": false,
            "addMargin": false,
            "cancelOrder": true,
            "cancelOrders": true,
            "closeAllPositions": false,
            "closePosition": false,
            "createDepositAddress": false,
            "createOrder": true,
            "createReduceOnlyOrder": false,
            "createTriggerOrder": true,
            "fetchBalance": true,
            "fetchBorrowRateHistories": false,
            "fetchBorrowRateHistory": false,
            "fetchClosedOrders": "emulated",
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchDepositAddress": false,
            "fetchDepositAddresses": false,
            "fetchDepositAddressesByNetwork": false,
            "fetchDeposits": true,
            "fetchDepositsWithdrawals": true,
            "fetchFundingHistory": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchIndexOHLCV": false,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchLeverage": false,
            "fetchMarginMode": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrders": true,
            "fetchPosition": false,
            "fetchPositionHistory": false,
            "fetchPositionMode": false,
            "fetchPositions": false,
            "fetchPositionsForSymbol": false,
            "fetchPositionsHistory": false,
            "fetchPositionsRisk": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchTicker": true,
            "fetchTime": true,
            "fetchTrades": true,
            "fetchTransactions": "emulated",
            "fetchWithdrawals": true,
            "reduceMargin": false,
            "setLeverage": false,
            "setMarginMode": false,
            "setPositionMode": false,
            "withdraw": true,
        },
        "urls": map[string]interface{} {
            "logo": "https://github.com/user-attachments/assets/8c8d6907-3873-4cc4-ad20-e22fba28247e",
            "api": map[string]interface{} {
                "public": "https://api.btcmarkets.net",
                "private": "https://api.btcmarkets.net",
            },
            "www": "https://btcmarkets.net",
            "doc": []interface{}{"https://api.btcmarkets.net/doc/v3", "https://github.com/BTCMarkets/API"},
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": []interface{}{"markets", "markets/{marketId}/ticker", "markets/{marketId}/trades", "markets/{marketId}/orderbook", "markets/{marketId}/candles", "markets/tickers", "markets/orderbooks", "time"},
            },
            "private": map[string]interface{} {
                "get": []interface{}{"orders", "orders/{id}", "batchorders/{ids}", "trades", "trades/{id}", "withdrawals", "withdrawals/{id}", "deposits", "deposits/{id}", "transfers", "transfers/{id}", "addresses", "withdrawal-fees", "assets", "accounts/me/trading-fees", "accounts/me/withdrawal-limits", "accounts/me/balances", "accounts/me/transactions", "reports/{id}"},
                "post": []interface{}{"orders", "batchorders", "withdrawals", "reports"},
                "delete": []interface{}{"orders", "orders/{id}", "batchorders/{ids}"},
                "put": []interface{}{"orders/{id}"},
            },
        },
        "timeframes": map[string]interface{} {
            "1m": "1m",
            "1h": "1h",
            "1d": "1d",
        },
        "features": map[string]interface{} {
            "spot": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": true,
                    "triggerPriceType": nil,
                    "triggerDirection": false,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": true,
                        "FOK": true,
                        "PO": true,
                        "GTD": false,
                    },
                    "hedged": false,
                    "leverage": false,
                    "marketBuyRequiresPrice": false,
                    "marketBuyByCost": false,
                    "selfTradePrevention": true,
                    "trailing": false,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": 100000,
                    "untilDays": 100000,
                    "symbolRequired": true,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": 100000,
                    "untilDays": 100000,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchClosedOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": 100000,
                    "daysBackCanceled": 1,
                    "untilDays": 100000,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOHLCV": map[string]interface{} {
                    "limit": 1000,
                },
            },
            "swap": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "precisionMode": TICK_SIZE,
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "InsufficientFund": InsufficientFunds,
                "InvalidPrice": InvalidOrder,
                "InvalidAmount": InvalidOrder,
                "MissingArgument": BadRequest,
                "OrderAlreadyCancelled": InvalidOrder,
                "OrderNotFound": OrderNotFound,
                "OrderStatusIsFinal": InvalidOrder,
                "InvalidPaginationParameter": BadRequest,
            },
            "broad": map[string]interface{} {},
        },
        "fees": map[string]interface{} {
            "percentage": true,
            "tierBased": true,
            "maker": this.ParseNumber("-0.0005"),
            "taker": this.ParseNumber("0.0020"),
        },
        "options": map[string]interface{} {
            "fees": map[string]interface{} {
                "AUD": map[string]interface{} {
                    "maker": this.ParseNumber("0.0085"),
                    "taker": this.ParseNumber("0.0085"),
                },
            },
        },
    })
}
func  (this *btcmarkets) FetchTransactionsWithMethod(method interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes2678 := (<-this.LoadMarkets())
            PanicOnError(retRes2678)
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "after", since)
            }
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
            }
        
            response:= (<-this.callDynamically(method, this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseTransactions(response, currency, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btcmarkets#fetchDepositsWithdrawals
 * @description fetch history of deposits and withdrawals
 * @see https://docs.btcmarkets.net/v3/#tag/Fund-Management-APIs/paths/~1v3~1transfers/get
 * @param {string} [code] unified currency code for the currency of the deposit/withdrawals, default is undefined
 * @param {int} [since] timestamp in ms of the earliest deposit/withdrawal, default is undefined
 * @param {int} [limit] max number of deposit/withdrawals to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *btcmarkets) FetchDepositsWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
                retRes29515 :=  (<-this.FetchTransactionsWithMethod("privateGetTransfers", code, since, limit, params))
                PanicOnError(retRes29515)
                ch <- retRes29515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btcmarkets#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://docs.btcmarkets.net/v3/#tag/Fund-Management-APIs/paths/~1v3~1deposits/get
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *btcmarkets) FetchDeposits(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
                retRes31015 :=  (<-this.FetchTransactionsWithMethod("privateGetDeposits", code, since, limit, params))
                PanicOnError(retRes31015)
                ch <- retRes31015
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btcmarkets#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @see https://docs.btcmarkets.net/v3/#tag/Fund-Management-APIs/paths/~1v3~1withdrawals/get
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawals structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *btcmarkets) FetchWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
                retRes32515 :=  (<-this.FetchTransactionsWithMethod("privateGetWithdrawals", code, since, limit, params))
                PanicOnError(retRes32515)
                ch <- retRes32515
                return nil
        
            }()
            return ch
        }
func  (this *btcmarkets) ParseTransactionStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "Accepted": "pending",
        "Pending Authorization": "pending",
        "Complete": "ok",
        "Cancelled": "cancelled",
        "Failed": "failed",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *btcmarkets) ParseTransactionType(typeVar interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "Withdraw": "withdrawal",
        "Deposit": "deposit",
    }
    return this.SafeString(statuses, typeVar, typeVar)
}
func  (this *btcmarkets) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //         "id": "6500230339",
    //         "assetName": "XRP",
    //         "amount": "500",
    //         "type": "Deposit",
    //         "creationTime": "2020-07-27T07:52:08.640000Z",
    //         "status": "Complete",
    //         "description": "RIPPLE Deposit, XRP 500",
    //         "fee": "0",
    //         "lastUpdate": "2020-07-27T07:52:08.665000Z",
    //         "paymentDetail": {
    //             "txId": "lsjflsjdfljsd",
    //             "address": "kjasfkjsdf?dt=873874545"
    //         }
    //    }
    //
    //    {
    //         "id": "500985282",
    //         "assetName": "BTC",
    //         "amount": "0.42570126",
    //         "type": "Withdraw",
    //         "creationTime": "2017-07-29T12:49:03.931000Z",
    //         "status": "Complete",
    //         "description": "BTC withdraw from [nick-btcmarkets@snowmonkey.co.uk] to Address: 1B9DsnSYQ54VMqFHVJYdGoLMCYzFwrQzsj amount: 0.42570126 fee: 0.00000000",
    //         "fee": "0.0005",
    //         "lastUpdate": "2017-07-29T12:52:20.676000Z",
    //         "paymentDetail": {
    //             "txId": "fkjdsfjsfljsdfl",
    //             "address": "a;daddjas;djas"
    //         }
    //    }
    //
    //    {
    //         "id": "505102262",
    //         "assetName": "XRP",
    //         "amount": "979.836",
    //         "type": "Deposit",
    //         "creationTime": "2017-07-31T08:50:01.053000Z",
    //         "status": "Complete",
    //         "description": "Ripple Deposit, X 979.8360",
    //         "fee": "0",
    //         "lastUpdate": "2017-07-31T08:50:01.290000Z"
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var timestamp interface{} = this.Parse8601(this.SafeString(transaction, "creationTime"))
    var lastUpdate interface{} = this.Parse8601(this.SafeString(transaction, "lastUpdate"))
    var typeVar interface{} = this.ParseTransactionType(this.SafeStringLower(transaction, "type"))
    if IsTrue(IsEqual(typeVar, "withdraw")) {
        typeVar = "withdrawal"
    }
    var cryptoPaymentDetail interface{} = this.SafeDict(transaction, "paymentDetail", map[string]interface{} {})
    var txid interface{} = this.SafeString(cryptoPaymentDetail, "txId")
    var address interface{} = this.SafeString(cryptoPaymentDetail, "address")
    var tag interface{} = nil
    if IsTrue(!IsEqual(address, nil)) {
        var addressParts interface{} = Split(address, "?dt=")
        var numParts interface{} =         GetArrayLength(addressParts)
        if IsTrue(IsGreaterThan(numParts, 1)) {
            address = GetValue(addressParts, 0)
            tag = GetValue(addressParts, 1)
        }
    }
    var addressTo interface{} = address
    var tagTo interface{} = tag
    var addressFrom interface{} = nil
    var tagFrom interface{} = nil
    var fee interface{} = this.SafeString(transaction, "fee")
    var status interface{} = this.ParseTransactionStatus(this.SafeString(transaction, "status"))
    var currencyId interface{} = this.SafeString(transaction, "assetName")
    var code interface{} = this.SafeCurrencyCode(currencyId)
    var amount interface{} = this.SafeString(transaction, "amount")
    if IsTrue(fee) {
        amount = Precise.StringSub(amount, fee)
    }
    return map[string]interface{} {
        "id": this.SafeString(transaction, "id"),
        "txid": txid,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "network": nil,
        "address": address,
        "addressTo": addressTo,
        "addressFrom": addressFrom,
        "tag": tag,
        "tagTo": tagTo,
        "tagFrom": tagFrom,
        "type": typeVar,
        "amount": this.ParseNumber(amount),
        "currency": code,
        "status": status,
        "updated": lastUpdate,
        "comment": this.SafeString(transaction, "description"),
        "internal": nil,
        "fee": map[string]interface{} {
            "currency": code,
            "cost": this.ParseNumber(fee),
            "rate": nil,
        },
        "info": transaction,
    }
}
/**
 * @method
 * @name btcmarkets#fetchMarkets
 * @description retrieves data on all markets for btcmarkets
 * @see https://docs.btcmarkets.net/v3/#tag/Market-Data-APIs/paths/~1v3~1markets/get
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *btcmarkets) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetMarkets(params))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "marketId":"COMP-AUD",
            //             "baseAssetName":"COMP",
            //             "quoteAssetName":"AUD",
            //             "minOrderAmount":"0.00007",
            //             "maxOrderAmount":"1000000",
            //             "amountDecimals":"8",
            //             "priceDecimals":"2",
            //             "status": "Online"
            //         }
            //     ]
            //
        ch <- this.ParseMarkets(response)
            return nil
        
            }()
            return ch
        }
func  (this *btcmarkets) ParseMarket(market interface{}) interface{}  {
    var baseId interface{} = this.SafeString(market, "baseAssetName")
    var quoteId interface{} = this.SafeString(market, "quoteAssetName")
    var id interface{} = this.SafeString(market, "marketId")
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    var symbol interface{} = Add(Add(base, "/"), quote)
    var fees interface{} = this.SafeValue(this.SafeDict(this.Options, "fees", map[string]interface{} {}), quote, this.Fees)
    var pricePrecision interface{} = this.ParseNumber(this.ParsePrecision(this.SafeString(market, "priceDecimals")))
    var minAmount interface{} = this.SafeNumber(market, "minOrderAmount")
    var maxAmount interface{} = this.SafeNumber(market, "maxOrderAmount")
    var status interface{} = this.SafeString(market, "status")
    var minPrice interface{} = nil
    if IsTrue(IsEqual(quote, "AUD")) {
        minPrice = pricePrecision
    }
    return map[string]interface{} {
        "id": id,
        "symbol": symbol,
        "base": base,
        "quote": quote,
        "settle": nil,
        "baseId": baseId,
        "quoteId": quoteId,
        "settleId": nil,
        "type": "spot",
        "spot": true,
        "margin": false,
        "swap": false,
        "future": false,
        "option": false,
        "active": (IsEqual(status, "Online")),
        "contract": false,
        "linear": nil,
        "inverse": nil,
        "taker": GetValue(fees, "taker"),
        "maker": GetValue(fees, "maker"),
        "contractSize": nil,
        "expiry": nil,
        "expiryDatetime": nil,
        "strike": nil,
        "optionType": nil,
        "precision": map[string]interface{} {
            "amount": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "amountDecimals"))),
            "price": pricePrecision,
        },
        "limits": map[string]interface{} {
            "leverage": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "amount": map[string]interface{} {
                "min": minAmount,
                "max": maxAmount,
            },
            "price": map[string]interface{} {
                "min": minPrice,
                "max": nil,
            },
            "cost": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
        },
        "created": nil,
        "info": market,
    }
}
/**
 * @method
 * @name btcmarkets#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @see https://docs.btcmarkets.net/v3/#tag/Misc-APIs/paths/~1v3~1time/get
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func  (this *btcmarkets) FetchTime(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetTime(params))
            PanicOnError(response)
        
                //
            //     {
            //         "timestamp": "2019-09-01T18:34:27.045000Z"
            //     }
            //
        ch <- this.Parse8601(this.SafeString(response, "timestamp"))
            return nil
        
            }()
            return ch
        }
func  (this *btcmarkets) ParseBalance(response interface{}) interface{}  {
    var result interface{} = map[string]interface{} {
        "info": response,
    }
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        var balance interface{} = GetValue(response, i)
        var currencyId interface{} = this.SafeString(balance, "assetName")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        AddElementToObject(account, "used", this.SafeString(balance, "locked"))
        AddElementToObject(account, "total", this.SafeString(balance, "balance"))
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name btcmarkets#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://docs.btcmarkets.net/v3/#tag/Account-APIs/paths/~1v3~1accounts~1me~1balances/get
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *btcmarkets) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes5888 := (<-this.LoadMarkets())
            PanicOnError(retRes5888)
        
            response:= (<-this.PrivateGetAccountsMeBalances(params))
            PanicOnError(response)
        
            ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
func  (this *btcmarkets) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     [
    //         "2020-09-12T18:30:00.000000Z",
    //         "14409.45", // open
    //         "14409.45", // high
    //         "14403.91", // low
    //         "14403.91", // close
    //         "0.01571701" // volume
    //     ]
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.Parse8601(this.SafeString(ohlcv, 0)), this.SafeNumber(ohlcv, 1), this.SafeNumber(ohlcv, 2), this.SafeNumber(ohlcv, 3), this.SafeNumber(ohlcv, 4), this.SafeNumber(ohlcv, 5)}
}
/**
 * @method
 * @name btcmarkets#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://docs.btcmarkets.net/v3/#tag/Market-Data-APIs/paths/~1v3~1markets~1{marketId}~1candles/get
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *btcmarkets) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes6278 := (<-this.LoadMarkets())
            PanicOnError(retRes6278)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "marketId": GetValue(market, "id"),
                "timeWindow": this.SafeString(this.Timeframes, timeframe, timeframe),
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "from", this.Iso8601(since))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", mathMin(limit, 200)) // default is 10, max 200
            }
        
            response:= (<-this.PublicGetMarketsMarketIdCandles(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         ["2020-09-12T18:30:00.000000Z","14409.45","14409.45","14403.91","14403.91","0.01571701"],
            //         ["2020-09-12T18:21:00.000000Z","14409.45","14409.45","14409.45","14409.45","0.0035"],
            //         ["2020-09-12T18:03:00.000000Z","14361.37","14361.37","14361.37","14361.37","0.00345221"],
            //     ]
            //
        ch <- this.ParseOHLCVs(response, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btcmarkets#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://docs.btcmarkets.net/v3/#tag/Market-Data-APIs/paths/~1v3~1markets~1{marketId}~1orderbook/get
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *btcmarkets) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes6668 := (<-this.LoadMarkets())
            PanicOnError(retRes6668)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "marketId": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetMarketsMarketIdOrderbook(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "marketId":"BTC-AUD",
            //         "snapshotId":1599936148941000,
            //         "asks":[
            //             ["14459.45","0.00456475"],
            //             ["14463.56","2"],
            //             ["14470.91","0.98"],
            //         ],
            //         "bids":[
            //             ["14421.01","0.52"],
            //             ["14421","0.75"],
            //             ["14418","0.3521"],
            //         ]
            //     }
            //
            var timestamp interface{} = this.SafeIntegerProduct(response, "snapshotId", 0.001)
            var orderbook interface{} = this.ParseOrderBook(response, symbol, timestamp)
            AddElementToObject(orderbook, "nonce", this.SafeInteger(response, "snapshotId"))
        
            ch <- orderbook
            return nil
        
            }()
            return ch
        }
func  (this *btcmarkets) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTicker
    //
    //     {
    //         "marketId":"BAT-AUD",
    //         "bestBid":"0.3751",
    //         "bestAsk":"0.377",
    //         "lastPrice":"0.3769",
    //         "volume24h":"56192.97613335",
    //         "volumeQte24h":"21179.13270465",
    //         "price24h":"0.0119",
    //         "pricePct24h":"3.26",
    //         "low24h":"0.3611",
    //         "high24h":"0.3799",
    //         "timestamp":"2020-08-09T18:28:23.280000Z"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(ticker, "marketId")
    market = this.SafeMarket(marketId, market, "-")
    var symbol interface{} = GetValue(market, "symbol")
    var timestamp interface{} = this.Parse8601(this.SafeString(ticker, "timestamp"))
    var last interface{} = this.SafeString(ticker, "lastPrice")
    var baseVolume interface{} = this.SafeString(ticker, "volume24h")
    var quoteVolume interface{} = this.SafeString(ticker, "volumeQte24h")
    var change interface{} = this.SafeString(ticker, "price24h")
    var percentage interface{} = this.SafeString(ticker, "pricePct24h")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeString(ticker, "high24h"),
        "low": this.SafeString(ticker, "low"),
        "bid": this.SafeString(ticker, "bestBid"),
        "bidVolume": nil,
        "ask": this.SafeString(ticker, "bestAsk"),
        "askVolume": nil,
        "vwap": nil,
        "open": nil,
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": change,
        "percentage": percentage,
        "average": nil,
        "baseVolume": baseVolume,
        "quoteVolume": quoteVolume,
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name btcmarkets#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://docs.btcmarkets.net/v3/#tag/Market-Data-APIs/paths/~1v3~1markets~1{marketId}~1ticker/get
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *btcmarkets) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes7558 := (<-this.LoadMarkets())
            PanicOnError(retRes7558)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "marketId": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetMarketsMarketIdTicker(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "marketId":"BAT-AUD",
            //         "bestBid":"0.3751",
            //         "bestAsk":"0.377",
            //         "lastPrice":"0.3769",
            //         "volume24h":"56192.97613335",
            //         "volumeQte24h":"21179.13270465",
            //         "price24h":"0.0119",
            //         "pricePct24h":"3.26",
            //         "low24h":"0.3611",
            //         "high24h":"0.3799",
            //         "timestamp":"2020-08-09T18:28:23.280000Z"
            //     }
            //
        ch <- this.ParseTicker(response, market)
            return nil
        
            }()
            return ch
        }
func  (this *btcmarkets) FetchTicker2(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes7808 := (<-this.LoadMarkets())
            PanicOnError(retRes7808)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "id": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetMarketsMarketIdTicker(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseTicker(response, market)
            return nil
        
            }()
            return ch
        }
func  (this *btcmarkets) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // public fetchTrades
    //
    //     {
    //         "id":"6191646611",
    //         "price":"539.98",
    //         "amount":"0.5",
    //         "timestamp":"2020-08-09T15:21:05.016000Z",
    //         "side":"Ask"
    //     }
    //
    // private fetchMyTrades
    //
    //     {
    //         "id": "36014819",
    //         "marketId": "XRP-AUD",
    //         "timestamp": "2019-06-25T16:01:02.977000Z",
    //         "price": "0.67",
    //         "amount": "1.50533262",
    //         "side": "Ask",
    //         "fee": "0.00857285",
    //         "orderId": "3648306",
    //         "liquidityType": "Taker",
    //         "clientOrderId": "48"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.Parse8601(this.SafeString(trade, "timestamp"))
    var marketId interface{} = this.SafeString(trade, "marketId")
    market = this.SafeMarket(marketId, market, "-")
    var feeCurrencyCode interface{} = Ternary(IsTrue((IsEqual(GetValue(market, "quote"), "AUD"))), GetValue(market, "quote"), GetValue(market, "base"))
    var side interface{} = this.SafeString(trade, "side")
    if IsTrue(IsEqual(side, "Bid")) {
        side = "buy"
    } else if IsTrue(IsEqual(side, "Ask")) {
        side = "sell"
    }
    var id interface{} = this.SafeString(trade, "id")
    var priceString interface{} = this.SafeString(trade, "price")
    var amountString interface{} = this.SafeString(trade, "amount")
    var orderId interface{} = this.SafeString(trade, "orderId")
    var fee interface{} = nil
    var feeCostString interface{} = this.SafeString(trade, "fee")
    if IsTrue(!IsEqual(feeCostString, nil)) {
        fee = map[string]interface{} {
            "cost": feeCostString,
            "currency": feeCurrencyCode,
        }
    }
    var takerOrMaker interface{} = this.SafeStringLower(trade, "liquidityType")
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "id": id,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "order": orderId,
        "symbol": GetValue(market, "symbol"),
        "type": nil,
        "side": side,
        "price": priceString,
        "amount": amountString,
        "cost": nil,
        "takerOrMaker": takerOrMaker,
        "fee": fee,
    }, market)
}
/**
 * @method
 * @name btcmarkets#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://docs.btcmarkets.net/v3/#tag/Market-Data-APIs/paths/~1v3~1markets~1{marketId}~1trades/get
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *btcmarkets) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes8688 := (<-this.LoadMarkets())
            PanicOnError(retRes8688)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "marketId": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetMarketsMarketIdTrades(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         {"id":"6191646611","price":"539.98","amount":"0.5","timestamp":"2020-08-09T15:21:05.016000Z","side":"Ask"},
            //         {"id":"6191646610","price":"539.99","amount":"0.5","timestamp":"2020-08-09T15:21:05.015000Z","side":"Ask"},
            //         {"id":"6191646590","price":"540","amount":"0.00233785","timestamp":"2020-08-09T15:21:04.171000Z","side":"Bid"},
            //     ]
            //
        ch <- this.ParseTrades(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btcmarkets#createOrder
 * @description create a trade order
 * @see https://docs.btcmarkets.net/v3/#tag/Order-Placement-APIs/paths/~1v3~1orders/post
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {float} [params.triggerPrice] the price at which a trigger order is triggered at
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *btcmarkets) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes9008 := (<-this.LoadMarkets())
            PanicOnError(retRes9008)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "marketId": GetValue(market, "id"),
                "amount": this.AmountToPrecision(symbol, amount),
                "side": Ternary(IsTrue((IsEqual(side, "buy"))), "Bid", "Ask"),
            }
            var lowercaseType interface{} = ToLower(typeVar)
            var orderTypes interface{} = this.SafeValue(this.Options, "orderTypes", map[string]interface{} {
                "limit": "Limit",
                "market": "Market",
                "stop": "Stop",
                "stop limit": "Stop Limit",
                "take profit": "Take Profit",
            })
            AddElementToObject(request, "type", this.SafeString(orderTypes, lowercaseType, typeVar))
            var priceIsRequired interface{} = false
            var triggerPriceIsRequired interface{} = false
            if IsTrue(IsEqual(lowercaseType, "limit")) {
                priceIsRequired = true
            } else if IsTrue(IsEqual(lowercaseType, "stop limit")) {
                triggerPriceIsRequired = true
                priceIsRequired = true
            } else if IsTrue(IsEqual(lowercaseType, "take profit")) {
                triggerPriceIsRequired = true
            } else if IsTrue(IsEqual(lowercaseType, "stop")) {
                triggerPriceIsRequired = true
            }
            if IsTrue(priceIsRequired) {
                if IsTrue(IsEqual(price, nil)) {
                    panic(ArgumentsRequired(Add(Add(Add(this.Id, " createOrder() requires a price argument for a "), typeVar), "order")))
                } else {
                    AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
                }
            }
            if IsTrue(triggerPriceIsRequired) {
                var triggerPrice interface{} = this.SafeNumber(params, "triggerPrice")
                params = this.Omit(params, "triggerPrice")
                if IsTrue(IsEqual(triggerPrice, nil)) {
                    panic(ArgumentsRequired(Add(Add(Add(this.Id, " createOrder() requires a triggerPrice parameter for a "), typeVar), "order")))
                } else {
                    AddElementToObject(request, "triggerPrice", this.PriceToPrecision(symbol, triggerPrice))
                }
            }
            var clientOrderId interface{} = this.SafeString(params, "clientOrderId")
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                AddElementToObject(request, "clientOrderId", clientOrderId)
            }
            params = this.Omit(params, "clientOrderId")
        
            response:= (<-this.PrivatePostOrders(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "orderId": "7524",
            //         "marketId": "BTC-AUD",
            //         "side": "Bid",
            //         "type": "Limit",
            //         "creationTime": "2019-08-30T11:08:21.956000Z",
            //         "price": "100.12",
            //         "amount": "1.034",
            //         "openAmount": "1.034",
            //         "status": "Accepted",
            //         "clientOrderId": "1234-5678",
            //         "timeInForce": "IOC",
            //         "postOnly": false,
            //         "selfTrade": "P",
            //         "triggerAmount": "105",
            //         "targetAmount": "1000"
            //     }
            //
        ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btcmarkets#cancelOrders
 * @description cancel multiple orders
 * @see https://docs.btcmarkets.net/v3/#tag/Batch-Order-APIs/paths/~1v3~1batchorders~1{ids}/delete
 * @param {string[]} ids order ids
 * @param {string} symbol not used by btcmarkets cancelOrders ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *btcmarkets) CancelOrders(ids interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes9948 := (<-this.LoadMarkets())
            PanicOnError(retRes9948)
            for i := 0; IsLessThan(i, GetArrayLength(ids)); i++ {
                AddElementToObject(ids, i, ParseInt(GetValue(ids, i)))
            }
            var request interface{} = map[string]interface{} {
                "ids": ids,
            }
        
            response:= (<-this.PrivateDeleteBatchordersIds(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //       "cancelOrders": [
            //            {
            //               "orderId": "414186",
            //               "clientOrderId": "6"
            //            },
            //            ...
            //        ],
            //        "unprocessedRequests": [
            //            {
            //               "code": "OrderAlreadyCancelled",
            //               "message": "order is already cancelled.",
            //               "requestId": "1"
            //            }
            //        ]
            //    }
            //
            var cancelOrders interface{} = this.SafeList(response, "cancelOrders", []interface{}{})
            var unprocessedRequests interface{} = this.SafeList(response, "unprocessedRequests", []interface{}{})
            var orders interface{} = this.ArrayConcat(cancelOrders, unprocessedRequests)
        
            ch <- this.ParseOrders(orders)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btcmarkets#cancelOrder
 * @description cancels an open order
 * @see https://docs.btcmarkets.net/v3/#operation/cancelOrder
 * @param {string} id order id
 * @param {string} symbol not used by btcmarket cancelOrder ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *btcmarkets) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes10378 := (<-this.LoadMarkets())
            PanicOnError(retRes10378)
            var request interface{} = map[string]interface{} {
                "id": id,
            }
        
            response:= (<-this.PrivateDeleteOrdersId(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //    {
            //        "orderId": "7524",
            //        "clientOrderId": "123-456"
            //    }
            //
        ch <- this.ParseOrder(response)
            return nil
        
            }()
            return ch
        }
func  (this *btcmarkets) CalculateFee(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, price interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @description calculates the presumptive fee that would be charged for an order
    * @param {string} symbol unified market symbol
    * @param {string} type not used by btcmarkets.calculateFee
    * @param {string} side not used by btcmarkets.calculateFee
    * @param {float} amount how much you want to trade, in units of the base currency on most exchanges, or number of contracts
    * @param {float} price the price for the order to be filled at, in units of the quote currency
    * @param {string} takerOrMaker 'taker' or 'maker'
    * @param {object} params
    * @returns {object} contains the rate, the percentage multiplied to the order amount to obtain the fee amount, and cost, the total value of the fee in units of the quote currency, for the order
    */
    takerOrMaker := GetArg(optionalArgs, 0, "taker")
    _ = takerOrMaker
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    var market interface{} = GetValue(this.Markets, symbol)
    var currency interface{} = nil
    var cost interface{} = nil
    if IsTrue(IsEqual(GetValue(market, "quote"), "AUD")) {
        currency = GetValue(market, "quote")
        var amountString interface{} = this.NumberToString(amount)
        var priceString interface{} = this.NumberToString(price)
        var otherUnitsAmount interface{} = Precise.StringMul(amountString, priceString)
        cost = this.CostToPrecision(symbol, otherUnitsAmount)
    } else {
        currency = GetValue(market, "base")
        cost = this.AmountToPrecision(symbol, amount)
    }
    var rate interface{} = GetValue(market, takerOrMaker)
    var rateCost interface{} = Precise.StringMul(this.NumberToString(rate), cost)
    return map[string]interface{} {
        "type": takerOrMaker,
        "currency": currency,
        "rate": rate,
        "cost": ParseFloat(this.FeeToPrecision(symbol, rateCost)),
    }
}
func  (this *btcmarkets) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "Accepted": "open",
        "Placed": "open",
        "Partially Matched": "open",
        "Fully Matched": "closed",
        "Cancelled": "canceled",
        "Partially Cancelled": "canceled",
        "Failed": "rejected",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *btcmarkets) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // createOrder
    //
    //     {
    //         "orderId": "7524",
    //         "marketId": "BTC-AUD",
    //         "side": "Bid",
    //         "type": "Limit",
    //         "creationTime": "2019-08-30T11:08:21.956000Z",
    //         "price": "100.12",
    //         "amount": "1.034",
    //         "openAmount": "1.034",
    //         "status": "Accepted",
    //         "clientOrderId": "1234-5678",
    //         "timeInForce": "IOC",
    //         "postOnly": false,
    //         "selfTrade": "P",
    //         "triggerAmount": "105",
    //         "targetAmount": "1000"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.Parse8601(this.SafeString(order, "creationTime"))
    var marketId interface{} = this.SafeString(order, "marketId")
    market = this.SafeMarket(marketId, market, "-")
    var side interface{} = this.SafeString(order, "side")
    if IsTrue(IsEqual(side, "Bid")) {
        side = "buy"
    } else if IsTrue(IsEqual(side, "Ask")) {
        side = "sell"
    }
    var typeVar interface{} = this.SafeStringLower(order, "type")
    var price interface{} = this.SafeString(order, "price")
    var amount interface{} = this.SafeString(order, "amount")
    var remaining interface{} = this.SafeString(order, "openAmount")
    var status interface{} = this.ParseOrderStatus(this.SafeString(order, "status"))
    var id interface{} = this.SafeString(order, "orderId")
    var clientOrderId interface{} = this.SafeString(order, "clientOrderId")
    var timeInForce interface{} = this.SafeString(order, "timeInForce")
    var postOnly interface{} = this.SafeBool(order, "postOnly")
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": id,
        "clientOrderId": clientOrderId,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "symbol": GetValue(market, "symbol"),
        "type": typeVar,
        "timeInForce": timeInForce,
        "postOnly": postOnly,
        "side": side,
        "price": price,
        "triggerPrice": this.SafeNumber(order, "triggerPrice"),
        "cost": nil,
        "amount": amount,
        "filled": nil,
        "remaining": remaining,
        "average": nil,
        "status": status,
        "trades": nil,
        "fee": nil,
    }, market)
}
/**
 * @method
 * @name btcmarkets#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://docs.btcmarkets.net/v3/#operation/getOrderById
 * @param {string} id the order id
 * @param {string} symbol not used by btcmarkets fetchOrder
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *btcmarkets) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes11768 := (<-this.LoadMarkets())
            PanicOnError(retRes11768)
            var request interface{} = map[string]interface{} {
                "id": id,
            }
        
            response:= (<-this.PrivateGetOrdersId(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseOrder(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btcmarkets#fetchOrders
 * @description fetches information on multiple orders made by the user
 * @see https://docs.btcmarkets.net/v3/#operation/listOrders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *btcmarkets) FetchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes11968 := (<-this.LoadMarkets())
            PanicOnError(retRes11968)
            var request interface{} = map[string]interface{} {
                "status": "all",
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "marketId", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "after", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.PrivateGetOrders(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseOrders(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btcmarkets#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://docs.btcmarkets.net/v3/#operation/listOrders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *btcmarkets) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "status": "open",
            }
        
                retRes122815 :=  (<-this.FetchOrders(symbol, since, limit, this.Extend(request, params)))
                PanicOnError(retRes122815)
                ch <- retRes122815
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btcmarkets#fetchClosedOrders
 * @description fetches information on multiple closed orders made by the user
 * @see https://docs.btcmarkets.net/v3/#operation/listOrders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *btcmarkets) FetchClosedOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            orders:= (<-this.FetchOrders(symbol, since, limit, params))
            PanicOnError(orders)
        
            ch <- this.FilterBy(orders, "status", "closed")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btcmarkets#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://docs.btcmarkets.net/v3/#operation/getTrades
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *btcmarkets) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes12598 := (<-this.LoadMarkets())
            PanicOnError(retRes12598)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "marketId", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "after", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.PrivateGetTrades(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "id": "36014819",
            //             "marketId": "XRP-AUD",
            //             "timestamp": "2019-06-25T16:01:02.977000Z",
            //             "price": "0.67",
            //             "amount": "1.50533262",
            //             "side": "Ask",
            //             "fee": "0.00857285",
            //             "orderId": "3648306",
            //             "liquidityType": "Taker",
            //             "clientOrderId": "48"
            //         },
            //         {
            //             "id": "3568960",
            //             "marketId": "GNT-AUD",
            //             "timestamp": "2019-06-20T08:44:04.488000Z",
            //             "price": "0.1362",
            //             "amount": "0.85",
            //             "side": "Bid",
            //             "fee": "0.00098404",
            //             "orderId": "3543015",
            //             "liquidityType": "Maker"
            //         }
            //     ]
            //
        ch <- this.ParseTrades(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btcmarkets#withdraw
 * @description make a withdrawal
 * @see https://docs.btcmarkets.net/v3/#tag/Fund-Management-APIs/paths/~1v3~1withdrawals/post
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *btcmarkets) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params);
            tag = GetValue(tagparamsVariable,0);
            params = GetValue(tagparamsVariable,1)
        
            retRes13178 := (<-this.LoadMarkets())
            PanicOnError(retRes13178)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "currency_id": GetValue(currency, "id"),
                "amount": this.CurrencyToPrecision(code, amount),
            }
            if IsTrue(!IsEqual(code, "AUD")) {
                this.CheckAddress(address)
                AddElementToObject(request, "toAddress", address)
            }
            if IsTrue(!IsEqual(tag, nil)) {
                AddElementToObject(request, "toAddress", Add(Add(address, "?dt="), tag))
            }
        
            response:= (<-this.PrivatePostWithdrawals(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //      {
            //          "id": "4126657",
            //          "assetName": "XRP",
            //          "amount": "25",
            //          "type": "Withdraw",
            //          "creationTime": "2019-09-04T00:04:10.973000Z",
            //          "status": "Pending Authorization",
            //          "description": "XRP withdraw from [me@test.com] to Address: abc amount: 25 fee: 0",
            //          "fee": "0",
            //          "lastUpdate": "2019-09-04T00:04:11.018000Z",
            //          "paymentDetail": {
            //              "address": "abc"
            //          }
            //      }
            //
        ch <- this.ParseTransaction(response, currency)
            return nil
        
            }()
            return ch
        }
func  (this *btcmarkets) Nonce() interface{}  {
    return this.Milliseconds()
}
func  (this *btcmarkets) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var request interface{} = Add(Add(Add("/", this.Version), "/"), this.ImplodeParams(path, params))
    var query interface{} = this.Keysort(this.Omit(params, this.ExtractParams(path)))
    if IsTrue(IsEqual(api, "private")) {
        this.CheckRequiredCredentials()
        var nonce interface{} = ToString(this.Nonce())
        var secret interface{} = this.Base64ToBinary(this.Secret)
        var auth interface{} = Add(Add(method, request), nonce)
        if IsTrue(IsTrue((IsEqual(method, "GET"))) || IsTrue((IsEqual(method, "DELETE")))) {
            if IsTrue(GetArrayLength(ObjectKeys(query))) {
                request = Add(request, Add("?", this.Urlencode(query)))
            }
        } else {
            body = this.Json(query)
            auth = Add(auth, body)
        }
        var signature interface{} = this.Hmac(this.Encode(auth), secret, sha512, "base64")
        headers = map[string]interface{} {
            "Accept": "application/json",
            "Accept-Charset": "UTF-8",
            "Content-Type": "application/json",
            "BM-AUTH-APIKEY": this.ApiKey,
            "BM-AUTH-TIMESTAMP": nonce,
            "BM-AUTH-SIGNATURE": signature,
        }
    } else if IsTrue(IsEqual(api, "public")) {
        if IsTrue(GetArrayLength(ObjectKeys(query))) {
            request = Add(request, Add("?", this.Urlencode(query)))
        }
    }
    var url interface{} = Add(GetValue(GetValue(this.Urls, "api"), api), request)
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *btcmarkets) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsEqual(response, nil)) {
        return nil  // fallback to default error handler
    }
    //
    //     {"code":"UnAuthorized","message":"invalid access token"}
    //     {"code":"MarketNotFound","message":"invalid marketId"}
    //
    var errorCode interface{} = this.SafeString(response, "code")
    var message interface{} = this.SafeString(response, "message")
    if IsTrue(!IsEqual(errorCode, nil)) {
        var feedback interface{} = Add(Add(this.Id, " "), body)
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), message, feedback)
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), errorCode, feedback)
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), message, feedback)
        panic(ExchangeError(feedback))
    }
    return nil
}


func (this *btcmarkets) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
