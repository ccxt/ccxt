package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type ace struct {
    Exchange

}

func NewAceCore() ace {
   p := ace{}
   setDefaults(&p)
   return p
}

func  (this *ace) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "ace",
        "name": "ACE",
        "countries": []interface{}{"TW"},
        "version": "v2",
        "rateLimit": 100,
        "pro": false,
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": false,
            "swap": false,
            "future": false,
            "option": false,
            "cancelAllOrders": false,
            "cancelOrder": true,
            "cancelOrders": false,
            "closeAllPositions": false,
            "closePosition": false,
            "createOrder": true,
            "editOrder": false,
            "fetchBalance": true,
            "fetchBorrowRateHistories": false,
            "fetchBorrowRateHistory": false,
            "fetchClosedOrders": false,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchCurrencies": false,
            "fetchDepositAddress": false,
            "fetchDeposits": false,
            "fetchFundingHistory": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchIndexOHLCV": false,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchMarginMode": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrders": false,
            "fetchOrderTrades": true,
            "fetchPosition": false,
            "fetchPositionHistory": false,
            "fetchPositionMode": false,
            "fetchPositions": false,
            "fetchPositionsForSymbol": false,
            "fetchPositionsHistory": false,
            "fetchPositionsRisk": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTime": false,
            "fetchTrades": false,
            "fetchTradingFee": false,
            "fetchTradingFees": false,
            "fetchTransactionFees": false,
            "fetchTransactions": false,
            "fetchTransfer": false,
            "fetchTransfers": false,
            "fetchWithdrawal": false,
            "fetchWithdrawals": false,
            "setLeverage": false,
            "setMarginMode": false,
            "transfer": false,
            "withdraw": false,
            "ws": false,
        },
        "timeframes": map[string]interface{} {
            "1m": 1,
            "5m": 5,
            "10m": 10,
            "30m": 10,
            "1h": 60,
            "2h": 120,
            "4h": 240,
            "8h": 480,
            "12h": 720,
            "1d": 24,
            "1w": 70,
            "1M": 31,
        },
        "urls": map[string]interface{} {
            "logo": "https://github.com/user-attachments/assets/115f1e4a-0fd0-4b76-85d5-a49ebf64d1c8",
            "api": map[string]interface{} {
                "public": "https://ace.io/polarisex",
                "private": "https://ace.io/polarisex/open",
            },
            "www": "https://ace.io/",
            "doc": []interface{}{"https://github.com/ace-exchange/ace-offical-api-docs"},
            "fees": "https://helpcenter.ace.io/hc/zh-tw/articles/360018609132-%E8%B2%BB%E7%8E%87%E8%AA%AA%E6%98%8E",
        },
        "requiredCredentials": map[string]interface{} {
            "apiKey": true,
            "secret": true,
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": []interface{}{"oapi/v2/list/tradePrice", "oapi/v2/list/marketPair", "open/v2/public/getOrderBook"},
            },
            "private": map[string]interface{} {
                "post": []interface{}{"v2/coin/customerAccount", "v2/kline/getKline", "v2/order/order", "v2/order/cancel", "v2/order/getOrderList", "v2/order/showOrderStatus", "v2/order/showOrderHistory", "v2/order/getTradeList"},
            },
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "percentage": true,
                "maker": this.ParseNumber("0.0005"),
                "taker": this.ParseNumber("0.001"),
            },
        },
        "options": map[string]interface{} {
            "brokerId": "ccxt",
        },
        "features": map[string]interface{} {
            "spot": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": false,
                    "triggerPriceType": nil,
                    "triggerDirection": false,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": false,
                        "FOK": false,
                        "PO": false,
                        "GTD": false,
                    },
                    "hedged": false,
                    "leverage": false,
                    "marketBuyRequiresPrice": false,
                    "marketBuyByCost": false,
                    "selfTradePrevention": false,
                    "trailing": false,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": 500,
                    "daysBack": nil,
                    "untilDays": nil,
                    "symbolRequired": true,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": nil,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOrders": nil,
                "fetchClosedOrders": nil,
                "fetchOHLCV": map[string]interface{} {
                    "limit": 2000,
                },
            },
            "swap": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "precisionMode": TICK_SIZE,
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "2003": InvalidOrder,
                "2004": InvalidOrder,
                "2005": InvalidOrder,
                "2021": InsufficientFunds,
                "2036": InvalidOrder,
                "2039": InvalidOrder,
                "2053": InvalidOrder,
                "2061": BadRequest,
                "2063": InvalidOrder,
                "9996": BadRequest,
                "10012": AuthenticationError,
                "20182": AuthenticationError,
                "20183": InvalidOrder,
            },
            "broad": map[string]interface{} {},
        },
        "commonCurrencies": map[string]interface{} {},
    })
}
/**
 * @method
 * @name ace#fetchMarkets
 * @description retrieves data on all markets for ace
 * @see https://github.com/ace-exchange/ace-official-api-docs/blob/master/api_v2.md#oapi-api---market-pair
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *ace) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetOapiV2ListMarketPair())
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "symbol":"BTC/USDT",
            //             "base":"btc",
            //             "baseCurrencyId": "122"
            //             "quote":"usdt",
            //             "basePrecision":"8",
            //             "quotePrecision":"5",
            //             "minLimitBaseAmount":"0.1",
            //             "maxLimitBaseAmount":"480286"
            //         }
            //     ]
            //
        ch <- this.ParseMarkets(response)
            return nil
        
            }()
            return ch
        }
func  (this *ace) ParseMarket(market interface{}) interface{}  {
    //
    //     {
    //         "symbol": "ADA/TWD",
    //         "base": "ADA",
    //         "baseCurrencyId": "122",
    //         "quote": "TWD",
    //         "quoteCurrencyId": "1",
    //         "basePrecision": "2",
    //         "quotePrecision": "3",
    //         "minLimitBaseAmount": "1.0",
    //         "maxLimitBaseAmount": "150000.0"
    //     }
    //
    var baseId interface{} = this.SafeString(market, "baseCurrencyId")
    var base interface{} = this.SafeCurrencyCode(this.SafeString(market, "base"))
    var quoteId interface{} = this.SafeString(market, "quoteCurrencyId")
    var quote interface{} = this.SafeCurrencyCode(this.SafeString(market, "quote"))
    var symbol interface{} = Add(Add(base, "/"), quote)
    return map[string]interface{} {
        "id": this.SafeString(market, "symbol"),
        "uppercaseId": nil,
        "symbol": symbol,
        "base": base,
        "baseId": baseId,
        "quote": quote,
        "quoteId": quoteId,
        "settle": nil,
        "settleId": nil,
        "type": "spot",
        "spot": true,
        "margin": false,
        "swap": false,
        "future": false,
        "option": false,
        "contract": false,
        "linear": nil,
        "inverse": nil,
        "contractSize": nil,
        "expiry": nil,
        "expiryDatetime": nil,
        "strike": nil,
        "optionType": nil,
        "limits": map[string]interface{} {
            "amount": map[string]interface{} {
                "min": this.SafeNumber(market, "minLimitBaseAmount"),
                "max": this.SafeNumber(market, "maxLimitBaseAmount"),
            },
            "price": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "cost": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "leverage": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
        },
        "precision": map[string]interface{} {
            "price": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "quotePrecision"))),
            "amount": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "basePrecision"))),
        },
        "active": nil,
        "created": nil,
        "info": market,
    }
}
func  (this *ace) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "base_volume":229196.34035399999,
    //         "last_price":11881.06,
    //         "quote_volume":19.2909
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(ticker, "id")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": nil,
        "datetime": nil,
        "high": nil,
        "low": nil,
        "bid": nil,
        "bidVolume": nil,
        "ask": nil,
        "askVolume": nil,
        "vwap": nil,
        "open": nil,
        "close": this.SafeString(ticker, "last_price"),
        "last": this.SafeString(ticker, "last_price"),
        "previousClose": nil,
        "change": nil,
        "percentage": nil,
        "average": nil,
        "baseVolume": this.SafeString(ticker, "base_volume"),
        "quoteVolume": this.SafeString(ticker, "quote_volume"),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name ace#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://github.com/ace-exchange/ace-official-api-docs/blob/master/api_v2.md#oapi-api---trade-data
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *ace) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes3808 := (<-this.LoadMarkets())
            PanicOnError(retRes3808)
            var market interface{} = this.Market(symbol)
        
            response:= (<-this.PublicGetOapiV2ListTradePrice(params))
            PanicOnError(response)
            var marketId interface{} = GetValue(market, "id")
            var ticker interface{} = this.SafeDict(response, marketId, map[string]interface{} {})
        
                //
            //     {
            //         "BTC/USDT":{
            //             "base_volume":229196.34035399999,
            //             "last_price":11881.06,
            //             "quote_volume":19.2909
            //         }
            //     }
            //
        ch <- this.ParseTicker(ticker, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ace#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://github.com/ace-exchange/ace-official-api-docs/blob/master/api_v2.md#oapi-api---trade-data
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *ace) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes4078 := (<-this.LoadMarkets())
            PanicOnError(retRes4078)
        
            response:= (<-this.PublicGetOapiV2ListTradePrice())
            PanicOnError(response)
            //
            //     {
            //         "BTC/USDT":{
            //             "base_volume":229196.34035399999,
            //             "last_price":11881.06,
            //             "quote_volume":19.2909
            //         }
            //     }
            //
            var tickers interface{} = []interface{}{}
            var pairs interface{} = ObjectKeys(response)
            for i := 0; IsLessThan(i, GetArrayLength(pairs)); i++ {
                var marketId interface{} = GetValue(pairs, i)
                var market interface{} = this.SafeMarket(marketId)
                var rawTicker interface{} = this.SafeDict(response, marketId, map[string]interface{} {})
                var ticker interface{} = this.ParseTicker(rawTicker, market)
                AppendToArray(&tickers,ticker)
            }
        
            ch <- this.FilterByArrayTickers(tickers, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ace#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://github.com/ace-exchange/ace-official-api-docs/blob/master/api_v2.md#open-api---order-books
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *ace) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes4418 := (<-this.LoadMarkets())
            PanicOnError(retRes4418)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "quoteCurrencyId": GetValue(market, "quoteId"),
                "baseCurrencyId": GetValue(market, "baseId"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "depth", limit)
            }
        
            response:= (<-this.PublicGetOpenV2PublicGetOrderBook(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "attachment": {
            //             "baseCurrencyId": "2",
            //             "quoteCurrencyId": "14",
            //             "baseCurrencyName": "BTC",
            //             "quoteCurrencyName": "USDT",
            //             "bids": [
            //                 [
            //                     "0.0009",
            //                     "19993.53"
            //                 ],
            //                 [
            //                     "0.001",
            //                     "19675.33"
            //                 ],
            //                 [
            //                     "0.001",
            //                     "19357.13"
            //                 ]
            //             ],
            //             "asks": [
            //                 [
            //                     "0.001",
            //                     "20629.92"
            //                 ],
            //                 [
            //                     "0.001",
            //                     "20948.12"
            //                 ]
            //             ]
            //         },
            //         "message": null,
            //         "parameters": null,
            //         "status": 200
            //     }
            //
            var orderBook interface{} = this.SafeDict(response, "attachment")
        
            ch <- this.ParseOrderBook(orderBook, GetValue(market, "symbol"), nil, "bids", "asks", 1, 0)
            return nil
        
            }()
            return ch
        }
func  (this *ace) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "changeRate": 0,
    //         "volume": 0,
    //         "closePrice": 101000.0,
    //         "lowPrice": 101000.0,
    //         "highPrice": 101000.0,
    //         "highPrice": 1573195740000L,
    //         "openPrice": 101000.0,
    //         "current": 101000.0,
    //         "currentTime": "2019-11-08 14:49:00",
    //         "createTime": "2019-11-08 14:49:00"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var dateTime interface{} = this.SafeString(ohlcv, "createTime")
    var timestamp interface{} = this.Parse8601(dateTime)
    if IsTrue(!IsEqual(timestamp, nil)) {
        timestamp = Subtract(timestamp, 28800000) // 8 hours
    }
    return []interface{}{timestamp, this.SafeNumber(ohlcv, "openPrice"), this.SafeNumber(ohlcv, "highPrice"), this.SafeNumber(ohlcv, "lowPrice"), this.SafeNumber(ohlcv, "closePrice"), this.SafeNumber(ohlcv, "volume")}
}
/**
 * @method
 * @name ace#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://github.com/ace-exchange/ace-official-api-docs/blob/master/api_v2.md#open-api---klinecandlestick-data
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *ace) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes5358 := (<-this.LoadMarkets())
            PanicOnError(retRes5358)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "duration": GetValue(this.Timeframes, timeframe),
                "quoteCurrencyId": GetValue(market, "quoteId"),
                "baseCurrencyId": GetValue(market, "baseId"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
        
            response:= (<-this.PrivatePostV2KlineGetKline(this.Extend(request, params)))
            PanicOnError(response)
            var data interface{} = this.SafeList(response, "attachment", []interface{}{})
        
                //
            //     {
            //         "attachment":[
            //                 {
            //                     "changeRate": 0,
            //                     "closePrice": 101000.0,
            //                     "volume": 0,
            //                     "lowPrice": 101000.0,
            //                     "highPrice": 101000.0,
            //                     "highPrice": 1573195740000L,
            //                     "openPrice": 101000.0,
            //                     "current": 101000.0,
            //                     "currentTime": "2019-11-08 14:49:00",
            //                     "createTime": "2019-11-08 14:49:00"
            //                 }
            //         ]
            //     }
            //
        ch <- this.ParseOHLCVs(data, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *ace) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "0": "open",
        "1": "open",
        "2": "closed",
        "4": "canceled",
        "5": "canceled",
    }
    return this.SafeString(statuses, status, nil)
}
func  (this *ace) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // createOrder
    //         "15697850529570392100421100482693"
    //
    // fetchOpenOrders
    //         {
    //             "uid": 0,
    //             "orderNo": "16113081376560890227301101413941",
    //             "orderTime": "2021-01-22 17:35:37",
    //             "orderTimeStamp": 1611308137656,
    //             "baseCurrencyId": 1,
    //             "baseCurrencyName": "TWD",
    //             "quoteCurrencyId": 14,
    //             "quoteCurrencyName": "USDT",
    //             "buyOrSell": "1",
    //             "num": "6.0000000000000000",
    //             "price": "32.5880000000000000",
    //             "remainNum": "2.0000000000000000",
    //             "tradeNum": "4.0000000000000000",
    //             "tradePrice": "31.19800000000000000000",
    //             "tradeAmount": "124.7920000000000000",
    //             "tradeRate": "0.66666666666666666667",
    //             "status": 1,
    //             "type": 1
    //         }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = nil
    var timestamp interface{} = nil
    var symbol interface{} = nil
    var price interface{} = nil
    var amount interface{} = nil
    var side interface{} = nil
    var typeVar interface{} = nil
    var status interface{} = nil
    var filled interface{} = nil
    var remaining interface{} = nil
    var average interface{} = nil
    if IsTrue(IsString(order)) {
        id = order
    } else {
        id = this.SafeString(order, "orderNo")
        timestamp = this.SafeInteger(order, "orderTimeStamp")
        if IsTrue(IsEqual(timestamp, nil)) {
            var dateTime interface{} = this.SafeString(order, "orderTime")
            if IsTrue(!IsEqual(dateTime, nil)) {
                timestamp = this.Parse8601(dateTime)
                timestamp = Subtract(timestamp, 28800000) // 8 hours
            }
        }
        var orderSide interface{} = this.SafeString(order, "buyOrSell")
        if IsTrue(!IsEqual(orderSide, nil)) {
            side = Ternary(IsTrue((IsEqual(orderSide, "1"))), "buy", "sell")
        }
        amount = this.SafeString(order, "num")
        price = this.SafeString(order, "price")
        var quoteId interface{} = this.SafeString(order, "quoteCurrencyName")
        var baseId interface{} = this.SafeString(order, "baseCurrencyName")
        if IsTrue(IsTrue(!IsEqual(quoteId, nil)) && IsTrue(!IsEqual(baseId, nil))) {
            symbol = Add(Add(baseId, "/"), quoteId)
        }
        var orderType interface{} = this.SafeString(order, "type")
        if IsTrue(!IsEqual(orderType, nil)) {
            typeVar = Ternary(IsTrue((IsEqual(orderType, "1"))), "limit", "market")
        }
        filled = this.SafeString(order, "tradeNum")
        remaining = this.SafeString(order, "remainNum")
        status = this.ParseOrderStatus(this.SafeString(order, "status"))
        average = this.SafeString(order, "averagePrice")
    }
    return this.SafeOrder(map[string]interface{} {
        "id": id,
        "clientOrderId": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "symbol": symbol,
        "type": typeVar,
        "timeInForce": nil,
        "postOnly": nil,
        "side": side,
        "price": price,
        "triggerPrice": nil,
        "amount": amount,
        "cost": nil,
        "average": average,
        "filled": filled,
        "remaining": remaining,
        "status": status,
        "fee": nil,
        "trades": nil,
        "info": order,
    }, market)
}
/**
 * @method
 * @name ace#createOrder
 * @description create a trade order
 * @see https://github.com/ace-exchange/ace-official-api-docs/blob/master/api_v2.md#open-api---new-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *ace) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes6918 := (<-this.LoadMarkets())
            PanicOnError(retRes6918)
            var market interface{} = this.Market(symbol)
            var orderType interface{} = ToUpper(typeVar)
            var orderSide interface{} = ToUpper(side)
            var request interface{} = map[string]interface{} {
                "baseCurrencyId": GetValue(market, "baseId"),
                "quoteCurrencyId": GetValue(market, "quoteId"),
                "type": Ternary(IsTrue((IsEqual(orderType, "LIMIT"))), 1, 2),
                "buyOrSell": Ternary(IsTrue((IsEqual(orderSide, "BUY"))), 1, 2),
                "num": this.AmountToPrecision(symbol, amount),
            }
            if IsTrue(IsEqual(typeVar, "limit")) {
                AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
            }
        
            response:= (<-this.PrivatePostV2OrderOrder(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "attachment": "15697850529570392100421100482693",
            //         "message": null,
            //         "parameters": null,
            //         "status": 200
            //     }
            //
            var data interface{} = this.SafeDict(response, "attachment")
        
            ch <- this.ParseOrder(data, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ace#cancelOrder
 * @description cancels an open order
 * @see https://github.com/ace-exchange/ace-official-api-docs/blob/master/api_v2.md#open-api---cancel-order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *ace) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes7298 := (<-this.LoadMarkets())
            PanicOnError(retRes7298)
            var request interface{} = map[string]interface{} {
                "orderNo": id,
            }
        
            response:= (<-this.PrivatePostV2OrderCancel(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "attachment": 200,
            //         "message": null,
            //         "parameters": null,
            //         "status": 200
            //     }
            //
        ch <- response
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ace#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://github.com/ace-exchange/ace-official-api-docs/blob/master/api_v2.md#open-api---order-status
 * @param {string} id the order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *ace) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes7568 := (<-this.LoadMarkets())
            PanicOnError(retRes7568)
            var request interface{} = map[string]interface{} {
                "orderNo": id,
            }
        
            response:= (<-this.PrivatePostV2OrderShowOrderStatus(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "attachment": {
            //             "buyOrSell": 1,
            //             "averagePrice": "490849.75000000",
            //             "num": "0.00000000",
            //             "orderTime": "2022-11-29 18:03:06.318",
            //             "price": "490849.75000000",
            //             "status": 4,
            //             "tradeNum": "0.02697000",
            //             "remainNum": "0.97303000",
            //             "baseCurrencyId": 2,
            //             "baseCurrencyName": "BTC",
            //             "quoteCurrencyId": 1,
            //             "quoteCurrencyName": "TWD",
            //             "orderNo": "16697161898600391472461100244406"
            //         },
            //         "message": null,
            //         "parameters": null,
            //         "status": 200
            //     }
            //
            var data interface{} = this.SafeDict(response, "attachment")
        
            ch <- this.ParseOrder(data, nil)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ace#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://github.com/ace-exchange/ace-official-api-docs/blob/master/api_v2.md#open-api---order-list
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *ace) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchOpenOrders() requires a symbol argument")))
            }
        
            retRes8028 := (<-this.LoadMarkets())
            PanicOnError(retRes8028)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "quoteCurrencyId": GetValue(market, "quoteId"),
                "baseCurrencyId": GetValue(market, "baseId"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "size", limit)
            }
        
            response:= (<-this.PrivatePostV2OrderGetOrderList(this.Extend(request, params)))
            PanicOnError(response)
            var orders interface{} = this.SafeList(response, "attachment")
        
                //
            //     {
            //         "attachment": [
            //             {
            //                 "uid": 0,
            //                 "orderNo": "16113081376560890227301101413941",
            //                 "orderTime": "2021-01-22 17:35:37",
            //                 "orderTimeStamp": 1611308137656,
            //                 "baseCurrencyId": 1,
            //                 "baseCurrencyName": "TWD",
            //                 "quoteCurrencyId": 14,
            //                 "quoteCurrencyName": "USDT",
            //                 "buyOrSell": "1",
            //                 "num": "6.0000000000000000",
            //                 "price": "32.5880000000000000",
            //                 "remainNum": "2.0000000000000000",
            //                 "tradeNum": "4.0000000000000000",
            //                 "tradePrice": "31.19800000000000000000",
            //                 "tradeAmount": "124.7920000000000000",
            //                 "tradeRate": "0.66666666666666666667",
            //                 "status": 1,
            //                 "type": 1
            //             }
            //         ],
            //         "message": null,
            //         "parameters": null,
            //         "status": 200
            //     }
            //
        ch <- this.ParseOrders(orders, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *ace) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchOrderTrades
    //         {
    //             "amount": 0.0030965,
    //             "tradeNo": "15681920522485652100751000417788",
    //             "price": "0.03096500",
    //             "num": "0.10000000",
    //             "bi": 1,
    //             "time": "2019-09-11 16:54:12.248"
    //         }
    //
    // fetchMyTrades
    //         {
    //             "buyOrSell": 1,
    //             "orderNo": "16708156853695560053601100247906",
    //             "num": "1",
    //             "price": "16895",
    //             "orderAmount": "16895",
    //             "tradeNum": "0.1",
    //             "tradePrice": "16895",
    //             "tradeAmount": "1689.5",
    //             "fee": "0",
    //             "feeSave": "0",
    //             "status": 1,
    //             "isSelf": false,
    //             "tradeNo": "16708186395087940051961000274150",
    //             "tradeTime": "2022-12-12 12:17:19",
    //             "tradeTimestamp": 1670818639508,
    //             "quoteCurrencyId": 14,
    //             "quoteCurrencyName": "USDT",
    //             "baseCurrencyId": 2,
    //             "baseCurrencyName": "BTC"
    //         }
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeString(trade, "tradeNo")
    var price interface{} = this.SafeString(trade, "price")
    var amount interface{} = this.SafeString(trade, "num")
    var timestamp interface{} = this.SafeInteger(trade, "tradeTimestamp")
    if IsTrue(IsEqual(timestamp, nil)) {
        var datetime interface{} = this.SafeString2(trade, "time", "tradeTime")
        timestamp = this.Parse8601(datetime)
        timestamp = Subtract(timestamp, 28800000) // 8 hours normalize timestamp
    }
    var symbol interface{} = GetValue(market, "symbol")
    var quoteId interface{} = this.SafeString(trade, "quoteCurrencyName")
    var baseId interface{} = this.SafeString(trade, "baseCurrencyName")
    if IsTrue(IsTrue(!IsEqual(quoteId, nil)) && IsTrue(!IsEqual(baseId, nil))) {
        symbol = Add(Add(baseId, "/"), quoteId)
    }
    var side interface{} = nil
    var tradeSide interface{} = this.SafeInteger(trade, "buyOrSell")
    if IsTrue(!IsEqual(tradeSide, nil)) {
        side = Ternary(IsTrue((IsEqual(tradeSide, 1))), "buy", "sell")
    }
    var feeString interface{} = this.SafeString(trade, "fee")
    var fee interface{} = nil
    if IsTrue(!IsEqual(feeString, nil)) {
        var feeSaveString interface{} = this.SafeString(trade, "feeSave")
        fee = map[string]interface{} {
            "cost": Precise.StringSub(feeString, feeSaveString),
            "currency": quoteId,
        }
    }
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "id": id,
        "order": this.SafeString(trade, "orderNo"),
        "symbol": symbol,
        "side": side,
        "type": nil,
        "takerOrMaker": nil,
        "price": price,
        "amount": amount,
        "cost": nil,
        "fee": fee,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
    }, market)
}
/**
 * @method
 * @name ace#fetchOrderTrades
 * @description fetch all the trades made from a single order
 * @see https://github.com/ace-exchange/ace-official-api-docs/blob/master/api_v2.md#open-api---order-history
 * @param {string} id order id
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *ace) FetchOrderTrades(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes9398 := (<-this.LoadMarkets())
            PanicOnError(retRes9398)
            var market interface{} = this.SafeMarket(symbol)
            var request interface{} = map[string]interface{} {
                "orderNo": id,
            }
        
            response:= (<-this.PrivatePostV2OrderShowOrderHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "attachment": {
            //             "order": {
            //                 "buyOrSell": 1,
            //                 "averagePrice": "491343.74000000",
            //                 "num": "1.00000000",
            //                 "orderTime": "2022-11-29 18:32:22.232",
            //                 "price": "491343.74000000",
            //                 "status": 1,
            //                 "tradeNum": "0.01622200",
            //                 "remainNum": "0.98377800",
            //                 "baseCurrencyId": 2,
            //                 "baseCurrencyName": "BTC",
            //                 "quoteCurrencyId": 1,
            //                 "quoteCurrencyName": "TWD",
            //                 "orderNo": "16697179457740441472471100214402"
            //             },
            //             "trades": [
            //                 {
            //                     "price": "491343.74000000",
            //                     "num": "0.01622200",
            //                     "time": "2022-11-29 18:32:25.789",
            //                     "tradeNo": "16697179457897791471461000223437",
            //                     "amount": "7970.57815028"
            //                 }
            //             ]
            //         },
            //         "message": null,
            //         "parameters": null,
            //         "status": 200
            //     }
            //
            var data interface{} = this.SafeDict(response, "attachment")
            var trades interface{} = this.SafeList(data, "trades", []interface{}{})
        
            ch <- this.ParseTrades(trades, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ace#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://github.com/ace-exchange/ace-official-api-docs/blob/master/api_v2.md#open-api---trade-list
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *ace) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes9958 := (<-this.LoadMarkets())
            PanicOnError(retRes9958)
            var market interface{} = this.SafeMarket(symbol)
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(GetValue(market, "id"), nil)) {
                AddElementToObject(request, "quoteCurrencyId", GetValue(market, "quoteId"))
                AddElementToObject(request, "baseCurrencyId", GetValue(market, "baseId"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "size", limit) // default 10, max 500
            }
        
            response:= (<-this.PrivatePostV2OrderGetTradeList(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "attachment": [
            //             {
            //                 "buyOrSell": 1,
            //                 "orderNo": "16708156853695560053601100247906",
            //                 "num": "1",
            //                 "price": "16895",
            //                 "orderAmount": "16895",
            //                 "tradeNum": "0.1",
            //                 "tradePrice": "16895",
            //                 "tradeAmount": "1689.5",
            //                 "fee": "0",
            //                 "feeSave": "0",
            //                 "status": 1,
            //                 "isSelf": false,
            //                 "tradeNo": "16708186395087940051961000274150",
            //                 "tradeTime": "2022-12-12 12:17:19",
            //                 "tradeTimestamp": 1670818639508,
            //                 "quoteCurrencyId": 14,
            //                 "quoteCurrencyName": "USDT",
            //                 "baseCurrencyId": 2,
            //                 "baseCurrencyName": "BTC"
            //             }
            //         ],
            //         "message": null,
            //         "parameters": null,
            //         "status": 200
            //     }
            //
            var trades interface{} = this.SafeList(response, "attachment", []interface{}{})
        
            ch <- this.ParseTrades(trades, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *ace) ParseBalance(response interface{}) interface{}  {
    //
    //     [
    //         {
    //             "currencyId": 4,
    //             "amount": 6.896,
    //             "cashAmount": 6.3855,
    //             "uid": 123,
    //             "currencyName": "BTC"
    //         }
    //     ]
    //
    var result interface{} = map[string]interface{} {
        "info": response,
    }
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        var balance interface{} = GetValue(response, i)
        var currencyId interface{} = this.SafeString(balance, "currencyName")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var amount interface{} = this.SafeString(balance, "amount")
        var available interface{} = this.SafeString(balance, "cashAmount")
        var account interface{} = map[string]interface{} {
            "free": available,
            "total": amount,
        }
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name ace#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://github.com/ace-exchange/ace-official-api-docs/blob/master/api_v2.md#open-api---account-balance
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *ace) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes10828 := (<-this.LoadMarkets())
            PanicOnError(retRes10828)
        
            response:= (<-this.PrivatePostV2CoinCustomerAccount(params))
            PanicOnError(response)
            var balances interface{} = this.SafeList(response, "attachment", []interface{}{})
        
                //
            //     {
            //         "attachment":[
            //             {
            //                 "currencyId": 4,
            //                 "amount": 6.896,
            //                 "cashAmount": 6.3855,
            //                 "uid": 123,
            //                 "currencyName": "BTC"
            //             }
            //         ],
            //         "message": null,
            //         "parameters": null,
            //         "status": "200"
            //     }
            //
        ch <- this.ParseBalance(balances)
            return nil
        
            }()
            return ch
        }
func  (this *ace) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var url interface{} = Add("/", this.ImplodeParams(path, params))
    var query interface{} = this.Omit(params, this.ExtractParams(path))
    if IsTrue(IsEqual(headers, nil)) {
        headers = map[string]interface{} {}
    }
    if IsTrue(IsEqual(api, "private")) {
        this.CheckRequiredCredentials()
        var nonce interface{} = this.Milliseconds()
        var auth interface{} = Add("ACE_SIGN", this.Secret)
        var data interface{} = this.Extend(map[string]interface{} {
            "apiKey": this.ApiKey,
            "timeStamp": this.NumberToString(nonce),
        }, params)
        var sortedData interface{} = this.Keysort(data)
        var values interface{} = ObjectValues(sortedData)
        var stringifiedValues interface{} = []interface{}{}
        for i := 0; IsLessThan(i, GetArrayLength(values)); i++ {
            var value interface{} = GetValue(values, i)
            var strValue interface{} = ToString(value)
            AppendToArray(&stringifiedValues,strValue)
        }
        auth = Add(auth, Join(stringifiedValues, ""))
        var signature interface{} = this.Hash(this.Encode(auth), sha256, "hex")
        AddElementToObject(data, "signKey", signature)
        headers = map[string]interface{} {
            "Content-Type": "application/x-www-form-urlencoded",
        }
        if IsTrue(IsEqual(method, "POST")) {
            var brokerId interface{} = this.SafeString(this.Options, "brokerId")
            if IsTrue(!IsEqual(brokerId, nil)) {
                AddElementToObject(headers, "Referer", brokerId)
            }
        }
        body = this.Urlencode(data)
    } else if IsTrue(IsTrue(IsEqual(api, "public")) && IsTrue(IsEqual(method, "GET"))) {
        if IsTrue(GetArrayLength(ObjectKeys(query))) {
            url = Add(url, Add("?", this.Urlencode(query)))
        }
    }
    url = Add(GetValue(GetValue(this.Urls, "api"), api), url)
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *ace) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsEqual(response, nil)) {
        return nil  // fallback to the default error handler
    }
    var feedback interface{} = Add(Add(this.Id, " "), body)
    var status interface{} = this.SafeNumber(response, "status", 200)
    if IsTrue(IsGreaterThan(status, 200)) {
        var statusStr interface{} = ToString(status)
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), statusStr, feedback)
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), statusStr, feedback)
    }
    return nil
}


func (this *ace) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
