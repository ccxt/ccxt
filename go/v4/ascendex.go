package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type ascendex struct {
    Exchange

}

func NewAscendexCore() ascendex {
   p := ascendex{}
   setDefaults(&p)
   return p
}

func  (this *ascendex) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "ascendex",
        "name": "AscendEX",
        "countries": []interface{}{"SG"},
        "rateLimit": 400,
        "certified": false,
        "pro": true,
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": true,
            "swap": true,
            "future": false,
            "option": false,
            "addMargin": true,
            "cancelAllOrders": true,
            "cancelOrder": true,
            "createOrder": true,
            "createOrders": true,
            "createPostOnlyOrder": true,
            "createReduceOnlyOrder": true,
            "createStopLimitOrder": true,
            "createStopMarketOrder": true,
            "createStopOrder": true,
            "fetchAccounts": true,
            "fetchBalance": true,
            "fetchClosedOrders": true,
            "fetchCurrencies": true,
            "fetchDepositAddress": true,
            "fetchDepositAddresses": false,
            "fetchDepositAddressesByNetwork": false,
            "fetchDeposits": true,
            "fetchDepositsWithdrawals": true,
            "fetchDepositWithdrawFee": "emulated",
            "fetchDepositWithdrawFees": true,
            "fetchFundingHistory": true,
            "fetchFundingRate": "emulated",
            "fetchFundingRateHistory": false,
            "fetchFundingRates": true,
            "fetchIndexOHLCV": false,
            "fetchLeverage": "emulated",
            "fetchLeverages": true,
            "fetchLeverageTiers": true,
            "fetchMarginMode": "emulated",
            "fetchMarginModes": true,
            "fetchMarketLeverageTiers": "emulated",
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchOHLCV": true,
            "fetchOpenInterest": false,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrders": false,
            "fetchPosition": false,
            "fetchPositionMode": false,
            "fetchPositions": true,
            "fetchPositionsRisk": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTime": true,
            "fetchTrades": true,
            "fetchTradingFee": false,
            "fetchTradingFees": true,
            "fetchTransactionFee": false,
            "fetchTransactionFees": false,
            "fetchTransactions": "emulated",
            "fetchTransfer": false,
            "fetchTransfers": false,
            "fetchWithdrawal": false,
            "fetchWithdrawals": true,
            "reduceMargin": true,
            "sandbox": true,
            "setLeverage": true,
            "setMarginMode": true,
            "setPositionMode": false,
            "transfer": true,
        },
        "timeframes": map[string]interface{} {
            "1m": "1",
            "5m": "5",
            "15m": "15",
            "30m": "30",
            "1h": "60",
            "2h": "120",
            "4h": "240",
            "6h": "360",
            "12h": "720",
            "1d": "1d",
            "1w": "1w",
            "1M": "1m",
        },
        "version": "v2",
        "urls": map[string]interface{} {
            "logo": "https://github.com/user-attachments/assets/55bab6b9-d4ca-42a8-a0e6-fac81ae557f1",
            "api": map[string]interface{} {
                "rest": "https://ascendex.com",
            },
            "test": map[string]interface{} {
                "rest": "https://api-test.ascendex-sandbox.com",
            },
            "www": "https://ascendex.com",
            "doc": []interface{}{"https://ascendex.github.io/ascendex-pro-api/#ascendex-pro-api-documentation"},
            "fees": "https://ascendex.com/en/feerate/transactionfee-traderate",
            "referral": map[string]interface{} {
                "url": "https://ascendex.com/en-us/register?inviteCode=EL6BXBQM",
                "discount": 0.25,
            },
        },
        "api": map[string]interface{} {
            "v1": map[string]interface{} {
                "public": map[string]interface{} {
                    "get": map[string]interface{} {
                        "assets": 1,
                        "products": 1,
                        "ticker": 1,
                        "barhist/info": 1,
                        "barhist": 1,
                        "depth": 1,
                        "trades": 1,
                        "cash/assets": 1,
                        "cash/products": 1,
                        "margin/assets": 1,
                        "margin/products": 1,
                        "futures/collateral": 1,
                        "futures/contracts": 1,
                        "futures/ref-px": 1,
                        "futures/market-data": 1,
                        "futures/funding-rates": 1,
                        "risk-limit-info": 1,
                        "exchange-info": 1,
                    },
                },
                "private": map[string]interface{} {
                    "get": map[string]interface{} {
                        "info": 1,
                        "wallet/transactions": 1,
                        "wallet/deposit/address": 1,
                        "data/balance/snapshot": 1,
                        "data/balance/history": 1,
                    },
                    "accountCategory": map[string]interface{} {
                        "get": map[string]interface{} {
                            "balance": 1,
                            "order/open": 1,
                            "order/status": 1,
                            "order/hist/current": 1,
                            "risk": 1,
                        },
                        "post": map[string]interface{} {
                            "order": 1,
                            "order/batch": 1,
                        },
                        "delete": map[string]interface{} {
                            "order": 1,
                            "order/all": 1,
                            "order/batch": 1,
                        },
                    },
                    "accountGroup": map[string]interface{} {
                        "get": map[string]interface{} {
                            "cash/balance": 1,
                            "margin/balance": 1,
                            "margin/risk": 1,
                            "futures/collateral-balance": 1,
                            "futures/position": 1,
                            "futures/risk": 1,
                            "futures/funding-payments": 1,
                            "order/hist": 1,
                            "spot/fee": 1,
                        },
                        "post": map[string]interface{} {
                            "transfer": 1,
                            "futures/transfer/deposit": 1,
                            "futures/transfer/withdraw": 1,
                        },
                    },
                },
            },
            "v2": map[string]interface{} {
                "public": map[string]interface{} {
                    "get": map[string]interface{} {
                        "assets": 1,
                        "futures/contract": 1,
                        "futures/collateral": 1,
                        "futures/pricing-data": 1,
                        "futures/ticker": 1,
                        "risk-limit-info": 1,
                    },
                },
                "private": map[string]interface{} {
                    "data": map[string]interface{} {
                        "get": map[string]interface{} {
                            "order/hist": 1,
                        },
                    },
                    "get": map[string]interface{} {
                        "account/info": 1,
                    },
                    "accountGroup": map[string]interface{} {
                        "get": map[string]interface{} {
                            "order/hist": 1,
                            "futures/position": 1,
                            "futures/free-margin": 1,
                            "futures/order/hist/current": 1,
                            "futures/funding-payments": 1,
                            "futures/order/open": 1,
                            "futures/order/status": 1,
                        },
                        "post": map[string]interface{} {
                            "futures/isolated-position-margin": 1,
                            "futures/margin-type": 1,
                            "futures/leverage": 1,
                            "futures/transfer/deposit": 1,
                            "futures/transfer/withdraw": 1,
                            "futures/order": 1,
                            "futures/order/batch": 1,
                            "futures/order/open": 1,
                            "subuser/subuser-transfer": 1,
                            "subuser/subuser-transfer-hist": 1,
                        },
                        "delete": map[string]interface{} {
                            "futures/order": 1,
                            "futures/order/batch": 1,
                            "futures/order/all": 1,
                        },
                    },
                },
            },
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "feeSide": "get",
                "tierBased": true,
                "percentage": true,
                "taker": this.ParseNumber("0.002"),
                "maker": this.ParseNumber("0.002"),
            },
        },
        "precisionMode": TICK_SIZE,
        "options": map[string]interface{} {
            "account-category": "cash",
            "account-group": nil,
            "fetchClosedOrders": map[string]interface{} {
                "method": "v2PrivateDataGetOrderHist",
            },
            "defaultType": "spot",
            "accountsByType": map[string]interface{} {
                "spot": "cash",
                "swap": "futures",
                "margin": "margin",
            },
            "transfer": map[string]interface{} {
                "fillResponseFromRequest": true,
            },
            "networks": map[string]interface{} {
                "BSC": Add("BEP20 ", "(BSC)"),
                "ARB": "arbitrum",
                "SOL": "Solana",
                "AVAX": "avalanche C chain",
                "OMNI": "Omni",
                "TRC20": "TRC20",
                "ERC20": "ERC20",
                "GO20": "GO20",
                "BEP2": "BEP2",
                "BTC": "Bitcoin",
                "BCH": "Bitcoin ABC",
                "LTC": "Litecoin",
                "MATIC": "Matic Network",
                "AKT": "Akash",
            },
        },
        "features": map[string]interface{} {
            "default": map[string]interface{} {
                "sandbox": true,
                "createOrder": map[string]interface{} {
                    "marginMode": true,
                    "triggerPrice": true,
                    "triggerPriceType": nil,
                    "triggerDirection": false,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": true,
                        "FOK": true,
                        "PO": true,
                        "GTD": false,
                    },
                    "hedged": false,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyRequiresPrice": false,
                    "marketBuyByCost": false,
                    "selfTradePrevention": false,
                    "iceberg": false,
                },
                "createOrders": map[string]interface{} {
                    "max": 10,
                },
                "fetchMyTrades": nil,
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "marketType": true,
                    "symbolRequired": false,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": nil,
                    "trigger": false,
                    "trailing": false,
                    "marketType": true,
                    "symbolRequired": false,
                },
                "fetchOrders": nil,
                "fetchClosedOrders": nil,
                "fetchOHLCV": map[string]interface{} {
                    "limit": 500,
                },
            },
            "spot": map[string]interface{} {
                "extends": "default",
                "fetchClosedOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 1000,
                    "daysBack": 100000,
                    "daysBackCanceled": 1,
                    "untilDays": 100000,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
            },
            "forDerivatives": map[string]interface{} {
                "extends": "default",
                "createOrder": map[string]interface{} {
                    "attachedStopLossTakeProfit": map[string]interface{} {
                        "triggerPriceType": map[string]interface{} {
                            "last": true,
                            "mark": false,
                            "index": false,
                        },
                        "price": false,
                    },
                },
                "fetchClosedOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 1000,
                    "daysBack": nil,
                    "daysBackCanceled": nil,
                    "untilDays": nil,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
            },
            "swap": map[string]interface{} {
                "linear": map[string]interface{} {
                    "extends": "forDerivatives",
                },
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "1900": BadRequest,
                "2100": AuthenticationError,
                "5002": BadSymbol,
                "6001": BadSymbol,
                "6010": InsufficientFunds,
                "60060": InvalidOrder,
                "600503": InvalidOrder,
                "100001": BadRequest,
                "100002": BadRequest,
                "100003": BadRequest,
                "100004": BadRequest,
                "100005": BadRequest,
                "100006": BadRequest,
                "100007": BadRequest,
                "100008": BadSymbol,
                "100009": AuthenticationError,
                "100010": BadRequest,
                "100011": BadRequest,
                "100012": BadRequest,
                "100013": BadRequest,
                "100101": ExchangeError,
                "150001": BadRequest,
                "200001": AuthenticationError,
                "200002": ExchangeError,
                "200003": ExchangeError,
                "200004": ExchangeError,
                "200005": ExchangeError,
                "200006": ExchangeError,
                "200007": ExchangeError,
                "200008": ExchangeError,
                "200009": ExchangeError,
                "200010": AuthenticationError,
                "200011": ExchangeError,
                "200012": ExchangeError,
                "200013": ExchangeError,
                "200014": PermissionDenied,
                "200015": PermissionDenied,
                "300001": InvalidOrder,
                "300002": InvalidOrder,
                "300003": InvalidOrder,
                "300004": InvalidOrder,
                "300005": InvalidOrder,
                "300006": InvalidOrder,
                "300007": InvalidOrder,
                "300008": InvalidOrder,
                "300009": InvalidOrder,
                "300011": InsufficientFunds,
                "300012": BadSymbol,
                "300013": InvalidOrder,
                "300014": InvalidOrder,
                "300020": InvalidOrder,
                "300021": AccountSuspended,
                "300031": InvalidOrder,
                "310001": InsufficientFunds,
                "310002": InvalidOrder,
                "310003": InvalidOrder,
                "310004": BadSymbol,
                "310005": InvalidOrder,
                "510001": ExchangeError,
                "900001": ExchangeError,
            },
            "broad": map[string]interface{} {},
        },
        "commonCurrencies": map[string]interface{} {
            "BOND": "BONDED",
            "BTCBEAR": "BEAR",
            "BTCBULL": "BULL",
            "BYN": "BeyondFi",
            "PLN": "Pollen",
        },
    })
}
func  (this *ascendex) GetAccount(optionalArgs ...interface{}) interface{}  {
    // get current or provided bitmax sub-account
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    var account interface{} = this.SafeValue(params, "account", GetValue(this.Options, "account"))
    var lowercaseAccount interface{} = ToLower(account)
    return this.Capitalize(lowercaseAccount)
}
/**
 * @method
 * @name ascendex#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func  (this *ascendex) FetchCurrencies(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var assetsPromise interface{} = this.V1PublicGetAssets(params)
            //
            //     {
            //         "code":0,
            //         "data":[
            //             {
            //                 "assetCode" : "LTCBULL",
            //                 "assetName" : "3X Long LTC Token",
            //                 "precisionScale" : 9,
            //                 "nativeScale" : 4,
            //                 "withdrawalFee" : "0.2",
            //                 "minWithdrawalAmt" : "1.0",
            //                 "status" : "Normal"
            //             },
            //         ]
            //     }
            //
            var marginPromise interface{} = this.V1PublicGetMarginAssets(params)
            //
            //     {
            //         "code":0,
            //         "data":[
            //             {
            //                 "assetCode":"BTT",
            //                 "borrowAssetCode":"BTT-B",
            //                 "interestAssetCode":"BTT-I",
            //                 "nativeScale":0,
            //                 "numConfirmations":1,
            //                 "withdrawFee":"100.0",
            //                 "minWithdrawalAmt":"1000.0",
            //                 "statusCode":"Normal",
            //                 "statusMessage":"",
            //                 "interestRate":"0.001"
            //             }
            //         ]
            //     }
            //
            var cashPromise interface{} = this.V1PublicGetCashAssets(params)
            //
            //     {
            //         "code":0,
            //         "data":[
            //             {
            //                 "assetCode":"LTCBULL",
            //                 "nativeScale":4,
            //                 "numConfirmations":20,
            //                 "withdrawFee":"0.2",
            //                 "minWithdrawalAmt":"1.0",
            //                 "statusCode":"Normal",
            //                 "statusMessage":""
            //             }
            //         ]
            //     }
            //
            assetsmargincashVariable := (<-promiseAll([]interface{}{assetsPromise, marginPromise, cashPromise}));
            assets := GetValue(assetsmargincashVariable,0);
            margin := GetValue(assetsmargincashVariable,1);
            cash := GetValue(assetsmargincashVariable,2)
            var assetsData interface{} = this.SafeList(assets, "data", []interface{}{})
            var marginData interface{} = this.SafeList(margin, "data", []interface{}{})
            var cashData interface{} = this.SafeList(cash, "data", []interface{}{})
            var assetsById interface{} = this.IndexBy(assetsData, "assetCode")
            var marginById interface{} = this.IndexBy(marginData, "assetCode")
            var cashById interface{} = this.IndexBy(cashData, "assetCode")
            var dataById interface{} = this.DeepExtend(assetsById, marginById, cashById)
            var ids interface{} = ObjectKeys(dataById)
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(ids)); i++ {
                var id interface{} = GetValue(ids, i)
                var currency interface{} = GetValue(dataById, id)
                var code interface{} = this.SafeCurrencyCode(id)
                var scale interface{} = this.SafeString2(currency, "precisionScale", "nativeScale")
                var precision interface{} = this.ParseNumber(this.ParsePrecision(scale))
                var fee interface{} = this.SafeNumber2(currency, "withdrawFee", "withdrawalFee")
                var status interface{} = this.SafeString2(currency, "status", "statusCode")
                var active interface{} =         (IsEqual(status, "Normal"))
                var marginInside interface{} =         (InOp(currency, "borrowAssetCode"))
                AddElementToObject(result, code, map[string]interface{} {
            "id": id,
            "code": code,
            "info": currency,
            "type": nil,
            "margin": marginInside,
            "name": this.SafeString(currency, "assetName"),
            "active": active,
            "deposit": nil,
            "withdraw": nil,
            "fee": fee,
            "precision": precision,
            "limits": map[string]interface{} {
                "amount": map[string]interface{} {
                    "min": precision,
                    "max": nil,
                },
                "withdraw": map[string]interface{} {
                    "min": this.SafeNumber(currency, "minWithdrawalAmt"),
                    "max": nil,
                },
            },
            "networks": map[string]interface{} {},
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ascendex#fetchMarkets
 * @description retrieves data on all markets for ascendex
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *ascendex) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var productsPromise interface{} = this.V1PublicGetProducts(params)
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "symbol": "LBA/BTC",
            //                 "baseAsset": "LBA",
            //                 "quoteAsset": "BTC",
            //                 "status": "Normal",
            //                 "minNotional": "0.000625",
            //                 "maxNotional": "6.25",
            //                 "marginTradable": false,
            //                 "commissionType": "Quote",
            //                 "commissionReserveRate": "0.001",
            //                 "tickSize": "0.000000001",
            //                 "lotSize": "1"
            //             },
            //         ]
            //     }
            //
            var cashPromise interface{} = this.V1PublicGetCashProducts(params)
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "symbol": "QTUM/BTC",
            //                 "displayName": "QTUM/BTC",
            //                 "domain": "BTC",
            //                 "tradingStartTime": 1569506400000,
            //                 "collapseDecimals": "0.0001,0.000001,0.00000001",
            //                 "minQty": "0.000000001",
            //                 "maxQty": "1000000000",
            //                 "minNotional": "0.000625",
            //                 "maxNotional": "12.5",
            //                 "statusCode": "Normal",
            //                 "statusMessage": "",
            //                 "tickSize": "0.00000001",
            //                 "useTick": false,
            //                 "lotSize": "0.1",
            //                 "useLot": false,
            //                 "commissionType": "Quote",
            //                 "commissionReserveRate": "0.001",
            //                 "qtyScale": 1,
            //                 "priceScale": 8,
            //                 "notionalScale": 4
            //             }
            //         ]
            //     }
            //
            var perpetualsPromise interface{} = this.V2PublicGetFuturesContract(params)
            //
            //    {
            //        "code": 0,
            //        "data": [
            //            {
            //                "symbol": "BTC-PERP",
            //                "status": "Normal",
            //                "displayName": "BTCUSDT",
            //                "settlementAsset": "USDT",
            //                "underlying": "BTC/USDT",
            //                "tradingStartTime": 1579701600000,
            //                "priceFilter": {
            //                    "minPrice": "1",
            //                    "maxPrice": "1000000",
            //                    "tickSize": "1"
            //                },
            //                "lotSizeFilter": {
            //                    "minQty": "0.0001",
            //                    "maxQty": "1000000000",
            //                    "lotSize": "0.0001"
            //                },
            //                "commissionType": "Quote",
            //                "commissionReserveRate": "0.001",
            //                "marketOrderPriceMarkup": "0.03",
            //                "marginRequirements": [
            //                    {
            //                        "positionNotionalLowerBound": "0",
            //                        "positionNotionalUpperBound": "50000",
            //                        "initialMarginRate": "0.01",
            //                        "maintenanceMarginRate": "0.006"
            //                    },
            //                    ...
            //                ]
            //            }
            //        ]
            //    }
            //
            productscashperpetualsVariable := (<-promiseAll([]interface{}{productsPromise, cashPromise, perpetualsPromise}));
            products := GetValue(productscashperpetualsVariable,0);
            cash := GetValue(productscashperpetualsVariable,1);
            perpetuals := GetValue(productscashperpetualsVariable,2)
            var productsData interface{} = this.SafeList(products, "data", []interface{}{})
            var productsById interface{} = this.IndexBy(productsData, "symbol")
            var cashData interface{} = this.SafeList(cash, "data", []interface{}{})
            var perpetualsData interface{} = this.SafeList(perpetuals, "data", []interface{}{})
            var cashAndPerpetualsData interface{} = this.ArrayConcat(cashData, perpetualsData)
            var cashAndPerpetualsById interface{} = this.IndexBy(cashAndPerpetualsData, "symbol")
            var dataById interface{} = this.DeepExtend(productsById, cashAndPerpetualsById)
            var ids interface{} = ObjectKeys(dataById)
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(ids)); i++ {
                var id interface{} = GetValue(ids, i)
                var market interface{} = GetValue(dataById, id)
                var settleId interface{} = this.SafeString(market, "settlementAsset")
                var settle interface{} = this.SafeCurrencyCode(settleId)
                var status interface{} = this.SafeString(market, "status")
                var domain interface{} = this.SafeString(market, "domain")
                var active interface{} = false
                if IsTrue(IsTrue((IsTrue((IsEqual(status, "Normal"))) || IsTrue((IsEqual(status, "InternalTrading"))))) && IsTrue((!IsEqual(domain, "LeveragedETF")))) {
                    active = true
                }
                var spot interface{} = IsEqual(settle, nil)
                var swap interface{} =         !IsTrue(spot)
                var linear interface{} = Ternary(IsTrue(swap), true, nil)
                var minQty interface{} = this.SafeNumber(market, "minQty")
                var maxQty interface{} = this.SafeNumber(market, "maxQty")
                var minPrice interface{} = this.SafeNumber(market, "tickSize")
                var maxPrice interface{} = nil
                var underlying interface{} = this.SafeString2(market, "underlying", "symbol")
                var parts interface{} = Split(underlying, "/")
                var baseId interface{} = this.SafeString(parts, 0)
                var quoteId interface{} = this.SafeString(parts, 1)
                var base interface{} = this.SafeCurrencyCode(baseId)
                var quote interface{} = this.SafeCurrencyCode(quoteId)
                var symbol interface{} = Add(Add(base, "/"), quote)
                if IsTrue(swap) {
                    var lotSizeFilter interface{} = this.SafeDict(market, "lotSizeFilter")
                    minQty = this.SafeNumber(lotSizeFilter, "minQty")
                    maxQty = this.SafeNumber(lotSizeFilter, "maxQty")
                    var priceFilter interface{} = this.SafeDict(market, "priceFilter")
                    minPrice = this.SafeNumber(priceFilter, "minPrice")
                    maxPrice = this.SafeNumber(priceFilter, "maxPrice")
                    symbol = Add(Add(Add(Add(base, "/"), quote), ":"), settle)
                }
                var fee interface{} = this.SafeNumber(market, "commissionReserveRate")
                var marginTradable interface{} = this.SafeBool(market, "marginTradable", false)
                AppendToArray(&result,map[string]interface{} {
                    "id": id,
                    "symbol": symbol,
                    "base": base,
                    "quote": quote,
                    "settle": settle,
                    "baseId": baseId,
                    "quoteId": quoteId,
                    "settleId": settleId,
                    "type": Ternary(IsTrue(swap), "swap", "spot"),
                    "spot": spot,
                    "margin": Ternary(IsTrue(spot), marginTradable, nil),
                    "swap": swap,
                    "future": false,
                    "option": false,
                    "active": active,
                    "contract": swap,
                    "linear": linear,
                    "inverse": Ternary(IsTrue(swap), !IsTrue(linear), nil),
                    "taker": fee,
                    "maker": fee,
                    "contractSize": Ternary(IsTrue(swap), this.ParseNumber("1"), nil),
                    "expiry": nil,
                    "expiryDatetime": nil,
                    "strike": nil,
                    "optionType": nil,
                    "precision": map[string]interface{} {
                        "amount": this.SafeNumber(market, "lotSize"),
                        "price": this.SafeNumber(market, "tickSize"),
                    },
                    "limits": map[string]interface{} {
                        "leverage": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "amount": map[string]interface{} {
                            "min": minQty,
                            "max": maxQty,
                        },
                        "price": map[string]interface{} {
                            "min": minPrice,
                            "max": maxPrice,
                        },
                        "cost": map[string]interface{} {
                            "min": this.SafeNumber(market, "minNotional"),
                            "max": this.SafeNumber(market, "maxNotional"),
                        },
                    },
                    "created": this.SafeInteger(market, "tradingStartTime"),
                    "info": market,
                })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ascendex#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the ascendex server
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the ascendex server
 */
func  (this *ascendex) FetchTime(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "requestTime": this.Milliseconds(),
            }
        
            response:= (<-this.V1PublicGetExchangeInfo(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "code": 0,
            //        "data": {
            //            "requestTimeEcho": 1656560463601,
            //            "requestReceiveAt": 1656560464331,
            //            "latency": 730
            //        }
            //    }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.SafeInteger(data, "requestReceiveAt")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ascendex#fetchAccounts
 * @description fetch all the accounts associated with a profile
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/#/?id=account-structure} indexed by the account type
 */
func  (this *ascendex) FetchAccounts(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var accountGroup interface{} = this.SafeString(this.Options, "account-group")
            var response interface{} = nil
            if IsTrue(IsEqual(accountGroup, nil)) {
                
        response = (<-this.V1PrivateGetInfo(params))
                PanicOnError(response)
                //
                //     {
                //         "code":0,
                //         "data":{
                //             "email":"igor.kroitor@gmail.com",
                //             "accountGroup":8,
                //             "viewPermission":true,
                //             "tradePermission":true,
                //             "transferPermission":true,
                //             "cashAccount":["cshrHKLZCjlZ2ejqkmvIHHtPmLYqdnda"],
                //             "marginAccount":["martXoh1v1N3EMQC5FDtSj5VHso8aI2Z"],
                //             "futuresAccount":["futc9r7UmFJAyBY2rE3beA2JFxav2XFF"],
                //             "userUID":"U6491137460"
                //         }
                //     }
                //
                var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
                accountGroup = this.SafeString(data, "accountGroup")
                AddElementToObject(this.Options, "account-group", accountGroup)
            }
        
            ch <- []interface{}{map[string]interface{} {
            "id": accountGroup,
            "type": nil,
            "code": nil,
            "info": response,
        }}
            return nil
        
            }()
            return ch
        }
func  (this *ascendex) ParseBalance(response interface{}) interface{}  {
    var result interface{} = map[string]interface{} {
        "info": response,
        "timestamp": nil,
        "datetime": nil,
    }
    var balances interface{} = this.SafeList(response, "data", []interface{}{})
    for i := 0; IsLessThan(i, GetArrayLength(balances)); i++ {
        var balance interface{} = GetValue(balances, i)
        var code interface{} = this.SafeCurrencyCode(this.SafeString(balance, "asset"))
        var account interface{} = this.Account()
        AddElementToObject(account, "free", this.SafeString(balance, "availableBalance"))
        AddElementToObject(account, "total", this.SafeString(balance, "totalBalance"))
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
func  (this *ascendex) ParseMarginBalance(response interface{}) interface{}  {
    var result interface{} = map[string]interface{} {
        "info": response,
        "timestamp": nil,
        "datetime": nil,
    }
    var balances interface{} = this.SafeList(response, "data", []interface{}{})
    for i := 0; IsLessThan(i, GetArrayLength(balances)); i++ {
        var balance interface{} = GetValue(balances, i)
        var code interface{} = this.SafeCurrencyCode(this.SafeString(balance, "asset"))
        var account interface{} = this.Account()
        AddElementToObject(account, "free", this.SafeString(balance, "availableBalance"))
        AddElementToObject(account, "total", this.SafeString(balance, "totalBalance"))
        var debt interface{} = this.SafeString(balance, "borrowed")
        var interest interface{} = this.SafeString(balance, "interest")
        AddElementToObject(account, "debt", Precise.StringAdd(debt, interest))
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
func  (this *ascendex) ParseSwapBalance(response interface{}) interface{}  {
    var result interface{} = map[string]interface{} {
        "info": response,
        "timestamp": nil,
        "datetime": nil,
    }
    var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
    var collaterals interface{} = this.SafeList(data, "collaterals", []interface{}{})
    for i := 0; IsLessThan(i, GetArrayLength(collaterals)); i++ {
        var balance interface{} = GetValue(collaterals, i)
        var code interface{} = this.SafeCurrencyCode(this.SafeString(balance, "asset"))
        var account interface{} = this.Account()
        AddElementToObject(account, "total", this.SafeString(balance, "balance"))
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name ascendex#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://ascendex.github.io/ascendex-pro-api/#cash-account-balance
 * @see https://ascendex.github.io/ascendex-pro-api/#margin-account-balance
 * @see https://ascendex.github.io/ascendex-futures-pro-api-v2/#position
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.type] wallet type, 'spot', 'margin', or 'swap'
 * @param {string} [params.marginMode] 'cross' or undefined, for spot margin trading, value of 'isolated' is invalid
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *ascendex) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes9268 := (<-this.LoadMarkets())
            PanicOnError(retRes9268)
        
            retRes9278 := (<-this.LoadAccounts())
            PanicOnError(retRes9278)
            var marketType interface{} = nil
            var marginMode interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchBalance", nil, params);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            marginModeparamsVariable := this.HandleMarginModeAndParams("fetchBalance", params);
            marginMode = GetValue(marginModeparamsVariable,0);
            params = GetValue(marginModeparamsVariable,1)
            var isMargin interface{} = this.SafeBool(params, "margin", false)
            var isCross interface{} = IsEqual(marginMode, "cross")
            marketType = Ternary(IsTrue((IsTrue(isMargin) || IsTrue(isCross))), "margin", marketType)
            params = this.Omit(params, "margin")
            var accountsByType interface{} = this.SafeDict(this.Options, "accountsByType", map[string]interface{} {})
            var accountCategory interface{} = this.SafeString(accountsByType, marketType, "cash")
            var account interface{} = this.SafeDict(this.Accounts, 0, map[string]interface{} {})
            var accountGroup interface{} = this.SafeString(account, "id")
            var request interface{} = map[string]interface{} {
                "account-group": accountGroup,
            }
            if IsTrue(IsTrue((IsEqual(marginMode, "isolated"))) && IsTrue((!IsEqual(marketType, "swap")))) {
                panic(BadRequest(Add(this.Id, " does not supported isolated margin trading")))
            }
            if IsTrue(IsTrue((IsEqual(accountCategory, "cash"))) || IsTrue((IsEqual(accountCategory, "margin")))) {
                AddElementToObject(request, "account-category", accountCategory)
            }
            var response interface{} = nil
            if IsTrue(IsTrue((IsEqual(marketType, "spot"))) || IsTrue((IsEqual(marketType, "margin")))) {
                
        response = (<-this.V1PrivateAccountCategoryGetBalance(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(marketType, "swap")) {
                
        response = (<-this.V2PrivateAccountGroupGetFuturesPosition(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                panic(NotSupported(Add(Add(Add(this.Id, " fetchBalance() is not currently supported for "), marketType), " markets")))
            }
            //
            // cash
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "asset": "BCHSV",
            //                 "totalBalance": "64.298000048",
            //                 "availableBalance": "64.298000048",
            //             },
            //         ]
            //     }
            //
            // margin
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "asset": "BCHSV",
            //                 "totalBalance": "64.298000048",
            //                 "availableBalance": "64.298000048",
            //                 "borrowed": "0",
            //                 "interest": "0",
            //             },
            //         ]
            //     }
            //
            // swap
            //
            //     {
            //         "code": 0,
            //         "data": {
            //             "accountId": "fut2ODPhGiY71Pl4vtXnOZ00ssgD7QGn",
            //             "ac": "FUTURES",
            //             "collaterals": [
            //                 {"asset":"ADA","balance":"0.355803","referencePrice":"1.05095","discountFactor":"0.9"},
            //                 {"asset":"USDT","balance":"0.000014519","referencePrice":"1","discountFactor":"1"}
            //             ],
            //         }j
            //     }
            //
            if IsTrue(IsEqual(marketType, "swap")) {
        
                ch <- this.ParseSwapBalance(response)
                return nil
            } else if IsTrue(IsEqual(marketType, "margin")) {
        
                ch <- this.ParseMarginBalance(response)
                return nil
            } else {
        
                ch <- this.ParseBalance(response)
                return nil
            }
                return nil
            }()
            return ch
        }
/**
 * @method
 * @name ascendex#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *ascendex) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes10198 := (<-this.LoadMarkets())
            PanicOnError(retRes10198)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.V1PublicGetDepth(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code":0,
            //         "data":{
            //             "m":"depth-snapshot",
            //             "symbol":"BTC-PERP",
            //             "data":{
            //                 "ts":1590223998202,
            //                 "seqnum":115444921,
            //                 "asks":[
            //                     ["9207.5","18.2383"],
            //                     ["9207.75","18.8235"],
            //                     ["9208","10.7873"],
            //                 ],
            //                 "bids":[
            //                     ["9207.25","0.4009"],
            //                     ["9207","0.003"],
            //                     ["9206.5","0.003"],
            //                 ]
            //             }
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var orderbook interface{} = this.SafeDict(data, "data", map[string]interface{} {})
            var timestamp interface{} = this.SafeInteger(orderbook, "ts")
            var result interface{} = this.ParseOrderBook(orderbook, symbol, timestamp)
            AddElementToObject(result, "nonce", this.SafeInteger(orderbook, "seqnum"))
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *ascendex) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "symbol":"QTUM/BTC",
    //         "open":"0.00016537",
    //         "close":"0.00019077",
    //         "high":"0.000192",
    //         "low":"0.00016537",
    //         "volume":"846.6",
    //         "ask":["0.00018698","26.2"],
    //         "bid":["0.00018408","503.7"],
    //         "type":"spot"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = nil
    var marketId interface{} = this.SafeString(ticker, "symbol")
    var typeVar interface{} = this.SafeString(ticker, "type")
    var delimiter interface{} = Ternary(IsTrue((IsEqual(typeVar, "spot"))), "/", nil)
    var symbol interface{} = this.SafeSymbol(marketId, market, delimiter)
    var close interface{} = this.SafeString(ticker, "close")
    var bid interface{} = this.SafeList(ticker, "bid", []interface{}{})
    var ask interface{} = this.SafeList(ticker, "ask", []interface{}{})
    var open interface{} = this.SafeString(ticker, "open")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": nil,
        "high": this.SafeString(ticker, "high"),
        "low": this.SafeString(ticker, "low"),
        "bid": this.SafeString(bid, 0),
        "bidVolume": this.SafeString(bid, 1),
        "ask": this.SafeString(ask, 0),
        "askVolume": this.SafeString(ask, 1),
        "vwap": nil,
        "open": open,
        "close": close,
        "last": close,
        "previousClose": nil,
        "change": nil,
        "percentage": nil,
        "average": nil,
        "baseVolume": this.SafeString(ticker, "volume"),
        "quoteVolume": nil,
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name ascendex#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *ascendex) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes11128 := (<-this.LoadMarkets())
            PanicOnError(retRes11128)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.V1PublicGetTicker(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code":0,
            //         "data":{
            //             "symbol":"BTC-PERP", // or "BTC/USDT"
            //             "open":"9073",
            //             "close":"9185.75",
            //             "high":"9185.75",
            //             "low":"9185.75",
            //             "volume":"576.8334",
            //             "ask":["9185.75","15.5863"],
            //             "bid":["9185.5","0.003"],
            //             "type":"derivatives", // or "spot"
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseTicker(data, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ascendex#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://ascendex.github.io/ascendex-pro-api/#ticker
 * @see https://ascendex.github.io/ascendex-futures-pro-api-v2/#ticker
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *ascendex) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes11498 := (<-this.LoadMarkets())
            PanicOnError(retRes11498)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbols, nil)) {
                var symbol interface{} = this.SafeString(symbols, 0)
                market = this.Market(symbol)
                var marketIds interface{} = this.MarketIds(symbols)
                AddElementToObject(request, "symbol", Join(marketIds, ","))
            }
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchTickers", market, params);
            typeVar = GetValue(typeVarparamsVariable,0);
            params = GetValue(typeVarparamsVariable,1)
            var response interface{} = nil
            if IsTrue(IsEqual(typeVar, "spot")) {
                
        response = (<-this.V1PublicGetTicker(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.V2PublicGetFuturesTicker(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            //     {
            //         "code":0,
            //         "data": {
            //             "symbol":"QTUM/BTC",
            //             "open":"0.00016537",
            //             "close":"0.00019077",
            //             "high":"0.000192",
            //             "low":"0.00016537",
            //             "volume":"846.6",
            //             "ask":["0.00018698","26.2"],
            //             "bid":["0.00018408","503.7"],
            //             "type":"spot"
            //         }
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
            if !IsTrue(IsArray(data)) {
        
                ch <- this.ParseTickers([]interface{}{data}, symbols)
                return nil
            }
        
            ch <- this.ParseTickers(data, symbols)
            return nil
        
            }()
            return ch
        }
func  (this *ascendex) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "m":"bar",
    //         "s":"BTC/USDT",
    //         "data":{
    //             "i":"1",
    //             "ts":1590228000000,
    //             "o":"9139.59",
    //             "c":"9131.94",
    //             "h":"9139.99",
    //             "l":"9121.71",
    //             "v":"25.20648"
    //         }
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var data interface{} = this.SafeDict(ohlcv, "data", map[string]interface{} {})
    return []interface{}{this.SafeInteger(data, "ts"), this.SafeNumber(data, "o"), this.SafeNumber(data, "h"), this.SafeNumber(data, "l"), this.SafeNumber(data, "c"), this.SafeNumber(data, "v")}
}
/**
 * @method
 * @name ascendex#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest candle to fetch
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *ascendex) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes12298 := (<-this.LoadMarkets())
            PanicOnError(retRes12298)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "interval": this.SafeString(this.Timeframes, timeframe, timeframe),
            }
            // if since and limit are not specified
            // the exchange will return just 1 last candle by default
            var duration interface{} = this.ParseTimeframe(timeframe)
            var options interface{} = this.SafeDict(this.Options, "fetchOHLCV", map[string]interface{} {})
            var defaultLimit interface{} = this.SafeInteger(options, "limit", 500)
            var until interface{} = this.SafeInteger(params, "until")
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "from", since)
                if IsTrue(IsEqual(limit, nil)) {
                    limit = defaultLimit
                } else {
                    limit = mathMin(limit, defaultLimit)
                }
                var toWithLimit interface{} = this.Sum(since, Multiply(Multiply(limit, duration), 1000), 1)
                if IsTrue(!IsEqual(until, nil)) {
                    AddElementToObject(request, "to", mathMin(toWithLimit, Add(until, 1)))
                } else {
                    AddElementToObject(request, "to", toWithLimit)
                }
            } else if IsTrue(!IsEqual(until, nil)) {
                AddElementToObject(request, "to", Add(until, 1))
                if IsTrue(IsEqual(limit, nil)) {
                    limit = defaultLimit
                } else {
                    limit = mathMin(limit, defaultLimit)
                }
                AddElementToObject(request, "from", Subtract(until, (Multiply(Multiply(limit, duration), 1000))))
            } else if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "n", limit) // max 500
            }
            params = this.Omit(params, "until")
        
            response:= (<-this.V1PublicGetBarhist(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code":0,
            //         "data":[
            //             {
            //                 "m":"bar",
            //                 "s":"BTC/USDT",
            //                 "data":{
            //                     "i":"1",
            //                     "ts":1590228000000,
            //                     "o":"9139.59",
            //                     "c":"9131.94",
            //                     "h":"9139.99",
            //                     "l":"9121.71",
            //                     "v":"25.20648"
            //                 }
            //             }
            //         ]
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseOHLCVs(data, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *ascendex) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // public fetchTrades
    //
    //     {
    //         "p":"9128.5", // price
    //         "q":"0.0030", // quantity
    //         "ts":1590229002385, // timestamp
    //         "bm":false, // if true, the buyer is the market maker, we only use this field to "define the side" of a public trade
    //         "seqnum":180143985289898554
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger(trade, "ts")
    var priceString interface{} = this.SafeString2(trade, "price", "p")
    var amountString interface{} = this.SafeString(trade, "q")
    var buyerIsMaker interface{} = this.SafeBool(trade, "bm", false)
    var side interface{} = Ternary(IsTrue(buyerIsMaker), "sell", "buy")
    market = this.SafeMarket(nil, market)
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": GetValue(market, "symbol"),
        "id": nil,
        "order": nil,
        "type": nil,
        "takerOrMaker": nil,
        "side": side,
        "price": priceString,
        "amount": amountString,
        "cost": nil,
        "fee": nil,
    }, market)
}
/**
 * @method
 * @name ascendex#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://ascendex.github.io/ascendex-pro-api/#market-trades
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *ascendex) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes13388 := (<-this.LoadMarkets())
            PanicOnError(retRes13388)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "n", limit) // max 100
            }
        
            response:= (<-this.V1PublicGetTrades(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code":0,
            //         "data":{
            //             "m":"trades",
            //             "symbol":"BTC-PERP",
            //             "data":[
            //                 {"p":"9128.5","q":"0.0030","ts":1590229002385,"bm":false,"seqnum":180143985289898554},
            //                 {"p":"9129","q":"0.0030","ts":1590229002642,"bm":false,"seqnum":180143985289898587},
            //                 {"p":"9129.5","q":"0.0030","ts":1590229021306,"bm":false,"seqnum":180143985289899043}
            //             ]
            //         }
            //     }
            //
            var records interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var trades interface{} = this.SafeList(records, "data", []interface{}{})
        
            ch <- this.ParseTrades(trades, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *ascendex) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "PendingNew": "open",
        "New": "open",
        "PartiallyFilled": "open",
        "Filled": "closed",
        "Canceled": "canceled",
        "Rejected": "rejected",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *ascendex) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // createOrder
    //
    //     {
    //         "id": "16e607e2b83a8bXHbAwwoqDo55c166fa",
    //         "orderId": "16e85b4d9b9a8bXHbAwwoqDoc3d66830",
    //         "orderType": "Market",
    //         "symbol": "BTC/USDT",
    //         "timestamp": 1573576916201
    //     }
    //
    //     {
    //         "ac": "FUTURES",
    //         "accountId": "fut2ODPhGiY71Pl4vtXnOZ00ssgD7QGn",
    //         "time": 1640819389454,
    //         "orderId": "a17e0874ecbdU0711043490bbtcpDU5X",
    //         "seqNum": -1,
    //         "orderType": "Limit",
    //         "execInst": "NULL_VAL",
    //         "side": "Buy",
    //         "symbol": "BTC-PERP",
    //         "price": "30000",
    //         "orderQty": "0.002",
    //         "stopPrice": "0",
    //         "stopBy": "ref-px",
    //         "status": "Ack",
    //         "lastExecTime": 1640819389454,
    //         "lastQty": "0",
    //         "lastPx": "0",
    //         "avgFilledPx": "0",
    //         "cumFilledQty": "0",
    //         "fee": "0",
    //         "cumFee": "0",
    //         "feeAsset": "",
    //         "errorCode": "",
    //         "posStopLossPrice": "0",
    //         "posStopLossTrigger": "market",
    //         "posTakeProfitPrice": "0",
    //         "posTakeProfitTrigger": "market",
    //         "liquidityInd": "n"
    //      }
    //
    // fetchOrder, fetchOpenOrders, fetchClosedOrders
    //
    //     {
    //         "symbol":       "BTC/USDT",
    //         "price":        "8131.22",
    //         "orderQty":     "0.00082",
    //         "orderType":    "Market",
    //         "avgPx":        "7392.02",
    //         "cumFee":       "0.005152238",
    //         "cumFilledQty": "0.00082",
    //         "errorCode":    "",
    //         "feeAsset":     "USDT",
    //         "lastExecTime": 1575953151764,
    //         "orderId":      "a16eee20b6750866943712zWEDdAjt3",
    //         "seqNum":       2623469,
    //         "side":         "Buy",
    //         "status":       "Filled",
    //         "stopPrice":    "",
    //         "execInst":     "NULL_VAL" // "Post" (for postOnly orders), "reduceOnly" (for reduceOnly orders)
    //     }
    //
    //     {
    //         "orderId": "a173ad938fc3U22666567717788c3b66",   // orderId
    //         "seqNum": 18777366360,                           // sequence number
    //         "accountId": "cshwSjbpPjSwHmxPdz2CPQVU9mnbzPpt", // accountId
    //         "symbol": "BTC/USDT",                            // symbol
    //         "orderType": "Limit",                            // order type (Limit/Market/StopMarket/StopLimit)
    //         "side": "Sell",                                  // order side (Buy/Sell)
    //         "price": "11346.77",                             // order price
    //         "stopPrice": "0",                                // stop price (0 by default)
    //         "orderQty": "0.01",                              // order quantity (in base asset)
    //         "status": "Canceled",                            // order status (Filled/Canceled/Rejected)
    //         "createTime": 1596344995793,                     // order creation time
    //         "lastExecTime": 1596344996053,                   // last execution time
    //         "avgFillPrice": "11346.77",                      // average filled price
    //         "fillQty": "0.01",                               // filled quantity (in base asset)
    //         "fee": "-0.004992579",                           // cummulative fee. if negative, this value is the commission charged; if possitive, this value is the rebate received.
    //         "feeAsset": "USDT"                               // fee asset
    //     }
    //
    //     {
    //         "ac": "FUTURES",
    //         "accountId": "testabcdefg",
    //         "avgPx": "0",
    //         "cumFee": "0",
    //         "cumQty": "0",
    //         "errorCode": "NULL_VAL",
    //         "execInst": "NULL_VAL",
    //         "feeAsset": "USDT",
    //         "lastExecTime": 1584072844085,
    //         "orderId": "r170d21956dd5450276356bbtcpKa74",
    //         "orderQty": "1.1499",
    //         "orderType": "Limit",
    //         "price": "4000",
    //         "sendingTime": 1584072841033,
    //         "seqNum": 24105338,
    //         "side": "Buy",
    //         "status": "Canceled",
    //         "stopPrice": "",
    //         "symbol": "BTC-PERP"
    //     },
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var status interface{} = this.ParseOrderStatus(this.SafeString(order, "status"))
    var marketId interface{} = this.SafeString(order, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId, market, "/")
    var timestamp interface{} = this.SafeInteger2(order, "timestamp", "sendingTime")
    var lastTradeTimestamp interface{} = this.SafeInteger(order, "lastExecTime")
    if IsTrue(IsEqual(timestamp, nil)) {
        timestamp = lastTradeTimestamp
    }
    var price interface{} = this.SafeString(order, "price")
    var amount interface{} = this.SafeString(order, "orderQty")
    var average interface{} = this.SafeString(order, "avgPx")
    var filled interface{} = this.SafeStringN(order, []interface{}{"cumFilledQty", "cumQty", "fillQty"})
    var id interface{} = this.SafeString(order, "orderId")
    var clientOrderId interface{} = this.SafeString(order, "id")
    if IsTrue(!IsEqual(clientOrderId, nil)) {
        if IsTrue(IsLessThan(GetLength(clientOrderId), 1)) {
            clientOrderId = nil
        }
    }
    var rawTypeLower interface{} = this.SafeStringLower(order, "orderType")
    var typeVar interface{} = rawTypeLower
    if IsTrue(!IsEqual(rawTypeLower, nil)) {
        if IsTrue(IsEqual(rawTypeLower, "stoplimit")) {
            typeVar = "limit"
        }
        if IsTrue(IsEqual(rawTypeLower, "stopmarket")) {
            typeVar = "market"
        }
    }
    var side interface{} = this.SafeStringLower(order, "side")
    var feeCost interface{} = this.SafeNumber2(order, "cumFee", "fee")
    var fee interface{} = nil
    if IsTrue(!IsEqual(feeCost, nil)) {
        var feeCurrencyId interface{} = this.SafeString(order, "feeAsset")
        var feeCurrencyCode interface{} = this.SafeCurrencyCode(feeCurrencyId)
        fee = map[string]interface{} {
            "cost": feeCost,
            "currency": feeCurrencyCode,
        }
    }
    var triggerPrice interface{} = this.OmitZero(this.SafeString(order, "stopPrice"))
    var reduceOnly interface{} = nil
    var execInst interface{} = this.SafeString(order, "execInst")
    if IsTrue(IsEqual(execInst, "reduceOnly")) {
        reduceOnly = true
    }
    var postOnly interface{} = nil
    if IsTrue(IsEqual(execInst, "Post")) {
        postOnly = true
    }
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": id,
        "clientOrderId": clientOrderId,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": lastTradeTimestamp,
        "symbol": symbol,
        "type": typeVar,
        "timeInForce": nil,
        "postOnly": postOnly,
        "reduceOnly": reduceOnly,
        "side": side,
        "price": price,
        "triggerPrice": triggerPrice,
        "amount": amount,
        "cost": nil,
        "average": average,
        "filled": filled,
        "remaining": nil,
        "status": status,
        "fee": fee,
        "trades": nil,
    }, market)
}
/**
 * @method
 * @name ascendex#fetchTradingFees
 * @description fetch the trading fees for multiple markets
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
 */
func  (this *ascendex) FetchTradingFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes15678 := (<-this.LoadMarkets())
            PanicOnError(retRes15678)
        
            retRes15688 := (<-this.LoadAccounts())
            PanicOnError(retRes15688)
            var account interface{} = this.SafeDict(this.Accounts, 0, map[string]interface{} {})
            var accountGroup interface{} = this.SafeString(account, "id")
            var request interface{} = map[string]interface{} {
                "account-group": accountGroup,
            }
        
            response:= (<-this.V1PrivateAccountGroupGetSpotFee(this.Extend(request, params)))
            PanicOnError(response)
            //
            //      {
            //         "code": "0",
            //         "data": {
            //           "domain": "spot",
            //           "userUID": "U1479576458",
            //           "vipLevel": "0",
            //           "fees": [
            //             { symbol: 'HT/USDT', fee: { taker: '0.001', maker: "0.001" } },
            //             { symbol: 'LAMB/BTC', fee: { taker: '0.002', maker: "0.002" } },
            //             { symbol: 'STOS/USDT', fee: { taker: '0.002', maker: "0.002" } },
            //             ...
            //           ]
            //         }
            //      }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var fees interface{} = this.SafeList(data, "fees", []interface{}{})
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(fees)); i++ {
                var fee interface{} = GetValue(fees, i)
                var marketId interface{} = this.SafeString(fee, "symbol")
                var symbol interface{} = this.SafeSymbol(marketId, nil, "/")
                var takerMaker interface{} = this.SafeDict(fee, "fee", map[string]interface{} {})
                AddElementToObject(result, symbol, map[string]interface{} {
            "info": fee,
            "symbol": symbol,
            "maker": this.SafeNumber(takerMaker, "maker"),
            "taker": this.SafeNumber(takerMaker, "taker"),
            "percentage": nil,
            "tierBased": nil,
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *ascendex) CreateOrderRequest(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @ignore
    * @name ascendex#createOrderRequest
    * @description helper function to build request
    * @param {string} symbol unified symbol of the market to create an order in
    * @param {string} type 'market' or 'limit'
    * @param {string} side 'buy' or 'sell'
    * @param {float} amount how much you want to trade in units of the base currency
    * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @param {string} [params.timeInForce] "GTC", "IOC", "FOK", or "PO"
    * @param {bool} [params.postOnly] true or false
    * @param {float} [params.triggerPrice] the price at which a trigger order is triggered at
    * @returns {object} request to be sent to the exchange
    */
    price := GetArg(optionalArgs, 0, nil)
    _ = price
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    var market interface{} = this.Market(symbol)
    var marginMode interface{} = nil
    var marketType interface{} = nil
    marginModeparamsVariable := this.HandleMarginModeAndParams("createOrderRequest", params);
    marginMode = GetValue(marginModeparamsVariable,0);
    params = GetValue(marginModeparamsVariable,1)
    marketTypeparamsVariable := this.HandleMarketTypeAndParams("createOrderRequest", market, params);
    marketType = GetValue(marketTypeparamsVariable,0);
    params = GetValue(marketTypeparamsVariable,1)
    var accountsByType interface{} = this.SafeDict(this.Options, "accountsByType", map[string]interface{} {})
    var accountCategory interface{} = this.SafeString(accountsByType, marketType, "cash")
    if IsTrue(!IsEqual(marginMode, nil)) {
        accountCategory = "margin"
    }
    var account interface{} = this.SafeDict(this.Accounts, 0, map[string]interface{} {})
    var accountGroup interface{} = this.SafeString(account, "id")
    var clientOrderId interface{} = this.SafeString2(params, "clientOrderId", "id")
    var request interface{} = map[string]interface{} {
        "account-group": accountGroup,
        "account-category": accountCategory,
        "symbol": GetValue(market, "id"),
        "time": this.Milliseconds(),
        "orderQty": this.AmountToPrecision(symbol, amount),
        "orderType": typeVar,
        "side": side,
    }
    var isMarketOrder interface{} =     (IsTrue((IsEqual(typeVar, "market"))) || IsTrue((IsEqual(typeVar, "stop_market"))))
    var isLimitOrder interface{} =     (IsTrue((IsEqual(typeVar, "limit"))) || IsTrue((IsEqual(typeVar, "stop_limit"))))
    var timeInForce interface{} = this.SafeString(params, "timeInForce")
    var postOnly interface{} = this.IsPostOnly(isMarketOrder, false, params)
    var reduceOnly interface{} = this.SafeBool(params, "reduceOnly", false)
    var triggerPrice interface{} = this.SafeString2(params, "triggerPrice", "stopPrice")
    if IsTrue(isLimitOrder) {
        AddElementToObject(request, "orderPrice", this.PriceToPrecision(symbol, price))
    }
    if IsTrue(IsEqual(timeInForce, "IOC")) {
        AddElementToObject(request, "timeInForce", "IOC")
    }
    if IsTrue(IsEqual(timeInForce, "FOK")) {
        AddElementToObject(request, "timeInForce", "FOK")
    }
    if IsTrue(postOnly) {
        AddElementToObject(request, "postOnly", true)
    }
    if IsTrue(!IsEqual(triggerPrice, nil)) {
        AddElementToObject(request, "stopPrice", this.PriceToPrecision(symbol, triggerPrice))
        if IsTrue(isLimitOrder) {
            AddElementToObject(request, "orderType", "stop_limit")
        } else if IsTrue(isMarketOrder) {
            AddElementToObject(request, "orderType", "stop_market")
        }
    }
    if IsTrue(!IsEqual(clientOrderId, nil)) {
        AddElementToObject(request, "id", clientOrderId)
    }
    if IsTrue(GetValue(market, "spot")) {
        if IsTrue(!IsEqual(accountCategory, nil)) {
            AddElementToObject(request, "category", accountCategory)
        }
    } else {
        AddElementToObject(request, "account-category", accountCategory)
        if IsTrue(reduceOnly) {
            AddElementToObject(request, "execInst", "ReduceOnly")
        }
        if IsTrue(postOnly) {
            AddElementToObject(request, "execInst", "Post")
        }
    }
    params = this.Omit(params, []interface{}{"reduceOnly", "triggerPrice"})
    return this.Extend(request, params)
}
/**
 * @method
 * @name ascendex#createOrder
 * @description create a trade order on the exchange
 * @see https://ascendex.github.io/ascendex-pro-api/#place-order
 * @see https://ascendex.github.io/ascendex-futures-pro-api-v2/#new-order
 * @param {string} symbol unified CCXT market symbol
 * @param {string} type "limit" or "market"
 * @param {string} side "buy" or "sell"
 * @param {float} amount the amount of currency to trade
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.timeInForce] "GTC", "IOC", "FOK", or "PO"
 * @param {bool} [params.postOnly] true or false
 * @param {float} [params.triggerPrice] the price at which a trigger order is triggered at
 * @param {object} [params.takeProfit] *takeProfit object in params* containing the triggerPrice that the attached take profit order will be triggered (perpetual swap markets only)
 * @param {float} [params.takeProfit.triggerPrice] *swap only* take profit trigger price
 * @param {object} [params.stopLoss] *stopLoss object in params* containing the triggerPrice that the attached stop loss order will be triggered (perpetual swap markets only)
 * @param {float} [params.stopLoss.triggerPrice] *swap only* stop loss trigger price
 * @returns [An order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *ascendex) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes17208 := (<-this.LoadMarkets())
            PanicOnError(retRes17208)
        
            retRes17218 := (<-this.LoadAccounts())
            PanicOnError(retRes17218)
            var market interface{} = this.Market(symbol)
            var request interface{} = this.CreateOrderRequest(symbol, typeVar, side, amount, price, params)
            var response interface{} = nil
            if IsTrue(GetValue(market, "swap")) {
                
        response = (<-this.V2PrivateAccountGroupPostFuturesOrder(request))
                PanicOnError(response)
            } else {
                
        response = (<-this.V1PrivateAccountCategoryPostOrder(request))
                PanicOnError(response)
            }
            //
            // spot
            //
            //      {
            //          "code":0,
            //          "data": {
            //              "accountId":"cshwT8RKojkT1HoaA5UdeimR2SrmHG2I",
            //              "ac":"CASH",
            //              "action":"place-order",
            //              "status":"Ack",
            //              "info": {
            //                  "symbol":"TRX/USDT",
            //                  "orderType":"StopLimit",
            //                  "timestamp":1654290662172,
            //                  "id":"",
            //                  "orderId":"a1812b6840ddU8191168955av0k6Eyhj"
            //              }
            //          }
            //      }
            //
            // swap
            //
            //      {
            //          "code":0,
            //          "data": {
            //              "meta": {
            //                  "id":"",
            //                  "action":"place-order",
            //                  "respInst":"ACK"
            //              },
            //              "order": {
            //                  "ac":"FUTURES",
            //                  "accountId":"futwT8RKojkT1HoaA5UdeimR2SrmHG2I",
            //                  "time":1654290969965,
            //                  "orderId":"a1812b6cf322U8191168955oJamfTh7b",
            //                  "seqNum":-1,
            //                  "orderType":"StopLimit",
            //                  "execInst":"NULL_VAL",
            //                  "side":"Buy",
            //                  "symbol":"TRX-PERP",
            //                  "price":"0.083",
            //                  "orderQty":"1",
            //                  "stopPrice":"0.082",
            //                  "stopBy":"ref-px",
            //                  "status":"Ack",
            //                  "lastExecTime":1654290969965,
            //                  "lastQty":"0",
            //                  "lastPx":"0",
            //                  "avgFilledPx":"0",
            //                  "cumFilledQty":"0",
            //                  "fee":"0",
            //                  "cumFee":"0",
            //                  "feeAsset":"",
            //                  "errorCode":"",
            //                  "posStopLossPrice":"0",
            //                  "posStopLossTrigger":"market",
            //                  "posTakeProfitPrice":"0",
            //                  "posTakeProfitTrigger":"market",
            //                  "liquidityInd":"n"
            //              }
            //          }
            //      }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var order interface{} = this.SafeDict2(data, "order", "info", map[string]interface{} {})
        
            ch <- this.ParseOrder(order, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ascendex#createOrders
 * @description create a list of trade orders
 * @see https://ascendex.github.io/ascendex-pro-api/#place-batch-orders
 * @see https://ascendex.github.io/ascendex-futures-pro-api-v2/#place-batch-orders
 * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.timeInForce] "GTC", "IOC", "FOK", or "PO"
 * @param {bool} [params.postOnly] true or false
 * @param {float} [params.triggerPrice] the price at which a trigger order is triggered at
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *ascendex) CreateOrders(orders interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes18128 := (<-this.LoadMarkets())
            PanicOnError(retRes18128)
        
            retRes18138 := (<-this.LoadAccounts())
            PanicOnError(retRes18138)
            var ordersRequests interface{} = []interface{}{}
            var symbol interface{} = nil
            var marginMode interface{} = nil
            for i := 0; IsLessThan(i, GetArrayLength(orders)); i++ {
                var rawOrder interface{} = GetValue(orders, i)
                var marketId interface{} = this.SafeString(rawOrder, "symbol")
                if IsTrue(IsEqual(symbol, nil)) {
                    symbol = marketId
                } else {
                    if IsTrue(!IsEqual(symbol, marketId)) {
                        panic(BadRequest(Add(this.Id, " createOrders() requires all orders to have the same symbol")))
                    }
                }
                var typeVar interface{} = this.SafeString(rawOrder, "type")
                var side interface{} = this.SafeString(rawOrder, "side")
                var amount interface{} = this.SafeNumber(rawOrder, "amount")
                var price interface{} = this.SafeNumber(rawOrder, "price")
                var orderParams interface{} = this.SafeDict(rawOrder, "params", map[string]interface{} {})
                var marginResult interface{} = this.HandleMarginModeAndParams("createOrders", orderParams)
                var currentMarginMode interface{} = GetValue(marginResult, 0)
                if IsTrue(!IsEqual(currentMarginMode, nil)) {
                    if IsTrue(IsEqual(marginMode, nil)) {
                        marginMode = currentMarginMode
                    } else {
                        if IsTrue(!IsEqual(marginMode, currentMarginMode)) {
                            panic(BadRequest(Add(this.Id, " createOrders() requires all orders to have the same margin mode (isolated or cross)")))
                        }
                    }
                }
                var orderRequest interface{} = this.CreateOrderRequest(marketId, typeVar, side, amount, price, orderParams)
                AppendToArray(&ordersRequests,orderRequest)
            }
            var market interface{} = this.Market(symbol)
            var accountsByType interface{} = this.SafeDict(this.Options, "accountsByType", map[string]interface{} {})
            var accountCategory interface{} = this.SafeString(accountsByType, GetValue(market, "type"), "cash")
            if IsTrue(!IsEqual(marginMode, nil)) {
                accountCategory = "margin"
            }
            var account interface{} = this.SafeDict(this.Accounts, 0, map[string]interface{} {})
            var accountGroup interface{} = this.SafeString(account, "id")
            var request interface{} = map[string]interface{} {}
            var response interface{} = nil
            if IsTrue(GetValue(market, "swap")) {
                panic(NotSupported(Add(this.Id, " createOrders() is not currently supported for swap markets on ascendex")))
            } else {
                AddElementToObject(request, "account-group", accountGroup)
                AddElementToObject(request, "account-category", accountCategory)
                AddElementToObject(request, "orders", ordersRequests)
                
        response = (<-this.V1PrivateAccountCategoryPostOrderBatch(request))
                PanicOnError(response)
            }
            //
            // spot
            //
            //     {
            //         "code": 0,
            //         "data": {
            //             "accountId": "cshdAKBO43TKIh2kJtq7FVVb42KIePyS",
            //             "ac": "CASH",
            //             "action": "batch-place-order",
            //             "status": "Ack",
            //             "info": [
            //                 {
            //                     "symbol": "BTC/USDT",
            //                     "orderType": "Limit",
            //                     "timestamp": 1699326589344,
            //                     "id": "",
            //                     "orderId": "a18ba7c1f6efU0711043490p3HvjjN5x"
            //                 }
            //             ]
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var info interface{} = this.SafeList(data, "info", []interface{}{})
        
            ch <- this.ParseOrders(info, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ascendex#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://ascendex.github.io/ascendex-pro-api/#query-order
 * @see https://ascendex.github.io/ascendex-futures-pro-api-v2/#query-order-by-id
 * @param {string} id the order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *ascendex) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes19078 := (<-this.LoadMarkets())
            PanicOnError(retRes19078)
        
            retRes19088 := (<-this.LoadAccounts())
            PanicOnError(retRes19088)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            typeVarqueryVariable := this.HandleMarketTypeAndParams("fetchOrder", market, params);
            typeVar := GetValue(typeVarqueryVariable,0);
            query := GetValue(typeVarqueryVariable,1)
            var accountsByType interface{} = this.SafeDict(this.Options, "accountsByType", map[string]interface{} {})
            var accountCategory interface{} = this.SafeString(accountsByType, typeVar, "cash")
            var account interface{} = this.SafeDict(this.Accounts, 0, map[string]interface{} {})
            var accountGroup interface{} = this.SafeString(account, "id")
            var request interface{} = map[string]interface{} {
                "account-group": accountGroup,
                "account-category": accountCategory,
                "orderId": id,
            }
            var response interface{} = nil
            if IsTrue(IsTrue((IsEqual(typeVar, "spot"))) || IsTrue((IsEqual(typeVar, "margin")))) {
                
        response = (<-this.V1PrivateAccountCategoryGetOrderStatus(this.Extend(request, query)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(typeVar, "swap")) {
                AddElementToObject(request, "account-category", accountCategory)
                
        response = (<-this.V2PrivateAccountGroupGetFuturesOrderStatus(this.Extend(request, query)))
                PanicOnError(response)
            } else {
                panic(NotSupported(Add(Add(Add(this.Id, " fetchOrder() is not currently supported for "), typeVar), " markets")))
            }
            //
            // AccountCategoryGetOrderStatus
            //
            //     {
            //         "code": 0,
            //         "accountCategory": "CASH",
            //         "accountId": "cshQtyfq8XLAA9kcf19h8bXHbAwwoqDo",
            //         "data": [
            //             {
            //                 "symbol":       "BTC/USDT",
            //                 "price":        "8131.22",
            //                 "orderQty":     "0.00082",
            //                 "orderType":    "Market",
            //                 "avgPx":        "7392.02",
            //                 "cumFee":       "0.005152238",
            //                 "cumFilledQty": "0.00082",
            //                 "errorCode":    "",
            //                 "feeAsset":     "USDT",
            //                 "lastExecTime": 1575953151764,
            //                 "orderId":      "a16eee20b6750866943712zWEDdAjt3",
            //                 "seqNum":       2623469,
            //                 "side":         "Buy",
            //                 "status":       "Filled",
            //                 "stopPrice":    "",
            //                 "execInst":     "NULL_VAL"
            //             }
            //         ]
            //     }
            //
            // AccountGroupGetFuturesOrderStatus
            //
            //     {
            //         "code": 0,
            //         "accountId": "fut2ODPhGiY71Pl4vtXnOZ00ssgD7QGn",
            //         "ac": "FUTURES",
            //         "data": {
            //             "ac": "FUTURES",
            //             "accountId": "fut2ODPhGiY71Pl4vtXnOZ00ssgD7QGn",
            //             "time": 1640247020217,
            //             "orderId": "r17de65747aeU0711043490bbtcp0cmt",
            //             "seqNum": 28796162908,
            //             "orderType": "Limit",
            //             "execInst": "NULL_VAL",
            //             "side": "Buy",
            //             "symbol": "BTC-PERP",
            //             "price": "30000",
            //             "orderQty": "0.0021",
            //             "stopPrice": "0",
            //             "stopBy": "market",
            //             "status": "New",
            //             "lastExecTime": 1640247020232,
            //             "lastQty": "0",
            //             "lastPx": "0",
            //             "avgFilledPx": "0",
            //             "cumFilledQty": "0",
            //             "fee": "0",
            //             "cumFee": "0",
            //             "feeAsset": "USDT",
            //             "errorCode": "",
            //             "posStopLossPrice": "0",
            //             "posStopLossTrigger": "market",
            //             "posTakeProfitPrice": "0",
            //             "posTakeProfitTrigger": "market",
            //             "liquidityInd": "n"
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseOrder(data, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ascendex#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://ascendex.github.io/ascendex-pro-api/#list-open-orders
 * @see https://ascendex.github.io/ascendex-futures-pro-api-v2/#list-open-orders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *ascendex) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes20168 := (<-this.LoadMarkets())
            PanicOnError(retRes20168)
        
            retRes20178 := (<-this.LoadAccounts())
            PanicOnError(retRes20178)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                symbol = GetValue(market, "symbol")
            }
            var account interface{} = this.SafeDict(this.Accounts, 0, map[string]interface{} {})
            var accountGroup interface{} = this.SafeString(account, "id")
            typeVarqueryVariable := this.HandleMarketTypeAndParams("fetchOpenOrders", market, params);
            typeVar := GetValue(typeVarqueryVariable,0);
            query := GetValue(typeVarqueryVariable,1)
            var accountsByType interface{} = this.SafeDict(this.Options, "accountsByType", map[string]interface{} {})
            var accountCategory interface{} = this.SafeString(accountsByType, typeVar, "cash")
            var request interface{} = map[string]interface{} {
                "account-group": accountGroup,
                "account-category": accountCategory,
            }
            var response interface{} = nil
            if IsTrue(IsTrue((IsEqual(typeVar, "spot"))) || IsTrue((IsEqual(typeVar, "margin")))) {
                
        response = (<-this.V1PrivateAccountCategoryGetOrderOpen(this.Extend(request, query)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(typeVar, "swap")) {
                AddElementToObject(request, "account-category", accountCategory)
                
        response = (<-this.V2PrivateAccountGroupGetFuturesOrderOpen(this.Extend(request, query)))
                PanicOnError(response)
            } else {
                panic(NotSupported(Add(Add(Add(this.Id, " fetchOpenOrders() is not currently supported for "), typeVar), " markets")))
            }
            //
            // AccountCategoryGetOrderOpen
            //
            //     {
            //         "ac": "CASH",
            //         "accountId": "cshQtyfq8XLAA9kcf19h8bXHbAwwoqDo",
            //         "code": 0,
            //         "data": [
            //             {
            //                 "avgPx": "0",         // Average filled price of the order
            //                 "cumFee": "0",       // cumulative fee paid for this order
            //                 "cumFilledQty": "0", // cumulative filled quantity
            //                 "errorCode": "",     // error code; could be empty
            //                 "feeAsset": "USDT",  // fee asset
            //                 "lastExecTime": 1576019723550, //  The last execution time of the order
            //                 "orderId": "s16ef21882ea0866943712034f36d83", // server provided orderId
            //                 "orderQty": "0.0083",  // order quantity
            //                 "orderType": "Limit",  // order type
            //                 "price": "7105",       // order price
            //                 "seqNum": 8193258,     // sequence number
            //                 "side": "Buy",         // order side
            //                 "status": "New",       // order status on matching engine
            //                 "stopPrice": "",       // only available for stop market and stop limit orders; otherwise empty
            //                 "symbol": "BTC/USDT",
            //                 "execInst": "NULL_VAL" // execution instruction
            //             },
            //         ]
            //     }
            //
            // AccountGroupGetFuturesOrderOpen
            //
            // {
            //     "code": 0,
            //     "data": [
            //         {
            //             "ac": "FUTURES",
            //             "accountId": "fut2ODPhGiY71Pl4vtXnOZ00ssgD7QGn",
            //             "time": 1640247020217,
            //             "orderId": "r17de65747aeU0711043490bbtcp0cmt",
            //             "seqNum": 28796162908,
            //             "orderType": "Limit",
            //             "execInst": "NULL_VAL",
            //             "side": "Buy",
            //             "symbol": "BTC-PERP",
            //             "price": "30000",
            //             "orderQty": "0.0021",
            //             "stopPrice": "0",
            //             "stopBy": "market",
            //             "status": "New",
            //             "lastExecTime": 1640247020232,
            //             "lastQty": "0",
            //             "lastPx": "0",
            //             "avgFilledPx": "0",
            //             "cumFilledQty": "0",
            //             "fee": "0",
            //             "cumFee": "0",
            //             "feeAsset": "USDT",
            //             "errorCode": "",
            //             "posStopLossPrice": "0",
            //             "posStopLossTrigger": "market",
            //             "posTakeProfitPrice": "0",
            //             "posTakeProfitTrigger": "market",
            //             "liquidityInd": "n"
            //         }
            //     ]
            // }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
            if IsTrue(IsEqual(accountCategory, "futures")) {
        
                ch <- this.ParseOrders(data, market, since, limit)
                return nil
            }
            // a workaround for https://github.com/ccxt/ccxt/issues/7187
            var orders interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
                var order interface{} = this.ParseOrder(GetValue(data, i), market)
                AppendToArray(&orders,order)
            }
        
            ch <- this.FilterBySymbolSinceLimit(orders, symbol, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ascendex#fetchClosedOrders
 * @description fetches information on multiple closed orders made by the user
 * @see https://ascendex.github.io/ascendex-pro-api/#list-history-orders-v2
 * @see https://ascendex.github.io/ascendex-futures-pro-api-v2/#list-current-history-orders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch orders for
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *ascendex) FetchClosedOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes21358 := (<-this.LoadMarkets())
            PanicOnError(retRes21358)
        
            retRes21368 := (<-this.LoadAccounts())
            PanicOnError(retRes21368)
            var account interface{} = this.SafeDict(this.Accounts, 0, map[string]interface{} {})
            var accountGroup interface{} = this.SafeString(account, "id")
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            typeVarqueryVariable := this.HandleMarketTypeAndParams("fetchClosedOrders", market, params);
            typeVar := GetValue(typeVarqueryVariable,0);
            query := GetValue(typeVarqueryVariable,1)
            var options interface{} = this.SafeDict(this.Options, "fetchClosedOrders", map[string]interface{} {})
            var defaultMethod interface{} = this.SafeString(options, "method", "v2PrivateDataGetOrderHist")
            var method interface{} = this.GetSupportedMapping(typeVar, map[string]interface{} {
                "spot": defaultMethod,
                "margin": defaultMethod,
                "swap": "v2PrivateAccountGroupGetFuturesOrderHistCurrent",
            })
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            var until interface{} = this.SafeString(params, "until")
            if IsTrue(!IsEqual(until, nil)) {
                AddElementToObject(request, "endTime", until)
            }
            var accountsByType interface{} = this.SafeDict(this.Options, "accountsByType", map[string]interface{} {})
            var accountCategory interface{} = this.SafeString(accountsByType, typeVar, "cash") // margin, futures
            var response interface{} = nil
            if IsTrue(IsEqual(method, "v1PrivateAccountCategoryGetOrderHistCurrent")) {
                AddElementToObject(request, "account-group", accountGroup)
                AddElementToObject(request, "account-category", accountCategory)
                if IsTrue(!IsEqual(limit, nil)) {
                    AddElementToObject(request, "limit", limit)
                }
                
        response = (<-this.V1PrivateAccountCategoryGetOrderHistCurrent(this.Extend(request, query)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(method, "v2PrivateDataGetOrderHist")) {
                AddElementToObject(request, "account", accountCategory)
                if IsTrue(!IsEqual(limit, nil)) {
                    AddElementToObject(request, "limit", limit)
                }
                
        response = (<-this.V2PrivateDataGetOrderHist(this.Extend(request, query)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(method, "v2PrivateAccountGroupGetFuturesOrderHistCurrent")) {
                AddElementToObject(request, "account-group", accountGroup)
                AddElementToObject(request, "account-category", accountCategory)
                if IsTrue(!IsEqual(limit, nil)) {
                    AddElementToObject(request, "pageSize", limit)
                }
                
        response = (<-this.V2PrivateAccountGroupGetFuturesOrderHistCurrent(this.Extend(request, query)))
                PanicOnError(response)
            } else {
                panic(NotSupported(Add(Add(Add(this.Id, " fetchClosedOrders() is not currently supported for "), typeVar), " markets")))
            }
            //
            // accountCategoryGetOrderHistCurrent
            //
            //     {
            //         "code":0,
            //         "accountId":"cshrHKLZCjlZ2ejqkmvIHHtPmLYqdnda",
            //         "ac":"CASH",
            //         "data":[
            //             {
            //                 "seqNum":15561826728,
            //                 "orderId":"a17294d305c0U6491137460bethu7kw9",
            //                 "symbol":"ETH/USDT",
            //                 "orderType":"Limit",
            //                 "lastExecTime":1591635618200,
            //                 "price":"200",
            //                 "orderQty":"0.1",
            //                 "side":"Buy",
            //                 "status":"Canceled",
            //                 "avgPx":"0",
            //                 "cumFilledQty":"0",
            //                 "stopPrice":"",
            //                 "errorCode":"",
            //                 "cumFee":"0",
            //                 "feeAsset":"USDT",
            //                 "execInst":"NULL_VAL"
            //             }
            //         ]
            //     }
            //
            //    {
            //        "code": 0,
            //        "data": [
            //            {
            //                "orderId"     :  "a173ad938fc3U22666567717788c3b66", // orderId
            //                "seqNum"      :  18777366360,                        // sequence number
            //                "accountId"   :  "cshwSjbpPjSwHmxPdz2CPQVU9mnbzPpt", // accountId
            //                "symbol"      :  "BTC/USDT",                         // symbol
            //                "orderType"   :  "Limit",                            // order type (Limit/Market/StopMarket/StopLimit)
            //                "side"        :  "Sell",                             // order side (Buy/Sell)
            //                "price"       :  "11346.77",                         // order price
            //                "stopPrice"   :  "0",                                // stop price (0 by default)
            //                "orderQty"    :  "0.01",                             // order quantity (in base asset)
            //                "status"      :  "Canceled",                         // order status (Filled/Canceled/Rejected)
            //                "createTime"  :  1596344995793,                      // order creation time
            //                "lastExecTime":  1596344996053,                      // last execution time
            //                "avgFillPrice":  "11346.77",                         // average filled price
            //                "fillQty"     :  "0.01",                             // filled quantity (in base asset)
            //                "fee"         :  "-0.004992579",                     // cummulative fee. if negative, this value is the commission charged; if possitive, this value is the rebate received.
            //                "feeAsset"    :  "USDT"                              // fee asset
            //            }
            //        ]
            //    }
            //
            // accountGroupGetFuturesOrderHistCurrent
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "ac": "FUTURES",
            //                 "accountId": "fut2ODPhGiY71Pl4vtXnOZ00ssgD7QGn",
            //                 "time": 1640245777002,
            //                 "orderId": "r17de6444fa6U0711043490bbtcpJ2lI",
            //                 "seqNum": 28796124902,
            //                 "orderType": "Limit",
            //                 "execInst": "NULL_VAL",
            //                 "side": "Buy",
            //                 "symbol": "BTC-PERP",
            //                 "price": "30000",
            //                 "orderQty": "0.0021",
            //                 "stopPrice": "0",
            //                 "stopBy": "market",
            //                 "status": "Canceled",
            //                 "lastExecTime": 1640246574886,
            //                 "lastQty": "0",
            //                 "lastPx": "0",
            //                 "avgFilledPx": "0",
            //                 "cumFilledQty": "0",
            //                 "fee": "0",
            //                 "cumFee": "0",
            //                 "feeAsset": "USDT",
            //                 "errorCode": "",
            //                 "posStopLossPrice": "0",
            //                 "posStopLossTrigger": "market",
            //                 "posTakeProfitPrice": "0",
            //                 "posTakeProfitTrigger": "market",
            //                 "liquidityInd": "n"
            //             }
            //         ]
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
            var isArray interface{} = IsArray(data)
            if !IsTrue(isArray) {
                data = this.SafeList(data, "data", []interface{}{})
            }
        
            ch <- this.ParseOrders(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ascendex#cancelOrder
 * @description cancels an open order
 * @see https://ascendex.github.io/ascendex-pro-api/#cancel-order
 * @see https://ascendex.github.io/ascendex-futures-pro-api-v2/#cancel-order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *ascendex) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " cancelOrder() requires a symbol argument")))
            }
        
            retRes23108 := (<-this.LoadMarkets())
            PanicOnError(retRes23108)
        
            retRes23118 := (<-this.LoadAccounts())
            PanicOnError(retRes23118)
            var market interface{} = this.Market(symbol)
            typeVarqueryVariable := this.HandleMarketTypeAndParams("cancelOrder", market, params);
            typeVar := GetValue(typeVarqueryVariable,0);
            query := GetValue(typeVarqueryVariable,1)
            var accountsByType interface{} = this.SafeDict(this.Options, "accountsByType", map[string]interface{} {})
            var accountCategory interface{} = this.SafeString(accountsByType, typeVar, "cash")
            var account interface{} = this.SafeDict(this.Accounts, 0, map[string]interface{} {})
            var accountGroup interface{} = this.SafeString(account, "id")
            var request interface{} = map[string]interface{} {
                "account-group": accountGroup,
                "account-category": accountCategory,
                "symbol": GetValue(market, "id"),
                "time": this.Milliseconds(),
                "id": "foobar",
            }
            var clientOrderId interface{} = this.SafeString2(params, "clientOrderId", "id")
            if IsTrue(IsEqual(clientOrderId, nil)) {
                AddElementToObject(request, "orderId", id)
            } else {
                AddElementToObject(request, "id", clientOrderId)
                params = this.Omit(params, []interface{}{"clientOrderId", "id"})
            }
            var response interface{} = nil
            if IsTrue(IsTrue((IsEqual(typeVar, "spot"))) || IsTrue((IsEqual(typeVar, "margin")))) {
                
        response = (<-this.V1PrivateAccountCategoryDeleteOrder(this.Extend(request, query)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(typeVar, "swap")) {
                AddElementToObject(request, "account-category", accountCategory)
                
        response = (<-this.V2PrivateAccountGroupDeleteFuturesOrder(this.Extend(request, query)))
                PanicOnError(response)
            } else {
                panic(NotSupported(Add(Add(Add(this.Id, " cancelOrder() is not currently supported for "), typeVar), " markets")))
            }
            //
            // AccountCategoryDeleteOrder
            //
            //     {
            //         "code": 0,
            //         "data": {
            //             "accountId": "cshQtyfq8XLAA9kcf19h8bXHbAwwoqDo",
            //             "ac": "CASH",
            //             "action": "cancel-order",
            //             "status": "Ack",
            //             "info": {
            //                 "id":        "wv8QGquoeamhssvQBeHOHGQCGlcBjj23",
            //                 "orderId":   "16e6198afb4s8bXHbAwwoqDo2ebc19dc",
            //                 "orderType": "", // could be empty
            //                 "symbol":    "ETH/USDT",
            //                 "timestamp":  1573594877822
            //             }
            //         }
            //     }
            //
            // AccountGroupDeleteFuturesOrder
            //
            //     {
            //         "code": 0,
            //         "data": {
            //             "meta": {
            //                 "id": "foobar",
            //                 "action": "cancel-order",
            //                 "respInst": "ACK"
            //             },
            //             "order": {
            //                 "ac": "FUTURES",
            //                 "accountId": "fut2ODPhGiY71Pl4vtXnOZ00ssgD7QGn",
            //                 "time": 1640244480476,
            //                 "orderId": "r17de63086f4U0711043490bbtcpPUF4",
            //                 "seqNum": 28795959269,
            //                 "orderType": "Limit",
            //                 "execInst": "NULL_VAL",
            //                 "side": "Buy",
            //                 "symbol": "BTC-PERP",
            //                 "price": "30000",
            //                 "orderQty": "0.0021",
            //                 "stopPrice": "0",
            //                 "stopBy": "market",
            //                 "status": "New",
            //                 "lastExecTime": 1640244480491,
            //                 "lastQty": "0",
            //                 "lastPx": "0",
            //                 "avgFilledPx": "0",
            //                 "cumFilledQty": "0",
            //                 "fee": "0",
            //                 "cumFee": "0",
            //                 "feeAsset": "BTCPC",
            //                 "errorCode": "",
            //                 "posStopLossPrice": "0",
            //                 "posStopLossTrigger": "market",
            //                 "posTakeProfitPrice": "0",
            //                 "posTakeProfitTrigger": "market",
            //                 "liquidityInd": "n"
            //             }
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var order interface{} = this.SafeDict2(data, "order", "info", map[string]interface{} {})
        
            ch <- this.ParseOrder(order, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ascendex#cancelAllOrders
 * @description cancel all open orders
 * @see https://ascendex.github.io/ascendex-pro-api/#cancel-all-orders
 * @see https://ascendex.github.io/ascendex-futures-pro-api-v2/#cancel-all-open-orders
 * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list with a single [order structure]{@link https://docs.ccxt.com/#/?id=order-structure} with the response assigned to the info property
 */
func  (this *ascendex) CancelAllOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes24208 := (<-this.LoadMarkets())
            PanicOnError(retRes24208)
        
            retRes24218 := (<-this.LoadAccounts())
            PanicOnError(retRes24218)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            typeVarqueryVariable := this.HandleMarketTypeAndParams("cancelAllOrders", market, params);
            typeVar := GetValue(typeVarqueryVariable,0);
            query := GetValue(typeVarqueryVariable,1)
            var accountsByType interface{} = this.SafeDict(this.Options, "accountsByType", map[string]interface{} {})
            var accountCategory interface{} = this.SafeString(accountsByType, typeVar, "cash")
            var account interface{} = this.SafeDict(this.Accounts, 0, map[string]interface{} {})
            var accountGroup interface{} = this.SafeString(account, "id")
            var request interface{} = map[string]interface{} {
                "account-group": accountGroup,
                "account-category": accountCategory,
                "time": this.Milliseconds(),
            }
            if IsTrue(!IsEqual(symbol, nil)) {
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            var response interface{} = nil
            if IsTrue(IsTrue((IsEqual(typeVar, "spot"))) || IsTrue((IsEqual(typeVar, "margin")))) {
                
        response = (<-this.V1PrivateAccountCategoryDeleteOrderAll(this.Extend(request, query)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(typeVar, "swap")) {
                AddElementToObject(request, "account-category", accountCategory)
                
        response = (<-this.V2PrivateAccountGroupDeleteFuturesOrderAll(this.Extend(request, query)))
                PanicOnError(response)
            } else {
                panic(NotSupported(Add(Add(Add(this.Id, " cancelAllOrders() is not currently supported for "), typeVar), " markets")))
            }
        
                //
            // AccountCategoryDeleteOrderAll
            //
            //     {
            //         "code": 0,
            //         "data": {
            //             "ac": "CASH",
            //             "accountId": "cshQtyfq8XLAA9kcf19h8bXHbAwwoqDo",
            //             "action": "cancel-all",
            //             "info": {
            //                 "id":  "2bmYvi7lyTrneMzpcJcf2D7Pe9V1P9wy",
            //                 "orderId": "",
            //                 "orderType": "NULL_VAL",
            //                 "symbol": "",
            //                 "timestamp": 1574118495462
            //             },
            //             "status": "Ack"
            //         }
            //     }
            //
            // AccountGroupDeleteFuturesOrderAll
            //
            //     {
            //         "code": 0,
            //         "data": {
            //             "ac": "FUTURES",
            //             "accountId": "fut2ODPhGiY71Pl4vtXnOZ00ssgD7QGn",
            //             "action": "cancel-all",
            //             "info": {
            //                 "symbol":"BTC-PERP"
            //             }
            //         }
            //     }
            //
        ch <- this.SafeOrder(map[string]interface{} {
                "info": response,
            })
            return nil
        
            }()
            return ch
        }
func  (this *ascendex) ParseDepositAddress(depositAddress interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "address": "0xe7c70b4e73b6b450ee46c3b5c0f5fb127ca55722",
    //         "destTag": "",
    //         "tagType": "",
    //         "tagId": "",
    //         "chainName": "ERC20",
    //         "numConfirmations": 20,
    //         "withdrawalFee": 1,
    //         "nativeScale": 4,
    //         "tips": []
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var address interface{} = this.SafeString(depositAddress, "address")
    var tagId interface{} = this.SafeString(depositAddress, "tagId")
    var tag interface{} = this.SafeString(depositAddress, tagId)
    this.CheckAddress(address)
    var code interface{} = Ternary(IsTrue((IsEqual(currency, nil))), nil, GetValue(currency, "code"))
    var chainName interface{} = this.SafeString(depositAddress, "blockchain")
    var network interface{} = this.NetworkIdToCode(chainName, code)
    return map[string]interface{} {
        "info": depositAddress,
        "currency": code,
        "network": network,
        "address": address,
        "tag": tag,
    }
}
/**
 * @method
 * @name ascendex#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account
 * @see https://ascendex.github.io/ascendex-pro-api/#query-deposit-addresses
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.network] unified network code for deposit chain
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *ascendex) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes25288 := (<-this.LoadMarkets())
            PanicOnError(retRes25288)
            var currency interface{} = this.Currency(code)
            var networkCode interface{} = this.SafeString2(params, "network", "chainName")
            var networkId interface{} = this.NetworkCodeToId(networkCode)
            params = this.Omit(params, []interface{}{"chainName"})
            var request interface{} = map[string]interface{} {
                "asset": GetValue(currency, "id"),
                "blockchain": networkId,
            }
        
            response:= (<-this.V1PrivateGetWalletDepositAddress(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code":0,
            //         "data":{
            //             "asset":"USDT",
            //             "assetName":"Tether",
            //             "address":[
            //                 {
            //                     "address":"1N22odLHXnLPCjC8kwBJPTayarr9RtPod6",
            //                     "destTag":"",
            //                     "tagType":"",
            //                     "tagId":"",
            //                     "chainName":"Omni",
            //                     "numConfirmations":3,
            //                     "withdrawalFee":4.7,
            //                     "nativeScale":4,
            //                     "tips":[]
            //                 },
            //                 {
            //                     "address":"0xe7c70b4e73b6b450ee46c3b5c0f5fb127ca55722",
            //                     "destTag":"",
            //                     "tagType":"",
            //                     "tagId":"",
            //                     "chainName":"ERC20",
            //                     "numConfirmations":20,
            //                     "withdrawalFee":1.0,
            //                     "nativeScale":4,
            //                     "tips":[]
            //                 }
            //             ]
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var addresses interface{} = this.SafeList(data, "address", []interface{}{})
            var numAddresses interface{} =     GetArrayLength(addresses)
            var address interface{} = nil
            if IsTrue(IsGreaterThan(numAddresses, 1)) {
                var addressesByChainName interface{} = this.IndexBy(addresses, "chainName")
                if IsTrue(IsEqual(networkId, nil)) {
                    var chainNames interface{} = ObjectKeys(addressesByChainName)
                    var chains interface{} = Join(chainNames, ", ")
                    panic(ArgumentsRequired(Add(Add(this.Id, " fetchDepositAddress() returned more than one address, a chainName parameter is required, one of "), chains)))
                }
                address = this.SafeDict(addressesByChainName, networkId, map[string]interface{} {})
            } else {
                // first address
                address = this.SafeDict(addresses, 0, map[string]interface{} {})
            }
            var result interface{} = this.ParseDepositAddress(address, currency)
        
            ch <- this.Extend(result, map[string]interface{} {
                "info": response,
            })
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ascendex#fetchDeposits
 * @description fetch all deposits made to an account
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *ascendex) FetchDeposits(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "txType": "deposit",
            }
        
                retRes260715 :=  (<-this.FetchTransactions(code, since, limit, this.Extend(request, params)))
                PanicOnError(retRes260715)
                ch <- retRes260715
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ascendex#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawals structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *ascendex) FetchWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "txType": "withdrawal",
            }
        
                retRes262415 :=  (<-this.FetchTransactions(code, since, limit, this.Extend(request, params)))
                PanicOnError(retRes262415)
                ch <- retRes262415
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ascendex#fetchDepositsWithdrawals
 * @description fetch history of deposits and withdrawals
 * @param {string} [code] unified currency code for the currency of the deposit/withdrawals, default is undefined
 * @param {int} [since] timestamp in ms of the earliest deposit/withdrawal, default is undefined
 * @param {int} [limit] max number of deposit/withdrawals to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *ascendex) FetchDepositsWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes26388 := (<-this.LoadMarkets())
            PanicOnError(retRes26388)
            var request interface{} = map[string]interface{} {}
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "asset", GetValue(currency, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTs", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "pageSize", limit)
            }
        
            response:= (<-this.V1PrivateGetWalletTransactions(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": 0,
            //         "data": {
            //             "data": [
            //                 {
            //                     "requestId": "wuzd1Ojsqtz4bCA3UXwtUnnJDmU8PiyB",
            //                     "time": 1591606166000,
            //                     "asset": "USDT",
            //                     "transactionType": "deposit",
            //                     "amount": "25",
            //                     "commission": "0",
            //                     "networkTransactionId": "0xbc4eabdce92f14dbcc01d799a5f8ca1f02f4a3a804b6350ea202be4d3c738fce",
            //                     "status": "pending",
            //                     "numConfirmed": 8,
            //                     "numConfirmations": 20,
            //                     "destAddress": { address: "0xe7c70b4e73b6b450ee46c3b5c0f5fb127ca55722" }
            //                 }
            //             ],
            //             "page": 1,
            //             "pageSize": 20,
            //             "hasNext": false
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var transactions interface{} = this.SafeList(data, "data", []interface{}{})
        
            ch <- this.ParseTransactions(transactions, currency, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *ascendex) ParseTransactionStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "reviewing": "pending",
        "pending": "pending",
        "confirmed": "ok",
        "rejected": "rejected",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *ascendex) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "requestId": "wuzd1Ojsqtz4bCA3UXwtUnnJDmU8PiyB",
    //         "time": 1591606166000,
    //         "asset": "USDT",
    //         "transactionType": "deposit",
    //         "amount": "25",
    //         "commission": "0",
    //         "networkTransactionId": "0xbc4eabdce92f14dbcc01d799a5f8ca1f02f4a3a804b6350ea202be4d3c738fce",
    //         "status": "pending",
    //         "numConfirmed": 8,
    //         "numConfirmations": 20,
    //         "destAddress": {
    //             "address": "0xe7c70b4e73b6b450ee46c3b5c0f5fb127ca55722",
    //             "destTag": "..." // for currencies that have it
    //         }
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var destAddress interface{} = this.SafeDict(transaction, "destAddress", map[string]interface{} {})
    var address interface{} = this.SafeString(destAddress, "address")
    var tag interface{} = this.SafeString(destAddress, "destTag")
    var timestamp interface{} = this.SafeInteger(transaction, "time")
    var currencyId interface{} = this.SafeString(transaction, "asset")
    var amountString interface{} = this.SafeString(transaction, "amount")
    var feeCostString interface{} = this.SafeString(transaction, "commission")
    amountString = Precise.StringSub(amountString, feeCostString)
    var code interface{} = this.SafeCurrencyCode(currencyId, currency)
    return map[string]interface{} {
        "info": transaction,
        "id": this.SafeString(transaction, "requestId"),
        "txid": this.SafeString(transaction, "networkTransactionId"),
        "type": this.SafeString(transaction, "transactionType"),
        "currency": code,
        "network": nil,
        "amount": this.ParseNumber(amountString),
        "status": this.ParseTransactionStatus(this.SafeString(transaction, "status")),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "address": address,
        "addressFrom": nil,
        "addressTo": address,
        "tag": tag,
        "tagFrom": nil,
        "tagTo": tag,
        "updated": nil,
        "comment": nil,
        "fee": map[string]interface{} {
            "currency": code,
            "cost": this.ParseNumber(feeCostString),
            "rate": nil,
        },
        "internal": false,
    }
}
/**
 * @method
 * @name ascendex#fetchPositions
 * @description fetch all open positions
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *ascendex) FetchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes27648 := (<-this.LoadMarkets())
            PanicOnError(retRes27648)
        
            retRes27658 := (<-this.LoadAccounts())
            PanicOnError(retRes27658)
            var account interface{} = this.SafeDict(this.Accounts, 0, map[string]interface{} {})
            var accountGroup interface{} = this.SafeString(account, "id")
            var request interface{} = map[string]interface{} {
                "account-group": accountGroup,
            }
        
            response:= (<-this.V2PrivateAccountGroupGetFuturesPosition(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": 0,
            //         "data": {
            //             "accountId": "fut2ODPhGiY71Pl4vtXnOZ00ssgD7QGn",
            //             "ac": "FUTURES",
            //             "collaterals": [
            //                 {
            //                     "asset": "USDT",
            //                     "balance": "44.570287262",
            //                     "referencePrice": "1",
            //                     "discountFactor": "1"
            //                 }
            //             ],
            //             "contracts": [
            //                 {
            //                     "symbol": "BTC-PERP",
            //                     "side": "LONG",
            //                     "position": "0.0001",
            //                     "referenceCost": "-3.12277254",
            //                     "unrealizedPnl": "-0.001700233",
            //                     "realizedPnl": "0",
            //                     "avgOpenPrice": "31209",
            //                     "marginType": "isolated",
            //                     "isolatedMargin": "1.654972977",
            //                     "leverage": "2",
            //                     "takeProfitPrice": "0",
            //                     "takeProfitTrigger": "market",
            //                     "stopLossPrice": "0",
            //                     "stopLossTrigger": "market",
            //                     "buyOpenOrderNotional": "0",
            //                     "sellOpenOrderNotional": "0",
            //                     "markPrice": "31210.723063672",
            //                     "indexPrice": "31223.148857925"
            //                 },
            //             ]
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var position interface{} = this.SafeList(data, "contracts", []interface{}{})
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(position)); i++ {
                AppendToArray(&result,this.ParsePosition(GetValue(position, i)))
            }
            symbols = this.MarketSymbols(symbols)
        
            ch <- this.FilterByArrayPositions(result, "symbol", symbols, false)
            return nil
        
            }()
            return ch
        }
func  (this *ascendex) ParsePosition(position interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "symbol": "BTC-PERP",
    //         "side": "LONG",
    //         "position": "0.0001",
    //         "referenceCost": "-3.12277254",
    //         "unrealizedPnl": "-0.001700233",
    //         "realizedPnl": "0",
    //         "avgOpenPrice": "31209",
    //         "marginType": "isolated",
    //         "isolatedMargin": "1.654972977",
    //         "leverage": "2",
    //         "takeProfitPrice": "0",
    //         "takeProfitTrigger": "market",
    //         "stopLossPrice": "0",
    //         "stopLossTrigger": "market",
    //         "buyOpenOrderNotional": "0",
    //         "sellOpenOrderNotional": "0",
    //         "markPrice": "31210.723063672",
    //         "indexPrice": "31223.148857925"
    //     },
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(position, "symbol")
    market = this.SafeMarket(marketId, market)
    var notional interface{} = this.SafeString(position, "buyOpenOrderNotional")
    if IsTrue(Precise.StringEq(notional, "0")) {
        notional = this.SafeString(position, "sellOpenOrderNotional")
    }
    var marginType interface{} = this.SafeString(position, "marginType")
    var marginMode interface{} = Ternary(IsTrue((IsEqual(marginType, "crossed"))), "cross", "isolated")
    var collateral interface{} = nil
    if IsTrue(IsEqual(marginMode, "isolated")) {
        collateral = this.SafeString(position, "isolatedMargin")
    }
    return this.SafePosition(map[string]interface{} {
        "info": position,
        "id": nil,
        "symbol": GetValue(market, "symbol"),
        "notional": this.ParseNumber(notional),
        "marginMode": marginMode,
        "liquidationPrice": nil,
        "entryPrice": this.SafeNumber(position, "avgOpenPrice"),
        "unrealizedPnl": this.SafeNumber(position, "unrealizedPnl"),
        "percentage": nil,
        "contracts": this.SafeNumber(position, "position"),
        "contractSize": this.SafeNumber(market, "contractSize"),
        "markPrice": this.SafeNumber(position, "markPrice"),
        "lastPrice": nil,
        "side": this.SafeStringLower(position, "side"),
        "hedged": nil,
        "timestamp": nil,
        "datetime": nil,
        "lastUpdateTimestamp": nil,
        "maintenanceMargin": nil,
        "maintenanceMarginPercentage": nil,
        "collateral": collateral,
        "initialMargin": nil,
        "initialMarginPercentage": nil,
        "leverage": this.SafeInteger(position, "leverage"),
        "marginRatio": nil,
        "stopLossPrice": this.SafeNumber(position, "stopLossPrice"),
        "takeProfitPrice": this.SafeNumber(position, "takeProfitPrice"),
    })
}
func  (this *ascendex) ParseFundingRate(contract interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //      {
    //          "time": 1640061364830,
    //          "symbol": "EOS-PERP",
    //          "markPrice": "3.353854865",
    //          "indexPrice": "3.3542",
    //          "openInterest": "14242",
    //          "fundingRate": "-0.000073026",
    //          "nextFundingTime": 1640073600000
    //      }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(contract, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var currentTime interface{} = this.SafeInteger(contract, "time")
    var nextFundingRate interface{} = this.SafeNumber(contract, "fundingRate")
    var nextFundingRateTimestamp interface{} = this.SafeInteger(contract, "nextFundingTime")
    return map[string]interface{} {
        "info": contract,
        "symbol": symbol,
        "markPrice": this.SafeNumber(contract, "markPrice"),
        "indexPrice": this.SafeNumber(contract, "indexPrice"),
        "interestRate": this.ParseNumber("0"),
        "estimatedSettlePrice": nil,
        "timestamp": currentTime,
        "datetime": this.Iso8601(currentTime),
        "previousFundingRate": nil,
        "nextFundingRate": nil,
        "previousFundingTimestamp": nil,
        "nextFundingTimestamp": nil,
        "previousFundingDatetime": nil,
        "nextFundingDatetime": nil,
        "fundingRate": nextFundingRate,
        "fundingTimestamp": nextFundingRateTimestamp,
        "fundingDatetime": this.Iso8601(nextFundingRateTimestamp),
        "interval": nil,
    }
}
/**
 * @method
 * @name ascendex#fetchFundingRates
 * @description fetch the funding rate for multiple markets
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [funding rates structures]{@link https://docs.ccxt.com/#/?id=funding-rates-structure}, indexe by market symbols
 */
func  (this *ascendex) FetchFundingRates(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes29358 := (<-this.LoadMarkets())
            PanicOnError(retRes29358)
            symbols = this.MarketSymbols(symbols)
        
            response:= (<-this.V2PublicGetFuturesPricingData(params))
            PanicOnError(response)
            //
            //     {
            //          "code": 0,
            //          "data": {
            //              "contracts": [
            //                  {
            //                      "time": 1640061364830,
            //                      "symbol": "EOS-PERP",
            //                      "markPrice": "3.353854865",
            //                      "indexPrice": "3.3542",
            //                      "openInterest": "14242",
            //                      "fundingRate": "-0.000073026",
            //                      "nextFundingTime": 1640073600000
            //                  },
            //              ],
            //              "collaterals": [
            //                  {
            //                      "asset": "USDTR",
            //                      "referencePrice": "1"
            //                  },
            //              ]
            //          }
            //      }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var contracts interface{} = this.SafeList(data, "contracts", []interface{}{})
        
            ch <- this.ParseFundingRates(contracts, symbols)
            return nil
        
            }()
            return ch
        }
func  (this *ascendex) ModifyMarginHelper(symbol interface{}, amount interface{}, typeVar interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes29688 := (<-this.LoadMarkets())
            PanicOnError(retRes29688)
        
            retRes29698 := (<-this.LoadAccounts())
            PanicOnError(retRes29698)
            var market interface{} = this.Market(symbol)
            var account interface{} = this.SafeDict(this.Accounts, 0, map[string]interface{} {})
            var accountGroup interface{} = this.SafeString(account, "id")
            amount = this.AmountToPrecision(symbol, amount)
            var request interface{} = map[string]interface{} {
                "account-group": accountGroup,
                "symbol": GetValue(market, "id"),
                "amount": amount,
            }
        
            response:= (<-this.V2PrivateAccountGroupPostFuturesIsolatedPositionMargin(this.Extend(request, params)))
            PanicOnError(response)
            //
            // Can only change margin for perpetual futures isolated margin positions
            //
            //     {
            //          "code": 0
            //     }
            //
            if IsTrue(IsEqual(typeVar, "reduce")) {
                amount = Precise.StringAbs(amount)
            }
        
            ch <- this.Extend(this.ParseMarginModification(response, market), map[string]interface{} {
                "amount": this.ParseNumber(amount),
                "type": typeVar,
            })
            return nil
        
            }()
            return ch
        }
func  (this *ascendex) ParseMarginModification(data interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // addMargin/reduceMargin
    //
    //     {
    //          "code": 0
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var errorCode interface{} = this.SafeString(data, "code")
    var status interface{} = Ternary(IsTrue((IsEqual(errorCode, "0"))), "ok", "failed")
    return map[string]interface{} {
        "info": data,
        "symbol": GetValue(market, "symbol"),
        "type": nil,
        "marginMode": "isolated",
        "amount": nil,
        "total": nil,
        "code": GetValue(market, "quote"),
        "status": status,
        "timestamp": nil,
        "datetime": nil,
    }
}
/**
 * @method
 * @name ascendex#reduceMargin
 * @description remove margin from a position
 * @param {string} symbol unified market symbol
 * @param {float} amount the amount of margin to remove
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=reduce-margin-structure}
 */
func  (this *ascendex) ReduceMargin(symbol interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes303015 :=  (<-this.ModifyMarginHelper(symbol, OpNeg(amount), "reduce", params))
                PanicOnError(retRes303015)
                ch <- retRes303015
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ascendex#addMargin
 * @description add margin
 * @param {string} symbol unified market symbol
 * @param {float} amount amount of margin to add
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=add-margin-structure}
 */
func  (this *ascendex) AddMargin(symbol interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes304315 :=  (<-this.ModifyMarginHelper(symbol, amount, "add", params))
                PanicOnError(retRes304315)
                ch <- retRes304315
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ascendex#setLeverage
 * @description set the level of leverage for a market
 * @see https://ascendex.github.io/ascendex-futures-pro-api-v2/#change-contract-leverage
 * @param {float} leverage the rate of leverage
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} response from the exchange
 */
func  (this *ascendex) SetLeverage(leverage interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " setLeverage() requires a symbol argument")))
            }
            if IsTrue(IsTrue((IsLessThan(leverage, 1))) || IsTrue((IsGreaterThan(leverage, 100)))) {
                panic(BadRequest(Add(this.Id, " leverage should be between 1 and 100")))
            }
        
            retRes30638 := (<-this.LoadMarkets())
            PanicOnError(retRes30638)
        
            retRes30648 := (<-this.LoadAccounts())
            PanicOnError(retRes30648)
            var market interface{} = this.Market(symbol)
            if !IsTrue(GetValue(market, "swap")) {
                panic(BadSymbol(Add(this.Id, " setLeverage() supports swap contracts only")))
            }
            var account interface{} = this.SafeDict(this.Accounts, 0, map[string]interface{} {})
            var accountGroup interface{} = this.SafeString(account, "id")
            var request interface{} = map[string]interface{} {
                "account-group": accountGroup,
                "symbol": GetValue(market, "id"),
                "leverage": leverage,
            }
        
                retRes307615 :=  (<-this.V2PrivateAccountGroupPostFuturesLeverage(this.Extend(request, params)))
                PanicOnError(retRes307615)
                ch <- retRes307615
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ascendex#setMarginMode
 * @description set margin mode to 'cross' or 'isolated'
 * @see https://ascendex.github.io/ascendex-futures-pro-api-v2/#change-margin-type
 * @param {string} marginMode 'cross' or 'isolated'
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} response from the exchange
 */
func  (this *ascendex) SetMarginMode(marginMode interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " setMarginMode() requires a symbol argument")))
            }
            marginMode = ToLower(marginMode)
            if IsTrue(IsEqual(marginMode, "cross")) {
                marginMode = "crossed"
            }
            if IsTrue(IsTrue(!IsEqual(marginMode, "isolated")) && IsTrue(!IsEqual(marginMode, "crossed"))) {
                panic(BadRequest(Add(this.Id, " setMarginMode() marginMode argument should be isolated or cross")))
            }
        
            retRes31008 := (<-this.LoadMarkets())
            PanicOnError(retRes31008)
        
            retRes31018 := (<-this.LoadAccounts())
            PanicOnError(retRes31018)
            var market interface{} = this.Market(symbol)
            var account interface{} = this.SafeDict(this.Accounts, 0, map[string]interface{} {})
            var accountGroup interface{} = this.SafeString(account, "id")
            var request interface{} = map[string]interface{} {
                "account-group": accountGroup,
                "symbol": GetValue(market, "id"),
                "marginType": marginMode,
            }
            if !IsTrue(GetValue(market, "swap")) {
                panic(BadSymbol(Add(this.Id, " setMarginMode() supports swap contracts only")))
            }
        
                retRes311315 :=  (<-this.V2PrivateAccountGroupPostFuturesMarginType(this.Extend(request, params)))
                PanicOnError(retRes311315)
                ch <- retRes311315
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ascendex#fetchLeverageTiers
 * @description retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [leverage tiers structures]{@link https://docs.ccxt.com/#/?id=leverage-tiers-structure}, indexed by market symbols
 */
func  (this *ascendex) FetchLeverageTiers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes31258 := (<-this.LoadMarkets())
            PanicOnError(retRes31258)
        
            response:= (<-this.V2PublicGetFuturesContract(params))
            PanicOnError(response)
            //
            //     {
            //         "code":0,
            //         "data":[
            //             {
            //                 "symbol":"BTC-PERP",
            //                 "status":"Normal",
            //                 "displayName":"BTCUSDT",
            //                 "settlementAsset":"USDT",
            //                 "underlying":"BTC/USDT",
            //                 "tradingStartTime":1579701600000,
            //                 "priceFilter":{"minPrice":"1","maxPrice":"1000000","tickSize":"1"},
            //                 "lotSizeFilter":{"minQty":"0.0001","maxQty":"1000000000","lotSize":"0.0001"},
            //                 "commissionType":"Quote",
            //                 "commissionReserveRate":"0.001",
            //                 "marketOrderPriceMarkup":"0.03",
            //                 "marginRequirements":[
            //                     {"positionNotionalLowerBound":"0","positionNotionalUpperBound":"50000","initialMarginRate":"0.01","maintenanceMarginRate":"0.006"},
            //                     {"positionNotionalLowerBound":"50000","positionNotionalUpperBound":"200000","initialMarginRate":"0.02","maintenanceMarginRate":"0.012"},
            //                     {"positionNotionalLowerBound":"200000","positionNotionalUpperBound":"2000000","initialMarginRate":"0.04","maintenanceMarginRate":"0.024"},
            //                     {"positionNotionalLowerBound":"2000000","positionNotionalUpperBound":"20000000","initialMarginRate":"0.1","maintenanceMarginRate":"0.06"},
            //                     {"positionNotionalLowerBound":"20000000","positionNotionalUpperBound":"40000000","initialMarginRate":"0.2","maintenanceMarginRate":"0.12"},
            //                     {"positionNotionalLowerBound":"40000000","positionNotionalUpperBound":"1000000000","initialMarginRate":"0.333333","maintenanceMarginRate":"0.2"}
            //                 ]
            //             }
            //         ]
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
            symbols = this.MarketSymbols(symbols)
        
            ch <- this.ParseLeverageTiers(data, symbols, "symbol")
            return nil
        
            }()
            return ch
        }
func  (this *ascendex) ParseMarketLeverageTiers(info interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @param {object} info Exchange market response for 1 market
    * @param {object} market CCXT market
    */
    //
    //    {
    //        "symbol":"BTC-PERP",
    //        "status":"Normal",
    //        "displayName":"BTCUSDT",
    //        "settlementAsset":"USDT",
    //        "underlying":"BTC/USDT",
    //        "tradingStartTime":1579701600000,
    //        "priceFilter":{"minPrice":"1","maxPrice":"1000000","tickSize":"1"},
    //        "lotSizeFilter":{"minQty":"0.0001","maxQty":"1000000000","lotSize":"0.0001"},
    //        "commissionType":"Quote",
    //        "commissionReserveRate":"0.001",
    //        "marketOrderPriceMarkup":"0.03",
    //        "marginRequirements":[
    //            {"positionNotionalLowerBound":"0","positionNotionalUpperBound":"50000","initialMarginRate":"0.01","maintenanceMarginRate":"0.006"},
    //            {"positionNotionalLowerBound":"50000","positionNotionalUpperBound":"200000","initialMarginRate":"0.02","maintenanceMarginRate":"0.012"},
    //            {"positionNotionalLowerBound":"200000","positionNotionalUpperBound":"2000000","initialMarginRate":"0.04","maintenanceMarginRate":"0.024"},
    //            {"positionNotionalLowerBound":"2000000","positionNotionalUpperBound":"20000000","initialMarginRate":"0.1","maintenanceMarginRate":"0.06"},
    //            {"positionNotionalLowerBound":"20000000","positionNotionalUpperBound":"40000000","initialMarginRate":"0.2","maintenanceMarginRate":"0.12"},
    //            {"positionNotionalLowerBound":"40000000","positionNotionalUpperBound":"1000000000","initialMarginRate":"0.333333","maintenanceMarginRate":"0.2"}
    //        ]
    //    }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marginRequirements interface{} = this.SafeList(info, "marginRequirements", []interface{}{})
    var marketId interface{} = this.SafeString(info, "symbol")
    market = this.SafeMarket(marketId, market)
    var tiers interface{} = []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(marginRequirements)); i++ {
        var tier interface{} = GetValue(marginRequirements, i)
        var initialMarginRate interface{} = this.SafeString(tier, "initialMarginRate")
        AppendToArray(&tiers,map[string]interface{} {
            "tier": this.Sum(i, 1),
            "symbol": this.SafeSymbol(marketId, market, nil, "contract"),
            "currency": GetValue(market, "quote"),
            "minNotional": this.SafeNumber(tier, "positionNotionalLowerBound"),
            "maxNotional": this.SafeNumber(tier, "positionNotionalUpperBound"),
            "maintenanceMarginRate": this.SafeNumber(tier, "maintenanceMarginRate"),
            "maxLeverage": this.ParseNumber(Precise.StringDiv("1", initialMarginRate)),
            "info": tier,
        })
    }
    return tiers
}
func  (this *ascendex) ParseDepositWithdrawFee(fee interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // {
    //     "assetCode":      "USDT",
    //     "assetName":      "Tether",
    //     "precisionScale":  9,
    //     "nativeScale":     4,
    //     "blockChain": [
    //         {
    //             "chainName":        "Omni",
    //             "withdrawFee":      "30.0",
    //             "allowDeposit":      true,
    //             "allowWithdraw":     true,
    //             "minDepositAmt":    "0.0",
    //             "minWithdrawal":    "50.0",
    //             "numConfirmations":  3
    //         },
    //     ]
    // }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var blockChains interface{} = this.SafeList(fee, "blockChain", []interface{}{})
    var blockChainsLength interface{} =     GetArrayLength(blockChains)
    var result interface{} = map[string]interface{} {
        "info": fee,
        "withdraw": map[string]interface{} {
            "fee": nil,
            "percentage": nil,
        },
        "deposit": map[string]interface{} {
            "fee": nil,
            "percentage": nil,
        },
        "networks": map[string]interface{} {},
    }
    for i := 0; IsLessThan(i, blockChainsLength); i++ {
        var blockChain interface{} = GetValue(blockChains, i)
        var networkId interface{} = this.SafeString(blockChain, "chainName")
        var currencyCode interface{} = this.SafeString(currency, "code")
        var networkCode interface{} = this.NetworkIdToCode(networkId, currencyCode)
        AddElementToObject(GetValue(result, "networks"), networkCode, map[string]interface{} {
    "deposit": map[string]interface{} {
        "fee": nil,
        "percentage": nil,
    },
    "withdraw": map[string]interface{} {
        "fee": this.SafeNumber(blockChain, "withdrawFee"),
        "percentage": false,
    },
})
        if IsTrue(IsEqual(blockChainsLength, 1)) {
            AddElementToObject(GetValue(result, "withdraw"), "fee", this.SafeNumber(blockChain, "withdrawFee"))
            AddElementToObject(GetValue(result, "withdraw"), "percentage", false)
        }
    }
    return result
}
/**
 * @method
 * @name ascendex#fetchDepositWithdrawFees
 * @description fetch deposit and withdraw fees
 * @see https://ascendex.github.io/ascendex-pro-api/#list-all-assets
 * @param {string[]|undefined} codes list of unified currency codes
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func  (this *ascendex) FetchDepositWithdrawFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    codes := GetArg(optionalArgs, 0, nil)
            _ = codes
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes32708 := (<-this.LoadMarkets())
            PanicOnError(retRes32708)
        
            response:= (<-this.V2PublicGetAssets(params))
            PanicOnError(response)
            var data interface{} = this.SafeList(response, "data")
        
            ch <- this.ParseDepositWithdrawFees(data, codes, "assetCode")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ascendex#transfer
 * @description transfer currency internally between wallets on the same account
 * @param {string} code unified currency codeåå
 * @param {float} amount amount to transfer
 * @param {string} fromAccount account to transfer from
 * @param {string} toAccount account to transfer to
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func  (this *ascendex) Transfer(code interface{}, amount interface{}, fromAccount interface{}, toAccount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes32888 := (<-this.LoadMarkets())
            PanicOnError(retRes32888)
        
            retRes32898 := (<-this.LoadAccounts())
            PanicOnError(retRes32898)
            var account interface{} = this.SafeDict(this.Accounts, 0, map[string]interface{} {})
            var accountGroup interface{} = this.SafeString(account, "id")
            var currency interface{} = this.Currency(code)
            var accountsByType interface{} = this.SafeDict(this.Options, "accountsByType", map[string]interface{} {})
            var fromId interface{} = this.SafeString(accountsByType, fromAccount, fromAccount)
            var toId interface{} = this.SafeString(accountsByType, toAccount, toAccount)
            if IsTrue(IsTrue(!IsEqual(fromId, "cash")) && IsTrue(!IsEqual(toId, "cash"))) {
                panic(ExchangeError(Add(this.Id, " transfer() only supports direct balance transfer between spot and swap, spot and margin")))
            }
            var request interface{} = map[string]interface{} {
                "account-group": accountGroup,
                "amount": this.CurrencyToPrecision(code, amount),
                "asset": GetValue(currency, "id"),
                "fromAccount": fromId,
                "toAccount": toId,
            }
        
            response:= (<-this.V1PrivateAccountGroupPostTransfer(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    { "code": "0" }
            //
            var transferOptions interface{} = this.SafeDict(this.Options, "transfer", map[string]interface{} {})
            var fillResponseFromRequest interface{} = this.SafeBool(transferOptions, "fillResponseFromRequest", true)
            var transfer interface{} = this.ParseTransfer(response, currency)
            if IsTrue(fillResponseFromRequest) {
                AddElementToObject(transfer, "fromAccount", fromAccount)
                AddElementToObject(transfer, "toAccount", toAccount)
                AddElementToObject(transfer, "amount", amount)
                AddElementToObject(transfer, "currency", code)
            }
        
            ch <- transfer
            return nil
        
            }()
            return ch
        }
func  (this *ascendex) ParseTransfer(transfer interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    { "code": "0" }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var status interface{} = this.SafeString(transfer, "code")
    var currencyCode interface{} = this.SafeCurrencyCode(nil, currency)
    return map[string]interface{} {
        "info": transfer,
        "id": nil,
        "timestamp": nil,
        "datetime": nil,
        "currency": currencyCode,
        "amount": nil,
        "fromAccount": nil,
        "toAccount": nil,
        "status": this.ParseTransferStatus(status),
    }
}
func  (this *ascendex) ParseTransferStatus(status interface{}) interface{}  {
    if IsTrue(IsEqual(status, "0")) {
        return "ok"
    }
    return "failed"
}
/**
 * @method
 * @name ascendex#fetchFundingHistory
 * @description fetch the history of funding payments paid and received on this account
 * @see https://ascendex.github.io/ascendex-futures-pro-api-v2/#funding-payment-history
 * @param {string} [symbol] unified market symbol
 * @param {int} [since] the earliest time in ms to fetch funding history for
 * @param {int} [limit] the maximum number of funding history structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object} a [funding history structure]{@link https://docs.ccxt.com/#/?id=funding-history-structure}
 */
func  (this *ascendex) FetchFundingHistory(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes33618 := (<-this.LoadMarkets())
            PanicOnError(retRes33618)
        
            retRes33628 := (<-this.LoadAccounts())
            PanicOnError(retRes33628)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchFundingHistory", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes336619 :=  (<-this.FetchPaginatedCallIncremental("fetchFundingHistory", symbol, since, limit, params, "page", 25))
                    PanicOnError(retRes336619)
                    ch <- retRes336619
                    return nil
            }
            var account interface{} = this.SafeDict(this.Accounts, 0, map[string]interface{} {})
            var accountGroup interface{} = this.SafeString(account, "id")
            var request interface{} = map[string]interface{} {
                "account-group": accountGroup,
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "pageSize", limit)
            }
        
            response:= (<-this.V2PrivateAccountGroupGetFuturesFundingPayments(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": 0,
            //         "data": {
            //             "data": [
            //                 {
            //                     "timestamp": 1640476800000,
            //                     "symbol": "BTC-PERP",
            //                     "paymentInUSDT": "-0.013991178",
            //                     "fundingRate": "0.000173497"
            //                 },
            //             ],
            //             "page": 1,
            //             "pageSize": 3,
            //             "hasNext": true
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var rows interface{} = this.SafeList(data, "data", []interface{}{})
        
            ch <- this.ParseIncomes(rows, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *ascendex) ParseIncome(income interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "timestamp": 1640476800000,
    //         "symbol": "BTC-PERP",
    //         "paymentInUSDT": "-0.013991178",
    //         "fundingRate": "0.000173497"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(income, "symbol")
    var timestamp interface{} = this.SafeInteger(income, "timestamp")
    return map[string]interface{} {
        "info": income,
        "symbol": this.SafeSymbol(marketId, market, "-", "swap"),
        "code": "USDT",
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "id": nil,
        "amount": this.SafeNumber(income, "paymentInUSDT"),
    }
}
/**
 * @method
 * @name ascendex#fetchMarginModes
 * @description fetches the set margin mode of the user
 * @see https://ascendex.github.io/ascendex-futures-pro-api-v2/#position
 * @param {string[]} [symbols] a list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [margin mode structures]{@link https://docs.ccxt.com/#/?id=margin-mode-structure}
 */
func  (this *ascendex) FetchMarginModes(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes34378 := (<-this.LoadMarkets())
            PanicOnError(retRes34378)
        
            retRes34388 := (<-this.LoadAccounts())
            PanicOnError(retRes34388)
            var account interface{} = this.SafeDict(this.Accounts, 0, map[string]interface{} {})
            var accountGroup interface{} = this.SafeString(account, "id")
            var request interface{} = map[string]interface{} {
                "account-group": accountGroup,
            }
        
            response:= (<-this.V2PrivateAccountGroupGetFuturesPosition(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": 0,
            //         "data": {
            //             "accountId": "fut2ODPhGiY71Pl4vtXnOZ00ssgD7QGn",
            //             "ac": "FUTURES",
            //             "collaterals": [
            //                 {
            //                     "asset": "USDT",
            //                     "balance": "44.570287262",
            //                     "referencePrice": "1",
            //                     "discountFactor": "1"
            //                 }
            //             ],
            //             "contracts": [
            //                 {
            //                     "symbol": "BTC-PERP",
            //                     "side": "LONG",
            //                     "position": "0.0001",
            //                     "referenceCost": "-3.12277254",
            //                     "unrealizedPnl": "-0.001700233",
            //                     "realizedPnl": "0",
            //                     "avgOpenPrice": "31209",
            //                     "marginType": "isolated",
            //                     "isolatedMargin": "1.654972977",
            //                     "leverage": "2",
            //                     "takeProfitPrice": "0",
            //                     "takeProfitTrigger": "market",
            //                     "stopLossPrice": "0",
            //                     "stopLossTrigger": "market",
            //                     "buyOpenOrderNotional": "0",
            //                     "sellOpenOrderNotional": "0",
            //                     "markPrice": "31210.723063672",
            //                     "indexPrice": "31223.148857925"
            //                 },
            //             ]
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var marginModes interface{} = this.SafeList(data, "contracts", []interface{}{})
        
            ch <- this.ParseMarginModes(marginModes, symbols, "symbol")
            return nil
        
            }()
            return ch
        }
func  (this *ascendex) ParseMarginMode(marginMode interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(marginMode, "symbol")
    var marginType interface{} = this.SafeString(marginMode, "marginType")
    var margin interface{} = Ternary(IsTrue((IsEqual(marginType, "crossed"))), "cross", "isolated")
    return map[string]interface{} {
        "info": marginMode,
        "symbol": this.SafeSymbol(marketId, market),
        "marginMode": margin,
    }
}
/**
 * @method
 * @name ascendex#fetchLeverages
 * @description fetch the set leverage for all contract markets
 * @see https://ascendex.github.io/ascendex-futures-pro-api-v2/#position
 * @param {string[]} [symbols] a list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [leverage structures]{@link https://docs.ccxt.com/#/?id=leverage-structure}
 */
func  (this *ascendex) FetchLeverages(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes35108 := (<-this.LoadMarkets())
            PanicOnError(retRes35108)
        
            retRes35118 := (<-this.LoadAccounts())
            PanicOnError(retRes35118)
            var account interface{} = this.SafeDict(this.Accounts, 0, map[string]interface{} {})
            var accountGroup interface{} = this.SafeString(account, "id")
            var request interface{} = map[string]interface{} {
                "account-group": accountGroup,
            }
        
            response:= (<-this.V2PrivateAccountGroupGetFuturesPosition(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": 0,
            //         "data": {
            //             "accountId": "fut2ODPhGiY71Pl4vtXnOZ00ssgD7QGn",
            //             "ac": "FUTURES",
            //             "collaterals": [
            //                 {
            //                     "asset": "USDT",
            //                     "balance": "44.570287262",
            //                     "referencePrice": "1",
            //                     "discountFactor": "1"
            //                 }
            //             ],
            //             "contracts": [
            //                 {
            //                     "symbol": "BTC-PERP",
            //                     "side": "LONG",
            //                     "position": "0.0001",
            //                     "referenceCost": "-3.12277254",
            //                     "unrealizedPnl": "-0.001700233",
            //                     "realizedPnl": "0",
            //                     "avgOpenPrice": "31209",
            //                     "marginType": "isolated",
            //                     "isolatedMargin": "1.654972977",
            //                     "leverage": "2",
            //                     "takeProfitPrice": "0",
            //                     "takeProfitTrigger": "market",
            //                     "stopLossPrice": "0",
            //                     "stopLossTrigger": "market",
            //                     "buyOpenOrderNotional": "0",
            //                     "sellOpenOrderNotional": "0",
            //                     "markPrice": "31210.723063672",
            //                     "indexPrice": "31223.148857925"
            //                 },
            //             ]
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var leverages interface{} = this.SafeList(data, "contracts", []interface{}{})
        
            ch <- this.ParseLeverages(leverages, symbols, "symbol")
            return nil
        
            }()
            return ch
        }
func  (this *ascendex) ParseLeverage(leverage interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(leverage, "symbol")
    var leverageValue interface{} = this.SafeInteger(leverage, "leverage")
    var marginType interface{} = this.SafeString(leverage, "marginType")
    var marginMode interface{} = Ternary(IsTrue((IsEqual(marginType, "crossed"))), "cross", "isolated")
    return map[string]interface{} {
        "info": leverage,
        "symbol": this.SafeSymbol(marketId, market),
        "marginMode": marginMode,
        "longLeverage": leverageValue,
        "shortLeverage": leverageValue,
    }
}
func  (this *ascendex) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var version interface{} = GetValue(api, 0)
    var access interface{} = GetValue(api, 1)
    var typeVar interface{} = this.SafeString(api, 2)
    var url interface{} = ""
    var accountCategory interface{} =     (IsEqual(typeVar, "accountCategory"))
    if IsTrue(IsTrue(accountCategory) || IsTrue((IsEqual(typeVar, "accountGroup")))) {
        url = Add(url, this.ImplodeParams("/{account-group}", params))
        params = this.Omit(params, "account-group")
    }
    var request interface{} = this.ImplodeParams(path, params)
    url = Add(url, "/api/pro/")
    if IsTrue(IsEqual(version, "v2")) {
        if IsTrue(IsEqual(typeVar, "data")) {
            request = Add(Add(Add("data/", version), "/"), request)
        } else {
            request = Add(Add(version, "/"), request)
        }
    } else {
        url = Add(url, Add(version, "/"))
    }
    if IsTrue(accountCategory) {
        url = Add(url, this.ImplodeParams("{account-category}/", params))
    }
    params = this.Omit(params, "account-category")
    url = Add(url, request)
    if IsTrue(IsTrue(IsTrue((IsEqual(version, "v1"))) && IsTrue((IsEqual(request, "cash/balance")))) || IsTrue((IsEqual(request, "margin/balance")))) {
        request = "balance"
    }
    if IsTrue(IsTrue((IsEqual(version, "v1"))) && IsTrue((IsEqual(request, "spot/fee")))) {
        request = "fee"
    }
    if IsTrue(IsGreaterThanOrEqual(GetIndexOf(request, "subuser"), 0)) {
        var parts interface{} = Split(request, "/")
        request = GetValue(parts, 2)
    }
    params = this.Omit(params, this.ExtractParams(path))
    if IsTrue(IsEqual(access, "public")) {
        if IsTrue(GetArrayLength(ObjectKeys(params))) {
            url = Add(url, Add("?", this.Urlencode(params)))
        }
    } else {
        this.CheckRequiredCredentials()
        var timestamp interface{} = ToString(this.Milliseconds())
        var payload interface{} = Add(Add(timestamp, "+"), request)
        var hmac interface{} = this.Hmac(this.Encode(payload), this.Encode(this.Secret), sha256, "base64")
        headers = map[string]interface{} {
            "x-auth-key": this.ApiKey,
            "x-auth-timestamp": timestamp,
            "x-auth-signature": hmac,
        }
        if IsTrue(IsEqual(method, "GET")) {
            if IsTrue(GetArrayLength(ObjectKeys(params))) {
                url = Add(url, Add("?", this.Urlencode(params)))
            }
        } else {
            AddElementToObject(headers, "Content-Type", "application/json")
            body = this.Json(params)
        }
    }
    url = Add(GetValue(GetValue(this.Urls, "api"), "rest"), url)
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *ascendex) HandleErrors(httpCode interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsEqual(response, nil)) {
        return nil  // fallback to default error handler
    }
    //
    //     {"code": 6010, "message": "Not enough balance."}
    //     {"code": 60060, "message": "The order is already filled or canceled."}
    //     {"code":2100,"message":"ApiKeyFailure"}
    //     {"code":300001,"message":"Price is too low from market price.","reason":"INVALID_PRICE","accountId":"cshrHKLZCjlZ2ejqkmvIHHtPmLYqdnda","ac":"CASH","action":"place-order","status":"Err","info":{"symbol":"BTC/USDT"}}
    //
    var code interface{} = this.SafeString(response, "code")
    var message interface{} = this.SafeString(response, "message")
    var error interface{} = IsTrue((!IsEqual(code, nil))) && IsTrue((!IsEqual(code, "0")))
    if IsTrue(IsTrue(error) || IsTrue((!IsEqual(message, nil)))) {
        var feedback interface{} = Add(Add(this.Id, " "), body)
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), code, feedback)
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), message, feedback)
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), message, feedback)
        panic(ExchangeError(feedback))
    }
    return nil
}


func (this *ascendex) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
