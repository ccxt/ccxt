package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type coincatch struct {
    Exchange

}

func NewCoincatchCore() coincatch {
   p := coincatch{}
   setDefaults(&p)
   return p
}

func  (this *coincatch) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "coincatch",
        "name": "CoinCatch",
        "countries": []interface{}{"VG"},
        "rateLimit": 50,
        "version": "v1",
        "certified": false,
        "pro": true,
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": false,
            "swap": true,
            "future": false,
            "option": false,
            "addMargin": true,
            "cancelAllOrders": true,
            "cancelAllOrdersAfter": false,
            "cancelOrder": true,
            "cancelOrders": true,
            "cancelWithdraw": false,
            "closePosition": false,
            "createConvertTrade": false,
            "createDepositAddress": false,
            "createLimitBuyOrder": true,
            "createLimitSellOrder": true,
            "createMarketBuyOrder": true,
            "createMarketBuyOrderWithCost": true,
            "createMarketOrder": true,
            "createMarketOrderWithCost": false,
            "createMarketSellOrder": true,
            "createMarketSellOrderWithCost": false,
            "createOrder": true,
            "createOrders": true,
            "createOrderWithTakeProfitAndStopLoss": true,
            "createPostOnlyOrder": true,
            "createReduceOnlyOrder": true,
            "createStopLimitOrder": true,
            "createStopLossOrder": true,
            "createStopMarketOrder": true,
            "createStopOrder": true,
            "createTakeProfitOrder": true,
            "createTrailingAmountOrder": false,
            "createTrailingPercentOrder": false,
            "createTriggerOrder": true,
            "fetchAccounts": false,
            "fetchBalance": true,
            "fetchCanceledAndClosedOrders": true,
            "fetchCanceledOrders": false,
            "fetchClosedOrder": false,
            "fetchClosedOrders": false,
            "fetchConvertCurrencies": false,
            "fetchConvertQuote": false,
            "fetchConvertTrade": false,
            "fetchConvertTradeHistory": false,
            "fetchCurrencies": true,
            "fetchDepositAddress": true,
            "fetchDeposits": true,
            "fetchDepositsWithdrawals": false,
            "fetchFundingHistory": false,
            "fetchFundingRate": true,
            "fetchFundingRateHistory": true,
            "fetchFundingRates": false,
            "fetchIndexOHLCV": false,
            "fetchLedger": true,
            "fetchLeverage": true,
            "fetchLeverageTiers": false,
            "fetchMarginAdjustmentHistory": false,
            "fetchMarginMode": true,
            "fetchMarkets": true,
            "fetchMarkOHLCV": true,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrder": false,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrders": false,
            "fetchOrderTrades": true,
            "fetchPosition": true,
            "fetchPositionHistory": false,
            "fetchPositionMode": true,
            "fetchPositions": true,
            "fetchPositionsForSymbol": true,
            "fetchPositionsHistory": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchStatus": false,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTime": true,
            "fetchTrades": true,
            "fetchTradingFee": false,
            "fetchTradingFees": false,
            "fetchTransactions": false,
            "fetchTransfers": false,
            "fetchWithdrawals": true,
            "reduceMargin": true,
            "sandbox": false,
            "setLeverage": true,
            "setMargin": false,
            "setMarginMode": true,
            "setPositionMode": true,
            "transfer": false,
            "withdraw": true,
        },
        "timeframes": map[string]interface{} {
            "1m": "1m",
            "3m": "3m",
            "5m": "5m",
            "15": "15m",
            "30": "30m",
            "1h": "1H",
            "2h": "2H",
            "4h": "4H",
            "6h": "6H",
            "12h": "12H",
            "1d": "1D",
            "3d": "3D",
            "1w": "1W",
            "1M": "1M",
        },
        "urls": map[string]interface{} {
            "logo": "https://github.com/user-attachments/assets/3d49065f-f05d-4573-88a2-1b5201ec6ff3",
            "api": map[string]interface{} {
                "public": "https://api.coincatch.com",
                "private": "https://api.coincatch.com",
            },
            "www": "https://www.coincatch.com/",
            "doc": "https://coincatch.github.io/github.io/en/",
            "fees": "https://www.coincatch.com/en/rate/",
            "referral": map[string]interface{} {
                "url": "https://partner.coincatch.cc/bg/92hy70391729607848548",
                "discount": 0.1,
            },
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": map[string]interface{} {
                    "api/spot/v1/public/time": 1,
                    "api/spot/v1/public/currencies": Divide(20, 3),
                    "api/spot/v1/market/ticker": 1,
                    "api/spot/v1/market/tickers": 1,
                    "api/spot/v1/market/fills": 2,
                    "api/spot/v1/market/fills-history": 2,
                    "api/spot/v1/market/candles": 1,
                    "api/spot/v1/market/history-candles": 1,
                    "api/spot/v1/market/depth": 1,
                    "api/spot/v1/market/merge-depth": 1,
                    "api/mix/v1/market/contracts": 1,
                    "api/mix/v1/market/merge-depth": 1,
                    "api/mix/v1/market/depth": 1,
                    "api/mix/v1/market/ticker": 1,
                    "api/mix/v1/market/tickers": 1,
                    "api/mix/v1/market/fills": 1,
                    "api/mix/v1/market/fills-history": 1,
                    "api/mix/v1/market/candles": 1,
                    "pi/mix/v1/market/index": 1,
                    "api/mix/v1/market/funding-time": 1,
                    "api/mix/v1/market/history-fundRate": 1,
                    "api/mix/v1/market/current-fundRate": 1,
                    "api/mix/v1/market/open-interest": 1,
                    "api/mix/v1/market/mark-price": 1,
                    "api/mix/v1/market/symbol-leverage": 1,
                    "api/mix/v1/market/queryPositionLever": 1,
                },
            },
            "private": map[string]interface{} {
                "get": map[string]interface{} {
                    "api/spot/v1/wallet/deposit-address": 4,
                    "pi/spot/v1/wallet/withdrawal-list": 1,
                    "api/spot/v1/wallet/withdrawal-list-v2": 1,
                    "api/spot/v1/wallet/deposit-list": 1,
                    "api/spot/v1/account/getInfo": 1,
                    "api/spot/v1/account/assets": 2,
                    "api/spot/v1/account/transferRecords": 1,
                    "api/mix/v1/account/account": 2,
                    "api/mix/v1/account/accounts": 2,
                    "api/mix/v1/position/singlePosition-v2": 2,
                    "api/mix/v1/position/allPosition-v2": 4,
                    "api/mix/v1/account/accountBill": 2,
                    "api/mix/v1/account/accountBusinessBill": 4,
                    "api/mix/v1/order/current": 1,
                    "api/mix/v1/order/marginCoinCurrent": 1,
                    "api/mix/v1/order/history": 2,
                    "api/mix/v1/order/historyProductType": 4,
                    "api/mix/v1/order/detail": 2,
                    "api/mix/v1/order/fills": 2,
                    "api/mix/v1/order/allFills": 2,
                    "api/mix/v1/plan/currentPlan": 1,
                    "api/mix/v1/plan/historyPlan": 2,
                },
                "post": map[string]interface{} {
                    "api/spot/v1/wallet/transfer-v2": 4,
                    "api/spot/v1/wallet/withdrawal-v2": 4,
                    "api/spot/v1/wallet/withdrawal-inner-v2": 1,
                    "api/spot/v1/account/bills": 2,
                    "api/spot/v1/trade/orders": 2,
                    "api/spot/v1/trade/batch-orders": map[string]interface{} {
                        "cost": 4,
                        "step": 10,
                    },
                    "api/spot/v1/trade/cancel-order": 1,
                    "api/spot/v1/trade/cancel-order-v2": 2,
                    "api/spot/v1/trade/cancel-symbol-order": 2,
                    "api/spot/v1/trade/cancel-batch-orders": 1,
                    "api/spot/v1/trade/cancel-batch-orders-v2": 1,
                    "api/spot/v1/trade/orderInfo": 1,
                    "api/spot/v1/trade/open-orders": 1,
                    "api/spot/v1/trade/history": 1,
                    "api/spot/v1/trade/fills": 1,
                    "api/spot/v1/plan/placePlan": 1,
                    "api/spot/v1/plan/modifyPlan": 1,
                    "api/spot/v1/plan/cancelPlan": 1,
                    "api/spot/v1/plan/currentPlan": 1,
                    "api/spot/v1/plan/historyPlan": 1,
                    "api/spot/v1/plan/batchCancelPlan": 2,
                    "api/mix/v1/account/open-count": 1,
                    "api/mix/v1/account/setLeverage": 4,
                    "api/mix/v1/account/setMargin": 4,
                    "api/mix/v1/account/setMarginMode": 4,
                    "api/mix/v1/account/setPositionMode": 4,
                    "api/mix/v1/order/placeOrder": 2,
                    "api/mix/v1/order/batch-orders": map[string]interface{} {
                        "cost": 4,
                        "step": 10,
                    },
                    "api/mix/v1/order/cancel-order": 2,
                    "api/mix/v1/order/cancel-batch-orders": 2,
                    "api/mix/v1/order/cancel-symbol-orders": 2,
                    "api/mix/v1/order/cancel-all-orders": 2,
                    "api/mix/v1/plan/placePlan": 2,
                    "api/mix/v1/plan/modifyPlan": 2,
                    "api/mix/v1/plan/modifyPlanPreset": 2,
                    "api/mix/v1/plan/placeTPSL": 2,
                    "api/mix/v1/plan/placeTrailStop": 2,
                    "api/mix/v1/plan/placePositionsTPSL": 2,
                    "api/mix/v1/plan/modifyTPSLPlan": 2,
                    "api/mix/v1/plan/cancelPlan": 2,
                    "api/mix/v1/plan/cancelSymbolPlan": 2,
                    "api/mix/v1/plan/cancelAllPlan": 2,
                },
            },
        },
        "requiredCredentials": map[string]interface{} {
            "apiKey": true,
            "secret": true,
            "password": true,
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "spot": map[string]interface{} {
                    "tierBased": false,
                    "percentage": true,
                    "feeSide": "get",
                    "maker": this.ParseNumber("0.001"),
                    "taker": this.ParseNumber("0.001"),
                },
            },
        },
        "options": map[string]interface{} {
            "brokerId": "47cfy",
            "createMarketBuyOrderRequiresPrice": true,
            "timeframes": map[string]interface{} {
                "spot": map[string]interface{} {
                    "1m": "1min",
                    "5m": "5min",
                    "15m": "15min",
                    "30m": "30min",
                    "1h": "1h",
                    "4h": "4h",
                    "6h": "6h",
                    "12h": "12h",
                    "1d": "1day",
                    "3d": "3day",
                    "1w": "1week",
                    "1M": "1M",
                },
                "swap": map[string]interface{} {
                    "1m": "1m",
                    "3m": "3m",
                    "5m": "5m",
                    "15": "15m",
                    "30": "30m",
                    "1h": "1H",
                    "2h": "2H",
                    "4h": "4H",
                    "6h": "6H",
                    "12h": "12H",
                    "1d": "1D",
                    "3d": "3D",
                    "1w": "1W",
                    "1M": "1M",
                },
            },
            "currencyIdsListForParseMarket": nil,
            "broker": "",
            "networks": map[string]interface{} {
                "BTC": "BITCOIN",
                "ERC20": "ERC20",
                "TRC20": "TRC20",
                "BEP20": "BEP20",
                "ARB": "ArbitrumOne",
                "OPTIMISM": "Optimism",
                "LTC": "LTC",
                "BCH": "BCH",
                "ETC": "ETC",
                "SOL": "SOL",
                "NEO3": "NEO3",
                "STX": "stacks",
                "EGLD": "Elrond",
                "NEAR": "NEARProtocol",
                "ACA": "AcalaToken",
                "KLAY": "Klaytn",
                "FTM": "Fantom",
                "TERRA": "Terra",
                "WAVES": "WAVES",
                "TAO": "TAO",
                "SUI": "SUI",
                "SEI": "SEI",
                "RUNE": "THORChain",
                "ZIL": "ZIL",
                "SXP": "Solar",
                "FET": "FET",
                "AVAX": "C-Chain",
                "XRP": "XRP",
                "EOS": "EOS",
                "DOGE": "DOGECOIN",
                "CAP20": "CAP20",
                "MATIC": "Polygon",
                "CSPR": "CSPR",
                "GLMR": "Moonbeam",
                "MINA": "MINA",
                "CFX": "CFX",
                "STRAT": "StratisEVM",
                "TIA": "Celestia",
                "ChilizChain": "ChilizChain",
                "APT": "Aptos",
                "ONT": "Ontology",
                "ICP": "ICP",
                "ADA": "Cardano",
                "FIL": "FIL",
                "CELO": "CELO",
                "DOT": "DOT",
                "XLM": "StellarLumens",
                "ATOM": "ATOM",
                "CRO": "CronosChain",
            },
            "networksById": map[string]interface{} {
                "BITCOIN": "BTC",
                "ERC20": "ERC20",
                "TRC20": "TRC20",
                "TRX(TRC20)": "TRC20",
                "BEP20": "BEP20",
                "ArbitrumOne": "ARB",
                "Optimism": "OPTIMISM",
                "LTC": "LTC",
                "BCH": "BCH",
                "ETC": "ETC",
                "SOL": "SOL",
                "NEO3": "NEO3",
                "stacks": "STX",
                "Elrond": "EGLD",
                "NEARProtocol": "NEAR",
                "AcalaToken": "ACA",
                "Klaytn": "KLAY",
                "Fantom": "FTM",
                "Terra": "TERRA",
                "WAVES": "WAVES",
                "TAO": "TAO",
                "SUI": "SUI",
                "SEI": "SEI",
                "THORChain": "RUNE",
                "ZIL": "ZIL",
                "Solar": "SXP",
                "FET": "FET",
                "C-Chain": "AVAX",
                "XRP": "XRP",
                "EOS": "EOS",
                "DOGECOIN": "DOGE",
                "CAP20": "CAP20",
                "Polygon": "MATIC",
                "CSPR": "CSPR",
                "Moonbeam": "GLMR",
                "MINA": "MINA",
                "CFXeSpace": "CFX",
                "CFX": "CFX",
                "StratisEVM": "STRAT",
                "Celestia": "TIA",
                "ChilizChain": "ChilizChain",
                "Aptos": "APT",
                "Ontology": "ONT",
                "ICP": "ICP",
                "Cardano": "ADA",
                "FIL": "FIL",
                "CELO": "CELO",
                "DOT": "DOT",
                "StellarLumens": "XLM",
                "ATOM": "ATOM",
                "CronosChain": "CRO",
            },
        },
        "features": map[string]interface{} {
            "default": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": true,
                    "triggerPriceType": map[string]interface{} {
                        "last": true,
                        "mark": true,
                        "index": false,
                    },
                    "triggerDirection": false,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": true,
                        "FOK": true,
                        "PO": true,
                        "GTD": false,
                    },
                    "hedged": false,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyByCost": true,
                    "marketBuyRequiresPrice": false,
                    "selfTradePrevention": false,
                    "iceberg": false,
                },
                "createOrders": map[string]interface{} {
                    "max": 50,
                },
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": 500,
                    "daysBack": 100000,
                    "untilDays": 100000,
                    "symbolRequired": true,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "trigger": true,
                    "trailing": false,
                    "marketType": true,
                    "symbolRequired": false,
                },
                "fetchOrders": nil,
                "fetchClosedOrders": nil,
                "fetchOHLCV": map[string]interface{} {
                    "limit": 1000,
                },
            },
            "spot": map[string]interface{} {
                "extends": "default",
            },
            "forDerivatives": map[string]interface{} {
                "extends": "default",
                "createOrder": map[string]interface{} {
                    "attachedStopLossTakeProfit": map[string]interface{} {
                        "triggerPriceType": nil,
                        "price": false,
                    },
                },
                "fetchMyTrades": map[string]interface{} {
                    "limit": 100,
                },
            },
            "swap": map[string]interface{} {
                "linear": map[string]interface{} {
                    "extends": "forDerivatives",
                },
                "inverse": map[string]interface{} {
                    "extends": "forDerivatives",
                },
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "commonCurrencies": map[string]interface{} {},
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "22001": OrderNotFound,
                "429": DDoSProtection,
                "40001": AuthenticationError,
                "40002": AuthenticationError,
                "40003": AuthenticationError,
                "40005": InvalidNonce,
                "40006": AuthenticationError,
                "40007": BadRequest,
                "40008": InvalidNonce,
                "40009": AuthenticationError,
                "40011": AuthenticationError,
                "40012": AuthenticationError,
                "40013": ExchangeError,
                "40014": PermissionDenied,
                "40015": ExchangeError,
                "40016": PermissionDenied,
                "40017": ExchangeError,
                "40018": PermissionDenied,
                "40019": BadRequest,
                "40020": BadRequest,
                "40034": BadRequest,
                "400172": BadRequest,
                "40912": BadRequest,
                "40913": BadRequest,
                "40102": BadRequest,
                "40200": OnMaintenance,
                "40305": BadRequest,
                "40409": ExchangeError,
                "40704": ExchangeError,
                "40724": BadRequest,
                "40725": ExchangeError,
                "40762": InsufficientFunds,
                "40774": BadRequest,
                "40808": BadRequest,
                "43001": OrderNotFound,
                "43002": InvalidOrder,
                "43004": OrderNotFound,
                "43005": RateLimitExceeded,
                "43006": BadRequest,
                "43007": BadRequest,
                "43008": BadRequest,
                "43009": BadRequest,
                "43010": BadRequest,
                "43011": BadRequest,
                "43012": InsufficientFunds,
                "43117": InsufficientFunds,
                "43118": BadRequest,
                "43122": BadRequest,
                "45006": InsufficientFunds,
                "45110": BadRequest,
            },
            "broad": map[string]interface{} {},
        },
        "precisionMode": TICK_SIZE,
    })
}
func  (this *coincatch) CalculateRateLimiterCost(api interface{}, method interface{}, path interface{}, params interface{}, optionalArgs ...interface{}) interface{}  {
    config := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = config
    var step interface{} = this.SafeInteger(config, "step")
    var cost interface{} = this.SafeInteger(config, "cost", 1)
    var orders interface{} = this.SafeList2(params, "orderList", "orderDataList", []interface{}{})
    var ordersLength interface{} =     GetArrayLength(orders)
    if IsTrue(IsTrue((!IsEqual(step, nil))) && IsTrue((IsGreaterThan(ordersLength, step)))) {
        var numberOfSteps interface{} = MathCeil(Divide(ordersLength, step))
        return Multiply(cost, numberOfSteps)
    } else {
        return cost
    }
}
/**
 * @method
 * @name coincatch#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @see https://coincatch.github.io/github.io/en/spot/#get-server-time
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func  (this *coincatch) FetchTime(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetApiSpotV1PublicTime(params))
            PanicOnError(response)
        
                //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1725046822028,
            //         "data": "1725046822028"
            //     }
            //
        ch <- this.SafeInteger(response, "data")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coincatch#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see https://coincatch.github.io/github.io/en/spot/#get-coin-list
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func  (this *coincatch) FetchCurrencies(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetApiSpotV1PublicCurrencies(params))
            PanicOnError(response)
            var data interface{} = this.SafeList(response, "data", []interface{}{})
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1725102364202,
            //         "data": [
            //             {
            //                 "coinId": "1",
            //                 "coinName": "BTC",
            //                 "transfer": "true",
            //                 "chains": [
            //                     {
            //                         "chainId": "10",
            //                         "chain": "BITCOIN",
            //                         "needTag": "false",
            //                         "withdrawable": "true",
            //                         "rechargeable": "true",
            //                         "withdrawFee": "0.0005",
            //                         "extraWithDrawFee": "0",
            //                         "depositConfirm": "1",
            //                         "withdrawConfirm": "1",
            //                         "minDepositAmount": "0.00001",
            //                         "minWithdrawAmount": "0.001",
            //                         "browserUrl": "https://blockchair.com/bitcoin/transaction/"
            //                     }
            //                 ]
            //             },
            //             ...
            //         ]
            //     }
            //
            var result interface{} = map[string]interface{} {}
            var currenciesIds interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
                var currecy interface{} = GetValue(data, i)
                var currencyId interface{} = this.SafeString(currecy, "coinName")
                AppendToArray(&currenciesIds,currencyId)
                var code interface{} = this.SafeCurrencyCode(currencyId)
                var allowDeposit interface{} = false
                var allowWithdraw interface{} = false
                var minDeposit interface{} = nil
                var minWithdraw interface{} = nil
                var networks interface{} = this.SafeList(currecy, "chains")
                var networksById interface{} = this.SafeDict(this.Options, "networksById")
                var parsedNetworks interface{} = map[string]interface{} {}
                for j := 0; IsLessThan(j, GetArrayLength(networks)); j++ {
                    var network interface{} = GetValue(networks, j)
                    var networkId interface{} = this.SafeString(network, "chain")
                    var networkName interface{} = this.SafeString(networksById, networkId, networkId)
                    var networkDepositString interface{} = this.SafeString(network, "rechargeable")
                    var networkDeposit interface{} = IsEqual(networkDepositString, "true")
                    var networkWithdrawString interface{} = this.SafeString(network, "withdrawable")
                    var networkWithdraw interface{} = IsEqual(networkWithdrawString, "true")
                    var networkMinDeposit interface{} = this.SafeString(network, "minDepositAmount")
                    var networkMinWithdraw interface{} = this.SafeString(network, "minWithdrawAmount")
                    AddElementToObject(parsedNetworks, networkId, map[string]interface{} {
            "id": networkId,
            "network": networkName,
            "limits": map[string]interface{} {
                "deposit": map[string]interface{} {
                    "min": this.ParseNumber(networkMinDeposit),
                    "max": nil,
                },
                "withdraw": map[string]interface{} {
                    "min": this.ParseNumber(networkMinWithdraw),
                    "max": nil,
                },
            },
            "active": IsTrue(networkDeposit) && IsTrue(networkWithdraw),
            "deposit": networkDeposit,
            "withdraw": networkWithdraw,
            "fee": this.SafeNumber(network, "withdrawFee"),
            "precision": nil,
            "info": network,
        })
                    allowDeposit = Ternary(IsTrue(allowDeposit), allowDeposit, networkDeposit)
                    allowWithdraw = Ternary(IsTrue(allowWithdraw), allowWithdraw, networkWithdraw)
                    minDeposit = Ternary(IsTrue(minDeposit), Precise.StringMin(networkMinDeposit, minDeposit), networkMinDeposit)
                    minWithdraw = Ternary(IsTrue(minWithdraw), Precise.StringMin(networkMinWithdraw, minWithdraw), networkMinWithdraw)
                }
                AddElementToObject(result, code, map[string]interface{} {
            "id": currencyId,
            "numericId": this.SafeInteger(currecy, "coinId"),
            "code": code,
            "precision": nil,
            "type": nil,
            "name": nil,
            "active": IsTrue(allowWithdraw) && IsTrue(allowDeposit),
            "deposit": allowDeposit,
            "withdraw": allowWithdraw,
            "fee": nil,
            "limits": map[string]interface{} {
                "deposit": map[string]interface{} {
                    "min": this.ParseNumber(minDeposit),
                    "max": nil,
                },
                "withdraw": map[string]interface{} {
                    "min": this.ParseNumber(minWithdraw),
                    "max": nil,
                },
            },
            "networks": parsedNetworks,
            "info": currecy,
        })
            }
            if IsTrue(IsEqual(this.SafeList(this.Options, "currencyIdsListForParseMarket"), nil)) {
                AddElementToObject(this.Options, "currencyIdsListForParseMarket", currenciesIds)
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coincatch#fetchMarkets
 * @description retrieves data on all markets for the exchange
 * @see https://coincatch.github.io/github.io/en/spot/#get-all-tickers
 * @see https://coincatch.github.io/github.io/en/mix/#get-all-symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *coincatch) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetApiSpotV1MarketTickers(params))
            PanicOnError(response)
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1725114040155,
            //         "data": [
            //             {
            //                 "symbol": "BTCUSDT",
            //                 "high24h": "59461.34",
            //                 "low24h": "57723.23",
            //                 "close": "59056.02",
            //                 "quoteVol": "18240112.23368",
            //                 "baseVol": "309.05564",
            //                 "usdtVol": "18240112.2336744",
            //                 "ts": "1725114038951",
            //                 "buyOne": "59055.85",
            //                 "sellOne": "59057.45",
            //                 "bidSz": "0.0139",
            //                 "askSz": "0.0139",
            //                 "openUtc0": "59126.71",
            //                 "changeUtc": "-0.0012",
            //                 "change": "0.01662"
            //             },
            //             ...
            //         ]
            //     }
            //
            if IsTrue(IsEqual(this.SafeList(this.Options, "currencyIdsListForParseMarket"), nil)) {
        
                retRes75812 := (<-this.FetchCurrencies())
                PanicOnError(retRes75812)
            }
            var spotMarkets interface{} = this.SafeList(response, "data", []interface{}{})
            var request interface{} = map[string]interface{} {}
            var productType interface{} = nil
            productTypeparamsVariable := this.HandleOptionAndParams(params, "fetchMarkets", "productType", productType);
            productType = GetValue(productTypeparamsVariable,0);
            params = GetValue(productTypeparamsVariable,1)
            var swapMarkets interface{} = []interface{}{}
            AddElementToObject(request, "productType", "umcbl")
            
        response = (<-this.PublicGetApiMixV1MarketContracts(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1725297439225,
            //         "data": [
            //             {
            //                 "symbol": "BTCUSDT_UMCBL",
            //                 "makerFeeRate": "0.0002",
            //                 "takerFeeRate": "0.0006",
            //                 "feeRateUpRatio": "0.005",
            //                 "openCostUpRatio": "0.01",
            //                 "quoteCoin": "USDT",
            //                 "baseCoin": "BTC",
            //                 "buyLimitPriceRatio": "0.01",
            //                 "sellLimitPriceRatio": "0.01",
            //                 "supportMarginCoins": [ "USDT" ],
            //                 "minTradeNum": "0.001",
            //                 "priceEndStep": "1",
            //                 "volumePlace": "3",
            //                 "pricePlace": "1",
            //                 "sizeMultiplier": "0.001",
            //                 "symbolType": "perpetual",
            //                 "symbolStatus": "normal",
            //                 "offTime": "-1",
            //                 "limitOpenTime": "-1",
            //                 "maintainTime": "",
            //                 "symbolName": "BTCUSDT",
            //                 "minTradeUSDT": null,
            //                 "maxPositionNum": null,
            //                 "maxOrderNum": null
            //             }
            //         ]
            //     }
            //
            var swapUMCBL interface{} = this.SafeList(response, "data", []interface{}{})
            AddElementToObject(request, "productType", "dmcbl")
            
        response = (<-this.PublicGetApiMixV1MarketContracts(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code":"00000",
            //         "msg":"success",
            //         "requestTime":1725297439646,
            //         "data":[
            //             {
            //                 "symbol":"BTCUSD_DMCBL",
            //                 "makerFeeRate":"0.0002",
            //                 "takerFeeRate":"0.0006",
            //                 "feeRateUpRatio":"0.005",
            //                 "openCostUpRatio":"0.01",
            //                 "quoteCoin":"USD",
            //                 "baseCoin":"BTC",
            //                 "buyLimitPriceRatio":"0.01",
            //                 "sellLimitPriceRatio":"0.01",
            //                 "supportMarginCoins":[
            //                     "BTC",
            //                     "ETH"
            //                 ],
            //                 "minTradeNum":"0.001",
            //                 "priceEndStep":"1",
            //                 "volumePlace":"3",
            //                 "pricePlace":"1",
            //                 "sizeMultiplier":"0.001",
            //                 "symbolType":"perpetual",
            //                 "symbolStatus":"normal",
            //                 "offTime":"-1",
            //                 "limitOpenTime":"-1",
            //                 "maintainTime":"",
            //                 "symbolName":"BTCUSD",
            //                 "minTradeUSDT":null,
            //                 "maxPositionNum":null,
            //                 "maxOrderNum":null
            //             }
            //         ]
            //     }
            var swapDMCBL interface{} = this.SafeList(response, "data", []interface{}{})
            var swapDMCBLExtended interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(swapDMCBL)); i++ {
                var market interface{} = GetValue(swapDMCBL, i)
                var supportMarginCoins interface{} = this.SafeList(market, "supportMarginCoins", []interface{}{})
                for j := 0; IsLessThan(j, GetArrayLength(supportMarginCoins)); j++ {
                    var settle interface{} = GetValue(supportMarginCoins, j)
                    var obj interface{} = map[string]interface{} {
                        "supportMarginCoins": []interface{}{settle},
                    }
                    AppendToArray(&swapDMCBLExtended,this.Extend(market, obj))
                }
            }
            swapMarkets = this.ArrayConcat(swapUMCBL, swapDMCBLExtended)
            var markets interface{} = this.ArrayConcat(spotMarkets, swapMarkets)
        
            ch <- this.ParseMarkets(markets)
            return nil
        
            }()
            return ch
        }
func  (this *coincatch) ParseMarket(market interface{}) interface{}  {
    //
    // spot
    //     {
    //         "symbol": "BTCUSDT",
    //         "high24h": "59461.34",
    //         "low24h": "57723.23",
    //         "close": "59056.02",
    //         "quoteVol": "18240112.23368",
    //         "baseVol": "309.05564",
    //         "usdtVol": "18240112.2336744",
    //         "ts": "1725114038951",
    //         "buyOne": "59055.85",
    //         "sellOne": "59057.45",
    //         "bidSz": "0.0139",
    //         "askSz": "0.0139",
    //         "openUtc0": "59126.71",
    //         "changeUtc": "-0.0012",
    //         "change": "0.01662"
    //     },
    //
    // swap
    //     {
    //         "symbol": "BTCUSDT_UMCBL",
    //         "makerFeeRate": "0.0002",
    //         "takerFeeRate": "0.0006",
    //         "feeRateUpRatio": "0.005",
    //         "openCostUpRatio": "0.01",
    //         "quoteCoin": "USDT",
    //         "baseCoin": "BTC",
    //         "buyLimitPriceRatio": "0.01",
    //         "sellLimitPriceRatio": "0.01",
    //         "supportMarginCoins": [ "USDT" ],
    //         "minTradeNum": "0.001",
    //         "priceEndStep": "1",
    //         "volumePlace": "3",
    //         "pricePlace": "1",
    //         "sizeMultiplier": "0.001",
    //         "symbolType": "perpetual",
    //         "symbolStatus": "normal",
    //         "offTime": "-1",
    //         "limitOpenTime": "-1",
    //         "maintainTime": "",
    //         "symbolName": "BTCUSDT",
    //         "minTradeUSDT": null,
    //         "maxPositionNum": null,
    //         "maxOrderNum": null
    //     }
    //
    var marketId interface{} = this.SafeString(market, "symbol")
    var tradingFees interface{} = this.SafeDict(this.Fees, "trading")
    var fees interface{} = this.SafeDict(tradingFees, "spot")
    var baseId interface{} = this.SafeString(market, "baseCoin")
    var quoteId interface{} = this.SafeString(market, "quoteCoin")
    var settleId interface{} = nil
    var suffix interface{} = ""
    var settle interface{} = nil
    var typeVar interface{} = "spot"
    var isLinear interface{} = nil
    var isInverse interface{} = nil
    var subType interface{} = nil
    var isSpot interface{} = IsEqual(baseId, nil) // for now spot markets have no properties baseCoin and quoteCoin
    if IsTrue(isSpot) {
        var parsedMarketId interface{} = this.ParseSpotMarketId(marketId)
        baseId = this.SafeString(parsedMarketId, "baseId")
        quoteId = this.SafeString(parsedMarketId, "quoteId")
        marketId = Add(marketId, "_SPBL") // spot markets should have current suffix
    } else {
        typeVar = "swap"
        AddElementToObject(fees, "taker", this.SafeNumber(market, "takerFeeRate"))
        AddElementToObject(fees, "maker", this.SafeNumber(market, "makerFeeRate"))
        var supportMarginCoins interface{} = this.SafeList(market, "supportMarginCoins", []interface{}{})
        settleId = this.SafeString(supportMarginCoins, 0)
        settle = this.SafeCurrencyCode(settleId)
        suffix = Add(":", settle)
        isLinear = IsEqual(quoteId, settleId) // todo check
        isInverse = IsEqual(baseId, settleId) // todo check
        if IsTrue(isLinear) {
            subType = "linear"
        } else if IsTrue(isInverse) {
            subType = "inverse"
        }
    }
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    var symbol interface{} = Add(Add(Add(base, "/"), quote), suffix)
    var symbolStatus interface{} = this.SafeString(market, "symbolStatus")
    var active interface{} = Ternary(IsTrue(symbolStatus), (IsEqual(symbolStatus, "normal")), nil)
    var volumePlace interface{} = this.SafeString(market, "volumePlace")
    var amountPrecisionString interface{} = this.ParsePrecision(volumePlace)
    var pricePlace interface{} = this.SafeString(market, "pricePlace")
    var priceEndStep interface{} = this.SafeString(market, "priceEndStep")
    var pricePrecisionString interface{} = Precise.StringMul(this.ParsePrecision(pricePlace), priceEndStep)
    return this.SafeMarketStructure(map[string]interface{} {
        "id": marketId,
        "symbol": symbol,
        "base": base,
        "quote": quote,
        "baseId": baseId,
        "quoteId": quoteId,
        "active": active,
        "type": typeVar,
        "subType": subType,
        "spot": isSpot,
        "margin": Ternary(IsTrue(isSpot), false, nil),
        "swap": !IsTrue(isSpot),
        "future": false,
        "option": false,
        "contract": !IsTrue(isSpot),
        "settle": settle,
        "settleId": settleId,
        "contractSize": this.SafeNumber(market, "sizeMultiplier"),
        "linear": isLinear,
        "inverse": isInverse,
        "taker": this.SafeNumber(fees, "taker"),
        "maker": this.SafeNumber(fees, "maker"),
        "percentage": this.SafeBool(fees, "percentage"),
        "tierBased": this.SafeBool(fees, "tierBased"),
        "feeSide": this.SafeString(fees, "feeSide"),
        "expiry": nil,
        "expiryDatetime": nil,
        "strike": nil,
        "optionType": nil,
        "precision": map[string]interface{} {
            "amount": this.ParseNumber(amountPrecisionString),
            "price": this.ParseNumber(pricePrecisionString),
        },
        "limits": map[string]interface{} {
            "amount": map[string]interface{} {
                "min": this.SafeNumber(market, "minTradeNum"),
                "max": nil,
            },
            "price": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "leverage": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "cost": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
        },
        "created": nil,
        "info": market,
    })
}
func  (this *coincatch) ParseSpotMarketId(marketId interface{}) interface{}  {
    var baseId interface{} = nil
    var quoteId interface{} = nil
    var currencyIds interface{} = this.SafeList(this.Options, "currencyIdsListForParseMarket", []interface{}{})
    for i := 0; IsLessThan(i, GetArrayLength(currencyIds)); i++ {
        var currencyId interface{} = GetValue(currencyIds, i)
        var entryIndex interface{} = GetIndexOf(marketId, currencyId)
        if IsTrue(IsGreaterThan(entryIndex, OpNeg(1))) {
            var restId interface{} = Replace(marketId, currencyId, "")
            if IsTrue(IsEqual(entryIndex, 0)) {
                baseId = currencyId
                quoteId = restId
            } else {
                baseId = restId
                quoteId = currencyId
            }
            break
        }
    }
    var result interface{} = map[string]interface{} {
        "baseId": baseId,
        "quoteId": quoteId,
    }
    return result
}
/**
 * @method
 * @name coincatch#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://coincatch.github.io/github.io/en/spot/#get-single-ticker
 * @see https://coincatch.github.io/github.io/en/mix/#get-single-symbol-ticker
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *coincatch) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes10478 := (<-this.LoadMarkets())
            PanicOnError(retRes10478)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var response interface{} = nil
            if IsTrue(GetValue(market, "spot")) {
                
        response = (<-this.PublicGetApiSpotV1MarketTicker(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(GetValue(market, "swap")) {
                
        response = (<-this.PublicGetApiMixV1MarketTicker(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                panic(NotSupported(Add(Add(Add(Add(this.Id, " "), "fetchTicker() is not supported for "), GetValue(market, "type")), " type of markets")))
            }
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseTicker(data, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coincatch#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://coincatch.github.io/github.io/en/spot/#get-all-tickers
 * @see https://coincatch.github.io/github.io/en/mix/#get-all-symbol-ticker
 * @param {string[]} [symbols] unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.type] 'spot' or 'swap' (default 'spot')
 * @param {string} [params.productType] 'umcbl' or 'dmcbl' (default 'umcbl') - USDT perpetual contract or Universal margin perpetual contract
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *coincatch) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var methodName interface{} = "fetchTickers"
        
            retRes11328 := (<-this.LoadMarkets())
            PanicOnError(retRes11328)
            symbols = this.MarketSymbols(symbols, nil, true, true)
            var market interface{} = this.GetMarketFromSymbols(symbols)
            var marketType interface{} = "spot"
            marketTypeparamsVariable := this.HandleMarketTypeAndParams(methodName, market, params, marketType);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            var response interface{} = nil
            if IsTrue(IsEqual(marketType, "spot")) {
                
        response = (<-this.PublicGetApiSpotV1MarketTickers(params))
                PanicOnError(response)
            } else if IsTrue(IsEqual(marketType, "swap")) {
                var productType interface{} = "umcbl"
                productTypeparamsVariable := this.HandleOptionAndParams(params, methodName, "productType", productType);
                productType = GetValue(productTypeparamsVariable,0);
                params = GetValue(productTypeparamsVariable,1)
                var request interface{} = map[string]interface{} {
                    "productType": productType,
                }
                
        response = (<-this.PublicGetApiMixV1MarketTickers(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                panic(NotSupported(Add(Add(Add(Add(Add(this.Id, " "), methodName), "() is not supported for "), marketType), " type of markets")))
            }
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTickers(data, symbols)
            return nil
        
            }()
            return ch
        }
func  (this *coincatch) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // spot
    //     {
    //         "symbol": "BTCUSDT",
    //         "high24h": "59461.34",
    //         "low24h": "57723.23",
    //         "close": "59056.02",
    //         "quoteVol": "18240112.23368",
    //         "baseVol": "309.05564",
    //         "usdtVol": "18240112.2336744",
    //         "ts": "1725114038951",
    //         "buyOne": "59055.85",
    //         "sellOne": "59057.45",
    //         "bidSz": "0.0139",
    //         "askSz": "0.0139",
    //         "openUtc0": "59126.71",
    //         "changeUtc": "-0.0012",
    //         "change": "0.01662"
    //     }
    //
    // swap
    //     {
    //         "symbol": "ETHUSDT_UMCBL",
    //         "last": "2540.6",
    //         "bestAsk": "2540.71",
    //         "bestBid": "2540.38",
    //         "bidSz": "12.1",
    //         "askSz": "20",
    //         "high24h": "2563.91",
    //         "low24h": "2398.3",
    //         "timestamp": "1725316687177",
    //         "priceChangePercent": "0.01134",
    //         "baseVolume": "706928.96",
    //         "quoteVolume": "1756401737.8766",
    //         "usdtVolume": "1756401737.8766",
    //         "openUtc": "2424.49",
    //         "chgUtc": "0.04789",
    //         "indexPrice": "2541.977142",
    //         "fundingRate": "0.00006",
    //         "holdingAmount": "144688.49",
    //         "deliveryStartTime": null,
    //         "deliveryTime": null,
    //         "deliveryStatus": "normal"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger2(ticker, "ts", "timestamp")
    var marketId interface{} = this.SafeString(ticker, "symbol", "")
    if IsTrue(IsLessThan(GetIndexOf(marketId, "_"), 0)) {
        marketId = Add(marketId, "_SPBL") // spot markets from tickers endpoints have no suffix specific for market id
    }
    market = this.SafeMarketCustom(marketId, market)
    var last interface{} = this.SafeString2(ticker, "close", "last")
    return this.SafeTicker(map[string]interface{} {
        "symbol": GetValue(market, "symbol"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeString(ticker, "high24h"),
        "low": this.SafeString(ticker, "low24h"),
        "bid": this.SafeString2(ticker, "buyOne", "bestBid"),
        "bidVolume": this.SafeString(ticker, "bidSz"),
        "ask": this.SafeString2(ticker, "sellOne", "bestAsk"),
        "askVolume": this.SafeString(ticker, "askSz"),
        "vwap": nil,
        "open": this.SafeString2(ticker, "openUtc0", "openUtc"),
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": nil,
        "percentage": Precise.StringMul(this.SafeString2(ticker, "changeUtc", "chgUtc"), "100"),
        "average": nil,
        "baseVolume": this.SafeString2(ticker, "baseVol", "baseVolume"),
        "quoteVolume": this.SafeString2(ticker, "quoteVol", "quoteVolume"),
        "indexPrice": this.SafeString(ticker, "indexPrice"),
        "markPrice": nil,
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name coincatch#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://coincatch.github.io/github.io/en/spot/#get-merged-depth-data
 * @see https://coincatch.github.io/github.io/en/mix/#get-merged-depth-data
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return (maximum and default value is 100)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.precision] 'scale0' (default), 'scale1', 'scale2' or 'scale3' - price accuracy, according to the selected accuracy as the step size to return the cumulative depth
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *coincatch) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes13068 := (<-this.LoadMarkets())
            PanicOnError(retRes13068)
            var methodName interface{} = "fetchOrderBook"
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            var precision interface{} = nil
            precisionparamsVariable := this.HandleOptionAndParams(params, methodName, "precision");
            precision = GetValue(precisionparamsVariable,0);
            params = GetValue(precisionparamsVariable,1)
            if IsTrue(!IsEqual(precision, nil)) {
                AddElementToObject(request, "precision", precision)
            }
            var response interface{} = nil
            if IsTrue(GetValue(market, "spot")) {
                
        response = (<-this.PublicGetApiSpotV1MarketMergeDepth(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(GetValue(market, "swap")) {
                
        response = (<-this.PublicGetApiMixV1MarketMergeDepth(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                panic(NotSupported(Add(Add(Add(Add(Add(this.Id, " "), methodName), "() is not supported for "), GetValue(market, "type")), " type of markets")))
            }
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var timestamp interface{} = this.SafeInteger(data, "ts")
        
            ch <- this.ParseOrderBook(data, symbol, timestamp, "bids", "asks")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coincatch#fetchOHLCV
 * @see https://coincatch.github.io/github.io/en/spot/#get-candle-data
 * @see https://coincatch.github.io/github.io/en/mix/#get-candle-data
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch (default 100)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest candle to fetch
 * @param {string} [params.price] "mark" for mark price candles
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *coincatch) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var methodName interface{} = "fetchOHLCV"
        
            retRes13658 := (<-this.LoadMarkets())
            PanicOnError(retRes13658)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var until interface{} = nil
            untilparamsVariable := this.HandleOptionAndParams(params, methodName, "until");
            until = GetValue(untilparamsVariable,0);
            params = GetValue(untilparamsVariable,1)
            var marketType interface{} = GetValue(market, "type")
            var timeframes interface{} = GetValue(GetValue(this.Options, "timeframes"), marketType)
            var encodedTimeframe interface{} = this.SafeString(timeframes, timeframe, timeframe)
            var maxLimit interface{} = 1000
            var requestedLimit interface{} = limit
            if IsTrue(IsTrue((!IsEqual(since, nil))) || IsTrue((!IsEqual(until, nil)))) {
                requestedLimit = maxLimit // the exchange returns only last limit candles, so we have to fetch max limit if since or until are provided
            }
            if IsTrue(!IsEqual(requestedLimit, nil)) {
                AddElementToObject(request, "limit", requestedLimit)
            }
            var response interface{} = nil
            if IsTrue(GetValue(market, "spot")) {
                AddElementToObject(request, "period", encodedTimeframe)
                if IsTrue(!IsEqual(since, nil)) {
                    AddElementToObject(request, "after", since)
                }
                if IsTrue(!IsEqual(until, nil)) {
                    AddElementToObject(request, "before", until)
                }
                
        response = (<-this.PublicGetApiSpotV1MarketCandles(this.Extend(request, params)))
                PanicOnError(response)
                //
                //     {
                //         "code": "00000",
                //         "msg": "success",
                //         "requestTime": 1725142465742,
                //         "data": [
                //             {
                //                 "open": "2518.6",
                //                 "high": "2519.19",
                //                 "low": "2518.42",
                //                 "close": "2518.86",
                //                 "quoteVol": "17193.239401",
                //                 "baseVol": "6.8259",
                //                 "usdtVol": "17193.239401",
                //                 "ts": "1725142200000"
                //             },
                //             ...
                //         ]
                //     }
                //
                var data interface{} = this.SafeList(response, "data", []interface{}{})
        
                ch <- this.ParseOHLCVs(data, market, timeframe, since, limit)
                return nil
            } else if IsTrue(GetValue(market, "swap")) {
                AddElementToObject(request, "granularity", encodedTimeframe)
                if IsTrue(IsEqual(until, nil)) {
                    until = this.Milliseconds()
                }
                if IsTrue(IsEqual(since, nil)) {
                    var duration interface{} = this.ParseTimeframe(timeframe)
                    since = Subtract(until, (Multiply(Multiply(duration, maxLimit), 1000)))
                }
                AddElementToObject(request, "startTime", since) // since and until are mandatory for swap
                AddElementToObject(request, "endTime", until)
                var priceType interface{} = nil
                priceTypeparamsVariable := this.HandleOptionAndParams(params, methodName, "price");
                priceType = GetValue(priceTypeparamsVariable,0);
                params = GetValue(priceTypeparamsVariable,1)
                if IsTrue(IsEqual(priceType, "mark")) {
                    AddElementToObject(request, "kLineType", "market mark index")
                }
                
        response = (<-this.PublicGetApiMixV1MarketCandles(this.Extend(request, params)))
                PanicOnError(response)
        
                        //
                //     [
                //         [
                //             "1725379020000",
                //             "57614",
                //             "57636",
                //             "57614",
                //             "57633",
                //             "28.725",
                //             "1655346.493"
                //         ],
                //         ...
                //     ]
                //
        ch <- this.ParseOHLCVs(response, market, timeframe, since, limit)
                return nil
            } else {
                panic(NotSupported(Add(Add(Add(Add(Add(this.Id, " "), methodName), "() is not supported for "), GetValue(market, "type")), " type of markets")))
            }
                return nil
            }()
            return ch
        }
func  (this *coincatch) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.SafeInteger2(ohlcv, "ts", 0), this.SafeNumber2(ohlcv, "open", 1), this.SafeNumber2(ohlcv, "high", 2), this.SafeNumber2(ohlcv, "low", 3), this.SafeNumber2(ohlcv, "close", 4), this.SafeNumber2(ohlcv, "baseVol", 5)}
}
/**
 * @method
 * @name coincatch#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://coincatch.github.io/github.io/en/spot/#get-recent-trades
 * @see https://coincatch.github.io/github.io/en/mix/#get-fills
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest entry to fetch
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *coincatch) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
            var methodName interface{} = "fetchTrades"
        
            retRes14788 := (<-this.LoadMarkets())
            PanicOnError(retRes14788)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var until interface{} = nil
            untilparamsVariable := this.HandleOptionAndParams(params, methodName, "until");
            until = GetValue(untilparamsVariable,0);
            params = GetValue(untilparamsVariable,1)
            var maxLimit interface{} = 1000
            var requestLimit interface{} = limit
            if IsTrue(IsTrue((!IsEqual(since, nil))) || IsTrue((!IsEqual(until, nil)))) {
                requestLimit = maxLimit
                if IsTrue(!IsEqual(since, nil)) {
                    AddElementToObject(request, "startTime", since)
                }
                if IsTrue(!IsEqual(until, nil)) {
                    AddElementToObject(request, "endTime", until)
                }
            }
            if IsTrue(!IsEqual(requestLimit, nil)) {
                AddElementToObject(request, "limit", requestLimit)
            }
            var response interface{} = nil
            if IsTrue(GetValue(market, "spot")) {
                
        response = (<-this.PublicGetApiSpotV1MarketFillsHistory(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(GetValue(market, "swap")) {
                
        response = (<-this.PublicGetApiMixV1MarketFillsHistory(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                panic(NotSupported(Add(Add(Add(Add(Add(this.Id, " "), methodName), "() is not supported for "), GetValue(market, "type")), " type of markets")))
            }
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTrades(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *coincatch) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTrades spot
    //     {
    //         "symbol": "ETHUSDT_SPBL",
    //         "tradeId": "1214135619719827457",
    //         "side": "Buy",
    //         "fillPrice": "2458.62",
    //         "fillQuantity": "0.4756",
    //         "fillTime": "1725198409967"
    //     }
    //
    // fetchTrades swap
    //     {
    //         "tradeId": "1214936067582234782",
    //         "price": "57998.5",
    //         "size": "1.918",
    //         "side": "Sell",
    //         "timestamp": "1725389251000",
    //         "symbol": "BTCUSDT_UMCBL"
    //     }
    //
    // fetchMyTrades spot
    //     {
    //         "accountId": "1002820815393",
    //         "symbol": "ETHUSDT_SPBL",
    //         "orderId": "1217143186968068096",
    //         "fillId": "1217143193356505089",
    //         "orderType": "market",
    //         "side": "buy",
    //         "fillPrice": "2340.55",
    //         "fillQuantity": "0.0042",
    //         "fillTotalAmount": "9.83031",
    //         "feeCcy": "ETH",
    //         "fees": "-0.0000042",
    //         "takerMakerFlag": "taker",
    //         "cTime": "1725915471400"
    //     }
    //
    // fetchMyTrades swap
    //     {
    //         "tradeId": "1225467075440189441",
    //         "symbol": "ETHUSD_DMCBL",
    //         "orderId": "1225467075288719360",
    //         "price": "2362.03",
    //         "sizeQty": "0.1",
    //         "fee": "-0.00005996",
    //         "side": "burst_close_long",
    //         "fillAmount": "236.203",
    //         "profit": "-0.0083359",
    //         "enterPointSource": "SYS",
    //         "tradeSide": "burst_close_long",
    //         "holdMode": "double_hold",
    //         "takerMakerFlag": "taker",
    //         "cTime": "1727900039539"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(trade, "symbol")
    market = this.SafeMarketCustom(marketId, market)
    var timestamp interface{} = this.SafeIntegerN(trade, []interface{}{"fillTime", "timestamp", "cTime"})
    var fees interface{} = this.SafeString2(trade, "fees", "fee")
    var feeCost interface{} = nil
    if IsTrue(!IsEqual(fees, nil)) {
        feeCost = Precise.StringAbs(fees)
    }
    var feeCurrency interface{} = this.SafeString(trade, "feeCcy")
    if IsTrue(IsTrue((IsEqual(feeCurrency, nil))) && IsTrue((!IsEqual(GetValue(market, "settle"), nil)))) {
        feeCurrency = GetValue(market, "settle")
    }
    var side interface{} = this.SafeStringLower2(trade, "tradeSide", "side")
    return this.SafeTrade(map[string]interface{} {
        "id": this.SafeString2(trade, "tradeId", "fillId"),
        "order": this.SafeString(trade, "orderId"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": GetValue(market, "symbol"),
        "type": this.SafeString(trade, "orderType"),
        "side": this.ParseOrderSide(side),
        "takerOrMaker": this.SafeString(trade, "takerMakerFlag"),
        "price": this.SafeString2(trade, "fillPrice", "price"),
        "amount": this.SafeStringN(trade, []interface{}{"fillQuantity", "size", "sizeQty"}),
        "cost": this.SafeString2(trade, "fillTotalAmount", "fillAmount"),
        "fee": map[string]interface{} {
            "cost": feeCost,
            "currency": feeCurrency,
        },
        "info": trade,
    }, market)
}
/**
 * @method
 * @name coincatch#fetchFundingRate
 * @description fetch the current funding rate
 * @see https://coincatch.github.io/github.io/en/mix/#get-current-funding-rate
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
 */
func  (this *coincatch) FetchFundingRate(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes16468 := (<-this.LoadMarkets())
            PanicOnError(retRes16468)
            var market interface{} = this.Market(symbol)
            var marketId interface{} = GetValue(market, "id")
            var parts interface{} = Split(marketId, "_")
            var request interface{} = map[string]interface{} {
                "symbol": marketId,
                "productType": this.SafeString(parts, 1),
            }
        
            response:= (<-this.PublicGetApiMixV1MarketCurrentFundRate(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1725402130395,
            //         "data": {
            //             "symbol": "BTCUSDT_UMCBL",
            //             "fundingRate": "0.000043"
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseFundingRate(data, market)
            return nil
        
            }()
            return ch
        }
func  (this *coincatch) ParseFundingRate(contract interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(contract, "symbol")
    market = this.SafeMarketCustom(marketId, market)
    var fundingRate interface{} = this.SafeNumber(contract, "fundingRate")
    return map[string]interface{} {
        "info": contract,
        "symbol": GetValue(market, "symbol"),
        "markPrice": nil,
        "indexPrice": nil,
        "interestRate": nil,
        "estimatedSettlePrice": nil,
        "timestamp": nil,
        "datetime": nil,
        "fundingRate": fundingRate,
        "fundingTimestamp": nil,
        "fundingDatetime": nil,
        "nextFundingRate": nil,
        "nextFundingTimestamp": nil,
        "nextFundingDatetime": nil,
        "previousFundingRate": nil,
        "previousFundingTimestamp": nil,
        "previousFundingDatetime": nil,
    }
}
func  (this *coincatch) HandleOptionParamsAndRequest(params interface{}, methodName interface{}, optionName interface{}, request interface{}, requestProperty interface{}, optionalArgs ...interface{}) interface{}  {
    defaultValue := GetArg(optionalArgs, 0, nil)
    _ = defaultValue
    optionparamsOmitedVariable := this.HandleOptionAndParams(params, methodName, optionName, defaultValue);
    option := GetValue(optionparamsOmitedVariable,0);
    paramsOmited := GetValue(optionparamsOmitedVariable,1)
    if IsTrue(!IsEqual(option, nil)) {
        AddElementToObject(request, requestProperty, option)
    }
    return []interface{}{request, paramsOmited}
}
/**
 * @method
 * @name coincatch#fetchFundingRateHistory
 * @description fetches historical funding rate prices
 * @see https://coincatch.github.io/github.io/en/mix/#get-history-funding-rate
 * @param {string} symbol unified symbol of the market to fetch the funding rate history for
 * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
 * @param {int} [limit] the maximum amount of entries to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.pageNo] the page number to fetch
 * @param {bool} [params.nextPage] whether to query the next page (default false)
 * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
 */
func  (this *coincatch) FetchFundingRateHistory(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchFundingRateHistory() requires a symbol argument")))
            }
        
            retRes17208 := (<-this.LoadMarkets())
            PanicOnError(retRes17208)
            var maxEntriesPerRequest interface{} = 100
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var requestedLimit interface{} = limit
            if IsTrue(!IsEqual(since, nil)) {
                requestedLimit = maxEntriesPerRequest
            }
            if IsTrue(!IsEqual(requestedLimit, nil)) {
                AddElementToObject(request, "pageSize", requestedLimit)
            }
        
            response:= (<-this.PublicGetApiMixV1MarketHistoryFundRate(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1725455810888,
            //         "data": [
            //             {
            //                 "symbol": "BTCUSD",
            //                 "fundingRate": "0.000635",
            //                 "settleTime": "1724889600000"
            //             }
            //         ]
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
            var rates interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
                var entry interface{} = GetValue(data, i)
                var timestamp interface{} = this.SafeInteger(entry, "settleTime")
                AppendToArray(&rates,map[string]interface{} {
                    "info": entry,
                    "symbol": this.SafeSymbol(this.SafeString(entry, "symbol"), market, nil, "swap"),
                    "fundingRate": this.SafeNumber(entry, "fundingRate"),
                    "timestamp": timestamp,
                    "datetime": this.Iso8601(timestamp),
                })
            }
            var sorted interface{} = this.SortBy(rates, "timestamp")
        
            ch <- this.FilterBySinceLimit(sorted, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coincatch#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://coincatch.github.io/github.io/en/spot/#get-account-assets
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.type] 'spot' or 'swap' - the type of the market to fetch balance for (default 'spot')
 * @param {string} [params.productType] *swap only* 'umcbl' or 'dmcbl' (default 'umcbl')
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *coincatch) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes17768 := (<-this.LoadMarkets())
            PanicOnError(retRes17768)
            var methodName interface{} = "fetchBalance"
            var marketType interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams(methodName, nil, params);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            var response interface{} = nil
            if IsTrue(IsEqual(marketType, "spot")) {
                //
                //     {
                //         "code": "00000",
                //         "msg": "success",
                //         "requestTime": 1725202685986,
                //         "data": [
                //             {
                //                 "coinId": 2,
                //                 "coinName": "USDT",
                //                 "available": "99.20000000",
                //                 "frozen": "0.00000000",
                //                 "lock": "0.00000000",
                //                 "uTime": "1724938746000"
                //             }
                //         ]
                //     }
                //
                
        response = (<-this.PrivateGetApiSpotV1AccountAssets(params))
                PanicOnError(response)
            } else if IsTrue(IsEqual(marketType, "swap")) {
                var productType interface{} = "umcbl"
                productTypeparamsVariable := this.HandleOptionAndParams(params, methodName, "productType", productType);
                productType = GetValue(productTypeparamsVariable,0);
                params = GetValue(productTypeparamsVariable,1)
                var request interface{} = map[string]interface{} {
                    "productType": productType,
                }
                //
                //     {
                //         "code": "00000",
                //         "msg": "success",
                //         "requestTime": 1726666298135,
                //         "data": [
                //             {
                //                 "marginCoin": "USDT",
                //                 "locked": "0",
                //                 "available": "60",
                //                 "crossMaxAvailable": "60",
                //                 "fixedMaxAvailable": "60",
                //                 "maxTransferOut": "60",
                //                 "equity": "60",
                //                 "usdtEquity": "60",
                //                 "btcEquity": "0.001002360626",
                //                 "crossRiskRate": "0",
                //                 "unrealizedPL": "0",
                //                 "bonus": "0",
                //                 "crossedUnrealizedPL": null,
                //                 "isolatedUnrealizedPL": null
                //             }
                //         ]
                //     }
                //
                
        response = (<-this.PrivateGetApiMixV1AccountAccounts(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                panic(NotSupported(Add(Add(Add(Add(Add(this.Id, " "), methodName), "() is not supported for "), marketType), " type of markets")))
            }
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseBalance(data)
            return nil
        
            }()
            return ch
        }
func  (this *coincatch) ParseBalance(balances interface{}) interface{}  {
    //
    // spot
    //     [
    //         {
    //             "coinId": 2,
    //             "coinName": "USDT",
    //             "available": "99.20000000",
    //             "frozen": "0.00000000",
    //             "lock": "0.00000000",
    //             "uTime": "1724938746000"
    //         }
    //     ]
    //
    // swap
    //     [
    //         {
    //             "marginCoin": "USDT",
    //             "locked": "0",
    //             "available": "60",
    //             "crossMaxAvailable": "60",
    //             "fixedMaxAvailable": "60",
    //             "maxTransferOut": "60",
    //             "equity": "60",
    //             "usdtEquity": "60",
    //             "btcEquity": "0.001002360626",
    //             "crossRiskRate": "0",
    //             "unrealizedPL": "0",
    //             "bonus": "0",
    //             "crossedUnrealizedPL": null,
    //             "isolatedUnrealizedPL": null
    //         }
    //     ]
    //
    var result interface{} = map[string]interface{} {
        "info": balances,
    }
    for i := 0; IsLessThan(i, GetArrayLength(balances)); i++ {
        var balanceEntry interface{} = this.SafeDict(balances, i, map[string]interface{} {})
        var currencyId interface{} = this.SafeString2(balanceEntry, "coinName", "marginCoin")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        AddElementToObject(account, "free", this.SafeString(balanceEntry, "available"))
        var locked interface{} = this.SafeString2(balanceEntry, "lock", "locked")
        var frozen interface{} = this.SafeString(balanceEntry, "frozen", "0")
        AddElementToObject(account, "used", Precise.StringAdd(locked, frozen))
        AddElementToObject(account, "total", this.SafeString(balanceEntry, "equity"))
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name coincatch#transfer
 * @description transfer currency internally between wallets on the same account
 * @see https://coincatch.github.io/github.io/en/spot/#transfer
 * @param {string} code unified currency code
 * @param {float} amount amount to transfer
 * @param {string} fromAccount 'spot' or 'swap' or 'mix_usdt' or 'mix_usd' - account to transfer from
 * @param {string} toAccount 'spot' or 'swap' or 'mix_usdt' or 'mix_usd' - account to transfer to
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.clientOrderId] a unique id for the transfer
 * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func  (this *coincatch) Transfer(code interface{}, amount interface{}, fromAccount interface{}, toAccount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes19058 := (<-this.LoadMarkets())
            PanicOnError(retRes19058)
            var currency interface{} = this.Currency(code)
            if IsTrue(IsEqual(fromAccount, "swap")) {
                if IsTrue(IsEqual(code, "USDT")) {
                    fromAccount = "mix_usdt"
                } else {
                    fromAccount = "mix_usd"
                }
            }
            if IsTrue(IsEqual(toAccount, "swap")) {
                if IsTrue(IsEqual(code, "USDT")) {
                    toAccount = "mix_usdt"
                } else {
                    toAccount = "mix_usd"
                }
            }
            var request interface{} = map[string]interface{} {
                "coin": GetValue(currency, "id"),
                "amount": this.CurrencyToPrecision(code, amount),
                "fromType": fromAccount,
                "toType": toAccount,
            }
            var clientOrderId interface{} = nil
            clientOrderIdparamsVariable := this.HandleOptionAndParams(params, "transfer", "clientOrderId");
            clientOrderId = GetValue(clientOrderIdparamsVariable,0);
            params = GetValue(clientOrderIdparamsVariable,1)
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                AddElementToObject(request, "clientOid", clientOrderId)
            }
        
            response:= (<-this.PrivatePostApiSpotV1WalletTransferV2(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1726664727436,
            //         "data": {
            //             "transferId": "1220285801129066496",
            //             "clientOrderId": null
            //         }
            //     }
            //
        ch <- this.ParseTransfer(response, currency)
            return nil
        
            }()
            return ch
        }
func  (this *coincatch) ParseTransfer(transfer interface{}, optionalArgs ...interface{}) interface{}  {
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var msg interface{} = this.SafeString(transfer, "msg")
    var status interface{} = nil
    if IsTrue(IsEqual(msg, "success")) {
        status = "ok"
    }
    var data interface{} = this.SafeDict(transfer, "data", map[string]interface{} {})
    return map[string]interface{} {
        "id": this.SafeString(data, "transferId"),
        "timestamp": nil,
        "datetime": nil,
        "currency": this.SafeCurrencyCode(nil, currency),
        "amount": nil,
        "fromAccount": nil,
        "toAccount": nil,
        "status": status,
        "info": transfer,
    }
}
/**
 * @method
 * @name coincatch#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account
 * @see https://coincatch.github.io/github.io/en/spot/#get-coin-address
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.network] network for fetch deposit address
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *coincatch) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes19788 := (<-this.LoadMarkets())
            PanicOnError(retRes19788)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "coin": GetValue(currency, "id"),
            }
            var networkCode interface{} = nil
            networkCodeparamsVariable := this.HandleNetworkCodeAndParams(params);
            networkCode = GetValue(networkCodeparamsVariable,0);
            params = GetValue(networkCodeparamsVariable,1)
            if IsTrue(IsEqual(networkCode, nil)) {
                networkCode = this.DefaultNetworkCode(code)
            }
            if IsTrue(IsEqual(networkCode, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchDepositAddress() requires a network parameter or a default network code")))
            }
            AddElementToObject(request, "chain", this.NetworkCodeToId(networkCode, code))
        
            response:= (<-this.PrivateGetApiSpotV1WalletDepositAddress(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1725210515143,
            //         "data": {
            //             "coin": "USDT",
            //             "address": "TKTUt7qiTaMgnTwZXjE3ZBkPB6LKhLPJyZ",
            //             "chain": "TRC20",
            //             "tag": null,
            //             "url": "https://tronscan.org/#/transaction/"
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var depositAddress interface{} = this.ParseDepositAddress(data, currency)
        
            ch <- depositAddress
            return nil
        
            }()
            return ch
        }
func  (this *coincatch) ParseDepositAddress(depositAddress interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "coin": "USDT",
    //         "address": "TKTUt7qiTaMgnTwZXjE3ZBkPB6LKhLPJyZ",
    //         "chain": "TRC20",
    //         "tag": null,
    //         "url": "https://tronscan.org/#/transaction/"
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var address interface{} = this.SafeString(depositAddress, "address")
    this.CheckAddress(address)
    var networkId interface{} = this.SafeString(depositAddress, "chain")
    var network interface{} = this.SafeString(GetValue(this.Options, "networksById"), networkId, networkId)
    var tag interface{} = this.SafeString(depositAddress, "tag")
    return map[string]interface{} {
        "currency": GetValue(currency, "code"),
        "address": address,
        "tag": tag,
        "network": network,
        "info": depositAddress,
    }
}
/**
 * @method
 * @name coincatch#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://coincatch.github.io/github.io/en/spot/#get-deposit-list
 * @param {string} code unified currency code of the currency transferred
 * @param {int} [since] the earliest time in ms to fetch transfers for (default 24 hours ago)
 * @param {int} [limit] the maximum number of transfer structures to retrieve (not used by exchange)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch transfers for (default time now)
 * @param {int} [params.pageNo] pageNo default 1
 * @param {int} [params.pageSize] pageSize (default 20, max 100)
 * @returns {object[]} a list of [transfer structures]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func  (this *coincatch) FetchDeposits(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var methodName interface{} = "fetchDeposits"
        
            retRes20528 := (<-this.LoadMarkets())
            PanicOnError(retRes20528)
            var request interface{} = map[string]interface{} {}
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "coin", GetValue(currency, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            var until interface{} = nil
            untilparamsVariable := this.HandleOptionAndParams(params, methodName, "until");
            until = GetValue(untilparamsVariable,0);
            params = GetValue(untilparamsVariable,1)
            if IsTrue(!IsEqual(until, nil)) {
                AddElementToObject(request, "endTime", until)
            }
        
            response:= (<-this.PrivateGetApiSpotV1WalletDepositList(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1725205525239,
            //         "data": [
            //             {
            //                 "id": "1213046466852196352",
            //                 "txId": "824246b030cd84d56400661303547f43a1d9fef66cf968628dd5112f362053ff",
            //                 "coin": "USDT",
            //                 "type": "deposit",
            //                 "amount": "99.20000000",
            //                 "status": "success",
            //                 "toAddress": "TKTUt7qiTaMgnTwZXjE3ZBkPB6LKhLPJyZ",
            //                 "fee": null,
            //                 "chain": "TRX(TRC20)",
            //                 "confirm": null,
            //                 "clientOid": null,
            //                 "tag": null,
            //                 "fromAddress": null,
            //                 "dest": "on_chain",
            //                 "cTime": "1724938735688",
            //                 "uTime": "1724938746015"
            //             }
            //         ]
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTransactions(data, currency, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coincatch#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @see https://coincatch.github.io/github.io/en/spot/#get-withdraw-list-v2
 * @param {string} code unified currency code of the currency transferred
 * @param {int} [since] the earliest time in ms to fetch transfers for (default 24 hours ago)
 * @param {int} [limit] the maximum number of transfer structures to retrieve (default 50, max 200)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch transfers for (default time now)
 * @param {string} [params.clientOid] clientOid
 * @param {string} [params.orderId] The response orderId
 * @param {string} [params.idLessThan] Requests the content on the page before this ID (older data), the value input should be the orderId of the corresponding interface.
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *coincatch) FetchWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var methodName interface{} = "fetchWithdrawals"
        
            retRes21168 := (<-this.LoadMarkets())
            PanicOnError(retRes21168)
            var request interface{} = map[string]interface{} {}
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "coin", GetValue(currency, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            var until interface{} = nil
            untilparamsVariable := this.HandleOptionAndParams(params, methodName, "until");
            until = GetValue(untilparamsVariable,0);
            params = GetValue(untilparamsVariable,1)
            if IsTrue(!IsEqual(until, nil)) {
                AddElementToObject(request, "endTime", until)
            }
        
            response:= (<-this.PrivateGetApiSpotV1WalletWithdrawalListV2(this.Extend(request, params)))
            PanicOnError(response)
            // todo add after withdrawal
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTransactions(data, currency, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coincatch#withdraw
 * @description make a withdrawal
 * @see https://coincatch.github.io/github.io/en/spot/#withdraw
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} [tag]
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} params.network network for withdraw (mandatory)
 * @param {string} [params.remark] remark
 * @param {string} [params.clientOid] custom id
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *coincatch) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params);
            tag = GetValue(tagparamsVariable,0);
            params = GetValue(tagparamsVariable,1)
        
            retRes21588 := (<-this.LoadMarkets())
            PanicOnError(retRes21588)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "coin": GetValue(currency, "id"),
                "address": address,
                "amount": amount,
            }
            if IsTrue(!IsEqual(tag, nil)) {
                AddElementToObject(request, "tag", tag)
            }
            var networkCode interface{} = nil
            networkCodeparamsVariable := this.HandleNetworkCodeAndParams(params);
            networkCode = GetValue(networkCodeparamsVariable,0);
            params = GetValue(networkCodeparamsVariable,1)
            if IsTrue(!IsEqual(networkCode, nil)) {
                AddElementToObject(request, "chain", this.NetworkCodeToId(networkCode))
            }
        
            response:= (<-this.PrivatePostApiSpotV1WalletWithdrawalV2(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "data": {
            //             "orderId":888291686266343424",
            //             "clientOrderId":"123"
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseTransaction(data, currency)
            return nil
        
            }()
            return ch
        }
func  (this *coincatch) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchDeposits
    //
    //     {
    //         "id": "1213046466852196352",
    //         "txId": "824246b030cd84d56400661303547f43a1d9fef66cf968628dd5112f362053ff",
    //         "coin": "USDT",
    //         "type": "deposit",
    //         "amount": "99.20000000",
    //         "status": "success",
    //         "toAddress": "TKTUt7qiTaMgnTwZXjE3ZBkPB6LKhLPJyZ",
    //         "fee": null,
    //         "chain": "TRX(TRC20)",
    //         "confirm": null,
    //         "clientOid": null,
    //         "tag": null,
    //         "fromAddress": null,
    //         "dest": "on_chain",
    //         "cTime": "1724938735688",
    //         "uTime": "1724938746015"
    //     }
    //
    // withdraw
    //
    //     {
    //         "code": "00000",
    //         "msg": "success",
    //         "data": {
    //             "orderId":888291686266343424",
    //             "clientOrderId":"123"
    //         }
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var status interface{} = this.SafeString(transaction, "status")
    if IsTrue(IsEqual(status, "success")) {
        status = "ok"
    }
    var txid interface{} = this.SafeString(transaction, "txId")
    var coin interface{} = this.SafeString(transaction, "coin")
    var code interface{} = this.SafeCurrencyCode(coin, currency)
    var timestamp interface{} = this.SafeInteger(transaction, "cTime")
    var amount interface{} = this.SafeNumber(transaction, "amount")
    var networkId interface{} = this.SafeString(transaction, "chain")
    var network interface{} = this.SafeString(GetValue(this.Options, "networksById"), networkId, networkId)
    var addressTo interface{} = this.SafeString(transaction, "toAddress")
    var addressFrom interface{} = this.SafeString(transaction, "fromAddress")
    var tag interface{} = this.SafeString(transaction, "tag")
    var typeVar interface{} = this.SafeString(transaction, "type")
    var feeCost interface{} = this.SafeNumber(transaction, "fee")
    var fee interface{} = nil
    if IsTrue(!IsEqual(feeCost, nil)) {
        fee = map[string]interface{} {
            "cost": feeCost,
            "currency": code,
        }
    }
    return map[string]interface{} {
        "info": transaction,
        "id": this.SafeString2(transaction, "id", "orderId"),
        "txid": txid,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "network": network,
        "address": nil,
        "addressTo": addressTo,
        "addressFrom": addressFrom,
        "tag": tag,
        "tagTo": nil,
        "tagFrom": nil,
        "type": typeVar,
        "amount": amount,
        "currency": code,
        "status": status,
        "updated": nil,
        "internal": nil,
        "comment": nil,
        "fee": fee,
    }
}
/**
 * @method
 * @name coincatch#createMarketBuyOrderWithCost
 * @description create a market buy order by providing the symbol and cost
 * @see https://coincatch.github.io/github.io/en/spot/#place-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {float} cost how much you want to trade in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coincatch) CreateMarketBuyOrderWithCost(symbol interface{}, cost interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes22808 := (<-this.LoadMarkets())
            PanicOnError(retRes22808)
            var methodName interface{} = "createMarketBuyOrderWithCost"
            var market interface{} = this.Market(symbol)
            if !IsTrue(GetValue(market, "spot")) {
                panic(NotSupported(Add(Add(Add(this.Id, " "), methodName), "() supports spot orders only")))
            }
            AddElementToObject(params, "methodName", methodName)
            AddElementToObject(params, "createMarketBuyOrderRequiresPrice", false)
        
                retRes228815 :=  (<-this.CreateOrder(symbol, "market", "buy", cost, nil, params))
                PanicOnError(retRes228815)
                ch <- retRes228815
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coincatch#createOrder
 * @description create a trade order
 * @see https://coincatch.github.io/github.io/en/spot/#place-order
 * @see https://coincatch.github.io/github.io/en/spot/#place-plan-order
 * @see https://coincatch.github.io/github.io/en/mix/#place-order
 * @see https://coincatch.github.io/github.io/en/mix/#place-plan-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit' or 'LIMIT_MAKER' for spot, 'market' or 'limit' or 'STOP' for swap
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of you want to trade in units of the base currency
 * @param {float} [price] the price that the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {float} [params.cost] *spot market buy only* the quote quantity that can be used as an alternative for the amount
 * @param {float} [params.triggerPrice] the price that the order is to be triggered
 * @param {bool} [params.postOnly] if true, the order will only be posted to the order book and not executed immediately
 * @param {string} [params.timeInForce] 'GTC', 'IOC', 'FOK' or 'PO'
 * @param {string} [params.clientOrderId] a unique id for the order - is mandatory for swap
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coincatch) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes23138 := (<-this.LoadMarkets())
            PanicOnError(retRes23138)
            AddElementToObject(params, "methodName", this.SafeString(params, "methodName", "createOrder"))
            var market interface{} = this.Market(symbol)
            if IsTrue(GetValue(market, "spot")) {
        
                    retRes231719 :=  (<-this.CreateSpotOrder(symbol, typeVar, side, amount, price, params))
                    PanicOnError(retRes231719)
                    ch <- retRes231719
                    return nil
            } else if IsTrue(GetValue(market, "swap")) {
        
                    retRes231919 :=  (<-this.CreateSwapOrder(symbol, typeVar, side, amount, price, params))
                    PanicOnError(retRes231919)
                    ch <- retRes231919
                    return nil
            } else {
                panic(NotSupported(Add(Add(Add(this.Id, " createOrder() is not supported for "), GetValue(market, "type")), " type of markets")))
            }
                return nil
            }()
            return ch
        }
/**
 * @method
 * @name coincatch#createSpotOrder
 * @description create a trade order on spot market
 * @see https://coincatch.github.io/github.io/en/spot/#place-order
 * @see https://coincatch.github.io/github.io/en/spot/#place-plan-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of you want to trade in units of the base currency
 * @param {float} [price] the price that the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {float} [params.cost] *market buy only* the quote quantity that can be used as an alternative for the amount
 * @param {float} [params.triggerPrice] the price that the order is to be triggered at
 * @param {bool} [params.postOnly] if true, the order will only be posted to the order book and not executed immediately
 * @param {string} [params.timeInForce] 'GTC', 'IOC', 'FOK' or 'PO'
 * @param {string} [params.clientOrderId] a unique id for the order (max length 40)
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coincatch) CreateSpotOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes23458 := (<-this.LoadMarkets())
            PanicOnError(retRes23458)
            AddElementToObject(params, "methodName", this.SafeString(params, "methodName", "createSpotOrder"))
            var request interface{} = this.CreateSpotOrderRequest(symbol, typeVar, side, amount, price, params)
            var isPlanOrer interface{} = !IsEqual(this.SafeString(request, "triggerPrice"), nil)
            var response interface{} = nil
            if IsTrue(isPlanOrer) {
                
        response = (<-this.PrivatePostApiSpotV1PlanPlacePlan(request))
                PanicOnError(response)
            } else {
                //
                //     {
                //         "code": "00000",
                //         "msg": "success",
                //         "requestTime": 1725915469815,
                //         "data": {
                //             "orderId": "1217143186968068096",
                //             "clientOrderId": "8fa3eb89-2377-4519-a199-35d5db9ed262"
                //         }
                //     }
                //
                
        response = (<-this.PrivatePostApiSpotV1TradeOrders(request))
                PanicOnError(response)
            }
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var market interface{} = this.Market(symbol)
        
            ch <- this.ParseOrder(data, market)
            return nil
        
            }()
            return ch
        }
func  (this *coincatch) CreateSpotOrderRequest(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @ignore
    * @name coincatch#createSpotOrderRequest
    * @description helper function to build request
    * @param {string} symbol unified symbol of the market to create an order in
    * @param {string} type 'market' or 'limit'
    * @param {string} side 'buy' or 'sell'
    * @param {float} amount how much of you want to trade in units of the base currency
    * @param {float} [price] the price that the order is to be fulfilled, in units of the quote currency, ignored in market orders
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @param {float} [params.triggerPrice] the price that the order is to be triggered at
    * @param {float} [params.cost] *market buy only* the quote quantity that can be used as an alternative for the amount
    * @param {bool} [params.postOnly] if true, the order will only be posted to the order book and not executed immediately
    * @param {string} [params.timeInForce] 'GTC', 'IOC', 'FOK' or 'PO' (default 'GTC')
    * @param {string} [params.clientOrderId] a unique id for the order (max length 40)
    * @returns {object} request to be sent to the exchange
    */
    price := GetArg(optionalArgs, 0, nil)
    _ = price
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    var methodName interface{} = "createSpotOrderRequest"
    // spot market info has no presicion so we do not use it
    methodNameparamsVariable := this.HandleParamString(params, "methodName", methodName);
    methodName = GetValue(methodNameparamsVariable,0);
    params = GetValue(methodNameparamsVariable,1)
    var market interface{} = this.Market(symbol)
    var request interface{} = map[string]interface{} {
        "symbol": GetValue(market, "id"),
        "side": side,
        "orderType": typeVar,
    }
    var isMarketOrder interface{} =     (IsEqual(typeVar, "market"))
    var timeInForceAndParams interface{} = this.HandleTimeInForceAndPostOnly(methodName, params, isMarketOrder)
    params = GetValue(timeInForceAndParams, "params")
    var timeInForce interface{} = GetValue(timeInForceAndParams, "timeInForce")
    var cost interface{} = nil
    costparamsVariable := this.HandleParamString(params, "cost");
    cost = GetValue(costparamsVariable,0);
    params = GetValue(costparamsVariable,1)
    var triggerPrice interface{} = nil
    triggerPriceparamsVariable := this.HandleParamString(params, "triggerPrice");
    triggerPrice = GetValue(triggerPriceparamsVariable,0);
    params = GetValue(triggerPriceparamsVariable,1)
    var isMarketBuy interface{} = IsTrue(isMarketOrder) && IsTrue((IsEqual(side, "buy")))
    if IsTrue(IsTrue((!IsTrue(isMarketBuy))) && IsTrue((!IsEqual(cost, nil)))) {
        panic(NotSupported(Add(Add(Add(this.Id, " "), methodName), " supports cost parameter for market buy orders only")))
    }
    if IsTrue(isMarketBuy) {
        var costAndParams interface{} = this.HandleRequiresPriceAndCost(methodName, params, price, amount, cost)
        cost = GetValue(costAndParams, "cost")
        params = GetValue(costAndParams, "params")
    }
    if IsTrue(IsEqual(triggerPrice, nil)) {
        if IsTrue(IsEqual(typeVar, "limit")) {
            AddElementToObject(request, "price", price) // spot markets have no precision
        }
        AddElementToObject(request, "quantity", Ternary(IsTrue(isMarketBuy), cost, this.NumberToString(amount))) // spot markets have no precision
        AddElementToObject(request, "force", Ternary(IsTrue(timeInForce), timeInForce, "normal")) // the exchange requres force but accepts any value
    } else {
        AddElementToObject(request, "triggerPrice", triggerPrice) // spot markets have no precision
        if IsTrue(!IsEqual(timeInForce, nil)) {
            AddElementToObject(request, "timeInForceValue", timeInForce)
        }
        var clientOrderId interface{} = nil
        clientOrderIdparamsVariable := this.HandleParamString(params, "clientOrderId");
        clientOrderId = GetValue(clientOrderIdparamsVariable,0);
        params = GetValue(clientOrderIdparamsVariable,1)
        if IsTrue(!IsEqual(clientOrderId, nil)) {
            AddElementToObject(request, "clientOid", clientOrderId)
        }
        if IsTrue(IsEqual(typeVar, "limit")) {
            AddElementToObject(request, "executePrice", price) // spot markets have no precision
        }
        var triggerType interface{} = nil
        if IsTrue(isMarketOrder) {
            triggerType = "market_price"
        } else {
            triggerType = "fill_price"
        }
        AddElementToObject(request, "triggerType", triggerType)
        // tood check placeType
        AddElementToObject(request, "size", Ternary(IsTrue(isMarketOrder), cost, this.NumberToString(amount))) // spot markets have no precision
    }
    return this.Extend(request, params)
}
func  (this *coincatch) HandleRequiresPriceAndCost(methodName interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    price := GetArg(optionalArgs, 1, nil)
    _ = price
    amount := GetArg(optionalArgs, 2, nil)
    _ = amount
    cost := GetArg(optionalArgs, 3, nil)
    _ = cost
    side := GetArg(optionalArgs, 4, "buy")
    _ = side
    var optionName interface{} = Add(Add("createMarket", this.Capitalize(side)), "OrderRequiresPrice")
    var requiresPrice interface{} = true
    requiresPriceparamsVariable := this.HandleOptionAndParams(params, methodName, optionName, true);
    requiresPrice = GetValue(requiresPriceparamsVariable,0);
    params = GetValue(requiresPriceparamsVariable,1)
    var amountString interface{} = nil
    if IsTrue(!IsEqual(amount, nil)) {
        amountString = this.NumberToString(amount)
    }
    var priceString interface{} = nil
    if IsTrue(!IsEqual(price, nil)) {
        priceString = this.NumberToString(price)
    }
    if IsTrue(requiresPrice) {
        if IsTrue(IsTrue((IsEqual(price, nil))) && IsTrue((IsEqual(cost, nil)))) {
            panic(InvalidOrder(Add(Add(Add(Add(Add(Add(Add(this.Id, " "), methodName), "() requires the price argument for market "), side), " orders to calculate the total cost to spend (amount * price), alternatively set the "), optionName), " option or param to false and pass the cost to spend in the amount argument")))
        } else if IsTrue(IsEqual(cost, nil)) {
            cost = Precise.StringMul(amountString, priceString)
        }
    } else {
        cost = Ternary(IsTrue(cost), cost, amountString)
    }
    var result interface{} = map[string]interface{} {
        "cost": cost,
        "params": params,
    }
    return result
}
func  (this *coincatch) HandleTimeInForceAndPostOnly(methodName interface{}, optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    isMarketOrder := GetArg(optionalArgs, 1, false)
    _ = isMarketOrder
    var timeInForce interface{} = nil
    timeInForceparamsVariable := this.HandleOptionAndParams(params, methodName, "timeInForce");
    timeInForce = GetValue(timeInForceparamsVariable,0);
    params = GetValue(timeInForceparamsVariable,1)
    var postOnly interface{} = false
    postOnlyparamsVariable := this.HandlePostOnly(isMarketOrder, IsEqual(timeInForce, "post_only"), params);
    postOnly = GetValue(postOnlyparamsVariable,0);
    params = GetValue(postOnlyparamsVariable,1)
    if IsTrue(postOnly) {
        timeInForce = "PO"
    }
    timeInForce = this.EncodeTimeInForce(timeInForce)
    var result interface{} = map[string]interface{} {
        "timeInForce": timeInForce,
        "params": params,
    }
    return result
}
/**
 * @method
 * @name coincatch#createSwapOrder
 * @description create a trade order on swap market
 * @see https://coincatch.github.io/github.io/en/mix/#place-order
 * @see https://coincatch.github.io/github.io/en/mix/#place-plan-order
 * @see https://coincatch.github.io/github.io/en/mix/#place-stop-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of you want to trade in units of the base currency
 * @param {float} [price] the price that the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {bool} [params.postOnly] *non-trigger orders only* if true, the order will only be posted to the order book and not executed immediately
 * @param {bool} [params.reduceOnly] true or false whether the order is reduce only
 * @param {string} [params.timeInForce] *non-trigger orders only* 'GTC', 'FOK', 'IOC' or 'PO'
 * @param {string} [params.clientOrderId] a unique id for the order
 * @param {float} [params.triggerPrice] the price that the order is to be triggered at
 * @param {float} [params.stopLossPrice] The price at which a stop loss order is triggered at
 * @param {float} [params.takeProfitPrice] The price at which a take profit order is triggered at
 * @param {object} [params.takeProfit] *takeProfit object in params* containing the triggerPrice at which the attached take profit order will be triggered (perpetual swap markets only)
 * @param {float} [params.takeProfit.triggerPrice] take profit trigger price
 * @param {object} [params.stopLoss] *stopLoss object in params* containing the triggerPrice at which the attached stop loss order will be triggered (perpetual swap markets only)
 * @param {float} [params.stopLoss.triggerPrice] stop loss trigger price
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coincatch) CreateSwapOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            AddElementToObject(params, "methodName", this.SafeString(params, "methodName", "createSwapOrder"))
        
            retRes25208 := (<-this.LoadMarkets())
            PanicOnError(retRes25208)
            var market interface{} = this.Market(symbol)
            var request interface{} = this.CreateSwapOrderRequest(symbol, typeVar, side, amount, price, params)
            var endpointType interface{} = this.SafeString(request, "endpointType")
            request = this.Omit(request, "endpointType")
            var response interface{} = nil
            if IsTrue(IsEqual(endpointType, "trigger")) {
                
        response = (<-this.PrivatePostApiMixV1PlanPlacePlan(request))
                PanicOnError(response)
            } else if IsTrue(IsEqual(endpointType, "tpsl")) {
                
        response = (<-this.PrivatePostApiMixV1PlanPlaceTPSL(request))
                PanicOnError(response)
            } else {
                
        response = (<-this.PrivatePostApiMixV1OrderPlaceOrder(request))
                PanicOnError(response)
            }
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1727977301979,
            //         "data":
            //         {
            //             "clientOid": "1225791137701519360",
            //             "orderId": "1225791137697325056"
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseOrder(data, market)
            return nil
        
            }()
            return ch
        }
func  (this *coincatch) CreateSwapOrderRequest(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @ignore
    * @name coincatch#createSwapOrderRequest
    * @description helper function to build request
    * @param {string} symbol unified symbol of the market to create an order in
    * @param {string} type 'market' or 'limit'
    * @param {string} side 'buy' or 'sell'
    * @param {float} amount how much of you want to trade in units of the base currency
    * @param {float} [price] the price that the order is to be fulfilled, in units of the quote currency, ignored in market orders
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @param {bool} [params.hedged] default false
    * @param {bool} [params.postOnly] *non-trigger orders only* if true, the order will only be posted to the order book and not executed immediately
    * @param {bool} [params.reduceOnly] true or false whether the order is reduce only
    * @param {string} [params.timeInForce] *non-trigger orders only* 'GTC', 'FOK', 'IOC' or 'PO'
    * @param {string} [params.clientOrderId] a unique id for the order
    * @param {float} [params.triggerPrice] the price that the order is to be triggered at
    * @param {float} [params.stopLossPrice] The price at which a stop loss order is triggered at
    * @param {float} [params.takeProfitPrice] The price at which a take profit order is triggered at
    * @param {object} [params.takeProfit] *takeProfit object in params* containing the triggerPrice at which the attached take profit order will be triggered (perpetual swap markets only)
    * @param {float} [params.takeProfit.triggerPrice] take profit trigger price
    * @param {object} [params.stopLoss] *stopLoss object in params* containing the triggerPrice at which the attached stop loss order will be triggered (perpetual swap markets only)
    * @param {float} [params.stopLoss.triggerPrice] stop loss trigger price
    * @returns {object} request to be sent to the exchange
    */
    price := GetArg(optionalArgs, 0, nil)
    _ = price
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    var methodName interface{} = "createSwapOrderRequest"
    methodNameparamsVariable := this.HandleParamString(params, "methodName", methodName);
    methodName = GetValue(methodNameparamsVariable,0);
    params = GetValue(methodNameparamsVariable,1)
    var market interface{} = this.Market(symbol)
    var request interface{} = map[string]interface{} {
        "symbol": GetValue(market, "id"),
        "marginCoin": GetValue(market, "settleId"),
        "size": this.AmountToPrecision(symbol, amount),
    }
    requestparamsVariable := this.HandleOptionParamsAndRequest(params, methodName, "clientOrderId", request, "clientOid");
    request = GetValue(requestparamsVariable,0);
    params = GetValue(requestparamsVariable,1)
    var isMarketOrder interface{} =     (IsEqual(typeVar, "market"))
    params = this.HandleTriggerStopLossAndTakeProfit(symbol, side, typeVar, price, methodName, params)
    var endpointType interface{} = this.SafeString(params, "endpointType")
    if IsTrue(IsTrue((IsEqual(endpointType, nil))) || IsTrue((IsEqual(endpointType, "standard")))) {
        var timeInForceAndParams interface{} = this.HandleTimeInForceAndPostOnly(methodName, params, isMarketOrder) // only for non-trigger orders
        params = GetValue(timeInForceAndParams, "params")
        var timeInForce interface{} = GetValue(timeInForceAndParams, "timeInForce")
        if IsTrue(!IsEqual(timeInForce, nil)) {
            AddElementToObject(request, "timeInForceValue", timeInForce)
        }
        if IsTrue(!IsEqual(price, nil)) {
            AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
        }
    }
    if IsTrue((!IsEqual(endpointType, "tpsl"))) {
        AddElementToObject(request, "orderType", typeVar)
        var hedged interface{} = false
        hedgedparamsVariable := this.HandleOptionAndParams(params, methodName, "hedged", hedged);
        hedged = GetValue(hedgedparamsVariable,0);
        params = GetValue(hedgedparamsVariable,1)
        // hedged and non-hedged orders have different side values and reduceOnly handling
        var reduceOnly interface{} = false
        reduceOnlyparamsVariable := this.HandleParamBool(params, "reduceOnly", reduceOnly);
        reduceOnly = GetValue(reduceOnlyparamsVariable,0);
        params = GetValue(reduceOnlyparamsVariable,1)
        if IsTrue(hedged) {
            if IsTrue(reduceOnly) {
                if IsTrue(IsEqual(side, "buy")) {
                    side = "close_short"
                } else if IsTrue(IsEqual(side, "sell")) {
                    side = "close_long"
                }
            } else {
                if IsTrue(IsEqual(side, "buy")) {
                    side = "open_long"
                } else if IsTrue(IsEqual(side, "sell")) {
                    side = "open_short"
                }
            }
        } else {
            side = Add(ToLower(side), "_single")
        }
        AddElementToObject(request, "side", side)
    }
    return this.Extend(request, params)
}
func  (this *coincatch) HandleTriggerStopLossAndTakeProfit(symbol interface{}, side interface{}, typeVar interface{}, price interface{}, optionalArgs ...interface{}) interface{}  {
    methodName := GetArg(optionalArgs, 0, "createOrder")
    _ = methodName
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    var request interface{} = map[string]interface{} {}
    var endpointType interface{} = "standard" // standard, trigger, tpsl, trailing - to define the endpoint to use
    var stopLossPrice interface{} = this.SafeString(params, "stopLossPrice")
    var takeProfitPrice interface{} = this.SafeString(params, "takeProfitPrice")
    var requestTriggerPrice interface{} = nil
    var takeProfitParams interface{} = this.SafeDict(params, "takeProfit")
    var stopLossParams interface{} = this.SafeDict(params, "stopLoss")
    var triggerPrice interface{} = this.SafeString2(params, "triggerPrice", "stopPrice")
    var isTrigger interface{} =     (!IsEqual(triggerPrice, nil))
    var trailingPercent interface{} = this.SafeString(params, "trailingPercent")
    var trailingTriggerPrice interface{} = this.SafeString(params, "trailingTriggerPrice")
    var hasTPPrice interface{} =     (!IsEqual(takeProfitPrice, nil))
    var hasSLPrice interface{} =     (!IsEqual(stopLossPrice, nil))
    var hasTPParams interface{} =     (!IsEqual(takeProfitParams, nil))
    if IsTrue(IsTrue(hasTPParams) && !IsTrue(hasTPPrice)) {
        takeProfitPrice = this.SafeString(takeProfitParams, "triggerPrice")
        hasTPPrice = (!IsEqual(takeProfitPrice, nil))
    }
    var hasSLParams interface{} =     (!IsEqual(stopLossParams, nil))
    if IsTrue(IsTrue(hasSLParams) && !IsTrue(hasSLPrice)) {
        stopLossPrice = this.SafeString(stopLossParams, "triggerPrice")
        hasSLPrice = (!IsEqual(stopLossPrice, nil))
    }
    var hasBothTPAndSL interface{} = IsTrue(hasTPPrice) && IsTrue(hasSLPrice)
    var isTrailingPercentOrder interface{} =     (!IsEqual(trailingPercent, nil))
    var isMarketOrder interface{} =     (IsEqual(typeVar, "market"))
    // handle with triggerPrice stopLossPrice and takeProfitPrice
    if IsTrue(IsTrue(IsTrue(hasBothTPAndSL) || IsTrue(isTrigger)) || IsTrue((IsEqual(methodName, "createOrderWithTakeProfitAndStopLoss")))) {
        if IsTrue(isTrigger) {
            if IsTrue(isMarketOrder) {
                AddElementToObject(request, "triggerType", "market_price")
            } else {
                AddElementToObject(request, "triggerType", "fill_price")
                AddElementToObject(request, "executePrice", this.PriceToPrecision(symbol, price))
            }
            AddElementToObject(request, "triggerPrice", this.PriceToPrecision(symbol, triggerPrice))
            endpointType = "trigger" // if order also has triggerPrice we use endpoint for trigger orders
        }
        if IsTrue(IsEqual(methodName, "createOrders")) {
            endpointType = nil // we do not provide endpointType for createOrders
        }
        if IsTrue(hasTPPrice) {
            AddElementToObject(request, "presetTakeProfitPrice", takeProfitPrice)
        }
        if IsTrue(hasSLPrice) {
            AddElementToObject(request, "presetStopLossPrice", stopLossPrice)
        }
    } else if IsTrue(IsTrue(IsTrue(hasTPPrice) || IsTrue(hasSLPrice)) || IsTrue(isTrailingPercentOrder)) {
        if !IsTrue(isMarketOrder) {
            panic(NotSupported(Add(Add(Add(Add(Add(this.Id, " "), methodName), "() supports does not support "), typeVar), " type of stop loss and take profit orders (only market type is supported for stop loss and take profit orders). To create a market order with stop loss or take profit attached use createOrderWithTakeProfitAndStopLoss()")))
        }
        endpointType = "tpsl" // if order has only one of the two we use endpoint for tpsl orders
        var holdSide interface{} = "long"
        if IsTrue(IsEqual(side, "buy")) {
            holdSide = "short"
        }
        AddElementToObject(request, "holdSide", holdSide)
        if IsTrue(isTrailingPercentOrder) {
            if IsTrue(IsEqual(trailingTriggerPrice, nil)) {
                panic(ArgumentsRequired(Add(Add(Add(this.Id, " "), methodName), "() requires the trailingTriggerPrice parameter for trailing stop orders")))
            }
            requestTriggerPrice = trailingTriggerPrice
            AddElementToObject(request, "rangeRate", trailingPercent)
            AddElementToObject(request, "planType", "moving_plan")
        } else if IsTrue(hasTPPrice) {
            requestTriggerPrice = takeProfitPrice
            AddElementToObject(request, "planType", "profit_plan")
        } else {
            requestTriggerPrice = stopLossPrice
            AddElementToObject(request, "planType", "loss_plan")
        }
        AddElementToObject(request, "triggerPrice", this.PriceToPrecision(symbol, requestTriggerPrice))
    }
    if IsTrue(!IsEqual(endpointType, nil)) {
        AddElementToObject(request, "endpointType", endpointType)
    }
    params = this.Omit(params, []interface{}{"stopLoss", "takeProfit", "stopLossPrice", "takeProfitPrice", "triggerPrice", "stopPrice", "trailingPercent", "trailingTriggerPrice"})
    return this.Extend(request, params)
}
/**
 * @method
 * @name coincatch#createOrderWithTakeProfitAndStopLoss
 * @description *swap markets only* create an order with a stop loss or take profit attached (type 3)
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much you want to trade in units of the base currency or the number of contracts
 * @param {float} [price] the price to fulfill the order, in units of the quote currency, ignored in market orders
 * @param {float} [takeProfit] the take profit price, in units of the quote currency
 * @param {float} [stopLoss] the stop loss price, in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coincatch) CreateOrderWithTakeProfitAndStopLoss(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            takeProfit := GetArg(optionalArgs, 1, nil)
            _ = takeProfit
            stopLoss := GetArg(optionalArgs, 2, nil)
            _ = stopLoss
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var methodName interface{} = "createOrderWithTakeProfitAndStopLoss"
        
            retRes27248 := (<-this.LoadMarkets())
            PanicOnError(retRes27248)
            var market interface{} = this.Market(symbol)
            if !IsTrue(GetValue(market, "swap")) {
                panic(NotSupported(Add(Add(Add(this.Id, " "), methodName), "() is supported for swap markets only")))
            }
            AddElementToObject(params, "methodName", methodName)
        
            ch <- this.Exchange.CreateOrderWithTakeProfitAndStopLoss(symbol, typeVar, side, amount, price, takeProfit, stopLoss, params)
            return nil
        
            }()
            return ch
        }
func  (this *coincatch) EncodeTimeInForce(timeInForce interface{}) interface{}  {
    var timeInForceMap interface{} = map[string]interface{} {
        "GTC": "normal",
        "IOC": "iok",
        "FOK": "fok",
        "PO": "post_only",
    }
    return this.SafeString(timeInForceMap, timeInForce, timeInForce)
}
/**
 * @method
 * @name coincatch#createOrders
 * @description create a list of trade orders (all orders should be of the same symbol)
 * @see https://coincatch.github.io/github.io/en/spot/#batch-order
 * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params (max 50 entries)
 * @param {object} [params] extra parameters specific to the api endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coincatch) CreateOrders(orders interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes27538 := (<-this.LoadMarkets())
            PanicOnError(retRes27538)
            // same symbol for all orders
            var methodName interface{} = "createOrders"
            AddElementToObject(params, "methodName", methodName)
            var ordersRequests interface{} = []interface{}{}
            var symbols interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(orders)); i++ {
                var rawOrder interface{} = GetValue(orders, i)
                var symbol interface{} = this.SafeString(rawOrder, "symbol")
                AppendToArray(&symbols,symbol)
                var typeVar interface{} = this.SafeString(rawOrder, "type")
                var side interface{} = this.SafeString(rawOrder, "side")
                var amount interface{} = this.SafeNumber(rawOrder, "amount")
                var price interface{} = this.SafeNumber(rawOrder, "price")
                var orderParams interface{} = this.SafeDict(rawOrder, "params", map[string]interface{} {})
                var orderRequest interface{} = this.CreateOrderRequest(symbol, typeVar, side, amount, price, orderParams)
                var triggerPrice interface{} = this.SafeString(orderParams, "triggerPrice")
                if IsTrue(!IsEqual(triggerPrice, nil)) {
                    panic(NotSupported(Add(Add(Add(this.Id, " "), methodName), "() does not support trigger orders")))
                }
                var clientOrderId interface{} = this.SafeString(orderRequest, "clientOrderId")
                if IsTrue(IsEqual(clientOrderId, nil)) {
                    AddElementToObject(orderRequest, "clientOrderId", this.Uuid()) // both spot and swap endpoints require clientOrderId
                }
                AppendToArray(&ordersRequests,orderRequest)
            }
            symbols = this.Unique(symbols)
            var symbolsLength interface{} =     GetArrayLength(symbols)
            if IsTrue(!IsEqual(symbolsLength, 1)) {
                panic(BadRequest(Add(this.Id, " createOrders() requires all orders to be of the same symbol")))
            }
            var ordersSymbol interface{} = this.SafeString(symbols, 0)
            var market interface{} = this.Market(ordersSymbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var marketType interface{} = GetValue(market, "type")
            var response interface{} = nil
            var responseOrders interface{} = nil
            var propertyName interface{} = nil
            if IsTrue(IsEqual(marketType, "spot")) {
                AddElementToObject(request, "orderList", ordersRequests)
                
        response = (<-this.PrivatePostApiSpotV1TradeBatchOrders(this.Extend(request, params)))
                PanicOnError(response)
                //
                //     {
                //         "code": "00000",
                //         "msg": "success",
                //         "requestTime": 1726160718706,
                //         "data": {
                //             "resultList": [
                //                 {
                //                     "orderId": "1218171835238367232",
                //                     "clientOrderId": "28759338-ca10-42dd-8ac3-5183785ef60b"
                //                 }
                //             ],
                //             "failure": [
                //                 {
                //                     "orderId": "",
                //                     "clientOrderId": "ee2e67c9-47fc-4311-9cc1-737ec408d509",
                //                     "errorMsg": "The order price of eth_usdt cannot be less than 5.00% of the current price",
                //                     "errorCode": "43008"
                //                 },
                //                 {
                //                     "orderId": "",
                //                     "clientOrderId": "1af2defa-0c2d-4bb5-acb7-6feb6a86787a",
                //                     "errorMsg": "less than the minimum amount 1 USDT",
                //                     "errorCode": "45110"
                //                 }
                //             ]
                //         }
                //     }
                //
                propertyName = "resultList"
            } else if IsTrue(GetValue(market, "swap")) {
                AddElementToObject(request, "marginCoin", GetValue(market, "settleId"))
                AddElementToObject(request, "orderDataList", ordersRequests)
                
        response = (<-this.PrivatePostApiMixV1OrderBatchOrders(this.Extend(request, params)))
                PanicOnError(response)
                //
                //     {
                //         "code": "00000",
                //         "msg": "success",
                //         "requestTime": 1729100084017,
                //         "data": {
                //             "orderInfo": [
                //                 {
                //                     "orderId": "1230500426827522049",
                //                     "clientOid": "1230500426898825216"
                //                 }
                //             ],
                //             "failure": [
                //                 {
                //                     "orderId": "",
                //                     "clientOid": null,
                //                     "errorMsg": "The order price exceeds the maximum price limit: 2,642.53",
                //                     "errorCode": "22047"
                //                 }
                //             ],
                //             "result": true
                //         }
                //     }
                //
                propertyName = "orderInfo"
            } else {
                panic(NotSupported(Add(Add(Add(Add(Add(this.Id, " "), methodName), "() is not supported for "), marketType), " type of markets")))
            }
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            responseOrders = this.SafeList(data, propertyName, []interface{}{})
        
            ch <- this.ParseOrders(responseOrders)
            return nil
        
            }()
            return ch
        }
func  (this *coincatch) CreateOrderRequest(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    price := GetArg(optionalArgs, 0, nil)
    _ = price
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    var methodName interface{} = this.SafeString(params, "methodName", "createOrderRequest")
    AddElementToObject(params, "methodName", methodName)
    var market interface{} = this.Market(symbol)
    if IsTrue(GetValue(market, "spot")) {
        return this.CreateSpotOrderRequest(symbol, typeVar, side, amount, price, params)
    } else if IsTrue(GetValue(market, "swap")) {
        return this.CreateSwapOrderRequest(symbol, typeVar, side, amount, price, params)
    } else {
        panic(NotSupported(Add(Add(Add(Add(Add(this.Id, " "), methodName), "() is not supported for "), GetValue(market, "type")), " type of markets")))
    }
}
/**
 * @method
 * @name coincatch#editOrder
 * @description edit a trade trigger, stop-looss or take-profit order
 * @see https://coincatch.github.io/github.io/en/spot/#modify-plan-order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coincatch) EditOrder(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    amount := GetArg(optionalArgs, 0, nil)
            _ = amount
            price := GetArg(optionalArgs, 1, nil)
            _ = price
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
            var methodName interface{} = "editOrder"
            // only trigger, stop-looss or take-profit orders can be edited
            AddElementToObject(params, "methodName", methodName)
        
            retRes28948 := (<-this.LoadMarkets())
            PanicOnError(retRes28948)
            var market interface{} = this.Market(symbol)
            if IsTrue(GetValue(market, "spot")) {
        
                    retRes289719 :=  (<-this.EditSpotOrder(id, symbol, typeVar, side, amount, price, params))
                    PanicOnError(retRes289719)
                    ch <- retRes289719
                    return nil
            } else {
                panic(NotSupported(Add(Add(Add(Add(Add(this.Id, " "), methodName), "() is not supported for "), GetValue(market, "type")), " type of markets")))
            }
                return nil
            }()
            return ch
        }
/**
 * @method
 * @name coincatch#editSpotOrder
 * @ignore
 * @description edit a trade order
 * @see https://coincatch.github.io/github.io/en/spot/#modify-plan-order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.clientOrderId] a unique id for the order that can be used as an alternative for the id
 * @param {string} params.triggerPrice *mandatory* the price that the order is to be triggered at
 * @param {float} [params.cost] *market buy only* the quote quantity that can be used as an alternative for the amount
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coincatch) EditSpotOrder(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes29238 := (<-this.LoadMarkets())
            PanicOnError(retRes29238)
            var methodName interface{} = "editSpotOrder"
            methodNameparamsVariable := this.HandleParamString(params, "methodName", methodName);
            methodName = GetValue(methodNameparamsVariable,0);
            params = GetValue(methodNameparamsVariable,1)
            var market interface{} = this.Market(symbol)
            if !IsTrue(GetValue(market, "spot")) {
                panic(NotSupported(Add(Add(Add(this.Id, " editSpotOrder() does not support "), GetValue(market, "type")), " orders")))
            }
            var request interface{} = map[string]interface{} {
                "orderType": typeVar,
            }
            var clientOrderId interface{} = this.SafeString(params, "clientOrderId")
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                AddElementToObject(request, "clientOid", clientOrderId)
            } else if IsTrue(IsEqual(id, nil)) {
                panic(BadRequest(Add(Add(Add(this.Id, " "), methodName), "() requires id or clientOrderId")))
            } else {
                AddElementToObject(request, "orderId", id)
            }
            var cost interface{} = nil
            costparamsVariable := this.HandleParamString(params, "cost");
            cost = GetValue(costparamsVariable,0);
            params = GetValue(costparamsVariable,1)
            var isMarketBuy interface{} = IsTrue((IsEqual(typeVar, "market"))) && IsTrue((IsEqual(side, "buy")))
            if IsTrue(IsTrue((!IsTrue(isMarketBuy))) && IsTrue((!IsEqual(cost, nil)))) {
                panic(NotSupported(Add(Add(Add(this.Id, " "), methodName), "() supports cost parameter for market buy orders only")))
            }
            if IsTrue(!IsEqual(amount, nil)) {
                if IsTrue(isMarketBuy) {
                    var costAndParams interface{} = this.HandleRequiresPriceAndCost(methodName, params, price, amount, cost)
                    cost = GetValue(costAndParams, "cost")
                    params = GetValue(costAndParams, "params")
                } else {
                    AddElementToObject(request, "size", this.NumberToString(amount)) // spot markets have no precision
                }
            }
            if IsTrue(!IsEqual(cost, nil)) {
                AddElementToObject(request, "size", cost) // spot markets have no precision
            }
            if IsTrue(IsTrue((IsEqual(typeVar, "limit"))) && IsTrue((!IsEqual(price, nil)))) {
                AddElementToObject(request, "price", price) // spot markets have no precision
            }
        
            response:= (<-this.PrivatePostApiSpotV1PlanModifyPlan(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1668136575920,
            //         "data": {
            //             "orderId": "974792060738441216",
            //             "clientOrderId": "974792554995224576"
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseOrder(data, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coincatch#fetchOrder
 * @description fetches information on an order made by the user (non-trigger orders only)
 * @see https://coincatch.github.io/github.io/en/spot/#get-order-details
 * @see https://coincatch.github.io/github.io/en/mix/#get-order-details
 * @param {string} id the order id
 * @param {string} symbol unified symbol of the market the order was made in (is mandatory for swap)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.type] 'spot' or 'swap' - the type of the market to fetch entry for (default 'spot')
 * @param {string} [params.clientOrderId] a unique id for the order that can be used as an alternative for the id
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coincatch) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var methodName interface{} = "fetchOrder"
            // for non-trigger orders only
        
            retRes29948 := (<-this.LoadMarkets())
            PanicOnError(retRes29948)
            var request interface{} = map[string]interface{} {}
            var clientOrderId interface{} = this.SafeString(params, "clientOrderId")
            if IsTrue(IsEqual(clientOrderId, nil)) {
                AddElementToObject(request, "orderId", id)
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var marketType interface{} = "spot"
            marketTypeparamsVariable := this.HandleMarketTypeAndParams(methodName, market, params, marketType);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            var response interface{} = nil
            var order interface{} = nil
            if IsTrue(IsEqual(marketType, "spot")) {
                // user could query cancelled/filled order details within 24 hours, After 24 hours should use fetchOrders
                
        response = (<-this.PrivatePostApiSpotV1TradeOrderInfo(this.Extend(request, params)))
                PanicOnError(response)
                //
                //     {
                //         "code": "00000",
                //         "msg": "success",
                //         "requestTime": 1725918004434,
                //         "data": [
                //             {
                //                 "accountId": "1002820815393",
                //                 "symbol": "ETHUSDT_SPBL",
                //                 "orderId": "1217143186968068096",
                //                 "clientOrderId": "8fa3eb89-2377-4519-a199-35d5db9ed262",
                //                 "price": "0",
                //                 "quantity": "10.0000000000000000",
                //                 "orderType": "market",
                //                 "side": "buy",
                //                 "status": "full_fill",
                //                 "fillPrice": "2340.5500000000000000",
                //                 "fillQuantity": "0.0042000000000000",
                //                 "fillTotalAmount": "9.8303100000000000",
                //                 "enterPointSource": "API",
                //                 "feeDetail": "{
                //                     \"ETH\": {
                //                         \"deduction\": false,
                //                         \"feeCoinCode\": \"ETH\",
                //                         \"totalDeductionFee\": 0,
                //                         \"totalFee\": -0.0000042000000000},
                //                         \"newFees\": {
                //                         \"c\": 0,
                //                         \"d\": 0,
                //                         \"deduction\": false,
                //                         \"r\": -0.0000042,
                //                         \"t\": -0.0000042,
                //                         \"totalDeductionFee\": 0
                //                     }
                //                 }",
                //                 "orderSource": "market",
                //                 "cTime": "1725915469877"
                //             }
                //         ]
                //     }
                //
                var data interface{} = this.SafeList(response, "data")
                if IsTrue(IsEqual(data, nil)) {
                    response = JsonParse(response) // the response from closed orders is not a standard JSON
                    data = this.SafeList(response, "data", []interface{}{})
                }
                order = this.SafeDict(data, 0, map[string]interface{} {})
            } else if IsTrue(IsEqual(marketType, "swap")) {
                if IsTrue(IsEqual(market, nil)) {
                    panic(ArgumentsRequired(Add(Add(Add(Add(Add(this.Id, " "), methodName), "() requires a symbol argument for "), marketType), " type of markets")))
                }
                AddElementToObject(request, "symbol", GetValue(market, "id"))
                if IsTrue(!IsEqual(clientOrderId, nil)) {
                    params = this.Omit(params, "clientOrderId")
                    AddElementToObject(request, "clientOid", clientOrderId)
                }
                
        response = (<-this.PrivateGetApiMixV1OrderDetail(this.Extend(request, params)))
                PanicOnError(response)
                //
                //     {
                //         "code": "00000",
                //         "msg": "success",
                //         "requestTime": 1727981421364,
                //         "data": {
                //             "symbol": "ETHUSDT_UMCBL",
                //             "size": 0.01,
                //             "orderId": "1225791137697325056",
                //             "clientOid": "1225791137701519360",
                //             "filledQty": 0.01,
                //             "fee": -0.01398864,
                //             "price": null,
                //             "priceAvg": 2331.44,
                //             "state": "filled",
                //             "side": "close_long",
                //             "timeInForce": "normal",
                //             "totalProfits": -2.23680000,
                //             "posSide": "long",
                //             "marginCoin": "USDT",
                //             "filledAmount": 23.3144,
                //             "orderType": "market",
                //             "leverage": "5",
                //             "marginMode": "crossed",
                //             "reduceOnly": true,
                //             "enterPointSource": "API",
                //             "tradeSide": "close_long",
                //             "holdMode": "double_hold",
                //             "orderSource": "market",
                //             "cTime": "1727977302003",
                //             "uTime": "1727977303604"
                //         }
                //     }
                //
                order = this.SafeDict(response, "data", map[string]interface{} {})
            } else {
                panic(NotSupported(Add(Add(Add(Add(Add(this.Id, " "), methodName), "() is not supported for "), marketType), " type of markets")))
            }
        
            ch <- this.ParseOrder(order, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coincatch#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://coincatch.github.io/github.io/en/spot/#get-order-list
 * @see https://coincatch.github.io/github.io/en/spot/#get-current-plan-orders
 * @see https://coincatch.github.io/github.io/en/mix/#get-open-order
 * @see https://coincatch.github.io/github.io/en/mix/#get-all-open-order
 * @see https://coincatch.github.io/github.io/en/mix/#get-plan-order-tpsl-list
 * @param {string} [symbol] unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] true if fetching trigger orders (default false)
 * @param {string} [params.type] 'spot' or 'swap' - the type of the market to fetch entries for (default 'spot')
 * @param {string} [params.productType] *swap only* 'umcbl' or 'dmcbl' - the product type of the market to fetch entries for (default 'umcbl')
 * @param {string} [params.marginCoin] *swap only* the margin coin of the market to fetch entries for
 * @param {string} [params.isPlan] *swap trigger only* 'plan' or 'profit_loss' ('plan' (default) for trigger (plan) orders, 'profit_loss' for stop-loss and take-profit orders)
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coincatch) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var methodName interface{} = "fetchOpenOrders"
        
            retRes31318 := (<-this.LoadMarkets())
            PanicOnError(retRes31318)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var marketType interface{} = "spot"
            marketTypeparamsVariable := this.HandleMarketTypeAndParams(methodName, market, params, marketType);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            AddElementToObject(params, "methodName", methodName)
            if IsTrue(IsEqual(marketType, "spot")) {
        
                    retRes314019 :=  (<-this.FetchOpenSpotOrders(symbol, since, limit, params))
                    PanicOnError(retRes314019)
                    ch <- retRes314019
                    return nil
            } else if IsTrue(IsEqual(marketType, "swap")) {
        
                    retRes314219 :=  (<-this.FetchOpenSwapOrders(symbol, since, limit, params))
                    PanicOnError(retRes314219)
                    ch <- retRes314219
                    return nil
            } else {
                panic(NotSupported(Add(Add(Add(Add(Add(this.Id, " "), methodName), "() is not supported for "), marketType), " type of markets")))
            }
                return nil
            }()
            return ch
        }
/**
 * @method
 * @ignore
 * @name coincatch#fetchOpenSpotOrders
 * @description fetch all unfilled currently open orders for spot markets
 * @see https://coincatch.github.io/github.io/en/spot/#get-order-list
 * @see https://coincatch.github.io/github.io/en/spot/#get-current-plan-orders
 * @param {string} [symbol] unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] true if fetching trigger orders (default false)
 * @param {string} [params.lastEndId] *for trigger orders only* the last order id to fetch entries after
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coincatch) FetchOpenSpotOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes31648 := (<-this.LoadMarkets())
            PanicOnError(retRes31648)
            var methodName interface{} = "fetchOpenSpotOrders"
            methodNameparamsVariable := this.HandleParamString(params, "methodName", methodName);
            methodName = GetValue(methodNameparamsVariable,0);
            params = GetValue(methodNameparamsVariable,1)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            var isTrigger interface{} = false
            isTriggerparamsVariable := this.HandleOptionAndParams2(params, methodName, "trigger", "stop", isTrigger);
            isTrigger = GetValue(isTriggerparamsVariable,0);
            params = GetValue(isTriggerparamsVariable,1)
            var result interface{} = nil
            if IsTrue(isTrigger) {
                if IsTrue(IsEqual(symbol, nil)) {
                    panic(ArgumentsRequired(Add(Add(Add(this.Id, " "), methodName), "() requires a symbol argument for trigger orders")))
                }
                if IsTrue(!IsEqual(limit, nil)) {
                    AddElementToObject(request, "pageSize", limit)
                }
        
                response:= (<-this.PrivatePostApiSpotV1PlanCurrentPlan(this.Extend(request, params)))
                PanicOnError(response)
                //
                //     {
                //         "code": "00000",
                //         "msg": "success",
                //         "requestTime": 1728664710749,
                //         "data": {
                //             "nextFlag": false,
                //             "endId": 1228661660806787072,
                //             "orderList": [
                //                 {
                //                     "orderId": "1228669617606991872",
                //                     "clientOid": "1228669617573437440",
                //                     "symbol": "ETHUSDT_SPBL",
                //                     "size": "50",
                //                     "executePrice": "0",
                //                     "triggerPrice": "4000",
                //                     "status": "not_trigger",
                //                     "orderType": "market",
                //                     "side": "sell",
                //                     "triggerType": "fill_price",
                //                     "enterPointSource": "API",
                //                     "placeType": null,
                //                     "cTime": "1728663585092",
                //                     "uTime": null
                //                 },
                //             ]
                //         }
                //     }
                //
                var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
                result = this.SafeList(data, "orderList", []interface{}{})
            } else {
        
                response:= (<-this.PrivatePostApiSpotV1TradeOpenOrders(this.Extend(request, params)))
                PanicOnError(response)
                //
                //     {
                //         "code": "00000",
                //         "msg": "success",
                //         "requestTime": 1725965783430,
                //         "data": [
                //             {
                //                 "accountId": "1002820815393",
                //                 "symbol": "ETHUSDT_SPBL",
                //                 "orderId": "1217347655911653376",
                //                 "clientOrderId": "c57c07d1-bd00-4167-95e2-9b22a55fbc28",
                //                 "price": "2000.0000000000000000",
                //                 "quantity": "0.0010000000000000",
                //                 "orderType": "limit",
                //                 "side": "buy",
                //                 "status": "new",
                //                 "fillPrice": "0",
                //                 "fillQuantity": "0.0000000000000000",
                //                 "fillTotalAmount": "0.0000000000000000",
                //                 "enterPointSource": "API",
                //                 "feeDetail": "",
                //                 "orderSource": "normal",
                //                 "cTime": "1725964219072"
                //             },
                //             ...
                //         ]
                //     }
                //
                result = this.SafeList(response, "data", []interface{}{})
            }
        
            ch <- this.ParseOrders(result, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @ignore
 * @name coincatch#fetchOpenSwapOrders
 * @description fetch all unfilled currently open orders for swap markets
 * @see https://coincatch.github.io/github.io/en/mix/#get-open-order
 * @see https://coincatch.github.io/github.io/en/mix/#get-all-open-order
 * @see https://coincatch.github.io/github.io/en/mix/#get-plan-order-tpsl-list
 * @param {string} [symbol] unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] true if fetching trigger orders (default false)
 * @param {string} [params.isPlan] 'plan' or 'profit_loss' ('plan' (default) for trigger (plan) orders, 'profit_loss' for stop-loss and take-profit orders)
 * @param {string} [params.productType] 'umcbl' or 'dmcbl' - the product type of the market to fetch entries for (default 'umcbl')
 * @param {string} [params.marginCoin] the margin coin of the market to fetch entries for
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coincatch) FetchOpenSwapOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes32698 := (<-this.LoadMarkets())
            PanicOnError(retRes32698)
            var methodName interface{} = "fetchOpenSwapOrders"
            methodNameparamsVariable := this.HandleParamString(params, "methodName", methodName);
            methodName = GetValue(methodNameparamsVariable,0);
            params = GetValue(methodNameparamsVariable,1)
            var isTrigger interface{} = false
            isTriggerparamsVariable := this.HandleOptionAndParams2(params, methodName, "trigger", "stop", isTrigger);
            isTrigger = GetValue(isTriggerparamsVariable,0);
            params = GetValue(isTriggerparamsVariable,1)
            var plan interface{} = nil
            planparamsVariable := this.HandleOptionAndParams(params, methodName, "isPlan", plan);
            plan = GetValue(planparamsVariable,0);
            params = GetValue(planparamsVariable,1)
            var productType interface{} = this.HandleOption(methodName, "productType")
            var market interface{} = nil
            var response interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                var request interface{} = map[string]interface{} {
                    "symbol": GetValue(market, "id"),
                }
                if IsTrue(IsTrue((isTrigger)) || IsTrue((!IsEqual(plan, nil)))) {
                    if IsTrue(!IsEqual(productType, nil)) {
                        AddElementToObject(request, "productType", productType)
                    }
                    if IsTrue(!IsEqual(plan, nil)) {
                        AddElementToObject(request, "isPlan", plan) // current param is used to define the type of the orders to fetch (trigger or stop-loss/take-profit)
                    }
                    //
                    //     {
                    //         "code": "00000",
                    //         "msg": "success",
                    //         "requestTime": 1729168682690,
                    //         "data": [
                    //             {
                    //                 "orderId": "1230779428914049025",
                    //                 "clientOid": "1230779428914049024",
                    //                 "symbol": "ETHUSDT_UMCBL",
                    //                 "marginCoin": "USDT",
                    //                 "size": "0.01",
                    //                 "executePrice": "1000",
                    //                 "triggerPrice": "1200",
                    //                 "status": "not_trigger",
                    //                 "orderType": "limit",
                    //                 "planType": "normal_plan",
                    //                 "side": "buy_single",
                    //                 "triggerType": "fill_price",
                    //                 "presetTakeProfitPrice": "4000",
                    //                 "presetTakeLossPrice": "900",
                    //                 "rangeRate": "",
                    //                 "enterPointSource": "API",
                    //                 "tradeSide": "buy_single",
                    //                 "holdMode": "single_hold",
                    //                 "reduceOnly": false,
                    //                 "cTime": "1729166603306",
                    //                 "uTime": null
                    //             }
                    //         ]
                    //     }
                    //
                    
        response = (<-this.PrivateGetApiMixV1PlanCurrentPlan(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.PrivateGetApiMixV1OrderCurrent(this.Extend(request, params)))
                    PanicOnError(response)
                }
            } else if IsTrue(isTrigger) {
                panic(ArgumentsRequired(Add(Add(Add(this.Id, " "), methodName), "() requires a symbol argument for swap trigger orders")))
            } else {
                if IsTrue(IsEqual(productType, nil)) {
                    productType = "umcbl"
                }
                var request interface{} = map[string]interface{} {
                    "productType": productType,
                }
                var marginCoin interface{} = nil
                marginCoin = this.HandleOption(methodName, "marginCoin", marginCoin)
                if IsTrue(!IsEqual(marginCoin, nil)) {
                    AddElementToObject(request, "marginCoin", marginCoin)
                }
                //
                //     {
                //         "code": "00000",
                //         "msg": "success",
                //         "requestTime": 1728127869097,
                //         "data": [
                //             {
                //                 "symbol": "ETHUSDT_UMCBL",
                //                 "size": 0.02,
                //                 "orderId": "1226422495431974913",
                //                 "clientOid": "1226422495457140736",
                //                 "filledQty": 0.00,
                //                 "fee": 0E-8,
                //                 "price": 500.00,
                //                 "state": "new",
                //                 "side": "buy_single",
                //                 "timeInForce": "normal",
                //                 "totalProfits": 0E-8,
                //                 "posSide": "long",
                //                 "marginCoin": "USDT",
                //                 "filledAmount": 0.0000,
                //                 "orderType": "limit",
                //                 "leverage": "5",
                //                 "marginMode": "crossed",
                //                 "reduceOnly": false,
                //                 "enterPointSource": "API",
                //                 "tradeSide": "buy_single",
                //                 "holdMode": "single_hold",
                //                 "orderSource": "normal",
                //                 "cTime": "1728127829422",
                //                 "uTime": "1728127830980"
                //             }
                //         ]
                //     }
                //
                
        response = (<-this.PrivateGetApiMixV1OrderMarginCoinCurrent(this.Extend(request, params)))
                PanicOnError(response)
            }
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseOrders(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coincatch#fetchCanceledAndClosedOrders
 * @description fetches information on multiple canceled and closed orders made by the user
 * @see https://coincatch.github.io/github.io/en/spot/#get-order-list
 * @see https://coincatch.github.io/github.io/en/spot/#get-history-plan-orders
 * @see https://coincatch.github.io/github.io/en/mix/#get-history-orders
 * @see https://coincatch.github.io/github.io/en/mix/#get-producttype-history-orders
 * @see https://coincatch.github.io/github.io/en/mix/#get-history-plan-orders-tpsl
 * @param {string} symbol *is mandatory* unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch orders for
 * @param {boolean} [params.trigger] true if fetching trigger orders (default false)
 * @param {string} [params.isPlan] *swap only* 'plan' or 'profit_loss' ('plan' (default) for trigger (plan) orders, 'profit_loss' for stop-loss and take-profit orders)
 * @param {string} [params.type] 'spot' or 'swap' - the type of the market to fetch entries for (default 'spot')
 * @param {string} [params.productType] *swap only* 'umcbl' or 'dmcbl' - the product type of the market to fetch entries for (default 'umcbl')
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coincatch) FetchCanceledAndClosedOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var methodName interface{} = "fetchCanceledAndClosedOrders"
        
            retRes34048 := (<-this.LoadMarkets())
            PanicOnError(retRes34048)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var marketType interface{} = "spot"
            marketTypeparamsVariable := this.HandleMarketTypeAndParams(methodName, market, params, marketType);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            AddElementToObject(params, "methodName", methodName)
            if IsTrue(IsEqual(marketType, "spot")) {
        
                    retRes341319 :=  (<-this.FetchCanceledAndClosedSpotOrders(symbol, since, limit, params))
                    PanicOnError(retRes341319)
                    ch <- retRes341319
                    return nil
            } else if IsTrue(IsEqual(marketType, "swap")) {
        
                    retRes341519 :=  (<-this.FetchCanceledAndClosedSwapOrders(symbol, since, limit, params))
                    PanicOnError(retRes341519)
                    ch <- retRes341519
                    return nil
            } else {
                panic(NotSupported(Add(Add(Add(Add(Add(this.Id, " "), methodName), "() is not supported for "), marketType), " type of markets")))
            }
                return nil
            }()
            return ch
        }
/**
 * @method
 * @ignore
 * @name coincatch#fetchCanceledAndClosedSpotOrders
 * @description fetches information on multiple canceled and closed orders made by the user on spot markets
 * @see https://coincatch.github.io/github.io/en/spot/#get-order-history
 * @see https://coincatch.github.io/github.io/en/spot/#get-history-plan-orders
 * @param {string} symbol *is mandatory* unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] *for trigger orders only* the latest time in ms to fetch orders for
 * @param {boolean} [params.trigger] true if fetching trigger orders (default false)
 * @param {string} [params.lastEndId] *for trigger orders only* the last order id to fetch entries after
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coincatch) FetchCanceledAndClosedSpotOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var methodName interface{} = "fetchCanceledAndClosedSpotOrders"
            methodNameparamsVariable := this.HandleParamString(params, "methodName", methodName);
            methodName = GetValue(methodNameparamsVariable,0);
            params = GetValue(methodNameparamsVariable,1)
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(Add(Add(this.Id, " "), methodName), " () requires a symbol argument for spot markets")))
            }
            var maxLimit interface{} = 500
        
            retRes34448 := (<-this.LoadMarkets())
            PanicOnError(retRes34448)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var requestLimit interface{} = limit
            var isTrigger interface{} = false
            isTriggerparamsVariable := this.HandleOptionAndParams2(params, methodName, "trigger", "stop", isTrigger);
            isTrigger = GetValue(isTriggerparamsVariable,0);
            params = GetValue(isTriggerparamsVariable,1)
            var result interface{} = nil
            if IsTrue(isTrigger) {
                var until interface{} = nil
                untilparamsVariable := this.HandleOptionAndParams(params, methodName, "until", until);
                until = GetValue(untilparamsVariable,0);
                params = GetValue(untilparamsVariable,1)
                // const now = this.milliseconds ();
                var requestSince interface{} = since
                var interval interface{} = Multiply(Multiply(Multiply(Multiply(90, 24), 60), 60), 1000) // startTime and endTime interval cannot be greater than 90 days
                var now interface{} = this.Milliseconds()
                // both since and until are required for trigger orders
                if IsTrue(IsTrue((IsEqual(until, nil))) && IsTrue((IsEqual(requestSince, nil)))) {
                    requestSince = Subtract(now, interval)
                    until = now
                } else if IsTrue(!IsEqual(until, nil)) {
                    requestSince = Subtract(until, interval)
                } else {
                    until = Add(since, interval)
                }
                AddElementToObject(request, "startTime", requestSince)
                AddElementToObject(request, "endTime", until)
                if IsTrue(IsEqual(requestLimit, nil)) {
                    requestLimit = maxLimit
                }
                AddElementToObject(request, "pageSize", requestLimit)
        
                response:= (<-this.PrivatePostApiSpotV1PlanHistoryPlan(this.Extend(request, params)))
                PanicOnError(response)
                //
                //     {
                //         "code": "00000",
                //         "msg": "success",
                //         "requestTime": 1728668998002,
                //         "data": {
                //             "nextFlag": false,
                //             "endId": 1228669617606991872,
                //             "orderList": [
                //                 {
                //                     "orderId": "1228669617606991872",
                //                     "clientOid": "1228669617573437440",
                //                     "symbol": "ETHUSDT_SPBL",
                //                     "size": "50",
                //                     "executePrice": "0",
                //                     "triggerPrice": "4000",
                //                     "status": "cancel",
                //                     "orderType": "market",
                //                     "side": "sell",
                //                     "triggerType": "fill_price",
                //                     "enterPointSource": "API",
                //                     "placeType": null,
                //                     "cTime": "1728663585092",
                //                     "uTime": "1728666719223"
                //                 }
                //             ]
                //         }
                //     }
                //
                var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
                result = this.SafeList(data, "orderList", []interface{}{})
            } else {
                if IsTrue(!IsEqual(since, nil)) {
                    AddElementToObject(request, "after", since)
                    requestLimit = maxLimit
                }
                if IsTrue(!IsEqual(requestLimit, nil)) {
                    AddElementToObject(request, "limit", requestLimit)
                }
        
                response:= (<-this.PrivatePostApiSpotV1TradeHistory(this.Extend(request, params)))
                PanicOnError(response)
                //
                //     {
                //         "code": "00000",
                //         "msg": "success",
                //         "requestTime": 1725963777690,
                //         "data": [
                //             {
                //                 "accountId": "1002820815393",
                //                 "symbol": "ETHUSDT_SPBL",
                //                 "orderId": "1217143186968068096",
                //                 "clientOrderId": "8fa3eb89-2377-4519-a199-35d5db9ed262",
                //                 "price": "0",
                //                 "quantity": "10.0000000000000000",
                //                 "orderType": "market",
                //                 "side": "buy",
                //                 "status": "full_fill",
                //                 "fillPrice": "2340.5500000000000000",
                //                 "fillQuantity": "0.0042000000000000",
                //                 "fillTotalAmount": "9.8303100000000000",
                //                 "enterPointSource": "API",
                //                 "feeDetail": "{
                //                     \"ETH\": {
                //                         \"deduction\": false,
                //                         \"feeCoinCode\": \"ETH\",
                //                         \"totalDeductionFee\": 0,
                //                         \"totalFee\": -0.0000042000000000
                //                     },
                //                     \"newFees\": {
                //                         \"c\": 0,
                //                         \"d\": 0,
                //                         \"deduction\": false,
                //                         \"r\": -0.0000042,
                //                         \"t\": -0.0000042,
                //                         \"totalDeductionFee\": 0
                //                     }
                //                 }",
                //                 "orderSource": "market",
                //                 "cTime": "1725915469877"
                //             },
                //             ...
                //         ]
                //     }
                //
                var parsedResponse interface{} = JsonParse(response) // the response is not a standard JSON
                result = this.SafeList(parsedResponse, "data", []interface{}{})
            }
        
            ch <- this.ParseOrders(result, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @ignore
 * @name coincatch#fetchCanceledAndClosedSwapOrders
 * @description fetches information on multiple canceled and closed orders made by the user on swap markets
 * @see https://coincatch.github.io/github.io/en/mix/#get-history-orders
 * @see https://coincatch.github.io/github.io/en/mix/#get-producttype-history-orders
 * @see https://coincatch.github.io/github.io/en/mix/#get-history-plan-orders-tpsl
 * @param {string} [symbol] unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch orders for
 * @param {boolean} [params.trigger] true if fetching trigger orders (default false)
 * @param {string} [params.isPlan] *swap only* 'plan' or 'profit_loss' ('plan' (default) for trigger (plan) orders, 'profit_loss' for stop-loss and take-profit orders)
 * @param {string} [params.productType] *swap only* 'umcbl' or 'dmcbl' - the product type of the market to fetch entries for (default 'umcbl')
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coincatch) FetchCanceledAndClosedSwapOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var methodName interface{} = "fetchCanceledAndClosedSwapOrders"
            methodNameparamsVariable := this.HandleParamString(params, "methodName", methodName);
            methodName = GetValue(methodNameparamsVariable,0);
            params = GetValue(methodNameparamsVariable,1)
            var requestSince interface{} = since
            var until interface{} = nil
            untilparamsVariable := this.HandleOptionAndParams(params, methodName, "until", until);
            until = GetValue(untilparamsVariable,0);
            params = GetValue(untilparamsVariable,1)
            var now interface{} = this.Milliseconds()
            // since and until are mandatory
            // they should be within 90 days interval
            var interval interface{} = Multiply(Multiply(Multiply(Multiply(90, 24), 60), 60), 1000)
            if IsTrue(IsTrue((IsEqual(until, nil))) && IsTrue((IsEqual(requestSince, nil)))) {
                requestSince = Subtract(now, interval)
                until = now
            } else if IsTrue(!IsEqual(until, nil)) {
                requestSince = Subtract(until, interval)
            } else {
                until = Add(since, interval)
            }
            var request interface{} = map[string]interface{} {
                "startTime": requestSince,
                "endTime": until,
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "pageSize", limit)
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            var productType interface{} = this.HandleOption(methodName, "productType")
            var isTrigger interface{} = false
            isTriggerparamsVariable := this.HandleOptionAndParams2(params, methodName, "trigger", "stop", isTrigger);
            isTrigger = GetValue(isTriggerparamsVariable,0);
            params = GetValue(isTriggerparamsVariable,1)
            var plan interface{} = nil
            planparamsVariable := this.HandleOptionAndParams(params, methodName, "isPlan", plan);
            plan = GetValue(planparamsVariable,0);
            params = GetValue(planparamsVariable,1)
            var response interface{} = nil
            var result interface{} = nil
            if IsTrue(IsTrue((isTrigger)) || IsTrue((!IsEqual(plan, nil)))) {
                if IsTrue(!IsEqual(plan, nil)) {
                    AddElementToObject(request, "isPlan", plan)
                }
                if IsTrue(!IsEqual(productType, nil)) {
                    AddElementToObject(request, "productType", productType)
                }
                
        response = (<-this.PrivateGetApiMixV1PlanHistoryPlan(this.Extend(request, params)))
                PanicOnError(response)
                //
                //     {
                //         "code": "00000",
                //         "msg": "success",
                //         "requestTime": 1729174716526,
                //         "data": [
                //             {
                //                 "orderId": "1230763430987104257",
                //                 "clientOid": "1230763431003881472",
                //                 "executeOrderId": "",
                //                 "symbol": "ETHUSDT_UMCBL",
                //                 "marginCoin": "USDT",
                //                 "size": "0.03",
                //                 "executePrice": "0",
                //                 "triggerPrice": "2000",
                //                 "status": "cancel",
                //                 "orderType": "market",
                //                 "planType": "loss_plan",
                //                 "side": "sell_single",
                //                 "triggerType": "fill_price",
                //                 "presetTakeProfitPrice": "0",
                //                 "presetTakeLossPrice": "0",
                //                 "rangeRate": null,
                //                 "enterPointSource": "SYS",
                //                 "tradeSide": "sell_single",
                //                 "holdMode": "single_hold",
                //                 "reduceOnly": true,
                //                 "executeTime": "1729173770776",
                //                 "executeSize": "0",
                //                 "cTime": "1729162789103",
                //                 "uTime": "1729173770776"
                //             }
                //         ]
                //     }
                //
                result = this.SafeList(response, "data", []interface{}{})
            } else {
                if IsTrue(!IsEqual(symbol, nil)) {
                    market = this.Market(symbol)
                    AddElementToObject(request, "symbol", GetValue(market, "id"))
                    
        response = (<-this.PrivateGetApiMixV1OrderHistory(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    if IsTrue(IsEqual(productType, nil)) {
                        productType = "umcbl" // is mandatory for current endpoint
                    }
                    AddElementToObject(request, "productType", productType)
                    
        response = (<-this.PrivateGetApiMixV1OrderHistoryProductType(this.Extend(request, params)))
                    PanicOnError(response)
                }
                //
                //     {
                //         "code": "00000",
                //         "msg": "success",
                //         "requestTime": 1728129807637,
                //         "data": {
                //             "nextFlag": false,
                //             "endId": "1221413696648339457",
                //             "orderList": [
                //                 {
                //                     "symbol": "ETHUSD_DMCBL",
                //                     "size": 0.1,
                //                     "orderId": "1225467075288719360",
                //                     "clientOid": "1225467075288719361",
                //                     "filledQty": 0.1,
                //                     "fee": -0.00005996,
                //                     "price": null,
                //                     "priceAvg": 2362.03,
                //                     "state": "filled",
                //                     "side": "burst_close_long",
                //                     "timeInForce": "normal",
                //                     "totalProfits": -0.00833590,
                //                     "posSide": "long",
                //                     "marginCoin": "ETH",
                //                     "filledAmount": 236.20300000,
                //                     "orderType": "market",
                //                     "leverage": "12",
                //                     "marginMode": "fixed",
                //                     "reduceOnly": true,
                //                     "enterPointSource": "SYS",
                //                     "tradeSide": "burst_close_long",
                //                     "holdMode": "double_hold",
                //                     "orderSource": "market",
                //                     "cTime": "1727900039503",
                //                     "uTime": "1727900039576"
                //                 }
                //             ]
                //         }
                //     }
                //
                var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
                result = this.SafeList(data, "orderList", []interface{}{})
            }
        
            ch <- this.ParseOrders(result, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coincatch#cancelOrder
 * @description cancels an open order
 * @see https://coincatch.github.io/github.io/en/spot/#cancel-order-v2
 * @see https://coincatch.github.io/github.io/en/spot/#cancel-plan-order
 * @see https://coincatch.github.io/github.io/en/mix/#cancel-order
 * @see https://coincatch.github.io/github.io/en/mix/#cancel-plan-order-tpsl
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.clientOrderId] a unique id for the order that can be used as an alternative for the id
 * @param {bool} [params.trigger] true for canceling a trigger order (default false)
 * @param {bool} [params.stop] *swap only* an alternative for trigger param
 * @param {string} [params.planType] *swap trigger only* the type of the plan order to cancel: 'profit_plan' - profit order, 'loss_plan' - loss order, 'normal_plan' - plan order, 'pos_profit' - position profit, 'pos_loss' - position loss, 'moving_plan' - Trailing TP/SL, 'track_plan' - Trailing Stop
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coincatch) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var methodName interface{} = "cancelOrder"
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(Add(Add(this.Id, " "), methodName), " () requires a symbol argument")))
            }
        
            retRes37448 := (<-this.LoadMarkets())
            PanicOnError(retRes37448)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {}
            var clientOrderId interface{} = nil
            clientOrderIdparamsVariable := this.HandleParamString(params, "clientOrderId");
            clientOrderId = GetValue(clientOrderIdparamsVariable,0);
            params = GetValue(clientOrderIdparamsVariable,1)
            if IsTrue(IsTrue((IsEqual(id, nil))) && IsTrue((IsEqual(clientOrderId, nil)))) {
                panic(ArgumentsRequired(Add(Add(Add(this.Id, " "), methodName), " () requires an id argument or clientOrderId parameter")))
            }
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                AddElementToObject(request, "clientOid", clientOrderId)
            } else {
                AddElementToObject(request, "orderId", id)
            }
            var marketType interface{} = GetValue(market, "type")
            var trigger interface{} = false
            triggerparamsVariable := this.HandleOptionAndParams2(params, methodName, "trigger", "stop", trigger);
            trigger = GetValue(triggerparamsVariable,0);
            params = GetValue(triggerparamsVariable,1)
            var response interface{} = nil
            if IsTrue(!IsTrue(trigger) || IsTrue((!IsEqual(marketType, "spot")))) {
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            if IsTrue(IsEqual(marketType, "spot")) {
                if IsTrue(trigger) {
                    
        response = (<-this.PrivatePostApiSpotV1PlanCancelPlan(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.PrivatePostApiSpotV1TradeCancelOrderV2(this.Extend(request, params)))
                    PanicOnError(response)
                }
            } else if IsTrue(IsEqual(marketType, "swap")) {
                var planType interface{} = nil
                planTypeparamsVariable := this.HandleOptionAndParams(params, methodName, "planType", planType);
                planType = GetValue(planTypeparamsVariable,0);
                params = GetValue(planTypeparamsVariable,1)
                AddElementToObject(request, "marginCoin", GetValue(market, "settleId"))
                if IsTrue(IsTrue((trigger)) || IsTrue((!IsEqual(planType, nil)))) {
                    if IsTrue(IsEqual(planType, nil)) {
                        panic(ArgumentsRequired(Add(Add(Add(this.Id, " "), methodName), " () requires a planType parameter for swap trigger orders (\"profit_plan\" - profit order, \"loss_plan\" - loss order, \"normal_plan\" - plan order, \"pos_profit\" - position profit, \"pos_loss\" - position loss, \"moving_plan\" - Trailing TP/SL, \"track_plan\" - Trailing Stop)")))
                    }
                    AddElementToObject(request, "planType", planType)
                    
        response = (<-this.PrivatePostApiMixV1PlanCancelPlan(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.PrivatePostApiMixV1OrderCancelOrder(this.Extend(request, params)))
                    PanicOnError(response)
                }
            } else {
                panic(NotSupported(Add(Add(Add(Add(Add(this.Id, " "), methodName), "() is not supported for "), marketType), " type of markets")))
            }
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseOrder(data, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coincatch#cancelAllOrders
 * @description cancels all open orders
 * @see https://coincatch.github.io/github.io/en/spot/#cancel-all-orders
 * @see https://coincatch.github.io/github.io/en/spot/#batch-cancel-plan-orders
 * @see https://coincatch.github.io/github.io/en/mix/#batch-cancel-order
 * @see https://coincatch.github.io/github.io/en/mix/#cancel-order-by-symbol
 * @see https://coincatch.github.io/github.io/en/mix/#cancel-plan-order-tpsl-by-symbol
 * @see https://coincatch.github.io/github.io/en/mix/#cancel-all-trigger-order-tpsl
 * @param {string} [symbol] unified symbol of the market the orders were made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.type] 'spot' or 'swap' - the type of the market to cancel orders for (default 'spot')
 * @param {bool} [params.trigger] true for canceling a trigger orders (default false)
 * @param {string} [params.productType] *swap only (if symbol is not provided* 'umcbl' or 'dmcbl' - the product type of the market to cancel orders for (default 'umcbl')
 * @param {string} [params.marginCoin] *mandatory for swap non-trigger dmcb (if symbol is not provided)* the margin coin of the market to cancel orders for
 * @param {string} [params.planType] *swap trigger only* the type of the plan order to cancel: 'profit_plan' - profit order, 'loss_plan' - loss order, 'normal_plan' - plan order, 'pos_profit' - position profit, 'pos_loss' - position loss, 'moving_plan' - Trailing TP/SL, 'track_plan' - Trailing Stop
 * @returns {object} response from the exchange
 */
func  (this *coincatch) CancelAllOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var methodName interface{} = "cancelAllOrders"
        
            retRes38118 := (<-this.LoadMarkets())
            PanicOnError(retRes38118)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var request interface{} = map[string]interface{} {}
            var marketType interface{} = "spot"
            marketTypeparamsVariable := this.HandleMarketTypeAndParams(methodName, market, params, marketType);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            var trigger interface{} = false
            triggerparamsVariable := this.HandleOptionAndParams2(params, methodName, "trigger", "stop", trigger);
            trigger = GetValue(triggerparamsVariable,0);
            params = GetValue(triggerparamsVariable,1)
            var response interface{} = nil
            if IsTrue(IsEqual(marketType, "spot")) {
                if IsTrue(trigger) {
                    if IsTrue(!IsEqual(symbol, nil)) {
                        AddElementToObject(request, "symbols", []interface{}{GetValue(market, "id")})
                    }
                    
        response = (<-this.PrivatePostApiSpotV1PlanBatchCancelPlan(this.Extend(request, params)))
                    PanicOnError(response)
                    //
                    //     {
                    //         "code": "00000",
                    //         "msg": "success",
                    //         "requestTime": 1728670464735,
                    //         "data": [
                    //             {
                    //                 "orderId": "1228661660806787072",
                    //                 "clientOid": "1228661660752261120",
                    //                 "result": true
                    //             }
                    //         ]
                    //     }
                    //
                    var data interface{} = this.SafeList(response, "data", []interface{}{})
        
                    ch <- this.ParseOrders(data, market)
                    return nil
                } else {
                    if IsTrue(IsEqual(symbol, nil)) {
                        panic(ArgumentsRequired(Add(Add(Add(this.Id, " "), methodName), " () requires a symbol argument for spot non-trigger orders")))
                    }
                    AddElementToObject(request, "symbol", GetValue(market, "id"))
                    //
                    //     {
                    //         "code": "00000",
                    //         "msg": "success",
                    //         "requestTime": 1725989560461,
                    //         "data": "ETHUSDT_SPBL"
                    //     }
                    //
                    
        response = (<-this.PrivatePostApiSpotV1TradeCancelSymbolOrder(this.Extend(request, params)))
                    PanicOnError(response)
                }
            } else if IsTrue(IsEqual(marketType, "swap")) {
                var productType interface{} = "umcbl"
                if IsTrue(!IsEqual(symbol, nil)) {
                    AddElementToObject(request, "symbol", GetValue(market, "id"))
                } else {
                    productType = this.HandleOption(methodName, "productType", productType)
                    AddElementToObject(request, "productType", productType) // we need either symbol or productType
                }
                var planType interface{} = nil
                planTypeparamsVariable := this.HandleOptionAndParams(params, methodName, "planType", planType);
                planType = GetValue(planTypeparamsVariable,0);
                params = GetValue(planTypeparamsVariable,1)
                if IsTrue(IsTrue((trigger)) || IsTrue((!IsEqual(planType, nil)))) {
                    if IsTrue(IsEqual(planType, nil)) {
                        panic(ArgumentsRequired(Add(Add(Add(this.Id, " "), methodName), " () requires a planType parameter for swap trigger orders (\"profit_plan\" - profit order, \"loss_plan\" - loss order, \"normal_plan\" - plan order, \"pos_profit\" - position profit, \"pos_loss\" - position loss, \"moving_plan\" - Trailing TP/SL, \"track_plan\" - Trailing Stop)")))
                    }
                    AddElementToObject(request, "planType", planType)
                    if IsTrue(!IsEqual(symbol, nil)) {
                        
        response = (<-this.PrivatePostApiMixV1PlanCancelSymbolPlan(this.Extend(request, params)))
                        PanicOnError(response)
                    } else {
                        
        response = (<-this.PrivatePostApiMixV1PlanCancelAllPlan(this.Extend(request, params)))
                        PanicOnError(response)
                    }
                } else if IsTrue(!IsEqual(symbol, nil)) {
                    AddElementToObject(request, "marginCoin", GetValue(market, "settleId"))
                    
        response = (<-this.PrivatePostApiMixV1OrderCancelSymbolOrders(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    var marginCoin interface{} = nil
                    if IsTrue(IsEqual(productType, "umcbl")) {
                        marginCoin = "USDT"
                    } else {
                        marginCoinparamsVariable := this.HandleOptionAndParams(params, methodName, "marginCoin", marginCoin);
                        marginCoin = GetValue(marginCoinparamsVariable,0);
                        params = GetValue(marginCoinparamsVariable,1)
                        if IsTrue(IsEqual(marginCoin, nil)) {
                            panic(ArgumentsRequired(Add(Add(Add(this.Id, " "), methodName), " () requires a marginCoin parameter for dmcbl product type")))
                        }
                    }
                    AddElementToObject(request, "marginCoin", marginCoin)
                    
        response = (<-this.PrivatePostApiMixV1OrderCancelAllOrders(this.Extend(request, params)))
                    PanicOnError(response)
                }
                //
                //     {
                //         "code": "00000",
                //         "msg": "success",
                //         "requestTime": 1729104940774,
                //         "data": {
                //             "result": true,
                //             "order_ids": [ "1230500426827522049" ],
                //             "client_order_ids": [ "1230500426898825216" ],
                //             "fail_infos": []
                //         }
                //     }
                //
                var result interface{} = this.GetResultFromBatchCancelingSwapOrders(response)
        
                ch <- this.ParseOrders(result, market)
                return nil
            } else {
                panic(NotSupported(Add(Add(Add(Add(Add(this.Id, " "), methodName), "() is not supported for "), marketType), " type of markets")))
            }
            var order interface{} = this.SafeOrder(response)
            AddElementToObject(order, "info", response)
        
            ch <- []interface{}{order}
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coincatch#cancelOrders
 * @description cancel multiple non-trigger orders
 * @see https://coincatch.github.io/github.io/en/spot/#cancel-order-in-batch-v2-single-instruments
 * @param {string[]} ids order ids
 * @param {string} symbol *is mandatory* unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string[]} [params.clientOrderIds] client order ids
 * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coincatch) CancelOrders(ids interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var methodName interface{} = "cancelOrders"
            // only non-trigger and not tp/sl orders can be canceled via cancelOrders
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(Add(Add(this.Id, " "), methodName), "() requires a symbol argument")))
            }
        
            retRes39358 := (<-this.LoadMarkets())
            PanicOnError(retRes39358)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var marketType interface{} = GetValue(market, "type")
            var clientOrderIds interface{} = this.SafeList(params, "clientOrderIds")
            if IsTrue(!IsEqual(clientOrderIds, nil)) {
                AddElementToObject(request, "clientOids", clientOrderIds)
                params = this.Omit(params, "clientOrderIds")
            } else if IsTrue(IsEqual(ids, nil)) {
                panic(ArgumentsRequired(Add(Add(Add(this.Id, " "), methodName), "() requires either ids argument or clientOrderIds parameter")))
            } else {
                AddElementToObject(request, "orderIds", ids)
            }
            var response interface{} = nil
            var result interface{} = nil
            if IsTrue(IsEqual(marketType, "spot")) {
                
        response = (<-this.PrivatePostApiSpotV1TradeCancelBatchOrdersV2(this.Extend(request)))
                PanicOnError(response)
                //
                //     {
                //         "code": "00000",
                //         "msg": "success",
                //         "requestTime": 1726491486352,
                //         "data": {
                //             "resultList": [
                //                 {
                //                     "orderId": "1219555778395160576",
                //                     "clientOrderId": "e229d70a-bb16-4633-a45c-d7f4d3b5d2cf"
                //                 }
                //             ],
                //             "failure": [
                //                 {
                //                     "orderId": "123124124",
                //                     "clientOrderId": null,
                //                     "errorMsg": "The order does not exist",
                //                     "errorCode": "43001"
                //                 }
                //             ]
                //         }
                //     }
                //
                var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
                result = this.SafeList(data, "resultList", []interface{}{})
            } else if IsTrue(IsEqual(marketType, "swap")) {
                AddElementToObject(request, "marginCoin", GetValue(market, "settleId"))
                
        response = (<-this.PrivatePostApiMixV1OrderCancelBatchOrders(this.Extend(request, params)))
                PanicOnError(response)
                //
                //     {
                //         "code": "00000",
                //         "msg": "success",
                //         "requestTime": 1729101962321,
                //         "data": {
                //             "result": true,
                //             "symbol": "ETHUSDT_UMCBL",
                //             "order_ids": [ "1226441551501418496", "1230506854262857729" ],
                //             "client_order_ids": [],
                //             "fail_infos": []
                //         }
                //     }
                //
                result = this.GetResultFromBatchCancelingSwapOrders(response)
            } else {
                panic(NotSupported(Add(Add(Add(Add(Add(this.Id, " "), methodName), "() is not supported for "), marketType), " type of markets")))
            }
        
            ch <- this.ParseOrders(result, market)
            return nil
        
            }()
            return ch
        }
func  (this *coincatch) GetResultFromBatchCancelingSwapOrders(response interface{}) interface{}  {
    var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
    var result interface{} = []interface{}{}
    var orderIds interface{} = this.SafeValue(data, "order_ids", []interface{}{})
    for i := 0; IsLessThan(i, GetArrayLength(orderIds)); i++ {
        var orderId interface{} = GetValue(orderIds, i)
        var resultItem interface{} = map[string]interface{} {
            "orderId": orderId,
        }
        AppendToArray(&result,resultItem)
    }
    return result
}
func  (this *coincatch) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // createOrder spot
    //     {
    //         "orderId": "1217143186968068096",
    //         "clientOrderId": "8fa3eb89-2377-4519-a199-35d5db9ed262"
    //     }
    //
    // createOrder swap
    //     {
    //         "clientOid": "1225791137701519360",
    //         "orderId": "1225791137697325056"
    //     }
    //
    // privatePostApiSpotV1TradeOrderInfo, privatePostApiSpotV1TradeHistory
    //     {
    //         "accountId": "1002820815393",
    //         "symbol": "ETHUSDT_SPBL",
    //         "orderId": "1217143186968068096",
    //         "clientOrderId": "8fa3eb89-2377-4519-a199-35d5db9ed262",
    //         "price": "0",
    //         "quantity": "10.0000000000000000",
    //         "orderType": "market",
    //         "side": "buy",
    //         "status": "full_fill",
    //         "fillPrice": "2340.5500000000000000",
    //         "fillQuantity": "0.0042000000000000",
    //         "fillTotalAmount": "9.8303100000000000",
    //         "enterPointSource": "API",
    //         "feeDetail": "{
    //             \"ETH\": {
    //                 \"deduction\": false,
    //                 \"feeCoinCode\": \"ETH\",
    //                 \"totalDeductionFee\": 0,
    //                 \"totalFee\": -0.0000042000000000},
    //                 \"newFees\": {
    //                     \"c\": 0,
    //                     \"d\": 0,
    //                     \"deduction\": false,
    //                     \"r\": -0.0000042,
    //                     \"t\": -0.0000042,
    //                     \"totalDeductionFee\": 0
    //             }
    //         }",
    //         "orderSource": "market",
    //         "cTime": "1725915469877"
    //     }
    //
    // privatePostApiMixV1OrderDetail, privateGetApiMixV1OrderMarginCoinCurrent
    //     {
    //         "symbol": "ETHUSDT_UMCBL",
    //         "size": 0.01,
    //         "orderId": "1225791137697325056",
    //         "clientOid": "1225791137701519360",
    //         "filledQty": 0.01,
    //         "fee": -0.01398864,
    //         "price": null,
    //         "priceAvg": 2331.44,
    //         "state": "filled",
    //         "side": "close_long",
    //         "timeInForce": "normal",
    //         "totalProfits": -2.23680000,
    //         "posSide": "long",
    //         "marginCoin": "USDT",
    //         "filledAmount": 23.3144,
    //         "orderType": "market",
    //         "leverage": "5",
    //         "marginMode": "crossed",
    //         "reduceOnly": true,
    //         "enterPointSource": "API",
    //         "tradeSide": "close_long",
    //         "holdMode": "double_hold",
    //         "orderSource": "market",
    //         "cTime": "1727977302003",
    //         "uTime": "1727977303604"
    //     }
    //
    // privatePostApiSpotV1TradeOpenOrders
    //     {
    //         "accountId": "1002820815393",
    //         "symbol": "ETHUSDT_SPBL",
    //         "orderId": "1217347655911653376",
    //         "clientOrderId": "c57c07d1-bd00-4167-95e2-9b22a55fbc28",
    //         "price": "2000.0000000000000000",
    //         "quantity": "0.0010000000000000",
    //         "orderType": "limit",
    //         "side": "buy",
    //         "status": "new",
    //         "fillPrice": "0",
    //         "fillQuantity": "0.0000000000000000",
    //         "fillTotalAmount": "0.0000000000000000",
    //         "enterPointSource": "API",
    //         "feeDetail": "",
    //         "orderSource": "normal",
    //         "cTime": "1725964219072"
    //     }
    //
    // privatePostApiSpotV1PlanCurrentPlan, privatePostApiSpotV1PlanHistoryPlan
    //     {
    //         "orderId": "1228669617606991872",
    //         "clientOid": "1228669617573437440",
    //         "symbol": "ETHUSDT_SPBL",
    //         "size": "50",
    //         "executePrice": "0",
    //         "triggerPrice": "4000",
    //         "status": "not_trigger",
    //         "orderType": "market",
    //         "side": "sell",
    //         "triggerType": "fill_price",
    //         "enterPointSource": "API",
    //         "placeType": null,
    //         "cTime": "1728663585092",
    //         "uTime": null
    //     }
    //
    // privateGetApiMixV1PlanCurrentPlan
    //     {
    //         "orderId": "1230779428914049025",
    //         "clientOid": "1230779428914049024",
    //         "symbol": "ETHUSDT_UMCBL",
    //         "marginCoin": "USDT",
    //         "size": "0.01",
    //         "executePrice": "1000",
    //         "triggerPrice": "1200",
    //         "status": "not_trigger",
    //         "orderType": "limit",
    //         "planType": "normal_plan",
    //         "side": "buy_single",
    //         "triggerType": "fill_price",
    //         "presetTakeProfitPrice": "4000",
    //         "presetTakeLossPrice": "900",
    //         "rangeRate": "",
    //         "enterPointSource": "API",
    //         "tradeSide": "buy_single",
    //         "holdMode": "single_hold",
    //         "reduceOnly": false,
    //         "cTime": "1729166603306",
    //         "uTime": null
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(order, "symbol")
    var marginCoin interface{} = this.SafeString(order, "marginCoin")
    market = this.SafeMarketCustom(marketId, market, marginCoin)
    var timestamp interface{} = this.SafeInteger(order, "cTime")
    var price interface{} = this.OmitZero(this.SafeString2(order, "price", "executePrice")) // price is zero for market orders
    var priceAvg interface{} = this.OmitZero(this.SafeString(order, "priceAvg"))
    if IsTrue(IsEqual(price, nil)) {
        price = priceAvg
    }
    var typeVar interface{} = this.SafeString(order, "orderType")
    var side interface{} = this.ParseOrderSide(this.SafeStringLower(order, "side"))
    var amount interface{} = this.SafeString2(order, "quantity", "size")
    var isTrigger interface{} = !IsEqual(this.SafeString(order, "triggerType"), nil)
    var isMarketBuy interface{} = IsTrue((IsEqual(typeVar, "market"))) && IsTrue((IsEqual(side, "buy")))
    if IsTrue(IsTrue(IsTrue((GetValue(market, "spot"))) && IsTrue((isMarketBuy))) && IsTrue((!IsTrue(isTrigger)))) {
        amount = nil // cost instead of amount is returned for market buy spot non-trigger orders
    }
    var status interface{} = this.SafeString2(order, "status", "state")
    var feeDetailString interface{} = this.SafeString(order, "feeDetail")
    var fees interface{} = nil
    var feeCurrency interface{} = nil
    var feeCost interface{} = nil
    if IsTrue(!IsEqual(feeDetailString, nil)) {
        fees = this.ParseFeeDetailString(feeDetailString)
    } else {
        feeCurrency = Ternary(IsTrue(marginCoin), this.SafeCurrencyCode(marginCoin), nil)
        feeCost = Precise.StringAbs(this.SafeString(order, "fee"))
    }
    var timeInForce interface{} = this.ParseOrderTimeInForce(this.SafeStringLower(order, "timeInForce"))
    var postOnly interface{} = nil
    if IsTrue(!IsEqual(timeInForce, nil)) {
        postOnly = IsEqual(timeInForce, "PO")
    }
    var triggerPrice interface{} = this.OmitZero(this.SafeString(order, "triggerPrice"))
    var takeProfitPrice interface{} = this.OmitZero(this.SafeString(order, "presetTakeProfitPrice"))
    var stopLossPrice interface{} = this.OmitZero(this.SafeString2(order, "presetTakeProfitPrice", "presetTakeLossPrice"))
    var planType interface{} = this.SafeString(order, "planType")
    if IsTrue(IsEqual(planType, "loss_plan")) {
        stopLossPrice = triggerPrice
    } else if IsTrue(IsEqual(planType, "profit_plan")) {
        takeProfitPrice = triggerPrice
    }
    return this.SafeOrder(map[string]interface{} {
        "id": this.SafeString(order, "orderId"),
        "clientOrderId": this.SafeString2(order, "clientOrderId", "clientOid"),
        "datetime": this.Iso8601(timestamp),
        "timestamp": timestamp,
        "lastTradeTimestamp": nil,
        "lastUpdateTimestamp": this.SafeInteger(order, "uTime"),
        "status": this.ParseOrderStatus(status),
        "symbol": GetValue(market, "symbol"),
        "type": typeVar,
        "timeInForce": timeInForce,
        "side": side,
        "price": price,
        "average": Ternary(IsTrue(priceAvg), priceAvg, this.SafeString(order, "fillPrice")),
        "amount": amount,
        "filled": this.SafeString2(order, "fillQuantity", "filledQty"),
        "remaining": nil,
        "triggerPrice": triggerPrice,
        "takeProfitPrice": takeProfitPrice,
        "stopLossPrice": stopLossPrice,
        "cost": this.SafeString2(order, "fillTotalAmount", "filledAmount"),
        "trades": nil,
        "fee": map[string]interface{} {
            "currency": feeCurrency,
            "cost": feeCost,
        },
        "fees": fees,
        "reduceOnly": this.SafeBool(order, "reduceOnly"),
        "postOnly": postOnly,
        "info": order,
    }, market)
}
func  (this *coincatch) ParseOrderStatus(status interface{}) interface{}  {
    var satuses interface{} = map[string]interface{} {
        "not_trigger": "open",
        "init": "open",
        "new": "open",
        "partially_filled": "open",
        "full_fill": "closed",
        "filled": "closed",
        "cancel": "canceled",
        "canceled": "canceled",
        "cancelled": "canceled",
    }
    return this.SafeString(satuses, status, status)
}
func  (this *coincatch) ParseOrderSide(side interface{}) interface{}  {
    var sides interface{} = map[string]interface{} {
        "buy": "buy",
        "sell": "sell",
        "open_long": "buy",
        "open_short": "sell",
        "close_long": "sell",
        "close_short": "buy",
        "reduce_close_long": "sell",
        "reduce_close_short": "buy",
        "offset_close_long": "sell",
        "offset_close_short": "buy",
        "burst_close_long": "sell",
        "burst_close_short": "buy",
        "delivery_close_long": "sell",
        "delivery_close_short": "buy",
        "buy_single": "buy",
        "sell_single": "sell",
    }
    return this.SafeString(sides, side, side)
}
func  (this *coincatch) ParseOrderTimeInForce(timeInForce interface{}) interface{}  {
    var timeInForces interface{} = map[string]interface{} {
        "normal": "GTC",
        "post_only": "PO",
        "iok": "IOC",
        "fok": "FOK",
    }
    return this.SafeString(timeInForces, timeInForce, timeInForce)
}
func  (this *coincatch) ParseFeeDetailString(feeDetailString interface{}) interface{}  {
    var result interface{} = []interface{}{}
    var feeDetail interface{} = this.ParseJson(feeDetailString)
    if IsTrue(feeDetail) {
        var keys interface{} = ObjectKeys(feeDetail)
        for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
            var currencyId interface{} = this.SafeString(keys, i)
            if IsTrue(InOp(this.Currencies_by_id, currencyId)) {
                var currency interface{} = this.SafeCurrencyCode(currencyId)
                var feeEntry interface{} = this.SafeDict(feeDetail, currencyId, map[string]interface{} {})
                var amount interface{} = Precise.StringAbs(this.SafeString(feeEntry, "totalFee"))
                AppendToArray(&result,map[string]interface{} {
                    "currency": currency,
                    "amount": amount,
                })
            }
        }
    }
    return result
}
/**
 * @method
 * @name coincatch#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://coincatch.github.io/github.io/en/spot/#get-transaction-details
 * @see https://coincatch.github.io/github.io/en/mix/#get-order-fill-detail
 * @see https://coincatch.github.io/github.io/en/mix/#get-producttype-order-fill-detail
 * @param {string} symbol *is mandatory* unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] *swap markets only* the latest time in ms to fetch trades for, only supports the last 30 days timeframe
 * @param {string} [params.lastEndId] *swap markets only* query the data after this tradeId
 * @returns {Trade[]} a list of [trade structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#trade-structure}
 */
func  (this *coincatch) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var methodName interface{} = "fetchMyTrades"
            methodNameparamsVariable := this.HandleParamString(params, "methodName", methodName);
            methodName = GetValue(methodNameparamsVariable,0);
            params = GetValue(methodNameparamsVariable,1)
        
            retRes43188 := (<-this.LoadMarkets())
            PanicOnError(retRes43188)
            var market interface{} = nil
            var marketType interface{} = "spot"
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                marketType = GetValue(market, "type")
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            } else {
                marketTypeparamsVariable := this.HandleMarketTypeAndParams(methodName, market, params, marketType);
                marketType = GetValue(marketTypeparamsVariable,0);
                params = GetValue(marketTypeparamsVariable,1)
                if IsTrue(IsEqual(marketType, "spot")) {
                    panic(ArgumentsRequired(Add(Add(Add(this.Id, " "), methodName), "() requires a symbol argument for spot markets")))
                }
            }
            var response interface{} = nil
            var requestLimit interface{} = limit
            if IsTrue(IsEqual(marketType, "spot")) {
                var maxSpotLimit interface{} = 500
                if IsTrue(!IsEqual(since, nil)) {
                    requestLimit = maxSpotLimit
                }
                if IsTrue(!IsEqual(requestLimit, nil)) {
                    AddElementToObject(request, "limit", requestLimit)
                }
                //
                //     {
                //         "code": "00000",
                //         "msg": "success",
                //         "requestTime": 1725968747299,
                //         "data": [
                //             {
                //                 "accountId": "1002820815393",
                //                 "symbol": "ETHUSDT_SPBL",
                //                 "orderId": "1217143186968068096",
                //                 "fillId": "1217143193356505089",
                //                 "orderType": "market",
                //                 "side": "buy",
                //                 "fillPrice": "2340.55",
                //                 "fillQuantity": "0.0042",
                //                 "fillTotalAmount": "9.83031",
                //                 "feeCcy": "ETH",
                //                 "fees": "-0.0000042",
                //                 "takerMakerFlag": "taker",
                //                 "cTime": "1725915471400"
                //             },
                //             ...
                //         ]
                //     }
                //
                
        response = (<-this.PrivatePostApiSpotV1TradeFills(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(marketType, "swap")) {
                if IsTrue(!IsEqual(since, nil)) {
                    AddElementToObject(params, "startTime", since)
                } else {
                    AddElementToObject(params, "startTime", 0) // mandatory
                }
                var until interface{} = nil
                untilparamsVariable := this.HandleOptionAndParams(params, methodName, "until");
                until = GetValue(untilparamsVariable,0);
                params = GetValue(untilparamsVariable,1)
                if IsTrue(!IsEqual(until, nil)) {
                    AddElementToObject(request, "endTime", until)
                } else {
                    AddElementToObject(request, "endTime", this.Milliseconds()) // mandatory
                }
                if IsTrue(!IsEqual(symbol, nil)) {
                    //
                    //     {
                    //         "code": "00000",
                    //         "msg": "success",
                    //         "requestTime": 1728306590704,
                    //         "data": [
                    //             {
                    //                 "tradeId": "1221355735285014530",
                    //                 "symbol": "ETHUSDT_UMCBL",
                    //                 "orderId": "1221355728716259329",
                    //                 "price": "2555.12",
                    //                 "sizeQty": "0.01",
                    //                 "fee": "-0.01533072",
                    //                 "side": "open_long",
                    //                 "fillAmount": "25.5512",
                    //                 "profit": "0",
                    //                 "enterPointSource": "API",
                    //                 "tradeSide": "open_long",
                    //                 "holdMode": "double_hold",
                    //                 "takerMakerFlag": "taker",
                    //                 "cTime": "1726919819661"
                    //             }
                    //         ]
                    //     }
                    //
                    
        response = (<-this.PrivateGetApiMixV1OrderFills(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    var productType interface{} = "umcbl"
                    productType = this.HandleOption(methodName, "productType", productType)
                    AddElementToObject(request, "productType", productType)
                    //
                    //     {
                    //         "code": "00000",
                    //         "msg": "success",
                    //         "requestTime": 1728306372044,
                    //         "data": [
                    //             {
                    //                 "tradeId": "1225467075440189441",
                    //                 "symbol": "ETHUSD_DMCBL",
                    //                 "orderId": "1225467075288719360",
                    //                 "price": "2362.03",
                    //                 "sizeQty": "0.1",
                    //                 "fee": "-0.00005996",
                    //                 "side": "burst_close_long",
                    //                 "fillAmount": "236.203",
                    //                 "profit": "-0.0083359",
                    //                 "enterPointSource": "SYS",
                    //                 "tradeSide": "burst_close_long",
                    //                 "holdMode": "double_hold",
                    //                 "takerMakerFlag": "taker",
                    //                 "cTime": "1727900039539"
                    //             },
                    //             ...
                    //         ]
                    //     }
                    //
                    
        response = (<-this.PrivateGetApiMixV1OrderAllFills(this.Extend(request, params)))
                    PanicOnError(response)
                }
            } else {
                panic(NotSupported(Add(Add(Add(Add(Add(this.Id, " "), methodName), "() is not supported for "), marketType), " type of markets")))
            }
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTrades(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coincatch#fetchOrderTrades
 * @description fetch all the trades made from a single order
 * @see https://coincatch.github.io/github.io/en/spot/#get-transaction-details
 * @param {string} id order id
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *coincatch) FetchOrderTrades(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var methodName interface{} = "fetchOrderTrades"
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(Add(Add(this.Id, " "), methodName), " () requires a symbol argument")))
            }
            var request interface{} = map[string]interface{} {
                "orderId": id,
                "methodName": methodName,
            }
        
                retRes446815 :=  (<-this.FetchMyTrades(symbol, since, limit, this.Extend(request, params)))
                PanicOnError(retRes446815)
                ch <- retRes446815
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coincatch#fetchMarginMode
 * @description fetches the margin mode of the trading pair
 * @see https://coincatch.github.io/github.io/en/mix/#get-single-account
 * @param {string} symbol unified symbol of the market to fetch the margin mode for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [margin mode structure]{@link https://docs.ccxt.com/#/?id=margin-mode-structure}
 */
func  (this *coincatch) FetchMarginMode(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes44818 := (<-this.LoadMarkets())
            PanicOnError(retRes44818)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "marginCoin": GetValue(market, "settleId"),
            }
        
            response:= (<-this.PrivateGetApiMixV1AccountAccount(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1726669633799,
            //         "data": {
            //             "marginCoin": "ETH",
            //             "locked": "0",
            //             "available": "0.01",
            //             "crossMaxAvailable": "0.01",
            //             "fixedMaxAvailable": "0.01",
            //             "maxTransferOut": "0.01",
            //             "equity": "0.01",
            //             "usdtEquity": "22.97657025",
            //             "btcEquity": "0.000386195288",
            //             "crossRiskRate": "0",
            //             "crossMarginLeverage": 100,
            //             "fixedLongLeverage": 100,
            //             "fixedShortLeverage": 100,
            //             "marginMode": "crossed",
            //             "holdMode": "double_hold",
            //             "unrealizedPL": "0",
            //             "bonus": "0",
            //             "crossedUnrealizedPL": "0",
            //             "isolatedUnrealizedPL": ""
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseMarginMode(data, market)
            return nil
        
            }()
            return ch
        }
func  (this *coincatch) ParseMarginMode(marginMode interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marginType interface{} = this.SafeStringLower(marginMode, "marginMode")
    return map[string]interface{} {
        "info": marginMode,
        "symbol": this.SafeSymbol(nil, market),
        "marginMode": this.ParseMarginModeType(marginType),
    }
}
func  (this *coincatch) ParseMarginModeType(typeVar interface{}) interface{}  {
    var types interface{} = map[string]interface{} {
        "crossed": "cross",
        "fixed": "isolated",
    }
    return this.SafeString(types, typeVar, typeVar)
}
/**
 * @method
 * @name coincatch#setMarginMode
 * @description set margin mode to 'cross' or 'isolated'
 * @see https://coincatch.github.io/github.io/en/mix/#change-margin-mode
 * @param {string} marginMode 'cross' or 'isolated'
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} response from the exchange
 */
func  (this *coincatch) SetMarginMode(marginMode interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " setMarginMode() requires a symbol argument")))
            }
            marginMode = ToLower(marginMode)
        
            retRes45528 := (<-this.LoadMarkets())
            PanicOnError(retRes45528)
            var market interface{} = this.Market(symbol)
            if IsTrue(!IsEqual(GetValue(market, "type"), "swap")) {
                panic(NotSupported(Add(Add(Add(this.Id, " setMarginMode() is not supported for "), GetValue(market, "type")), " type of markets")))
            }
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "marginCoin": GetValue(market, "settleId"),
                "marginMode": this.EncodeMarginModeType(marginMode),
            }
        
            response:= (<-this.PrivatePostApiMixV1AccountSetMarginMode(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1726670096099,
            //         "data": {
            //             "symbol": "ETHUSD_DMCBL",
            //             "marginCoin": "ETH",
            //             "longLeverage": 10,
            //             "shortLeverage": 10,
            //             "crossMarginLeverage": null,
            //             "marginMode": "fixed"
            //         }
            //     }
            //
        ch <- response
            return nil
        
            }()
            return ch
        }
func  (this *coincatch) EncodeMarginModeType(typeVar interface{}) interface{}  {
    var types interface{} = map[string]interface{} {
        "cross": "crossed",
        "isolated": "fixed",
    }
    return this.SafeString(types, typeVar, typeVar)
}
/**
 * @method
 * @name coincatch#fetchPositionMode
 * @description fetchs the position mode, hedged or one way
 * @see https://coincatch.github.io/github.io/en/mix/#get-single-account
 * @param {string} symbol unified symbol of the market to fetch entry for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an object detailing whether the market is in hedged or one-way mode
 */
func  (this *coincatch) FetchPositionMode(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchPositionMode() requires a symbol argument")))
            }
        
            retRes46028 := (<-this.LoadMarkets())
            PanicOnError(retRes46028)
            var market interface{} = this.Market(symbol)
            if IsTrue(!IsEqual(GetValue(market, "type"), "swap")) {
                panic(NotSupported(Add(Add(Add(this.Id, " fetchPositionMode() is not supported for "), GetValue(market, "type")), " type of markets")))
            }
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "marginCoin": GetValue(market, "settleId"),
            }
        
            response:= (<-this.PrivateGetApiMixV1AccountAccount(this.Extend(request, params)))
            PanicOnError(response) // same endpoint as fetchMarginMode
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var holdMode interface{} = this.SafeString(data, "holdMode")
        
            ch <- map[string]interface{} {
                "info": response,
                "hedged": IsEqual(holdMode, "double_hold"),
            }
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coincatch#setPositionMode
 * @description set hedged to true or false for a market
 * @see https://bingx-api.github.io/docs/#/en-us/swapV2/trade-api.html#Set%20Position%20Mode
 * @param {bool} hedged set to true to use dualSidePosition
 * @param {string} symbol unified symbol of the market to fetch entry for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.productType] 'umcbl' or 'dmcbl' (default 'umcbl' if symbol is not provided)
 * @returns {object} response from the exchange
 */
func  (this *coincatch) SetPositionMode(hedged interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var methodName interface{} = "setPositionMode"
            var defaultProductType interface{} = "umcbl"
        
            retRes46348 := (<-this.LoadMarkets())
            PanicOnError(retRes46348)
            var productType interface{} = this.SafeString(params, "productType")
            if IsTrue(IsEqual(productType, nil)) {
                if IsTrue(!IsEqual(symbol, nil)) {
                    var market interface{} = this.Market(symbol)
                    if IsTrue(!IsEqual(GetValue(market, "type"), "swap")) {
                        panic(NotSupported(Add(Add(Add(this.Id, " setPositionMode() is not supported for "), GetValue(market, "type")), " type of markets")))
                    }
                    var marketId interface{} = GetValue(market, "id")
                    var parts interface{} = Split(marketId, "_")
                    productType = this.SafeStringLower(parts, 1, productType)
                } else {
                    productType = this.HandleOption(methodName, "productType", defaultProductType)
                }
            }
            var request interface{} = map[string]interface{} {
                "productType": productType,
                "holdMode": Ternary(IsTrue(hedged), "double_hold", "single_hold"),
            }
        
                retRes466415 :=  (<-this.PrivatePostApiMixV1AccountSetPositionMode(this.Extend(request, params)))
                PanicOnError(retRes466415)
                    //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1726677135005,
            //         "data": {
            //             "marginCoin": "ETH",
            //             "dualSidePosition": false
            //         }
            //     }
            //
        ch <- retRes466415
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coincatch#fetchLeverage
 * @description fetch the set leverage for a market
 * @see https://coincatch.github.io/github.io/en/mix/#get-single-account
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [leverage structure]{@link https://docs.ccxt.com/#/?id=leverage-structure}
 */
func  (this *coincatch) FetchLeverage(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes46778 := (<-this.LoadMarkets())
            PanicOnError(retRes46778)
            var market interface{} = this.Market(symbol)
            if IsTrue(!IsEqual(GetValue(market, "type"), "swap")) {
                panic(NotSupported(Add(Add(Add(this.Id, " fetchLeverage() is not supported for "), GetValue(market, "type")), " type of markets")))
            }
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "marginCoin": GetValue(market, "settleId"),
            }
        
            response:= (<-this.PrivateGetApiMixV1AccountAccount(this.Extend(request, params)))
            PanicOnError(response) // same endpoint as fetchMarginMode
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseLeverage(data, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coincatch#setLeverage
 * @description set the level of leverage for a market
 * @see https://hashkeyglobal-apidoc.readme.io/reference/change-futures-leverage-trade
 * @param {float} leverage the rate of leverage
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.side] *for isolated margin mode with hedged position mode only* 'long' or 'short'
 * @returns {object} response from the exchange
 */
func  (this *coincatch) SetLeverage(leverage interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var methodName interface{} = "setLeverage"
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(Add(Add(this.Id, " "), methodName), "() requires a symbol argument")))
            }
        
            retRes47078 := (<-this.LoadMarkets())
            PanicOnError(retRes47078)
            var market interface{} = this.Market(symbol)
            if IsTrue(!IsEqual(GetValue(market, "type"), "swap")) {
                panic(NotSupported(Add(Add(Add(Add(Add(this.Id, " "), methodName), "() is not supported for "), GetValue(market, "type")), " type of markets")))
            }
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "marginCoin": GetValue(market, "settleId"),
                "leverage": leverage,
            }
            var side interface{} = nil
            sideparamsVariable := this.HandleOptionAndParams(params, methodName, "side");
            side = GetValue(sideparamsVariable,0);
            params = GetValue(sideparamsVariable,1)
            if IsTrue(!IsEqual(side, nil)) {
                AddElementToObject(request, "holdSide", side)
            }
        
            response:= (<-this.PrivatePostApiMixV1AccountSetLeverage(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1726680486657,
            //         "data": {
            //             "symbol": "ETHUSD_DMCBL",
            //             "marginCoin": "ETH",
            //             "longLeverage": 2,
            //             "shortLeverage": 2,
            //             "crossMarginLeverage": 2,
            //             "marginMode": "crossed"
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseLeverage(data, market)
            return nil
        
            }()
            return ch
        }
func  (this *coincatch) ParseLeverage(leverage interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchLeverage
    //     {
    //         "marginCoin": "ETH",
    //         "locked": "0",
    //         "available": "0.01",
    //         "crossMaxAvailable": "0.01",
    //         "fixedMaxAvailable": "0.01",
    //         "maxTransferOut": "0.01",
    //         "equity": "0.01",
    //         "usdtEquity": "22.97657025",
    //         "btcEquity": "0.000386195288",
    //         "crossRiskRate": "0",
    //         "crossMarginLeverage": 100,
    //         "fixedLongLeverage": 100,
    //         "fixedShortLeverage": 100,
    //         "marginMode": "crossed",
    //         "holdMode": "double_hold",
    //         "unrealizedPL": "0",
    //         "bonus": "0",
    //         "crossedUnrealizedPL": "0",
    //         "isolatedUnrealizedPL": ""
    //     }
    //
    // setLeverage
    //     {
    //         "symbol": "ETHUSD_DMCBL",
    //         "marginCoin": "ETH",
    //         "longLeverage": 2,
    //         "shortLeverage": 2,
    //         "crossMarginLeverage": 2,
    //         "marginMode": "crossed"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(leverage, "symbol")
    market = this.SafeMarketCustom(marketId, market)
    var marginMode interface{} = this.ParseMarginModeType(this.SafeStringLower(leverage, "marginMode"))
    var longLeverage interface{} = this.SafeInteger2(leverage, "fixedLongLeverage", "longLeverage")
    var shortLeverage interface{} = this.SafeInteger2(leverage, "fixedShortLeverage", "shortLeverage")
    var crossMarginLeverage interface{} = this.SafeInteger(leverage, "crossMarginLeverage")
    if IsTrue(IsEqual(marginMode, "cross")) {
        longLeverage = crossMarginLeverage
        shortLeverage = crossMarginLeverage
    }
    return map[string]interface{} {
        "info": leverage,
        "symbol": GetValue(market, "symbol"),
        "marginMode": marginMode,
        "longLeverage": longLeverage,
        "shortLeverage": shortLeverage,
    }
}
func  (this *coincatch) ModifyMarginHelper(symbol interface{}, amount interface{}, typeVar interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var methodName interface{} = "modifyMarginHelper"
            methodNameparamsVariable := this.HandleParamString(params, "methodName", methodName);
            methodName = GetValue(methodNameparamsVariable,0);
            params = GetValue(methodNameparamsVariable,1)
        
            retRes47998 := (<-this.LoadMarkets())
            PanicOnError(retRes47998)
            var market interface{} = this.Market(symbol)
            if IsTrue(!IsEqual(GetValue(market, "type"), "swap")) {
                panic(NotSupported(Add(Add(Add(Add(Add(this.Id, " "), methodName), "() is not supported for "), GetValue(market, "type")), " type of markets")))
            }
            amount = this.AmountToPrecision(symbol, amount)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "marginCoin": GetValue(market, "settleId"),
                "amount": amount,
            }
            var side interface{} = nil
            sideparamsVariable := this.HandleOptionAndParams(params, methodName, "side");
            side = GetValue(sideparamsVariable,0);
            params = GetValue(sideparamsVariable,1)
            if IsTrue(!IsEqual(side, nil)) {
                AddElementToObject(request, "holdSide", side)
            }
        
            response:= (<-this.PrivatePostApiMixV1AccountSetMargin(this.Extend(request, params)))
            PanicOnError(response)
            // todo check response
            // always returns error
            // addMargin - "code":"45006","msg":"Insufficient position","requestTime":1729162281543,"data":null
            // reduceMargin - "code":"40800","msg":"Insufficient amount of margin","requestTime":1729162362718,"data":null
            if IsTrue(IsEqual(typeVar, "reduce")) {
                amount = Precise.StringAbs(amount)
            }
        
            ch <- this.Extend(this.ParseMarginModification(response, market), map[string]interface{} {
                "amount": this.ParseNumber(amount),
                "type": typeVar,
            })
            return nil
        
            }()
            return ch
        }
func  (this *coincatch) ParseMarginModification(data interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var msg interface{} = this.SafeString(data, "msg")
    var status interface{} = Ternary(IsTrue((IsEqual(msg, "success"))), "ok", "failed")
    return map[string]interface{} {
        "info": data,
        "symbol": GetValue(market, "symbol"),
        "type": nil,
        "marginMode": nil,
        "amount": nil,
        "total": nil,
        "code": GetValue(market, "quote"),
        "status": status,
        "timestamp": nil,
        "datetime": nil,
    }
}
/**
 * @method
 * @name coincatch#reduceMargin
 * @description remove margin from a position
 * @see https://coincatch.github.io/github.io/en/mix/#change-margin
 * @param {string} symbol unified market symbol
 * @param {float} amount the amount of margin to remove
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.side] *for isolated margin mode with hedged position mode only* 'long' or 'short'
 * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=reduce-margin-structure}
 */
func  (this *coincatch) ReduceMargin(symbol interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            AddElementToObject(params, "methodName", "reduceMargin")
        
                retRes486115 :=  (<-this.ModifyMarginHelper(symbol, OpNeg(amount), "reduce", params))
                PanicOnError(retRes486115)
                ch <- retRes486115
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coincatch#addMargin
 * @description add margin
 * @see https://coincatch.github.io/github.io/en/mix/#change-margin
 * @param {string} symbol unified market symbol
 * @param {float} amount amount of margin to add
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.side] *for isolated margin mode with hedged position mode only* 'long' or 'short'
 * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=add-margin-structure}
 */
func  (this *coincatch) AddMargin(symbol interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            AddElementToObject(params, "methodName", "addMargin")
        
                retRes487715 :=  (<-this.ModifyMarginHelper(symbol, amount, "add", params))
                PanicOnError(retRes487715)
                ch <- retRes487715
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coincatch#fetchPosition
 * @description fetch data on a single open contract trade position
 * @see https://coincatch.github.io/github.io/en/mix/#get-symbol-position
 * @param {string} symbol unified market symbol of the market the position is held in, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string}  [params.side] 'long' or 'short' *for non-hedged position mode only* (default 'long')
 * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *coincatch) FetchPosition(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var methodName interface{} = "fetchPosition"
            var side interface{} = "long"
            sideparamsVariable := this.HandleOptionAndParams(params, methodName, "side");
            side = GetValue(sideparamsVariable,0);
            params = GetValue(sideparamsVariable,1)
        
            positions:= (<-this.FetchPositionsForSymbol(symbol, params))
            PanicOnError(positions)
            var arrayLength interface{} =     GetArrayLength(positions)
            if IsTrue(IsGreaterThan(arrayLength, 1)) {
                for i := 0; IsLessThan(i, GetArrayLength(positions)); i++ {
                    var position interface{} = GetValue(positions, i)
                    if IsTrue(IsEqual(GetValue(position, "side"), side)) {
        
                        ch <- position
                        return nil
                    }
                }
            }
        
            ch <- GetValue(positions, 0)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @description fetch open positions for a single market
 * @name coincatch#fetchPositionsForSymbol
 * @see https://coincatch.github.io/github.io/en/mix/#get-symbol-position
 * @description fetch all open positions for specific symbol
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *coincatch) FetchPositionsForSymbol(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes49188 := (<-this.LoadMarkets())
            PanicOnError(retRes49188)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "marginCoin": GetValue(market, "settleId"),
            }
        
            response:= (<-this.PrivateGetApiMixV1PositionSinglePositionV2(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1726926959041,
            //         "data": [
            //             {
            //                 "marginCoin": "USDT",
            //                 "symbol": "ETHUSDT_UMCBL",
            //                 "holdSide": "long",
            //                 "openDelegateCount": "0",
            //                 "margin": "2.55512",
            //                 "available": "0.01",
            //                 "locked": "0",
            //                 "total": "0.01",
            //                 "leverage": 10,
            //                 "achievedProfits": "0",
            //                 "averageOpenPrice": "2555.12",
            //                 "marginMode": "crossed",
            //                 "holdMode": "double_hold",
            //                 "unrealizedPL": "0.1371",
            //                 "liquidationPrice": "-3433.328491",
            //                 "keepMarginRate": "0.0033",
            //                 "marketPrice": "2568.83",
            //                 "marginRatio": "0.001666357648",
            //                 "autoMargin": "off",
            //                 "cTime": "1726919819686"
            //             }
            //         ]
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParsePositions(data, []interface{}{symbol})
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coincatch#fetchPositions
 * @description fetch all open positions
 * @see https://coincatch.github.io/github.io/en/mix/#get-all-position
 * @param {string[]} [symbols] list of unified market symbols (all symbols must belong to the same product type)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.productType] 'umcbl' or 'dmcbl' (default 'umcbl' if symbols are not provided)
 * @param {string} [params.marginCoin] the settle currency of the positions, needs to match the productType
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *coincatch) FetchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var methodName interface{} = "fetchPositions"
        
            retRes49738 := (<-this.LoadMarkets())
            PanicOnError(retRes49738)
            var productType interface{} = "umcbl"
            if IsTrue(!IsEqual(symbols, nil)) {
                var marketIds interface{} = this.MarketIds(symbols)
                var productTypes interface{} = []interface{}{}
                for i := 0; IsLessThan(i, GetArrayLength(marketIds)); i++ {
                    var marketId interface{} = GetValue(marketIds, i)
                    var parts interface{} = Split(marketId, "_")
                    var marketProductType interface{} = this.SafeString(parts, 1)
                    AppendToArray(&productTypes,marketProductType)
                }
                productTypes = this.Unique(productTypes)
                var arrayLength interface{} =         GetArrayLength(productTypes)
                if IsTrue(IsGreaterThan(arrayLength, 1)) {
                    panic(BadSymbol(Add(Add(Add(this.Id, " "), methodName), "() requires all symbols to belong to the same product type (umcbl or dmcbl)")))
                } else {
                    productType = GetValue(productTypes, 0)
                }
            } else {
                productTypeparamsVariable := this.HandleOptionAndParams(params, methodName, "productType", productType);
                productType = GetValue(productTypeparamsVariable,0);
                params = GetValue(productTypeparamsVariable,1)
            }
            var request interface{} = map[string]interface{} {
                "productType": productType,
            }
            if IsTrue(IsEqual(productType, "dmcbl")) {
                var marginCoin interface{} = nil
                marginCoinparamsVariable := this.HandleOptionAndParams(params, methodName, "marginCoin");
                marginCoin = GetValue(marginCoinparamsVariable,0);
                params = GetValue(marginCoinparamsVariable,1)
                if IsTrue(!IsEqual(marginCoin, nil)) {
                    var currency interface{} = this.Currency(marginCoin)
                    AddElementToObject(request, "marginCoin", GetValue(currency, "id"))
                }
            }
        
            response:= (<-this.PrivateGetApiMixV1PositionAllPositionV2(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "00000",
            //         "msg": "success",
            //         "requestTime": 1726933132054,
            //         "data": [
            //             {
            //                 "marginCoin": "USDT",
            //                 "symbol": "ETHUSDT_UMCBL",
            //                 "holdSide": "long",
            //                 "openDelegateCount": "0",
            //                 "margin": "2.55512",
            //                 "available": "0.01",
            //                 "locked": "0",
            //                 "total": "0.01",
            //                 "leverage": 10,
            //                 "achievedProfits": "0",
            //                 "averageOpenPrice": "2555.12",
            //                 "marginMode": "crossed",
            //                 "holdMode": "double_hold",
            //                 "unrealizedPL": "0.0093",
            //                 "liquidationPrice": "-3433.378333",
            //                 "keepMarginRate": "0.0033",
            //                 "marketPrice": "2556.05",
            //                 "marginRatio": "0.001661599511",
            //                 "autoMargin": "off",
            //                 "cTime": "1726919819686",
            //                 "uTime": "1726919819686"
            //             }
            //         ]
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParsePositions(data, symbols)
            return nil
        
            }()
            return ch
        }
func  (this *coincatch) ParsePosition(position interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "marginCoin": "USDT",
    //         "symbol": "ETHUSDT_UMCBL",
    //         "holdSide": "long",
    //         "openDelegateCount": "0",
    //         "margin": "2.55512",
    //         "available": "0.01",
    //         "locked": "0",
    //         "total": "0.01",
    //         "leverage": 10,
    //         "achievedProfits": "0",
    //         "averageOpenPrice": "2555.12",
    //         "marginMode": "crossed",
    //         "holdMode": "double_hold",
    //         "unrealizedPL": "0.0093",
    //         "liquidationPrice": "-3433.378333",
    //         "keepMarginRate": "0.0033",
    //         "marketPrice": "2556.05",
    //         "marginRatio": "0.001661599511",
    //         "autoMargin": "off",
    //         "cTime": "1726919819686",
    //         "uTime": "1726919819686"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(position, "symbol")
    var settleId interface{} = this.SafeString(position, "marginCoin")
    market = this.SafeMarketCustom(marketId, market, settleId)
    var timestamp interface{} = this.SafeInteger(position, "cTime")
    var marginMode interface{} = this.SafeString(position, "marginMode")
    var isHedged interface{} = nil
    var holdMode interface{} = this.SafeString(position, "holdMode")
    if IsTrue(IsEqual(holdMode, "double_hold")) {
        isHedged = true
    } else if IsTrue(IsEqual(holdMode, "single_hold")) {
        isHedged = false
    }
    var margin interface{} = this.SafeNumber(position, "margin")
    var keepMarginRate interface{} = this.SafeString(position, "keepMarginRate")
    return this.SafePosition(map[string]interface{} {
        "symbol": GetValue(market, "symbol"),
        "id": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "contracts": this.SafeNumber(position, "total"),
        "contractSize": nil,
        "side": this.SafeStringLower(position, "holdSide"),
        "notional": margin,
        "leverage": this.SafeInteger(position, "leverage"),
        "unrealizedPnl": this.SafeNumber(position, "unrealizedPL"),
        "realizedPnl": this.SafeNumber(position, "achievedProfits"),
        "collateral": nil,
        "entryPrice": this.SafeNumber(position, "averageOpenPrice"),
        "markPrice": this.SafeNumber(position, "marketPrice"),
        "liquidationPrice": this.SafeNumber(position, "liquidationPrice"),
        "marginMode": this.ParseMarginModeType(marginMode),
        "hedged": isHedged,
        "maintenanceMargin": nil,
        "maintenanceMarginPercentage": this.ParseNumber(Precise.StringMul(keepMarginRate, "100")),
        "initialMargin": margin,
        "initialMarginPercentage": nil,
        "marginRatio": this.SafeNumber(position, "marginRatio"),
        "lastUpdateTimestamp": this.SafeInteger(position, "uTime"),
        "lastPrice": nil,
        "stopLossPrice": nil,
        "takeProfitPrice": nil,
        "percentage": nil,
        "info": position,
    })
}
func  (this *coincatch) SafeMarketCustom(marketId interface{}, optionalArgs ...interface{}) interface{}  {
    // catch block:
    // dmcbl markets have the same id and market type but different settleId
    // so we need to resolve the market by settleId
    // try block:
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    settleId := GetArg(optionalArgs, 1, nil)
    _ = settleId
    
    {		ret__ := func(this *coincatch) (ret_ interface{}) {
    		defer func() {
    			if e := recover(); e != nil {
                    if e == "break" {
    				    return
    			    }
    				ret_ = func(this *coincatch) interface{} {
            var marketsWithCurrentId interface{} = this.SafeList(this.Markets_by_id, marketId, []interface{}{})
            if IsTrue(IsEqual(settleId, nil)) {
                market = GetValue(marketsWithCurrentId, 0) // if settleId is not provided, return the first market with the current id
            } else {
                for i := 0; IsLessThan(i, GetArrayLength(marketsWithCurrentId)); i++ {
                    var marketWithCurrentId interface{} = GetValue(marketsWithCurrentId, i)
                    if IsTrue(IsEqual(GetValue(marketWithCurrentId, "settleId"), settleId)) {
                        market = marketWithCurrentId
                        break
                    }
                }
            }
                        return nil
    				}(this)
    			}
    		}()
                    market = this.SafeMarket(marketId, market)
    		return nil
    	}(this)
    	if ret__ != nil {
    		return ret__
    	}
    }
    return market
}
/**
 * @method
 * @name coincatch#fetchLedger
 * @description fetch the history of changes, actions done by the user or operations that altered balance of the user
 * @see https://coincatch.github.io/github.io/en/spot/#get-bills
 * @see https://coincatch.github.io/github.io/en/mix/#get-business-account-bill
 * @param {string} [code] unified currency code
 * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
 * @param {int} [limit] max number of ledger entrys to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] *swap only* the latest time in ms to fetch entries for
 * @param {string} [params.type] 'spot' or 'swap' (default 'spot')
 * @param {string} [params.after] *spot only* billId, return the data less than this billId
 * @param {string} [params.before] *spot only* billId, return the data greater than or equals to this billId
 * @param {string} [params.groupType] *spot only*
 * @param {string} [params.bizType] *spot only*
 * @param {string} [params.productType] *swap only* 'umcbl' or 'dmcbl' (default 'umcbl' or 'dmcbl' if code is provided and code is not equal to 'USDT')
 * @param {string} [params.business] *swap only*
 * @param {string} [params.lastEndId] *swap only*
 * @param {bool} [params.next] *swap only*
 * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger}
 */
func  (this *coincatch) FetchLedger(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var methodName interface{} = "fetchLedger"
        
            retRes51608 := (<-this.LoadMarkets())
            PanicOnError(retRes51608)
            var request interface{} = map[string]interface{} {}
            var marketType interface{} = "spot"
            marketTypeparamsVariable := this.HandleMarketTypeAndParams(methodName, nil, params, marketType);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            var result interface{} = nil
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
            }
            if IsTrue(IsEqual(marketType, "spot")) {
                if IsTrue(!IsEqual(currency, nil)) {
                    var numericId interface{} = this.SafeString(currency, "numericId")
                    AddElementToObject(request, "coinId", numericId)
                }
                if IsTrue(!IsEqual(limit, nil)) {
                    AddElementToObject(request, "limit", limit)
                }
        
                response:= (<-this.PrivatePostApiSpotV1AccountBills(this.Extend(request, params)))
                PanicOnError(response)
                //
                //     {
                //         "code": "00000",
                //         "msg": "success",
                //         "requestTime": 1727964749515,
                //         "data": [
                //             {
                //                 "billId": "1220289012519190529",
                //                 "coinId": 2,
                //                 "coinName": "USDT",
                //                 "groupType": "transfer",
                //                 "bizType": "Transfer out",
                //                 "quantity": "-40.00000000",
                //                 "balance": "4.43878673",
                //                 "fees": "0.00000000",
                //                 "cTime": "1726665493092"
                //             },
                //             ...
                //         ]
                //     }
                //
                result = this.SafeList(response, "data", []interface{}{})
            } else if IsTrue(IsEqual(marketType, "swap")) {
                if IsTrue(!IsEqual(since, nil)) {
                    AddElementToObject(request, "startTime", since)
                } else {
                    AddElementToObject(request, "startTime", 0) // is mandatory
                }
                var until interface{} = nil
                untilparamsVariable := this.HandleOptionAndParams(params, methodName, "until");
                until = GetValue(untilparamsVariable,0);
                params = GetValue(untilparamsVariable,1)
                if IsTrue(!IsEqual(until, nil)) {
                    AddElementToObject(request, "endTime", until)
                } else {
                    AddElementToObject(request, "endTime", this.Milliseconds()) // is mandatory
                }
                if IsTrue(!IsEqual(limit, nil)) {
                    AddElementToObject(request, "pageSize", limit)
                }
                var productType interface{} = "umcbl"
                if IsTrue(IsEqual(code, nil)) {
                    productType = this.HandleOption(methodName, "productType", productType)
                } else if IsTrue(IsEqual(code, "USDT")) {
                    productType = "umcbl"
                } else {
                    productType = "dmcbl"
                }
                productTypeparamsVariable := this.HandleParamString(params, "productType", productType);
                productType = GetValue(productTypeparamsVariable,0);
                params = GetValue(productTypeparamsVariable,1)
                AddElementToObject(request, "productType", productType)
        
                response:= (<-this.PrivateGetApiMixV1AccountAccountBusinessBill(this.Extend(request, params)))
                PanicOnError(response)
                //
                //     {
                //         "code": "00000",
                //         "msg": "success",
                //         "requestTime": 1727971607663,
                //         "data": {
                //             "result": [
                //                 {
                //                     "id": "1225766556446064640",
                //                     "symbol": null,
                //                     "marginCoin": "ETH",
                //                     "amount": "-0.0016",
                //                     "fee": "0",
                //                     "feeByCoupon": "",
                //                     "feeCoin": "ETH",
                //                     "business": "trans_to_exchange",
                //                     "cTime": "1727971441425"
                //                 },
                //                 {
                //                     "id": "1225467081664061441",
                //                     "symbol": "ETHUSD_DMCBL",
                //                     "marginCoin": "ETH",
                //                     "amount": "-0.00052885",
                //                     "fee": "0",
                //                     "feeByCoupon": "",
                //                     "feeCoin": "ETH",
                //                     "business": "risk_captital_user_transfer",
                //                     "cTime": "1727900041024"
                //                 },
                //                 {
                //                     "id": "1225467075440189441",
                //                     "symbol": "ETHUSD_DMCBL",
                //                     "marginCoin": "ETH",
                //                     "amount": "-0.0083359",
                //                     "fee": "-0.00005996",
                //                     "feeByCoupon": "",
                //                     "feeCoin": "ETH",
                //                     "business": "burst_long_loss_query",
                //                     "cTime": "1727900039576"
                //                 },
                //                 {
                //                     "id": "1221416895715303426",
                //                     "symbol": "ETHUSD_DMCBL",
                //                     "marginCoin": "ETH",
                //                     "amount": "0.00004756",
                //                     "fee": "0",
                //                     "feeByCoupon": "",
                //                     "feeCoin": "ETH",
                //                     "business": "contract_settle_fee",
                //                     "cTime": "1726934401444"
                //                 },
                //                 {
                //                     "id": "1221413703233871873",
                //                     "symbol": "ETHUSD_DMCBL",
                //                     "marginCoin": "ETH",
                //                     "amount": "0",
                //                     "fee": "-0.00005996",
                //                     "feeByCoupon": "",
                //                     "feeCoin": "ETH",
                //                     "business": "open_long",
                //                     "cTime": "1726933640336"
                //                 },
                //                 {
                //                     "id": "1220288640761122816",
                //                     "symbol": null,
                //                     "marginCoin": "ETH",
                //                     "amount": "0.01",
                //                     "fee": "0",
                //                     "feeByCoupon": "",
                //                     "feeCoin": "ETH",
                //                     "business": "trans_from_exchange",
                //                     "cTime": "1726665404563"
                //                 }
                //             ],
                //             "lastEndId": "1220288641021337600",
                //             "nextFlag": false,
                //             "preFlag": false
                //         }
                //     }
                //
                var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
                result = this.SafeList(data, "result", []interface{}{})
            } else {
                panic(NotSupported(Add(Add(Add(Add(this.Id, " "), methodName), "() does not support market type "), marketType)))
            }
        
            ch <- this.ParseLedger(result, currency, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *coincatch) ParseLedgerEntry(item interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // spot
    //     {
    //         "billId": "1220289012519190529",
    //         "coinId": 2,
    //         "coinName": "USDT",
    //         "groupType": "transfer",
    //         "bizType": "Transfer out",
    //         "quantity": "-40.00000000",
    //         "balance": "4.43878673",
    //         "fees": "0.00000000",
    //         "cTime": "1726665493092"
    //     }
    //
    // swap
    //     {
    //         "id": "1220288640761122816",
    //         "symbol": null,
    //         "marginCoin": "ETH",
    //         "amount": "0.01",
    //         "fee": "0",
    //         "feeByCoupon": "",
    //         "feeCoin": "ETH",
    //         "business": "trans_from_exchange",
    //         "cTime": "1726665404563"
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var timestamp interface{} = this.SafeInteger(item, "cTime")
    var settleId interface{} = this.SafeString2(item, "coinName", "marginCoin")
    var market interface{} = nil
    var marketId interface{} = this.SafeString(item, "symbol")
    market = this.SafeMarketCustom(marketId, market, settleId)
    var amountString interface{} = this.SafeString2(item, "quantity", "amount")
    var direction interface{} = "in"
    if IsTrue(Precise.StringLt(amountString, "0")) {
        direction = "out"
        amountString = Precise.StringMul(amountString, "-1")
    }
    var fee interface{} = map[string]interface{} {
        "cost": Precise.StringAbs(this.SafeString2(item, "fee", "fees")),
        "currency": this.SafeString(item, "feeCoin"),
    }
    return this.SafeLedgerEntry(map[string]interface{} {
        "id": this.SafeString2(item, "billId", "id"),
        "info": item,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "account": nil,
        "direction": direction,
        "referenceId": nil,
        "referenceAccount": nil,
        "type": this.ParseLedgerEntryType(this.SafeStringLower2(item, "bizType", "business")),
        "currency": this.SafeCurrencyCode(settleId, currency),
        "symbol": GetValue(market, "symbol"),
        "amount": amountString,
        "before": nil,
        "after": this.SafeString(item, "balance"),
        "status": "ok",
        "fee": fee,
    }, currency)
}
func  (this *coincatch) ParseLedgerEntryType(typeVar interface{}) interface{}  {
    var types interface{} = map[string]interface{} {
        "deposit": "deposit",
        "withdraw": "withdrawal",
        "buy": "trade",
        "sell": "trade",
        "deduction of handling fee": "fee",
        "transfer-in": "transfer",
        "transfer in": "transfer",
        "transfer out": "transfer",
        "rebate rewards": "rebate",
        "airdrop rewards": "rebate",
        "usdt contract rewards": "rebate",
        "mix contract rewards": "rebate",
        "system lock": "system lock",
        "user lock": "user lock",
        "open_long": "trade",
        "open_short": "trade",
        "close_long": "trade",
        "close_short": "trade",
        "trans_from_exchange": "transfer",
        "trans_to_exchange": "transfer",
        "contract_settle_fee": "fee",
        "burst_long_loss_query": "trade",
        "burst_short_loss_query": "trade",
    }
    return this.SafeString(types, typeVar, typeVar)
}
func  (this *coincatch) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if !IsTrue(response) {
        return nil  // fallback to default error handler
    }
    var message interface{} = this.SafeString(response, "msg")
    var feedback interface{} = Add(Add(this.Id, " "), body)
    var messageCode interface{} = this.SafeString(response, "code")
    var success interface{} = IsTrue((IsEqual(message, "success"))) || IsTrue((IsEqual(message, nil)))
    if IsTrue(IsGreaterThanOrEqual(GetIndexOf(url, "batch"), 0)) {
        var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        var failure interface{} = this.SafeList2(data, "failure", "fail_infos", []interface{}{})
        if !IsTrue(this.IsEmpty(failure)) {
            success = false
            var firstEntry interface{} = this.SafeDict(failure, 0, map[string]interface{} {})
            messageCode = this.SafeString(firstEntry, "errorCode")
            message = this.SafeString(firstEntry, "errorMsg")
        }
    }
    if !IsTrue(success) {
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), messageCode, feedback)
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), message, feedback)
        panic(ExchangeError(feedback))
    }
    return nil
}
func  (this *coincatch) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var endpoint interface{} = Add("/", path)
    if IsTrue(IsEqual(method, "GET")) {
        var query interface{} = this.Urlencode(params)
        if IsTrue(!IsEqual(GetArrayLength(query), 0)) {
            endpoint = Add(endpoint, Add("?", query))
        }
    }
    if IsTrue(IsEqual(api, "private")) {
        this.CheckRequiredCredentials()
        var timestamp interface{} = this.NumberToString(this.Milliseconds())
        var suffix interface{} = ""
        if IsTrue(!IsEqual(method, "GET")) {
            body = this.Json(params)
            suffix = body
        }
        var payload interface{} = Add(Add(Add(timestamp, method), endpoint), suffix)
        var signature interface{} = this.Hmac(this.Encode(payload), this.Encode(this.Secret), sha256, "base64")
        headers = map[string]interface{} {
            "ACCESS-KEY": this.ApiKey,
            "ACCESS-SIGN": signature,
            "ACCESS-TIMESTAMP": timestamp,
            "ACCESS-PASSPHRASE": this.Password,
            "Content-Type": "application/json",
            "X-CHANNEL-API-CODE": this.SafeString(this.Options, "brokerId", "47cfy"),
        }
    }
    var url interface{} = Add(GetValue(GetValue(this.Urls, "api"), api), endpoint)
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}


func (this *coincatch) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
