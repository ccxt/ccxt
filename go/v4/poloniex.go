package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type poloniex struct {
    Exchange

}

func NewPoloniexCore() poloniex {
   p := poloniex{}
   setDefaults(&p)
   return p
}

func  (this *poloniex) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "poloniex",
        "name": "Poloniex",
        "countries": []interface{}{"US"},
        "rateLimit": 5,
        "certified": false,
        "pro": true,
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": nil,
            "swap": true,
            "future": true,
            "option": false,
            "addMargin": true,
            "cancelAllOrders": true,
            "cancelOrder": true,
            "cancelOrders": nil,
            "createDepositAddress": true,
            "createMarketBuyOrderWithCost": true,
            "createMarketOrderWithCost": false,
            "createMarketSellOrderWithCost": false,
            "createOrder": true,
            "createOrders": nil,
            "createStopOrder": true,
            "createTriggerOrder": true,
            "editOrder": true,
            "fetchBalance": true,
            "fetchClosedOrder": false,
            "fetchClosedOrders": true,
            "fetchCurrencies": true,
            "fetchDepositAddress": true,
            "fetchDepositAddresses": false,
            "fetchDepositAddressesByNetwork": false,
            "fetchDeposits": true,
            "fetchDepositsWithdrawals": true,
            "fetchDepositWithdrawFee": "emulated",
            "fetchDepositWithdrawFees": true,
            "fetchFundingHistory": false,
            "fetchFundingInterval": false,
            "fetchFundingIntervals": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": nil,
            "fetchLedger": nil,
            "fetchLeverage": true,
            "fetchLiquidations": nil,
            "fetchMarginMode": false,
            "fetchMarkets": true,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrder": false,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrderBooks": false,
            "fetchOrderTrades": true,
            "fetchPosition": false,
            "fetchPositionMode": true,
            "fetchPositions": true,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTime": true,
            "fetchTrades": true,
            "fetchTradingFee": false,
            "fetchTradingFees": true,
            "fetchTransactions": "emulated",
            "fetchTransfer": false,
            "fetchTransfers": false,
            "fetchWithdrawals": true,
            "reduceMargin": true,
            "sandbox": true,
            "setLeverage": true,
            "setPositionMode": true,
            "transfer": true,
            "withdraw": true,
        },
        "timeframes": map[string]interface{} {
            "1m": "MINUTE_1",
            "5m": "MINUTE_5",
            "10m": "MINUTE_10",
            "15m": "MINUTE_15",
            "30m": "MINUTE_30",
            "1h": "HOUR_1",
            "2h": "HOUR_2",
            "4h": "HOUR_4",
            "6h": "HOUR_6",
            "12h": "HOUR_12",
            "1d": "DAY_1",
            "3d": "DAY_3",
            "1w": "WEEK_1",
            "1M": "MONTH_1",
        },
        "urls": map[string]interface{} {
            "logo": "https://user-images.githubusercontent.com/1294454/27766817-e9456312-5ee6-11e7-9b3c-b628ca5626a5.jpg",
            "api": map[string]interface{} {
                "spot": "https://api.poloniex.com",
                "swap": "https://api.poloniex.com",
            },
            "test": map[string]interface{} {
                "spot": "https://sand-spot-api-gateway.poloniex.com",
            },
            "www": "https://www.poloniex.com",
            "doc": "https://api-docs.poloniex.com/spot/",
            "fees": "https://poloniex.com/fees",
            "referral": "https://poloniex.com/signup?c=UBFZJRPJ",
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": map[string]interface{} {
                    "markets": 20,
                    "markets/{symbol}": 1,
                    "currencies": 20,
                    "currencies/{currency}": 20,
                    "v2/currencies": 20,
                    "v2/currencies/{currency}": 20,
                    "timestamp": 1,
                    "markets/price": 1,
                    "markets/{symbol}/price": 1,
                    "markets/markPrice": 1,
                    "markets/{symbol}/markPrice": 1,
                    "markets/{symbol}/markPriceComponents": 1,
                    "markets/{symbol}/orderBook": 1,
                    "markets/{symbol}/candles": 1,
                    "markets/{symbol}/trades": 20,
                    "markets/ticker24h": 20,
                    "markets/{symbol}/ticker24h": 20,
                    "markets/collateralInfo": 1,
                    "markets/{currency}/collateralInfo": 1,
                    "markets/borrowRatesInfo": 1,
                },
            },
            "private": map[string]interface{} {
                "get": map[string]interface{} {
                    "accounts": 4,
                    "accounts/balances": 4,
                    "accounts/{id}/balances": 4,
                    "accounts/activity": 20,
                    "accounts/transfer": 20,
                    "accounts/transfer/{id}": 4,
                    "feeinfo": 20,
                    "accounts/interest/history": 1,
                    "subaccounts": 4,
                    "subaccounts/balances": 20,
                    "subaccounts/{id}/balances": 4,
                    "subaccounts/transfer": 20,
                    "subaccounts/transfer/{id}": 4,
                    "wallets/addresses": 20,
                    "wallets/addresses/{currency}": 20,
                    "wallets/activity": 20,
                    "margin/accountMargin": 4,
                    "margin/borrowStatus": 4,
                    "margin/maxSize": 4,
                    "orders": 20,
                    "orders/{id}": 4,
                    "orders/killSwitchStatus": 4,
                    "smartorders": 20,
                    "smartorders/{id}": 4,
                    "orders/history": 20,
                    "smartorders/history": 20,
                    "trades": 20,
                    "orders/{id}/trades": 4,
                },
                "post": map[string]interface{} {
                    "accounts/transfer": 4,
                    "subaccounts/transfer": 20,
                    "wallets/address": 20,
                    "wallets/withdraw": 20,
                    "v2/wallets/withdraw": 20,
                    "orders": 4,
                    "orders/batch": 20,
                    "orders/killSwitch": 4,
                    "smartorders": 4,
                },
                "delete": map[string]interface{} {
                    "orders/{id}": 4,
                    "orders/cancelByIds": 20,
                    "orders": 20,
                    "smartorders/{id}": 4,
                    "smartorders/cancelByIds": 20,
                    "smartorders": 20,
                },
                "put": map[string]interface{} {
                    "orders/{id}": 20,
                    "smartorders/{id}": 20,
                },
            },
            "swapPublic": map[string]interface{} {
                "get": map[string]interface{} {
                    "v3/market/allInstruments": Divide(2, 3),
                    "v3/market/instruments": Divide(2, 3),
                    "v3/market/orderBook": Divide(2, 3),
                    "v3/market/candles": 10,
                    "v3/market/indexPriceCandlesticks": 10,
                    "v3/market/premiumIndexCandlesticks": 10,
                    "v3/market/markPriceCandlesticks": 10,
                    "v3/market/trades": Divide(2, 3),
                    "v3/market/liquidationOrder": Divide(2, 3),
                    "v3/market/tickers": Divide(2, 3),
                    "v3/market/markPrice": Divide(2, 3),
                    "v3/market/indexPrice": Divide(2, 3),
                    "v3/market/indexPriceComponents": Divide(2, 3),
                    "v3/market/fundingRate": Divide(2, 3),
                    "v3/market/openInterest": Divide(2, 3),
                    "v3/market/insurance": Divide(2, 3),
                    "v3/market/riskLimit": Divide(2, 3),
                },
            },
            "swapPrivate": map[string]interface{} {
                "get": map[string]interface{} {
                    "v3/account/balance": 4,
                    "v3/account/bills": 20,
                    "v3/trade/order/opens": 20,
                    "v3/trade/order/trades": 20,
                    "v3/trade/order/history": 20,
                    "v3/trade/position/opens": 20,
                    "v3/trade/position/history": 20,
                    "v3/position/leverages": 20,
                    "v3/position/mode": 20,
                },
                "post": map[string]interface{} {
                    "v3/trade/order": 4,
                    "v3/trade/orders": 40,
                    "v3/trade/position": 20,
                    "v3/trade/positionAll": 100,
                    "v3/position/leverage": 20,
                    "v3/position/mode": 20,
                    "v3/trade/position/margin": 20,
                },
                "delete": map[string]interface{} {
                    "v3/trade/order": 2,
                    "v3/trade/batchOrders": 20,
                    "v3/trade/allOrders": 20,
                },
            },
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "feeSide": "get",
                "maker": this.ParseNumber("0.0009"),
                "taker": this.ParseNumber("0.0009"),
            },
            "funding": map[string]interface{} {},
        },
        "commonCurrencies": map[string]interface{} {
            "AIR": "AirCoin",
            "APH": "AphroditeCoin",
            "BCC": "BTCtalkcoin",
            "BCHABC": "BCHABC",
            "BDG": "Badgercoin",
            "BTM": "Bitmark",
            "CON": "Coino",
            "ETHTRON": "ETH",
            "GOLD": "GoldEagles",
            "GPUC": "GPU",
            "HOT": "Hotcoin",
            "ITC": "Information Coin",
            "KEY": "KEYCoin",
            "MASK": "NFTX Hashmasks Index",
            "MEME": "Degenerator Meme",
            "PLX": "ParallaxCoin",
            "REPV2": "REP",
            "STR": "XLM",
            "SOC": "SOCC",
            "TRADE": "Unitrade",
            "TRXETH": "TRX",
            "XAP": "API Coin",
            "USDTBSC": "USDT",
            "USDTTRON": "USDT",
            "USDTETH": "USDT",
            "UST": "USTC",
        },
        "options": map[string]interface{} {
            "defaultType": "spot",
            "createMarketBuyOrderRequiresPrice": true,
            "networks": map[string]interface{} {
                "BEP20": "BSC",
                "ERC20": "ETH",
                "TRC20": "TRON",
            },
            "limits": map[string]interface{} {
                "cost": map[string]interface{} {
                    "min": map[string]interface{} {
                        "BTC": 0.0001,
                        "ETH": 0.0001,
                        "USDT": 1,
                        "TRX": 100,
                        "BNB": 0.06,
                        "USDC": 1,
                        "USDJ": 1,
                        "TUSD": 0.0001,
                        "DAI": 1,
                        "PAX": 1,
                        "BUSD": 1,
                    },
                },
            },
            "accountsByType": map[string]interface{} {
                "spot": "spot",
                "future": "futures",
            },
            "accountsById": map[string]interface{} {
                "exchange": "spot",
                "futures": "future",
            },
        },
        "features": map[string]interface{} {
            "default": map[string]interface{} {
                "sandbox": true,
                "createOrder": map[string]interface{} {
                    "marginMode": true,
                    "triggerPrice": true,
                    "triggerPriceType": nil,
                    "triggerDirection": false,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": true,
                        "FOK": true,
                        "PO": true,
                        "GTD": false,
                    },
                    "hedged": false,
                    "leverage": false,
                    "marketBuyByCost": true,
                    "marketBuyRequiresPrice": false,
                    "selfTradePrevention": true,
                    "trailing": false,
                    "iceberg": false,
                },
                "createOrders": map[string]interface{} {
                    "max": 20,
                },
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": 1000,
                    "daysBack": 100000,
                    "untilDays": 100000,
                    "symbolRequired": false,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 2000,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOrders": nil,
                "fetchClosedOrders": nil,
                "fetchOHLCV": map[string]interface{} {
                    "limit": 500,
                },
            },
            "spot": map[string]interface{} {
                "extends": "default",
            },
            "forContracts": map[string]interface{} {
                "extends": "default",
                "createOrder": map[string]interface{} {
                    "marginMode": true,
                    "triggerPrice": false,
                    "hedged": true,
                    "stpMode": true,
                    "marketBuyByCost": false,
                },
                "createOrders": map[string]interface{} {
                    "max": 10,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "limit": 100,
                },
                "fetchClosedOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": nil,
                    "daysBackCanceled": Divide(1, 6),
                    "untilDays": nil,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchMyTrades": map[string]interface{} {
                    "limit": 100,
                    "untilDays": 90,
                },
            },
            "swap": map[string]interface{} {
                "linear": map[string]interface{} {
                    "extends": "forContracts",
                },
                "inverse": map[string]interface{} {
                    "extends": "forContracts",
                },
            },
            "future": map[string]interface{} {
                "linear": map[string]interface{} {
                    "extends": "forContracts",
                },
                "inverse": map[string]interface{} {
                    "extends": "forContracts",
                },
            },
        },
        "precisionMode": TICK_SIZE,
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "500": ExchangeNotAvailable,
                "603": RequestTimeout,
                "601": BadRequest,
                "415": ExchangeError,
                "602": ArgumentsRequired,
                "21604": BadRequest,
                "21600": AuthenticationError,
                "21605": AuthenticationError,
                "21102": ExchangeError,
                "21100": AuthenticationError,
                "21704": AuthenticationError,
                "21700": BadRequest,
                "21705": BadRequest,
                "21707": ExchangeError,
                "21708": BadRequest,
                "21601": AccountSuspended,
                "21711": ExchangeError,
                "21709": InsufficientFunds,
                "250000": ExchangeError,
                "250001": BadRequest,
                "250002": BadRequest,
                "250003": BadRequest,
                "250004": BadRequest,
                "250005": InsufficientFunds,
                "250008": BadRequest,
                "250012": ExchangeError,
                "21110": BadRequest,
                "10040": BadSymbol,
                "10060": ExchangeError,
                "10020": BadSymbol,
                "10041": BadSymbol,
                "21340": OnMaintenance,
                "21341": InvalidOrder,
                "21342": InvalidOrder,
                "21343": InvalidOrder,
                "21351": AccountSuspended,
                "21352": BadSymbol,
                "21353": PermissionDenied,
                "21354": PermissionDenied,
                "21359": OrderNotFound,
                "21360": InvalidOrder,
                "24106": BadRequest,
                "24201": ExchangeNotAvailable,
                "21301": OrderNotFound,
                "21302": ExchangeError,
                "21304": ExchangeError,
                "21305": OrderNotFound,
                "21307": ExchangeError,
                "21309": InvalidOrder,
                "21310": InvalidOrder,
                "21311": InvalidOrder,
                "21312": InvalidOrder,
                "21314": InvalidOrder,
                "21315": InvalidOrder,
                "21317": InvalidOrder,
                "21319": InvalidOrder,
                "21320": InvalidOrder,
                "21321": InvalidOrder,
                "21322": InvalidOrder,
                "21324": BadRequest,
                "21327": InvalidOrder,
                "21328": InvalidOrder,
                "21330": InvalidOrder,
                "21335": InvalidOrder,
                "21336": InvalidOrder,
                "21337": InvalidOrder,
                "21344": InvalidOrder,
                "21345": InvalidOrder,
                "21346": InvalidOrder,
                "21348": InvalidOrder,
                "21347": InvalidOrder,
                "21349": InvalidOrder,
                "21350": InvalidOrder,
                "21355": ExchangeError,
                "21356": BadRequest,
                "21721": InsufficientFunds,
                "24101": BadSymbol,
                "24102": InvalidOrder,
                "24103": InvalidOrder,
                "24104": InvalidOrder,
                "24105": InvalidOrder,
                "25020": InvalidOrder,
                "25000": InvalidOrder,
                "25001": InvalidOrder,
                "25002": InvalidOrder,
                "25003": ExchangeError,
                "25004": InvalidOrder,
                "25005": ExchangeError,
                "25006": InvalidOrder,
                "25007": InvalidOrder,
                "25008": InvalidOrder,
                "25009": ExchangeError,
                "25010": PermissionDenied,
                "25011": InvalidOrder,
                "25012": ExchangeError,
                "25013": OrderNotFound,
                "25014": OrderNotFound,
                "25015": OrderNotFound,
                "25016": ExchangeError,
                "25017": ExchangeError,
                "25018": BadRequest,
                "25019": BadSymbol,
            },
            "broad": map[string]interface{} {},
        },
    })
}
func  (this *poloniex) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // spot:
    //
    //     [
    //         [
    //             "22814.01",
    //             "22937.42",
    //             "22832.57",
    //             "22937.42",
    //             "3916.58764051",
    //             "0.171199",
    //             "2982.64647063",
    //             "0.130295",
    //             33,
    //             0,
    //             "22877.449915304470460711",
    //             "MINUTE_5",
    //             1659664800000,
    //             1659665099999
    //         ]
    //     ]
    //
    // contract:
    //
    //           [
    //             "84207.02",
    //             "84320.85",
    //             "84207.02",
    //             "84253.83",
    //             "3707.5395",
    //             "44",
    //             "14",
    //             "1740770040000",
    //             "1740770099999",
    //           ],
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var ohlcvLength interface{} =     GetArrayLength(ohlcv)
    var isContract interface{} = IsEqual(ohlcvLength, 9)
    if IsTrue(isContract) {
        return []interface{}{this.SafeInteger(ohlcv, 7), this.SafeNumber(ohlcv, 2), this.SafeNumber(ohlcv, 1), this.SafeNumber(ohlcv, 0), this.SafeNumber(ohlcv, 3), this.SafeNumber(ohlcv, 5)}
    }
    return []interface{}{this.SafeInteger(ohlcv, 12), this.SafeNumber(ohlcv, 2), this.SafeNumber(ohlcv, 1), this.SafeNumber(ohlcv, 0), this.SafeNumber(ohlcv, 3), this.SafeNumber(ohlcv, 5)}
}
/**
 * @method
 * @name poloniex#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://api-docs.poloniex.com/spot/api/public/market-data#candles
 * @see https://api-docs.poloniex.com/v3/futures/api/market/get-kline-data
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *poloniex) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes6338 := (<-this.LoadMarkets())
            PanicOnError(retRes6338)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchOHLCV", "paginate", false);
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes63719 :=  (<-this.FetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, params, 500))
                    PanicOnError(retRes63719)
                    ch <- retRes63719
                    return nil
            }
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "interval": this.SafeString(this.Timeframes, timeframe, timeframe),
            }
            var keyStart interface{} = Ternary(IsTrue(GetValue(market, "spot")), "startTime", "sTime")
            var keyEnd interface{} = Ternary(IsTrue(GetValue(market, "spot")), "endTime", "eTime")
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, keyStart, since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                // limit should in between 100 and 500
                AddElementToObject(request, "limit", limit)
            }
            requestparamsVariable := this.HandleUntilOption(keyEnd, request, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
            if IsTrue(GetValue(market, "contract")) {
                if IsTrue(this.InArray(timeframe, []interface{}{"10m", "1M"})) {
                    panic(NotSupported(Add(Add(Add(Add(Add(this.Id, " "), timeframe), " "), GetValue(market, "type")), " fetchOHLCV is not supported")))
                }
        
                responseRaw:= (<-this.SwapPublicGetV3MarketCandles(this.Extend(request, params)))
                PanicOnError(responseRaw)
                //
                //     {
                //         code: "200",
                //         msg: "Success",
                //         data: [
                //           [
                //             "84207.02",
                //             "84320.85",
                //             "84207.02",
                //             "84253.83",
                //             "3707.5395",
                //             "44",
                //             "14",
                //             "1740770040000",
                //             "1740770099999",
                //           ],
                //
                var data interface{} = this.SafeList(responseRaw, "data")
        
                ch <- this.ParseOHLCVs(data, market, timeframe, since, limit)
                return nil
            }
        
            response:= (<-this.PublicGetMarketsSymbolCandles(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         [
            //             "22814.01",
            //             "22937.42",
            //             "22832.57",
            //             "22937.42",
            //             "3916.58764051",
            //             "0.171199",
            //             "2982.64647063",
            //             "0.130295",
            //             33,
            //             0,
            //             "22877.449915304470460711",
            //             "MINUTE_5",
            //             1659664800000,
            //             1659665099999
            //         ]
            //     ]
            //
        ch <- this.ParseOHLCVs(response, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *poloniex) LoadMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    reload := GetArg(optionalArgs, 0, false)
            _ = reload
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            markets:= (<-this.Exchange.LoadMarkets(reload, params))
            PanicOnError(markets)
            var currenciesByNumericId interface{} = this.SafeValue(this.Options, "currenciesByNumericId")
            if IsTrue(IsTrue((IsEqual(currenciesByNumericId, nil))) || IsTrue(reload)) {
                AddElementToObject(this.Options, "currenciesByNumericId", this.IndexBy(this.Currencies, "numericId"))
            }
        
            ch <- markets
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniex#fetchMarkets
 * @description retrieves data on all markets for poloniex
 * @see https://api-docs.poloniex.com/spot/api/public/reference-data#symbol-information
 * @see https://api-docs.poloniex.com/v3/futures/api/market/get-all-product-info
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *poloniex) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var promises interface{} = []interface{}{this.FetchSpotMarkets(params), this.FetchSwapMarkets(params)}
        
            results:= (<-promiseAll(promises))
            PanicOnError(results)
        
            ch <- this.ArrayConcat(GetValue(results, 0), GetValue(results, 1))
            return nil
        
            }()
            return ch
        }
func  (this *poloniex) FetchSpotMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            markets:= (<-this.PublicGetMarkets(params))
            PanicOnError(markets)
        
                //
            //     [
            //         {
            //             "symbol" : "BTS_BTC",
            //             "baseCurrencyName" : "BTS",
            //             "quoteCurrencyName" : "BTC",
            //             "displayName" : "BTS/BTC",
            //             "state" : "NORMAL",
            //             "visibleStartTime" : 1659018816626,
            //             "tradableStartTime" : 1659018816626,
            //             "symbolTradeLimit" : {
            //                 "symbol" : "BTS_BTC",
            //                 "priceScale" : 10,
            //                 "quantityScale" : 0,
            //                 "amountScale" : 8,
            //                 "minQuantity" : "100",
            //                 "minAmount" : "0.00001",
            //                 "highestBid" : "0",
            //                 "lowestAsk" : "0"
            //             }
            //         }
            //     ]
            //
        ch <- this.ParseMarkets(markets)
            return nil
        
            }()
            return ch
        }
func  (this *poloniex) FetchSwapMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    // do similar as spot per https://api-docs.poloniex.com/v3/futures/api/market/get-product-info
            params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.SwapPublicGetV3MarketAllInstruments(params))
            PanicOnError(response)
            //
            //    {
            //        "code": "200",
            //        "msg": "Success",
            //        "data": [
            //            {
            //                "symbol": "BNB_USDT_PERP",
            //                "bAsset": ".PBNBUSDT",
            //                "bCcy": "BNB",
            //                "qCcy": "USDT",
            //                "visibleStartTime": "1620390600000",
            //                "tradableStartTime": "1620390600000",
            //                "sCcy": "USDT",
            //                "tSz": "0.001",
            //                "pxScale": "0.001,0.01,0.1,1,10",
            //                "lotSz": "1",
            //                "minSz": "1",
            //                "ctVal": "0.1",
            //                "status": "OPEN",
            //                "oDate": "1620287590000",
            //                "maxPx": "1000000",
            //                "minPx": "0.001",
            //                "maxQty": "1000000",
            //                "minQty": "1",
            //                "maxLever": "50",
            //                "lever": "10",
            //                "ctType": "LINEAR",
            //                "alias": "",
            //                "iM": "0.02",
            //                "mM": "0.0115",
            //                "mR": "2000",
            //                "buyLmt": "",
            //                "sellLmt": "",
            //                "ordPxRange": "0.05",
            //                "marketMaxQty": "2800",
            //                "limitMaxQty": "1000000"
            //            },
            //
            var markets interface{} = this.SafeList(response, "data")
        
            ch <- this.ParseMarkets(markets)
            return nil
        
            }()
            return ch
        }
func  (this *poloniex) ParseMarket(market interface{}) interface{}  {
    if IsTrue(InOp(market, "ctType")) {
        return this.ParseSwapMarket(market)
    } else {
        return this.ParseSpotMarket(market)
    }
}
func  (this *poloniex) ParseSpotMarket(market interface{}) interface{}  {
    var id interface{} = this.SafeString(market, "symbol")
    var baseId interface{} = this.SafeString(market, "baseCurrencyName")
    var quoteId interface{} = this.SafeString(market, "quoteCurrencyName")
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    var state interface{} = this.SafeString(market, "state")
    var active interface{} = IsEqual(state, "NORMAL")
    var symbolTradeLimit interface{} = this.SafeValue(market, "symbolTradeLimit")
    // these are known defaults
    return map[string]interface{} {
        "id": id,
        "symbol": Add(Add(base, "/"), quote),
        "base": base,
        "quote": quote,
        "settle": nil,
        "baseId": baseId,
        "quoteId": quoteId,
        "settleId": nil,
        "type": "spot",
        "spot": true,
        "margin": false,
        "swap": false,
        "future": false,
        "option": false,
        "active": active,
        "contract": false,
        "linear": nil,
        "inverse": nil,
        "contractSize": nil,
        "expiry": nil,
        "expiryDatetime": nil,
        "strike": nil,
        "optionType": nil,
        "precision": map[string]interface{} {
            "amount": this.ParseNumber(this.ParsePrecision(this.SafeString(symbolTradeLimit, "quantityScale"))),
            "price": this.ParseNumber(this.ParsePrecision(this.SafeString(symbolTradeLimit, "priceScale"))),
        },
        "limits": map[string]interface{} {
            "amount": map[string]interface{} {
                "min": this.SafeNumber(symbolTradeLimit, "minQuantity"),
                "max": nil,
            },
            "price": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "cost": map[string]interface{} {
                "min": this.SafeNumber(symbolTradeLimit, "minAmount"),
                "max": nil,
            },
        },
        "created": this.SafeInteger(market, "tradableStartTime"),
        "info": market,
    }
}
func  (this *poloniex) ParseSwapMarket(market interface{}) interface{}  {
    //
    //            {
    //                "symbol": "BNB_USDT_PERP",
    //                "bAsset": ".PBNBUSDT",
    //                "bCcy": "BNB",
    //                "qCcy": "USDT",
    //                "visibleStartTime": "1620390600000",
    //                "tradableStartTime": "1620390600000",
    //                "sCcy": "USDT",
    //                "tSz": "0.001",
    //                "pxScale": "0.001,0.01,0.1,1,10",
    //                "lotSz": "1",
    //                "minSz": "1",
    //                "ctVal": "0.1",
    //                "status": "OPEN",
    //                "oDate": "1620287590000",
    //                "maxPx": "1000000",
    //                "minPx": "0.001",
    //                "maxQty": "1000000",
    //                "minQty": "1",
    //                "maxLever": "50",
    //                "lever": "10",
    //                "ctType": "LINEAR",
    //                "alias": "",
    //                "iM": "0.02",
    //                "mM": "0.0115",
    //                "mR": "2000",
    //                "buyLmt": "",
    //                "sellLmt": "",
    //                "ordPxRange": "0.05",
    //                "marketMaxQty": "2800",
    //                "limitMaxQty": "1000000"
    //            },
    //
    var id interface{} = this.SafeString(market, "symbol")
    var baseId interface{} = this.SafeString(market, "bCcy")
    var quoteId interface{} = this.SafeString(market, "qCcy")
    var settleId interface{} = this.SafeString(market, "sCcy")
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    var settle interface{} = this.SafeCurrencyCode(settleId)
    var status interface{} = this.SafeString(market, "status")
    var active interface{} = IsEqual(status, "OPEN")
    var linear interface{} = IsEqual(GetValue(market, "ctType"), "LINEAR")
    var symbol interface{} = Add(Add(base, "/"), quote)
    if IsTrue(linear) {
        symbol = Add(symbol, Add(":", settle))
    } else {
        // actually, exchange does not have any inverse future now
        symbol = Add(symbol, Add(":", base))
    }
    var alias interface{} = this.SafeString(market, "alias")
    var typeVar interface{} = "swap"
    if IsTrue(!IsEqual(alias, nil)) {
        typeVar = "future"
    }
    return map[string]interface{} {
        "id": id,
        "symbol": symbol,
        "base": base,
        "quote": quote,
        "settle": settle,
        "baseId": baseId,
        "quoteId": quoteId,
        "settleId": settleId,
        "type": Ternary(IsTrue((IsEqual(typeVar, "future"))), "future", "swap"),
        "spot": false,
        "margin": false,
        "swap": IsEqual(typeVar, "swap"),
        "future": IsEqual(typeVar, "future"),
        "option": false,
        "active": active,
        "contract": true,
        "linear": linear,
        "inverse": !IsTrue(linear),
        "contractSize": this.SafeNumber(market, "ctVal"),
        "expiry": nil,
        "expiryDatetime": nil,
        "strike": nil,
        "optionType": nil,
        "taker": this.SafeNumber(market, "tFee"),
        "maker": this.SafeNumber(market, "mFee"),
        "precision": map[string]interface{} {
            "amount": this.SafeNumber(market, "lotSz"),
            "price": this.SafeNumber(market, "tSz"),
        },
        "limits": map[string]interface{} {
            "amount": map[string]interface{} {
                "min": this.SafeNumber(market, "minSz"),
                "max": this.SafeNumber(market, "limitMaxQty"),
            },
            "price": map[string]interface{} {
                "min": this.SafeNumber(market, "minPx"),
                "max": this.SafeNumber(market, "maxPx"),
            },
            "cost": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "leverage": map[string]interface{} {
                "max": this.SafeNumber(market, "maxLever"),
                "min": nil,
            },
        },
        "created": this.SafeInteger(market, "oDate"),
        "info": market,
    }
}
/**
 * @method
 * @name poloniex#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @see https://api-docs.poloniex.com/spot/api/public/reference-data#system-timestamp
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func  (this *poloniex) FetchTime(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetTimestamp(params))
            PanicOnError(response)
        
            ch <- this.SafeInteger(response, "serverTime")
            return nil
        
            }()
            return ch
        }
func  (this *poloniex) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //  spot:
    //
    //     {
    //         "symbol" : "BTC_USDT",
    //         "open" : "26053.33",
    //         "low" : "26053.33",
    //         "high" : "26798.02",
    //         "close" : "26447.58",
    //         "quantity" : "6116.210188",
    //         "amount" : "161082122.88450926",
    //         "tradeCount" : "134709",
    //         "startTime" : "1692784440000",
    //         "closeTime" : "1692870839630",
    //         "displayName" : "BTC/USDT",
    //         "dailyChange" : "0.0151",
    //         "bid" : "26447.57",
    //         "bidQuantity" : "0.016313",
    //         "ask" : "26447.58",
    //         "askQuantity" : "0.068307",
    //         "ts" : "1692870845446",
    //         "markPrice" : "26444.11"
    //     }
    //
    //  swap:
    //
    //            {
    //                "s": "XRP_USDT_PERP",
    //                "o": "2.0503",
    //                "l": "2.0066",
    //                "h": "2.216",
    //                "c": "2.1798",
    //                "qty": "21090",
    //                "amt": "451339.65",
    //                "tC": "3267",
    //                "sT": "1740736380000",
    //                "cT": "1740822777559",
    //                "dN": "XRP/USDT/PERP",
    //                "dC": "0.0632",
    //                "bPx": "2.175",
    //                "bSz": "3",
    //                "aPx": "2.1831",
    //                "aSz": "111",
    //                "mPx": "2.1798",
    //                "iPx": "2.1834"
    //            },
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger2(ticker, "ts", "cT")
    var marketId interface{} = this.SafeString2(ticker, "symbol", "s")
    market = this.SafeMarket(marketId)
    var relativeChange interface{} = this.SafeString2(ticker, "dailyChange", "dc")
    var percentage interface{} = Precise.StringMul(relativeChange, "100")
    return this.SafeTicker(map[string]interface{} {
        "id": marketId,
        "symbol": GetValue(market, "symbol"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeString2(ticker, "high", "h"),
        "low": this.SafeString2(ticker, "low", "l"),
        "bid": this.SafeString2(ticker, "bid", "bPx"),
        "bidVolume": this.SafeString2(ticker, "bidQuantity", "bSz"),
        "ask": this.SafeString2(ticker, "ask", "aPx"),
        "askVolume": this.SafeString2(ticker, "askQuantity", "aSz"),
        "vwap": nil,
        "open": this.SafeString2(ticker, "open", "o"),
        "close": this.SafeString2(ticker, "close", "c"),
        "previousClose": nil,
        "change": nil,
        "percentage": percentage,
        "average": nil,
        "baseVolume": this.SafeString2(ticker, "quantity", "qty"),
        "quoteVolume": this.SafeString2(ticker, "amount", "amt"),
        "markPrice": this.SafeString2(ticker, "markPrice", "mPx"),
        "indexPrice": this.SafeString(ticker, "iPx"),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name poloniex#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://api-docs.poloniex.com/spot/api/public/market-data#ticker
 * @see https://api-docs.poloniex.com/v3/futures/api/market/get-market-info
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *poloniex) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes10788 := (<-this.LoadMarkets())
            PanicOnError(retRes10788)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbols, nil)) {
                symbols = this.MarketSymbols(symbols, nil, true, true, false)
                var symbolsLength interface{} =         GetArrayLength(symbols)
                if IsTrue(IsGreaterThan(symbolsLength, 0)) {
                    market = this.Market(GetValue(symbols, 0))
                    if IsTrue(IsEqual(symbolsLength, 1)) {
                        AddElementToObject(request, "symbol", GetValue(market, "id"))
                    }
                }
            }
            var marketType interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchTickers", market, params);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            if IsTrue(IsEqual(marketType, "swap")) {
        
                responseRaw:= (<-this.SwapPublicGetV3MarketTickers(this.Extend(request, params)))
                PanicOnError(responseRaw)
                //
                //    {
                //        "code": "200",
                //        "msg": "Success",
                //        "data": [
                //            {
                //                "s": "XRP_USDT_PERP",
                //                "o": "2.0503",
                //                "l": "2.0066",
                //                "h": "2.216",
                //                "c": "2.1798",
                //                "qty": "21090",
                //                "amt": "451339.65",
                //                "tC": "3267",
                //                "sT": "1740736380000",
                //                "cT": "1740822777559",
                //                "dN": "XRP/USDT/PERP",
                //                "dC": "0.0632",
                //                "bPx": "2.175",
                //                "bSz": "3",
                //                "aPx": "2.1831",
                //                "aSz": "111",
                //                "mPx": "2.1798",
                //                "iPx": "2.1834"
                //            },
                //
                var data interface{} = this.SafeList(responseRaw, "data")
        
                ch <- this.ParseTickers(data, symbols)
                return nil
            }
        
            response:= (<-this.PublicGetMarketsTicker24h(params))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //              "symbol" : "BTC_USDT",
            //              "open" : "26053.33",
            //              "low" : "26053.33",
            //              "high" : "26798.02",
            //              "close" : "26447.58",
            //              "quantity" : "6116.210188",
            //              "amount" : "161082122.88450926",
            //              "tradeCount" : "134709",
            //              "startTime" : "1692784440000",
            //              "closeTime" : "1692870839630",
            //              "displayName" : "BTC/USDT",
            //              "dailyChange" : "0.0151",
            //              "bid" : "26447.57",
            //              "bidQuantity" : "0.016313",
            //              "ask" : "26447.58",
            //              "askQuantity" : "0.068307",
            //              "ts" : "1692870845446",
            //              "markPrice" : "26444.11"
            //         }
            //     ]
            //
        ch <- this.ParseTickers(response, symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniex#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see https://api-docs.poloniex.com/spot/api/public/reference-data#currency-information
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func  (this *poloniex) FetchCurrencies(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetCurrencies(this.Extend(params, map[string]interface{} {
            "includeMultiChainCurrencies": true,
        })))
            PanicOnError(response)
            //
            //     [
            //         {
            //             "1CR": {
            //                 "id": 1,
            //                 "name": "1CRedit",
            //                 "description": "BTC Clone",
            //                 "type": "address",
            //                 "withdrawalFee": "0.01000000",
            //                 "minConf": 10000,
            //                 "depositAddress": null,
            //                 "blockchain": "1CR",
            //                 "delisted": false,
            //                 "tradingState": "NORMAL",
            //                 "walletState": "DISABLED",
            //                 "walletDepositState": "DISABLED",
            //                 "walletWithdrawalState": "DISABLED",
            //                 "parentChain": null,
            //                 "isMultiChain": false,
            //                 "isChildChain": false,
            //                 "childChains": []
            //             }
            //         }
            //     ]
            //
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
                var item interface{} = this.SafeValue(response, i)
                var ids interface{} = ObjectKeys(item)
                var id interface{} = this.SafeValue(ids, 0)
                var currency interface{} = this.SafeValue(item, id)
                var code interface{} = this.SafeCurrencyCode(id)
                var name interface{} = this.SafeString(currency, "name")
                var networkId interface{} = this.SafeString(currency, "blockchain")
                var networkCode interface{} = nil
                if IsTrue(!IsEqual(networkId, nil)) {
                    networkCode = this.NetworkIdToCode(networkId, code)
                }
                var delisted interface{} = this.SafeValue(currency, "delisted")
                var walletEnabled interface{} = IsEqual(this.SafeString(currency, "walletState"), "ENABLED")
                var depositEnabled interface{} = IsEqual(this.SafeString(currency, "walletDepositState"), "ENABLED")
                var withdrawEnabled interface{} = IsEqual(this.SafeString(currency, "walletWithdrawalState"), "ENABLED")
                var active interface{} = IsTrue(IsTrue(!IsTrue(delisted) && IsTrue(walletEnabled)) && IsTrue(depositEnabled)) && IsTrue(withdrawEnabled)
                var numericId interface{} = this.SafeInteger(currency, "id")
                var feeString interface{} = this.SafeString(currency, "withdrawalFee")
                var parentChain interface{} = this.SafeValue(currency, "parentChain")
                var noParentChain interface{} = IsEqual(parentChain, nil)
                if IsTrue(IsEqual(this.SafeValue(result, code), nil)) {
                    AddElementToObject(result, code, map[string]interface{} {
            "id": id,
            "code": code,
            "info": nil,
            "name": name,
            "active": active,
            "deposit": depositEnabled,
            "withdraw": withdrawEnabled,
            "fee": this.ParseNumber(feeString),
            "precision": nil,
            "limits": map[string]interface{} {
                "amount": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
                "deposit": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
                "withdraw": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
            },
        })
                }
                var minFeeString interface{} = this.SafeString(GetValue(result, code), "fee")
                if IsTrue(!IsEqual(feeString, nil)) {
                    minFeeString = Ternary(IsTrue((IsEqual(minFeeString, nil))), feeString, Precise.StringMin(feeString, minFeeString))
                }
                var depositAvailable interface{} = this.SafeValue(GetValue(result, code), "deposit")
                depositAvailable = Ternary(IsTrue((depositEnabled)), depositEnabled, depositAvailable)
                var withdrawAvailable interface{} = this.SafeValue(GetValue(result, code), "withdraw")
                withdrawAvailable = Ternary(IsTrue((withdrawEnabled)), withdrawEnabled, withdrawAvailable)
                var networks interface{} = this.SafeValue(GetValue(result, code), "networks", map[string]interface{} {})
                if IsTrue(!IsEqual(networkCode, nil)) {
                    AddElementToObject(networks, networkCode, map[string]interface{} {
            "info": currency,
            "id": networkId,
            "network": networkCode,
            "currencyId": id,
            "numericId": numericId,
            "deposit": depositEnabled,
            "withdraw": withdrawEnabled,
            "active": active,
            "fee": this.ParseNumber(feeString),
            "precision": nil,
            "limits": map[string]interface{} {
                "amount": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
                "withdraw": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
                "deposit": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
            },
        })
                }
                AddElementToObject(GetValue(result, code), "networks", networks)
                var info interface{} = this.SafeValue(GetValue(result, code), "info", []interface{}{})
                var rawInfo interface{} = map[string]interface{} {}
                AddElementToObject(rawInfo, id, currency)
                AppendToArray(&info,rawInfo)
                AddElementToObject(GetValue(result, code), "info", info)
                if IsTrue(noParentChain) {
                    AddElementToObject(GetValue(result, code), "id", id)
                    AddElementToObject(GetValue(result, code), "name", name)
                }
                AddElementToObject(GetValue(result, code), "active", IsTrue(depositAvailable) && IsTrue(withdrawAvailable))
                AddElementToObject(GetValue(result, code), "deposit", depositAvailable)
                AddElementToObject(GetValue(result, code), "withdraw", withdrawAvailable)
                AddElementToObject(GetValue(result, code), "fee", this.ParseNumber(minFeeString))
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniex#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://api-docs.poloniex.com/spot/api/public/market-data#ticker
 * @see https://api-docs.poloniex.com/v3/futures/api/market/get-market-info
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *poloniex) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes13028 := (<-this.LoadMarkets())
            PanicOnError(retRes13028)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(GetValue(market, "contract")) {
        
                tickers:= (<-this.FetchTickers([]interface{}{GetValue(market, "symbol")}, params))
                PanicOnError(tickers)
        
                ch <- this.SafeDict(tickers, symbol)
                return nil
            }
        
            response:= (<-this.PublicGetMarketsSymbolTicker24h(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "symbol" : "BTC_USDT",
            //         "open" : "26053.33",
            //         "low" : "26053.33",
            //         "high" : "26798.02",
            //         "close" : "26447.58",
            //         "quantity" : "6116.210188",
            //         "amount" : "161082122.88450926",
            //         "tradeCount" : "134709",
            //         "startTime" : "1692784440000",
            //         "closeTime" : "1692870839630",
            //         "displayName" : "BTC/USDT",
            //         "dailyChange" : "0.0151",
            //         "bid" : "26447.57",
            //         "bidQuantity" : "0.016313",
            //         "ask" : "26447.58",
            //         "askQuantity" : "0.068307",
            //         "ts" : "1692870845446",
            //         "markPrice" : "26444.11"
            //     }
            //
        ch <- this.ParseTicker(response, market)
            return nil
        
            }()
            return ch
        }
func  (this *poloniex) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTrades
    //
    //  spot:
    //
    //     {
    //         "id" : "60014521",
    //         "price" : "23162.94",
    //         "quantity" : "0.00009",
    //         "amount" : "2.0846646",
    //         "takerSide" : "SELL",
    //         "ts" : 1659684602042,
    //         "createTime" : 1659684602036
    //     }
    //
    //   swap:
    //
    //     {
    //         "id": "105807376",
    //         "side": "buy",
    //         "px": "84410.57",
    //         "qty": "1",
    //         "amt": "84.41057",
    //         "cT": "1740777563557",
    //     }
    //
    // fetchMyTrades
    //
    //  spot:
    //
    //     {
    //         "id": "32164924331503616",
    //         "symbol": "LINK_USDT",
    //         "accountType": "SPOT",
    //         "orderId": "32164923987566592",
    //         "side": "SELL",
    //         "type": "MARKET",
    //         "matchRole": "TAKER",
    //         "createTime": 1648635115525,
    //         "price": "11",
    //         "quantity": "0.5",
    //         "amount": "5.5",
    //         "feeCurrency": "USDT",
    //         "feeAmount": "0.007975",
    //         "pageId": "32164924331503616",
    //         "clientOrderId": "myOwnId-321"
    //     }
    //
    //  swap:
    //
    //     {
    //         "symbol": "BTC_USDT_PERP",
    //         "trdId": "105813553",
    //         "side": "SELL",
    //         "type": "TRADE",
    //         "mgnMode": "CROSS",
    //         "ordType": "MARKET",
    //         "clOrdId": "polo418912106147315112",
    //         "role": "TAKER",
    //         "px": "84704.9",
    //         "qty": "1",
    //         "cTime": "1740842829430",
    //         "uTime": "1740842829450",
    //         "feeCcy": "USDT",
    //         "feeAmt": "0.04235245",
    //         "deductCcy": "",
    //         "deductAmt": "0",
    //         "feeRate": "0.0005",
    //         "id": "418912106342654592",
    //         "posSide": "BOTH",
    //         "ordId": "418912106147315112",
    //         "qCcy": "USDT",
    //         "value": "84.7049",
    //         "actType": "TRADING"
    //     },
    //
    // fetchOrderTrades (taker trades)
    //
    //     {
    //         "id": "30341456333942784",
    //         "symbol": "LINK_USDT",
    //         "accountType": "SPOT",
    //         "orderId": "30249408733945856",
    //         "side": "BUY",
    //         "type": "LIMIT",
    //         "matchRole": "MAKER",
    //         "createTime": 1648200366864,
    //         "price": "3.1",
    //         "quantity": "1",
    //         "amount": "3.1",
    //         "feeCurrency": "LINK",
    //         "feeAmount": "0.00145",
    //         "pageId": "30341456333942784",
    //         "clientOrderId": ""
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeStringN(trade, []interface{}{"id", "tradeID", "trdId"})
    var orderId interface{} = this.SafeString2(trade, "orderId", "ordId")
    var timestamp interface{} = this.SafeIntegerN(trade, []interface{}{"ts", "createTime", "cT", "cTime"})
    var marketId interface{} = this.SafeString(trade, "symbol")
    market = this.SafeMarket(marketId, market, "_")
    var symbol interface{} = GetValue(market, "symbol")
    var side interface{} = this.SafeStringLower2(trade, "side", "takerSide")
    var fee interface{} = nil
    var priceString interface{} = this.SafeString2(trade, "price", "px")
    var amountString interface{} = this.SafeString2(trade, "quantity", "qty")
    var costString interface{} = this.SafeString2(trade, "amount", "amt")
    var feeCurrencyId interface{} = this.SafeString2(trade, "feeCurrency", "feeCcy")
    var feeCostString interface{} = this.SafeString2(trade, "feeAmount", "feeAmt")
    if IsTrue(!IsEqual(feeCostString, nil)) {
        var feeCurrencyCode interface{} = this.SafeCurrencyCode(feeCurrencyId)
        fee = map[string]interface{} {
            "cost": feeCostString,
            "currency": feeCurrencyCode,
        }
    }
    return this.SafeTrade(map[string]interface{} {
        "id": id,
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "order": orderId,
        "type": this.SafeStringLower2(trade, "ordType", "type"),
        "side": side,
        "takerOrMaker": this.SafeStringLower2(trade, "matchRole", "role"),
        "price": priceString,
        "amount": amountString,
        "cost": costString,
        "fee": fee,
    }, market)
}
/**
 * @method
 * @name poloniex#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://api-docs.poloniex.com/spot/api/public/market-data#trades
 * @see https://api-docs.poloniex.com/v3/futures/api/market/get-execution-info
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *poloniex) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes14848 := (<-this.LoadMarkets())
            PanicOnError(retRes14848)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit) // max 1000, for spot & swap
            }
            if IsTrue(GetValue(market, "contract")) {
        
                response:= (<-this.SwapPublicGetV3MarketTrades(this.Extend(request, params)))
                PanicOnError(response)
                //
                //     {
                //         code: "200",
                //         msg: "Success",
                //         data: [
                //         {
                //             id: "105807320", // descending order
                //             side: "sell",
                //             px: "84383.93",
                //             qty: "1",
                //             amt: "84.38393",
                //             cT: "1740777074704",
                //         },
                //
                var tradesList interface{} = this.SafeList(response, "data")
        
                ch <- this.ParseTrades(tradesList, market, since, limit)
                return nil
            }
        
            trades:= (<-this.PublicGetMarketsSymbolTrades(this.Extend(request, params)))
            PanicOnError(trades)
        
                //
            //     [
            //         {
            //             "id" : "60014521",
            //             "price" : "23162.94",
            //             "quantity" : "0.00009",
            //             "amount" : "2.0846646",
            //             "takerSide" : "SELL",
            //             "ts" : 1659684602042,
            //             "createTime" : 1659684602036
            //         }
            //     ]
            //
        ch <- this.ParseTrades(trades, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniex#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://api-docs.poloniex.com/spot/api/private/trade#trade-history
 * @see https://api-docs.poloniex.com/v3/futures/api/trade/get-execution-details
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch entries for
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *poloniex) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes15438 := (<-this.LoadMarkets())
            PanicOnError(retRes15438)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchMyTrades", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes154719 :=  (<-this.FetchPaginatedCallDynamic("fetchMyTrades", symbol, since, limit, params))
                    PanicOnError(retRes154719)
                    ch <- retRes154719
                    return nil
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var marketType interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchMyTrades", market, params);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            var isContract interface{} = this.InArray(marketType, []interface{}{"swap", "future"})
            var request interface{} = map[string]interface{} {}
            var startKey interface{} = Ternary(IsTrue(isContract), "sTime", "startTime")
            var endKey interface{} = Ternary(IsTrue(isContract), "eTime", "endTime")
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, startKey, since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            if IsTrue(IsTrue(isContract) && IsTrue(!IsEqual(symbol, nil))) {
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            requestparamsVariable := this.HandleUntilOption(endKey, request, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
            if IsTrue(isContract) {
        
                raw:= (<-this.SwapPrivateGetV3TradeOrderTrades(this.Extend(request, params)))
                PanicOnError(raw)
                //
                //    {
                //        "code": "200",
                //        "msg": "",
                //        "data": [
                //            {
                //                "symbol": "BTC_USDT_PERP",
                //                "trdId": "105813553",
                //                "side": "SELL",
                //                "type": "TRADE",
                //                "mgnMode": "CROSS",
                //                "ordType": "MARKET",
                //                "clOrdId": "polo418912106147315112",
                //                "role": "TAKER",
                //                "px": "84704.9",
                //                "qty": "1",
                //                "cTime": "1740842829430",
                //                "uTime": "1740842829450",
                //                "feeCcy": "USDT",
                //                "feeAmt": "0.04235245",
                //                "deductCcy": "",
                //                "deductAmt": "0",
                //                "feeRate": "0.0005",
                //                "id": "418912106342654592",
                //                "posSide": "BOTH",
                //                "ordId": "418912106147315112",
                //                "qCcy": "USDT",
                //                "value": "84.7049",
                //                "actType": "TRADING"
                //            },
                //
                var data interface{} = this.SafeList(raw, "data")
        
                ch <- this.ParseTrades(data, market, since, limit)
                return nil
            }
        
            response:= (<-this.PrivateGetTrades(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     [
            //         {
            //             "id": "32164924331503616",
            //             "symbol": "LINK_USDT",
            //             "accountType": "SPOT",
            //             "orderId": "32164923987566592",
            //             "side": "SELL",
            //             "type": "MARKET",
            //             "matchRole": "TAKER",
            //             "createTime": 1648635115525,
            //             "price": "11",
            //             "quantity": "0.5",
            //             "amount": "5.5",
            //             "feeCurrency": "USDT",
            //             "feeAmount": "0.007975",
            //             "pageId": "32164924331503616",
            //             "clientOrderId": "myOwnId-321"
            //         }
            //     ]
            //
            var result interface{} = this.ParseTrades(response, market, since, limit)
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *poloniex) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "NEW": "open",
        "PARTIALLY_FILLED": "open",
        "FILLED": "closed",
        "PENDING_CANCEL": "canceled",
        "PARTIALLY_CANCELED": "canceled",
        "CANCELED": "canceled",
        "FAILED": "canceled",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *poloniex) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchOpenOrder
    //
    //     {
    //         "id" : "7xxxxxxxxxxxxxxx6",
    //         "clientOrderId" : "",
    //         "symbol" : "ETH_USDT",
    //         "state" : "NEW",
    //         "accountType" : "SPOT",
    //         "side" : "BUY",
    //         "type" : "LIMIT",
    //         "timeInForce" : "GTC",
    //         "quantity" : "0.001",
    //         "price" : "1600",
    //         "avgPrice" : "0",
    //         "amount" : "0",
    //         "filledQuantity" : "0",
    //         "filledAmount" : "0",
    //         "createTime" : 16xxxxxxxxx26,
    //         "updateTime" : 16xxxxxxxxx36
    //     }
    //
    // fetchOpenOrders (and fetchClosedOrders same for contracts)
    //
    //  spot:
    //
    //     {
    //         "id": "24993088082542592",
    //         "clientOrderId": "",
    //         "symbol": "ELON_USDC",
    //         "state": "NEW",
    //         "accountType": "SPOT",
    //         "side": "SELL",
    //         "type": "MARKET",
    //         "timeInForce": "GTC",
    //         "quantity": "1.00",
    //         "price": "0.00",
    //         "avgPrice": "0.00",
    //         "amount": "0.00",
    //         "filledQuantity": "0.00",
    //         "filledAmount": "0.00",
    //         "createTime": 1646925216548,
    //         "updateTime": 1646925216548
    //     }
    //
    //  contract:
    //
    //     {
    //         "symbol": "BTC_USDT_PERP",
    //         "side": "BUY",
    //         "type": "LIMIT",
    //         "ordId": "418890767248232148",
    //         "clOrdId": "polo418890767248232148",
    //         "mgnMode": "CROSS",
    //         "px": "81130.13",
    //         "reduceOnly": false,
    //         "lever": "20",
    //         "state": "NEW",
    //         "source": "WEB",
    //         "timeInForce": "GTC",
    //         "tpTrgPx": "",
    //         "tpPx": "",
    //         "tpTrgPxType": "",
    //         "slTrgPx": "",
    //         "slPx": "",
    //         "slTrgPxType": "",
    //         "avgPx": "0",
    //         "execQty": "0",
    //         "execAmt": "0",
    //         "feeCcy": "",
    //         "feeAmt": "0",
    //         "deductCcy": "0",
    //         "deductAmt": "0",
    //         "stpMode": "NONE", // todo: selfTradePrevention
    //         "cTime": "1740837741523",
    //         "uTime": "1740840846882",
    //         "sz": "1",
    //         "posSide": "BOTH",
    //         "qCcy": "USDT"
    //         "cancelReason": "", // this field can only be in closed orders
    //     },
    //
    // createOrder, editOrder
    //
    //  spot:
    //
    //     {
    //         "id": "29772698821328896",
    //         "clientOrderId": "1234Abc"
    //     }
    //
    //  contract:
    //
    //    {
    //        "ordId":"418876147745775616",
    //        "clOrdId":"polo418876147745775616"
    //    }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeIntegerN(order, []interface{}{"timestamp", "createTime", "cTime"})
    if IsTrue(IsEqual(timestamp, nil)) {
        timestamp = this.Parse8601(this.SafeString(order, "date"))
    }
    var marketId interface{} = this.SafeString(order, "symbol")
    market = this.SafeMarket(marketId, market, "_")
    var symbol interface{} = GetValue(market, "symbol")
    var resultingTrades interface{} = this.SafeValue(order, "resultingTrades")
    if IsTrue(!IsEqual(resultingTrades, nil)) {
        if !IsTrue(IsArray(resultingTrades)) {
            resultingTrades = this.SafeValue(resultingTrades, this.SafeString(market, "id", marketId))
        }
    }
    var price interface{} = this.SafeStringN(order, []interface{}{"price", "rate", "px"})
    var amount interface{} = this.SafeString2(order, "quantity", "sz")
    var filled interface{} = this.SafeString2(order, "filledQuantity", "execQty")
    var status interface{} = this.ParseOrderStatus(this.SafeString(order, "state"))
    var side interface{} = this.SafeStringLower(order, "side")
    var rawType interface{} = this.SafeString(order, "type")
    var typeVar interface{} = this.ParseOrderType(rawType)
    var id interface{} = this.SafeStringN(order, []interface{}{"orderNumber", "id", "orderId", "ordId"})
    var fee interface{} = nil
    var feeCurrency interface{} = this.SafeString2(order, "tokenFeeCurrency", "feeCcy")
    var feeCost interface{} = nil
    var feeCurrencyCode interface{} = nil
    var rate interface{} = this.SafeString(order, "fee")
    if IsTrue(IsEqual(feeCurrency, nil)) {
        feeCurrencyCode = Ternary(IsTrue((IsEqual(side, "buy"))), GetValue(market, "base"), GetValue(market, "quote"))
    } else {
        // poloniex accepts a 30% discount to pay fees in TRX
        feeCurrencyCode = this.SafeCurrencyCode(feeCurrency)
        feeCost = this.SafeString2(order, "tokenFee", "feeAmt")
    }
    if IsTrue(!IsEqual(feeCost, nil)) {
        fee = map[string]interface{} {
            "rate": rate,
            "cost": feeCost,
            "currency": feeCurrencyCode,
        }
    }
    var clientOrderId interface{} = this.SafeString2(order, "clientOrderId", "clOrdId")
    var marginMode interface{} = this.SafeStringLower(order, "mgnMode")
    var reduceOnly interface{} = this.SafeBool(order, "reduceOnly")
    var leverage interface{} = this.SafeInteger(order, "lever")
    var hedged interface{} = !IsEqual(this.SafeString(order, "posSide"), "BOTH")
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": id,
        "clientOrderId": clientOrderId,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": this.SafeInteger(order, "updateTime"),
        "status": status,
        "symbol": symbol,
        "type": typeVar,
        "timeInForce": this.SafeString(order, "timeInForce"),
        "postOnly": IsEqual(rawType, "LIMIT_MAKER"),
        "side": side,
        "price": price,
        "triggerPrice": this.SafeString2(order, "triggerPrice", "stopPrice"),
        "cost": this.SafeString(order, "execAmt"),
        "average": this.SafeString2(order, "avgPrice", "avgPx"),
        "amount": amount,
        "filled": filled,
        "remaining": nil,
        "trades": resultingTrades,
        "fee": fee,
        "marginMode": marginMode,
        "reduceOnly": reduceOnly,
        "leverage": leverage,
        "hedged": hedged,
    }, market)
}
func  (this *poloniex) ParseOrderType(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "MARKET": "market",
        "LIMIT": "limit",
        "LIMIT_MAKER": "limit",
        "STOP-LIMIT": "limit",
        "STOP-MARKET": "market",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *poloniex) ParseOpenOrders(orders interface{}, market interface{}, result interface{}) interface{}  {
    for i := 0; IsLessThan(i, GetArrayLength(orders)); i++ {
        var order interface{} = GetValue(orders, i)
        var extended interface{} = this.Extend(order, map[string]interface{} {
            "status": "open",
            "type": "limit",
            "side": GetValue(order, "type"),
            "price": GetValue(order, "rate"),
        })
        AppendToArray(&result,this.ParseOrder(extended, market))
    }
    return result
}
/**
 * @method
 * @name poloniex#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://api-docs.poloniex.com/spot/api/private/order#open-orders
 * @see https://api-docs.poloniex.com/spot/api/private/smart-order#open-orders  // trigger orders
 * @see https://api-docs.poloniex.com/v3/futures/api/trade/get-current-orders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] set true to fetch trigger orders instead of regular orders
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *poloniex) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes18608 := (<-this.LoadMarkets())
            PanicOnError(retRes18608)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            var marketType interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchOpenOrders", market, params);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            if IsTrue(!IsEqual(limit, nil)) {
                var max interface{} = Ternary(IsTrue((IsEqual(marketType, "spot"))), 2000, 100)
                AddElementToObject(request, "limit", mathMax(limit, max))
            }
            var isTrigger interface{} = this.SafeValue2(params, "trigger", "stop")
            params = this.Omit(params, []interface{}{"trigger", "stop"})
            var response interface{} = nil
            if !IsTrue(GetValue(market, "spot")) {
        
                raw:= (<-this.SwapPrivateGetV3TradeOrderOpens(this.Extend(request, params)))
                PanicOnError(raw)
                //
                //    {
                //        "code": "200",
                //        "msg": "",
                //        "data": [
                //            {
                //                "symbol": "BTC_USDT_PERP",
                //                "side": "BUY",
                //                "type": "LIMIT",
                //                "ordId": "418890767248232148",
                //                "clOrdId": "polo418890767248232148",
                //                "mgnMode": "CROSS",
                //                "px": "81130.13",
                //                "reduceOnly": false,
                //                "lever": "20",
                //                "state": "NEW",
                //                "source": "WEB",
                //                "timeInForce": "GTC",
                //                "tpTrgPx": "",
                //                "tpPx": "",
                //                "tpTrgPxType": "",
                //                "slTrgPx": "",
                //                "slPx": "",
                //                "slTrgPxType": "",
                //                "avgPx": "0",
                //                "execQty": "0",
                //                "execAmt": "0",
                //                "feeCcy": "",
                //                "feeAmt": "0",
                //                "deductCcy": "0",
                //                "deductAmt": "0",
                //                "stpMode": "NONE",
                //                "cTime": "1740837741523",
                //                "uTime": "1740840846882",
                //                "sz": "1",
                //                "posSide": "BOTH",
                //                "qCcy": "USDT"
                //            },
                //
                response = this.SafeList(raw, "data")
            } else if IsTrue(isTrigger) {
                
        response = (<-this.PrivateGetSmartorders(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PrivateGetOrders(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            //     [
            //         {
            //             "id" : "7xxxxxxxxxxxxxxx6",
            //             "clientOrderId" : "",
            //             "symbol" : "ETH_USDT",
            //             "state" : "NEW",
            //             "accountType" : "SPOT",
            //             "side" : "BUY",
            //             "type" : "LIMIT",
            //             "timeInForce" : "GTC",
            //             "quantity" : "0.001",
            //             "price" : "1600",
            //             "avgPrice" : "0",
            //             "amount" : "0",
            //             "filledQuantity" : "0",
            //             "filledAmount" : "0",
            //             "stopPrice": "3750.00",              // for trigger orders
            //             "createTime" : 16xxxxxxxxx26,
            //             "updateTime" : 16xxxxxxxxx36
            //         }
            //     ]
            //
            var extension interface{} = map[string]interface{} {
                "status": "open",
            }
        
            ch <- this.ParseOrders(response, market, since, limit, extension)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniex#fetchClosedOrders
 * @see https://api-docs.poloniex.com/v3/futures/api/trade/get-order-history
 * @description fetches information on multiple closed orders made by the user
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest entry
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *poloniex) FetchClosedOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes19638 := (<-this.LoadMarkets())
            PanicOnError(retRes19638)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            var marketType interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchClosedOrders", market, params, "swap");
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            if IsTrue(IsEqual(marketType, "spot")) {
                panic(NotSupported(Add(this.Id, " fetchClosedOrders() is not supported for spot markets yet")))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", mathMin(200, limit))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "sTime", since)
            }
            requestparamsVariable := this.HandleUntilOption("eTime", request, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
        
            response:= (<-this.SwapPrivateGetV3TradeOrderHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "code": "200",
            //        "msg": "",
            //        "data": [
            //            {
            //                "symbol": "BTC_USDT_PERP",
            //                "side": "SELL",
            //                "type": "MARKET",
            //                "ordId": "418912106147315712",
            //                "clOrdId": "polo418912106147315712",
            //                "mgnMode": "CROSS",
            //                "px": "0",
            //                "sz": "2",
            //                "lever": "20",
            //                "state": "FILLED",
            //                "cancelReason": "",
            //                "source": "WEB",
            //                "reduceOnly": "true",
            //                "timeInForce": "GTC",
            //                "tpTrgPx": "",
            //                "tpPx": "",
            //                "tpTrgPxType": "",
            //                "slTrgPx": "",
            //                "slPx": "",
            //                "slTrgPxType": "",
            //                "avgPx": "84705.56",
            //                "execQty": "2",
            //                "execAmt": "169.41112",
            //                "feeCcy": "USDT",
            //                "feeAmt": "0.08470556",
            //                "deductCcy": "0",
            //                "deductAmt": "0",
            //                "stpMode": "NONE",
            //                "cTime": "1740842829116",
            //                "uTime": "1740842829130",
            //                "posSide": "BOTH",
            //                "qCcy": "USDT"
            //            },
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseOrders(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniex#createOrder
 * @description create a trade order
 * @see https://api-docs.poloniex.com/spot/api/private/order#create-order
 * @see https://api-docs.poloniex.com/spot/api/private/smart-order#create-order  // trigger orders
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {float} [params.triggerPrice] the price at which a trigger order is triggered at
 * @param {float} [params.cost] *spot market buy only* the quote quantity that can be used as an alternative for the amount
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *poloniex) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes20448 := (<-this.LoadMarkets())
            PanicOnError(retRes20448)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "side": ToUpper(side),
            }
            var triggerPrice interface{} = this.SafeNumber2(params, "stopPrice", "triggerPrice")
            requestparamsVariable := this.OrderRequest(symbol, typeVar, side, amount, request, price, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
            var response interface{} = nil
            if IsTrue(IsTrue(GetValue(market, "swap")) || IsTrue(GetValue(market, "future"))) {
        
                responseInitial:= (<-this.SwapPrivatePostV3TradeOrder(this.Extend(request, params)))
                PanicOnError(responseInitial)
                //
                // {"code":200,"msg":"Success","data":{"ordId":"418876147745775616","clOrdId":"polo418876147745775616"}}
                //
                response = this.SafeDict(responseInitial, "data")
            } else if IsTrue(!IsEqual(triggerPrice, nil)) {
                
        response = (<-this.PrivatePostSmartorders(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PrivatePostOrders(this.Extend(request, params)))
                PanicOnError(response)
            }
        
                //
            //     {
            //         "id" : "78923648051920896",
            //         "clientOrderId" : ""
            //     }
            //
        ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
func  (this *poloniex) OrderRequest(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, request interface{}, optionalArgs ...interface{}) interface{}  {
    price := GetArg(optionalArgs, 0, nil)
    _ = price
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    var triggerPrice interface{} = this.SafeNumber2(params, "stopPrice", "triggerPrice")
    var market interface{} = this.Market(symbol)
    if IsTrue(GetValue(market, "contract")) {
        var marginMode interface{} = nil
        marginModeparamsVariable := this.HandleParamString(params, "marginMode");
        marginMode = GetValue(marginModeparamsVariable,0);
        params = GetValue(marginModeparamsVariable,1)
        if IsTrue(!IsEqual(marginMode, nil)) {
            this.CheckRequiredArgument("createOrder", marginMode, "marginMode", []interface{}{"cross", "isolated"})
            AddElementToObject(request, "mgnMode", ToUpper(marginMode))
        }
        var hedged interface{} = nil
        hedgedparamsVariable := this.HandleParamString(params, "hedged");
        hedged = GetValue(hedgedparamsVariable,0);
        params = GetValue(hedgedparamsVariable,1)
        if IsTrue(hedged) {
            if IsTrue(IsEqual(marginMode, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " createOrder() requires a marginMode parameter \"cross\" or \"isolated\" for hedged orders")))
            }
            if !IsTrue((InOp(params, "posSide"))) {
                panic(ArgumentsRequired(Add(this.Id, " createOrder() requires a posSide parameter \"LONG\" or \"SHORT\" for hedged orders")))
            }
        }
    }
    var upperCaseType interface{} = ToUpper(typeVar)
    var isMarket interface{} = IsEqual(upperCaseType, "MARKET")
    var isPostOnly interface{} = this.IsPostOnly(isMarket, IsEqual(upperCaseType, "LIMIT_MAKER"), params)
    params = this.Omit(params, []interface{}{"postOnly", "triggerPrice", "stopPrice"})
    if IsTrue(!IsEqual(triggerPrice, nil)) {
        if !IsTrue(GetValue(market, "spot")) {
            panic(InvalidOrder(Add(Add(Add(this.Id, " createOrder() does not support trigger orders for "), GetValue(market, "type")), " markets")))
        }
        upperCaseType = Ternary(IsTrue((IsEqual(price, nil))), "STOP", "STOP_LIMIT")
        AddElementToObject(request, "stopPrice", triggerPrice)
    } else if IsTrue(isPostOnly) {
        upperCaseType = "LIMIT_MAKER"
    }
    AddElementToObject(request, "type", upperCaseType)
    if IsTrue(isMarket) {
        if IsTrue(IsEqual(side, "buy")) {
            var quoteAmount interface{} = nil
            var createMarketBuyOrderRequiresPrice interface{} = true
            createMarketBuyOrderRequiresPriceparamsVariable := this.HandleOptionAndParams(params, "createOrder", "createMarketBuyOrderRequiresPrice", true);
            createMarketBuyOrderRequiresPrice = GetValue(createMarketBuyOrderRequiresPriceparamsVariable,0);
            params = GetValue(createMarketBuyOrderRequiresPriceparamsVariable,1)
            var cost interface{} = this.SafeNumber(params, "cost")
            params = this.Omit(params, "cost")
            if IsTrue(!IsEqual(cost, nil)) {
                quoteAmount = this.CostToPrecision(symbol, cost)
            } else if IsTrue(IsTrue(createMarketBuyOrderRequiresPrice) && IsTrue(GetValue(market, "spot"))) {
                if IsTrue(IsEqual(price, nil)) {
                    panic(InvalidOrder(Add(this.Id, " createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend (quote quantity) in the amount argument")))
                } else {
                    var amountString interface{} = this.NumberToString(amount)
                    var priceString interface{} = this.NumberToString(price)
                    var costRequest interface{} = Precise.StringMul(amountString, priceString)
                    quoteAmount = this.CostToPrecision(symbol, costRequest)
                }
            } else {
                quoteAmount = this.CostToPrecision(symbol, amount)
            }
            var amountKey interface{} = Ternary(IsTrue(GetValue(market, "spot")), "amount", "sz")
            AddElementToObject(request, amountKey, quoteAmount)
        } else {
            var amountKey interface{} = Ternary(IsTrue(GetValue(market, "spot")), "quantity", "sz")
            AddElementToObject(request, amountKey, this.AmountToPrecision(symbol, amount))
        }
    } else {
        var amountKey interface{} = Ternary(IsTrue(GetValue(market, "spot")), "quantity", "sz")
        AddElementToObject(request, amountKey, this.AmountToPrecision(symbol, amount))
        var priceKey interface{} = Ternary(IsTrue(GetValue(market, "spot")), "price", "px")
        AddElementToObject(request, priceKey, this.PriceToPrecision(symbol, price))
    }
    var clientOrderId interface{} = this.SafeString(params, "clientOrderId")
    if IsTrue(!IsEqual(clientOrderId, nil)) {
        AddElementToObject(request, "clientOrderId", clientOrderId)
        params = this.Omit(params, "clientOrderId")
    }
    // remember the timestamp before issuing the request
    return []interface{}{request, params}
}
/**
 * @method
 * @name poloniex#editOrder
 * @description edit a trade order
 * @see https://api-docs.poloniex.com/spot/api/private/order#cancel-replace-order
 * @see https://api-docs.poloniex.com/spot/api/private/smart-order#cancel-replace-order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} [amount] how much of the currency you want to trade in units of the base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {float} [params.triggerPrice] The price at which a trigger order is triggered at
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *poloniex) EditOrder(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    amount := GetArg(optionalArgs, 0, nil)
            _ = amount
            price := GetArg(optionalArgs, 1, nil)
            _ = price
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes21708 := (<-this.LoadMarkets())
            PanicOnError(retRes21708)
            var market interface{} = this.Market(symbol)
            if !IsTrue(GetValue(market, "spot")) {
                panic(NotSupported(Add(Add(Add(this.Id, " editOrder() does not support "), GetValue(market, "type")), " orders, only spot orders are accepted")))
            }
            var request interface{} = map[string]interface{} {
                "id": id,
            }
            var triggerPrice interface{} = this.SafeNumber2(params, "stopPrice", "triggerPrice")
            requestparamsVariable := this.OrderRequest(symbol, typeVar, side, amount, request, price, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
            var response interface{} = nil
            if IsTrue(!IsEqual(triggerPrice, nil)) {
                
        response = (<-this.PrivatePutSmartordersId(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PrivatePutOrdersId(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            //     {
            //         "id" : "78923648051920896",
            //         "clientOrderId" : ""
            //     }
            //
            response = this.Extend(response, map[string]interface{} {
                "side": side,
                "type": typeVar,
            })
        
            ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
func  (this *poloniex) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    //
            // @method
            // @name poloniex#cancelOrder
            // @description cancels an open order
            // @see https://api-docs.poloniex.com/spot/api/private/order#cancel-order-by-id
            // @see https://api-docs.poloniex.com/spot/api/private/smart-order#cancel-order-by-id  // trigger orders
            // @param {string} id order id
            // @param {string} symbol unified symbol of the market the order was made in
            // @param {object} [params] extra parameters specific to the exchange API endpoint
            // @param {boolean} [params.trigger] true if canceling a trigger order
            // @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
            //
            symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes22138 := (<-this.LoadMarkets())
            PanicOnError(retRes22138)
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " cancelOrder() requires a symbol argument")))
            }
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {}
            if !IsTrue(GetValue(market, "spot")) {
                AddElementToObject(request, "symbol", GetValue(market, "id"))
                AddElementToObject(request, "ordId", id)
        
                raw:= (<-this.SwapPrivateDeleteV3TradeOrder(this.Extend(request, params)))
                PanicOnError(raw)
        
                        //
                //    {
                //        "code": "200",
                //        "msg": "Success",
                //        "data": {
                //            "ordId": "418886099910612040",
                //            "clOrdId": "polo418886099910612040"
                //        }
                //    }
                //
        ch <- this.ParseOrder(this.SafeDict(raw, "data"))
                return nil
            }
            var clientOrderId interface{} = this.SafeValue(params, "clientOrderId")
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                id = clientOrderId
            }
            AddElementToObject(request, "id", id)
            var isTrigger interface{} = this.SafeValue2(params, "trigger", "stop")
            params = this.Omit(params, []interface{}{"clientOrderId", "trigger", "stop"})
            var response interface{} = nil
            if IsTrue(isTrigger) {
                
        response = (<-this.PrivateDeleteSmartordersId(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PrivateDeleteOrdersId(this.Extend(request, params)))
                PanicOnError(response)
            }
        
                //
            //   {
            //       "orderId":"210832697138888704",
            //       "clientOrderId":"",
            //       "state":"PENDING_CANCEL",
            //       "code":200,
            //       "message":""
            //   }
            //
        ch <- this.ParseOrder(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniex#cancelAllOrders
 * @description cancel all open orders
 * @see https://api-docs.poloniex.com/spot/api/private/order#cancel-all-orders
 * @see https://api-docs.poloniex.com/spot/api/private/smart-order#cancel-all-orders  // trigger orders
 * @see https://api-docs.poloniex.com/v3/futures/api/trade/cancel-all-orders - contract markets
 * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] true if canceling trigger orders
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *poloniex) CancelAllOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes22738 := (<-this.LoadMarkets())
            PanicOnError(retRes22738)
            var request interface{} = map[string]interface{} {
                "symbols": []interface{}{},
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbols", []interface{}{GetValue(market, "id")})
            }
            var response interface{} = nil
            var marketType interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("cancelAllOrders", market, params);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            if IsTrue(IsTrue(IsEqual(marketType, "swap")) || IsTrue(IsEqual(marketType, "future"))) {
        
                raw:= (<-this.SwapPrivateDeleteV3TradeAllOrders(this.Extend(request, params)))
                PanicOnError(raw)
                //
                //    {
                //        "code": "200",
                //        "msg": "Success",
                //        "data": [
                //            {
                //                "code": "200",
                //                "msg": "Success",
                //                "ordId": "418885787866388511",
                //                "clOrdId": "polo418885787866388511"
                //            }
                //        ]
                //    }
                //
                response = this.SafeList(raw, "data")
        
                ch <- this.ParseOrders(response, market)
                return nil
            }
            var isTrigger interface{} = this.SafeValue2(params, "trigger", "stop")
            params = this.Omit(params, []interface{}{"trigger", "stop"})
            if IsTrue(isTrigger) {
                
        response = (<-this.PrivateDeleteSmartorders(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PrivateDeleteOrders(this.Extend(request, params)))
                PanicOnError(response)
            }
        
                //
            //     [
            //         {
            //             "orderId" : "78xxxxxxxx80",
            //             "clientOrderId" : "",
            //             "state" : "NEW",
            //             "code" : 200,
            //             "message" : ""
            //         }, {
            //             "orderId" : "78xxxxxxxxx80",
            //             "clientOrderId" : "",
            //             "state" : "NEW",
            //             "code" : 200,
            //             "message" : ""
            //         }
            //     ]
            //
        ch <- this.ParseOrders(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniex#fetchOrder
 * @description fetch an order by it's id
 * @see https://api-docs.poloniex.com/spot/api/private/order#order-details
 * @see https://api-docs.poloniex.com/spot/api/private/smart-order#open-orders  // trigger orders
 * @param {string} id order id
 * @param {string} symbol unified market symbol, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] true if fetching a trigger order
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *poloniex) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes23478 := (<-this.LoadMarkets())
            PanicOnError(retRes23478)
            id = ToString(id)
            var request interface{} = map[string]interface{} {
                "id": id,
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            var marketType interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchOrder", market, params);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            if IsTrue(!IsEqual(marketType, "spot")) {
                panic(NotSupported(Add(Add(Add(this.Id, " fetchOrder() is not supported for "), marketType), " markets yet")))
            }
            var isTrigger interface{} = this.SafeValue2(params, "trigger", "stop")
            params = this.Omit(params, []interface{}{"trigger", "stop"})
            var response interface{} = nil
            if IsTrue(isTrigger) {
                
        response = (<-this.PrivateGetSmartordersId(this.Extend(request, params)))
                PanicOnError(response)
                response = this.SafeValue(response, 0)
            } else {
                
        response = (<-this.PrivateGetOrdersId(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            //     {
            //         "id": "21934611974062080",
            //         "clientOrderId": "123",
            //         "symbol": "TRX_USDC",
            //         "state": "NEW",
            //         "accountType": "SPOT",
            //         "side": "SELL",
            //         "type": "LIMIT",
            //         "timeInForce": "GTC",
            //         "quantity": "1.00",
            //         "price": "10.00",
            //         "avgPrice": "0.00",
            //         "amount": "0.00",
            //         "filledQuantity": "0.00",
            //         "filledAmount": "0.00",
            //         "stopPrice": "3750.00",              // for trigger orders
            //         "createTime": 1646196019020,
            //         "updateTime": 1646196019020
            //     }
            //
            var order interface{} = this.ParseOrder(response)
            AddElementToObject(order, "id", id)
        
            ch <- order
            return nil
        
            }()
            return ch
        }
func  (this *poloniex) FetchOrderStatus(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes23988 := (<-this.LoadMarkets())
            PanicOnError(retRes23988)
        
            orders:= (<-this.FetchOpenOrders(symbol, nil, nil, params))
            PanicOnError(orders)
            var indexed interface{} = this.IndexBy(orders, "id")
        
            ch <- Ternary(IsTrue((InOp(indexed, id))), "open", "closed")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniex#fetchOrderTrades
 * @description fetch all the trades made from a single order
 * @see https://api-docs.poloniex.com/spot/api/private/trade#trades-by-order-id
 * @param {string} id order id
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *poloniex) FetchOrderTrades(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes24178 := (<-this.LoadMarkets())
            PanicOnError(retRes24178)
            var request interface{} = map[string]interface{} {
                "id": id,
            }
        
            trades:= (<-this.PrivateGetOrdersIdTrades(this.Extend(request, params)))
            PanicOnError(trades)
        
                //
            //     [
            //         {
            //             "id": "30341456333942784",
            //             "symbol": "LINK_USDT",
            //             "accountType": "SPOT",
            //             "orderId": "30249408733945856",
            //             "side": "BUY",
            //             "type": "LIMIT",
            //             "matchRole": "MAKER",
            //             "createTime": 1648200366864,
            //             "price": "3.1",
            //             "quantity": "1",
            //             "amount": "3.1",
            //             "feeCurrency": "LINK",
            //             "feeAmount": "0.00145",
            //             "pageId": "30341456333942784",
            //             "clientOrderId": ""
            //         }
            //     ]
            //
        ch <- this.ParseTrades(trades)
            return nil
        
            }()
            return ch
        }
func  (this *poloniex) ParseBalance(response interface{}) interface{}  {
    var result interface{} = map[string]interface{} {
        "info": response,
        "timestamp": nil,
        "datetime": nil,
    }
    // for swap
    if !IsTrue(IsArray(response)) {
        var ts interface{} = this.SafeInteger(response, "uTime")
        AddElementToObject(result, "timestamp", ts)
        AddElementToObject(result, "datetime", this.Iso8601(ts))
        var details interface{} = this.SafeList(response, "details", []interface{}{})
        for i := 0; IsLessThan(i, GetArrayLength(details)); i++ {
            var balance interface{} = GetValue(details, i)
            var currencyId interface{} = this.SafeString(balance, "ccy")
            var code interface{} = this.SafeCurrencyCode(currencyId)
            var account interface{} = this.Account()
            AddElementToObject(account, "total", this.SafeString(balance, "avail"))
            AddElementToObject(account, "used", this.SafeString(balance, "im"))
            AddElementToObject(result, code, account)
        }
        return this.SafeBalance(result)
    }
    // for spot
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        var account interface{} = this.SafeValue(response, i, map[string]interface{} {})
        var balances interface{} = this.SafeValue(account, "balances")
        for j := 0; IsLessThan(j, GetArrayLength(balances)); j++ {
            var balance interface{} = this.SafeValue(balances, j)
            var currencyId interface{} = this.SafeString(balance, "currency")
            var code interface{} = this.SafeCurrencyCode(currencyId)
            var newAccount interface{} = this.Account()
            AddElementToObject(newAccount, "free", this.SafeString(balance, "available"))
            AddElementToObject(newAccount, "used", this.SafeString(balance, "hold"))
            AddElementToObject(result, code, newAccount)
        }
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name poloniex#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://api-docs.poloniex.com/spot/api/private/account#all-account-balances
 * @see https://api-docs.poloniex.com/v3/futures/api/account/balance
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *poloniex) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes24968 := (<-this.LoadMarkets())
            PanicOnError(retRes24968)
            var marketType interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchBalance", nil, params);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            if IsTrue(!IsEqual(marketType, "spot")) {
        
                responseRaw:= (<-this.SwapPrivateGetV3AccountBalance(params))
                PanicOnError(responseRaw)
                //
                //    {
                //        "code": "200",
                //        "msg": "",
                //        "data": {
                //            "state": "NORMAL",
                //            "eq": "9.98571622",
                //            "isoEq": "0",
                //            "im": "0",
                //            "mm": "0",
                //            "mmr": "0",
                //            "upl": "0",
                //            "availMgn": "9.98571622",
                //            "cTime": "1738093601775",
                //            "uTime": "1740829116236",
                //            "details": [
                //                {
                //                    "ccy": "USDT",
                //                    "eq": "9.98571622",
                //                    "isoEq": "0",
                //                    "avail": "9.98571622",
                //                    "trdHold": "0",
                //                    "upl": "0",
                //                    "isoAvail": "0",
                //                    "isoHold": "0",
                //                    "isoUpl": "0",
                //                    "im": "0",
                //                    "mm": "0",
                //                    "mmr": "0",
                //                    "imr": "0",
                //                    "cTime": "1740829116236",
                //                    "uTime": "1740829116236"
                //                }
                //            ]
                //        }
                //    }
                //
                var data interface{} = this.SafeDict(responseRaw, "data", map[string]interface{} {})
        
                ch <- this.ParseBalance(data)
                return nil
            }
            var request interface{} = map[string]interface{} {
                "accountType": "SPOT",
            }
        
            response:= (<-this.PrivateGetAccountsBalances(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "accountId" : "7xxxxxxxxxx8",
            //             "accountType" : "SPOT",
            //             "balances" : [
            //                 {
            //                     "currencyId" : "214",
            //                     "currency" : "USDT",
            //                     "available" : "2.00",
            //                     "hold" : "0.00"
            //                 }
            //             ]
            //         }
            //     ]
            //
        ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniex#fetchTradingFees
 * @description fetch the trading fees for multiple markets
 * @see https://api-docs.poloniex.com/spot/api/private/account#fee-info
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
 */
func  (this *poloniex) FetchTradingFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes25738 := (<-this.LoadMarkets())
            PanicOnError(retRes25738)
        
            response:= (<-this.PrivateGetFeeinfo(params))
            PanicOnError(response)
            //
            //     {
            //         "trxDiscount" : false,
            //         "makerRate" : "0.00145",
            //         "takerRate" : "0.00155",
            //         "volume30D" : "0.00"
            //     }
            //
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(this.Symbols)); i++ {
                var symbol interface{} = GetValue(this.Symbols, i)
                AddElementToObject(result, symbol, map[string]interface{} {
            "info": response,
            "symbol": symbol,
            "maker": this.SafeNumber(response, "makerRate"),
            "taker": this.SafeNumber(response, "takerRate"),
            "percentage": true,
            "tierBased": true,
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniex#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://api-docs.poloniex.com/spot/api/public/market-data#order-book
 * @see https://api-docs.poloniex.com/v3/futures/api/market/get-order-book
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *poloniex) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes26108 := (<-this.LoadMarkets())
            PanicOnError(retRes26108)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit) // The default value of limit is 10. Valid limit values are: 5, 10, 20, 50, 100, 150.
                if IsTrue(GetValue(market, "contract")) {
                    AddElementToObject(request, "limit", this.FindNearestCeiling([]interface{}{5, 10, 20, 100, 150}, limit))
                }
            }
            if IsTrue(GetValue(market, "contract")) {
        
                responseRaw:= (<-this.SwapPublicGetV3MarketOrderBook(this.Extend(request, params)))
                PanicOnError(responseRaw)
                //
                //    {
                //       "code": 200,
                //       "data": {
                //         "asks": [ ["58700", "9934"], ..],
                //         "bids": [ ["58600", "9952"], ..],
                //         "s": "100",
                //         "ts": 1719974138333
                //       },
                //       "msg": "Success"
                //    }
                //
                var data interface{} = this.SafeDict(responseRaw, "data", map[string]interface{} {})
                var ts interface{} = this.SafeInteger(data, "ts")
        
                ch <- this.ParseOrderBook(data, symbol, ts)
                return nil
            }
        
            response:= (<-this.PublicGetMarketsSymbolOrderBook(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "time" : 1659695219507,
            //         "scale" : "-1",
            //         "asks" : [ "23139.82", "0.317981", "23140", "0.191091", "23170.06", "0.01", "23200", "0.107758", "23230.55", "0.01", "23247.2", "0.154", "23254", "0.005121", "23263", "0.038", "23285.4", "0.308", "23300", "0.108896" ],
            //         "bids" : [ "23139.74", "0.432092", "23139.73", "0.198592", "23123.21", "0.000886", "23123.2", "0.308", "23121.4", "0.154", "23105", "0.000789", "23100", "0.078175", "23069.1", "0.026276", "23068.83", "0.001329", "23051", "0.000048" ],
            //         "ts" : 1659695219513
            //     }
            //
            var timestamp interface{} = this.SafeInteger(response, "time")
            var asks interface{} = this.SafeValue(response, "asks")
            var bids interface{} = this.SafeValue(response, "bids")
            var asksResult interface{} = []interface{}{}
            var bidsResult interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(asks)); i++ {
                if IsTrue(IsLessThan((Mod(i, 2)), 1)) {
                    var price interface{} = this.SafeNumber(asks, i)
                    var amount interface{} = this.SafeNumber(asks, this.Sum(i, 1))
                    AppendToArray(&asksResult,[]interface{}{price, amount})
                }
            }
            for i := 0; IsLessThan(i, GetArrayLength(bids)); i++ {
                if IsTrue(IsLessThan((Mod(i, 2)), 1)) {
                    var price interface{} = this.SafeNumber(bids, i)
                    var amount interface{} = this.SafeNumber(bids, this.Sum(i, 1))
                    AppendToArray(&bidsResult,[]interface{}{price, amount})
                }
            }
        
            ch <- map[string]interface{} {
                "symbol": GetValue(market, "symbol"),
                "bids": this.SortBy(bidsResult, 0, true),
                "asks": this.SortBy(asksResult, 0),
                "timestamp": timestamp,
                "datetime": this.Iso8601(timestamp),
                "nonce": nil,
            }
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniex#createDepositAddress
 * @description create a currency deposit address
 * @see https://api-docs.poloniex.com/spot/api/private/wallet#deposit-addresses
 * @param {string} code unified currency code of the currency for the deposit address
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *poloniex) CreateDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes26888 := (<-this.LoadMarkets())
            PanicOnError(retRes26888)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "currency": GetValue(currency, "id"),
            }
            var networks interface{} = this.SafeValue(this.Options, "networks", map[string]interface{} {})
            var network interface{} = this.SafeStringUpper(params, "network") // this line allows the user to specify either ERC20 or ETH
            network = this.SafeString(networks, network, network) // handle ERC20>ETH alias
            if IsTrue(!IsEqual(network, nil)) {
                AddElementToObject(request, "currency", Add(GetValue(request, "currency"), network)) // when network the currency need to be changed to currency+network https://docs.poloniex.com/#withdraw on MultiChain Currencies section
                params = this.Omit(params, "network")
            } else {
                if IsTrue(IsEqual(GetValue(currency, "id"), "USDT")) {
                    panic(ArgumentsRequired(Add(Add(Add(this.Id, " createDepositAddress requires a network parameter for "), code), ".")))
                }
            }
        
            response:= (<-this.PrivatePostWalletsAddress(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "address" : "0xfxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxf"
            //     }
            //
            var address interface{} = this.SafeString(response, "address")
            var tag interface{} = nil
            this.CheckAddress(address)
            if IsTrue(!IsEqual(currency, nil)) {
                var depositAddress interface{} = this.SafeString(GetValue(currency, "info"), "depositAddress")
                if IsTrue(!IsEqual(depositAddress, nil)) {
                    tag = address
                    address = depositAddress
                }
            }
        
            ch <- map[string]interface{} {
                "currency": code,
                "address": address,
                "tag": tag,
                "network": network,
                "info": response,
            }
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniex#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account
 * @see https://api-docs.poloniex.com/spot/api/private/wallet#deposit-addresses
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *poloniex) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes27398 := (<-this.LoadMarkets())
            PanicOnError(retRes27398)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "currency": GetValue(currency, "id"),
            }
            var networks interface{} = this.SafeValue(this.Options, "networks", map[string]interface{} {})
            var network interface{} = this.SafeStringUpper(params, "network") // this line allows the user to specify either ERC20 or ETH
            network = this.SafeString(networks, network, network) // handle ERC20>ETH alias
            if IsTrue(!IsEqual(network, nil)) {
                AddElementToObject(request, "currency", Add(GetValue(request, "currency"), network)) // when network the currency need to be changed to currency+network https://docs.poloniex.com/#withdraw on MultiChain Currencies section
                params = this.Omit(params, "network")
            } else {
                if IsTrue(IsEqual(GetValue(currency, "id"), "USDT")) {
                    panic(ArgumentsRequired(Add(Add(Add(this.Id, " fetchDepositAddress requires a network parameter for "), code), ".")))
                }
            }
        
            response:= (<-this.PrivateGetWalletsAddresses(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "USDTTRON" : "Txxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxp"
            //     }
            //
            var address interface{} = this.SafeString(response, GetValue(request, "currency"))
            var tag interface{} = nil
            this.CheckAddress(address)
            if IsTrue(!IsEqual(currency, nil)) {
                var depositAddress interface{} = this.SafeString(GetValue(currency, "info"), "depositAddress")
                if IsTrue(!IsEqual(depositAddress, nil)) {
                    tag = address
                    address = depositAddress
                }
            }
        
            ch <- map[string]interface{} {
                "info": response,
                "currency": code,
                "network": network,
                "address": address,
                "tag": tag,
            }
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniex#transfer
 * @description transfer currency internally between wallets on the same account
 * @see https://api-docs.poloniex.com/spot/api/private/account#accounts-transfer
 * @param {string} code unified currency code
 * @param {float} amount amount to transfer
 * @param {string} fromAccount account to transfer from
 * @param {string} toAccount account to transfer to
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func  (this *poloniex) Transfer(code interface{}, amount interface{}, fromAccount interface{}, toAccount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes27938 := (<-this.LoadMarkets())
            PanicOnError(retRes27938)
            var currency interface{} = this.Currency(code)
            var accountsByType interface{} = this.SafeValue(this.Options, "accountsByType", map[string]interface{} {})
            var fromId interface{} = this.SafeString(accountsByType, fromAccount, fromAccount)
            var toId interface{} = this.SafeString(accountsByType, toAccount, fromAccount)
            var request interface{} = map[string]interface{} {
                "amount": this.CurrencyToPrecision(code, amount),
                "currency": GetValue(currency, "id"),
                "fromAccount": fromId,
                "toAccount": toId,
            }
        
            response:= (<-this.PrivatePostAccountsTransfer(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //    {
            //        "transferId" : "168041074"
            //    }
            //
        ch <- this.ParseTransfer(response, currency)
            return nil
        
            }()
            return ch
        }
func  (this *poloniex) ParseTransfer(transfer interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "transferId" : "168041074"
    //    }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    return map[string]interface{} {
        "info": transfer,
        "id": this.SafeString(transfer, "transferId"),
        "timestamp": nil,
        "datetime": nil,
        "currency": this.SafeString(currency, "id"),
        "amount": nil,
        "fromAccount": nil,
        "toAccount": nil,
        "status": nil,
    }
}
/**
 * @method
 * @name poloniex#withdraw
 * @description make a withdrawal
 * @see https://api-docs.poloniex.com/spot/api/private/wallet#withdraw-currency
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *poloniex) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params);
            tag = GetValue(tagparamsVariable,0);
            params = GetValue(tagparamsVariable,1)
            this.CheckAddress(address)
        
            retRes28478 := (<-this.LoadMarkets())
            PanicOnError(retRes28478)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "currency": GetValue(currency, "id"),
                "amount": amount,
                "address": address,
            }
            if IsTrue(!IsEqual(tag, nil)) {
                AddElementToObject(request, "paymentId", tag)
            }
            var networks interface{} = this.SafeValue(this.Options, "networks", map[string]interface{} {})
            var network interface{} = this.SafeStringUpper(params, "network") // this line allows the user to specify either ERC20 or ETH
            network = this.SafeString(networks, network, network) // handle ERC20>ETH alias
            if IsTrue(!IsEqual(network, nil)) {
                AddElementToObject(request, "currency", Add(GetValue(request, "currency"), network)) // when network the currency need to be changed to currency+network https://docs.poloniex.com/#withdraw on MultiChain Currencies section
                params = this.Omit(params, "network")
            }
        
            response:= (<-this.PrivatePostWalletsWithdraw(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "response": "Withdrew 1.00000000 USDT.",
            //         "email2FA": false,
            //         "withdrawalNumber": 13449869
            //     }
            //
        ch <- this.ParseTransaction(response, currency)
            return nil
        
            }()
            return ch
        }
func  (this *poloniex) FetchTransactionsHelper(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes28768 := (<-this.LoadMarkets())
            PanicOnError(retRes28768)
            var year interface{} = 31104000 // 60 * 60 * 24 * 30 * 12 = one year of history, why not
            var now interface{} = this.Seconds()
            var start interface{} = Ternary(IsTrue((!IsEqual(since, nil))), this.ParseToInt(Divide(since, 1000)), Subtract(now, Multiply(10, year)))
            var request interface{} = map[string]interface{} {
                "start": start,
                "end": now,
            }
        
            response:= (<-this.PrivateGetWalletsActivity(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "adjustments":[],
            //         "deposits":[
            //             {
            //                 "currency": "BTC",
            //                 "address": "1MEtiqJWru53FhhHrfJPPvd2tC3TPDVcmW",
            //                 "amount": "0.01063000",
            //                 "confirmations":  1,
            //                 "txid": "952b0e1888d6d491591facc0d37b5ebec540ac1efb241fdbc22bcc20d1822fb6",
            //                 "timestamp":  1507916888,
            //                 "status": "COMPLETE"
            //             },
            //             {
            //                 "currency": "ETH",
            //                 "address": "0x20108ba20b65c04d82909e91df06618107460197",
            //                 "amount": "4.00000000",
            //                 "confirmations": 38,
            //                 "txid": "0x4be260073491fe63935e9e0da42bd71138fdeb803732f41501015a2d46eb479d",
            //                 "timestamp": 1525060430,
            //                 "status": "COMPLETE"
            //             }
            //         ],
            //         "withdrawals":[
            //             {
            //                 "withdrawalNumber":13449869,
            //                 "currency":"USDTTRON", // not documented in API docs, see commonCurrencies in describe()
            //                 "address":"TXGaqPW23JdRWhsVwS2mRsGsegbdnAd3Rw",
            //                 "amount":"1.00000000",
            //                 "fee":"0.00000000",
            //                 "timestamp":1591573420,
            //                 "status":"COMPLETE: dadf427224b3d44b38a2c13caa4395e4666152556ca0b2f67dbd86a95655150f",
            //                 "ipAddress":"x.x.x.x",
            //                 "canCancel":0,
            //                 "canResendEmail":0,
            //                 "paymentID":null,
            //                 "scope":"crypto"
            //             },
            //             {
            //                 "withdrawalNumber": 8224394,
            //                 "currency": "EMC2",
            //                 "address": "EYEKyCrqTNmVCpdDV8w49XvSKRP9N3EUyF",
            //                 "amount": "63.10796020",
            //                 "fee": "0.01000000",
            //                 "timestamp": 1510819838,
            //                 "status": "COMPLETE: d37354f9d02cb24d98c8c4fc17aa42f475530b5727effdf668ee5a43ce667fd6",
            //                 "ipAddress": "x.x.x.x"
            //             },
            //             {
            //                 "withdrawalNumber": 9290444,
            //                 "currency": "ETH",
            //                 "address": "0x191015ff2e75261d50433fbd05bd57e942336149",
            //                 "amount": "0.15500000",
            //                 "fee": "0.00500000",
            //                 "timestamp": 1514099289,
            //                 "status": "COMPLETE: 0x12d444493b4bca668992021fd9e54b5292b8e71d9927af1f076f554e4bea5b2d",
            //                 "ipAddress": "x.x.x.x"
            //             },
            //             {
            //                 "withdrawalNumber": 11518260,
            //                 "currency": "BTC",
            //                 "address": "8JoDXAmE1GY2LRK8jD1gmAmgRPq54kXJ4t",
            //                 "amount": "0.20000000",
            //                 "fee": "0.00050000",
            //                 "timestamp": 1527918155,
            //                 "status": "COMPLETE: 1864f4ebb277d90b0b1ff53259b36b97fa1990edc7ad2be47c5e0ab41916b5ff",
            //                 "ipAddress": "x.x.x.x"
            //             }
            //         ]
            //     }
            //
        ch <- response
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniex#fetchDepositsWithdrawals
 * @description fetch history of deposits and withdrawals
 * @see https://api-docs.poloniex.com/spot/api/private/wallet#wallets-activity-records
 * @param {string} [code] unified currency code for the currency of the deposit/withdrawals, default is undefined
 * @param {int} [since] timestamp in ms of the earliest deposit/withdrawal, default is undefined
 * @param {int} [limit] max number of deposit/withdrawals to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *poloniex) FetchDepositsWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes29718 := (<-this.LoadMarkets())
            PanicOnError(retRes29718)
        
            response:= (<-this.FetchTransactionsHelper(code, since, limit, params))
            PanicOnError(response)
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
            }
            var withdrawals interface{} = this.SafeValue(response, "withdrawals", []interface{}{})
            var deposits interface{} = this.SafeValue(response, "deposits", []interface{}{})
            var withdrawalTransactions interface{} = this.ParseTransactions(withdrawals, currency, since, limit)
            var depositTransactions interface{} = this.ParseTransactions(deposits, currency, since, limit)
            var transactions interface{} = this.ArrayConcat(depositTransactions, withdrawalTransactions)
        
            ch <- this.FilterByCurrencySinceLimit(this.SortBy(transactions, "timestamp"), code, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniex#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @see https://api-docs.poloniex.com/spot/api/private/wallet#wallets-activity-records
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawals structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *poloniex) FetchWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            response:= (<-this.FetchTransactionsHelper(code, since, limit, params))
            PanicOnError(response)
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
            }
            var withdrawals interface{} = this.SafeValue(response, "withdrawals", []interface{}{})
            var transactions interface{} = this.ParseTransactions(withdrawals, currency, since, limit)
        
            ch <- this.FilterByCurrencySinceLimit(transactions, code, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniex#fetchDepositWithdrawFees
 * @description fetch deposit and withdraw fees
 * @see https://api-docs.poloniex.com/spot/api/public/reference-data#currency-information
 * @param {string[]|undefined} codes list of unified currency codes
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [fees structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func  (this *poloniex) FetchDepositWithdrawFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    codes := GetArg(optionalArgs, 0, nil)
            _ = codes
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes30178 := (<-this.LoadMarkets())
            PanicOnError(retRes30178)
        
            response:= (<-this.PublicGetCurrencies(this.Extend(params, map[string]interface{} {
            "includeMultiChainCurrencies": true,
        })))
            PanicOnError(response)
            //
            //     [
            //         {
            //             "1CR": {
            //                 "id": 1,
            //                 "name": "1CRedit",
            //                 "description": "BTC Clone",
            //                 "type": "address",
            //                 "withdrawalFee": "0.01000000",
            //                 "minConf": 10000,
            //                 "depositAddress": null,
            //                 "blockchain": "1CR",
            //                 "delisted": false,
            //                 "tradingState": "NORMAL",
            //                 "walletState": "DISABLED",
            //                 "parentChain": null,
            //                 "isMultiChain": false,
            //                 "isChildChain": false,
            //                 "childChains": []
            //             }
            //         }
            //     ]
            //
            var data interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
                var entry interface{} = GetValue(response, i)
                var currencies interface{} = ObjectKeys(entry)
                var currencyId interface{} = this.SafeString(currencies, 0)
                AddElementToObject(data, currencyId, GetValue(entry, currencyId))
            }
        
            ch <- this.ParseDepositWithdrawFees(data, codes)
            return nil
        
            }()
            return ch
        }
func  (this *poloniex) ParseDepositWithdrawFees(response interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //         {
    //             "1CR": {
    //                 "id": 1,
    //                 "name": "1CRedit",
    //                 "description": "BTC Clone",
    //                 "type": "address",
    //                 "withdrawalFee": "0.01000000",
    //                 "minConf": 10000,
    //                 "depositAddress": null,
    //                 "blockchain": "1CR",
    //                 "delisted": false,
    //                 "tradingState": "NORMAL",
    //                 "walletState": "DISABLED",
    //                 "parentChain": null,
    //                 "isMultiChain": false,
    //                 "isChildChain": false,
    //                 "childChains": []
    //             },
    //         }
    //
    codes := GetArg(optionalArgs, 0, nil)
    _ = codes
    currencyIdKey := GetArg(optionalArgs, 1, nil)
    _ = currencyIdKey
    var depositWithdrawFees interface{} = map[string]interface{} {}
    codes = this.MarketCodes(codes)
    var responseKeys interface{} = ObjectKeys(response)
    for i := 0; IsLessThan(i, GetArrayLength(responseKeys)); i++ {
        var currencyId interface{} = GetValue(responseKeys, i)
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var feeInfo interface{} = GetValue(response, currencyId)
        if IsTrue(IsTrue((IsEqual(codes, nil))) || IsTrue((this.InArray(code, codes)))) {
            var currency interface{} = this.Currency(code)
            AddElementToObject(depositWithdrawFees, code, this.ParseDepositWithdrawFee(feeInfo, currency))
            var childChains interface{} = this.SafeValue(feeInfo, "childChains")
            var chainsLength interface{} =             GetArrayLength(childChains)
            if IsTrue(IsGreaterThan(chainsLength, 0)) {
                for j := 0; IsLessThan(j, GetArrayLength(childChains)); j++ {
                    var networkId interface{} = GetValue(childChains, j)
                    networkId = Replace(networkId, code, "")
                    var networkCode interface{} = this.NetworkIdToCode(networkId)
                    var networkInfo interface{} = this.SafeValue(response, networkId)
                    var networkObject interface{} = map[string]interface{} {}
                    var withdrawFee interface{} = this.SafeNumber(networkInfo, "withdrawalFee")
                    AddElementToObject(networkObject, networkCode, map[string]interface{} {
    "withdraw": map[string]interface{} {
        "fee": withdrawFee,
        "percentage": Ternary(IsTrue((!IsEqual(withdrawFee, nil))), false, nil),
    },
    "deposit": map[string]interface{} {
        "fee": nil,
        "percentage": nil,
    },
})
                    AddElementToObject(GetValue(depositWithdrawFees, code), "networks", this.Extend(GetValue(GetValue(depositWithdrawFees, code), "networks"), networkObject))
                }
            }
        }
    }
    return depositWithdrawFees
}
func  (this *poloniex) ParseDepositWithdrawFee(fee interface{}, optionalArgs ...interface{}) interface{}  {
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var depositWithdrawFee interface{} = this.DepositWithdrawFee(map[string]interface{} {})
    AddElementToObject(GetValue(depositWithdrawFee, "info"), GetValue(currency, "code"), fee)
    var networkId interface{} = this.SafeString(fee, "blockchain")
    var withdrawFee interface{} = this.SafeNumber(fee, "withdrawalFee")
    var withdrawResult interface{} = map[string]interface{} {
        "fee": withdrawFee,
        "percentage": Ternary(IsTrue((!IsEqual(withdrawFee, nil))), false, nil),
    }
    var depositResult interface{} = map[string]interface{} {
        "fee": nil,
        "percentage": nil,
    }
    AddElementToObject(depositWithdrawFee, "withdraw", withdrawResult)
    AddElementToObject(depositWithdrawFee, "deposit", depositResult)
    var networkCode interface{} = this.NetworkIdToCode(networkId)
    AddElementToObject(GetValue(depositWithdrawFee, "networks"), networkCode, map[string]interface{} {
    "withdraw": withdrawResult,
    "deposit": depositResult,
})
    return depositWithdrawFee
}
/**
 * @method
 * @name poloniex#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://api-docs.poloniex.com/spot/api/private/wallet#wallets-activity-records
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *poloniex) FetchDeposits(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            response:= (<-this.FetchTransactionsHelper(code, since, limit, params))
            PanicOnError(response)
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
            }
            var deposits interface{} = this.SafeValue(response, "deposits", []interface{}{})
            var transactions interface{} = this.ParseTransactions(deposits, currency, since, limit)
        
            ch <- this.FilterByCurrencySinceLimit(transactions, code, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *poloniex) ParseTransactionStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "COMPLETE": "ok",
        "COMPLETED": "ok",
        "AWAITING APPROVAL": "pending",
        "AWAITING_APPROVAL": "pending",
        "PENDING": "pending",
        "PROCESSING": "pending",
        "COMPLETE ERROR": "failed",
        "COMPLETE_ERROR": "failed",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *poloniex) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // deposits
    //
    //     {
    //         "txid": "f49d489616911db44b740612d19464521179c76ebe9021af85b6de1e2f8d68cd",
    //         "amount": "49798.01987021",
    //         "status": "COMPLETE",
    //         "address": "DJVJZ58tJC8UeUv9Tqcdtn6uhWobouxFLT",
    //         "currency": "DOGE",
    //         "timestamp": 1524321838,
    //         "confirmations": 3371,
    //         "depositNumber": 134587098
    //     }
    //
    // withdrawals
    //
    //     {
    //         "withdrawalRequestsId": 7397527,
    //         "currency": "ETC",
    //         "address": "0x26419a62055af459d2cd69bb7392f5100b75e304",
    //         "amount": "13.19951600",
    //         "fee": "0.01000000",
    //         "timestamp": 1506010932,
    //         "status": "COMPLETED",
    //         "txid": "343346392f82ac16e8c2604f2a604b7b2382d0e9d8030f673821f8de4b5f5bk",
    //         "ipAddress": "1.2.3.4",
    //         "paymentID": null
    //     }
    //
    // withdraw
    //
    //     {
    //         "withdrawalRequestsId": 33485231
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var timestamp interface{} = this.SafeTimestamp(transaction, "timestamp")
    var currencyId interface{} = this.SafeString(transaction, "currency")
    var code interface{} = this.SafeCurrencyCode(currencyId)
    var status interface{} = this.SafeString(transaction, "status", "pending")
    status = this.ParseTransactionStatus(status)
    var txid interface{} = this.SafeString(transaction, "txid")
    var typeVar interface{} = Ternary(IsTrue((InOp(transaction, "withdrawalRequestsId"))), "withdrawal", "deposit")
    var id interface{} = this.SafeString2(transaction, "withdrawalRequestsId", "depositNumber")
    var address interface{} = this.SafeString(transaction, "address")
    var tag interface{} = this.SafeString(transaction, "paymentID")
    var amountString interface{} = this.SafeString(transaction, "amount")
    var feeCostString interface{} = this.SafeString(transaction, "fee")
    if IsTrue(IsEqual(typeVar, "withdrawal")) {
        amountString = Precise.StringSub(amountString, feeCostString)
    }
    return map[string]interface{} {
        "info": transaction,
        "id": id,
        "currency": code,
        "amount": this.ParseNumber(amountString),
        "network": nil,
        "address": address,
        "addressTo": nil,
        "addressFrom": nil,
        "tag": tag,
        "tagTo": nil,
        "tagFrom": nil,
        "status": status,
        "type": typeVar,
        "updated": nil,
        "txid": txid,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "comment": nil,
        "internal": nil,
        "fee": map[string]interface{} {
            "currency": code,
            "cost": this.ParseNumber(feeCostString),
            "rate": nil,
        },
    }
}
/**
 * @method
 * @name poloniex#setLeverage
 * @description set the level of leverage for a market
 * @see https://api-docs.poloniex.com/v3/futures/api/positions/set-leverage
 * @param {int} leverage the rate of leverage
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] 'cross' or 'isolated'
 * @returns {object} response from the exchange
 */
func  (this *poloniex) SetLeverage(leverage interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " setLeverage() requires a symbol argument")))
            }
        
            retRes32658 := (<-this.LoadMarkets())
            PanicOnError(retRes32658)
            var market interface{} = this.Market(symbol)
            var marginMode interface{} = nil
            marginModeparamsVariable := this.HandleMarginModeAndParams("setLeverage", params);
            marginMode = GetValue(marginModeparamsVariable,0);
            params = GetValue(marginModeparamsVariable,1)
            if IsTrue(IsEqual(marginMode, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " setLeverage() requires a marginMode parameter \"cross\" or \"isolated\"")))
            }
            var hedged interface{} = nil
            hedgedparamsVariable := this.HandleParamBool(params, "hedged", false);
            hedged = GetValue(hedgedparamsVariable,0);
            params = GetValue(hedgedparamsVariable,1)
            if IsTrue(hedged) {
                if !IsTrue((InOp(params, "posSide"))) {
                    panic(ArgumentsRequired(Add(this.Id, " setLeverage() requires a posSide parameter for hedged mode: \"LONG\" or \"SHORT\"")))
                }
            }
            var request interface{} = map[string]interface{} {
                "lever": leverage,
                "mgnMode": ToUpper(marginMode),
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.SwapPrivatePostV3PositionLeverage(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- response
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniex#fetchLeverage
 * @description fetch the set leverage for a market
 * @see https://api-docs.poloniex.com/v3/futures/api/positions/get-leverages
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [leverage structure]{@link https://docs.ccxt.com/#/?id=leverage-structure}
 */
func  (this *poloniex) FetchLeverage(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes32988 := (<-this.LoadMarkets())
            PanicOnError(retRes32988)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var marginMode interface{} = nil
            marginModeparamsVariable := this.HandleMarginModeAndParams("fetchLeverage", params);
            marginMode = GetValue(marginModeparamsVariable,0);
            params = GetValue(marginModeparamsVariable,1)
            if IsTrue(IsEqual(marginMode, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchLeverage() requires a marginMode parameter \"cross\" or \"isolated\"")))
            }
            AddElementToObject(request, "mgnMode", ToUpper(marginMode))
        
            response:= (<-this.SwapPrivateGetV3PositionLeverages(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //  for one-way mode:
            //
            //    {
            //        "code": "200",
            //        "msg": "",
            //        "data": [
            //            {
            //                "symbol": "BTC_USDT_PERP",
            //                "lever": "10",
            //                "mgnMode": "CROSS",
            //                "posSide": "BOTH"
            //            }
            //        ]
            //    }
            //
            //  for hedge:
            //
            //    {
            //        "code": "200",
            //        "msg": "",
            //        "data": [
            //            {
            //                "symbol": "BTC_USDT_PERP",
            //                "lever": "20",
            //                "mgnMode": "CROSS",
            //                "posSide": "SHORT"
            //            },
            //            {
            //                "symbol": "BTC_USDT_PERP",
            //                "lever": "20",
            //                "mgnMode": "CROSS",
            //                "posSide": "LONG"
            //            }
            //        ]
            //    }
            //
        ch <- this.ParseLeverage(response, market)
            return nil
        
            }()
            return ch
        }
func  (this *poloniex) ParseLeverage(leverage interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var shortLeverage interface{} = nil
    var longLeverage interface{} = nil
    var marketId interface{} = nil
    var marginMode interface{} = nil
    var data interface{} = this.SafeList(leverage, "data")
    for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
        var entry interface{} = GetValue(data, i)
        marketId = this.SafeString(entry, "symbol")
        marginMode = this.SafeString(entry, "mgnMode")
        var lever interface{} = this.SafeInteger(entry, "lever")
        var posSide interface{} = this.SafeString(entry, "posSide")
        if IsTrue(IsEqual(posSide, "LONG")) {
            longLeverage = lever
        } else if IsTrue(IsEqual(posSide, "SHORT")) {
            shortLeverage = lever
        } else {
            longLeverage = lever
            shortLeverage = lever
        }
    }
    return map[string]interface{} {
        "info": leverage,
        "symbol": this.SafeSymbol(marketId, market),
        "marginMode": marginMode,
        "longLeverage": longLeverage,
        "shortLeverage": shortLeverage,
    }
}
/**
 * @method
 * @name poloniex#fetchPositionMode
 * @description fetchs the position mode, hedged or one way, hedged for binance is set identically for all linear markets or all inverse markets
 * @see https://api-docs.poloniex.com/v3/futures/api/positions/position-mode-switch
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an object detailing whether the market is in hedged or one-way mode
 */
func  (this *poloniex) FetchPositionMode(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            response:= (<-this.SwapPrivateGetV3PositionMode(params))
            PanicOnError(response)
            //
            //    {
            //        "code": "200",
            //        "msg": "Success",
            //        "data": {
            //            "posMode": "ONE_WAY"
            //        }
            //    }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var posMode interface{} = this.SafeString(data, "posMode")
            var hedged interface{} = IsEqual(posMode, "HEDGE")
        
            ch <- map[string]interface{} {
                "info": response,
                "hedged": hedged,
            }
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniex#setPositionMode
 * @description set hedged to true or false for a market
 * @see https://api-docs.poloniex.com/v3/futures/api/positions/position-mode-switch
 * @param {bool} hedged set to true to use dualSidePosition
 * @param {string} symbol not used by binance setPositionMode ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} response from the exchange
 */
func  (this *poloniex) SetPositionMode(hedged interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var mode interface{} = Ternary(IsTrue(hedged), "HEDGE", "ONE_WAY")
            var request interface{} = map[string]interface{} {
                "posMode": mode,
            }
        
            response:= (<-this.SwapPrivatePostV3PositionMode(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //    {
            //        "code": "200",
            //        "msg": "Success",
            //        "data": {}
            //    }
            //
        ch <- response
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniex#fetchPositions
 * @description fetch all open positions
 * @see https://api-docs.poloniex.com/v3/futures/api/positions/get-current-position
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.standard] whether to fetch standard contract positions
 * @returns {object[]} a list of [position structures]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *poloniex) FetchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes34468 := (<-this.LoadMarkets())
            PanicOnError(retRes34468)
            symbols = this.MarketSymbols(symbols)
        
            response:= (<-this.SwapPrivateGetV3TradePositionOpens(params))
            PanicOnError(response)
            //
            //    {
            //        "code": "200",
            //        "msg": "",
            //        "data": [
            //            {
            //                "symbol": "BTC_USDT_PERP",
            //                "posSide": "LONG",
            //                "side": "BUY",
            //                "mgnMode": "CROSS",
            //                "openAvgPx": "94193.42",
            //                "qty": "1",
            //                "availQty": "1",
            //                "lever": "20",
            //                "adl": "0.3007",
            //                "liqPx": "84918.201844064386317906",
            //                "im": "4.7047795",
            //                "mm": "0.56457354",
            //                "upl": "-0.09783",
            //                "uplRatio": "-0.0207",
            //                "pnl": "0",
            //                "markPx": "94095.59",
            //                "mgnRatio": "0.0582",
            //                "state": "NORMAL",
            //                "cTime": "1740950344401",
            //                "uTime": "1740950344401",
            //                "mgn": "4.7047795",
            //                "actType": "TRADING",
            //                "maxWAmt": "0",
            //                "tpTrgPx": "",
            //                "slTrgPx": ""
            //            }
            //        ]
            //    }
            //
            var positions interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParsePositions(positions, symbols)
            return nil
        
            }()
            return ch
        }
func  (this *poloniex) ParsePosition(position interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //            {
    //                "symbol": "BTC_USDT_PERP",
    //                "posSide": "LONG",
    //                "side": "BUY",
    //                "mgnMode": "CROSS",
    //                "openAvgPx": "94193.42",
    //                "qty": "1",
    //                "availQty": "1",
    //                "lever": "20",
    //                "adl": "0.3007",
    //                "liqPx": "84918.201844064386317906",
    //                "im": "4.7047795",
    //                "mm": "0.56457354",
    //                "upl": "-0.09783",
    //                "uplRatio": "-0.0207",
    //                "pnl": "0",
    //                "markPx": "94095.59",
    //                "mgnRatio": "0.0582",
    //                "state": "NORMAL",
    //                "cTime": "1740950344401",
    //                "uTime": "1740950344401",
    //                "mgn": "4.7047795",
    //                "actType": "TRADING",
    //                "maxWAmt": "0",
    //                "tpTrgPx": "",
    //                "slTrgPx": ""
    //            }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(position, "symbol")
    market = this.SafeMarket(marketId, market)
    var timestamp interface{} = this.SafeInteger(position, "cTime")
    var marginMode interface{} = this.SafeStringLower(position, "mgnMode")
    var leverage interface{} = this.SafeString(position, "lever")
    var initialMargin interface{} = this.SafeString(position, "im")
    var notional interface{} = Precise.StringMul(leverage, initialMargin)
    var qty interface{} = this.SafeString(position, "qty")
    var avgPrice interface{} = this.SafeString(position, "openAvgPx")
    var collateral interface{} = Precise.StringMul(qty, avgPrice)
    // todo: some more fields
    return this.SafePosition(map[string]interface{} {
        "info": position,
        "id": nil,
        "symbol": GetValue(market, "symbol"),
        "notional": notional,
        "marginMode": marginMode,
        "liquidationPrice": this.SafeNumber(position, "liqPx"),
        "entryPrice": this.SafeNumber(position, "openAvgPx"),
        "unrealizedPnl": this.SafeNumber(position, "upl"),
        "percentage": nil,
        "contracts": this.SafeNumber(position, "qty"),
        "contractSize": nil,
        "markPrice": this.SafeNumber(position, "markPx"),
        "lastPrice": nil,
        "side": this.SafeStringLower(position, "posSide"),
        "hedged": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastUpdateTimestamp": nil,
        "maintenanceMargin": this.SafeNumber(position, "mm"),
        "maintenanceMarginPercentage": nil,
        "collateral": collateral,
        "initialMargin": initialMargin,
        "initialMarginPercentage": nil,
        "leverage": ParseInt(leverage),
        "marginRatio": this.SafeNumber(position, "mgnRatio"),
        "stopLossPrice": this.SafeNumber(position, "slTrgPx"),
        "takeProfitPrice": this.SafeNumber(position, "tpTrgPx"),
    })
}
func  (this *poloniex) ModifyMarginHelper(symbol interface{}, amount interface{}, typeVar interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes35618 := (<-this.LoadMarkets())
            PanicOnError(retRes35618)
            var market interface{} = this.Market(symbol)
            amount = this.AmountToPrecision(symbol, amount)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "amt": Precise.StringAbs(amount),
                "type": ToUpper(typeVar),
            }
            // todo: hedged handling, tricky
            if !IsTrue((InOp(params, "posMode"))) {
                AddElementToObject(request, "posMode", "BOTH")
            }
        
            response:= (<-this.SwapPrivatePostV3TradePositionMargin(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "code": 200,
            //     "data": {
            //       "amt": "50",
            //       "lever": "20",
            //       "symbol": "DOT_USDT_PERP",
            //       "posSide": "BOTH",
            //       "type": "ADD"
            //     },
            //     "msg": "Success"
            // }
            //
            if IsTrue(IsEqual(typeVar, "reduce")) {
                amount = Precise.StringAbs(amount)
            }
            var data interface{} = this.SafeDict(response, "data")
        
            ch <- this.ParseMarginModification(data, market)
            return nil
        
            }()
            return ch
        }
func  (this *poloniex) ParseMarginModification(data interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(data, "symbol")
    market = this.SafeMarket(marketId, market)
    var rawType interface{} = this.SafeString(data, "type")
    var typeVar interface{} = Ternary(IsTrue((IsEqual(rawType, "ADD"))), "add", "reduce")
    return map[string]interface{} {
        "info": data,
        "symbol": GetValue(market, "symbol"),
        "type": typeVar,
        "marginMode": nil,
        "amount": this.SafeNumber(data, "amt"),
        "total": nil,
        "code": nil,
        "status": "ok",
        "timestamp": nil,
        "datetime": nil,
    }
}
/**
 * @method
 * @name poloniex#reduceMargin
 * @description remove margin from a position
 * @param {string} symbol unified market symbol
 * @param {float} amount the amount of margin to remove
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=reduce-margin-structure}
 */
func  (this *poloniex) ReduceMargin(symbol interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes362315 :=  (<-this.ModifyMarginHelper(symbol, OpNeg(amount), "reduce", params))
                PanicOnError(retRes362315)
                ch <- retRes362315
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniex#addMargin
 * @description add margin
 * @param {string} symbol unified market symbol
 * @param {float} amount amount of margin to add
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=add-margin-structure}
 */
func  (this *poloniex) AddMargin(symbol interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes363615 :=  (<-this.ModifyMarginHelper(symbol, amount, "add", params))
                PanicOnError(retRes363615)
                ch <- retRes363615
                return nil
        
            }()
            return ch
        }
func  (this *poloniex) Nonce() interface{}  {
    return this.Milliseconds()
}
func  (this *poloniex) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var url interface{} = GetValue(GetValue(this.Urls, "api"), "spot")
    if IsTrue(this.InArray(api, []interface{}{"swapPublic", "swapPrivate"})) {
        url = GetValue(GetValue(this.Urls, "api"), "swap")
    }
    var query interface{} = this.Omit(params, this.ExtractParams(path))
    var implodedPath interface{} = this.ImplodeParams(path, params)
    if IsTrue(IsTrue(IsEqual(api, "public")) || IsTrue(IsEqual(api, "swapPublic"))) {
        url = Add(url, Add("/", implodedPath))
        if IsTrue(GetArrayLength(ObjectKeys(query))) {
            url = Add(url, Add("?", this.Urlencode(query)))
        }
    } else {
        this.CheckRequiredCredentials()
        var timestamp interface{} = ToString(this.Nonce())
        var auth interface{} = Add(method, "\n") // eslint-disable-line quotes
        url = Add(url, Add("/", implodedPath))
        auth = Add(auth, Add("/", implodedPath))
        if IsTrue(IsTrue(IsTrue((IsEqual(method, "POST"))) || IsTrue((IsEqual(method, "PUT")))) || IsTrue((IsEqual(method, "DELETE")))) {
            auth = Add(auth, "\n") // eslint-disable-line quotes
            if IsTrue(GetArrayLength(ObjectKeys(query))) {
                body = this.Json(query)
                auth = Add(auth, Add(Add("requestBody=", body), "&"))
            }
            auth = Add(auth, Add("signTimestamp=", timestamp))
        } else {
            var sortedQuery interface{} = this.Extend(map[string]interface{} {
                "signTimestamp": timestamp,
            }, query)
            sortedQuery = this.Keysort(sortedQuery)
            auth = Add(auth, Add("\n", this.Urlencode(sortedQuery))) // eslint-disable-line quotes
            if IsTrue(GetArrayLength(ObjectKeys(query))) {
                url = Add(url, Add("?", this.Urlencode(query)))
            }
        }
        var signature interface{} = this.Hmac(this.Encode(auth), this.Encode(this.Secret), sha256, "base64")
        headers = map[string]interface{} {
            "Content-Type": "application/json",
            "key": this.ApiKey,
            "signTimestamp": timestamp,
            "signature": signature,
        }
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *poloniex) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsEqual(response, nil)) {
        return nil
    }
    //
    //     {
    //         "code" : 21709,
    //         "message" : "Low available balance"
    //     }
    //
    var responseCode interface{} = this.SafeString(response, "code")
    if IsTrue(IsTrue((!IsEqual(responseCode, nil))) && IsTrue((!IsEqual(responseCode, "200")))) {
        var codeInner interface{} = GetValue(response, "code")
        var message interface{} = this.SafeString(response, "message")
        var feedback interface{} = Add(Add(this.Id, " "), body)
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), codeInner, feedback)
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), message, feedback)
        panic(ExchangeError(feedback))
    }
    return nil
}


func (this *poloniex) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.DerivedExchange = this
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
}
