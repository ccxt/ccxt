package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type bitso struct {
    Exchange

}

func NewBitsoCore() bitso {
   p := bitso{}
   setDefaults(&p)
   return p
}

func  (this *bitso) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "bitso",
        "name": "Bitso",
        "countries": []interface{}{"MX"},
        "rateLimit": 2000,
        "version": "v3",
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": false,
            "swap": false,
            "future": false,
            "option": false,
            "addMargin": false,
            "cancelAllOrders": true,
            "cancelOrder": true,
            "cancelOrders": true,
            "closeAllPositions": false,
            "closePosition": false,
            "createDepositAddress": false,
            "createOrder": true,
            "createReduceOnlyOrder": false,
            "fetchAccounts": false,
            "fetchBalance": true,
            "fetchBorrowRateHistories": false,
            "fetchBorrowRateHistory": false,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchDeposit": true,
            "fetchDepositAddress": true,
            "fetchDepositAddresses": false,
            "fetchDepositAddressesByNetwork": false,
            "fetchDeposits": true,
            "fetchDepositsWithdrawals": false,
            "fetchDepositWithdrawFee": "emulated",
            "fetchDepositWithdrawFees": true,
            "fetchFundingHistory": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchIndexOHLCV": false,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchLedger": true,
            "fetchLeverage": false,
            "fetchMarginMode": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrderTrades": true,
            "fetchPosition": false,
            "fetchPositionHistory": false,
            "fetchPositionMode": false,
            "fetchPositions": false,
            "fetchPositionsForSymbol": false,
            "fetchPositionsHistory": false,
            "fetchPositionsRisk": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchTicker": true,
            "fetchTickers": false,
            "fetchTime": false,
            "fetchTrades": true,
            "fetchTradingFee": false,
            "fetchTradingFees": true,
            "fetchTransactionFee": false,
            "fetchTransactionFees": true,
            "fetchTransactions": false,
            "fetchTransfer": false,
            "fetchTransfers": false,
            "reduceMargin": false,
            "setLeverage": false,
            "setMarginMode": false,
            "setPositionMode": false,
            "transfer": false,
            "withdraw": true,
        },
        "urls": map[string]interface{} {
            "logo": "https://github.com/user-attachments/assets/178c8e56-9054-4107-b192-5e5053d4f975",
            "api": map[string]interface{} {
                "rest": "https://bitso.com/api",
            },
            "test": map[string]interface{} {
                "rest": "https://stage.bitso.com/api",
            },
            "www": "https://bitso.com",
            "doc": "https://bitso.com/api_info",
            "fees": "https://bitso.com/fees",
            "referral": "https://bitso.com/?ref=itej",
        },
        "precisionMode": TICK_SIZE,
        "options": map[string]interface{} {
            "precision": map[string]interface{} {
                "XRP": 0.000001,
                "MXN": 0.01,
                "TUSD": 0.01,
            },
            "defaultPrecision": 1e-8,
            "networks": map[string]interface{} {
                "TRC20": "trx",
                "ERC20": "erc20",
                "BEP20": "bsc",
                "BEP2": "bep2",
            },
        },
        "timeframes": map[string]interface{} {
            "1m": "60",
            "5m": "300",
            "15m": "900",
            "30m": "1800",
            "1h": "3600",
            "4h": "14400",
            "12h": "43200",
            "1d": "86400",
            "1w": "604800",
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": []interface{}{"available_books", "ticker", "order_book", "trades", "ohlc"},
            },
            "private": map[string]interface{} {
                "get": []interface{}{"account_status", "balance", "fees", "fundings", "fundings/{fid}", "funding_destination", "kyc_documents", "ledger", "ledger/trades", "ledger/fees", "ledger/fundings", "ledger/withdrawals", "mx_bank_codes", "open_orders", "order_trades/{oid}", "orders/{oid}", "user_trades", "user_trades/{tid}", "withdrawals/", "withdrawals/{wid}"},
                "post": []interface{}{"bitcoin_withdrawal", "debit_card_withdrawal", "ether_withdrawal", "orders", "phone_number", "phone_verification", "phone_withdrawal", "spei_withdrawal", "ripple_withdrawal", "bcash_withdrawal", "litecoin_withdrawal"},
                "delete": []interface{}{"orders", "orders/{oid}", "orders/all"},
            },
        },
        "features": map[string]interface{} {
            "spot": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": true,
                    "triggerPriceType": nil,
                    "triggerDirection": nil,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": true,
                        "FOK": true,
                        "PO": true,
                        "GTD": false,
                    },
                    "hedged": false,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyRequiresPrice": false,
                    "marketBuyByCost": false,
                    "selfTradePrevention": false,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": nil,
                    "untilDays": nil,
                    "symbolRequired": true,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 500,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchOrders": nil,
                "fetchClosedOrders": nil,
                "fetchOHLCV": map[string]interface{} {
                    "limit": 300,
                },
            },
            "swap": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "exceptions": map[string]interface{} {
            "0201": AuthenticationError,
            "104": InvalidNonce,
            "0304": BadRequest,
        },
    })
}
/**
 * @method
 * @name bitso#fetchLedger
 * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
 * @param {string} [code] unified currency code, default is undefined
 * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
 * @param {int} [limit] max number of ledger entries to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger}
 */
func  (this *bitso) FetchLedger(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.PrivateGetLedger(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "payload": [{
            //             "eid": "2510b3e2bc1c87f584500a18084f35ed",
            //             "created_at": "2022-06-08T12:21:42+0000",
            //             "balance_updates": [{
            //                 "amount": "0.00080000",
            //                 "currency": "btc"
            //             }],
            //             "operation": "funding",
            //             "details": {
            //                 "network": "btc",
            //                 "method": "btc",
            //                 "method_name": "Bitcoin",
            //                 "asset": "btc",
            //                 "protocol": "btc",
            //                 "integration": "bitgo-v2",
            //                 "fid": "6112c6369100d6ecceb7f54f17cf0511"
            //             }
            //         }]
            //     }
            //
            var payload interface{} = this.SafeValue(response, "payload", []interface{}{})
            var currency interface{} = this.SafeCurrency(code)
        
            ch <- this.ParseLedger(payload, currency, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *bitso) ParseLedgerEntryType(typeVar interface{}) interface{}  {
    var types interface{} = map[string]interface{} {
        "funding": "transaction",
        "withdrawal": "transaction",
        "trade": "trade",
        "fee": "fee",
    }
    return this.SafeString(types, typeVar, typeVar)
}
func  (this *bitso) ParseLedgerEntry(item interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "eid": "2510b3e2bc1c87f584500a18084f35ed",
    //         "created_at": "2022-06-08T12:21:42+0000",
    //         "balance_updates": [{
    //             "amount": "0.00080000",
    //             "currency": "btc"
    //         }],
    //         "operation": "funding",
    //         "details": {
    //             "network": "btc",
    //             "method": "btc",
    //             "method_name": "Bitcoin",
    //             "asset": "btc",
    //             "protocol": "btc",
    //             "integration": "bitgo-v2",
    //             "fid": "6112c6369100d6ecceb7f54f17cf0511"
    //         }
    //     }
    //
    //  trade
    //     {
    //         "eid": "8976c6053f078f704f037d82a813678a",
    //         "created_at": "2022-06-08T17:01:48+0000",
    //         "balance_updates": [{
    //                 "amount": "59.21320500",
    //                 "currency": "mxn"
    //             },
    //             {
    //                 "amount": "-0.00010000",
    //                 "currency": "btc"
    //             }
    //         ],
    //         "operation": "trade",
    //         "details": {
    //             "tid": "72145428",
    //             "oid": "JO5TZmMZjzjlZDyT"
    //         }
    //     }
    //
    //  fee
    //     {
    //         "eid": "cbbb3c8d4e41723d25d2850dcb7c3c74",
    //         "created_at": "2022-06-08T17:01:48+0000",
    //         "balance_updates": [{
    //             "amount": "-0.38488583",
    //             "currency": "mxn"
    //         }],
    //         "operation": "fee",
    //         "details": {
    //             "tid": "72145428",
    //             "oid": "JO5TZmMZjzjlZDyT"
    //         }
    //     }
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var operation interface{} = this.SafeString(item, "operation")
    var typeVar interface{} = this.ParseLedgerEntryType(operation)
    var balanceUpdates interface{} = this.SafeValue(item, "balance_updates", []interface{}{})
    var firstBalance interface{} = this.SafeValue(balanceUpdates, 0, map[string]interface{} {})
    var direction interface{} = nil
    var fee interface{} = nil
    var amount interface{} = this.SafeString(firstBalance, "amount")
    var currencyId interface{} = this.SafeString(firstBalance, "currency")
    var code interface{} = this.SafeCurrencyCode(currencyId, currency)
    currency = this.SafeCurrency(currencyId, currency)
    var details interface{} = this.SafeValue(item, "details", map[string]interface{} {})
    var referenceId interface{} = this.SafeString2(details, "fid", "wid")
    if IsTrue(IsEqual(referenceId, nil)) {
        referenceId = this.SafeString(details, "tid")
    }
    if IsTrue(IsEqual(operation, "funding")) {
        direction = "in"
    } else if IsTrue(IsEqual(operation, "withdrawal")) {
        direction = "out"
    } else if IsTrue(IsEqual(operation, "trade")) {
        direction = nil
    } else if IsTrue(IsEqual(operation, "fee")) {
        direction = "out"
        var cost interface{} = Precise.StringAbs(amount)
        fee = map[string]interface{} {
            "cost": cost,
            "currency": currency,
        }
    }
    var timestamp interface{} = this.Parse8601(this.SafeString(item, "created_at"))
    return this.SafeLedgerEntry(map[string]interface{} {
        "info": item,
        "id": this.SafeString(item, "eid"),
        "direction": direction,
        "account": nil,
        "referenceId": referenceId,
        "referenceAccount": nil,
        "type": typeVar,
        "currency": code,
        "amount": amount,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "before": nil,
        "after": nil,
        "status": "ok",
        "fee": fee,
    }, currency)
}
/**
 * @method
 * @name bitso#fetchMarkets
 * @description retrieves data on all markets for bitso
 * @see https://docs.bitso.com/bitso-api/docs/list-available-books
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *bitso) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetAvailableBooks(params))
            PanicOnError(response)
            //
            //     {
            //         "success":true,
            //         "payload":[
            //             {
            //                 "book":"btc_mxn",
            //                 "minimum_price":"500",
            //                 "maximum_price":"10000000",
            //                 "minimum_amount":"0.00005",
            //                 "maximum_amount":"500",
            //                 "minimum_value":"5",
            //                 "maximum_value":"10000000",
            //                 "tick_size":"0.01",
            //                 "fees":{
            //                     "flat_rate":{"maker":"0.500","taker":"0.650"},
            //                     "structure":[
            //                         {"volume":"1500000","maker":"0.00500","taker":"0.00650"},
            //                         {"volume":"2000000","maker":"0.00490","taker":"0.00637"},
            //                         {"volume":"5000000","maker":"0.00480","taker":"0.00624"},
            //                         {"volume":"7000000","maker":"0.00440","taker":"0.00572"},
            //                         {"volume":"10000000","maker":"0.00420","taker":"0.00546"},
            //                         {"volume":"15000000","maker":"0.00400","taker":"0.00520"},
            //                         {"volume":"35000000","maker":"0.00370","taker":"0.00481"},
            //                         {"volume":"50000000","maker":"0.00300","taker":"0.00390"},
            //                         {"volume":"150000000","maker":"0.00200","taker":"0.00260"},
            //                         {"volume":"250000000","maker":"0.00100","taker":"0.00130"},
            //                         {"volume":"9999999999","maker":"0.00000","taker":"0.00130"},
            //                     ]
            //                 }
            //             },
            //         ]
            //     }
            var markets interface{} = this.SafeValue(response, "payload", []interface{}{})
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(markets)); i++ {
                var market interface{} = GetValue(markets, i)
                var id interface{} = this.SafeString(market, "book")
                baseIdquoteIdVariable := Split(id, "_");
                baseId := GetValue(baseIdquoteIdVariable,0);
                quoteId := GetValue(baseIdquoteIdVariable,1)
                var base interface{} = ToUpper(baseId)
                var quote interface{} = ToUpper(quoteId)
                base = this.SafeCurrencyCode(base)
                quote = this.SafeCurrencyCode(quote)
                var fees interface{} = this.SafeValue(market, "fees", map[string]interface{} {})
                var flatRate interface{} = this.SafeValue(fees, "flat_rate", map[string]interface{} {})
                var takerString interface{} = this.SafeString(flatRate, "taker")
                var makerString interface{} = this.SafeString(flatRate, "maker")
                var taker interface{} = this.ParseNumber(Precise.StringDiv(takerString, "100"))
                var maker interface{} = this.ParseNumber(Precise.StringDiv(makerString, "100"))
                var feeTiers interface{} = this.SafeValue(fees, "structure", []interface{}{})
                var fee interface{} = map[string]interface{} {
                    "taker": taker,
                    "maker": maker,
                    "percentage": true,
                    "tierBased": true,
                }
                var takerFees interface{} = []interface{}{}
                var makerFees interface{} = []interface{}{}
                for j := 0; IsLessThan(j, GetArrayLength(feeTiers)); j++ {
                    var tier interface{} = GetValue(feeTiers, j)
                    var volume interface{} = this.SafeNumber(tier, "volume")
                    var takerFee interface{} = this.SafeNumber(tier, "taker")
                    var makerFee interface{} = this.SafeNumber(tier, "maker")
                    AppendToArray(&takerFees,[]interface{}{volume, takerFee})
                    AppendToArray(&makerFees,[]interface{}{volume, makerFee})
                    if IsTrue(IsEqual(j, 0)) {
                        AddElementToObject(fee, "taker", takerFee)
                        AddElementToObject(fee, "maker", makerFee)
                    }
                }
                var tiers interface{} = map[string]interface{} {
                    "taker": takerFees,
                    "maker": makerFees,
                }
                AddElementToObject(fee, "tiers", tiers)
                // TODO: precisions can be also set from https://bitso.com/api/v3/catalogues ->available_currency_conversions->currencies (or ->currencies->metadata)  or https://bitso.com/api/v3/get_exchange_rates/mxn
                var defaultPricePrecision interface{} = this.SafeNumber(GetValue(this.Options, "precision"), quote, GetValue(this.Options, "defaultPrecision"))
                AppendToArray(&result,this.Extend(map[string]interface{} {
                    "id": id,
                    "symbol": Add(Add(base, "/"), quote),
                    "base": base,
                    "quote": quote,
                    "settle": nil,
                    "baseId": baseId,
                    "quoteId": quoteId,
                    "settleId": nil,
                    "type": "spot",
                    "spot": true,
                    "margin": false,
                    "swap": false,
                    "future": false,
                    "option": false,
                    "active": nil,
                    "contract": false,
                    "linear": nil,
                    "inverse": nil,
                    "taker": taker,
                    "maker": maker,
                    "contractSize": nil,
                    "expiry": nil,
                    "expiryDatetime": nil,
                    "strike": nil,
                    "optionType": nil,
                    "precision": map[string]interface{} {
                        "amount": this.SafeNumber(GetValue(this.Options, "precision"), base, GetValue(this.Options, "defaultPrecision")),
                        "price": this.SafeNumber(market, "tick_size", defaultPricePrecision),
                    },
                    "limits": map[string]interface{} {
                        "leverage": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "amount": map[string]interface{} {
                            "min": this.SafeNumber(market, "minimum_amount"),
                            "max": this.SafeNumber(market, "maximum_amount"),
                        },
                        "price": map[string]interface{} {
                            "min": this.SafeNumber(market, "minimum_price"),
                            "max": this.SafeNumber(market, "maximum_price"),
                        },
                        "cost": map[string]interface{} {
                            "min": this.SafeNumber(market, "minimum_value"),
                            "max": this.SafeNumber(market, "maximum_value"),
                        },
                    },
                    "created": nil,
                    "info": market,
                }, fee))
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *bitso) ParseBalance(response interface{}) interface{}  {
    var payload interface{} = this.SafeValue(response, "payload", map[string]interface{} {})
    var balances interface{} = this.SafeValue(payload, "balances", []interface{}{})
    var result interface{} = map[string]interface{} {
        "info": response,
        "timestamp": nil,
        "datetime": nil,
    }
    for i := 0; IsLessThan(i, GetArrayLength(balances)); i++ {
        var balance interface{} = GetValue(balances, i)
        var currencyId interface{} = this.SafeString(balance, "currency")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        AddElementToObject(account, "free", this.SafeString(balance, "available"))
        AddElementToObject(account, "used", this.SafeString(balance, "locked"))
        AddElementToObject(account, "total", this.SafeString(balance, "total"))
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name bitso#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://docs.bitso.com/bitso-api/docs/get-account-balance
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *bitso) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes5908 := (<-this.LoadMarkets())
            PanicOnError(retRes5908)
        
            response:= (<-this.PrivateGetBalance(params))
            PanicOnError(response)
        
                //
            //     {
            //       "success": true,
            //       "payload": {
            //         "balances": [
            //           {
            //             "currency": "bat",
            //             "available": "0.00000000",
            //             "locked": "0.00000000",
            //             "total": "0.00000000",
            //             "pending_deposit": "0.00000000",
            //             "pending_withdrawal": "0.00000000"
            //           },
            //           {
            //             "currency": "bch",
            //             "available": "0.00000000",
            //             "locked": "0.00000000",
            //             "total": "0.00000000",
            //             "pending_deposit": "0.00000000",
            //             "pending_withdrawal": "0.00000000"
            //           },
            //         ],
            //       },
            //     }
            //
        ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitso#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://docs.bitso.com/bitso-api/docs/list-order-book
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *bitso) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes6318 := (<-this.LoadMarkets())
            PanicOnError(retRes6318)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "book": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetOrderBook(this.Extend(request, params)))
            PanicOnError(response)
            var orderbook interface{} = this.SafeValue(response, "payload")
            var timestamp interface{} = this.Parse8601(this.SafeString(orderbook, "updated_at"))
        
            ch <- this.ParseOrderBook(orderbook, GetValue(market, "symbol"), timestamp, "bids", "asks", "price", "amount")
            return nil
        
            }()
            return ch
        }
func  (this *bitso) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "high":"37446.85",
    //         "last":"36599.54",
    //         "created_at":"2022-01-28T12:06:11+00:00",
    //         "book":"btc_usdt",
    //         "volume":"7.29075419",
    //         "vwap":"36579.1564400307",
    //         "low":"35578.52",
    //         "ask":"36574.76",
    //         "bid":"36538.22",
    //         "change_24":"-105.64"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var symbol interface{} = this.SafeSymbol(nil, market)
    var timestamp interface{} = this.Parse8601(this.SafeString(ticker, "created_at"))
    var vwap interface{} = this.SafeString(ticker, "vwap")
    var baseVolume interface{} = this.SafeString(ticker, "volume")
    var quoteVolume interface{} = Precise.StringMul(baseVolume, vwap)
    var last interface{} = this.SafeString(ticker, "last")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeString(ticker, "high"),
        "low": this.SafeString(ticker, "low"),
        "bid": this.SafeString(ticker, "bid"),
        "bidVolume": nil,
        "ask": this.SafeString(ticker, "ask"),
        "askVolume": nil,
        "vwap": vwap,
        "open": nil,
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": nil,
        "percentage": nil,
        "average": nil,
        "baseVolume": baseVolume,
        "quoteVolume": quoteVolume,
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name bitso#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://docs.bitso.com/bitso-api/docs/ticker
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *bitso) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes6978 := (<-this.LoadMarkets())
            PanicOnError(retRes6978)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "book": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetTicker(this.Extend(request, params)))
            PanicOnError(response)
            var ticker interface{} = this.SafeValue(response, "payload")
        
                //
            //     {
            //         "success":true,
            //         "payload":{
            //             "high":"37446.85",
            //             "last":"37051.96",
            //             "created_at":"2022-01-28T17:03:29+00:00",
            //             "book":"btc_usdt",
            //             "volume":"6.16176186",
            //             "vwap":"36582.6293169472",
            //             "low":"35578.52",
            //             "ask":"37083.62",
            //             "bid":"37039.66",
            //             "change_24":"478.45"
            //         }
            //     }
            //
        ch <- this.ParseTicker(ticker, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitso#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *bitso) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes7368 := (<-this.LoadMarkets())
            PanicOnError(retRes7368)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "book": GetValue(market, "id"),
                "time_bucket": this.SafeString(this.Timeframes, timeframe, timeframe),
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start", since)
                if IsTrue(!IsEqual(limit, nil)) {
                    var duration interface{} = this.ParseTimeframe(timeframe)
                    AddElementToObject(request, "end", this.Sum(since, Multiply(Multiply(duration, limit), 1000)))
                }
            } else if IsTrue(!IsEqual(limit, nil)) {
                var now interface{} = this.Milliseconds()
                AddElementToObject(request, "end", now)
                AddElementToObject(request, "start", Subtract(now, Multiply(Multiply(this.ParseTimeframe(timeframe), 1000), limit)))
            }
        
            response:= (<-this.PublicGetOhlc(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "success":true,
            //         "payload": [
            //             {
            //                 "bucket_start_time":1648219140000,
            //                 "first_trade_time":1648219154990,
            //                 "last_trade_time":1648219189441,
            //                 "first_rate":"44958.60",
            //                 "last_rate":"44979.88",
            //                 "min_rate":"44957.33",
            //                 "max_rate":"44979.88",
            //                 "trade_count":8,
            //                 "volume":"0.00082814",
            //                 "vwap":"44965.02"
            //             },
            //         ]
            //     }
            //
            var payload interface{} = this.SafeList(response, "payload", []interface{}{})
        
            ch <- this.ParseOHLCVs(payload, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *bitso) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "bucket_start_time":1648219140000,
    //         "first_trade_time":1648219154990,
    //         "last_trade_time":1648219189441,
    //         "first_rate":"44958.60",
    //         "last_rate":"44979.88",
    //         "min_rate":"44957.33",
    //         "max_rate":"44979.88",
    //         "trade_count":8,
    //         "volume":"0.00082814",
    //         "vwap":"44965.02"
    //     },
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.SafeInteger(ohlcv, "bucket_start_time"), this.SafeNumber(ohlcv, "first_rate"), this.SafeNumber(ohlcv, "max_rate"), this.SafeNumber(ohlcv, "min_rate"), this.SafeNumber(ohlcv, "last_rate"), this.SafeNumber(ohlcv, "volume")}
}
func  (this *bitso) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTrades (public)
    //
    //      {
    //          "book": "btc_usdt",
    //          "created_at": "2021-11-24T12:14:53+0000",
    //          "amount": "0.00026562",
    //          "maker_side": "sell",
    //          "price": "56471.55",
    //          "tid": "52557338"
    //      }
    //
    // fetchMyTrades (private)
    //
    //      {
    //          "book": "btc_usdt",
    //          "created_at": "2021-11-24T12:31:03+0000",
    //          "minor": "11.30356000",
    //          "major": "-0.00020000",
    //          "fees_amount": "0.01119052",
    //          "fees_currency": "usdt",
    //          "minor_currency": "usdt",
    //          "major_currency": "btc",
    //          "oid": "djTzMIWx2Vi3iMjl",
    //          "tid": "52559051",
    //          "price": "56517.80",
    //          "side": "sell",
    //          "maker_side": "buy"
    //      }
    //
    // fetchOrderTrades (private)
    //
    //      {
    //          "book": "btc_usdt",
    //          "created_at": "2021-11-24T12:30:52+0000",
    //          "minor": "-11.33047916",
    //          "major": "0.00020020",
    //          "fees_amount": "0.00000020",
    //          "fees_currency": "btc",
    //          "minor_currency": "usdt",
    //          "major_currency": "btc",
    //          "oid": "O0D2zcljjjQF5xlG",
    //          "tid": "52559030",
    //          "price": "56595.80",
    //          "side": "buy",
    //          "maker_side": "sell"
    //      }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.Parse8601(this.SafeString(trade, "created_at"))
    var marketId interface{} = this.SafeString(trade, "book")
    var symbol interface{} = this.SafeSymbol(marketId, market, "_")
    var side interface{} = this.SafeString(trade, "side")
    var makerSide interface{} = this.SafeString(trade, "maker_side")
    var takerOrMaker interface{} = nil
    if IsTrue(!IsEqual(side, nil)) {
        if IsTrue(IsEqual(side, makerSide)) {
            takerOrMaker = "maker"
        } else {
            takerOrMaker = "taker"
        }
    } else {
        if IsTrue(IsEqual(makerSide, "buy")) {
            side = "sell"
        } else {
            side = "buy"
        }
    }
    var amount interface{} = this.SafeString2(trade, "amount", "major")
    if IsTrue(!IsEqual(amount, nil)) {
        amount = Precise.StringAbs(amount)
    }
    var fee interface{} = nil
    var feeCost interface{} = this.SafeString(trade, "fees_amount")
    if IsTrue(!IsEqual(feeCost, nil)) {
        var feeCurrencyId interface{} = this.SafeString(trade, "fees_currency")
        var feeCurrency interface{} = this.SafeCurrencyCode(feeCurrencyId)
        fee = map[string]interface{} {
            "cost": feeCost,
            "currency": feeCurrency,
        }
    }
    var cost interface{} = this.SafeString(trade, "minor")
    if IsTrue(!IsEqual(cost, nil)) {
        cost = Precise.StringAbs(cost)
    }
    var price interface{} = this.SafeString(trade, "price")
    var orderId interface{} = this.SafeString(trade, "oid")
    var id interface{} = this.SafeString(trade, "tid")
    return this.SafeTrade(map[string]interface{} {
        "id": id,
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "order": orderId,
        "type": nil,
        "side": side,
        "takerOrMaker": takerOrMaker,
        "price": price,
        "amount": amount,
        "cost": cost,
        "fee": fee,
    }, market)
}
/**
 * @method
 * @name bitso#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://docs.bitso.com/bitso-api/docs/list-trades
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *bitso) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes9208 := (<-this.LoadMarkets())
            PanicOnError(retRes9208)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "book": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetTrades(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseTrades(GetValue(response, "payload"), market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitso#fetchTradingFees
 * @description fetch the trading fees for multiple markets
 * @see https://docs.bitso.com/bitso-api/docs/list-fees
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
 */
func  (this *bitso) FetchTradingFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes9388 := (<-this.LoadMarkets())
            PanicOnError(retRes9388)
        
            response:= (<-this.PrivateGetFees(params))
            PanicOnError(response)
            //
            //    {
            //        "success": true,
            //        "payload": {
            //            "fees": [
            //                {
            //                    "book": "btc_mxn",
            //                    "fee_percent": "0.6500",
            //                    "fee_decimal": "0.00650000",
            //                    "taker_fee_percent": "0.6500",
            //                    "taker_fee_decimal": "0.00650000",
            //                    "maker_fee_percent": "0.5000",
            //                    "maker_fee_decimal": "0.00500000",
            //                    "volume_currency": "mxn",
            //                    "current_volume": "0.00",
            //                    "next_volume": "1500000.00",
            //                    "next_maker_fee_percent": "0.490",
            //                    "next_taker_fee_percent": "0.637",
            //                    "nextVolume": "1500000.00",
            //                    "nextFee": "0.490",
            //                    "nextTakerFee": "0.637"
            //                },
            //                ...
            //            ],
            //            "deposit_fees": [
            //                {
            //                    "currency": "btc",
            //                    "method": "rewards",
            //                    "fee": "0.00",
            //                    "is_fixed": false
            //                },
            //                ...
            //            ],
            //            "withdrawal_fees": {
            //                "ada": "0.20958100",
            //                "bch": "0.00009437",
            //                "ars": "0",
            //                "btc": "0.00001209",
            //                ...
            //            }
            //        }
            //    }
            //
            var payload interface{} = this.SafeValue(response, "payload", map[string]interface{} {})
            var fees interface{} = this.SafeValue(payload, "fees", []interface{}{})
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(fees)); i++ {
                var fee interface{} = GetValue(fees, i)
                var marketId interface{} = this.SafeString(fee, "book")
                var symbol interface{} = this.SafeSymbol(marketId, nil, "_")
                AddElementToObject(result, symbol, map[string]interface{} {
            "info": fee,
            "symbol": symbol,
            "maker": this.SafeNumber(fee, "maker_fee_decimal"),
            "taker": this.SafeNumber(fee, "taker_fee_decimal"),
            "percentage": true,
            "tierBased": true,
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitso#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://docs.bitso.com/bitso-api/docs/user-trades
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *bitso) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, 25)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes10148 := (<-this.LoadMarkets())
            PanicOnError(retRes10148)
            var market interface{} = this.Market(symbol)
            // the don't support fetching trades starting from a date yet
            // use the `marker` extra param for that
            // this is not a typo, the variable name is 'marker' (don't confuse with 'market')
            var markerInParams interface{} =     (InOp(params, "marker"))
            // warn the user with an exception if the user wants to filter
            // starting from since timestamp, but does not set the trade id with an extra 'marker' param
            if IsTrue(IsTrue((!IsEqual(since, nil))) && !IsTrue(markerInParams)) {
                panic(ExchangeError(Add(this.Id, " fetchMyTrades() does not support fetching trades starting from a timestamp with the `since` argument, use the `marker` extra param to filter starting from an integer trade id")))
            }
            // convert it to an integer unconditionally
            if IsTrue(markerInParams) {
                params = this.Extend(params, map[string]interface{} {
                    "marker": ParseInt(GetValue(params, "marker")),
                })
            }
            var request interface{} = map[string]interface{} {
                "book": GetValue(market, "id"),
                "limit": limit,
            }
        
            response:= (<-this.PrivateGetUserTrades(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseTrades(GetValue(response, "payload"), market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitso#createOrder
 * @description create a trade order
 * @see https://docs.bitso.com/bitso-api/docs/place-an-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bitso) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes10558 := (<-this.LoadMarkets())
            PanicOnError(retRes10558)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "book": GetValue(market, "id"),
                "side": side,
                "type": typeVar,
                "major": this.AmountToPrecision(GetValue(market, "symbol"), amount),
            }
            if IsTrue(IsEqual(typeVar, "limit")) {
                AddElementToObject(request, "price", this.PriceToPrecision(GetValue(market, "symbol"), price))
            }
        
            response:= (<-this.PrivatePostOrders(this.Extend(request, params)))
            PanicOnError(response)
            var id interface{} = this.SafeString(GetValue(response, "payload"), "oid")
        
            ch <- this.SafeOrder(map[string]interface{} {
                "info": response,
                "id": id,
            }, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitso#cancelOrder
 * @description cancels an open order
 * @see https://docs.bitso.com/bitso-api/docs/cancel-an-order
 * @param {string} id order id
 * @param {string} symbol not used by bitso cancelOrder ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bitso) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes10858 := (<-this.LoadMarkets())
            PanicOnError(retRes10858)
            var request interface{} = map[string]interface{} {
                "oid": id,
            }
        
            response:= (<-this.PrivateDeleteOrdersOid(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "payload": ["yWTQGxDMZ0VimZgZ"]
            //     }
            //
            var payload interface{} = this.SafeList(response, "payload", []interface{}{})
            var orderId interface{} = this.SafeString(payload, 0)
        
            ch <- this.SafeOrder(map[string]interface{} {
                "info": response,
                "id": orderId,
            })
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitso#cancelOrders
 * @description cancel multiple orders
 * @see https://docs.bitso.com/bitso-api/docs/cancel-an-order
 * @param {string[]} ids order ids
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bitso) CancelOrders(ids interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if !IsTrue(IsArray(ids)) {
                panic(ArgumentsRequired(Add(this.Id, " cancelOrders() ids argument should be an array")))
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var oids interface{} = Join(ids, ",")
            var request interface{} = map[string]interface{} {
                "oids": oids,
            }
        
            response:= (<-this.PrivateDeleteOrders(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "payload": ["yWTQGxDMZ0VimZgZ"]
            //     }
            //
            var payload interface{} = this.SafeValue(response, "payload", []interface{}{})
            var orders interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(payload)); i++ {
                var id interface{} = GetValue(payload, i)
                AppendToArray(&orders,this.ParseOrder(id, market))
            }
        
            ch <- orders
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitso#cancelAllOrders
 * @description cancel all open orders
 * @see https://docs.bitso.com/bitso-api/docs/cancel-an-order
 * @param {undefined} symbol bitso does not support canceling orders for only a specific market
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bitso) CancelAllOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(!IsEqual(symbol, nil)) {
                panic(NotSupported(Add(this.Id, " cancelAllOrders() deletes all orders for user, it does not support filtering by symbol.")))
            }
        
            response:= (<-this.PrivateDeleteOrdersAll(params))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "payload": ["NWUZUYNT12ljwzDT", "kZUkZmQ2TTjkkYTY"]
            //     }
            //
            var payload interface{} = this.SafeValue(response, "payload", []interface{}{})
            var canceledOrders interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(payload)); i++ {
                var order interface{} = this.ParseOrder(GetValue(payload, i))
                AppendToArray(&canceledOrders,order)
            }
        
            ch <- canceledOrders
            return nil
        
            }()
            return ch
        }
func  (this *bitso) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "partial-fill": "open",
        "partially filled": "open",
        "queued": "open",
        "completed": "closed",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *bitso) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //
    // canceledOrder
    // yWTQGxDMZ0VimZgZ
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = nil
    if IsTrue(IsString(order)) {
        id = order
    } else {
        id = this.SafeString(order, "oid")
    }
    var side interface{} = this.SafeString(order, "side")
    var status interface{} = this.ParseOrderStatus(this.SafeString(order, "status"))
    var marketId interface{} = this.SafeString(order, "book")
    var symbol interface{} = this.SafeSymbol(marketId, market, "_")
    var orderType interface{} = this.SafeString(order, "type")
    var timestamp interface{} = this.Parse8601(this.SafeString(order, "created_at"))
    var price interface{} = this.SafeString(order, "price")
    var amount interface{} = this.SafeString(order, "original_amount")
    var remaining interface{} = this.SafeString(order, "unfilled_amount")
    var clientOrderId interface{} = this.SafeString(order, "client_id")
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": id,
        "clientOrderId": clientOrderId,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "symbol": symbol,
        "type": orderType,
        "timeInForce": nil,
        "postOnly": nil,
        "side": side,
        "price": price,
        "triggerPrice": nil,
        "amount": amount,
        "cost": nil,
        "remaining": remaining,
        "filled": nil,
        "status": status,
        "fee": nil,
        "average": nil,
        "trades": nil,
    }, market)
}
/**
 * @method
 * @name bitso#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://docs.bitso.com/bitso-api/docs/list-open-orders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bitso) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, 25)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes12408 := (<-this.LoadMarkets())
            PanicOnError(retRes12408)
            var market interface{} = this.Market(symbol)
            // the don't support fetching trades starting from a date yet
            // use the `marker` extra param for that
            // this is not a typo, the variable name is 'marker' (don't confuse with 'market')
            var markerInParams interface{} =     (InOp(params, "marker"))
            // warn the user with an exception if the user wants to filter
            // starting from since timestamp, but does not set the trade id with an extra 'marker' param
            if IsTrue(IsTrue((!IsEqual(since, nil))) && !IsTrue(markerInParams)) {
                panic(ExchangeError(Add(this.Id, " fetchOpenOrders() does not support fetching orders starting from a timestamp with the `since` argument, use the `marker` extra param to filter starting from an integer trade id")))
            }
            // convert it to an integer unconditionally
            if IsTrue(markerInParams) {
                params = this.Extend(params, map[string]interface{} {
                    "marker": ParseInt(GetValue(params, "marker")),
                })
            }
            var request interface{} = map[string]interface{} {
                "book": GetValue(market, "id"),
                "limit": limit,
            }
        
            response:= (<-this.PrivateGetOpenOrders(this.Extend(request, params)))
            PanicOnError(response)
            var orders interface{} = this.ParseOrders(GetValue(response, "payload"), market, since, limit)
        
            ch <- orders
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitso#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://docs.bitso.com/bitso-api/docs/look-up-orders
 * @param {string} id the order id
 * @param {string} symbol not used by bitso fetchOrder
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bitso) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes12798 := (<-this.LoadMarkets())
            PanicOnError(retRes12798)
        
            response:= (<-this.PrivateGetOrdersOid(map[string]interface{} {
            "oid": id,
        }))
            PanicOnError(response)
            var payload interface{} = this.SafeValue(response, "payload")
            if IsTrue(IsArray(payload)) {
                var numOrders interface{} =         GetArrayLength(GetValue(response, "payload"))
                if IsTrue(IsEqual(numOrders, 1)) {
        
                    ch <- this.ParseOrder(GetValue(payload, 0))
                    return nil
                }
            }
            panic(OrderNotFound(Add(Add(Add(this.Id, ": The order "), id), " not found.")))
        
            }()
            return ch
        }
/**
 * @method
 * @name bitso#fetchOrderTrades
 * @description fetch all the trades made from a single order
 * @see https://docs.bitso.com/bitso-api/docs/list-user-trades
 * @param {string} id order id
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *bitso) FetchOrderTrades(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes13068 := (<-this.LoadMarkets())
            PanicOnError(retRes13068)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "oid": id,
            }
        
            response:= (<-this.PrivateGetOrderTradesOid(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseTrades(GetValue(response, "payload"), market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitso#fetchDeposit
 * @description fetch information on a deposit
 * @see https://docs.bitso.com/bitso-payouts-funding/docs/fundings
 * @param {string} id deposit id
 * @param {string} code bitso does not support filtering by currency code and will ignore this argument
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *bitso) FetchDeposit(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes13268 := (<-this.LoadMarkets())
            PanicOnError(retRes13268)
            var request interface{} = map[string]interface{} {
                "fid": id,
            }
        
            response:= (<-this.PrivateGetFundingsFid(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "payload": [{
            //             "fid": "6112c6369100d6ecceb7f54f17cf0511",
            //             "status": "complete",
            //             "created_at": "2022-06-08T12:02:49+0000",
            //             "currency": "btc",
            //             "method": "btc",
            //             "method_name": "Bitcoin",
            //             "amount": "0.00080000",
            //             "asset": "btc",
            //             "network": "btc",
            //             "protocol": "btc",
            //             "integration": "bitgo-v2",
            //             "details": {
            //                 "receiving_address": "3N2vbcYKhogs6RoTb4eYCUJ3beRSqLgSif",
            //                 "tx_hash": "327f3838531f211485ec59f9d0a119fea1595591e274d942b2c10b9b8262eb1d",
            //                 "confirmations": "4"
            //             }
            //         }]
            //     }
            //
            var transactions interface{} = this.SafeValue(response, "payload", []interface{}{})
            var first interface{} = this.SafeDict(transactions, 0, map[string]interface{} {})
        
            ch <- this.ParseTransaction(first)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitso#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://docs.bitso.com/bitso-payouts-funding/docs/fundings
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *bitso) FetchDeposits(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes13718 := (<-this.LoadMarkets())
            PanicOnError(retRes13718)
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
            }
        
            response:= (<-this.PrivateGetFundings(params))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "payload": [{
            //             "fid": "6112c6369100d6ecceb7f54f17cf0511",
            //             "status": "complete",
            //             "created_at": "2022-06-08T12:02:49+0000",
            //             "currency": "btc",
            //             "method": "btc",
            //             "method_name": "Bitcoin",
            //             "amount": "0.00080000",
            //             "asset": "btc",
            //             "network": "btc",
            //             "protocol": "btc",
            //             "integration": "bitgo-v2",
            //             "details": {
            //                 "receiving_address": "3N2vbcYKhogs6RoTb4eYCUJ3beRSqLgSif",
            //                 "tx_hash": "327f3838531f211485ec59f9d0a119fea1595591e274d942b2c10b9b8262eb1d",
            //                 "confirmations": "4"
            //             }
            //         }]
            //     }
            //
            var transactions interface{} = this.SafeList(response, "payload", []interface{}{})
        
            ch <- this.ParseTransactions(transactions, currency, since, limit, params)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitso#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *bitso) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes14138 := (<-this.LoadMarkets())
            PanicOnError(retRes14138)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "fund_currency": GetValue(currency, "id"),
            }
        
            response:= (<-this.PrivateGetFundingDestination(this.Extend(request, params)))
            PanicOnError(response)
            var address interface{} = this.SafeString(GetValue(response, "payload"), "account_identifier")
            var tag interface{} = nil
            if IsTrue(IsGreaterThanOrEqual(GetIndexOf(address, "?dt="), 0)) {
                var parts interface{} = Split(address, "?dt=")
                address = this.SafeString(parts, 0)
                tag = this.SafeString(parts, 1)
            }
            this.CheckAddress(address)
        
            ch <- map[string]interface{} {
                "info": response,
                "currency": code,
                "network": nil,
                "address": address,
                "tag": tag,
            }
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitso#fetchTransactionFees
 * @deprecated
 * @description please use fetchDepositWithdrawFees instead
 * @see https://docs.bitso.com/bitso-api/docs/list-fees
 * @param {string[]|undefined} codes list of unified currency codes
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func  (this *bitso) FetchTransactionFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    codes := GetArg(optionalArgs, 0, nil)
            _ = codes
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes14478 := (<-this.LoadMarkets())
            PanicOnError(retRes14478)
        
            response:= (<-this.PrivateGetFees(params))
            PanicOnError(response)
            //
            //    {
            //        "success": true,
            //        "payload": {
            //            "fees": [
            //                {
            //                    "book": "btc_mxn",
            //                    "fee_percent": "0.6500",
            //                    "fee_decimal": "0.00650000",
            //                    "taker_fee_percent": "0.6500",
            //                    "taker_fee_decimal": "0.00650000",
            //                    "maker_fee_percent": "0.5000",
            //                    "maker_fee_decimal": "0.00500000",
            //                    "volume_currency": "mxn",
            //                    "current_volume": "0.00",
            //                    "next_volume": "1500000.00",
            //                    "next_maker_fee_percent": "0.490",
            //                    "next_taker_fee_percent": "0.637",
            //                    "nextVolume": "1500000.00",
            //                    "nextFee": "0.490",
            //                    "nextTakerFee": "0.637"
            //                },
            //                ...
            //            ],
            //            "deposit_fees": [
            //                {
            //                    "currency": "btc",
            //                    "method": "rewards",
            //                    "fee": "0.00",
            //                    "is_fixed": false
            //                },
            //                ...
            //            ],
            //            "withdrawal_fees": {
            //                "ada": "0.20958100",
            //                "bch": "0.00009437",
            //                "ars": "0",
            //                "btc": "0.00001209",
            //                ...
            //            }
            //        }
            //    }
            //
            var result interface{} = map[string]interface{} {}
            var payload interface{} = this.SafeValue(response, "payload", map[string]interface{} {})
            var depositFees interface{} = this.SafeValue(payload, "deposit_fees", []interface{}{})
            for i := 0; IsLessThan(i, GetArrayLength(depositFees)); i++ {
                var depositFee interface{} = GetValue(depositFees, i)
                var currencyId interface{} = this.SafeString(depositFee, "currency")
                var code interface{} = this.SafeCurrencyCode(currencyId)
                if IsTrue(IsTrue((!IsEqual(codes, nil))) && !IsTrue(this.InArray(code, codes))) {
                    continue
                }
                AddElementToObject(result, code, map[string]interface{} {
            "deposit": this.SafeNumber(depositFee, "fee"),
            "withdraw": nil,
            "info": map[string]interface{} {
                "deposit": depositFee,
                "withdraw": nil,
            },
        })
            }
            var withdrawalFees interface{} = this.SafeValue(payload, "withdrawal_fees", []interface{}{})
            var currencyIds interface{} = ObjectKeys(withdrawalFees)
            for i := 0; IsLessThan(i, GetArrayLength(currencyIds)); i++ {
                var currencyId interface{} = GetValue(currencyIds, i)
                var code interface{} = this.SafeCurrencyCode(currencyId)
                if IsTrue(IsTrue((!IsEqual(codes, nil))) && !IsTrue(this.InArray(code, codes))) {
                    continue
                }
                AddElementToObject(result, code, map[string]interface{} {
            "deposit": this.SafeValue(GetValue(result, code), "deposit"),
            "withdraw": this.SafeNumber(withdrawalFees, currencyId),
            "info": map[string]interface{} {
                "deposit": this.SafeValue(GetValue(GetValue(result, code), "info"), "deposit"),
                "withdraw": this.SafeNumber(withdrawalFees, currencyId),
            },
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitso#fetchDepositWithdrawFees
 * @description fetch deposit and withdraw fees
 * @see https://docs.bitso.com/bitso-api/docs/list-fees
 * @param {string[]|undefined} codes list of unified currency codes
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func  (this *bitso) FetchDepositWithdrawFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    codes := GetArg(optionalArgs, 0, nil)
            _ = codes
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes15418 := (<-this.LoadMarkets())
            PanicOnError(retRes15418)
        
            response:= (<-this.PrivateGetFees(params))
            PanicOnError(response)
            //
            //    {
            //        "success": true,
            //        "payload": {
            //            "fees": [
            //                {
            //                    "book": "btc_mxn",
            //                    "fee_percent": "0.6500",
            //                    "fee_decimal": "0.00650000",
            //                    "taker_fee_percent": "0.6500",
            //                    "taker_fee_decimal": "0.00650000",
            //                    "maker_fee_percent": "0.5000",
            //                    "maker_fee_decimal": "0.00500000",
            //                    "volume_currency": "mxn",
            //                    "current_volume": "0.00",
            //                    "next_volume": "1500000.00",
            //                    "next_maker_fee_percent": "0.490",
            //                    "next_taker_fee_percent": "0.637",
            //                    "nextVolume": "1500000.00",
            //                    "nextFee": "0.490",
            //                    "nextTakerFee": "0.637"
            //                },
            //                ...
            //            ],
            //            "deposit_fees": [
            //                {
            //                    "currency": "btc",
            //                    "method": "rewards",
            //                    "fee": "0.00",
            //                    "is_fixed": false
            //                },
            //                ...
            //            ],
            //            "withdrawal_fees": {
            //                "ada": "0.20958100",
            //                "bch": "0.00009437",
            //                "ars": "0",
            //                "btc": "0.00001209",
            //                ...
            //            }
            //        }
            //    }
            //
            var payload interface{} = this.SafeList(response, "payload", []interface{}{})
        
            ch <- this.ParseDepositWithdrawFees(payload, codes)
            return nil
        
            }()
            return ch
        }
func  (this *bitso) ParseDepositWithdrawFees(response interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "fees": [
    //            {
    //                "book": "btc_mxn",
    //                "fee_percent": "0.6500",
    //                "fee_decimal": "0.00650000",
    //                "taker_fee_percent": "0.6500",
    //                "taker_fee_decimal": "0.00650000",
    //                "maker_fee_percent": "0.5000",
    //                "maker_fee_decimal": "0.00500000",
    //                "volume_currency": "mxn",
    //                "current_volume": "0.00",
    //                "next_volume": "1500000.00",
    //                "next_maker_fee_percent": "0.490",
    //                "next_taker_fee_percent": "0.637",
    //                "nextVolume": "1500000.00",
    //                "nextFee": "0.490",
    //                "nextTakerFee": "0.637"
    //            },
    //            ...
    //        ],
    //        "deposit_fees": [
    //            {
    //                "currency": "btc",
    //                "method": "rewards",
    //                "fee": "0.00",
    //                "is_fixed": false
    //            },
    //            ...
    //        ],
    //        "withdrawal_fees": {
    //            "ada": "0.20958100",
    //            "bch": "0.00009437",
    //            "ars": "0",
    //            "btc": "0.00001209",
    //            ...
    //        }
    //    }
    //
    codes := GetArg(optionalArgs, 0, nil)
    _ = codes
    currencyIdKey := GetArg(optionalArgs, 1, nil)
    _ = currencyIdKey
    var result interface{} = map[string]interface{} {}
    var depositResponse interface{} = this.SafeValue(response, "deposit_fees", []interface{}{})
    var withdrawalResponse interface{} = this.SafeValue(response, "withdrawal_fees", []interface{}{})
    for i := 0; IsLessThan(i, GetArrayLength(depositResponse)); i++ {
        var entry interface{} = GetValue(depositResponse, i)
        var currencyId interface{} = this.SafeString(entry, "currency")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        if IsTrue(IsTrue((IsEqual(codes, nil))) || IsTrue((InOp(codes, code)))) {
            AddElementToObject(result, code, map[string]interface{} {
    "deposit": map[string]interface{} {
        "fee": this.SafeNumber(entry, "fee"),
        "percentage": !IsTrue(this.SafeValue(entry, "is_fixed")),
    },
    "withdraw": map[string]interface{} {
        "fee": nil,
        "percentage": nil,
    },
    "networks": map[string]interface{} {},
    "info": entry,
})
        }
    }
    var withdrawalKeys interface{} = ObjectKeys(withdrawalResponse)
    for i := 0; IsLessThan(i, GetArrayLength(withdrawalKeys)); i++ {
        var currencyId interface{} = GetValue(withdrawalKeys, i)
        var code interface{} = this.SafeCurrencyCode(currencyId)
        if IsTrue(IsTrue((IsEqual(codes, nil))) || IsTrue((InOp(codes, code)))) {
            var withdrawFee interface{} = this.ParseNumber(GetValue(withdrawalResponse, currencyId))
            var resultValue interface{} = this.SafeValue(result, code)
            if IsTrue(IsEqual(resultValue, nil)) {
                AddElementToObject(result, code, this.DepositWithdrawFee(map[string]interface{} {}))
            }
            AddElementToObject(GetValue(GetValue(result, code), "withdraw"), "fee", withdrawFee)
            AddElementToObject(GetValue(GetValue(result, code), "info"), code, withdrawFee)
        }
    }
    return result
}
/**
 * @method
 * @name bitso#withdraw
 * @description make a withdrawal
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *bitso) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params);
            tag = GetValue(tagparamsVariable,0);
            params = GetValue(tagparamsVariable,1)
            this.CheckAddress(address)
        
            retRes16848 := (<-this.LoadMarkets())
            PanicOnError(retRes16848)
            var methods interface{} = map[string]interface{} {
                "BTC": "Bitcoin",
                "ETH": "Ether",
                "XRP": "Ripple",
                "BCH": "Bcash",
                "LTC": "Litecoin",
            }
            var currency interface{} = this.Currency(code)
            var method interface{} = Ternary(IsTrue((InOp(methods, code))), GetValue(methods, code), nil)
            if IsTrue(IsEqual(method, nil)) {
                panic(ExchangeError(Add(Add(this.Id, " not valid withdraw coin: "), code)))
            }
            var request interface{} = map[string]interface{} {
                "amount": amount,
                "address": address,
                "destination_tag": tag,
            }
            var classMethod interface{} = Add(Add("privatePost", method), "Withdrawal")
        
            response:= (<-this.callDynamically(classMethod, this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "payload": [
            //             {
            //                 "wid": "c5b8d7f0768ee91d3b33bee648318688",
            //                 "status": "pending",
            //                 "created_at": "2016-04-08T17:52:31.000+00:00",
            //                 "currency": "btc",
            //                 "method": "Bitcoin",
            //                 "amount": "0.48650929",
            //                 "details": {
            //                     "withdrawal_address": "18MsnATiNiKLqUHDTRKjurwMg7inCrdNEp",
            //                     "tx_hash": "d4f28394693e9fb5fffcaf730c11f32d1922e5837f76ca82189d3bfe30ded433"
            //                 }
            //             },
            //         ]
            //     }
            //
            var payload interface{} = this.SafeValue(response, "payload", []interface{}{})
            var first interface{} = this.SafeDict(payload, 0)
        
            ch <- this.ParseTransaction(first, currency)
            return nil
        
            }()
            return ch
        }
func  (this *bitso) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // deposit
    //     {
    //         "fid": "6112c6369100d6ecceb7f54f17cf0511",
    //         "status": "complete",
    //         "created_at": "2022-06-08T12:02:49+0000",
    //         "currency": "btc",
    //         "method": "btc",
    //         "method_name": "Bitcoin",
    //         "amount": "0.00080000",
    //         "asset": "btc",
    //         "network": "btc",
    //         "protocol": "btc",
    //         "integration": "bitgo-v2",
    //         "details": {
    //             "receiving_address": "3NmvbcYKhogs6RoTb4eYCUJ3beRSqLgSif",
    //             "tx_hash": "327f3838531f611485ec59f9d0a119fea1595591e274d942b2c10b9b8262eb1d",
    //             "confirmations": "4"
    //         }
    //     }
    //
    // withdraw
    //
    //     {
    //         "wid": "c5b8d7f0768ee91d3b33bee648318688",
    //         "status": "pending",
    //         "created_at": "2016-04-08T17:52:31.000+00:00",
    //         "currency": "btc",
    //         "method": "Bitcoin",
    //         "amount": "0.48650929",
    //         "details": {
    //             "withdrawal_address": "18MsnATiNiKLqUHDTRKjurwMg7inCrdNEp",
    //             "tx_hash": "d4f28394693e9fb5fffcaf730c11f32d1922e5837f76ca82189d3bfe30ded433"
    //         }
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var currencyId interface{} = this.SafeString2(transaction, "currency", "asset")
    currency = this.SafeCurrency(currencyId, currency)
    var details interface{} = this.SafeValue(transaction, "details", map[string]interface{} {})
    var datetime interface{} = this.SafeString(transaction, "created_at")
    var withdrawalAddress interface{} = this.SafeString(details, "withdrawal_address")
    var receivingAddress interface{} = this.SafeString(details, "receiving_address")
    var networkId interface{} = this.SafeString2(transaction, "network", "method")
    var status interface{} = this.SafeString(transaction, "status")
    var withdrawId interface{} = this.SafeString(transaction, "wid")
    var networkCode interface{} = this.NetworkIdToCode(networkId)
    var networkCodeUpper interface{} = Ternary(IsTrue((!IsEqual(networkCode, nil))), ToUpper(networkCode), nil)
    return map[string]interface{} {
        "id": this.SafeString2(transaction, "wid", "fid"),
        "txid": this.SafeString(details, "tx_hash"),
        "timestamp": this.Parse8601(datetime),
        "datetime": datetime,
        "network": networkCodeUpper,
        "addressFrom": receivingAddress,
        "address": Ternary(IsTrue((!IsEqual(withdrawalAddress, nil))), withdrawalAddress, receivingAddress),
        "addressTo": withdrawalAddress,
        "amount": this.SafeNumber(transaction, "amount"),
        "type": Ternary(IsTrue((IsEqual(withdrawId, nil))), "deposit", "withdrawal"),
        "currency": this.SafeCurrencyCode(currencyId, currency),
        "status": this.ParseTransactionStatus(status),
        "updated": nil,
        "tagFrom": nil,
        "tag": nil,
        "tagTo": nil,
        "comment": nil,
        "internal": nil,
        "fee": nil,
        "info": transaction,
    }
}
func  (this *bitso) ParseTransactionStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "pending": "pending",
        "in_progress": "pending",
        "complete": "ok",
        "failed": "failed",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *bitso) Nonce() interface{}  {
    return this.Milliseconds()
}
func  (this *bitso) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var endpoint interface{} = Add(Add(Add("/", this.Version), "/"), this.ImplodeParams(path, params))
    var query interface{} = this.Omit(params, this.ExtractParams(path))
    if IsTrue(IsTrue(IsEqual(method, "GET")) || IsTrue(IsEqual(method, "DELETE"))) {
        if IsTrue(GetArrayLength(ObjectKeys(query))) {
            endpoint = Add(endpoint, Add("?", this.Urlencode(query)))
        }
    }
    var url interface{} = Add(GetValue(GetValue(this.Urls, "api"), "rest"), endpoint)
    if IsTrue(IsEqual(api, "private")) {
        this.CheckRequiredCredentials()
        var nonce interface{} = ToString(this.Nonce())
        endpoint = Add("/api", endpoint)
        var request interface{} = Join([]interface{}{nonce, method, endpoint}, "")
        if IsTrue(IsTrue(!IsEqual(method, "GET")) && IsTrue(!IsEqual(method, "DELETE"))) {
            if IsTrue(GetArrayLength(ObjectKeys(query))) {
                body = this.Json(query)
                request = Add(request, body)
            }
        }
        var signature interface{} = this.Hmac(this.Encode(request), this.Encode(this.Secret), sha256)
        var auth interface{} = Add(Add(Add(Add(this.ApiKey, ":"), nonce), ":"), signature)
        headers = map[string]interface{} {
            "Authorization": Add("Bitso ", auth),
        }
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *bitso) HandleErrors(httpCode interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsEqual(response, nil)) {
        return nil  // fallback to default error handler
    }
    if IsTrue(InOp(response, "success")) {
        //
        //     {"success":false,"error":{"code":104,"message":"Cannot perform request - nonce must be higher than 1520307203724237"}}
        //
        var success interface{} = this.SafeBool(response, "success", false)
        if IsTrue(IsString(success)) {
            if IsTrue(IsTrue((IsEqual(success, "true"))) || IsTrue((IsEqual(success, "1")))) {
                success = true
            } else {
                success = false
            }
        }
        if !IsTrue(success) {
            var feedback interface{} = Add(Add(this.Id, " "), this.Json(response))
            var error interface{} = this.SafeValue(response, "error")
            if IsTrue(IsEqual(error, nil)) {
                panic(ExchangeError(feedback))
            }
            var code interface{} = this.SafeString(error, "code")
            this.ThrowExactlyMatchedException(this.Exceptions, code, feedback)
            panic(ExchangeError(feedback))
        }
    }
    return nil
}


func (this *bitso) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
