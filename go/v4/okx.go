package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type OkxCore struct {
	Exchange
}

func NewOkxCore() *OkxCore {
	p := &OkxCore{}
	setDefaults(p)
	return p
}

func (this *OkxCore) Describe() interface{} {
	return this.DeepExtend(this.Exchange.Describe(), map[string]interface{}{
		"id":        "okx",
		"name":      "OKX",
		"countries": []interface{}{"CN", "US"},
		"version":   "v5",
		"rateLimit": Multiply(100, 1.1),
		"pro":       true,
		"certified": true,
		"has": map[string]interface{}{
			"CORS":                                 nil,
			"spot":                                 true,
			"margin":                               true,
			"swap":                                 true,
			"future":                               true,
			"option":                               true,
			"addMargin":                            true,
			"cancelAllOrders":                      false,
			"cancelAllOrdersAfter":                 true,
			"cancelOrder":                          true,
			"cancelOrders":                         true,
			"cancelOrdersForSymbols":               true,
			"closeAllPositions":                    false,
			"closePosition":                        true,
			"createConvertTrade":                   true,
			"createDepositAddress":                 false,
			"createMarketBuyOrderWithCost":         true,
			"createMarketSellOrderWithCost":        true,
			"createOrder":                          true,
			"createOrders":                         true,
			"createOrderWithTakeProfitAndStopLoss": true,
			"createPostOnlyOrder":                  true,
			"createReduceOnlyOrder":                true,
			"createStopLimitOrder":                 true,
			"createStopLossOrder":                  true,
			"createStopMarketOrder":                true,
			"createStopOrder":                      true,
			"createTakeProfitOrder":                true,
			"createTrailingPercentOrder":           true,
			"createTriggerOrder":                   true,
			"editOrder":                            true,
			"fetchAccounts":                        true,
			"fetchAllGreeks":                       true,
			"fetchBalance":                         true,
			"fetchBidsAsks":                        nil,
			"fetchBorrowInterest":                  true,
			"fetchBorrowRateHistories":             true,
			"fetchBorrowRateHistory":               true,
			"fetchCanceledOrders":                  true,
			"fetchClosedOrder":                     nil,
			"fetchClosedOrders":                    true,
			"fetchConvertCurrencies":               true,
			"fetchConvertQuote":                    true,
			"fetchConvertTrade":                    true,
			"fetchConvertTradeHistory":             true,
			"fetchCrossBorrowRate":                 true,
			"fetchCrossBorrowRates":                true,
			"fetchCurrencies":                      true,
			"fetchDeposit":                         true,
			"fetchDepositAddress":                  true,
			"fetchDepositAddresses":                false,
			"fetchDepositAddressesByNetwork":       true,
			"fetchDeposits":                        true,
			"fetchDepositsWithdrawals":             false,
			"fetchDepositWithdrawFee":              "emulated",
			"fetchDepositWithdrawFees":             true,
			"fetchFundingHistory":                  true,
			"fetchFundingInterval":                 true,
			"fetchFundingIntervals":                false,
			"fetchFundingRate":                     true,
			"fetchFundingRateHistory":              true,
			"fetchFundingRates":                    true,
			"fetchGreeks":                          true,
			"fetchIndexOHLCV":                      true,
			"fetchIsolatedBorrowRate":              false,
			"fetchIsolatedBorrowRates":             false,
			"fetchL3OrderBook":                     false,
			"fetchLedger":                          true,
			"fetchLedgerEntry":                     nil,
			"fetchLeverage":                        true,
			"fetchLeverageTiers":                   false,
			"fetchLongShortRatio":                  false,
			"fetchLongShortRatioHistory":           true,
			"fetchMarginAdjustmentHistory":         true,
			"fetchMarketLeverageTiers":             true,
			"fetchMarkets":                         true,
			"fetchMarkOHLCV":                       true,
			"fetchMarkPrice":                       true,
			"fetchMarkPrices":                      true,
			"fetchMySettlementHistory":             false,
			"fetchMyTrades":                        true,
			"fetchOHLCV":                           true,
			"fetchOpenInterest":                    true,
			"fetchOpenInterestHistory":             true,
			"fetchOpenInterests":                   true,
			"fetchOpenOrder":                       nil,
			"fetchOpenOrders":                      true,
			"fetchOption":                          true,
			"fetchOptionChain":                     true,
			"fetchOrder":                           true,
			"fetchOrderBook":                       true,
			"fetchOrderBooks":                      false,
			"fetchOrders":                          false,
			"fetchOrderTrades":                     true,
			"fetchPosition":                        true,
			"fetchPositionHistory":                 "emulated",
			"fetchPositions":                       true,
			"fetchPositionsForSymbol":              true,
			"fetchPositionsHistory":                true,
			"fetchPositionsRisk":                   false,
			"fetchPremiumIndexOHLCV":               false,
			"fetchSettlementHistory":               true,
			"fetchStatus":                          true,
			"fetchTicker":                          true,
			"fetchTickers":                         true,
			"fetchTime":                            true,
			"fetchTrades":                          true,
			"fetchTradingFee":                      true,
			"fetchTradingFees":                     false,
			"fetchTradingLimits":                   false,
			"fetchTransactionFee":                  false,
			"fetchTransactionFees":                 false,
			"fetchTransactions":                    false,
			"fetchTransfer":                        true,
			"fetchTransfers":                       true,
			"fetchUnderlyingAssets":                true,
			"fetchVolatilityHistory":               false,
			"fetchWithdrawal":                      true,
			"fetchWithdrawals":                     true,
			"fetchWithdrawalWhitelist":             false,
			"reduceMargin":                         true,
			"repayCrossMargin":                     true,
			"sandbox":                              true,
			"setLeverage":                          true,
			"setMargin":                            false,
			"setMarginMode":                        true,
			"setPositionMode":                      true,
			"signIn":                               false,
			"transfer":                             true,
			"withdraw":                             true,
		},
		"timeframes": map[string]interface{}{
			"1m":  "1m",
			"3m":  "3m",
			"5m":  "5m",
			"15m": "15m",
			"30m": "30m",
			"1h":  "1H",
			"2h":  "2H",
			"4h":  "4H",
			"6h":  "6H",
			"12h": "12H",
			"1d":  "1D",
			"1w":  "1W",
			"1M":  "1M",
			"3M":  "3M",
		},
		"hostname": "www.okx.com",
		"urls": map[string]interface{}{
			"logo": "https://user-images.githubusercontent.com/1294454/152485636-38b19e4a-bece-4dec-979a-5982859ffc04.jpg",
			"api": map[string]interface{}{
				"rest": "https://{hostname}",
			},
			"www":  "https://www.okx.com",
			"doc":  "https://www.okx.com/docs-v5/en/",
			"fees": "https://www.okx.com/pages/products/fees.html",
			"referral": map[string]interface{}{
				"url":      "https://www.okx.com/join/CCXTCOM",
				"discount": 0.2,
			},
			"test": map[string]interface{}{
				"rest": "https://{hostname}",
			},
		},
		"api": map[string]interface{}{
			"public": map[string]interface{}{
				"get": map[string]interface{}{
					"market/tickers":                             1,
					"market/ticker":                              1,
					"market/books":                               Divide(1, 2),
					"market/books-full":                          2,
					"market/candles":                             Divide(1, 2),
					"market/history-candles":                     1,
					"market/trades":                              Divide(1, 5),
					"market/history-trades":                      2,
					"market/option/instrument-family-trades":     1,
					"market/platform-24-volume":                  10,
					"market/call-auction-detail":                 1,
					"market/books-sbe":                           10,
					"market/block-tickers":                       1,
					"market/block-ticker":                        1,
					"market/sprd-ticker":                         1,
					"market/sprd-candles":                        Divide(1, 2),
					"market/sprd-history-candles":                1,
					"market/index-tickers":                       1,
					"market/index-candles":                       1,
					"market/history-index-candles":               2,
					"market/mark-price-candles":                  1,
					"market/history-mark-price-candles":          1,
					"market/exchange-rate":                       20,
					"market/index-components":                    1,
					"market/open-oracle":                         50,
					"market/books-lite":                          Divide(5, 3),
					"public/option-trades":                       1,
					"public/block-trades":                        1,
					"public/instruments":                         1,
					"public/estimated-price":                     2,
					"public/delivery-exercise-history":           Divide(1, 2),
					"public/estimated-settlement-info":           2,
					"public/settlement-history":                  Divide(1, 2),
					"public/funding-rate":                        2,
					"public/funding-rate-history":                2,
					"public/open-interest":                       1,
					"public/price-limit":                         1,
					"public/opt-summary":                         1,
					"public/discount-rate-interest-free-quota":   10,
					"public/time":                                2,
					"public/mark-price":                          2,
					"public/position-tiers":                      2,
					"public/interest-rate-loan-quota":            10,
					"public/underlying":                          1,
					"public/insurance-fund":                      2,
					"public/convert-contract-coin":               2,
					"public/instrument-tick-bands":               4,
					"public/premium-history":                     1,
					"public/economic-calendar":                   50,
					"public/market-data-history":                 4,
					"public/vip-interest-rate-loan-quota":        10,
					"rubik/stat/trading-data/support-coin":       4,
					"rubik/stat/contracts/open-interest-history": 2,
					"rubik/stat/taker-volume":                    4,
					"rubik/stat/taker-volume-contract":           4,
					"rubik/stat/margin/loan-ratio":               4,
					"rubik/stat/contracts/long-short-account-ratio-contract-top-trader": 4,
					"rubik/stat/contracts/long-short-account-ratio-contract":            4,
					"rubik/stat/contracts/long-short-account-ratio":                     4,
					"rubik/stat/contracts/open-interest-volume":                         4,
					"rubik/stat/option/open-interest-volume":                            4,
					"rubik/stat/option/open-interest-volume-ratio":                      4,
					"rubik/stat/option/open-interest-volume-expiry":                     4,
					"rubik/stat/option/open-interest-volume-strike":                     4,
					"rubik/stat/option/taker-block-volume":                              4,
					"system/status":                                                     50,
					"sprd/spreads":                                                      1,
					"sprd/books":                                                        1,
					"sprd/public-trades":                                                1,
					"sprd/ticker":                                                       1,
					"tradingBot/grid/ai-param":                                          1,
					"tradingBot/grid/min-investment":                                    1,
					"tradingBot/public/rsi-back-testing":                                1,
					"tradingBot/grid/grid-quantity":                                     4,
					"asset/exchange-list":                                               Divide(5, 3),
					"finance/staking-defi/eth/apy-history":                              Divide(5, 3),
					"finance/staking-defi/sol/apy-history":                              Divide(5, 3),
					"finance/savings/lending-rate-summary":                              Divide(5, 3),
					"finance/savings/lending-rate-history":                              Divide(5, 3),
					"finance/fixed-loan/lending-offers":                                 Divide(10, 3),
					"finance/fixed-loan/lending-apy-history":                            Divide(10, 3),
					"finance/fixed-loan/pending-lending-volume":                         Divide(10, 3),
					"finance/sfp/dcd/products":                                          Divide(2, 3),
					"copytrading/public-config":                                         4,
					"copytrading/public-lead-traders":                                   4,
					"copytrading/public-weekly-pnl":                                     4,
					"copytrading/public-pnl":                                            4,
					"copytrading/public-stats":                                          4,
					"copytrading/public-preference-currency":                            4,
					"copytrading/public-current-subpositions":                           4,
					"copytrading/public-subpositions-history":                           4,
					"copytrading/public-copy-traders":                                   4,
					"support/announcements":                                             4,
					"support/announcements-types":                                       20,
				},
				"post": map[string]interface{}{
					"tradingBot/grid/min-investment": 1,
				},
			},
			"private": map[string]interface{}{
				"get": map[string]interface{}{
					"rfq/counterparties":                                 4,
					"rfq/maker-instrument-settings":                      4,
					"rfq/mmp-config":                                     4,
					"rfq/rfqs":                                           10,
					"rfq/quotes":                                         10,
					"rfq/trades":                                         4,
					"rfq/public-trades":                                  4,
					"sprd/order":                                         1,
					"sprd/orders-pending":                                2,
					"sprd/orders-history":                                1,
					"sprd/orders-history-archive":                        1,
					"sprd/trades":                                        1,
					"trade/order":                                        Divide(1, 3),
					"trade/orders-pending":                               Divide(1, 3),
					"trade/orders-history":                               Divide(1, 2),
					"trade/orders-history-archive":                       1,
					"trade/fills":                                        Divide(1, 3),
					"trade/fills-history":                                2,
					"trade/fills-archive":                                2,
					"trade/order-algo":                                   1,
					"trade/orders-algo-pending":                          1,
					"trade/orders-algo-history":                          1,
					"trade/easy-convert-currency-list":                   20,
					"trade/easy-convert-history":                         20,
					"trade/one-click-repay-currency-list":                20,
					"trade/one-click-repay-currency-list-v2":             20,
					"trade/one-click-repay-history":                      20,
					"trade/one-click-repay-history-v2":                   20,
					"trade/account-rate-limit":                           1,
					"asset/currencies":                                   Divide(5, 3),
					"asset/balances":                                     Divide(5, 3),
					"asset/non-tradable-assets":                          Divide(5, 3),
					"asset/asset-valuation":                              10,
					"asset/transfer-state":                               1,
					"asset/bills":                                        Divide(5, 3),
					"asset/bills-history":                                10,
					"asset/deposit-lightning":                            5,
					"asset/deposit-address":                              Divide(5, 3),
					"asset/deposit-history":                              Divide(5, 3),
					"asset/withdrawal-history":                           Divide(5, 3),
					"asset/deposit-withdraw-status":                      20,
					"asset/monthly-statement":                            2,
					"asset/convert/currencies":                           Divide(5, 3),
					"asset/convert/currency-pair":                        Divide(5, 3),
					"asset/convert/history":                              Divide(5, 3),
					"account/instruments":                                1,
					"account/balance":                                    2,
					"account/positions":                                  2,
					"account/positions-history":                          2,
					"account/account-position-risk":                      2,
					"account/bills":                                      2,
					"account/bills-archive":                              4,
					"account/bills-history-archive":                      2,
					"account/config":                                     4,
					"account/max-size":                                   1,
					"account/max-avail-size":                             1,
					"account/leverage-info":                              1,
					"account/adjust-leverage-info":                       4,
					"account/max-loan":                                   1,
					"account/trade-fee":                                  4,
					"account/interest-accrued":                           4,
					"account/interest-rate":                              4,
					"account/max-withdrawal":                             1,
					"account/risk-state":                                 2,
					"account/interest-limits":                            4,
					"account/spot-borrow-repay-history":                  4,
					"account/greeks":                                     2,
					"account/position-tiers":                             2,
					"account/set-account-switch-precheck":                4,
					"account/collateral-assets":                          4,
					"account/mmp-config":                                 4,
					"account/move-positions-history":                     10,
					"account/precheck-set-delta-neutral":                 20,
					"account/quick-margin-borrow-repay-history":          4,
					"account/borrow-repay-history":                       4,
					"account/vip-interest-accrued":                       4,
					"account/vip-interest-deducted":                      4,
					"account/vip-loan-order-list":                        4,
					"account/vip-loan-order-detail":                      4,
					"account/fixed-loan/borrowing-limit":                 4,
					"account/fixed-loan/borrowing-quote":                 5,
					"account/fixed-loan/borrowing-orders-list":           5,
					"account/spot-manual-borrow-repay":                   30,
					"account/set-auto-repay":                             4,
					"users/subaccount/list":                              10,
					"account/subaccount/balances":                        Divide(10, 3),
					"asset/subaccount/balances":                          Divide(10, 3),
					"account/subaccount/max-withdrawal":                  1,
					"asset/subaccount/bills":                             Divide(5, 3),
					"asset/subaccount/managed-subaccount-bills":          Divide(5, 3),
					"users/entrust-subaccount-list":                      10,
					"account/subaccount/interest-limits":                 4,
					"users/subaccount/apikey":                            10,
					"tradingBot/grid/orders-algo-pending":                1,
					"tradingBot/grid/orders-algo-history":                1,
					"tradingBot/grid/orders-algo-details":                1,
					"tradingBot/grid/sub-orders":                         1,
					"tradingBot/grid/positions":                          1,
					"tradingBot/grid/ai-param":                           1,
					"tradingBot/signal/signals":                          1,
					"tradingBot/signal/orders-algo-details":              1,
					"tradingBot/signal/orders-algo-pending":              1,
					"tradingBot/signal/orders-algo-history":              1,
					"tradingBot/signal/positions":                        1,
					"tradingBot/signal/positions-history":                2,
					"tradingBot/signal/sub-orders":                       1,
					"tradingBot/signal/event-history":                    1,
					"tradingBot/recurring/orders-algo-pending":           1,
					"tradingBot/recurring/orders-algo-history":           1,
					"tradingBot/recurring/orders-algo-details":           1,
					"tradingBot/recurring/sub-orders":                    1,
					"finance/savings/balance":                            Divide(5, 3),
					"finance/savings/lending-history":                    Divide(5, 3),
					"finance/staking-defi/offers":                        Divide(10, 3),
					"finance/staking-defi/orders-active":                 Divide(10, 3),
					"finance/staking-defi/orders-history":                Divide(10, 3),
					"finance/staking-defi/eth/product-info":              Divide(10, 3),
					"finance/staking-defi/eth/balance":                   Divide(5, 3),
					"finance/staking-defi/eth/purchase-redeem-history":   Divide(5, 3),
					"finance/staking-defi/sol/product-info":              Divide(10, 3),
					"finance/staking-defi/sol/balance":                   Divide(5, 3),
					"finance/staking-defi/sol/purchase-redeem-history":   Divide(5, 3),
					"finance/flexible-loan/borrow-currencies":            4,
					"finance/flexible-loan/collateral-assets":            4,
					"finance/flexible-loan/max-collateral-redeem-amount": 4,
					"finance/flexible-loan/loan-info":                    4,
					"finance/flexible-loan/loan-history":                 4,
					"finance/flexible-loan/interest-accrued":             4,
					"copytrading/current-subpositions":                   1,
					"copytrading/subpositions-history":                   1,
					"copytrading/instruments":                            4,
					"copytrading/profit-sharing-details":                 4,
					"copytrading/total-profit-sharing":                   4,
					"copytrading/unrealized-profit-sharing-details":      4,
					"copytrading/total-unrealized-profit-sharing":        4,
					"copytrading/config":                                 4,
					"copytrading/copy-settings":                          4,
					"copytrading/current-lead-traders":                   4,
					"copytrading/batch-leverage-info":                    4,
					"copytrading/lead-traders-history":                   4,
					"broker/dma/subaccount-info":                         2,
					"broker/dma/subaccount-trade-fee":                    10,
					"broker/dma/subaccount/apikey":                       10,
					"broker/dma/rebate-per-orders":                       300,
					"broker/fd/rebate-per-orders":                        300,
					"broker/fd/if-rebate":                                5,
					"broker/nd/info":                                     10,
					"broker/nd/subaccount-info":                          10,
					"broker/nd/subaccount/apikey":                        10,
					"asset/broker/nd/subaccount-deposit-address":         Divide(5, 3),
					"asset/broker/nd/subaccount-deposit-history":         4,
					"asset/broker/nd/subaccount-withdrawal-history":      4,
					"broker/nd/rebate-daily":                             100,
					"broker/nd/rebate-per-orders":                        300,
					"finance/sfp/dcd/order":                              2,
					"finance/sfp/dcd/orders":                             2,
					"affiliate/invitee/detail":                           1,
					"users/partner/if-rebate":                            1,
					"support/announcements":                              4,
				},
				"post": map[string]interface{}{
					"rfq/create-rfq":                                    4,
					"rfq/cancel-rfq":                                    4,
					"rfq/cancel-batch-rfqs":                             10,
					"rfq/cancel-all-rfqs":                               10,
					"rfq/execute-quote":                                 15,
					"rfq/maker-instrument-settings":                     4,
					"rfq/mmp-reset":                                     4,
					"rfq/mmp-config":                                    100,
					"rfq/create-quote":                                  0.4,
					"rfq/cancel-quote":                                  0.4,
					"rfq/cancel-batch-quotes":                           10,
					"rfq/cancel-all-quotes":                             10,
					"rfq/cancel-all-after":                              10,
					"sprd/order":                                        1,
					"sprd/cancel-order":                                 1,
					"sprd/mass-cancel":                                  1,
					"sprd/amend-order":                                  1,
					"sprd/cancel-all-after":                             10,
					"trade/order":                                       Divide(1, 3),
					"trade/batch-orders":                                Divide(1, 15),
					"trade/cancel-order":                                Divide(1, 3),
					"trade/cancel-batch-orders":                         Divide(1, 15),
					"trade/amend-order":                                 Divide(1, 3),
					"trade/amend-batch-orders":                          Divide(1, 150),
					"trade/close-position":                              1,
					"trade/fills-archive":                               172800,
					"trade/cancel-advance-algos":                        1,
					"trade/easy-convert":                                20,
					"trade/one-click-repay":                             20,
					"trade/one-click-repay-v2":                          20,
					"trade/mass-cancel":                                 4,
					"trade/cancel-all-after":                            10,
					"trade/order-precheck":                              4,
					"trade/order-algo":                                  1,
					"trade/cancel-algos":                                1,
					"trade/amend-algos":                                 1,
					"asset/transfer":                                    5,
					"asset/withdrawal":                                  Divide(5, 3),
					"asset/withdrawal-lightning":                        5,
					"asset/cancel-withdrawal":                           Divide(5, 3),
					"asset/convert-dust-assets":                         10,
					"asset/monthly-statement":                           1296000,
					"asset/convert/estimate-quote":                      50,
					"asset/convert/trade":                               1,
					"account/bills-history-archive":                     72000,
					"account/set-position-mode":                         4,
					"account/set-leverage":                              1,
					"account/position/margin-balance":                   1,
					"account/set-fee-type":                              4,
					"account/set-greeks":                                4,
					"account/set-isolated-mode":                         4,
					"account/spot-manual-borrow-repay":                  30,
					"account/set-auto-repay":                            4,
					"account/quick-margin-borrow-repay":                 4,
					"account/borrow-repay":                              Divide(5, 3),
					"account/simulated_margin":                          10,
					"account/position-builder":                          10,
					"account/position-builder-graph":                    50,
					"account/set-riskOffset-type":                       2,
					"account/activate-option":                           4,
					"account/set-auto-loan":                             4,
					"account/account-level-switch-preset":               4,
					"account/set-account-level":                         4,
					"account/set-collateral-assets":                     4,
					"account/mmp-reset":                                 4,
					"account/mmp-config":                                50,
					"account/fixed-loan/borrowing-order":                5,
					"account/fixed-loan/amend-borrowing-order":          5,
					"account/fixed-loan/manual-reborrow":                5,
					"account/fixed-loan/repay-borrowing-order":          5,
					"account/move-positions":                            10,
					"account/set-auto-earn":                             10,
					"account/set-settle-currency":                       1,
					"account/set-trading-config":                        20,
					"asset/subaccount/transfer":                         10,
					"account/subaccount/set-loan-allocation":            4,
					"users/subaccount/create-subaccount":                10,
					"users/subaccount/apikey":                           10,
					"users/subaccount/modify-apikey":                    10,
					"users/subaccount/subaccount-apikey":                10,
					"users/subaccount/delete-apikey":                    10,
					"users/subaccount/set-transfer-out":                 10,
					"tradingBot/grid/order-algo":                        1,
					"tradingBot/grid/amend-algo-basic-param":            1,
					"tradingBot/grid/amend-order-algo":                  1,
					"tradingBot/grid/stop-order-algo":                   1,
					"tradingBot/grid/close-position":                    1,
					"tradingBot/grid/cancel-close-order":                1,
					"tradingBot/grid/order-instant-trigger":             1,
					"tradingBot/grid/withdraw-income":                   1,
					"tradingBot/grid/compute-margin-balance":            1,
					"tradingBot/grid/margin-balance":                    1,
					"tradingBot/grid/min-investment":                    1,
					"tradingBot/grid/adjust-investment":                 1,
					"tradingBot/signal/create-signal":                   1,
					"tradingBot/signal/order-algo":                      1,
					"tradingBot/signal/stop-order-algo":                 1,
					"tradingBot/signal/margin-balance":                  1,
					"tradingBot/signal/amendTPSL":                       1,
					"tradingBot/signal/set-instruments":                 1,
					"tradingBot/signal/close-position":                  1,
					"tradingBot/signal/sub-order":                       1,
					"tradingBot/signal/cancel-sub-order":                1,
					"tradingBot/recurring/order-algo":                   1,
					"tradingBot/recurring/amend-order-algo":             1,
					"tradingBot/recurring/stop-order-algo":              1,
					"finance/savings/purchase-redempt":                  Divide(5, 3),
					"finance/savings/set-lending-rate":                  Divide(5, 3),
					"finance/staking-defi/purchase":                     5,
					"finance/staking-defi/redeem":                       5,
					"finance/staking-defi/cancel":                       5,
					"finance/staking-defi/eth/purchase":                 5,
					"finance/staking-defi/eth/redeem":                   5,
					"finance/staking-defi/eth/cancel-redeem":            5,
					"finance/staking-defi/sol/purchase":                 5,
					"finance/staking-defi/sol/redeem":                   5,
					"finance/staking-defi/sol/cancel-redeem":            5,
					"finance/flexible-loan/max-loan":                    4,
					"finance/flexible-loan/adjust-collateral":           4,
					"copytrading/algo-order":                            1,
					"copytrading/close-subposition":                     1,
					"copytrading/set-instruments":                       4,
					"copytrading/amend-profit-sharing-ratio":            4,
					"copytrading/first-copy-settings":                   4,
					"copytrading/amend-copy-settings":                   4,
					"copytrading/stop-copy-trading":                     4,
					"copytrading/batch-set-leverage":                    4,
					"broker/nd/create-subaccount":                       0.25,
					"broker/nd/delete-subaccount":                       1,
					"broker/nd/subaccount/apikey":                       0.25,
					"broker/nd/subaccount/modify-apikey":                1,
					"broker/nd/subaccount/delete-apikey":                1,
					"broker/nd/set-subaccount-level":                    4,
					"broker/nd/set-subaccount-fee-rate":                 4,
					"broker/nd/set-subaccount-assets":                   0.25,
					"asset/broker/nd/subaccount-deposit-address":        1,
					"asset/broker/nd/modify-subaccount-deposit-address": Divide(5, 3),
					"broker/nd/rebate-per-orders":                       36000,
					"finance/sfp/dcd/quote":                             10,
					"finance/sfp/dcd/order":                             10,
					"broker/nd/report-subaccount-ip":                    0.25,
					"broker/dma/subaccount/apikey":                      Divide(1, 4),
					"broker/dma/trades":                                 36000,
					"broker/fd/rebate-per-orders":                       36000,
				},
			},
		},
		"fees": map[string]interface{}{
			"trading": map[string]interface{}{
				"taker": this.ParseNumber("0.0015"),
				"maker": this.ParseNumber("0.0010"),
			},
			"spot": map[string]interface{}{
				"taker": this.ParseNumber("0.0015"),
				"maker": this.ParseNumber("0.0010"),
			},
			"future": map[string]interface{}{
				"taker": this.ParseNumber("0.0005"),
				"maker": this.ParseNumber("0.0002"),
			},
			"swap": map[string]interface{}{
				"taker": this.ParseNumber("0.00050"),
				"maker": this.ParseNumber("0.00020"),
			},
		},
		"requiredCredentials": map[string]interface{}{
			"apiKey":   true,
			"secret":   true,
			"password": true,
		},
		"exceptions": map[string]interface{}{
			"exact": map[string]interface{}{
				"1":     ExchangeError,
				"2":     ExchangeError,
				"4088":  ManualInteractionNeeded,
				"50000": BadRequest,
				"50001": OnMaintenance,
				"50002": BadRequest,
				"50004": RequestTimeout,
				"50005": ExchangeNotAvailable,
				"50006": BadRequest,
				"50007": AccountSuspended,
				"50008": AuthenticationError,
				"50009": AccountSuspended,
				"50010": ExchangeError,
				"50011": RateLimitExceeded,
				"50012": ExchangeError,
				"50013": ExchangeNotAvailable,
				"50014": BadRequest,
				"50015": ExchangeError,
				"50016": ExchangeError,
				"50017": ExchangeError,
				"50018": ExchangeError,
				"50019": ExchangeError,
				"50020": ExchangeError,
				"50021": ExchangeError,
				"50022": ExchangeError,
				"50023": ExchangeError,
				"50024": BadRequest,
				"50025": ExchangeError,
				"50026": ExchangeNotAvailable,
				"50027": PermissionDenied,
				"50028": ExchangeError,
				"50044": BadRequest,
				"50061": ExchangeError,
				"50062": ExchangeError,
				"50100": ExchangeError,
				"50101": AuthenticationError,
				"50102": InvalidNonce,
				"50103": AuthenticationError,
				"50104": AuthenticationError,
				"50105": AuthenticationError,
				"50106": AuthenticationError,
				"50107": AuthenticationError,
				"50108": ExchangeError,
				"50109": ExchangeError,
				"50110": PermissionDenied,
				"50111": AuthenticationError,
				"50112": AuthenticationError,
				"50113": AuthenticationError,
				"50114": AuthenticationError,
				"50115": BadRequest,
				"51000": BadRequest,
				"51001": BadSymbol,
				"51002": BadSymbol,
				"51003": BadRequest,
				"51004": InvalidOrder,
				"51005": InvalidOrder,
				"51006": InvalidOrder,
				"51007": InvalidOrder,
				"51008": InsufficientFunds,
				"51009": AccountSuspended,
				"51010": AccountNotEnabled,
				"51011": InvalidOrder,
				"51012": BadSymbol,
				"51014": BadSymbol,
				"51015": BadSymbol,
				"51016": InvalidOrder,
				"51017": ExchangeError,
				"51018": ExchangeError,
				"51019": ExchangeError,
				"51020": InvalidOrder,
				"51021": ContractUnavailable,
				"51022": ContractUnavailable,
				"51023": ExchangeError,
				"51024": AccountSuspended,
				"51025": ExchangeError,
				"51026": BadSymbol,
				"51027": ContractUnavailable,
				"51028": ContractUnavailable,
				"51029": ContractUnavailable,
				"51030": ContractUnavailable,
				"51031": InvalidOrder,
				"51046": InvalidOrder,
				"51047": InvalidOrder,
				"51051": InvalidOrder,
				"51072": InvalidOrder,
				"51073": InvalidOrder,
				"51074": InvalidOrder,
				"51090": InvalidOrder,
				"51091": InvalidOrder,
				"51092": InvalidOrder,
				"51093": InvalidOrder,
				"51094": InvalidOrder,
				"51095": InvalidOrder,
				"51096": InvalidOrder,
				"51098": InvalidOrder,
				"51099": InvalidOrder,
				"51100": InvalidOrder,
				"51101": InvalidOrder,
				"51102": InvalidOrder,
				"51103": InvalidOrder,
				"51104": InvalidOrder,
				"51105": InvalidOrder,
				"51106": InvalidOrder,
				"51107": InvalidOrder,
				"51108": InvalidOrder,
				"51109": InvalidOrder,
				"51110": InvalidOrder,
				"51111": BadRequest,
				"51112": InvalidOrder,
				"51113": RateLimitExceeded,
				"51115": InvalidOrder,
				"51116": InvalidOrder,
				"51117": InvalidOrder,
				"51118": InvalidOrder,
				"51119": InsufficientFunds,
				"51120": InvalidOrder,
				"51121": InvalidOrder,
				"51122": InvalidOrder,
				"51124": InvalidOrder,
				"51125": InvalidOrder,
				"51126": InvalidOrder,
				"51127": InsufficientFunds,
				"51128": InvalidOrder,
				"51129": InvalidOrder,
				"51130": BadSymbol,
				"51131": InsufficientFunds,
				"51132": InvalidOrder,
				"51133": InvalidOrder,
				"51134": InvalidOrder,
				"51135": InvalidOrder,
				"51136": InvalidOrder,
				"51137": InvalidOrder,
				"51138": InvalidOrder,
				"51139": InvalidOrder,
				"51155": RestrictedLocation,
				"51156": BadRequest,
				"51159": BadRequest,
				"51162": InvalidOrder,
				"51163": InvalidOrder,
				"51166": InvalidOrder,
				"51174": InvalidOrder,
				"51185": InvalidOrder,
				"51201": InvalidOrder,
				"51202": InvalidOrder,
				"51203": InvalidOrder,
				"51204": InvalidOrder,
				"51205": InvalidOrder,
				"51250": InvalidOrder,
				"51251": InvalidOrder,
				"51252": InvalidOrder,
				"51253": InvalidOrder,
				"51254": InvalidOrder,
				"51255": InvalidOrder,
				"51256": InvalidOrder,
				"51257": InvalidOrder,
				"51258": InvalidOrder,
				"51259": InvalidOrder,
				"51260": InvalidOrder,
				"51261": InvalidOrder,
				"51262": InvalidOrder,
				"51263": InvalidOrder,
				"51264": InvalidOrder,
				"51265": InvalidOrder,
				"51267": InvalidOrder,
				"51268": InvalidOrder,
				"51269": InvalidOrder,
				"51270": InvalidOrder,
				"51271": InvalidOrder,
				"51272": InvalidOrder,
				"51273": InvalidOrder,
				"51274": InvalidOrder,
				"51275": InvalidOrder,
				"51276": InvalidOrder,
				"51277": InvalidOrder,
				"51278": InvalidOrder,
				"51279": InvalidOrder,
				"51280": InvalidOrder,
				"51321": InvalidOrder,
				"51322": InvalidOrder,
				"51323": BadRequest,
				"51324": BadRequest,
				"51325": InvalidOrder,
				"51327": InvalidOrder,
				"51328": InvalidOrder,
				"51329": InvalidOrder,
				"51330": InvalidOrder,
				"51400": OrderNotFound,
				"51401": OrderNotFound,
				"51402": OrderNotFound,
				"51403": InvalidOrder,
				"51404": InvalidOrder,
				"51405": ExchangeError,
				"51406": ExchangeError,
				"51407": BadRequest,
				"51408": ExchangeError,
				"51409": ExchangeError,
				"51410": CancelPending,
				"51500": ExchangeError,
				"51501": ExchangeError,
				"51502": InsufficientFunds,
				"51503": ExchangeError,
				"51506": ExchangeError,
				"51508": ExchangeError,
				"51509": ExchangeError,
				"51510": ExchangeError,
				"51511": ExchangeError,
				"51600": ExchangeError,
				"51601": ExchangeError,
				"51602": ExchangeError,
				"51603": OrderNotFound,
				"51732": AuthenticationError,
				"51733": AuthenticationError,
				"51734": AuthenticationError,
				"51735": ExchangeError,
				"51736": InsufficientFunds,
				"52000": ExchangeError,
				"54000": ExchangeError,
				"54001": ExchangeError,
				"54008": InvalidOrder,
				"54009": InvalidOrder,
				"54011": InvalidOrder,
				"54072": ExchangeError,
				"54073": BadRequest,
				"54074": ExchangeError,
				"55100": InvalidOrder,
				"55101": InvalidOrder,
				"55102": InvalidOrder,
				"55103": InvalidOrder,
				"55104": InvalidOrder,
				"55111": InvalidOrder,
				"55112": InvalidOrder,
				"55113": InvalidOrder,
				"58000": ExchangeError,
				"58001": AuthenticationError,
				"58002": PermissionDenied,
				"58003": ExchangeError,
				"58004": AccountSuspended,
				"58005": ExchangeError,
				"58006": ExchangeError,
				"58007": ExchangeError,
				"58100": ExchangeError,
				"58101": AccountSuspended,
				"58102": RateLimitExceeded,
				"58103": ExchangeError,
				"58104": ExchangeError,
				"58105": ExchangeError,
				"58106": ExchangeError,
				"58107": ExchangeError,
				"58108": ExchangeError,
				"58109": ExchangeError,
				"58110": ExchangeError,
				"58111": ExchangeError,
				"58112": ExchangeError,
				"58114": ExchangeError,
				"58115": ExchangeError,
				"58116": ExchangeError,
				"58117": ExchangeError,
				"58125": BadRequest,
				"58126": BadRequest,
				"58127": BadRequest,
				"58128": BadRequest,
				"58200": ExchangeError,
				"58201": ExchangeError,
				"58202": ExchangeError,
				"58203": InvalidAddress,
				"58204": AccountSuspended,
				"58205": ExchangeError,
				"58206": ExchangeError,
				"58207": InvalidAddress,
				"58208": ExchangeError,
				"58209": ExchangeError,
				"58210": ExchangeError,
				"58211": ExchangeError,
				"58212": ExchangeError,
				"58213": AuthenticationError,
				"58221": BadRequest,
				"58222": BadRequest,
				"58224": BadRequest,
				"58227": BadRequest,
				"58228": BadRequest,
				"58229": InsufficientFunds,
				"58300": ExchangeError,
				"58350": InsufficientFunds,
				"59000": ExchangeError,
				"59001": ExchangeError,
				"59100": ExchangeError,
				"59101": ExchangeError,
				"59102": ExchangeError,
				"59103": InsufficientFunds,
				"59104": ExchangeError,
				"59105": ExchangeError,
				"59106": ExchangeError,
				"59107": ExchangeError,
				"59108": InsufficientFunds,
				"59109": ExchangeError,
				"59128": InvalidOrder,
				"59200": InsufficientFunds,
				"59201": InsufficientFunds,
				"59216": BadRequest,
				"59260": PermissionDenied,
				"59262": PermissionDenied,
				"59300": ExchangeError,
				"59301": ExchangeError,
				"59313": ExchangeError,
				"59401": ExchangeError,
				"59410": OperationRejected,
				"59411": InsufficientFunds,
				"59412": OperationRejected,
				"59413": OperationRejected,
				"59414": BadRequest,
				"59500": ExchangeError,
				"59501": ExchangeError,
				"59502": ExchangeError,
				"59503": ExchangeError,
				"59504": ExchangeError,
				"59505": ExchangeError,
				"59506": ExchangeError,
				"59507": ExchangeError,
				"59508": AccountSuspended,
				"59515": ExchangeError,
				"59516": ExchangeError,
				"59517": ExchangeError,
				"59518": ExchangeError,
				"59519": ExchangeError,
				"59642": BadRequest,
				"59643": ExchangeError,
				"59683": ExchangeError,
				"59684": BadRequest,
				"59686": BadRequest,
				"60001": AuthenticationError,
				"60002": AuthenticationError,
				"60003": AuthenticationError,
				"60004": AuthenticationError,
				"60005": AuthenticationError,
				"60006": InvalidNonce,
				"60007": AuthenticationError,
				"60008": AuthenticationError,
				"60009": AuthenticationError,
				"60010": AuthenticationError,
				"60011": AuthenticationError,
				"60012": BadRequest,
				"60013": BadRequest,
				"60014": RateLimitExceeded,
				"60015": NetworkError,
				"60016": ExchangeNotAvailable,
				"60017": BadRequest,
				"60018": BadRequest,
				"60019": BadRequest,
				"60020": ExchangeError,
				"60021": AccountNotEnabled,
				"60022": AuthenticationError,
				"60023": DDoSProtection,
				"60024": AuthenticationError,
				"60025": ExchangeError,
				"60026": AuthenticationError,
				"60027": ArgumentsRequired,
				"60028": NotSupported,
				"60029": AccountNotEnabled,
				"60030": AccountNotEnabled,
				"60031": AuthenticationError,
				"60032": AuthenticationError,
				"63999": ExchangeError,
				"64000": BadRequest,
				"64001": BadRequest,
				"64002": BadRequest,
				"64003": AccountNotEnabled,
				"70010": BadRequest,
				"70013": BadRequest,
				"70016": BadRequest,
				"70060": BadRequest,
				"70061": BadRequest,
				"70062": BadRequest,
				"70064": BadRequest,
				"70065": BadRequest,
				"70066": BadRequest,
				"70067": BadRequest,
				"1009":  BadRequest,
				"4001":  AuthenticationError,
				"4002":  BadRequest,
				"4003":  RateLimitExceeded,
				"4004":  NetworkError,
				"4005":  ExchangeNotAvailable,
				"4006":  BadRequest,
				"4007":  AuthenticationError,
				"4008":  RateLimitExceeded,
			},
			"broad": map[string]interface{}{
				"Internal Server Error": ExchangeNotAvailable,
				"server error":          ExchangeNotAvailable,
			},
		},
		"httpExceptions": map[string]interface{}{
			"429": ExchangeNotAvailable,
		},
		"precisionMode": TICK_SIZE,
		"options": map[string]interface{}{
			"sandboxMode":    false,
			"defaultNetwork": "ERC20",
			"defaultNetworks": map[string]interface{}{
				"ETH":  "ERC20",
				"BTC":  "BTC",
				"USDT": "TRC20",
			},
			"networks": map[string]interface{}{
				"BTC":          "Bitcoin",
				"BTCLN":        "Lightning",
				"BTCLIGHTNING": "Lightning",
				"BEP20":        "BSC",
				"BRC20":        "BRC20",
				"ERC20":        "ERC20",
				"TRC20":        "TRC20",
				"CRC20":        "Crypto",
				"ACA":          "Acala",
				"ALGO":         "Algorand",
				"APT":          "Aptos",
				"SCROLL":       "Scroll",
				"ARBONE":       "Arbitrum One",
				"AVAXC":        "Avalanche C-Chain",
				"AVAXX":        "Avalanche X-Chain",
				"BASE":         "Base",
				"SUI":          "SUI",
				"ZKSYNCERA":    "zkSync Era",
				"LINEA":        "Linea",
				"AR":           "Arweave",
				"ASTR":         "Astar",
				"BCH":          "BitcoinCash",
				"BSV":          "Bitcoin SV",
				"ADA":          "Cardano",
				"CSPR":         "Casper",
				"CELO":         "CELO",
				"XCH":          "Chia",
				"ATOM":         "Cosmos",
				"DGB":          "Digibyte",
				"DOGE":         "Dogecoin",
				"EGLD":         "Elrond",
				"CFX":          "Conflux",
				"EOS":          "EOS",
				"CORE":         "CORE",
				"ETC":          "Ethereum Classic",
				"ETHW":         "EthereumPow",
				"FIL":          "Filecoin",
				"ONE":          "Harmony",
				"HBAR":         "Hedera",
				"ICX":          "ICON",
				"ICP":          "Dfinity",
				"IOST":         "IOST",
				"IOTA":         "MIOTA",
				"KLAY":         "Klaytn",
				"KSM":          "Kusama",
				"LSK":          "Lisk",
				"LTC":          "Litecoin",
				"METIS":        "Metis",
				"MINA":         "Mina",
				"GLRM":         "Moonbeam",
				"MOVR":         "Moonriver",
				"NANO":         "Nano",
				"NEAR":         "NEAR",
				"NULS":         "NULS",
				"OASYS":        "OASYS",
				"ONT":          "Ontology",
				"OPTIMISM":     "Optimism",
				"LAT":          "PlatON",
				"DOT":          "Polkadot",
				"MATIC":        "Polygon",
				"RVN":          "Ravencoin",
				"XRP":          "Ripple",
				"SC":           "Siacoin",
				"SOL":          "Solana",
				"STX":          "l-Stacks",
				"XLM":          "Stellar Lumens",
				"XTZ":          "Tezos",
				"TON":          "TON",
				"THETA":        "Theta",
				"WAX":          "Wax",
				"ZIL":          "Zilliqa",
			},
			"fetchOpenInterestHistory": map[string]interface{}{
				"timeframes": map[string]interface{}{
					"5m": "5m",
					"1h": "1H",
					"8h": "8H",
					"1d": "1D",
					"5M": "5m",
					"1H": "1H",
					"8H": "8H",
					"1D": "1D",
				},
			},
			"fetchOHLCV": map[string]interface{}{
				"timezone": "UTC",
			},
			"fetchPositions": map[string]interface{}{
				"method": "privateGetAccountPositions",
			},
			"createOrder":                       "privatePostTradeBatchOrders",
			"createMarketBuyOrderRequiresPrice": false,
			"fetchMarkets": map[string]interface{}{
				"types": []interface{}{"spot", "future", "swap", "option"},
			},
			"timeDifference":          0,
			"adjustForTimeDifference": false,
			"defaultType":             "spot",
			"fetchLedger": map[string]interface{}{
				"method": "privateGetAccountBills",
			},
			"fetchOrder": map[string]interface{}{
				"method": "privateGetTradeOrder",
			},
			"fetchOpenOrders": map[string]interface{}{
				"method": "privateGetTradeOrdersPending",
			},
			"cancelOrders": map[string]interface{}{
				"method": "privatePostTradeCancelBatchOrders",
			},
			"fetchCanceledOrders": map[string]interface{}{
				"method": "privateGetTradeOrdersHistory",
			},
			"fetchClosedOrders": map[string]interface{}{
				"method": "privateGetTradeOrdersHistory",
			},
			"withdraw": map[string]interface{}{
				"password": nil,
				"pwd":      nil,
			},
			"algoOrderTypes": map[string]interface{}{
				"conditional":     true,
				"trigger":         true,
				"oco":             true,
				"move_order_stop": true,
				"iceberg":         true,
				"twap":            true,
			},
			"accountsByType": map[string]interface{}{
				"funding": "6",
				"trading": "18",
				"spot":    "18",
				"future":  "18",
				"futures": "18",
				"margin":  "18",
				"swap":    "18",
				"option":  "18",
			},
			"accountsById": map[string]interface{}{
				"6":  "funding",
				"18": "trading",
			},
			"exchangeType": map[string]interface{}{
				"spot":    "SPOT",
				"margin":  "MARGIN",
				"swap":    "SWAP",
				"future":  "FUTURES",
				"futures": "FUTURES",
				"option":  "OPTION",
				"SPOT":    "SPOT",
				"MARGIN":  "MARGIN",
				"SWAP":    "SWAP",
				"FUTURES": "FUTURES",
				"OPTION":  "OPTION",
			},
			"brokerId": "6b9ad766b55dBCDE",
		},
		"features": map[string]interface{}{
			"default": map[string]interface{}{
				"sandbox": true,
				"createOrder": map[string]interface{}{
					"marginMode":   true,
					"triggerPrice": true,
					"triggerPriceType": map[string]interface{}{
						"last":  true,
						"mark":  true,
						"index": true,
					},
					"triggerDirection": false,
					"stopLossPrice":    true,
					"takeProfitPrice":  true,
					"attachedStopLossTakeProfit": map[string]interface{}{
						"triggerPriceType": map[string]interface{}{
							"last":  true,
							"mark":  true,
							"index": true,
						},
						"price": true,
					},
					"timeInForce": map[string]interface{}{
						"IOC": true,
						"FOK": true,
						"PO":  true,
						"GTD": false,
					},
					"hedged":                 true,
					"trailing":               true,
					"iceberg":                true,
					"leverage":               false,
					"selfTradePrevention":    true,
					"marketBuyByCost":        true,
					"marketBuyRequiresPrice": false,
				},
				"createOrders": map[string]interface{}{
					"max": 20,
				},
				"fetchMyTrades": map[string]interface{}{
					"marginMode":     false,
					"daysBack":       90,
					"limit":          100,
					"untilDays":      10000,
					"symbolRequired": false,
				},
				"fetchOrder": map[string]interface{}{
					"marginMode":     false,
					"trigger":        true,
					"trailing":       true,
					"symbolRequired": true,
				},
				"fetchOpenOrders": map[string]interface{}{
					"marginMode":     false,
					"limit":          100,
					"trigger":        true,
					"trailing":       true,
					"symbolRequired": false,
				},
				"fetchOrders": nil,
				"fetchClosedOrders": map[string]interface{}{
					"marginMode":       false,
					"limit":            100,
					"daysBack":         90,
					"daysBackCanceled": Divide(1, 12),
					"untilDays":        nil,
					"trigger":          true,
					"trailing":         true,
					"symbolRequired":   false,
				},
				"fetchOHLCV": map[string]interface{}{
					"limit": 300,
					"mark":  100,
					"index": 100,
				},
			},
			"spot": map[string]interface{}{
				"extends": "default",
				"fetchCurrencies": map[string]interface{}{
					"private": true,
				},
			},
			"swap": map[string]interface{}{
				"linear": map[string]interface{}{
					"extends": "default",
				},
				"inverse": map[string]interface{}{
					"extends": "default",
				},
			},
			"future": map[string]interface{}{
				"linear": map[string]interface{}{
					"extends": "default",
				},
				"inverse": map[string]interface{}{
					"extends": "default",
				},
			},
		},
		"currencies": map[string]interface{}{
			"USD": this.SafeCurrencyStructure(map[string]interface{}{
				"id":        "USD",
				"code":      "USD",
				"precision": this.ParseNumber("0.0001"),
			}),
			"EUR": this.SafeCurrencyStructure(map[string]interface{}{
				"id":        "EUR",
				"code":      "EUR",
				"precision": this.ParseNumber("0.0001"),
			}),
			"AED": this.SafeCurrencyStructure(map[string]interface{}{
				"id":        "AED",
				"code":      "AED",
				"precision": this.ParseNumber("0.0001"),
			}),
			"GBP": this.SafeCurrencyStructure(map[string]interface{}{
				"id":        "GBP",
				"code":      "GBP",
				"precision": this.ParseNumber("0.0001"),
			}),
			"AUD": this.SafeCurrencyStructure(map[string]interface{}{
				"id":        "AUD",
				"code":      "AUD",
				"precision": this.ParseNumber("0.0001"),
			}),
		},
		"commonCurrencies": map[string]interface{}{
			"AE": "AET",
		},
	})
}
func (this *OkxCore) HandleMarketTypeAndParams(methodName interface{}, optionalArgs ...interface{}) interface{} {
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	params := GetArg(optionalArgs, 1, map[string]interface{}{})
	_ = params
	defaultValue := GetArg(optionalArgs, 2, nil)
	_ = defaultValue
	var instType interface{} = this.SafeString(params, "instType")
	params = this.Omit(params, "instType")
	var typeVar interface{} = this.SafeString(params, "type")
	if IsTrue(IsTrue((IsEqual(typeVar, nil))) && IsTrue((!IsEqual(instType, nil)))) {
		AddElementToObject(params, "type", instType)
	}
	return this.Exchange.HandleMarketTypeAndParams(methodName, market, params, defaultValue)
}
func (this *OkxCore) ConvertToInstrumentType(typeVar interface{}) interface{} {
	var exchangeTypes interface{} = this.SafeDict(this.Options, "exchangeType", map[string]interface{}{})
	return this.SafeString(exchangeTypes, typeVar, typeVar)
}
func (this *OkxCore) CreateExpiredOptionMarket(symbol interface{}) interface{} {
	// support expired option contracts
	var quote interface{} = "USD"
	var optionParts interface{} = Split(symbol, "-")
	var symbolBase interface{} = Split(symbol, "/")
	var base interface{} = nil
	if IsTrue(IsGreaterThan(GetIndexOf(symbol, "/"), OpNeg(1))) {
		base = this.SafeString(symbolBase, 0)
	} else {
		base = this.SafeString(optionParts, 0)
	}
	var settle interface{} = base
	var expiry interface{} = this.SafeString(optionParts, 2)
	var strike interface{} = this.SafeString(optionParts, 3)
	var optionType interface{} = this.SafeString(optionParts, 4)
	var datetime interface{} = this.ConvertExpireDate(expiry)
	var timestamp interface{} = this.Parse8601(datetime)
	return map[string]interface{}{
		"id":             Add(Add(Add(Add(Add(Add(Add(Add(base, "-"), quote), "-"), expiry), "-"), strike), "-"), optionType),
		"symbol":         Add(Add(Add(Add(Add(Add(Add(Add(Add(Add(base, "/"), quote), ":"), settle), "-"), expiry), "-"), strike), "-"), optionType),
		"base":           base,
		"quote":          quote,
		"settle":         settle,
		"baseId":         base,
		"quoteId":        quote,
		"settleId":       settle,
		"active":         false,
		"type":           "option",
		"linear":         nil,
		"inverse":        nil,
		"spot":           false,
		"swap":           false,
		"future":         false,
		"option":         true,
		"margin":         false,
		"contract":       true,
		"contractSize":   this.ParseNumber("1"),
		"expiry":         timestamp,
		"expiryDatetime": datetime,
		"optionType":     Ternary(IsTrue((IsEqual(optionType, "C"))), "call", "put"),
		"strike":         this.ParseNumber(strike),
		"precision": map[string]interface{}{
			"amount": nil,
			"price":  nil,
		},
		"limits": map[string]interface{}{
			"amount": map[string]interface{}{
				"min": nil,
				"max": nil,
			},
			"price": map[string]interface{}{
				"min": nil,
				"max": nil,
			},
			"cost": map[string]interface{}{
				"min": nil,
				"max": nil,
			},
		},
		"info": nil,
	}
}
func (this *OkxCore) SafeMarket(optionalArgs ...interface{}) interface{} {
	marketId := GetArg(optionalArgs, 0, nil)
	_ = marketId
	market := GetArg(optionalArgs, 1, nil)
	_ = market
	delimiter := GetArg(optionalArgs, 2, nil)
	_ = delimiter
	marketType := GetArg(optionalArgs, 3, nil)
	_ = marketType
	var isOption interface{} = IsTrue((!IsEqual(marketId, nil))) && IsTrue((IsTrue((IsGreaterThan(GetIndexOf(marketId, "-C"), OpNeg(1)))) || IsTrue((IsGreaterThan(GetIndexOf(marketId, "-P"), OpNeg(1))))))
	if IsTrue(IsTrue(isOption) && !IsTrue((InOp(this.Markets_by_id, marketId)))) {
		// handle expired option contracts
		return this.CreateExpiredOptionMarket(marketId)
	}
	return this.Exchange.SafeMarket(marketId, market, delimiter, marketType)
}

/**
 * @method
 * @name okx#fetchStatus
 * @description the latest known information on the availability of the exchange API
 * @see https://www.okx.com/docs-v5/en/#status-get-status
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [status structure]{@link https://docs.ccxt.com/?id=exchange-status-structure}
 */
func (this *OkxCore) FetchStatus(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		response := (<-this.PublicGetSystemStatus(params))
		PanicOnError(response)
		//
		// Note, if there is no maintenance around, the 'data' array is empty
		//
		//     {
		//         "code": "0",
		//         "msg": "",
		//         "data": [
		//             {
		//                 "begin": "1621328400000",
		//                 "end": "1621329000000",
		//                 "href": "https://www.okx.com/support/hc/en-us/articles/360060882172",
		//                 "scheDesc": "",
		//                 "serviceType": "1", // 0 WebSocket, 1 Spot/Margin, 2 Futures, 3 Perpetual, 4 Options, 5 Trading service
		//                 "state": "scheduled", // ongoing, completed, canceled
		//                 "system": "classic", // classic, unified
		//                 "title": "Classic Spot System Upgrade"
		//             },
		//         ]
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var dataLength interface{} = GetArrayLength(data)
		var update interface{} = map[string]interface{}{
			"updated": nil,
			"status":  Ternary(IsTrue((IsEqual(dataLength, 0))), "ok", "maintenance"),
			"eta":     nil,
			"url":     nil,
			"info":    response,
		}
		for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
			var event interface{} = GetValue(data, i)
			var state interface{} = this.SafeString(event, "state")
			AddElementToObject(update, "eta", this.SafeInteger(event, "end"))
			AddElementToObject(update, "url", this.SafeString(event, "href"))
			if IsTrue(IsEqual(state, "ongoing")) {
				AddElementToObject(update, "status", "maintenance")
			} else if IsTrue(IsEqual(state, "scheduled")) {
				AddElementToObject(update, "status", "ok")
			} else if IsTrue(IsEqual(state, "completed")) {
				AddElementToObject(update, "status", "ok")
			} else if IsTrue(IsEqual(state, "canceled")) {
				AddElementToObject(update, "status", "ok")
			}
		}

		ch <- update
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @see https://www.okx.com/docs-v5/en/#public-data-rest-api-get-system-time
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func (this *OkxCore) FetchTime(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		response := (<-this.PublicGetPublicTime(params))
		PanicOnError(response)
		//
		//     {
		//         "code": "0",
		//         "data": [
		//             {"ts": "1621247923668"}
		//         ],
		//         "msg": ""
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var first interface{} = this.SafeDict(data, 0, map[string]interface{}{})

		ch <- this.SafeInteger(first, "ts")
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#fetchAccounts
 * @description fetch all the accounts associated with a profile
 * @see https://www.okx.com/docs-v5/en/#trading-account-rest-api-get-account-configuration
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/?id=account-structure} indexed by the account type
 */
func (this *OkxCore) FetchAccounts(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		response := (<-this.PrivateGetAccountConfig(params))
		PanicOnError(response)
		//
		//     {
		//         "code": "0",
		//         "data": [
		//             {
		//                 "acctLv": "2",
		//                 "acctStpMode": "cancel_maker",
		//                 "autoLoan": false,
		//                 "ctIsoMode": "automatic",
		//                 "enableSpotBorrow": false,
		//                 "greeksType": "PA",
		//                 "feeType": "0",
		//                 "ip": "",
		//                 "type": "0",
		//                 "kycLv": "3",
		//                 "label": "v5 test",
		//                 "level": "Lv1",
		//                 "levelTmp": "",
		//                 "liquidationGear": "-1",
		//                 "mainUid": "44705892343619584",
		//                 "mgnIsoMode": "automatic",
		//                 "opAuth": "1",
		//                 "perm": "read_only,withdraw,trade",
		//                 "posMode": "long_short_mode",
		//                 "roleType": "0",
		//                 "spotBorrowAutoRepay": false,
		//                 "spotOffsetType": "",
		//                 "spotRoleType": "0",
		//                 "spotTraderInsts": [],
		//                 "traderInsts": [],
		//                 "uid": "44705892343619584",
		//                 "settleCcy": "USDT",
		//                 "settleCcyList": ["USD", "USDC", "USDG"],
		//             }
		//         ],
		//         "msg": ""
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var result interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
			var account interface{} = GetValue(data, i)
			var accountId interface{} = this.SafeString(account, "uid")
			var typeVar interface{} = this.SafeString(account, "acctLv")
			AppendToArray(&result, map[string]interface{}{
				"id":       accountId,
				"type":     typeVar,
				"currency": nil,
				"info":     account,
				"code":     nil,
			})
		}

		ch <- result
		return nil

	}()
	return ch
}
func (this *OkxCore) Nonce() interface{} {
	return Subtract(this.Milliseconds(), GetValue(this.Options, "timeDifference"))
}

/**
 * @method
 * @name okx#fetchMarkets
 * @description retrieves data on all markets for okx
 * @see https://www.okx.com/docs-v5/en/#rest-api-public-data-get-instruments
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func (this *OkxCore) FetchMarkets(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		if IsTrue(GetValue(this.Options, "adjustForTimeDifference")) {

			retRes164712 := (<-this.LoadTimeDifference())
			PanicOnError(retRes164712)
		}
		var types interface{} = []interface{}{"spot", "future", "swap", "option"}
		var fetchMarketsOption interface{} = this.SafeDict(this.Options, "fetchMarkets")
		if IsTrue(!IsEqual(fetchMarketsOption, nil)) {
			types = this.SafeList(fetchMarketsOption, "types", types)
		} else {
			types = this.SafeList(this.Options, "fetchMarkets", types) // backward-support
		}
		var promises interface{} = []interface{}{}
		var result interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(types)); i++ {
			AppendToArray(&promises, this.FetchMarketsByType(GetValue(types, i), params))
		}

		promises = (<-promiseAll(promises))
		PanicOnError(promises)
		for i := 0; IsLessThan(i, GetArrayLength(promises)); i++ {
			result = this.ArrayConcat(result, GetValue(promises, i))
		}

		ch <- result
		return nil

	}()
	return ch
}
func (this *OkxCore) ParseMarket(market interface{}) interface{} {
	//
	//     {
	//         "alias": "", // this_week, next_week, quarter, next_quarter
	//         "baseCcy": "BTC",
	//         "category": "1",
	//         "ctMult": "",
	//         "ctType": "", // inverse, linear
	//         "ctVal": "",
	//         "ctValCcy": "",
	//         "expTime": "",
	//         "instId": "BTC-USDT", // BTC-USD-210521, CSPR-USDT-SWAP, BTC-USD-210517-44000-C
	//         "instType": "SPOT", // SPOT, FUTURES, SWAP, OPTION
	//         "lever": "10",
	//         "listTime": "1548133413000",
	//         "lotSz": "0.00000001",
	//         "minSz": "0.00001",
	//         "optType": "",
	//         "quoteCcy": "USDT",
	//         "settleCcy": "",
	//         "state": "live",
	//         "stk": "",
	//         "tickSz": "0.1",
	//         "uly": ""
	//     }
	//
	//     {
	//         "alias": "",
	//         "baseCcy": "",
	//         "category": "1",
	//         "ctMult": "0.1",
	//         "ctType": "",
	//         "ctVal": "1",
	//         "ctValCcy": "BTC",
	//         "expTime": "1648195200000",
	//         "instId": "BTC-USD-220325-194000-P",
	//         "instType": "OPTION",
	//         "lever": "",
	//         "listTime": "1631262612280",
	//         "contTdSwTime": "1631262812280",
	//         "lotSz": "1",
	//         "minSz": "1",
	//         "optType": "P",
	//         "quoteCcy": "",
	//         "settleCcy": "BTC",
	//         "state": "live",
	//         "stk": "194000",
	//         "tickSz": "0.0005",
	//         "uly": "BTC-USD"
	//     }
	//
	// for swap "preopen" markets, only `instId` and `instType` are present
	//
	//         instId: "ETH-USD_UM-SWAP",
	//         instType: "SWAP",
	//         state: "preopen",
	//
	var id interface{} = this.SafeString(market, "instId")
	var typeVar interface{} = this.SafeStringLower(market, "instType")
	if IsTrue(IsEqual(typeVar, "futures")) {
		typeVar = "future"
	}
	var spot interface{} = (IsEqual(typeVar, "spot"))
	var future interface{} = (IsEqual(typeVar, "future"))
	var swap interface{} = (IsEqual(typeVar, "swap"))
	var option interface{} = (IsEqual(typeVar, "option"))
	var contract interface{} = IsTrue(IsTrue(swap) || IsTrue(future)) || IsTrue(option)
	var baseId interface{} = this.SafeString(market, "baseCcy", "") // defaulting to '' because some weird preopen markets have empty baseId
	var quoteId interface{} = this.SafeString(market, "quoteCcy", "")
	var settleId interface{} = this.SafeString(market, "settleCcy")
	var settle interface{} = this.SafeCurrencyCode(settleId)
	var underlying interface{} = this.SafeString(market, "uly")
	if IsTrue(IsTrue((!IsEqual(underlying, nil))) && !IsTrue(spot)) {
		var parts interface{} = Split(underlying, "-")
		baseId = this.SafeString(parts, 0)
		quoteId = this.SafeString(parts, 1)
	}
	if IsTrue(IsTrue((IsTrue((IsEqual(baseId, ""))) || IsTrue((IsEqual(quoteId, ""))))) && IsTrue(spot)) {
		var instId interface{} = this.SafeString(market, "instId", "")
		var parts interface{} = Split(instId, "-")
		baseId = this.SafeString(parts, 0)
		quoteId = this.SafeString(parts, 1)
	}
	var base interface{} = this.SafeCurrencyCode(baseId)
	var quote interface{} = this.SafeCurrencyCode(quoteId)
	var symbol interface{} = Add(Add(base, "/"), quote)
	// handle preopen empty markets
	if IsTrue(IsTrue(IsEqual(base, "")) || IsTrue(IsEqual(quote, ""))) {
		symbol = id
	}
	var expiry interface{} = nil
	var strikePrice interface{} = nil
	var optionType interface{} = nil
	if IsTrue(contract) {
		if IsTrue(!IsEqual(settle, nil)) {
			symbol = Add(Add(symbol, ":"), settle)
		}
		if IsTrue(future) {
			expiry = this.SafeInteger(market, "expTime")
			if IsTrue(!IsEqual(expiry, nil)) {
				var ymd interface{} = this.Yymmdd(expiry)
				symbol = Add(Add(symbol, "-"), ymd)
			}
		} else if IsTrue(option) {
			expiry = this.SafeInteger(market, "expTime")
			strikePrice = this.SafeString(market, "stk")
			optionType = this.SafeString(market, "optType")
			if IsTrue(!IsEqual(expiry, nil)) {
				var ymd interface{} = this.Yymmdd(expiry)
				symbol = Add(Add(Add(Add(Add(Add(symbol, "-"), ymd), "-"), strikePrice), "-"), optionType)
				optionType = Ternary(IsTrue((IsEqual(optionType, "P"))), "put", "call")
			}
		}
	}
	var fees interface{} = this.SafeDict2(this.Fees, typeVar, "trading", map[string]interface{}{})
	var maxLeverage interface{} = this.SafeString(market, "lever", "1")
	maxLeverage = Precise.StringMax(maxLeverage, "1")
	var maxSpotCost interface{} = this.SafeNumber(market, "maxMktSz")
	var status interface{} = this.SafeString(market, "state")
	var instIdCode interface{} = this.SafeInteger(market, "instIdCode")
	return this.Extend(fees, map[string]interface{}{
		"id":             id,
		"instIdCode":     instIdCode,
		"symbol":         symbol,
		"base":           base,
		"quote":          quote,
		"settle":         settle,
		"baseId":         baseId,
		"quoteId":        quoteId,
		"settleId":       settleId,
		"type":           typeVar,
		"spot":           spot,
		"margin":         IsTrue(spot) && IsTrue((Precise.StringGt(maxLeverage, "1"))),
		"swap":           swap,
		"future":         future,
		"option":         option,
		"active":         IsEqual(status, "live"),
		"contract":       contract,
		"linear":         Ternary(IsTrue(contract), (IsEqual(quoteId, settleId)), nil),
		"inverse":        Ternary(IsTrue(contract), (IsEqual(baseId, settleId)), nil),
		"contractSize":   Ternary(IsTrue(contract), this.SafeNumber(market, "ctVal"), nil),
		"expiry":         expiry,
		"expiryDatetime": this.Iso8601(expiry),
		"strike":         this.ParseNumber(strikePrice),
		"optionType":     optionType,
		"created":        this.SafeInteger2(market, "contTdSwTime", "listTime"),
		"precision": map[string]interface{}{
			"amount": this.SafeNumber(market, "lotSz"),
			"price":  this.SafeNumber(market, "tickSz"),
		},
		"limits": map[string]interface{}{
			"leverage": map[string]interface{}{
				"min": this.ParseNumber("1"),
				"max": this.ParseNumber(maxLeverage),
			},
			"amount": map[string]interface{}{
				"min": this.SafeNumber(market, "minSz"),
				"max": nil,
			},
			"price": map[string]interface{}{
				"min": nil,
				"max": nil,
			},
			"cost": map[string]interface{}{
				"min": nil,
				"max": Ternary(IsTrue(contract), nil, maxSpotCost),
			},
		},
		"info": market,
	})
}
func (this *OkxCore) FetchMarketsByType(typeVar interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		var request interface{} = map[string]interface{}{
			"instType": this.ConvertToInstrumentType(typeVar),
		}
		if IsTrue(IsEqual(typeVar, "option")) {
			var optionsUnderlying interface{} = this.SafeList(this.Options, "defaultUnderlying", []interface{}{"BTC-USD", "ETH-USD"})
			var promises interface{} = []interface{}{}
			for i := 0; IsLessThan(i, GetArrayLength(optionsUnderlying)); i++ {
				var underlying interface{} = GetValue(optionsUnderlying, i)
				AddElementToObject(request, "uly", underlying)
				AppendToArray(&promises, this.PublicGetPublicInstruments(this.Extend(request, params)))
			}

			promisesResult := (<-promiseAll(promises))
			PanicOnError(promisesResult)
			var markets interface{} = []interface{}{}
			for i := 0; IsLessThan(i, GetArrayLength(promisesResult)); i++ {
				var res interface{} = this.SafeDict(promisesResult, i, map[string]interface{}{})
				var options interface{} = this.SafeList(res, "data", []interface{}{})
				markets = this.ArrayConcat(markets, options)
			}

			ch <- this.ParseMarkets(markets)
			return nil
		}

		response := (<-this.PublicGetPublicInstruments(this.Extend(request, params)))
		PanicOnError(response)
		//
		// spot, future, swap, option
		//
		//     {
		//         "code": "0",
		//         "data": [
		//             {
		//                 "alias": "", // this_week, next_week, quarter, next_quarter
		//                 "baseCcy": "BTC",
		//                 "category": "1",
		//                 "ctMult": "",
		//                 "ctType": "", // inverse, linear
		//                 "ctVal": "",
		//                 "ctValCcy": "",
		//                 "expTime": "",
		//                 "instId": "BTC-USDT", // BTC-USD-210521, CSPR-USDT-SWAP, BTC-USD-210517-44000-C
		//                 "instType": "SPOT", // SPOT, FUTURES, SWAP, OPTION
		//                 "lever": "10",
		//                 "listTime": "1548133413000",
		//                 "lotSz": "0.00000001",
		//                 "minSz": "0.00001",
		//                 "optType": "",
		//                 "quoteCcy": "USDT",
		//                 "settleCcy": "",
		//                 "state": "live",
		//                 "stk": "",
		//                 "tickSz": "0.1",
		//                 "uly": ""
		//             }
		//         ],
		//         "msg": ""
		//     }
		//
		var dataResponse interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseMarkets(dataResponse)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see https://www.okx.com/docs-v5/en/#rest-api-funding-get-currencies
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func (this *OkxCore) FetchCurrencies(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		// this endpoint requires authentication
		// while fetchCurrencies is a public API method by design
		// therefore we check the keys here
		// and fallback to generating the currencies from the markets
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		var isSandboxMode interface{} = this.SafeBool(this.Options, "sandboxMode", false)
		if IsTrue(!IsTrue(this.CheckRequiredCredentials(false)) || IsTrue(isSandboxMode)) {

			ch <- map[string]interface{}{}
			return nil
		}
		//
		// has['fetchCurrencies'] is currently set to true, but an unauthorized request returns
		//
		//     {"msg":"Request header OK_ACCESS_KEY can't be empty.","code":"50103"}
		//

		response := (<-this.PrivateGetAssetCurrencies(params))
		PanicOnError(response)
		//
		//    {
		//        "code": "0",
		//        "data": [
		//            {
		//                "canDep": true,
		//                "canInternal": false,
		//                "canWd": true,
		//                "ccy": "USDT",
		//                "chain": "USDT-TRC20",
		//                "logoLink": "https://static.coinall.ltd/cdn/assets/imgs/221/5F74EB20302D7761.png",
		//                "mainNet": false,
		//                "maxFee": "1.6",
		//                "maxWd": "8852150",
		//                "minFee": "0.8",
		//                "minWd": "2",
		//                "name": "Tether",
		//                "usedWdQuota": "0",
		//                "wdQuota": "500",
		//                "wdTickSz": "3"
		//            },
		//            {
		//                "canDep": true,
		//                "canInternal": false,
		//                "canWd": true,
		//                "ccy": "USDT",
		//                "chain": "USDT-ERC20",
		//                "logoLink": "https://static.coinall.ltd/cdn/assets/imgs/221/5F74EB20302D7761.png",
		//                "mainNet": false,
		//                "maxFee": "16",
		//                "maxWd": "8852150",
		//                "minFee": "8",
		//                "minWd": "2",
		//                "name": "Tether",
		//                "usedWdQuota": "0",
		//                "wdQuota": "500",
		//                "wdTickSz": "3"
		//            },
		//            ...
		//        ],
		//        "msg": ""
		//    }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var result interface{} = map[string]interface{}{}
		var dataByCurrencyId interface{} = this.GroupBy(data, "ccy")
		var currencyIds interface{} = ObjectKeys(dataByCurrencyId)
		for i := 0; IsLessThan(i, GetArrayLength(currencyIds)); i++ {
			var currencyId interface{} = GetValue(currencyIds, i)
			var currency interface{} = this.SafeCurrency(currencyId)
			var code interface{} = GetValue(currency, "code")
			var chains interface{} = GetValue(dataByCurrencyId, currencyId)
			var networks interface{} = map[string]interface{}{}
			var typeVar interface{} = "crypto"
			var chainsLength interface{} = GetArrayLength(chains)
			for j := 0; IsLessThan(j, chainsLength); j++ {
				var chain interface{} = GetValue(chains, j)
				// allow empty string for rare fiat-currencies, e.g. TRY
				var networkId interface{} = this.SafeString(chain, "chain", "") // USDT-BEP20, USDT-Avalance-C, etc
				if IsTrue(IsEqual(networkId, "")) {
					// only happens for fiat 'TRY' currency
					typeVar = "fiat"
				}
				var idParts interface{} = Split(networkId, "-")
				var parts interface{} = this.ArraySlice(idParts, 1)
				var chainPart interface{} = Join(parts, "-")
				var networkCode interface{} = this.NetworkIdToCode(chainPart, GetValue(currency, "code"))
				AddElementToObject(networks, networkCode, map[string]interface{}{
					"id":        networkId,
					"network":   networkCode,
					"active":    nil,
					"deposit":   this.SafeBool(chain, "canDep"),
					"withdraw":  this.SafeBool(chain, "canWd"),
					"fee":       this.SafeNumber(chain, "fee"),
					"precision": this.ParseNumber(this.ParsePrecision(this.SafeString(chain, "wdTickSz"))),
					"limits": map[string]interface{}{
						"withdraw": map[string]interface{}{
							"min": this.SafeNumber(chain, "minWd"),
							"max": this.SafeNumber(chain, "maxWd"),
						},
					},
					"info": chain,
				})
			}
			var firstChain interface{} = this.SafeDict(chains, 0, map[string]interface{}{})
			AddElementToObject(result, code, this.SafeCurrencyStructure(map[string]interface{}{
				"info":      chains,
				"code":      code,
				"id":        currencyId,
				"name":      this.SafeString(firstChain, "name"),
				"active":    nil,
				"deposit":   nil,
				"withdraw":  nil,
				"fee":       nil,
				"precision": nil,
				"limits": map[string]interface{}{
					"amount": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
				},
				"type":     typeVar,
				"networks": networks,
			}))
		}

		ch <- result
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-market-data-get-order-book
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.method] 'publicGetMarketBooksFull' or 'publicGetMarketBooks' default is 'publicGetMarketBooks'
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func (this *OkxCore) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		limit := GetArg(optionalArgs, 0, nil)
		_ = limit
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes20428 := (<-this.LoadMarkets())
		PanicOnError(retRes20428)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"instId": GetValue(market, "id"),
		}
		var method interface{} = nil
		methodparamsVariable := this.HandleOptionAndParams(params, "fetchOrderBook", "method", "publicGetMarketBooks")
		method = GetValue(methodparamsVariable, 0)
		params = GetValue(methodparamsVariable, 1)
		if IsTrue(IsTrue(IsEqual(method, "publicGetMarketBooksFull")) && IsTrue(IsEqual(limit, nil))) {
			limit = 5000
		}
		limit = Ternary(IsTrue((IsEqual(limit, nil))), 100, limit)
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "sz", limit) // max 400
		}
		var response interface{} = nil
		if IsTrue(IsTrue((IsEqual(method, "publicGetMarketBooksFull"))) || IsTrue((IsGreaterThan(limit, 400)))) {

			response = (<-this.PublicGetMarketBooksFull(this.Extend(request, params)))
			PanicOnError(response)
		} else {

			response = (<-this.PublicGetMarketBooks(this.Extend(request, params)))
			PanicOnError(response)
		}
		//
		//     {
		//         "code": "0",
		//         "msg": "",
		//         "data": [
		//             {
		//                 "asks": [
		//                     ["0.07228","4.211619","0","2"], // price, amount, liquidated orders, total open orders
		//                     ["0.0723","299.880364","0","2"],
		//                     ["0.07231","3.72832","0","1"],
		//                 ],
		//                 "bids": [
		//                     ["0.07221","18.5","0","1"],
		//                     ["0.0722","18.5","0","1"],
		//                     ["0.07219","0.505407","0","1"],
		//                 ],
		//                 "ts": "1621438475342"
		//             }
		//         ]
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var first interface{} = this.SafeDict(data, 0, map[string]interface{}{})
		var timestamp interface{} = this.SafeInteger(first, "ts")

		ch <- this.ParseOrderBook(first, symbol, timestamp)
		return nil

	}()
	return ch
}
func (this *OkxCore) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{} {
	//
	//      {
	//          "instType":"SWAP",
	//          "instId":"BTC-USDT-SWAP",
	//          "markPx":"200",
	//          "ts":"1597026383085"
	//      }
	//
	//     {
	//         "instType": "SPOT",
	//         "instId": "ETH-BTC",
	//         "last": "0.07319",
	//         "lastSz": "0.044378",
	//         "askPx": "0.07322",
	//         "askSz": "4.2",
	//         "bidPx": "0.0732",
	//         "bidSz": "6.050058",
	//         "open24h": "0.07801",
	//         "high24h": "0.07975",
	//         "low24h": "0.06019",
	//         "volCcy24h": "11788.887619",
	//         "vol24h": "167493.829229",
	//         "ts": "1621440583784",
	//         "sodUtc0": "0.07872",
	//         "sodUtc8": "0.07345"
	//     }
	//     {
	//          instId: 'LTC-USDT',
	//          idxPx: '65.74',
	//          open24h: '65.37',
	//          high24h: '66.15',
	//          low24h: '64.97',
	//          sodUtc0: '65.68',
	//          sodUtc8: '65.54',
	//          ts: '1728467346900'
	//     },
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var timestamp interface{} = this.SafeInteger(ticker, "ts")
	var marketId interface{} = this.SafeString(ticker, "instId")
	market = this.SafeMarket(marketId, market, "-")
	var symbol interface{} = GetValue(market, "symbol")
	var last interface{} = this.SafeString(ticker, "last")
	var open interface{} = this.SafeString(ticker, "open24h")
	var spot interface{} = this.SafeBool(market, "spot", false)
	var quoteVolume interface{} = Ternary(IsTrue(spot), this.SafeString(ticker, "volCcy24h"), nil)
	var baseVolume interface{} = this.SafeString(ticker, "vol24h")
	var high interface{} = this.SafeString(ticker, "high24h")
	var low interface{} = this.SafeString(ticker, "low24h")
	return this.SafeTicker(map[string]interface{}{
		"symbol":        symbol,
		"timestamp":     timestamp,
		"datetime":      this.Iso8601(timestamp),
		"high":          high,
		"low":           low,
		"bid":           this.SafeString(ticker, "bidPx"),
		"bidVolume":     this.SafeString(ticker, "bidSz"),
		"ask":           this.SafeString(ticker, "askPx"),
		"askVolume":     this.SafeString(ticker, "askSz"),
		"vwap":          nil,
		"open":          open,
		"close":         last,
		"last":          last,
		"previousClose": nil,
		"change":        nil,
		"percentage":    nil,
		"average":       nil,
		"baseVolume":    baseVolume,
		"quoteVolume":   quoteVolume,
		"markPrice":     this.SafeString(ticker, "markPx"),
		"indexPrice":    this.SafeString(ticker, "idxPx"),
		"info":          ticker,
	}, market)
}

/**
 * @method
 * @name okx#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-market-data-get-ticker
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func (this *OkxCore) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes21748 := (<-this.LoadMarkets())
		PanicOnError(retRes21748)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"instId": GetValue(market, "id"),
		}

		response := (<-this.PublicGetMarketTicker(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "0",
		//         "msg": "",
		//         "data": [
		//             {
		//                 "instType": "SPOT",
		//                 "instId": "ETH-BTC",
		//                 "last": "0.07319",
		//                 "lastSz": "0.044378",
		//                 "askPx": "0.07322",
		//                 "askSz": "4.2",
		//                 "bidPx": "0.0732",
		//                 "bidSz": "6.050058",
		//                 "open24h": "0.07801",
		//                 "high24h": "0.07975",
		//                 "low24h": "0.06019",
		//                 "volCcy24h": "11788.887619",
		//                 "vol24h": "167493.829229",
		//                 "ts": "1621440583784",
		//                 "sodUtc0": "0.07872",
		//                 "sodUtc8": "0.07345"
		//             }
		//         ]
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var first interface{} = this.SafeDict(data, 0, map[string]interface{}{})

		ch <- this.ParseTicker(first, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-market-data-get-tickers
 * @param {string[]} [symbols] unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func (this *OkxCore) FetchTickers(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes22218 := (<-this.LoadMarkets())
		PanicOnError(retRes22218)
		symbols = this.MarketSymbols(symbols)
		var market interface{} = this.GetMarketFromSymbols(symbols)
		var marketType interface{} = nil
		marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchTickers", market, params)
		marketType = GetValue(marketTypeparamsVariable, 0)
		params = GetValue(marketTypeparamsVariable, 1)
		var request interface{} = map[string]interface{}{
			"instType": this.ConvertToInstrumentType(marketType),
		}
		if IsTrue(IsEqual(marketType, "option")) {
			var defaultUnderlying interface{} = this.SafeString(this.Options, "defaultUnderlying", "BTC-USD")
			var currencyId interface{} = this.SafeString2(params, "uly", "marketId", defaultUnderlying)
			if IsTrue(IsEqual(currencyId, nil)) {
				panic(ArgumentsRequired(Add(this.Id, " fetchTickers() requires an underlying uly or marketId parameter for options markets")))
			} else {
				AddElementToObject(request, "uly", currencyId)
			}
		}

		response := (<-this.PublicGetMarketTickers(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "0",
		//         "msg": "",
		//         "data": [
		//             {
		//                 "instType": "SPOT",
		//                 "instId": "BCD-BTC",
		//                 "last": "0.0000769",
		//                 "lastSz": "5.4788",
		//                 "askPx": "0.0000777",
		//                 "askSz": "3.2197",
		//                 "bidPx": "0.0000757",
		//                 "bidSz": "4.7509",
		//                 "open24h": "0.0000885",
		//                 "high24h": "0.0000917",
		//                 "low24h": "0.0000596",
		//                 "volCcy24h": "9.2877",
		//                 "vol24h": "124824.1985",
		//                 "ts": "1621441741434",
		//                 "sodUtc0": "0.0000905",
		//                 "sodUtc8": "0.0000729"
		//             },
		//         ]
		//     }
		//
		var tickers interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseTickers(tickers, symbols)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#fetchMarkPrice
 * @description fetches mark price for the market
 * @see https://www.okx.com/docs-v5/en/#public-data-rest-api-get-mark-price
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func (this *OkxCore) FetchMarkPrice(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes22798 := (<-this.LoadMarkets())
		PanicOnError(retRes22798)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"instId": GetValue(market, "id"),
		}

		response := (<-this.PublicGetPublicMarkPrice(this.Extend(request, params)))
		PanicOnError(response)
		//
		// {
		//     "code": "0",
		//     "data": [
		//         {
		//             "instId": "ETH-USDT",
		//             "instType": "MARGIN",
		//             "markPx": "2403.98",
		//             "ts": "1728578500703"
		//         }
		//     ],
		//     "msg": ""
		// }
		//
		var data interface{} = this.SafeList(response, "data")

		ch <- this.ParseTicker(this.SafeDict(data, 0), market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#fetchMarkPrices
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://www.okx.com/docs-v5/en/#public-data-rest-api-get-mark-price
 * @param {string[]} [symbols] unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func (this *OkxCore) FetchMarkPrices(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes23138 := (<-this.LoadMarkets())
		PanicOnError(retRes23138)
		symbols = this.MarketSymbols(symbols)
		var market interface{} = this.GetMarketFromSymbols(symbols)
		var marketType interface{} = nil
		marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchTickers", market, params, "swap")
		marketType = GetValue(marketTypeparamsVariable, 0)
		params = GetValue(marketTypeparamsVariable, 1)
		var request interface{} = map[string]interface{}{
			"instType": this.ConvertToInstrumentType(marketType),
		}
		if IsTrue(IsEqual(marketType, "option")) {
			var defaultUnderlying interface{} = this.SafeString(this.Options, "defaultUnderlying", "BTC-USD")
			var currencyId interface{} = this.SafeString2(params, "uly", "marketId", defaultUnderlying)
			if IsTrue(IsEqual(currencyId, nil)) {
				panic(ArgumentsRequired(Add(this.Id, " fetchMarkPrices() requires an underlying uly or marketId parameter for options markets")))
			} else {
				AddElementToObject(request, "uly", currencyId)
			}
		}

		response := (<-this.PublicGetPublicMarkPrice(this.Extend(request, params)))
		PanicOnError(response)
		var tickers interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseTickers(tickers, symbols)
		return nil

	}()
	return ch
}
func (this *OkxCore) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{} {
	//
	// public fetchTrades
	//
	//     {
	//         "instId": "ETH-BTC",
	//         "side": "sell",
	//         "sz": "0.119501",
	//         "px": "0.07065",
	//         "tradeId": "15826757",
	//         "ts": "1621446178316"
	//     }
	//
	// option: fetchTrades
	//
	//     {
	//         "fillVol": "0.46387625976562497",
	//         "fwdPx": "26299.754935451125",
	//         "indexPx": "26309.7",
	//         "instFamily": "BTC-USD",
	//         "instId": "BTC-USD-230526-26000-C",
	//         "markPx": "0.042386283557554236",
	//         "optType": "C",
	//         "px": "0.0415",
	//         "side": "sell",
	//         "sz": "90",
	//         "tradeId": "112",
	//         "ts": "1683907480154"
	//     }
	//
	// private fetchMyTrades
	//
	//     {
	//         "side": "buy",
	//         "fillSz": "0.007533",
	//         "fillPx": "2654.98",
	//         "fee": "-0.000007533",
	//         "ordId": "317321390244397056",
	//         "instType": "SPOT",
	//         "instId": "ETH-USDT",
	//         "clOrdId": "",
	//         "posSide": "net",
	//         "billId": "317321390265368576",
	//         "tag": "0",
	//         "execType": "T",
	//         "tradeId": "107601752",
	//         "feeCcy": "ETH",
	//         "ts": "1621927314985"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var id interface{} = this.SafeString(trade, "tradeId")
	var marketId interface{} = this.SafeString(trade, "instId")
	market = this.SafeMarket(marketId, market, "-")
	var symbol interface{} = GetValue(market, "symbol")
	var timestamp interface{} = this.SafeInteger(trade, "ts")
	var price interface{} = this.SafeString2(trade, "fillPx", "px")
	var amount interface{} = this.SafeString2(trade, "fillSz", "sz")
	var side interface{} = this.SafeString(trade, "side")
	var orderId interface{} = this.SafeString(trade, "ordId")
	var feeCostString interface{} = this.SafeString(trade, "fee")
	var fee interface{} = nil
	if IsTrue(!IsEqual(feeCostString, nil)) {
		var feeCostSigned interface{} = Precise.StringNeg(feeCostString)
		var feeCurrencyId interface{} = this.SafeString(trade, "feeCcy")
		var feeCurrencyCode interface{} = this.SafeCurrencyCode(feeCurrencyId)
		fee = map[string]interface{}{
			"cost":     feeCostSigned,
			"currency": feeCurrencyCode,
		}
	}
	var takerOrMaker interface{} = this.SafeString(trade, "execType")
	if IsTrue(IsEqual(takerOrMaker, "T")) {
		takerOrMaker = "taker"
	} else if IsTrue(IsEqual(takerOrMaker, "M")) {
		takerOrMaker = "maker"
	}
	return this.SafeTrade(map[string]interface{}{
		"info":         trade,
		"timestamp":    timestamp,
		"datetime":     this.Iso8601(timestamp),
		"symbol":       symbol,
		"id":           id,
		"order":        orderId,
		"type":         nil,
		"takerOrMaker": takerOrMaker,
		"side":         side,
		"price":        price,
		"amount":       amount,
		"cost":         nil,
		"fee":          fee,
	}, market)
}

/**
 * @method
 * @name okx#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://www.okx.com/docs-v5/en/#rest-api-market-data-get-trades
 * @see https://www.okx.com/docs-v5/en/#rest-api-public-data-get-option-trades
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.method] 'publicGetMarketTrades' or 'publicGetMarketHistoryTrades' default is 'publicGetMarketTrades'
 * @param {boolean} [params.paginate] *only applies to publicGetMarketHistoryTrades* default false, when true will automatically paginate by calling this endpoint multiple times
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func (this *OkxCore) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		since := GetArg(optionalArgs, 0, nil)
		_ = since
		limit := GetArg(optionalArgs, 1, nil)
		_ = limit
		params := GetArg(optionalArgs, 2, map[string]interface{}{})
		_ = params

		retRes24438 := (<-this.LoadMarkets())
		PanicOnError(retRes24438)
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchTrades", "paginate")
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {

			retRes244719 := (<-this.FetchPaginatedCallCursor("fetchTrades", symbol, since, limit, params, "tradeId", "after", nil, 100))
			PanicOnError(retRes244719)
			ch <- retRes244719
			return nil
		}
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"instId": GetValue(market, "id"),
		}
		var response interface{} = nil
		if IsTrue(GetValue(market, "option")) {

			response = (<-this.PublicGetPublicOptionTrades(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			if IsTrue(!IsEqual(limit, nil)) {
				AddElementToObject(request, "limit", limit) // default 100
			}
			var method interface{} = nil
			methodparamsVariable := this.HandleOptionAndParams(params, "fetchTrades", "method", "publicGetMarketTrades")
			method = GetValue(methodparamsVariable, 0)
			params = GetValue(methodparamsVariable, 1)
			if IsTrue(IsEqual(method, "publicGetMarketTrades")) {

				response = (<-this.PublicGetMarketTrades(this.Extend(request, params)))
				PanicOnError(response)
			} else if IsTrue(IsEqual(method, "publicGetMarketHistoryTrades")) {

				response = (<-this.PublicGetMarketHistoryTrades(this.Extend(request, params)))
				PanicOnError(response)
			}
		}
		//
		//     {
		//         "code": "0",
		//         "msg": "",
		//         "data": [
		//             {"instId":"ETH-BTC","side":"sell","sz":"0.119501","px":"0.07065","tradeId":"15826757","ts":"1621446178316"},
		//             {"instId":"ETH-BTC","side":"sell","sz":"0.03","px":"0.07068","tradeId":"15826756","ts":"1621446178066"},
		//             {"instId":"ETH-BTC","side":"buy","sz":"0.507","px":"0.07069","tradeId":"15826755","ts":"1621446175085"},
		//         ]
		//     }
		//
		// option
		//
		//     {
		//         "code": "0",
		//         "data": [
		//             {
		//                 "fillVol": "0.46387625976562497",
		//                 "fwdPx": "26299.754935451125",
		//                 "indexPx": "26309.7",
		//                 "instFamily": "BTC-USD",
		//                 "instId": "BTC-USD-230526-26000-C",
		//                 "markPx": "0.042386283557554236",
		//                 "optType": "C",
		//                 "px": "0.0415",
		//                 "side": "sell",
		//                 "sz": "90",
		//                 "tradeId": "112",
		//                 "ts": "1683907480154"
		//             },
		//         ],
		//         "msg": ""
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseTrades(data, market, since, limit)
		return nil

	}()
	return ch
}
func (this *OkxCore) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     [
	//         "1678928760000", // timestamp
	//         "24341.4", // open
	//         "24344", // high
	//         "24313.2", // low
	//         "24323", // close
	//         "628", // contract volume
	//         "2.5819", // base volume
	//         "62800", // quote volume
	//         "0" // candlestick state
	//     ]
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var res interface{} = this.HandleMarketTypeAndParams("fetchOHLCV", market, nil)
	var typeVar interface{} = GetValue(res, 0)
	var volumeIndex interface{} = Ternary(IsTrue((IsEqual(typeVar, "spot"))), 5, 6)
	return []interface{}{this.SafeInteger(ohlcv, 0), this.SafeNumber(ohlcv, 1), this.SafeNumber(ohlcv, 2), this.SafeNumber(ohlcv, 3), this.SafeNumber(ohlcv, 4), this.SafeNumber(ohlcv, volumeIndex)}
}

/**
 * @method
 * @name okx#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://www.okx.com/docs-v5/en/#rest-api-market-data-get-candlesticks
 * @see https://www.okx.com/docs-v5/en/#rest-api-market-data-get-candlesticks-history
 * @see https://www.okx.com/docs-v5/en/#rest-api-market-data-get-mark-price-candlesticks
 * @see https://www.okx.com/docs-v5/en/#rest-api-market-data-get-mark-price-candlesticks-history
 * @see https://www.okx.com/docs-v5/en/#rest-api-market-data-get-index-candlesticks
 * @see https://www.okx.com/docs-v5/en/#rest-api-market-data-get-index-candlesticks-history
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-market-data-get-candlesticks-history
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.price] "mark" or "index" for mark price and index price candles
 * @param {int} [params.until] timestamp in ms of the latest candle to fetch
 * @param {string} [params.type] "Candles" or "HistoryCandles", default is "Candles" for recent candles, "HistoryCandles" for older candles
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func (this *OkxCore) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		timeframe := GetArg(optionalArgs, 0, "1m")
		_ = timeframe
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes25568 := (<-this.LoadMarkets())
		PanicOnError(retRes25568)
		var market interface{} = this.Market(symbol)
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchOHLCV", "paginate")
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {

			retRes256119 := (<-this.FetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, params, 200))
			PanicOnError(retRes256119)
			ch <- retRes256119
			return nil
		}
		var priceType interface{} = this.SafeString(params, "price")
		var isMarkOrIndex interface{} = this.InArray(priceType, []interface{}{"mark", "index"})
		params = this.Omit(params, "price")
		var options interface{} = this.SafeDict(this.Options, "fetchOHLCV", map[string]interface{}{})
		var timezone interface{} = this.SafeString(options, "timezone", "UTC")
		var limitIsUndefined interface{} = (IsEqual(limit, nil))
		if IsTrue(IsEqual(limit, nil)) {
			limit = 100 // default 100, max 300
		} else {
			var maxLimit interface{} = Ternary(IsTrue(isMarkOrIndex), 100, 300) // default 300, only 100 if 'mark' or 'index'
			limit = mathMin(limit, maxLimit)
		}
		var duration interface{} = this.ParseTimeframe(timeframe)
		var bar interface{} = this.SafeString(this.Timeframes, timeframe, timeframe)
		if IsTrue(IsTrue((IsEqual(timezone, "UTC"))) && IsTrue((IsGreaterThanOrEqual(duration, 21600)))) {
			bar = Add(bar, ToLower(timezone))
		}
		var request interface{} = map[string]interface{}{
			"instId": GetValue(market, "id"),
			"bar":    bar,
			"limit":  limit,
		}
		var defaultType interface{} = "Candles"
		if IsTrue(!IsEqual(since, nil)) {
			var now interface{} = this.Milliseconds()
			var durationInMilliseconds interface{} = Multiply(duration, 1000)
			// switch to history candles if since is past the cutoff for current candles
			var historyBorder interface{} = Subtract(now, (Multiply((Subtract(1440, 1)), durationInMilliseconds)))
			if IsTrue(IsLessThan(since, historyBorder)) {
				defaultType = "HistoryCandles"
				var maxLimit interface{} = Ternary(IsTrue(isMarkOrIndex), 100, 300)
				limit = mathMin(limit, maxLimit)
			}
			var startTime interface{} = mathMax(Subtract(since, 1), 0)
			AddElementToObject(request, "before", startTime)
			AddElementToObject(request, "after", this.Sum(since, Multiply(durationInMilliseconds, limit)))
		}
		var until interface{} = this.SafeInteger(params, "until")
		if IsTrue(!IsEqual(until, nil)) {
			AddElementToObject(request, "after", until)
			params = this.Omit(params, "until")
		}
		defaultType = this.SafeString(options, "type", defaultType) // Candles or HistoryCandles
		var typeVar interface{} = this.SafeString(params, "type", defaultType)
		params = this.Omit(params, "type")
		var isHistoryCandles interface{} = (IsEqual(typeVar, "HistoryCandles"))
		var response interface{} = nil
		if IsTrue(IsEqual(priceType, "mark")) {
			if IsTrue(isHistoryCandles) {

				response = (<-this.PublicGetMarketHistoryMarkPriceCandles(this.Extend(request, params)))
				PanicOnError(response)
			} else {

				response = (<-this.PublicGetMarketMarkPriceCandles(this.Extend(request, params)))
				PanicOnError(response)
			}
		} else if IsTrue(IsEqual(priceType, "index")) {
			AddElementToObject(request, "instId", GetValue(GetValue(market, "info"), "instFamily")) // okx index candles require instFamily instead of instId
			if IsTrue(isHistoryCandles) {

				response = (<-this.PublicGetMarketHistoryIndexCandles(this.Extend(request, params)))
				PanicOnError(response)
			} else {

				response = (<-this.PublicGetMarketIndexCandles(this.Extend(request, params)))
				PanicOnError(response)
			}
		} else {
			if IsTrue(isHistoryCandles) {
				if IsTrue(IsTrue(limitIsUndefined) && IsTrue((IsEqual(limit, 100)))) {
					limit = 300
					AddElementToObject(request, "limit", 300) // reassign to 300, but this whole logic needs to be simplified...
				}

				response = (<-this.PublicGetMarketHistoryCandles(this.Extend(request, params)))
				PanicOnError(response)
			} else {

				response = (<-this.PublicGetMarketCandles(this.Extend(request, params)))
				PanicOnError(response)
			}
		}
		//
		//     {
		//         "code": "0",
		//         "msg": "",
		//         "data": [
		//             ["1678928760000","24341.4","24344","24313.2","24323","628","2.5819","62800","0"],
		//             ["1678928700000","24324.1","24347.6","24321.7","24341.4","2565","10.5401","256500","1"],
		//             ["1678928640000","24300.2","24324.1","24288","24324.1","3304","13.5937","330400","1"],
		//         ]
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseOHLCVs(data, market, timeframe, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#fetchFundingRateHistory
 * @description fetches historical funding rate prices
 * @see https://www.okx.com/docs-v5/en/#public-data-rest-api-get-funding-rate-history
 * @param {string} symbol unified symbol of the market to fetch the funding rate history for
 * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
 * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/?id=funding-rate-history-structure} to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/?id=funding-rate-history-structure}
 */
func (this *OkxCore) FetchFundingRateHistory(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchFundingRateHistory() requires a symbol argument")))
		}

		retRes26658 := (<-this.LoadMarkets())
		PanicOnError(retRes26658)
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchFundingRateHistory", "paginate")
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {

			retRes266919 := (<-this.FetchPaginatedCallDeterministic("fetchFundingRateHistory", symbol, since, limit, "8h", params, 100))
			PanicOnError(retRes266919)
			ch <- retRes266919
			return nil
		}
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"instId": GetValue(market, "id"),
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "before", mathMax(Subtract(since, 1), 0))
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}

		response := (<-this.PublicGetPublicFundingRateHistory(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code":"0",
		//         "msg":"",
		//         "data":[
		//             {
		//                 "instType":"SWAP",
		//                 "instId":"BTC-USDT-SWAP",
		//                 "fundingRate":"0.018",
		//                 "realizedRate":"0.017",
		//                 "fundingTime":"1597026383085"
		//             },
		//             {
		//                 "instType":"SWAP",
		//                 "instId":"BTC-USDT-SWAP",
		//                 "fundingRate":"0.018",
		//                 "realizedRate":"0.017",
		//                 "fundingTime":"1597026383085"
		//             }
		//         ]
		//     }
		//
		var rates interface{} = []interface{}{}
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
			var rate interface{} = GetValue(data, i)
			var timestamp interface{} = this.SafeInteger(rate, "fundingTime")
			AppendToArray(&rates, map[string]interface{}{
				"info":        rate,
				"symbol":      this.SafeSymbol(this.SafeString(rate, "instId")),
				"fundingRate": this.SafeNumber(rate, "realizedRate"),
				"timestamp":   timestamp,
				"datetime":    this.Iso8601(timestamp),
			})
		}
		var sorted interface{} = this.SortBy(rates, "timestamp")

		ch <- this.FilterBySymbolSinceLimit(sorted, GetValue(market, "symbol"), since, limit)
		return nil

	}()
	return ch
}
func (this *OkxCore) ParseBalanceByType(typeVar interface{}, response interface{}) interface{} {
	if IsTrue(IsEqual(typeVar, "funding")) {
		return this.ParseFundingBalance(response)
	} else {
		return this.ParseTradingBalance(response)
	}
}
func (this *OkxCore) ParseTradingBalance(response interface{}) interface{} {
	var result interface{} = map[string]interface{}{
		"info": response,
	}
	var data interface{} = this.SafeList(response, "data", []interface{}{})
	var first interface{} = this.SafeDict(data, 0, map[string]interface{}{})
	var timestamp interface{} = this.SafeInteger(first, "uTime")
	var details interface{} = this.SafeList(first, "details", []interface{}{})
	for i := 0; IsLessThan(i, GetArrayLength(details)); i++ {
		var balance interface{} = GetValue(details, i)
		var currencyId interface{} = this.SafeString(balance, "ccy")
		var code interface{} = this.SafeCurrencyCode(currencyId)
		var account interface{} = this.Account()
		// it may be incorrect to use total, free and used for swap accounts
		var eq interface{} = this.SafeString(balance, "eq")
		var availEq interface{} = this.SafeString(balance, "availEq")
		AddElementToObject(account, "total", eq)
		if IsTrue(IsEqual(availEq, nil)) {
			AddElementToObject(account, "free", this.SafeString(balance, "availBal"))
			AddElementToObject(account, "used", this.SafeString(balance, "frozenBal"))
		} else {
			AddElementToObject(account, "free", availEq)
		}
		AddElementToObject(result, code, account)
	}
	AddElementToObject(result, "timestamp", timestamp)
	AddElementToObject(result, "datetime", this.Iso8601(timestamp))
	return this.SafeBalance(result)
}
func (this *OkxCore) ParseFundingBalance(response interface{}) interface{} {
	var result interface{} = map[string]interface{}{
		"info": response,
	}
	var data interface{} = this.SafeList(response, "data", []interface{}{})
	for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
		var balance interface{} = GetValue(data, i)
		var currencyId interface{} = this.SafeString(balance, "ccy")
		var code interface{} = this.SafeCurrencyCode(currencyId)
		var account interface{} = this.Account()
		// it may be incorrect to use total, free and used for swap accounts
		AddElementToObject(account, "total", this.SafeString(balance, "bal"))
		AddElementToObject(account, "free", this.SafeString(balance, "availBal"))
		AddElementToObject(account, "used", this.SafeString(balance, "frozenBal"))
		AddElementToObject(result, code, account)
	}
	return this.SafeBalance(result)
}
func (this *OkxCore) ParseTradingFee(fee interface{}, optionalArgs ...interface{}) interface{} {
	// https://www.okx.com/docs-v5/en/#rest-api-account-get-fee-rates
	//
	//     {
	//         "category": "1",
	//         "delivery": "",
	//         "exercise": "",
	//         "instType": "SPOT",
	//         "level": "Lv1",
	//         "maker": "-0.0008",
	//         "taker": "-0.001",
	//         "ts": "1639043138472"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	return map[string]interface{}{
		"info":       fee,
		"symbol":     this.SafeSymbol(nil, market),
		"maker":      this.ParseNumber(Precise.StringNeg(this.SafeString2(fee, "maker", "makerU"))),
		"taker":      this.ParseNumber(Precise.StringNeg(this.SafeString2(fee, "taker", "takerU"))),
		"percentage": nil,
		"tierBased":  nil,
	}
}

/**
 * @method
 * @name okx#fetchTradingFee
 * @description fetch the trading fees for a market
 * @see https://www.okx.com/docs-v5/en/#trading-account-rest-api-get-fee-rates
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [fee structure]{@link https://docs.ccxt.com/?id=fee-structure}
 */
func (this *OkxCore) FetchTradingFee(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes28098 := (<-this.LoadMarkets())
		PanicOnError(retRes28098)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"instType": this.ConvertToInstrumentType(GetValue(market, "type")),
		}
		if IsTrue(GetValue(market, "spot")) {
			AddElementToObject(request, "instId", GetValue(market, "id"))
		} else if IsTrue(IsTrue(IsTrue(GetValue(market, "swap")) || IsTrue(GetValue(market, "future"))) || IsTrue(GetValue(market, "option"))) {
			AddElementToObject(request, "uly", Add(Add(GetValue(market, "baseId"), "-"), GetValue(market, "quoteId")))
		} else {
			panic(NotSupported(Add(this.Id, " fetchTradingFee() supports spot, swap, future or option markets only")))
		}

		response := (<-this.PrivateGetAccountTradeFee(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "0",
		//         "data": [
		//             {
		//                 "category": "1",
		//                 "delivery": "",
		//                 "exercise": "",
		//                 "instType": "SPOT",
		//                 "level": "Lv1",
		//                 "maker": "-0.0008",
		//                 "taker": "-0.001",
		//                 "ts": "1639043138472"
		//             }
		//         ],
		//         "msg": ""
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var first interface{} = this.SafeDict(data, 0, map[string]interface{}{})

		ch <- this.ParseTradingFee(first, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://www.okx.com/docs-v5/en/#funding-account-rest-api-get-balance
 * @see https://www.okx.com/docs-v5/en/#trading-account-rest-api-get-balance
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.type] wallet type, ['funding' or 'trading'] default is 'trading'
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/?id=balance-structure}
 */
func (this *OkxCore) FetchBalance(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes28598 := (<-this.LoadMarkets())
		PanicOnError(retRes28598)
		marketTypequeryVariable := this.HandleMarketTypeAndParams("fetchBalance", nil, params)
		marketType := GetValue(marketTypequeryVariable, 0)
		query := GetValue(marketTypequeryVariable, 1)
		var request interface{} = map[string]interface{}{}
		var response interface{} = nil
		if IsTrue(IsEqual(marketType, "funding")) {

			response = (<-this.PrivateGetAssetBalances(this.Extend(request, query)))
			PanicOnError(response)
		} else {

			response = (<-this.PrivateGetAccountBalance(this.Extend(request, query)))
			PanicOnError(response)
		}

		//
		//     {
		//         "code": "0",
		//         "data": [
		//             {
		//                 "adjEq": "",
		//                 "details": [
		//                     {
		//                         "availBal": "",
		//                         "availEq": "28.21006347",
		//                         "cashBal": "28.21006347",
		//                         "ccy": "USDT",
		//                         "crossLiab": "",
		//                         "disEq": "28.2687404020176",
		//                         "eq":"28 .21006347",
		//                         "eqUsd": "28.2687404020176",
		//                         "frozenBal": "0",
		//                         "interest": "",
		//                         "isoEq": "0",
		//                         "isoLiab": "",
		//                         "liab": "",
		//                         "maxLoan": "",
		//                         "mgnRatio": "",
		//                         "notionalLever": "0",
		//                         "ordFrozen": "0",
		//                         "twap": "0",
		//                         "uTime": "1621556539861",
		//                         "upl": "0",
		//                         "uplLiab": ""
		//                     }
		//                 ],
		//                 "imr": "",
		//                 "isoEq": "0",
		//                 "mgnRatio": "",
		//                 "mmr": "",
		//                 "notionalUsd": "",
		//                 "ordFroz": "",
		//                 "totalEq": "28.2687404020176",
		//                 "uTime": "1621556553510"
		//             }
		//         ],
		//         "msg": ""
		//     }
		//
		//     {
		//         "code": "0",
		//         "data": [
		//             {
		//                 "adjEq": "",
		//                 "details": [
		//                     {
		//                         "availBal": "0.049",
		//                         "availEq": "",
		//                         "cashBal": "0.049",
		//                         "ccy": "BTC",
		//                         "crossLiab": "",
		//                         "disEq": "1918.55678",
		//                         "eq": "0.049",
		//                         "eqUsd": "1918.55678",
		//                         "frozenBal": "0",
		//                         "interest": "",
		//                         "isoEq": "",
		//                         "isoLiab": "",
		//                         "liab": "",
		//                         "maxLoan": "",
		//                         "mgnRatio": "",
		//                         "notionalLever": "",
		//                         "ordFrozen": "0",
		//                         "twap": "0",
		//                         "uTime": "1621973128591",
		//                         "upl": "",
		//                         "uplLiab": ""
		//                     }
		//                 ],
		//                 "imr": "",
		//                 "isoEq": "",
		//                 "mgnRatio": "",
		//                 "mmr": "",
		//                 "notionalUsd": "",
		//                 "ordFroz": "",
		//                 "totalEq": "1918.55678",
		//                 "uTime": "1622045126908"
		//             }
		//         ],
		//         "msg": ""
		//     }
		//
		// funding
		//
		//     {
		//         "code": "0",
		//         "data": [
		//             {
		//                 "availBal": "0.00005426",
		//                 "bal": 0.0000542600000000,
		//                 "ccy": "BTC",
		//                 "frozenBal": "0"
		//             }
		//         ],
		//         "msg": ""
		//     }
		//
		ch <- this.ParseBalanceByType(marketType, response)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#createMarketBuyOrderWithCost
 * @description create a market buy order by providing the symbol and cost
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-post-place-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {float} cost how much you want to trade in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *OkxCore) CreateMarketBuyOrderWithCost(symbol interface{}, cost interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes29868 := (<-this.LoadMarkets())
		PanicOnError(retRes29868)
		var market interface{} = this.Market(symbol)
		if !IsTrue(GetValue(market, "spot")) {
			panic(NotSupported(Add(this.Id, " createMarketBuyOrderWithCost() supports spot markets only")))
		}
		var req interface{} = map[string]interface{}{
			"createMarketBuyOrderRequiresPrice": false,
			"tgtCcy":                            "quote_ccy",
		}

		retRes299515 := (<-this.CreateOrder(symbol, "market", "buy", cost, nil, this.Extend(req, params)))
		PanicOnError(retRes299515)
		ch <- retRes299515
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#createMarketSellOrderWithCost
 * @description create a market buy order by providing the symbol and cost
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-post-place-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {float} cost how much you want to trade in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *OkxCore) CreateMarketSellOrderWithCost(symbol interface{}, cost interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes30098 := (<-this.LoadMarkets())
		PanicOnError(retRes30098)
		var market interface{} = this.Market(symbol)
		if !IsTrue(GetValue(market, "spot")) {
			panic(NotSupported(Add(this.Id, " createMarketSellOrderWithCost() supports spot markets only")))
		}
		var req interface{} = map[string]interface{}{
			"createMarketBuyOrderRequiresPrice": false,
			"tgtCcy":                            "quote_ccy",
		}

		retRes301815 := (<-this.CreateOrder(symbol, "market", "sell", cost, nil, this.Extend(req, params)))
		PanicOnError(retRes301815)
		ch <- retRes301815
		return nil

	}()
	return ch
}
func (this *OkxCore) CreateOrderRequest(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{} {
	price := GetArg(optionalArgs, 0, nil)
	_ = price
	params := GetArg(optionalArgs, 1, map[string]interface{}{})
	_ = params
	var market interface{} = this.Market(symbol)
	var takeProfitPrice interface{} = this.SafeValue2(params, "takeProfitPrice", "tpTriggerPx")
	var stopLossPrice interface{} = this.SafeValue2(params, "stopLossPrice", "slTriggerPx")
	var conditional interface{} = IsTrue(IsTrue((!IsEqual(stopLossPrice, nil))) || IsTrue((!IsEqual(takeProfitPrice, nil)))) || IsTrue((IsEqual(typeVar, "conditional")))
	var request interface{} = map[string]interface{}{
		"instId":  GetValue(market, "id"),
		"side":    side,
		"ordType": typeVar,
	}
	var isConditionalOrOCO interface{} = IsTrue(conditional) || IsTrue((IsEqual(typeVar, "oco")))
	var closeFraction interface{} = this.SafeString(params, "closeFraction")
	var shouldOmitSize interface{} = IsTrue(isConditionalOrOCO) && IsTrue(!IsEqual(closeFraction, nil))
	if !IsTrue(shouldOmitSize) {
		AddElementToObject(request, "sz", this.AmountToPrecision(symbol, amount))
	}
	var spot interface{} = GetValue(market, "spot")
	var contract interface{} = GetValue(market, "contract")
	var triggerPrice interface{} = this.SafeValueN(params, []interface{}{"triggerPrice", "stopPrice", "triggerPx"})
	var timeInForce interface{} = this.SafeString(params, "timeInForce", "GTC")
	// const takeProfitPrice = this.safeValue2 (params, 'takeProfitPrice', 'tpTriggerPx');
	var tpOrdPx interface{} = this.SafeValue(params, "tpOrdPx", price)
	var tpTriggerPxType interface{} = this.SafeString(params, "tpTriggerPxType", "last")
	// const stopLossPrice = this.safeValue2 (params, 'stopLossPrice', 'slTriggerPx');
	var slOrdPx interface{} = this.SafeValue(params, "slOrdPx", price)
	var slTriggerPxType interface{} = this.SafeString(params, "slTriggerPxType", "last")
	var clientOrderId interface{} = this.SafeString2(params, "clOrdId", "clientOrderId")
	var stopLoss interface{} = this.SafeValue(params, "stopLoss")
	var takeProfit interface{} = this.SafeValue(params, "takeProfit")
	var hasStopLoss interface{} = (!IsEqual(stopLoss, nil))
	var hasTakeProfit interface{} = (!IsEqual(takeProfit, nil))
	var trailingPercent interface{} = this.SafeString2(params, "trailingPercent", "callbackRatio")
	var isTrailingPercentOrder interface{} = !IsEqual(trailingPercent, nil)
	var trailingPrice interface{} = this.SafeString2(params, "trailingPrice", "callbackSpread")
	var isTrailingPriceOrder interface{} = !IsEqual(trailingPrice, nil)
	var trigger interface{} = IsTrue((!IsEqual(triggerPrice, nil))) || IsTrue((IsEqual(typeVar, "trigger")))
	var isReduceOnly interface{} = IsTrue(this.SafeValue(params, "reduceOnly", false)) || IsTrue((!IsEqual(closeFraction, nil)))
	var defaultMarginMode interface{} = this.SafeString2(this.Options, "defaultMarginMode", "marginMode", "cross")
	var marginMode interface{} = this.SafeString2(params, "marginMode", "tdMode") // cross or isolated, tdMode not ommited so as to be extended into the request
	var margin interface{} = false
	if IsTrue(IsTrue((!IsEqual(marginMode, nil))) && IsTrue((!IsEqual(marginMode, "cash")))) {
		margin = true
	} else {
		marginMode = defaultMarginMode
		margin = this.SafeBool(params, "margin", false)
	}
	if IsTrue(spot) {
		if IsTrue(margin) {
			var defaultCurrency interface{} = Ternary(IsTrue((IsEqual(side, "buy"))), GetValue(market, "quote"), GetValue(market, "base"))
			var currency interface{} = this.SafeString(params, "ccy", defaultCurrency)
			AddElementToObject(request, "ccy", this.SafeCurrencyCode(currency))
		}
		var tradeMode interface{} = Ternary(IsTrue(margin), marginMode, "cash")
		AddElementToObject(request, "tdMode", tradeMode)
	} else if IsTrue(contract) {
		if IsTrue(IsTrue(GetValue(market, "swap")) || IsTrue(GetValue(market, "future"))) {
			var positionSide interface{} = nil
			positionSideparamsVariable := this.HandleOptionAndParams(params, "createOrder", "positionSide")
			positionSide = GetValue(positionSideparamsVariable, 0)
			params = GetValue(positionSideparamsVariable, 1)
			if IsTrue(!IsEqual(positionSide, nil)) {
				AddElementToObject(request, "posSide", positionSide)
			} else {
				var hedged interface{} = nil
				hedgedparamsVariable := this.HandleOptionAndParams(params, "createOrder", "hedged")
				hedged = GetValue(hedgedparamsVariable, 0)
				params = GetValue(hedgedparamsVariable, 1)
				if IsTrue(hedged) {
					var isBuy interface{} = (IsEqual(side, "buy"))
					var isProtective interface{} = IsTrue(IsTrue((!IsEqual(takeProfitPrice, nil))) || IsTrue((!IsEqual(stopLossPrice, nil)))) || IsTrue(isReduceOnly)
					if IsTrue(isProtective) {
						// in case of protective orders, the posSide should be opposite of position side
						// reduceOnly is emulated and not natively supported by the exchange
						AddElementToObject(request, "posSide", Ternary(IsTrue(isBuy), "short", "long"))
						if IsTrue(isReduceOnly) {
							params = this.Omit(params, "reduceOnly")
						}
					} else {
						AddElementToObject(request, "posSide", Ternary(IsTrue(isBuy), "long", "short"))
					}
				}
			}
		}
		AddElementToObject(request, "tdMode", marginMode)
	}
	var isMarketOrder interface{} = IsEqual(typeVar, "market")
	var postOnly interface{} = false
	postOnlyparamsVariable := this.HandlePostOnly(isMarketOrder, IsEqual(typeVar, "post_only"), params)
	postOnly = GetValue(postOnlyparamsVariable, 0)
	params = GetValue(postOnlyparamsVariable, 1)
	params = this.Omit(params, []interface{}{"currency", "ccy", "marginMode", "timeInForce", "stopPrice", "triggerPrice", "clientOrderId", "stopLossPrice", "takeProfitPrice", "slOrdPx", "tpOrdPx", "margin", "stopLoss", "takeProfit", "trailingPercent"})
	var ioc interface{} = IsTrue((IsEqual(timeInForce, "IOC"))) || IsTrue((IsEqual(typeVar, "ioc")))
	var fok interface{} = IsTrue((IsEqual(timeInForce, "FOK"))) || IsTrue((IsEqual(typeVar, "fok")))
	// const conditional = (stopLossPrice !== undefined) || (takeProfitPrice !== undefined) || (type === 'conditional');
	var marketIOC interface{} = IsTrue((IsTrue(isMarketOrder) && IsTrue(ioc))) || IsTrue((IsEqual(typeVar, "optimal_limit_ioc")))
	var defaultTgtCcy interface{} = this.SafeString(this.Options, "tgtCcy", "base_ccy")
	var tgtCcy interface{} = this.SafeString(params, "tgtCcy", defaultTgtCcy)
	if IsTrue(IsTrue((!IsTrue(contract))) && IsTrue((!IsTrue(margin)))) {
		AddElementToObject(request, "tgtCcy", tgtCcy)
	}
	if IsTrue(IsTrue(isMarketOrder) || IsTrue(marketIOC)) {
		AddElementToObject(request, "ordType", "market")
		if IsTrue(IsTrue(spot) && IsTrue((IsEqual(side, "buy")))) {
			// spot market buy: "sz" can refer either to base currency units or to quote currency units
			// see documentation: https://www.okx.com/docs-v5/en/#rest-api-trade-place-order
			if IsTrue(IsEqual(tgtCcy, "quote_ccy")) {
				// quote_ccy: sz refers to units of quote currency
				var createMarketBuyOrderRequiresPrice interface{} = true
				createMarketBuyOrderRequiresPriceparamsVariable := this.HandleOptionAndParams(params, "createOrder", "createMarketBuyOrderRequiresPrice", true)
				createMarketBuyOrderRequiresPrice = GetValue(createMarketBuyOrderRequiresPriceparamsVariable, 0)
				params = GetValue(createMarketBuyOrderRequiresPriceparamsVariable, 1)
				var notional interface{} = this.SafeNumber2(params, "cost", "sz")
				params = this.Omit(params, []interface{}{"cost", "sz"})
				if IsTrue(createMarketBuyOrderRequiresPrice) {
					if IsTrue(!IsEqual(price, nil)) {
						if IsTrue(IsEqual(notional, nil)) {
							var amountString interface{} = this.NumberToString(amount)
							var priceString interface{} = this.NumberToString(price)
							var quoteAmount interface{} = Precise.StringMul(amountString, priceString)
							notional = this.ParseNumber(quoteAmount)
						}
					} else if IsTrue(IsEqual(notional, nil)) {
						panic(InvalidOrder(Add(this.Id, " createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options[\\'createMarketBuyOrderRequiresPrice\\'] = false and supply the total cost value in the \\'amount\\' argument or in the \\'cost\\' unified extra parameter or in exchange-specific \\'sz\\' extra parameter (the exchange-specific behaviour)")))
					}
				} else {
					notional = Ternary(IsTrue((IsEqual(notional, nil))), amount, notional)
				}
				AddElementToObject(request, "sz", this.CostToPrecision(symbol, notional))
			}
		}
		if IsTrue(IsTrue(marketIOC) && IsTrue(contract)) {
			AddElementToObject(request, "ordType", "optimal_limit_ioc")
		}
	} else {
		if IsTrue(IsTrue((!IsTrue(trigger))) && IsTrue((!IsTrue(conditional)))) {
			AddElementToObject(request, "px", this.PriceToPrecision(symbol, price))
		}
	}
	if IsTrue(postOnly) {
		AddElementToObject(request, "ordType", "post_only")
	} else if IsTrue(IsTrue(ioc) && !IsTrue(marketIOC)) {
		AddElementToObject(request, "ordType", "ioc")
	} else if IsTrue(fok) {
		AddElementToObject(request, "ordType", "fok")
	}
	if IsTrue(isTrailingPercentOrder) {
		var convertedTrailingPercent interface{} = Precise.StringDiv(trailingPercent, "100")
		AddElementToObject(request, "callbackRatio", convertedTrailingPercent)
		AddElementToObject(request, "ordType", "move_order_stop")
	} else if IsTrue(isTrailingPriceOrder) {
		AddElementToObject(request, "callbackSpread", trailingPrice)
		AddElementToObject(request, "ordType", "move_order_stop")
	} else if IsTrue(IsTrue(hasStopLoss) || IsTrue(hasTakeProfit)) {
		var attachAlgoOrd interface{} = map[string]interface{}{}
		if IsTrue(hasStopLoss) {
			var stopLossTriggerPrice interface{} = this.SafeValueN(stopLoss, []interface{}{"triggerPrice", "stopPrice", "slTriggerPx"})
			if IsTrue(IsEqual(stopLossTriggerPrice, nil)) {
				panic(InvalidOrder(Add(this.Id, " createOrder() requires a trigger price in params[\"stopLoss\"][\"triggerPrice\"], or params[\"stopLoss\"][\"stopPrice\"], or params[\"stopLoss\"][\"slTriggerPx\"] for a stop loss order")))
			}
			var slTriggerPx interface{} = this.PriceToPrecision(symbol, stopLossTriggerPrice)
			var slOrder interface{} = map[string]interface{}{}
			AddElementToObject(slOrder, "slTriggerPx", slTriggerPx)
			var stopLossLimitPrice interface{} = this.SafeValueN(stopLoss, []interface{}{"price", "stopLossPrice", "slOrdPx"})
			var stopLossOrderType interface{} = this.SafeString(stopLoss, "type")
			if IsTrue(!IsEqual(stopLossOrderType, nil)) {
				var stopLossLimitOrderType interface{} = (IsEqual(stopLossOrderType, "limit"))
				var stopLossMarketOrderType interface{} = (IsEqual(stopLossOrderType, "market"))
				if IsTrue(IsTrue((!IsTrue(stopLossLimitOrderType))) && IsTrue((!IsTrue(stopLossMarketOrderType)))) {
					panic(InvalidOrder(Add(this.Id, " createOrder() params[\"stopLoss\"][\"type\"] must be either \"limit\" or \"market\"")))
				} else if IsTrue(stopLossLimitOrderType) {
					if IsTrue(IsEqual(stopLossLimitPrice, nil)) {
						panic(InvalidOrder(Add(this.Id, " createOrder() requires a limit price in params[\"stopLoss\"][\"price\"] or params[\"stopLoss\"][\"slOrdPx\"] for a stop loss limit order")))
					} else {
						AddElementToObject(slOrder, "slOrdPx", this.PriceToPrecision(symbol, stopLossLimitPrice))
					}
				} else if IsTrue(IsEqual(stopLossOrderType, "market")) {
					AddElementToObject(slOrder, "slOrdPx", "-1")
				}
			} else if IsTrue(!IsEqual(stopLossLimitPrice, nil)) {
				AddElementToObject(slOrder, "slOrdPx", this.PriceToPrecision(symbol, stopLossLimitPrice)) // limit sl order
			} else {
				AddElementToObject(slOrder, "slOrdPx", "-1") // market sl order
			}
			var stopLossTriggerPriceType interface{} = this.SafeString2(stopLoss, "triggerPriceType", "slTriggerPxType", "last")
			if IsTrue(!IsEqual(stopLossTriggerPriceType, nil)) {
				if IsTrue(IsTrue(IsTrue((!IsEqual(stopLossTriggerPriceType, "last"))) && IsTrue((!IsEqual(stopLossTriggerPriceType, "index")))) && IsTrue((!IsEqual(stopLossTriggerPriceType, "mark")))) {
					panic(InvalidOrder(Add(this.Id, " createOrder() stop loss trigger price type must be one of \"last\", \"index\" or \"mark\"")))
				}
				AddElementToObject(slOrder, "slTriggerPxType", stopLossTriggerPriceType)
			}
			attachAlgoOrd = this.Extend(attachAlgoOrd, slOrder)
		}
		if IsTrue(hasTakeProfit) {
			var takeProfitTriggerPrice interface{} = this.SafeValueN(takeProfit, []interface{}{"triggerPrice", "stopPrice", "tpTriggerPx"})
			if IsTrue(IsEqual(takeProfitTriggerPrice, nil)) {
				panic(InvalidOrder(Add(this.Id, " createOrder() requires a trigger price in params[\"takeProfit\"][\"triggerPrice\"], or params[\"takeProfit\"][\"stopPrice\"], or params[\"takeProfit\"][\"tpTriggerPx\"] for a take profit order")))
			}
			var tpOrder interface{} = map[string]interface{}{}
			AddElementToObject(tpOrder, "tpTriggerPx", this.PriceToPrecision(symbol, takeProfitTriggerPrice))
			var takeProfitLimitPrice interface{} = this.SafeValueN(takeProfit, []interface{}{"price", "takeProfitPrice", "tpOrdPx"})
			var takeProfitOrderType interface{} = this.SafeString2(takeProfit, "type", "tpOrdKind")
			if IsTrue(!IsEqual(takeProfitOrderType, nil)) {
				var takeProfitLimitOrderType interface{} = (IsEqual(takeProfitOrderType, "limit"))
				var takeProfitMarketOrderType interface{} = (IsEqual(takeProfitOrderType, "market"))
				if IsTrue(IsTrue((!IsTrue(takeProfitLimitOrderType))) && IsTrue((!IsTrue(takeProfitMarketOrderType)))) {
					panic(InvalidOrder(Add(this.Id, " createOrder() params[\"takeProfit\"][\"type\"] must be either \"limit\" or \"market\"")))
				} else if IsTrue(takeProfitLimitOrderType) {
					if IsTrue(IsEqual(takeProfitLimitPrice, nil)) {
						panic(InvalidOrder(Add(this.Id, " createOrder() requires a limit price in params[\"takeProfit\"][\"price\"] or params[\"takeProfit\"][\"tpOrdPx\"] for a take profit limit order")))
					} else {
						AddElementToObject(tpOrder, "tpOrdKind", takeProfitOrderType)
						AddElementToObject(tpOrder, "tpOrdPx", this.PriceToPrecision(symbol, takeProfitLimitPrice))
					}
				} else if IsTrue(IsEqual(takeProfitOrderType, "market")) {
					AddElementToObject(tpOrder, "tpOrdPx", "-1")
				}
			} else if IsTrue(!IsEqual(takeProfitLimitPrice, nil)) {
				AddElementToObject(tpOrder, "tpOrdKind", "limit")
				AddElementToObject(tpOrder, "tpOrdPx", this.PriceToPrecision(symbol, takeProfitLimitPrice)) // limit tp order
			} else {
				AddElementToObject(tpOrder, "tpOrdPx", "-1") // market tp order
			}
			var takeProfitTriggerPriceType interface{} = this.SafeString2(takeProfit, "triggerPriceType", "tpTriggerPxType", "last")
			if IsTrue(!IsEqual(takeProfitTriggerPriceType, nil)) {
				if IsTrue(IsTrue(IsTrue((!IsEqual(takeProfitTriggerPriceType, "last"))) && IsTrue((!IsEqual(takeProfitTriggerPriceType, "index")))) && IsTrue((!IsEqual(takeProfitTriggerPriceType, "mark")))) {
					panic(InvalidOrder(Add(this.Id, " createOrder() take profit trigger price type must be one of \"last\", \"index\" or \"mark\"")))
				}
				AddElementToObject(tpOrder, "tpTriggerPxType", takeProfitTriggerPriceType)
			}
			attachAlgoOrd = this.Extend(attachAlgoOrd, tpOrder)
		}
		var attachOrdKeys interface{} = ObjectKeys(attachAlgoOrd)
		var attachOrdLen interface{} = GetArrayLength(attachOrdKeys)
		if IsTrue(IsGreaterThan(attachOrdLen, 0)) {
			AddElementToObject(request, "attachAlgoOrds", []interface{}{attachAlgoOrd})
		}
	}
	// algo order details
	if IsTrue(trigger) {
		AddElementToObject(request, "ordType", "trigger")
		AddElementToObject(request, "triggerPx", this.PriceToPrecision(symbol, triggerPrice))
		AddElementToObject(request, "orderPx", Ternary(IsTrue(isMarketOrder), "-1", this.PriceToPrecision(symbol, price)))
	} else if IsTrue(conditional) {
		AddElementToObject(request, "ordType", "conditional")
		var twoWayCondition interface{} = (IsTrue((!IsEqual(takeProfitPrice, nil))) && IsTrue((!IsEqual(stopLossPrice, nil))))
		// if TP and SL are sent together
		// as ordType 'conditional' only stop-loss order will be applied
		// tpOrdKind is 'condition' which is the default
		if IsTrue(twoWayCondition) {
			AddElementToObject(request, "ordType", "oco")
		}
		if IsTrue(IsEqual(side, "sell")) {
			request = this.Omit(request, "tgtCcy")
		}
		if IsTrue(IsEqual(this.SafeString(request, "tdMode"), "cash")) {
			// for some reason tdMode = cash throws
			// {"code":"1","data":[{"algoClOrdId":"","algoId":"","clOrdId":"","sCode":"51000","sMsg":"Parameter tdMode error ","tag":""}],"msg":""}
			AddElementToObject(request, "tdMode", marginMode)
		}
		if IsTrue(!IsEqual(takeProfitPrice, nil)) {
			AddElementToObject(request, "tpTriggerPx", this.PriceToPrecision(symbol, takeProfitPrice))
			var tpOrdPxReq interface{} = "-1"
			if IsTrue(!IsEqual(tpOrdPx, nil)) {
				tpOrdPxReq = this.PriceToPrecision(symbol, tpOrdPx)
			}
			AddElementToObject(request, "tpOrdPx", tpOrdPxReq)
			AddElementToObject(request, "tpTriggerPxType", tpTriggerPxType)
		}
		if IsTrue(!IsEqual(stopLossPrice, nil)) {
			AddElementToObject(request, "slTriggerPx", this.PriceToPrecision(symbol, stopLossPrice))
			var slOrdPxReq interface{} = "-1"
			if IsTrue(!IsEqual(slOrdPx, nil)) {
				slOrdPxReq = this.PriceToPrecision(symbol, slOrdPx)
			}
			AddElementToObject(request, "slOrdPx", slOrdPxReq)
			AddElementToObject(request, "slTriggerPxType", slTriggerPxType)
		}
	}
	if IsTrue(IsEqual(clientOrderId, nil)) {
		var brokerId interface{} = this.SafeString(this.Options, "brokerId")
		if IsTrue(!IsEqual(brokerId, nil)) {
			AddElementToObject(request, "clOrdId", Add(brokerId, this.Uuid16()))
			AddElementToObject(request, "tag", brokerId)
		}
	} else {
		AddElementToObject(request, "clOrdId", clientOrderId)
		params = this.Omit(params, []interface{}{"clOrdId", "clientOrderId"})
	}
	return this.Extend(request, params)
}

/**
 * @method
 * @name okx#createOrder
 * @description create a trade order
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-post-place-order
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-post-place-multiple-orders
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-algo-trading-post-place-algo-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {bool} [params.reduceOnly] a mark to reduce the position size for margin, swap and future orders
 * @param {bool} [params.postOnly] true to place a post only order
 * @param {object} [params.takeProfit] *takeProfit object in params* containing the triggerPrice at which the attached take profit order will be triggered (perpetual swap markets only)
 * @param {float} [params.takeProfit.triggerPrice] take profit trigger price
 * @param {float} [params.takeProfit.price] used for take profit limit orders, not used for take profit market price orders
 * @param {string} [params.takeProfit.type] 'market' or 'limit' used to specify the take profit price type
 * @param {object} [params.stopLoss] *stopLoss object in params* containing the triggerPrice at which the attached stop loss order will be triggered (perpetual swap markets only)
 * @param {float} [params.stopLoss.triggerPrice] stop loss trigger price
 * @param {float} [params.stopLoss.price] used for stop loss limit orders, not used for stop loss market price orders
 * @param {string} [params.stopLoss.type] 'market' or 'limit' used to specify the stop loss price type
 * @param {string} [params.positionSide] if position mode is one-way: set to 'net', if position mode is hedge-mode: set to 'long' or 'short'
 * @param {string} [params.trailingPercent] the percent to trail away from the current market price
 * @param {string} [params.tpOrdKind] 'condition' or 'limit', the default is 'condition'
 * @param {bool} [params.hedged] *swap and future only* true for hedged mode, false for one way mode
 * @param {string} [params.marginMode] 'cross' or 'isolated', the default is 'cross'
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *OkxCore) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		price := GetArg(optionalArgs, 0, nil)
		_ = price
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes33568 := (<-this.LoadMarkets())
		PanicOnError(retRes33568)
		var market interface{} = this.Market(symbol)
		var request interface{} = this.CreateOrderRequest(symbol, typeVar, side, amount, price, params)
		var method interface{} = this.SafeString(this.Options, "createOrder", "privatePostTradeBatchOrders")
		var requestOrdType interface{} = this.SafeString(request, "ordType")
		if IsTrue(IsTrue(IsTrue(IsTrue(IsTrue(IsTrue(IsTrue((IsEqual(requestOrdType, "trigger"))) || IsTrue((IsEqual(requestOrdType, "conditional")))) || IsTrue((IsEqual(requestOrdType, "move_order_stop")))) || IsTrue((IsEqual(typeVar, "move_order_stop")))) || IsTrue((IsEqual(typeVar, "oco")))) || IsTrue((IsEqual(typeVar, "iceberg")))) || IsTrue((IsEqual(typeVar, "twap")))) {
			method = "privatePostTradeOrderAlgo"
		}
		if IsTrue(IsTrue(IsTrue((!IsEqual(method, "privatePostTradeOrder"))) && IsTrue((!IsEqual(method, "privatePostTradeOrderAlgo")))) && IsTrue((!IsEqual(method, "privatePostTradeBatchOrders")))) {
			panic(ExchangeError(Add(this.Id, " createOrder() this.options[\"createOrder\"] must be either privatePostTradeBatchOrders or privatePostTradeOrder or privatePostTradeOrderAlgo")))
		}
		if IsTrue(IsEqual(method, "privatePostTradeBatchOrders")) {
			// keep the request body the same
			// submit a single order in an array to the batch order endpoint
			// because it has a lower ratelimit
			request = []interface{}{request}
		}
		var response interface{} = nil
		if IsTrue(IsEqual(method, "privatePostTradeOrder")) {

			response = (<-this.PrivatePostTradeOrder(request))
			PanicOnError(response)
		} else if IsTrue(IsEqual(method, "privatePostTradeOrderAlgo")) {

			response = (<-this.PrivatePostTradeOrderAlgo(request))
			PanicOnError(response)
		} else {

			response = (<-this.PrivatePostTradeBatchOrders(request))
			PanicOnError(response)
		}
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var first interface{} = this.SafeDict(data, 0, map[string]interface{}{})
		var order interface{} = this.ParseOrder(first, market)
		AddElementToObject(order, "type", typeVar)
		AddElementToObject(order, "side", side)

		ch <- order
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#createOrders
 * @description create a list of trade orders
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-post-place-multiple-orders
 * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *OkxCore) CreateOrders(orders interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes33998 := (<-this.LoadMarkets())
		PanicOnError(retRes33998)
		var ordersRequests interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(orders)); i++ {
			var rawOrder interface{} = GetValue(orders, i)
			var marketId interface{} = this.SafeString(rawOrder, "symbol")
			var typeVar interface{} = this.SafeString(rawOrder, "type")
			var side interface{} = this.SafeString(rawOrder, "side")
			var amount interface{} = this.SafeValue(rawOrder, "amount")
			var price interface{} = this.SafeValue(rawOrder, "price")
			var orderParams interface{} = this.SafeDict(rawOrder, "params", map[string]interface{}{})
			var extendedParams interface{} = this.Extend(orderParams, params) // the request does not accept extra params since it's a list, so we're extending each order with the common params
			var orderRequest interface{} = this.CreateOrderRequest(marketId, typeVar, side, amount, price, extendedParams)
			AppendToArray(&ordersRequests, orderRequest)
		}

		response := (<-this.PrivatePostTradeBatchOrders(ordersRequests))
		PanicOnError(response)
		// {
		//     "code": "0",
		//     "data": [
		//        {
		//           "clOrdId": "e847386590ce4dBCc7f2a1b4c4509f82",
		//           "ordId": "636305438765568000",
		//           "sCode": "0",
		//           "sMsg": "Order placed",
		//           "tag": "e847386590ce4dBC"
		//        },
		//        {
		//           "clOrdId": "e847386590ce4dBC0b9993fe642d8f62",
		//           "ordId": "636305438765568001",
		//           "sCode": "0",
		//           "sMsg": "Order placed",
		//           "tag": "e847386590ce4dBC"
		//        }
		//     ],
		//     "inTime": "1697979038584486",
		//     "msg": "",
		//     "outTime": "1697979038586493"
		// }
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseOrders(data)
		return nil

	}()
	return ch
}
func (this *OkxCore) EditOrderRequest(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) interface{} {
	amount := GetArg(optionalArgs, 0, nil)
	_ = amount
	price := GetArg(optionalArgs, 1, nil)
	_ = price
	params := GetArg(optionalArgs, 2, map[string]interface{}{})
	_ = params
	var market interface{} = this.Market(symbol)
	var request interface{} = map[string]interface{}{
		"instId": GetValue(market, "id"),
	}
	var isAlgoOrder interface{} = nil
	if IsTrue(IsTrue(IsTrue(IsTrue(IsTrue(IsTrue((IsEqual(typeVar, "trigger"))) || IsTrue((IsEqual(typeVar, "conditional")))) || IsTrue((IsEqual(typeVar, "move_order_stop")))) || IsTrue((IsEqual(typeVar, "oco")))) || IsTrue((IsEqual(typeVar, "iceberg")))) || IsTrue((IsEqual(typeVar, "twap")))) {
		isAlgoOrder = true
	}
	var clientOrderId interface{} = this.SafeString2(params, "clOrdId", "clientOrderId")
	if IsTrue(!IsEqual(clientOrderId, nil)) {
		if IsTrue(isAlgoOrder) {
			AddElementToObject(request, "algoClOrdId", clientOrderId)
		} else {
			AddElementToObject(request, "clOrdId", clientOrderId)
		}
	} else {
		if IsTrue(isAlgoOrder) {
			AddElementToObject(request, "algoId", id)
		} else {
			AddElementToObject(request, "ordId", id)
		}
	}
	var stopLossTriggerPrice interface{} = this.SafeValue2(params, "stopLossPrice", "newSlTriggerPx")
	var stopLossPrice interface{} = this.SafeValue(params, "newSlOrdPx")
	var stopLossTriggerPriceType interface{} = this.SafeString(params, "newSlTriggerPxType", "last")
	var takeProfitTriggerPrice interface{} = this.SafeValue2(params, "takeProfitPrice", "newTpTriggerPx")
	var takeProfitPrice interface{} = this.SafeValue(params, "newTpOrdPx")
	var takeProfitTriggerPriceType interface{} = this.SafeString(params, "newTpTriggerPxType", "last")
	var stopLoss interface{} = this.SafeValue(params, "stopLoss")
	var takeProfit interface{} = this.SafeValue(params, "takeProfit")
	var hasStopLoss interface{} = (!IsEqual(stopLoss, nil))
	var hasTakeProfit interface{} = (!IsEqual(takeProfit, nil))
	if IsTrue(isAlgoOrder) {
		if IsTrue(IsTrue((IsEqual(stopLossTriggerPrice, nil))) && IsTrue((IsEqual(takeProfitTriggerPrice, nil)))) {
			panic(BadRequest(Add(this.Id, " editOrder() requires a stopLossPrice or takeProfitPrice parameter for editing an algo order")))
		}
		if IsTrue(!IsEqual(stopLossTriggerPrice, nil)) {
			if IsTrue(IsEqual(stopLossPrice, nil)) {
				panic(BadRequest(Add(this.Id, " editOrder() requires a newSlOrdPx parameter for editing an algo order")))
			}
			AddElementToObject(request, "newSlTriggerPx", this.PriceToPrecision(symbol, stopLossTriggerPrice))
			AddElementToObject(request, "newSlOrdPx", Ternary(IsTrue((IsEqual(typeVar, "market"))), "-1", this.PriceToPrecision(symbol, stopLossPrice)))
			AddElementToObject(request, "newSlTriggerPxType", stopLossTriggerPriceType)
		}
		if IsTrue(!IsEqual(takeProfitTriggerPrice, nil)) {
			if IsTrue(IsEqual(takeProfitPrice, nil)) {
				panic(BadRequest(Add(this.Id, " editOrder() requires a newTpOrdPx parameter for editing an algo order")))
			}
			AddElementToObject(request, "newTpTriggerPx", this.PriceToPrecision(symbol, takeProfitTriggerPrice))
			AddElementToObject(request, "newTpOrdPx", Ternary(IsTrue((IsEqual(typeVar, "market"))), "-1", this.PriceToPrecision(symbol, takeProfitPrice)))
			AddElementToObject(request, "newTpTriggerPxType", takeProfitTriggerPriceType)
		}
	} else {
		if IsTrue(!IsEqual(stopLossTriggerPrice, nil)) {
			AddElementToObject(request, "newSlTriggerPx", this.PriceToPrecision(symbol, stopLossTriggerPrice))
			AddElementToObject(request, "newSlOrdPx", Ternary(IsTrue((IsEqual(typeVar, "market"))), "-1", this.PriceToPrecision(symbol, stopLossPrice)))
			AddElementToObject(request, "newSlTriggerPxType", stopLossTriggerPriceType)
		}
		if IsTrue(!IsEqual(takeProfitTriggerPrice, nil)) {
			AddElementToObject(request, "newTpTriggerPx", this.PriceToPrecision(symbol, takeProfitTriggerPrice))
			AddElementToObject(request, "newTpOrdPx", Ternary(IsTrue((IsEqual(typeVar, "market"))), "-1", this.PriceToPrecision(symbol, takeProfitPrice)))
			AddElementToObject(request, "newTpTriggerPxType", takeProfitTriggerPriceType)
		}
		if IsTrue(hasStopLoss) {
			stopLossTriggerPrice = this.SafeValue(stopLoss, "triggerPrice")
			stopLossPrice = this.SafeValue(stopLoss, "price")
			var stopLossType interface{} = this.SafeString(stopLoss, "type")
			AddElementToObject(request, "newSlTriggerPx", this.PriceToPrecision(symbol, stopLossTriggerPrice))
			AddElementToObject(request, "newSlOrdPx", Ternary(IsTrue((IsEqual(stopLossType, "market"))), "-1", this.PriceToPrecision(symbol, stopLossPrice)))
			AddElementToObject(request, "newSlTriggerPxType", stopLossTriggerPriceType)
		}
		if IsTrue(hasTakeProfit) {
			takeProfitTriggerPrice = this.SafeValue(takeProfit, "triggerPrice")
			takeProfitPrice = this.SafeValue(takeProfit, "price")
			var takeProfitType interface{} = this.SafeString(takeProfit, "type")
			AddElementToObject(request, "newTpOrdKind", Ternary(IsTrue((IsEqual(takeProfitType, "limit"))), takeProfitType, "condition"))
			AddElementToObject(request, "newTpTriggerPx", this.PriceToPrecision(symbol, takeProfitTriggerPrice))
			AddElementToObject(request, "newTpOrdPx", Ternary(IsTrue((IsEqual(takeProfitType, "market"))), "-1", this.PriceToPrecision(symbol, takeProfitPrice)))
			AddElementToObject(request, "newTpTriggerPxType", takeProfitTriggerPriceType)
		}
	}
	if IsTrue(!IsEqual(amount, nil)) {
		AddElementToObject(request, "newSz", this.AmountToPrecision(symbol, amount))
	}
	if !IsTrue(isAlgoOrder) {
		if IsTrue(!IsEqual(price, nil)) {
			AddElementToObject(request, "newPx", this.PriceToPrecision(symbol, price))
		}
	}
	params = this.Omit(params, []interface{}{"clOrdId", "clientOrderId", "takeProfitPrice", "stopLossPrice", "stopLoss", "takeProfit", "postOnly"})
	return this.Extend(request, params)
}

/**
 * @method
 * @name okx#editOrder
 * @description edit a trade order
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-post-amend-order
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-algo-trading-post-amend-algo-order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of the currency you want to trade in units of the base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.clientOrderId] client order id, uses id if not passed
 * @param {float} [params.stopLossPrice] stop loss trigger price
 * @param {float} [params.newSlOrdPx] the stop loss order price, set to stopLossPrice if the type is market
 * @param {string} [params.newSlTriggerPxType] 'last', 'index' or 'mark' used to specify the stop loss trigger price type, default is 'last'
 * @param {float} [params.takeProfitPrice] take profit trigger price
 * @param {float} [params.newTpOrdPx] the take profit order price, set to takeProfitPrice if the type is market
 * @param {string} [params.newTpTriggerPxType] 'last', 'index' or 'mark' used to specify the take profit trigger price type, default is 'last'
 * @param {object} [params.stopLoss] *stopLoss object in params* containing the triggerPrice at which the attached stop loss order will be triggered
 * @param {float} [params.stopLoss.triggerPrice] stop loss trigger price
 * @param {float} [params.stopLoss.price] used for stop loss limit orders, not used for stop loss market price orders
 * @param {string} [params.stopLoss.type] 'market' or 'limit' used to specify the stop loss price type
 * @param {object} [params.takeProfit] *takeProfit object in params* containing the triggerPrice at which the attached take profit order will be triggered
 * @param {float} [params.takeProfit.triggerPrice] take profit trigger price
 * @param {float} [params.takeProfit.price] used for take profit limit orders, not used for take profit market price orders
 * @param {string} [params.takeProfit.type] 'market' or 'limit' used to specify the take profit price type
 * @param {string} [params.newTpOrdKind] 'condition' or 'limit', the default is 'condition'
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *OkxCore) EditOrder(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		amount := GetArg(optionalArgs, 0, nil)
		_ = amount
		price := GetArg(optionalArgs, 1, nil)
		_ = price
		params := GetArg(optionalArgs, 2, map[string]interface{}{})
		_ = params

		retRes35668 := (<-this.LoadMarkets())
		PanicOnError(retRes35668)
		var market interface{} = this.Market(symbol)
		var request interface{} = this.EditOrderRequest(id, symbol, typeVar, side, amount, price, params)
		var isAlgoOrder interface{} = nil
		if IsTrue(IsTrue(IsTrue(IsTrue(IsTrue(IsTrue((IsEqual(typeVar, "trigger"))) || IsTrue((IsEqual(typeVar, "conditional")))) || IsTrue((IsEqual(typeVar, "move_order_stop")))) || IsTrue((IsEqual(typeVar, "oco")))) || IsTrue((IsEqual(typeVar, "iceberg")))) || IsTrue((IsEqual(typeVar, "twap")))) {
			isAlgoOrder = true
		}
		var response interface{} = nil
		if IsTrue(isAlgoOrder) {

			response = (<-this.PrivatePostTradeAmendAlgos(this.Extend(request, params)))
			PanicOnError(response)
		} else {

			response = (<-this.PrivatePostTradeAmendOrder(this.Extend(request, params)))
			PanicOnError(response)
		}
		//
		//     {
		//        "code": "0",
		//        "data": [
		//            {
		//                 "clOrdId": "e847386590ce4dBCc1a045253497a547",
		//                 "ordId": "559176536793178112",
		//                 "reqId": "",
		//                 "sCode": "0",
		//                 "sMsg": ""
		//            }
		//        ],
		//        "msg": ""
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var first interface{} = this.SafeDict(data, 0, map[string]interface{}{})
		var order interface{} = this.ParseOrder(first, market)
		AddElementToObject(order, "type", typeVar)
		AddElementToObject(order, "side", side)

		ch <- order
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#cancelOrder
 * @description cancels an open order
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-post-cancel-order
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-algo-trading-post-cancel-algo-order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] true if trigger orders
 * @param {boolean} [params.trailing] set to true if you want to cancel a trailing order
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *OkxCore) CancelOrder(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " cancelOrder() requires a symbol argument")))
		}
		var trigger interface{} = this.SafeValue2(params, "stop", "trigger")
		var trailing interface{} = this.SafeBool(params, "trailing", false)
		if IsTrue(IsTrue(trigger) || IsTrue(trailing)) {

			orderInner := (<-this.CancelOrders([]interface{}{id}, symbol, params))
			PanicOnError(orderInner)

			ch <- this.SafeDict(orderInner, 0)
			return nil
		}

		retRes36258 := (<-this.LoadMarkets())
		PanicOnError(retRes36258)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"instId": GetValue(market, "id"),
		}
		var clientOrderId interface{} = this.SafeString2(params, "clOrdId", "clientOrderId")
		if IsTrue(!IsEqual(clientOrderId, nil)) {
			AddElementToObject(request, "clOrdId", clientOrderId)
		} else {
			AddElementToObject(request, "ordId", id)
		}
		var query interface{} = this.Omit(params, []interface{}{"clOrdId", "clientOrderId"})

		response := (<-this.PrivatePostTradeCancelOrder(this.Extend(request, query)))
		PanicOnError(response)
		// {"code":"0","data":[{"clOrdId":"","ordId":"317251910906576896","sCode":"0","sMsg":""}],"msg":""}
		var data interface{} = this.SafeValue(response, "data", []interface{}{})
		var order interface{} = this.SafeDict(data, 0)

		ch <- this.ParseOrder(order, market)
		return nil

	}()
	return ch
}
func (this *OkxCore) ParseIds(ids interface{}) interface{} {
	/**
	 * @ignore
	 * @method
	 * @name okx#parseIds
	 * @param {string[]|string} ids order ids
	 * @returns {string[]} list of order ids
	 */
	if IsTrue(IsTrue((!IsEqual(ids, nil))) && IsTrue(IsString(ids))) {
		return Split(ids, ",")
	} else {
		return ids
	}
}

/**
 * @method
 * @name okx#cancelOrders
 * @description cancel multiple orders
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-post-cancel-multiple-orders
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-algo-trading-post-cancel-algo-order
 * @param {string[]} ids order ids
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] whether the order is a stop/trigger order
 * @param {boolean} [params.trailing] set to true if you want to cancel trailing orders
 * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *OkxCore) CancelOrders(ids interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		// TODO : the original endpoint signature differs, according to that you can skip individual symbol and assign ids in batch. At this moment, `params` is not being used too.
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " cancelOrders() requires a symbol argument")))
		}

		retRes36798 := (<-this.LoadMarkets())
		PanicOnError(retRes36798)
		var market interface{} = this.Market(symbol)
		var request interface{} = []interface{}{}
		var options interface{} = this.SafeValue(this.Options, "cancelOrders", map[string]interface{}{})
		var defaultMethod interface{} = this.SafeString(options, "method", "privatePostTradeCancelBatchOrders")
		var method interface{} = this.SafeString(params, "method", defaultMethod)
		var clientOrderIds interface{} = this.ParseIds(this.SafeValue2(params, "clOrdId", "clientOrderId"))
		var algoIds interface{} = this.ParseIds(this.SafeValue(params, "algoId"))
		var trigger interface{} = this.SafeValue2(params, "stop", "trigger")
		var trailing interface{} = this.SafeBool(params, "trailing", false)
		if IsTrue(IsTrue(trigger) || IsTrue(trailing)) {
			method = "privatePostTradeCancelAlgos"
		}
		if IsTrue(IsEqual(clientOrderIds, nil)) {
			ids = this.ParseIds(ids)
			if IsTrue(!IsEqual(algoIds, nil)) {
				for i := 0; IsLessThan(i, GetArrayLength(algoIds)); i++ {
					AppendToArray(&request, map[string]interface{}{
						"algoId": GetValue(algoIds, i),
						"instId": GetValue(market, "id"),
					})
				}
			}
			for i := 0; IsLessThan(i, GetArrayLength(ids)); i++ {
				if IsTrue(IsTrue(trailing) || IsTrue(trigger)) {
					AppendToArray(&request, map[string]interface{}{
						"algoId": GetValue(ids, i),
						"instId": GetValue(market, "id"),
					})
				} else {
					AppendToArray(&request, map[string]interface{}{
						"ordId":  GetValue(ids, i),
						"instId": GetValue(market, "id"),
					})
				}
			}
		} else {
			for i := 0; IsLessThan(i, GetArrayLength(clientOrderIds)); i++ {
				if IsTrue(IsTrue(trailing) || IsTrue(trigger)) {
					AppendToArray(&request, map[string]interface{}{
						"instId":      GetValue(market, "id"),
						"algoClOrdId": GetValue(clientOrderIds, i),
					})
				} else {
					AppendToArray(&request, map[string]interface{}{
						"instId":  GetValue(market, "id"),
						"clOrdId": GetValue(clientOrderIds, i),
					})
				}
			}
		}
		var response interface{} = nil
		if IsTrue(IsEqual(method, "privatePostTradeCancelAlgos")) {

			response = (<-this.PrivatePostTradeCancelAlgos(request))
			PanicOnError(response) // * dont extend with params, otherwise ARRAY will be turned into OBJECT
		} else {

			response = (<-this.PrivatePostTradeCancelBatchOrders(request))
			PanicOnError(response) // * dont extend with params, otherwise ARRAY will be turned into OBJECT
		}
		//
		//     {
		//         "code": "0",
		//         "data": [
		//             {
		//                 "clOrdId": "e123456789ec4dBC1123456ba123b45e",
		//                 "ordId": "405071912345641543",
		//                 "sCode": "0",
		//                 "sMsg": ""
		//             },
		//             ...
		//         ],
		//         "msg": ""
		//     }
		//
		// Algo order
		//
		//     {
		//         "code": "0",
		//         "data": [
		//             {
		//                 "algoId": "431375349042380800",
		//                 "sCode": "0",
		//                 "sMsg": ""
		//             }
		//         ],
		//         "msg": ""
		//     }
		//
		var ordersData interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseOrders(ordersData, market, nil, nil, params)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#cancelOrdersForSymbols
 * @description cancel multiple orders for multiple symbols
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-post-cancel-multiple-orders
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-algo-trading-post-cancel-algo-order
 * @param {CancellationRequest[]} orders each order should contain the parameters required by cancelOrder namely id and symbol, example [{"id": "a", "symbol": "BTC/USDT"}, {"id": "b", "symbol": "ETH/USDT"}]
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.trigger] whether the order is a stop/trigger order
 * @param {boolean} [params.trailing] set to true if you want to cancel trailing orders
 * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *OkxCore) CancelOrdersForSymbols(orders interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes37828 := (<-this.LoadMarkets())
		PanicOnError(retRes37828)
		var request interface{} = []interface{}{}
		var options interface{} = this.SafeDict(this.Options, "cancelOrders", map[string]interface{}{})
		var defaultMethod interface{} = this.SafeString(options, "method", "privatePostTradeCancelBatchOrders")
		var method interface{} = this.SafeString(params, "method", defaultMethod)
		var trigger interface{} = this.SafeBool2(params, "stop", "trigger")
		var trailing interface{} = this.SafeBool(params, "trailing", false)
		var isStopOrTrailing interface{} = IsTrue(trigger) || IsTrue(trailing)
		if IsTrue(isStopOrTrailing) {
			method = "privatePostTradeCancelAlgos"
		}
		for i := 0; IsLessThan(i, GetArrayLength(orders)); i++ {
			var order interface{} = GetValue(orders, i)
			var id interface{} = this.SafeString(order, "id")
			var clientOrderId interface{} = this.SafeString2(order, "clOrdId", "clientOrderId")
			var symbol interface{} = this.SafeString(order, "symbol")
			var market interface{} = this.Market(symbol)
			var idKey interface{} = "ordId"
			if IsTrue(isStopOrTrailing) {
				idKey = "algoId"
			} else if IsTrue(!IsEqual(clientOrderId, nil)) {
				if IsTrue(isStopOrTrailing) {
					idKey = "algoClOrdId"
				} else {
					idKey = "clOrdId"
				}
			}
			var requestItem interface{} = map[string]interface{}{
				"instId": GetValue(market, "id"),
			}
			AddElementToObject(requestItem, idKey, Ternary(IsTrue((!IsEqual(clientOrderId, nil))), clientOrderId, id))
			AppendToArray(&request, requestItem)
		}
		var response interface{} = nil
		if IsTrue(IsEqual(method, "privatePostTradeCancelAlgos")) {

			response = (<-this.PrivatePostTradeCancelAlgos(request))
			PanicOnError(response) // * dont extend with params, otherwise ARRAY will be turned into OBJECT
		} else {

			response = (<-this.PrivatePostTradeCancelBatchOrders(request))
			PanicOnError(response) // * dont extend with params, otherwise ARRAY will be turned into OBJECT
		}
		//
		//     {
		//         "code": "0",
		//         "data": [
		//             {
		//                 "clOrdId": "e123456789ec4dBC1123456ba123b45e",
		//                 "ordId": "405071912345641543",
		//                 "sCode": "0",
		//                 "sMsg": ""
		//             },
		//             ...
		//         ],
		//         "msg": ""
		//     }
		//
		// Algo order
		//
		//     {
		//         "code": "0",
		//         "data": [
		//             {
		//                 "algoId": "431375349042380800",
		//                 "sCode": "0",
		//                 "sMsg": ""
		//             }
		//         ],
		//         "msg": ""
		//     }
		//
		var ordersData interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseOrders(ordersData, nil, nil, nil, params)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#cancelAllOrdersAfter
 * @description dead man's switch, cancel all orders after the given timeout
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-post-cancel-all-after
 * @param {number} timeout time in milliseconds, 0 represents cancel the timer
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} the api result
 */
func (this *OkxCore) CancelAllOrdersAfter(timeout interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes38648 := (<-this.LoadMarkets())
		PanicOnError(retRes38648)
		var request interface{} = map[string]interface{}{
			"timeOut": Ternary(IsTrue((IsGreaterThan(timeout, 0))), this.ParseToInt(Divide(timeout, 1000)), 0),
		}

		response := (<-this.PrivatePostTradeCancelAllAfter(this.Extend(request, params)))
		PanicOnError(response)

		//
		//     {
		//         "code":"0",
		//         "msg":"",
		//         "data":[
		//             {
		//                 "triggerTime":"1587971460",
		//                 "ts":"1587971400"
		//             }
		//         ]
		//     }
		//
		ch <- response
		return nil

	}()
	return ch
}
func (this *OkxCore) ParseOrderStatus(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"canceled":         "canceled",
		"order_failed":     "canceled",
		"live":             "open",
		"partially_filled": "open",
		"filled":           "closed",
		"effective":        "closed",
	}
	return this.SafeString(statuses, status, status)
}
func (this *OkxCore) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{} {
	//
	// createOrder
	//
	//     {
	//         "clOrdId": "oktswap6",
	//         "ordId": "312269865356374016",
	//         "tag": "",
	//         "sCode": "0",
	//         "sMsg": ""
	//     }
	//
	// editOrder
	//
	//     {
	//         "clOrdId": "e847386590ce4dBCc1a045253497a547",
	//         "ordId": "559176536793178112",
	//         "reqId": "",
	//         "sCode": "0",
	//         "sMsg": ""
	//     }
	//
	// Spot and Swap fetchOrder, fetchOpenOrders
	//
	//     {
	//         "accFillSz": "0",
	//         "avgPx": "",
	//         "cTime": "1621910749815",
	//         "category": "normal",
	//         "ccy": "",
	//         "clOrdId": "",
	//         "fee": "0",
	//         "feeCcy": "ETH",
	//         "fillPx": "",
	//         "fillSz": "0",
	//         "fillTime": "",
	//         "instId": "ETH-USDT",
	//         "instType": "SPOT",
	//         "lever": "",
	//         "ordId": "317251910906576896",
	//         "ordType": "limit",
	//         "pnl": "0",
	//         "posSide": "net",
	//         "px": "2000",
	//         "rebate": "0",
	//         "rebateCcy": "USDT",
	//         "side": "buy",
	//         "slOrdPx": "",
	//         "slTriggerPx": "",
	//         "state": "live",
	//         "sz": "0.001",
	//         "tag": "",
	//         "tdMode": "cash",
	//         "tpOrdPx": "",
	//         "tpTriggerPx": "",
	//         "tradeId": "",
	//         "uTime": "1621910749815"
	//     }
	//
	// watchOrders & fetchClosedOrders
	//
	//    {
	//        "algoClOrdId": "",
	//        "algoId": "",
	//        "attachAlgoClOrdId": "",
	//        "attachAlgoOrds": [],
	//        "cancelSource": "",
	//        "cancelSourceReason": "", // not present in WS, but present in fetchClosedOrders
	//        "category": "normal",
	//        "ccy": "", // empty in WS, but eg. `USDT` in fetchClosedOrders
	//        "clOrdId": "",
	//        "cTime": "1751705801423",
	//        "feeCcy": "USDT",
	//        "instId": "LINK-USDT-SWAP",
	//        "instType": "SWAP",
	//        "isTpLimit": "false",
	//        "lever": "3",
	//        "linkedAlgoOrd": { "algoId": "" },
	//        "ordId": "2657625147249614848",
	//        "ordType": "limit",
	//        "posSide": "net",
	//        "px": "13.142",
	//        "pxType": "",
	//        "pxUsd": "",
	//        "pxVol": "",
	//        "quickMgnType": "",
	//        "rebate": "0",
	//        "rebateCcy": "USDT",
	//        "reduceOnly": "true",
	//        "side": "sell",
	//        "slOrdPx": "",
	//        "slTriggerPx": "",
	//        "slTriggerPxType": "",
	//        "source": "",
	//        "stpId": "",
	//        "stpMode": "cancel_maker",
	//        "sz": "0.1",
	//        "tag": "",
	//        "tdMode": "isolated",
	//        "tgtCcy": "",
	//        "tpOrdPx": "",
	//        "tpTriggerPx": "",
	//        "tpTriggerPxType": "",
	//        "uTime": "1751705807467",
	//        "reqId": "",                      // field present only in WS
	//        "msg": "",                        // field present only in WS
	//        "amendResult": "",                // field present only in WS
	//        "amendSource": "",                // field present only in WS
	//        "code": "0",                      // field present only in WS
	//        "fillFwdPx": "",                  // field present only in WS
	//        "fillMarkVol": "",                // field present only in WS
	//        "fillPxUsd": "",                  // field present only in WS
	//        "fillPxVol": "",                  // field present only in WS
	//        "lastPx": "13.142",               // field present only in WS
	//        "notionalUsd": "1.314515408",     // field present only in WS
	//
	//     #### these below fields are empty on first omit from websocket, because of "creation" event. however, if order is executed, it also immediately sends another update with these fields filled  ###
	//
	//        "pnl": "-0.0001",
	//        "accFillSz": "0.1",
	//        "avgPx": "13.142",
	//        "state": "filled",
	//        "fee": "-0.00026284",
	//        "fillPx": "13.142",
	//        "tradeId": "293429690",
	//        "fillSz": "0.1",
	//        "fillTime": "1751705807467",
	//        "fillNotionalUsd": "1.314515408", // field present only in WS
	//        "fillPnl": "-0.0001",             // field present only in WS
	//        "fillFee": "-0.00026284",         // field present only in WS
	//        "fillFeeCcy": "USDT",             // field present only in WS
	//        "execType": "M",                  // field present only in WS
	//        "fillMarkPx": "13.141",           // field present only in WS
	//        "fillIdxPx": "13.147"             // field present only in WS
	//    }
	//
	//
	// Algo Order fetchOpenOrders, fetchCanceledOrders, fetchClosedOrders
	//
	//     {
	//         "activePx": "",
	//         "activePxType": "",
	//         "actualPx": "",
	//         "actualSide": "buy",
	//         "actualSz": "0",
	//         "algoId": "431375349042380800",
	//         "cTime": "1649119897778",
	//         "callbackRatio": "",
	//         "callbackSpread": "",
	//         "ccy": "",
	//         "ctVal": "0.01",
	//         "instId": "BTC-USDT-SWAP",
	//         "instType": "SWAP",
	//         "last": "46538.9",
	//         "lever": "125",
	//         "moveTriggerPx": "",
	//         "notionalUsd": "467.059",
	//         "ordId": "",
	//         "ordPx": "50000",
	//         "ordType": "trigger",
	//         "posSide": "long",
	//         "pxLimit": "",
	//         "pxSpread": "",
	//         "pxVar": "",
	//         "side": "buy",
	//         "slOrdPx": "",
	//         "slTriggerPx": "",
	//         "slTriggerPxType": "",
	//         "state": "live",
	//         "sz": "1",
	//         "szLimit": "",
	//         "tag": "",
	//         "tdMode": "isolated",
	//         "tgtCcy": "",
	//         "timeInterval": "",
	//         "tpOrdPx": "",
	//         "tpTriggerPx": "",
	//         "tpTriggerPxType": "",
	//         "triggerPx": "50000",
	//         "triggerPxType": "last",
	//         "triggerTime": "",
	//         "uly": "BTC-USDT"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var scode interface{} = this.SafeString(order, "sCode")
	if IsTrue(IsTrue((!IsEqual(scode, nil))) && IsTrue((!IsEqual(scode, "0")))) {
		return this.SafeOrder(map[string]interface{}{
			"id":            this.SafeString(order, "ordId"),
			"clientOrderId": this.SafeString(order, "clOrdId"),
			"status":        "rejected",
			"info":          order,
		})
	}
	var id interface{} = this.SafeString2(order, "algoId", "ordId")
	var timestamp interface{} = this.SafeInteger(order, "cTime")
	var lastUpdateTimestamp interface{} = this.SafeInteger(order, "uTime")
	var lastTradeTimestamp interface{} = this.SafeInteger(order, "fillTime")
	var side interface{} = this.SafeString(order, "side")
	var typeVar interface{} = this.SafeString(order, "ordType")
	var postOnly interface{} = nil
	var timeInForce interface{} = nil
	if IsTrue(IsEqual(typeVar, "post_only")) {
		postOnly = true
		typeVar = "limit"
	} else if IsTrue(IsEqual(typeVar, "fok")) {
		timeInForce = "FOK"
		typeVar = "limit"
	} else if IsTrue(IsEqual(typeVar, "ioc")) {
		timeInForce = "IOC"
		typeVar = "limit"
	}
	var marketId interface{} = this.SafeString(order, "instId")
	market = this.SafeMarket(marketId, market)
	var symbol interface{} = this.SafeSymbol(marketId, market, "-")
	var filled interface{} = this.SafeString(order, "accFillSz")
	var price interface{} = this.SafeString2(order, "px", "ordPx")
	var average interface{} = this.SafeString(order, "avgPx")
	var status interface{} = this.ParseOrderStatus(this.SafeString(order, "state"))
	var feeCostString interface{} = this.SafeString(order, "fee")
	var amount interface{} = nil
	var cost interface{} = nil
	// spot market buy: "sz" can refer either to base currency units or to quote currency units
	// see documentation: https://www.okx.com/docs-v5/en/#rest-api-trade-place-order
	var defaultTgtCcy interface{} = this.SafeString(this.Options, "tgtCcy", "base_ccy")
	var tgtCcy interface{} = this.SafeString(order, "tgtCcy", defaultTgtCcy)
	var instType interface{} = this.SafeString(order, "instType")
	if IsTrue(IsTrue(IsTrue(IsTrue((IsEqual(side, "buy"))) && IsTrue((IsEqual(typeVar, "market")))) && IsTrue((IsEqual(instType, "SPOT")))) && IsTrue((IsEqual(tgtCcy, "quote_ccy")))) {
		// "sz" refers to the cost
		cost = this.SafeString(order, "sz")
	} else {
		// "sz" refers to the trade currency amount
		amount = this.SafeString(order, "sz")
	}
	var fee interface{} = nil
	if IsTrue(!IsEqual(feeCostString, nil)) {
		var feeCostSigned interface{} = Precise.StringNeg(feeCostString)
		var feeCurrencyId interface{} = this.SafeString(order, "feeCcy")
		var feeCurrencyCode interface{} = this.SafeCurrencyCode(feeCurrencyId)
		fee = map[string]interface{}{
			"cost":     this.ParseNumber(feeCostSigned),
			"currency": feeCurrencyCode,
		}
	}
	var clientOrderId interface{} = this.SafeString(order, "clOrdId")
	if IsTrue(IsTrue((!IsEqual(clientOrderId, nil))) && IsTrue((IsLessThan(GetLength(clientOrderId), 1)))) {
		clientOrderId = nil // fix empty clientOrderId string
	}
	var stopLossPrice interface{} = this.SafeNumber2(order, "slTriggerPx", "slOrdPx")
	var takeProfitPrice interface{} = this.SafeNumber2(order, "tpTriggerPx", "tpOrdPx")
	var reduceOnlyRaw interface{} = this.SafeString(order, "reduceOnly")
	var reduceOnly interface{} = false
	if IsTrue(!IsEqual(reduceOnly, nil)) {
		reduceOnly = (IsEqual(reduceOnlyRaw, "true"))
	}
	return this.SafeOrder(map[string]interface{}{
		"info":                order,
		"id":                  id,
		"clientOrderId":       clientOrderId,
		"timestamp":           timestamp,
		"datetime":            this.Iso8601(timestamp),
		"lastTradeTimestamp":  lastTradeTimestamp,
		"lastUpdateTimestamp": lastUpdateTimestamp,
		"symbol":              symbol,
		"type":                typeVar,
		"timeInForce":         timeInForce,
		"postOnly":            postOnly,
		"side":                side,
		"price":               price,
		"stopLossPrice":       stopLossPrice,
		"takeProfitPrice":     takeProfitPrice,
		"triggerPrice":        this.SafeNumberN(order, []interface{}{"triggerPx", "moveTriggerPx"}),
		"average":             average,
		"cost":                cost,
		"amount":              amount,
		"filled":              filled,
		"remaining":           nil,
		"status":              status,
		"fee":                 fee,
		"trades":              nil,
		"reduceOnly":          reduceOnly,
	}, market)
}

/**
 * @method
 * @name okx#fetchOrder
 * @description fetch an order by the id
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-get-order-details
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-algo-trading-get-algo-order-details
 * @param {string} id the order id
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra and exchange specific parameters
 * @param {boolean} [params.trigger] true if fetching trigger orders
 * @returns [an order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *OkxCore) FetchOrder(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchOrder() requires a symbol argument")))
		}

		retRes41958 := (<-this.LoadMarkets())
		PanicOnError(retRes41958)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"instId": GetValue(market, "id"),
		}
		var clientOrderId interface{} = this.SafeString2(params, "clOrdId", "clientOrderId")
		var options interface{} = this.SafeValue(this.Options, "fetchOrder", map[string]interface{}{})
		var defaultMethod interface{} = this.SafeString(options, "method", "privateGetTradeOrder")
		var method interface{} = this.SafeString(params, "method", defaultMethod)
		var trigger interface{} = this.SafeValue2(params, "stop", "trigger")
		if IsTrue(trigger) {
			method = "privateGetTradeOrderAlgo"
			if IsTrue(!IsEqual(clientOrderId, nil)) {
				AddElementToObject(request, "algoClOrdId", clientOrderId)
			} else {
				AddElementToObject(request, "algoId", id)
			}
		} else {
			if IsTrue(!IsEqual(clientOrderId, nil)) {
				AddElementToObject(request, "clOrdId", clientOrderId)
			} else {
				AddElementToObject(request, "ordId", id)
			}
		}
		var query interface{} = this.Omit(params, []interface{}{"method", "clOrdId", "clientOrderId", "stop", "trigger"})
		var response interface{} = nil
		if IsTrue(IsEqual(method, "privateGetTradeOrderAlgo")) {

			response = (<-this.PrivateGetTradeOrderAlgo(this.Extend(request, query)))
			PanicOnError(response)
		} else {

			response = (<-this.PrivateGetTradeOrder(this.Extend(request, query)))
			PanicOnError(response)
		}
		//
		// Spot and Swap
		//
		//     {
		//         "code": "0",
		//         "data": [
		//             {
		//                 "accFillSz": "0",
		//                 "avgPx": "",
		//                 "cTime": "1621910749815",
		//                 "category": "normal",
		//                 "ccy": "",
		//                 "clOrdId": "",
		//                 "fee": "0",
		//                 "feeCcy": "ETH",
		//                 "fillPx": "",
		//                 "fillSz": "0",
		//                 "fillTime": "",
		//                 "instId": "ETH-USDT",
		//                 "instType": "SPOT",
		//                 "lever": "",
		//                 "ordId": "317251910906576896",
		//                 "ordType": "limit",
		//                 "pnl": "0",
		//                 "posSide": "net",
		//                 "px":"20 00",
		//                 "rebate": "0",
		//                 "rebateCcy": "USDT",
		//                 "side": "buy",
		//                 "slOrdPx": "",
		//                 "slTriggerPx": "",
		//                 "state": "live",
		//                 "sz":"0. 001",
		//                 "tag": "",
		//                 "tdMode": "cash",
		//                 "tpOrdPx": "",
		//                 "tpTriggerPx": "",
		//                 "tradeId": "",
		//                 "uTime": "1621910749815"
		//             }
		//         ],
		//         "msg": ""
		//     }
		//
		// Algo order
		//     {
		//         "code":"0",
		//         "msg":"",
		//         "data":[
		//             {
		//                 "instType":"FUTURES",
		//                 "instId":"BTC-USD-200329",
		//                 "ordId":"123445",
		//                 "ccy":"BTC",
		//                 "clOrdId":"",
		//                 "algoId":"1234",
		//                 "sz":"999",
		//                 "closeFraction":"",
		//                 "ordType":"oco",
		//                 "side":"buy",
		//                 "posSide":"long",
		//                 "tdMode":"cross",
		//                 "tgtCcy": "",
		//                 "state":"effective",
		//                 "lever":"20",
		//                 "tpTriggerPx":"",
		//                 "tpTriggerPxType":"",
		//                 "tpOrdPx":"",
		//                 "slTriggerPx":"",
		//                 "slTriggerPxType":"",
		//                 "triggerPx":"99",
		//                 "triggerPxType":"last",
		//                 "ordPx":"12",
		//                 "actualSz":"",
		//                 "actualPx":"",
		//                 "actualSide":"",
		//                 "pxVar":"",
		//                 "pxSpread":"",
		//                 "pxLimit":"",
		//                 "szLimit":"",
		//                 "tag": "adadadadad",
		//                 "timeInterval":"",
		//                 "callbackRatio":"",
		//                 "callbackSpread":"",
		//                 "activePx":"",
		//                 "moveTriggerPx":"",
		//                 "reduceOnly": "false",
		//                 "triggerTime":"1597026383085",
		//                 "last": "16012",
		//                 "failCode": "",
		//                 "algoClOrdId": "",
		//                 "cTime":"1597026383000"
		//             }
		//         ]
		//     }
		//
		var data interface{} = this.SafeValue(response, "data", []interface{}{})
		var order interface{} = this.SafeDict(data, 0)

		ch <- this.ParseOrder(order, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-get-order-list
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-algo-trading-get-algo-order-list
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {bool} [params.trigger] True if fetching trigger or conditional orders
 * @param {string} [params.ordType] "conditional", "oco", "trigger", "move_order_stop", "iceberg", or "twap"
 * @param {string} [params.algoId] Algo ID "'433845797218942976'"
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @param {boolean} [params.trailing] set to true if you want to fetch trailing orders
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *OkxCore) FetchOpenOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes43488 := (<-this.LoadMarkets())
		PanicOnError(retRes43488)
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchOpenOrders", "paginate")
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {

			retRes435219 := (<-this.FetchPaginatedCallDynamic("fetchOpenOrders", symbol, since, limit, params))
			PanicOnError(retRes435219)
			ch <- retRes435219
			return nil
		}
		var request interface{} = map[string]interface{}{}
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			AddElementToObject(request, "instId", GetValue(market, "id"))
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit) // default 100, max 100
		}
		var options interface{} = this.SafeValue(this.Options, "fetchOpenOrders", map[string]interface{}{})
		var algoOrderTypes interface{} = this.SafeValue(this.Options, "algoOrderTypes", map[string]interface{}{})
		var defaultMethod interface{} = this.SafeString(options, "method", "privateGetTradeOrdersPending")
		var method interface{} = this.SafeString(params, "method", defaultMethod)
		var ordType interface{} = this.SafeString(params, "ordType")
		var trigger interface{} = this.SafeValue2(params, "stop", "trigger")
		var trailing interface{} = this.SafeBool(params, "trailing", false)
		if IsTrue(IsTrue(IsTrue(trailing) || IsTrue(trigger)) || IsTrue((InOp(algoOrderTypes, ordType)))) {
			method = "privateGetTradeOrdersAlgoPending"
		}
		if IsTrue(trailing) {
			AddElementToObject(request, "ordType", "move_order_stop")
		} else if IsTrue(IsTrue(trigger) && IsTrue((IsEqual(ordType, nil)))) {
			AddElementToObject(request, "ordType", "trigger")
		}
		var query interface{} = this.Omit(params, []interface{}{"method", "stop", "trigger", "trailing"})
		var response interface{} = nil
		if IsTrue(IsEqual(method, "privateGetTradeOrdersAlgoPending")) {

			response = (<-this.PrivateGetTradeOrdersAlgoPending(this.Extend(request, query)))
			PanicOnError(response)
		} else {

			response = (<-this.PrivateGetTradeOrdersPending(this.Extend(request, query)))
			PanicOnError(response)
		}
		//
		//     {
		//         "code": "0",
		//         "data": [
		//             {
		//                 "accFillSz": "0",
		//                 "avgPx": "",
		//                 "cTime": "1621910749815",
		//                 "category": "normal",
		//                 "ccy": "",
		//                 "clOrdId": "",
		//                 "fee": "0",
		//                 "feeCcy": "ETH",
		//                 "fillPx": "",
		//                 "fillSz": "0",
		//                 "fillTime": "",
		//                 "instId": "ETH-USDT",
		//                 "instType": "SPOT",
		//                 "lever": "",
		//                 "ordId": "317251910906576896",
		//                 "ordType": "limit",
		//                 "pnl": "0",
		//                 "posSide": "net",
		//                 "px":"20 00",
		//                 "rebate": "0",
		//                 "rebateCcy": "USDT",
		//                 "side": "buy",
		//                 "slOrdPx": "",
		//                 "slTriggerPx": "",
		//                 "state": "live",
		//                 "sz":"0. 001",
		//                 "tag": "",
		//                 "tdMode": "cash",
		//                 "tpOrdPx": "",
		//                 "tpTriggerPx": "",
		//                 "tradeId": "",
		//                 "uTime": "1621910749815"
		//             }
		//         ],
		//         "msg":""
		//     }
		//
		// Algo order
		//
		//     {
		//         "code": "0",
		//         "data": [
		//             {
		//                 "activePx": "",
		//                 "activePxType": "",
		//                 "actualPx": "",
		//                 "actualSide": "buy",
		//                 "actualSz": "0",
		//                 "algoId": "431375349042380800",
		//                 "cTime": "1649119897778",
		//                 "callbackRatio": "",
		//                 "callbackSpread": "",
		//                 "ccy": "",
		//                 "ctVal": "0.01",
		//                 "instId": "BTC-USDT-SWAP",
		//                 "instType": "SWAP",
		//                 "last": "46538.9",
		//                 "lever": "125",
		//                 "moveTriggerPx": "",
		//                 "notionalUsd": "467.059",
		//                 "ordId": "",
		//                 "ordPx": "50000",
		//                 "ordType": "trigger",
		//                 "posSide": "long",
		//                 "pxLimit": "",
		//                 "pxSpread": "",
		//                 "pxVar": "",
		//                 "side": "buy",
		//                 "slOrdPx": "",
		//                 "slTriggerPx": "",
		//                 "slTriggerPxType": "",
		//                 "state": "live",
		//                 "sz": "1",
		//                 "szLimit": "",
		//                 "tag": "",
		//                 "tdMode": "isolated",
		//                 "tgtCcy": "",
		//                 "timeInterval": "",
		//                 "tpOrdPx": "",
		//                 "tpTriggerPx": "",
		//                 "tpTriggerPxType": "",
		//                 "triggerPx": "50000",
		//                 "triggerPxType": "last",
		//                 "triggerTime": "",
		//                 "uly": "BTC-USDT"
		//             }
		//         ],
		//         "msg": ""
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseOrders(data, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#fetchCanceledOrders
 * @description fetches information on multiple canceled orders made by the user
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-get-order-history-last-7-days
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-algo-trading-get-algo-order-history
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] timestamp in ms of the earliest order, default is undefined
 * @param {int} [limit] max number of orders to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {bool} [params.trigger] True if fetching trigger or conditional orders
 * @param {string} [params.ordType] "conditional", "oco", "trigger", "move_order_stop", "iceberg", or "twap"
 * @param {string} [params.algoId] Algo ID "'433845797218942976'"
 * @param {int} [params.until] timestamp in ms to fetch orders for
 * @param {boolean} [params.trailing] set to true if you want to fetch trailing orders
 * @returns {object} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *OkxCore) FetchCanceledOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes45118 := (<-this.LoadMarkets())
		PanicOnError(retRes45118)
		var request interface{} = map[string]interface{}{}
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			AddElementToObject(request, "instId", GetValue(market, "id"))
		}
		var typeVar interface{} = nil
		var query interface{} = nil
		typeVarqueryVariable := this.HandleMarketTypeAndParams("fetchCanceledOrders", market, params)
		typeVar = GetValue(typeVarqueryVariable, 0)
		query = GetValue(typeVarqueryVariable, 1)
		AddElementToObject(request, "instType", this.ConvertToInstrumentType(typeVar))
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit) // default 100, max 100
		}
		AddElementToObject(request, "state", "canceled")
		var options interface{} = this.SafeValue(this.Options, "fetchCanceledOrders", map[string]interface{}{})
		var algoOrderTypes interface{} = this.SafeValue(this.Options, "algoOrderTypes", map[string]interface{}{})
		var defaultMethod interface{} = this.SafeString(options, "method", "privateGetTradeOrdersHistory")
		var method interface{} = this.SafeString(params, "method", defaultMethod)
		var ordType interface{} = this.SafeString(params, "ordType")
		var trigger interface{} = this.SafeValue2(params, "stop", "trigger")
		var trailing interface{} = this.SafeBool(params, "trailing", false)
		if IsTrue(trailing) {
			method = "privateGetTradeOrdersAlgoHistory"
			AddElementToObject(request, "ordType", "move_order_stop")
		} else if IsTrue(IsTrue(trigger) || IsTrue((InOp(algoOrderTypes, ordType)))) {
			method = "privateGetTradeOrdersAlgoHistory"
			var algoId interface{} = this.SafeString(params, "algoId")
			if IsTrue(!IsEqual(algoId, nil)) {
				AddElementToObject(request, "algoId", algoId)
				params = this.Omit(params, "algoId")
			}
			if IsTrue(trigger) {
				if IsTrue(IsEqual(ordType, nil)) {
					panic(ArgumentsRequired(Add(this.Id, " fetchCanceledOrders() requires an \"ordType\" string parameter, \"conditional\", \"oco\", \"trigger\", \"move_order_stop\", \"iceberg\", or \"twap\"")))
				}
			}
		} else {
			if IsTrue(!IsEqual(since, nil)) {
				AddElementToObject(request, "begin", since)
			}
			var until interface{} = this.SafeInteger(query, "until")
			if IsTrue(!IsEqual(until, nil)) {
				AddElementToObject(request, "end", until)
				query = this.Omit(query, []interface{}{"until"})
			}
		}
		var send interface{} = this.Omit(query, []interface{}{"method", "stop", "trigger", "trailing"})
		var response interface{} = nil
		if IsTrue(IsEqual(method, "privateGetTradeOrdersAlgoHistory")) {

			response = (<-this.PrivateGetTradeOrdersAlgoHistory(this.Extend(request, send)))
			PanicOnError(response)
		} else {

			response = (<-this.PrivateGetTradeOrdersHistory(this.Extend(request, send)))
			PanicOnError(response)
		}
		//
		//     {
		//         "code": "0",
		//         "data": [
		//             {
		//                 "accFillSz": "0",
		//                 "avgPx": "",
		//                 "cTime": "1644037822494",
		//                 "category": "normal",
		//                 "ccy": "",
		//                 "clOrdId": "",
		//                 "fee": "0",
		//                 "feeCcy": "BTC",
		//                 "fillPx": "",
		//                 "fillSz": "0",
		//                 "fillTime": "",
		//                 "instId": "BTC-USDT",
		//                 "instType": "SPOT",
		//                 "lever": "",
		//                 "ordId": "410059580352409602",
		//                 "ordType": "limit",
		//                 "pnl": "0",
		//                 "posSide": "net",
		//                 "px": "30000",
		//                 "rebate": "0",
		//                 "rebateCcy": "USDT",
		//                 "side": "buy",
		//                 "slOrdPx": "",
		//                 "slTriggerPx": "",
		//                 "slTriggerPxType": "",
		//                 "source": "",
		//                 "state": "canceled",
		//                 "sz": "0.0005452",
		//                 "tag": "",
		//                 "tdMode": "cash",
		//                 "tgtCcy": "",
		//                 "tpOrdPx": "",
		//                 "tpTriggerPx": "",
		//                 "tpTriggerPxType": "",
		//                 "tradeId": "",
		//                 "uTime": "1644038165667"
		//             }
		//         ],
		//         "msg": ""
		//     }
		//
		// Algo order
		//
		//     {
		//         "code": "0",
		//         "data": [
		//             {
		//                 "activePx": "",
		//                 "activePxType": "",
		//                 "actualPx": "",
		//                 "actualSide": "buy",
		//                 "actualSz": "0",
		//                 "algoId": "433845797218942976",
		//                 "cTime": "1649708898523",
		//                 "callbackRatio": "",
		//                 "callbackSpread": "",
		//                 "ccy": "",
		//                 "ctVal": "0.01",
		//                 "instId": "BTC-USDT-SWAP",
		//                 "instType": "SWAP",
		//                 "last": "39950.4",
		//                 "lever": "125",
		//                 "moveTriggerPx": "",
		//                 "notionalUsd": "1592.1760000000002",
		//                 "ordId": "",
		//                 "ordPx": "29000",
		//                 "ordType": "trigger",
		//                 "posSide": "long",
		//                 "pxLimit": "",
		//                 "pxSpread": "",
		//                 "pxVar": "",
		//                 "side": "buy",
		//                 "slOrdPx": "",
		//                 "slTriggerPx": "",
		//                 "slTriggerPxType": "",
		//                 "state": "canceled",
		//                 "sz": "4",
		//                 "szLimit": "",
		//                 "tag": "",
		//                 "tdMode": "isolated",
		//                 "tgtCcy": "",
		//                 "timeInterval": "",
		//                 "tpOrdPx": "",
		//                 "tpTriggerPx": "",
		//                 "tpTriggerPxType": "",
		//                 "triggerPx": "30000",
		//                 "triggerPxType": "last",
		//                 "triggerTime": "",
		//                 "uly": "BTC-USDT"
		//             },
		//         ],
		//         "msg": ""
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseOrders(data, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#fetchClosedOrders
 * @description fetches information on multiple closed orders made by the user
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-get-order-history-last-7-days
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-algo-trading-get-algo-order-history
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-get-order-history-last-3-months
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {bool} [params.trigger] True if fetching trigger or conditional orders
 * @param {string} [params.ordType] "conditional", "oco", "trigger", "move_order_stop", "iceberg", or "twap"
 * @param {string} [params.algoId] Algo ID "'433845797218942976'"
 * @param {int} [params.until] timestamp in ms to fetch orders for
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @param {string} [params.method] method to be used, either 'privateGetTradeOrdersHistory', 'privateGetTradeOrdersHistoryArchive' or 'privateGetTradeOrdersAlgoHistory' default is 'privateGetTradeOrdersHistory'
 * @param {boolean} [params.trailing] set to true if you want to fetch trailing orders
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *OkxCore) FetchClosedOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes46998 := (<-this.LoadMarkets())
		PanicOnError(retRes46998)
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchClosedOrders", "paginate")
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {

			retRes470319 := (<-this.FetchPaginatedCallDynamic("fetchClosedOrders", symbol, since, limit, params))
			PanicOnError(retRes470319)
			ch <- retRes470319
			return nil
		}
		var request interface{} = map[string]interface{}{}
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			AddElementToObject(request, "instId", GetValue(market, "id"))
		}
		var typeVar interface{} = nil
		var query interface{} = nil
		typeVarqueryVariable := this.HandleMarketTypeAndParams("fetchClosedOrders", market, params)
		typeVar = GetValue(typeVarqueryVariable, 0)
		query = GetValue(typeVarqueryVariable, 1)
		AddElementToObject(request, "instType", this.ConvertToInstrumentType(typeVar))
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit) // default 100, max 100
		}
		var options interface{} = this.SafeDict(this.Options, "fetchClosedOrders", map[string]interface{}{})
		var algoOrderTypes interface{} = this.SafeDict(this.Options, "algoOrderTypes", map[string]interface{}{})
		var defaultMethod interface{} = this.SafeString(options, "method", "privateGetTradeOrdersHistory")
		var method interface{} = this.SafeString(params, "method", defaultMethod)
		var ordType interface{} = this.SafeString(params, "ordType")
		var trigger interface{} = this.SafeBool2(params, "stop", "trigger")
		var trailing interface{} = this.SafeBool(params, "trailing", false)
		if IsTrue(IsTrue(IsTrue(trailing) || IsTrue(trigger)) || IsTrue((InOp(algoOrderTypes, ordType)))) {
			method = "privateGetTradeOrdersAlgoHistory"
			AddElementToObject(request, "state", "effective")
		}
		if IsTrue(trailing) {
			AddElementToObject(request, "ordType", "move_order_stop")
		} else if IsTrue(trigger) {
			if IsTrue(IsEqual(ordType, nil)) {
				AddElementToObject(request, "ordType", "trigger")
			}
		} else {
			if IsTrue(!IsEqual(since, nil)) {
				AddElementToObject(request, "begin", since)
			}
			var until interface{} = this.SafeInteger(query, "until")
			if IsTrue(!IsEqual(until, nil)) {
				AddElementToObject(request, "end", until)
				query = this.Omit(query, []interface{}{"until"})
			}
			AddElementToObject(request, "state", "filled")
		}
		var send interface{} = this.Omit(query, []interface{}{"method", "stop", "trigger", "trailing"})
		var response interface{} = nil
		if IsTrue(IsEqual(method, "privateGetTradeOrdersAlgoHistory")) {

			response = (<-this.PrivateGetTradeOrdersAlgoHistory(this.Extend(request, send)))
			PanicOnError(response)
		} else if IsTrue(IsEqual(method, "privateGetTradeOrdersHistoryArchive")) {

			response = (<-this.PrivateGetTradeOrdersHistoryArchive(this.Extend(request, send)))
			PanicOnError(response)
		} else {

			response = (<-this.PrivateGetTradeOrdersHistory(this.Extend(request, send)))
			PanicOnError(response)
		}
		//
		//     {
		//         "code": "0",
		//         "data": [
		//             {
		//                 "accFillSz": "0",
		//                 "avgPx": "",
		//                 "cTime": "1621910749815",
		//                 "category": "normal",
		//                 "ccy": "",
		//                 "clOrdId": "",
		//                 "fee": "0",
		//                 "feeCcy": "ETH",
		//                 "fillPx": "",
		//                 "fillSz": "0",
		//                 "fillTime": "",
		//                 "instId": "ETH-USDT",
		//                 "instType": "SPOT",
		//                 "lever": "",
		//                 "ordId": "317251910906576896",
		//                 "ordType": "limit",
		//                 "pnl": "0",
		//                 "posSide": "net",
		//                 "px": "2000",
		//                 "rebate": "0",
		//                 "rebateCcy": "USDT",
		//                 "side": "buy",
		//                 "slOrdPx": "",
		//                 "slTriggerPx": "",
		//                 "state": "live",
		//                 "sz": "0.001",
		//                 "tag": "",
		//                 "tdMode": "cash",
		//                 "tpOrdPx": "",
		//                 "tpTriggerPx": "",
		//                 "tradeId": "",
		//                 "uTime": "1621910749815"
		//             }
		//         ],
		//         "msg": ""
		//     }
		//
		// Algo order
		//
		//     {
		//         "code": "0",
		//         "data": [
		//             {
		//                 "activePx": "",
		//                 "activePxType": "",
		//                 "actualPx": "",
		//                 "actualSide": "buy",
		//                 "actualSz": "0",
		//                 "algoId": "433845797218942976",
		//                 "cTime": "1649708898523",
		//                 "callbackRatio": "",
		//                 "callbackSpread": "",
		//                 "ccy": "",
		//                 "ctVal": "0.01",
		//                 "instId": "BTC-USDT-SWAP",
		//                 "instType": "SWAP",
		//                 "last": "39950.4",
		//                 "lever": "125",
		//                 "moveTriggerPx": "",
		//                 "notionalUsd": "1592.1760000000002",
		//                 "ordId": "",
		//                 "ordPx": "29000",
		//                 "ordType": "trigger",
		//                 "posSide": "long",
		//                 "pxLimit": "",
		//                 "pxSpread": "",
		//                 "pxVar": "",
		//                 "side": "buy",
		//                 "slOrdPx": "",
		//                 "slTriggerPx": "",
		//                 "slTriggerPxType": "",
		//                 "state": "effective",
		//                 "sz": "4",
		//                 "szLimit": "",
		//                 "tag": "",
		//                 "tdMode": "isolated",
		//                 "tgtCcy": "",
		//                 "timeInterval": "",
		//                 "tpOrdPx": "",
		//                 "tpTriggerPx": "",
		//                 "tpTriggerPxType": "",
		//                 "triggerPx": "30000",
		//                 "triggerPxType": "last",
		//                 "triggerTime": "",
		//                 "uly": "BTC-USDT"
		//             },
		//         ],
		//         "msg": ""
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseOrders(data, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-get-transaction-details-last-3-months
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] Timestamp in ms of the latest time to retrieve trades for
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
 */
func (this *OkxCore) FetchMyTrades(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes48788 := (<-this.LoadMarkets())
		PanicOnError(retRes48788)
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchMyTrades", "paginate")
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {

			retRes488219 := (<-this.FetchPaginatedCallDynamic("fetchMyTrades", symbol, since, limit, params))
			PanicOnError(retRes488219)
			ch <- retRes488219
			return nil
		}
		var request interface{} = map[string]interface{}{}
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			AddElementToObject(request, "instId", GetValue(market, "id"))
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "begin", since)
		}
		requestparamsVariable := this.HandleUntilOption("end", request, params)
		request = GetValue(requestparamsVariable, 0)
		params = GetValue(requestparamsVariable, 1)
		typeVarqueryVariable := this.HandleMarketTypeAndParams("fetchMyTrades", market, params)
		typeVar := GetValue(typeVarqueryVariable, 0)
		query := GetValue(typeVarqueryVariable, 1)
		AddElementToObject(request, "instType", this.ConvertToInstrumentType(typeVar))
		if IsTrue(IsTrue((!IsEqual(limit, nil))) && IsTrue((IsEqual(since, nil)))) {
			AddElementToObject(request, "limit", limit) // default 100, max 100
		}

		response := (<-this.PrivateGetTradeFillsHistory(this.Extend(request, query)))
		PanicOnError(response)
		//
		//     {
		//         "code": "0",
		//         "data": [
		//             {
		//                 "side": "buy",
		//                 "fillSz": "0.007533",
		//                 "fillPx": "2654.98",
		//                 "fee": "-0.000007533",
		//                 "ordId": "317321390244397056",
		//                 "instType": "SPOT",
		//                 "instId": "ETH-USDT",
		//                 "clOrdId": "",
		//                 "posSide": "net",
		//                 "billId": "317321390265368576",
		//                 "tag": "0",
		//                 "execType": "T",
		//                 "tradeId": "107601752",
		//                 "feeCcy": "ETH",
		//                 "ts": "1621927314985"
		//             }
		//         ],
		//         "msg": ""
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseTrades(data, market, since, limit, query)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#fetchOrderTrades
 * @description fetch all the trades made from a single order
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-get-transaction-details-last-3-months
 * @param {string} id order id
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
 */
func (this *OkxCore) FetchOrderTrades(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		var request interface{} = map[string]interface{}{
			"ordId": id,
		}

		retRes495715 := (<-this.FetchMyTrades(symbol, since, limit, this.Extend(request, params)))
		PanicOnError(retRes495715)
		ch <- retRes495715
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#fetchLedger
 * @description fetch the history of changes, actions done by the user or operations that altered balance of the user
 * @see https://www.okx.com/docs-v5/en/#rest-api-account-get-bills-details-last-7-days
 * @see https://www.okx.com/docs-v5/en/#rest-api-account-get-bills-details-last-3-months
 * @see https://www.okx.com/docs-v5/en/#rest-api-funding-asset-bills-details
 * @param {string} [code] unified currency code, default is undefined
 * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
 * @param {int} [limit] max number of ledger entries to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] 'cross' or 'isolated'
 * @param {int} [params.until] the latest time in ms to fetch entries for
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/?id=ledger-entry-structure}
 */
func (this *OkxCore) FetchLedger(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes49778 := (<-this.LoadMarkets())
		PanicOnError(retRes49778)
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchLedger", "paginate")
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {

			retRes498119 := (<-this.FetchPaginatedCallDynamic("fetchLedger", code, since, limit, params))
			PanicOnError(retRes498119)
			ch <- retRes498119
			return nil
		}
		var options interface{} = this.SafeDict(this.Options, "fetchLedger", map[string]interface{}{})
		var method interface{} = this.SafeString(options, "method")
		method = this.SafeString(params, "method", method)
		params = this.Omit(params, "method")
		var request interface{} = map[string]interface{}{}
		var marginMode interface{} = nil
		marginModeparamsVariable := this.HandleMarginModeAndParams("fetchLedger", params)
		marginMode = GetValue(marginModeparamsVariable, 0)
		params = GetValue(marginModeparamsVariable, 1)
		if IsTrue(IsEqual(marginMode, nil)) {
			marginMode = this.SafeString(params, "mgnMode")
		}
		if IsTrue(!IsEqual(method, "privateGetAssetBills")) {
			if IsTrue(!IsEqual(marginMode, nil)) {
				AddElementToObject(request, "mgnMode", marginMode)
			}
		}
		typeVarqueryVariable := this.HandleMarketTypeAndParams("fetchLedger", nil, params)
		typeVar := GetValue(typeVarqueryVariable, 0)
		query := GetValue(typeVarqueryVariable, 1)
		if IsTrue(!IsEqual(typeVar, nil)) {
			AddElementToObject(request, "instType", this.ConvertToInstrumentType(typeVar))
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}
		var currency interface{} = nil
		if IsTrue(!IsEqual(code, nil)) {
			currency = this.Currency(code)
			AddElementToObject(request, "ccy", GetValue(currency, "id"))
		}
		requestparamsVariable := this.HandleUntilOption("end", request, params)
		request = GetValue(requestparamsVariable, 0)
		params = GetValue(requestparamsVariable, 1)
		var response interface{} = nil
		if IsTrue(IsEqual(method, "privateGetAccountBillsArchive")) {

			response = (<-this.PrivateGetAccountBillsArchive(this.Extend(request, query)))
			PanicOnError(response)
		} else if IsTrue(IsEqual(method, "privateGetAssetBills")) {

			response = (<-this.PrivateGetAssetBills(this.Extend(request, query)))
			PanicOnError(response)
		} else {

			response = (<-this.PrivateGetAccountBills(this.Extend(request, query)))
			PanicOnError(response)
		}
		//
		// privateGetAccountBills, privateGetAccountBillsArchive
		//
		//     {
		//         "code": "0",
		//         "msg": "",
		//         "data": [
		//             {
		//                 "bal": "0.0000819307998198",
		//                 "balChg": "-664.2679586599999802",
		//                 "billId": "310394313544966151",
		//                 "ccy": "USDT",
		//                 "fee": "0",
		//                 "from": "",
		//                 "instId": "LTC-USDT",
		//                 "instType": "SPOT",
		//                 "mgnMode": "cross",
		//                 "notes": "",
		//                 "ordId": "310394313519800320",
		//                 "pnl": "0",
		//                 "posBal": "0",
		//                 "posBalChg": "0",
		//                 "subType": "2",
		//                 "sz": "664.26795866",
		//                 "to": "",
		//                 "ts": "1620275771196",
		//                 "type": "2"
		//             }
		//         ]
		//     }
		//
		// privateGetAssetBills
		//
		//     {
		//         "code": "0",
		//         "msg": "",
		//         "data": [
		//             {
		//                 "billId": "12344",
		//                 "ccy": "BTC",
		//                 "balChg": "2",
		//                 "bal": "12",
		//                 "type": "1",
		//                 "ts": "1597026383085"
		//             }
		//         ]
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseLedger(data, currency, since, limit)
		return nil

	}()
	return ch
}
func (this *OkxCore) ParseLedgerEntryType(typeVar interface{}) interface{} {
	var types interface{} = map[string]interface{}{
		"1":  "transfer",
		"2":  "trade",
		"3":  "trade",
		"4":  "rebate",
		"5":  "trade",
		"6":  "transfer",
		"7":  "trade",
		"8":  "fee",
		"9":  "trade",
		"10": "trade",
		"11": "trade",
	}
	return this.SafeString(types, typeVar, typeVar)
}
func (this *OkxCore) ParseLedgerEntry(item interface{}, optionalArgs ...interface{}) interface{} {
	//
	// privateGetAccountBills, privateGetAccountBillsArchive
	//
	//     {
	//         "bal": "0.0000819307998198",
	//         "balChg": "-664.2679586599999802",
	//         "billId": "310394313544966151",
	//         "ccy": "USDT",
	//         "fee": "0",
	//         "from": "",
	//         "instId": "LTC-USDT",
	//         "instType": "SPOT",
	//         "mgnMode": "cross",
	//         "notes": "",
	//         "ordId": "310394313519800320",
	//         "pnl": "0",
	//         "posBal": "0",
	//         "posBalChg": "0",
	//         "subType": "2",
	//         "sz": "664.26795866",
	//         "to": "",
	//         "ts": "1620275771196",
	//         "type": "2"
	//     }
	//
	// privateGetAssetBills
	//
	//     {
	//         "billId": "12344",
	//         "ccy": "BTC",
	//         "balChg": "2",
	//         "bal": "12",
	//         "type": "1",
	//         "ts": "1597026383085"
	//     }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var currencyId interface{} = this.SafeString(item, "ccy")
	var code interface{} = this.SafeCurrencyCode(currencyId, currency)
	currency = this.SafeCurrency(currencyId, currency)
	var timestamp interface{} = this.SafeInteger(item, "ts")
	var feeCostString interface{} = this.SafeString(item, "fee")
	var fee interface{} = nil
	if IsTrue(!IsEqual(feeCostString, nil)) {
		fee = map[string]interface{}{
			"cost":     this.ParseNumber(Precise.StringNeg(feeCostString)),
			"currency": code,
		}
	}
	var marketId interface{} = this.SafeString(item, "instId")
	var symbol interface{} = this.SafeSymbol(marketId, nil, "-")
	return this.SafeLedgerEntry(map[string]interface{}{
		"info":             item,
		"id":               this.SafeString(item, "billId"),
		"timestamp":        timestamp,
		"datetime":         this.Iso8601(timestamp),
		"account":          nil,
		"referenceId":      this.SafeString(item, "ordId"),
		"referenceAccount": nil,
		"type":             this.ParseLedgerEntryType(this.SafeString(item, "type")),
		"currency":         code,
		"symbol":           symbol,
		"amount":           this.SafeNumber(item, "balChg"),
		"before":           nil,
		"after":            this.SafeNumber(item, "bal"),
		"status":           "ok",
		"fee":              fee,
	}, currency)
}
func (this *OkxCore) ParseDepositAddress(depositAddress interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "addr": "okbtothemoon",
	//         "memo": "971668", // may be missing
	//         "tag":"52055", // may be missing
	//         "pmtId": "", // may be missing
	//         "ccy": "BTC",
	//         "to": "6", // 1 SPOT, 3 FUTURES, 6 FUNDING, 9 SWAP, 12 OPTION, 18 Unified account
	//         "selected": true
	//     }
	//
	//     {
	//         "ccy":"usdt-erc20",
	//         "to":"6",
	//         "addr":"0x696abb81974a8793352cbd33aadcf78eda3cfdfa",
	//         "selected":true
	//     }
	//
	//     {
	//        "chain": "ETH-OKExChain",
	//        "addrEx": { "comment": "6040348" }, // some currencies like TON may have this field,
	//        "ctAddr": "72315c",
	//        "ccy": "ETH",
	//        "to": "6",
	//        "addr": "0x1c9f2244d1ccaa060bd536827c18925db10db102",
	//        "selected": true
	//     }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var address interface{} = this.SafeString(depositAddress, "addr")
	var tag interface{} = this.SafeStringN(depositAddress, []interface{}{"tag", "pmtId", "memo"})
	if IsTrue(IsEqual(tag, nil)) {
		var addrEx interface{} = this.SafeValue(depositAddress, "addrEx", map[string]interface{}{})
		tag = this.SafeString(addrEx, "comment")
	}
	var currencyId interface{} = this.SafeString(depositAddress, "ccy")
	currency = this.SafeCurrency(currencyId, currency)
	var code interface{} = GetValue(currency, "code")
	var chain interface{} = this.SafeString(depositAddress, "chain")
	var networks interface{} = this.SafeValue(currency, "networks", map[string]interface{}{})
	var networksById interface{} = this.IndexBy(networks, "id")
	var networkData interface{} = this.SafeValue(networksById, chain)
	// inconsistent naming responses from exchange
	// with respect to network naming provided in currency info vs address chain-names and ids
	//
	// response from address endpoint:
	//      {
	//          "chain": "USDT-Polygon",
	//          "ctAddr": "",
	//          "ccy": "USDT",
	//          "to":"6" ,
	//          "addr": "0x1903441e386cc49d937f6302955b5feb4286dcfa",
	//          "selected": true
	//      }
	// network information from currency['networks'] field:
	// Polygon: {
	//        info: {
	//            canDep: false,
	//            canInternal: false,
	//            canWd: false,
	//            ccy: 'USDT',
	//            chain: 'USDT-Polygon-Bridge',
	//            mainNet: false,
	//            maxFee: '26.879528',
	//            minFee: '13.439764',
	//            minWd: '0.001',
	//            name: ''
	//        },
	//        id: 'USDT-Polygon-Bridge',
	//        network: 'Polygon',
	//        active: false,
	//        deposit: false,
	//        withdraw: false,
	//        fee: 13.439764,
	//        precision: undefined,
	//        limits: {
	//            withdraw: {
	//                min: 0.001,
	//                max: undefined
	//            }
	//        }
	//     },
	//
	if IsTrue(IsEqual(chain, "USDT-Polygon")) {
		networkData = this.SafeValue2(networksById, "USDT-Polygon-Bridge", "USDT-Polygon")
	}
	var network interface{} = this.SafeString(networkData, "network")
	var networkCode interface{} = this.NetworkIdToCode(network, code)
	this.CheckAddress(address)
	return map[string]interface{}{
		"info":     depositAddress,
		"currency": code,
		"network":  networkCode,
		"address":  address,
		"tag":      tag,
	}
}

/**
 * @method
 * @name okx#fetchDepositAddressesByNetwork
 * @description fetch a dictionary of addresses for a currency, indexed by network
 * @see https://www.okx.com/docs-v5/en/#funding-account-rest-api-get-deposit-address
 * @param {string} code unified currency code of the currency for the deposit address
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [address structures]{@link https://docs.ccxt.com/?id=address-structure} indexed by the network
 */
func (this *OkxCore) FetchDepositAddressesByNetwork(code interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes52788 := (<-this.LoadMarkets())
		PanicOnError(retRes52788)
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"ccy": GetValue(currency, "id"),
		}

		response := (<-this.PrivateGetAssetDepositAddress(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "0",
		//         "msg": "",
		//         "data": [
		//             {
		//                 "addr": "okbtothemoon",
		//                 "memo": "971668", // may be missing
		//                 "tag":"52055", // may be missing
		//                 "pmtId": "", // may be missing
		//                 "ccy": "BTC",
		//                 "to": "6", // 1 SPOT, 3 FUTURES, 6 FUNDING, 9 SWAP, 12 OPTION, 18 Unified account
		//                 "selected": true
		//             },
		//             // {"ccy":"usdt-erc20","to":"6","addr":"0x696abb81974a8793352cbd33aadcf78eda3cfdfa","selected":true},
		//             // {"ccy":"usdt-trc20","to":"6","addr":"TRrd5SiSZrfQVRKm4e9SRSbn2LNTYqCjqx","selected":true},
		//             // {"ccy":"usdt_okexchain","to":"6","addr":"0x696abb81974a8793352cbd33aadcf78eda3cfdfa","selected":true},
		//             // {"ccy":"usdt_kip20","to":"6","addr":"0x696abb81974a8793352cbd33aadcf78eda3cfdfa","selected":true},
		//         ]
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var filtered interface{} = this.FilterBy(data, "selected", true)
		var parsed interface{} = this.ParseDepositAddresses(filtered, []interface{}{GetValue(currency, "code")}, false)

		ch <- this.IndexBy(parsed, "network")
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account
 * @see https://www.okx.com/docs-v5/en/#funding-account-rest-api-get-deposit-address
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.network] the network name for the deposit address
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/?id=address-structure}
 */
func (this *OkxCore) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes53228 := (<-this.LoadMarkets())
		PanicOnError(retRes53228)
		var rawNetwork interface{} = this.SafeString(params, "network") // some networks are like "Dora Vota Mainnet"
		params = this.Omit(params, "network")
		code = this.SafeCurrencyCode(code)
		var network interface{} = this.NetworkIdToCode(rawNetwork, code)

		response := (<-this.FetchDepositAddressesByNetwork(code, params))
		PanicOnError(response)
		if IsTrue(!IsEqual(network, nil)) {
			var result interface{} = this.SafeDict(response, network)
			if IsTrue(IsEqual(result, nil)) {
				panic(InvalidAddress(Add(Add(Add(Add(this.Id, " fetchDepositAddress() cannot find "), network), " deposit address for "), code)))
			}

			ch <- result
			return nil
		}
		var codeNetwork interface{} = this.NetworkIdToCode(code, code)
		if IsTrue(InOp(response, codeNetwork)) {

			ch <- GetValue(response, codeNetwork)
			return nil
		}
		// if the network is not specified, return the first address
		var keys interface{} = ObjectKeys(response)
		var first interface{} = this.SafeString(keys, 0)

		ch <- this.SafeDict(response, first)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#withdraw
 * @description make a withdrawal
 * @see https://www.okx.com/docs-v5/en/#funding-account-rest-api-withdrawal
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/?id=transaction-structure}
 */
func (this *OkxCore) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		tag := GetArg(optionalArgs, 0, nil)
		_ = tag
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params)
		tag = GetValue(tagparamsVariable, 0)
		params = GetValue(tagparamsVariable, 1)
		this.CheckAddress(address)

		retRes53608 := (<-this.LoadMarkets())
		PanicOnError(retRes53608)
		var currency interface{} = this.Currency(code)
		if IsTrue(IsTrue((!IsEqual(tag, nil))) && IsTrue((IsGreaterThan(GetLength(tag), 0)))) {
			address = Add(Add(address, ":"), tag)
		}
		var request interface{} = map[string]interface{}{
			"ccy":    GetValue(currency, "id"),
			"toAddr": address,
			"dest":   "4",
			"amt":    this.NumberToString(amount),
		}
		var network interface{} = this.SafeString(params, "network") // this line allows the user to specify either ERC20 or ETH
		if IsTrue(!IsEqual(network, nil)) {
			var networks interface{} = this.SafeDict(this.Options, "networks", map[string]interface{}{})
			network = this.SafeString(networks, ToUpper(network), network) // handle ETH>ERC20 alias
			AddElementToObject(request, "chain", Add(Add(GetValue(currency, "id"), "-"), network))
			params = this.Omit(params, "network")
		}
		var fee interface{} = this.SafeString(params, "fee")
		if IsTrue(IsEqual(fee, nil)) {

			currencies := (<-this.FetchCurrencies())
			PanicOnError(currencies)
			this.Currencies = this.MapToSafeMap(this.DeepExtend(this.Currencies, currencies))
			var targetNetwork interface{} = this.SafeDict(GetValue(currency, "networks"), this.NetworkIdToCode(network), map[string]interface{}{})
			fee = this.SafeString(targetNetwork, "fee")
			if IsTrue(IsEqual(fee, nil)) {
				panic(ArgumentsRequired(Add(this.Id, " withdraw() requires a \"fee\" string parameter, network transaction fee must be  0. Withdrawals to OKCoin or OKX are fee-free, please set \"0\". Withdrawing to external digital asset address requires network transaction fee.")))
			}
		}
		AddElementToObject(request, "fee", this.NumberToString(fee)) // withdrawals to OKCoin or OKX are fee-free, please set 0
		var query interface{} = this.Omit(params, []interface{}{"fee"})

		response := (<-this.PrivatePostAssetWithdrawal(this.Extend(request, query)))
		PanicOnError(response)
		//
		//     {
		//         "code": "0",
		//         "msg": "",
		//         "data": [
		//             {
		//                 "amt": "0.1",
		//                 "wdId": "67485",
		//                 "ccy": "BTC"
		//             }
		//         ]
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var transaction interface{} = this.SafeDict(data, 0)

		ch <- this.ParseTransaction(transaction, currency)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://www.okx.com/docs-v5/en/#rest-api-funding-get-deposit-history
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch entries for
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/?id=transaction-structure}
 */
func (this *OkxCore) FetchDeposits(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes54238 := (<-this.LoadMarkets())
		PanicOnError(retRes54238)
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchDeposits", "paginate")
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {

			retRes542719 := (<-this.FetchPaginatedCallDynamic("fetchDeposits", code, since, limit, params))
			PanicOnError(retRes542719)
			ch <- retRes542719
			return nil
		}
		var request interface{} = map[string]interface{}{}
		var currency interface{} = nil
		if IsTrue(!IsEqual(code, nil)) {
			currency = this.Currency(code)
			AddElementToObject(request, "ccy", GetValue(currency, "id"))
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "before", mathMax(Subtract(since, 1), 0))
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit) // default 100, max 100
		}
		requestparamsVariable := this.HandleUntilOption("after", request, params)
		request = GetValue(requestparamsVariable, 0)
		params = GetValue(requestparamsVariable, 1)

		response := (<-this.PrivateGetAssetDepositHistory(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "0",
		//         "msg": "",
		//         "data": [
		//             {
		//                 "amt": "0.01044408",
		//                 "txId": "1915737_3_0_0_asset",
		//                 "ccy": "BTC",
		//                 "from": "13801825426",
		//                 "to": "",
		//                 "ts": "1597026383085",
		//                 "state": "2",
		//                 "depId": "4703879"
		//             },
		//             {
		//                 "amt": "491.6784211",
		//                 "txId": "1744594_3_184_0_asset",
		//                 "ccy": "OKB",
		//                 "from": "",
		//                 "to": "",
		//                 "ts": "1597026383085",
		//                 "state": "2",
		//                 "depId": "4703809"
		//             },
		//             {
		//                 "amt": "223.18782496",
		//                 "txId": "6d892c669225b1092c780bf0da0c6f912fc7dc8f6b8cc53b003288624c",
		//                 "ccy": "USDT",
		//                 "from": "",
		//                 "to": "39kK4XvgEuM7rX9frgyHoZkWqx4iKu1spD",
		//                 "ts": "1597026383085",
		//                 "state": "2",
		//                 "depId": "4703779"
		//             }
		//         ]
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseTransactions(data, currency, since, limit, params)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#fetchDeposit
 * @description fetch data on a currency deposit via the deposit id
 * @see https://www.okx.com/docs-v5/en/#rest-api-funding-get-deposit-history
 * @param {string} id deposit id
 * @param {string} code filter by currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/?id=transaction-structure}
 */
func (this *OkxCore) FetchDeposit(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes55028 := (<-this.LoadMarkets())
		PanicOnError(retRes55028)
		var request interface{} = map[string]interface{}{
			"depId": id,
		}
		var currency interface{} = nil
		if IsTrue(!IsEqual(code, nil)) {
			currency = this.Currency(code)
			AddElementToObject(request, "ccy", GetValue(currency, "id"))
		}

		response := (<-this.PrivateGetAssetDepositHistory(this.Extend(request, params)))
		PanicOnError(response)
		var data interface{} = this.SafeValue(response, "data")
		var deposit interface{} = this.SafeDict(data, 0, map[string]interface{}{})

		ch <- this.ParseTransaction(deposit, currency)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @see https://www.okx.com/docs-v5/en/#rest-api-funding-get-withdrawal-history
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawals structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch entries for
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/?id=transaction-structure}
 */
func (this *OkxCore) FetchWithdrawals(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes55318 := (<-this.LoadMarkets())
		PanicOnError(retRes55318)
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchWithdrawals", "paginate")
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {

			retRes553519 := (<-this.FetchPaginatedCallDynamic("fetchWithdrawals", code, since, limit, params))
			PanicOnError(retRes553519)
			ch <- retRes553519
			return nil
		}
		var request interface{} = map[string]interface{}{}
		var currency interface{} = nil
		if IsTrue(!IsEqual(code, nil)) {
			currency = this.Currency(code)
			AddElementToObject(request, "ccy", GetValue(currency, "id"))
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "before", mathMax(Subtract(since, 1), 0))
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit) // default 100, max 100
		}
		requestparamsVariable := this.HandleUntilOption("after", request, params)
		request = GetValue(requestparamsVariable, 0)
		params = GetValue(requestparamsVariable, 1)

		response := (<-this.PrivateGetAssetWithdrawalHistory(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "0",
		//         "msg": "",
		//         "data": [
		//             {
		//                 "amt": "0.094",
		//                 "wdId": "4703879",
		//                 "fee": "0.01000000eth",
		//                 "txId": "0x62477bac6509a04512819bb1455e923a60dea5966c7caeaa0b24eb8fb0432b85",
		//                 "ccy": "ETH",
		//                 "from": "13426335357",
		//                 "to": "0xA41446125D0B5b6785f6898c9D67874D763A1519",
		//                 "ts": "1597026383085",
		//                 "state": "2"
		//             },
		//             {
		//                 "amt": "0.01",
		//                 "wdId": "4703879",
		//                 "fee": "0.00000000btc",
		//                 "txId": "",
		//                 "ccy": "BTC",
		//                 "from": "13426335357",
		//                 "to": "13426335357",
		//                 "ts": "1597026383085",
		//                 "state": "2"
		//             }
		//         ]
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseTransactions(data, currency, since, limit, params)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#fetchWithdrawal
 * @description fetch data on a currency withdrawal via the withdrawal id
 * @see https://www.okx.com/docs-v5/en/#rest-api-funding-get-withdrawal-history
 * @param {string} id withdrawal id
 * @param {string} code unified currency code of the currency withdrawn, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/?id=transaction-structure}
 */
func (this *OkxCore) FetchWithdrawal(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes56028 := (<-this.LoadMarkets())
		PanicOnError(retRes56028)
		var request interface{} = map[string]interface{}{
			"wdId": id,
		}
		var currency interface{} = nil
		if IsTrue(!IsEqual(code, nil)) {
			currency = this.Currency(code)
			AddElementToObject(request, "ccy", GetValue(currency, "id"))
		}

		response := (<-this.PrivateGetAssetWithdrawalHistory(this.Extend(request, params)))
		PanicOnError(response)
		//
		//    {
		//        "code": "0",
		//        "data": [
		//            {
		//                "chain": "USDT-TRC20",
		//                "clientId": '',
		//                "fee": "0.8",
		//                "ccy": "USDT",
		//                "amt": "54.561",
		//                "txId": "00cff6ec7fa7c7d7d184bd84e82b9ff36863f07c0421188607f87dfa94e06b70",
		//                "from": "example@email.com",
		//                "to": "TEY6qjnKDyyq5jDc3DJizWLCdUySrpQ4yp",
		//                "state": "2",
		//                "ts": "1641376485000",
		//                "wdId": "25147041"
		//            }
		//        ],
		//        "msg": ''
		//    }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var withdrawal interface{} = this.SafeDict(data, 0, map[string]interface{}{})

		ch <- this.ParseTransaction(withdrawal)
		return nil

	}()
	return ch
}
func (this *OkxCore) ParseTransactionStatus(status interface{}) interface{} {
	//
	// deposit statuses
	//
	//     {
	//         "0": "waiting for confirmation",
	//         "1": "deposit credited",
	//         "2": "deposit successful"
	//     }
	//
	// withdrawal statuses
	//
	//     {
	//        '-3': "pending cancel",
	//        "-2": "canceled",
	//        "-1": "failed",
	//         "0": "pending",
	//         "1": "sending",
	//         "2": "sent",
	//         "3": "awaiting email verification",
	//         "4": "awaiting manual verification",
	//         "5": "awaiting identity verification"
	//     }
	//
	var statuses interface{} = map[string]interface{}{
		"-3": "pending",
		"-2": "canceled",
		"-1": "failed",
		"0":  "pending",
		"1":  "pending",
		"2":  "ok",
		"3":  "pending",
		"4":  "pending",
		"5":  "pending",
		"6":  "pending",
		"7":  "pending",
		"8":  "pending",
		"9":  "pending",
		"10": "pending",
		"12": "pending",
		"15": "pending",
		"16": "pending",
	}
	return this.SafeString(statuses, status, status)
}
func (this *OkxCore) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{} {
	//
	// withdraw
	//
	//     {
	//         "amt": "0.1",
	//         "wdId": "67485",
	//         "ccy": "BTC"
	//     }
	//
	// fetchWithdrawals
	//
	//     {
	//         "amt": "0.094",
	//         "wdId": "4703879",
	//         "fee": "0.01000000eth",
	//         "txId": "0x62477bac6509a04512819bb1455e923a60dea5966c7caeaa0b24eb8fb0432b85",
	//         "ccy": "ETH",
	//         "from": "13426335357",
	//         "to": "0xA41446125D0B5b6785f6898c9D67874D763A1519",
	//         "tag",
	//         "pmtId",
	//         "memo",
	//         "ts": "1597026383085",
	//         "state": "2"
	//     }
	//
	// fetchDeposits
	//
	//     {
	//         "amt": "0.01044408",
	//         "txId": "1915737_3_0_0_asset",
	//         "ccy": "BTC",
	//         "from": "13801825426",
	//         "to": "",
	//         "ts": "1597026383085",
	//         "state": "2",
	//         "depId": "4703879"
	//     }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var typeVar interface{} = nil
	var id interface{} = nil
	var withdrawalId interface{} = this.SafeString(transaction, "wdId")
	var addressFrom interface{} = this.SafeString(transaction, "from")
	var addressTo interface{} = this.SafeString(transaction, "to")
	var address interface{} = addressTo
	var tagTo interface{} = this.SafeString2(transaction, "tag", "memo")
	tagTo = this.SafeString2(transaction, "pmtId", tagTo)
	if IsTrue(!IsEqual(withdrawalId, nil)) {
		typeVar = "withdrawal"
		id = withdrawalId
	} else {
		// the payment_id will appear on new deposits but appears to be removed from the response after 2 months
		id = this.SafeString(transaction, "depId")
		typeVar = "deposit"
	}
	var currencyId interface{} = this.SafeString(transaction, "ccy")
	var code interface{} = this.SafeCurrencyCode(currencyId)
	var amount interface{} = this.SafeNumber(transaction, "amt")
	var status interface{} = this.ParseTransactionStatus(this.SafeString(transaction, "state"))
	var txid interface{} = this.SafeString(transaction, "txId")
	var timestamp interface{} = this.SafeInteger(transaction, "ts")
	var feeCost interface{} = nil
	if IsTrue(IsEqual(typeVar, "deposit")) {
		feeCost = 0
	} else {
		feeCost = this.SafeNumber(transaction, "fee")
	}
	// todo parse tags
	return map[string]interface{}{
		"info":        transaction,
		"id":          id,
		"currency":    code,
		"amount":      amount,
		"network":     nil,
		"addressFrom": addressFrom,
		"addressTo":   addressTo,
		"address":     address,
		"tagFrom":     nil,
		"tagTo":       tagTo,
		"tag":         tagTo,
		"status":      status,
		"type":        typeVar,
		"updated":     nil,
		"txid":        txid,
		"timestamp":   timestamp,
		"datetime":    this.Iso8601(timestamp),
		"internal":    nil,
		"comment":     nil,
		"fee": map[string]interface{}{
			"currency": code,
			"cost":     feeCost,
		},
	}
}

/**
 * @method
 * @name okx#fetchLeverage
 * @description fetch the set leverage for a market
 * @see https://www.okx.com/docs-v5/en/#rest-api-account-get-leverage
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] 'cross' or 'isolated'
 * @returns {object} a [leverage structure]{@link https://docs.ccxt.com/?id=leverage-structure}
 */
func (this *OkxCore) FetchLeverage(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes57918 := (<-this.LoadMarkets())
		PanicOnError(retRes57918)
		var marginMode interface{} = nil
		marginModeparamsVariable := this.HandleMarginModeAndParams("fetchLeverage", params)
		marginMode = GetValue(marginModeparamsVariable, 0)
		params = GetValue(marginModeparamsVariable, 1)
		if IsTrue(IsEqual(marginMode, nil)) {
			marginMode = this.SafeString(params, "mgnMode", "cross") // cross as default marginMode
		}
		if IsTrue(IsTrue((!IsEqual(marginMode, "cross"))) && IsTrue((!IsEqual(marginMode, "isolated")))) {
			panic(BadRequest(Add(this.Id, " fetchLeverage() requires a marginMode parameter that must be either cross or isolated")))
		}
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"instId":  GetValue(market, "id"),
			"mgnMode": marginMode,
		}

		response := (<-this.PrivateGetAccountLeverageInfo(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//        "code": "0",
		//        "data": [
		//            {
		//                "instId": "BTC-USDT-SWAP",
		//                "lever": "5.00000000",
		//                "mgnMode": "isolated",
		//                "posSide": "net"
		//            }
		//        ],
		//        "msg": ""
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseLeverage(data, market)
		return nil

	}()
	return ch
}
func (this *OkxCore) ParseLeverage(leverage interface{}, optionalArgs ...interface{}) interface{} {
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = nil
	var marginMode interface{} = nil
	var longLeverage interface{} = nil
	var shortLeverage interface{} = nil
	for i := 0; IsLessThan(i, GetArrayLength(leverage)); i++ {
		var entry interface{} = GetValue(leverage, i)
		marginMode = this.SafeStringLower(entry, "mgnMode")
		marketId = this.SafeString(entry, "instId")
		var positionSide interface{} = this.SafeStringLower(entry, "posSide")
		if IsTrue(IsEqual(positionSide, "long")) {
			longLeverage = this.SafeInteger(entry, "lever")
		} else if IsTrue(IsEqual(positionSide, "short")) {
			shortLeverage = this.SafeInteger(entry, "lever")
		} else {
			longLeverage = this.SafeInteger(entry, "lever")
			shortLeverage = this.SafeInteger(entry, "lever")
		}
	}
	return map[string]interface{}{
		"info":          leverage,
		"symbol":        this.SafeSymbol(marketId, market),
		"marginMode":    marginMode,
		"longLeverage":  longLeverage,
		"shortLeverage": shortLeverage,
	}
}

/**
 * @method
 * @name okx#fetchPosition
 * @description fetch data on a single open contract trade position
 * @see https://www.okx.com/docs-v5/en/#rest-api-account-get-positions
 * @param {string} symbol unified market symbol of the market the position is held in, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.instType] MARGIN, SWAP, FUTURES, OPTION
 * @returns {object} a [position structure]{@link https://docs.ccxt.com/?id=position-structure}
 */
func (this *OkxCore) FetchPosition(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes58638 := (<-this.LoadMarkets())
		PanicOnError(retRes58638)
		var market interface{} = this.Market(symbol)
		typeVarqueryVariable := this.HandleMarketTypeAndParams("fetchPosition", market, params)
		typeVar := GetValue(typeVarqueryVariable, 0)
		query := GetValue(typeVarqueryVariable, 1)
		var request interface{} = map[string]interface{}{
			"instId": GetValue(market, "id"),
		}
		if IsTrue(!IsEqual(typeVar, nil)) {
			AddElementToObject(request, "instType", this.ConvertToInstrumentType(typeVar))
		}

		response := (<-this.PrivateGetAccountPositions(this.Extend(request, query)))
		PanicOnError(response)
		//
		//     {
		//         "code": "0",
		//         "msg": "",
		//         "data": [
		//             {
		//                 "adl": "1",
		//                 "availPos": "1",
		//                 "avgPx": "2566.31",
		//                 "cTime": "1619507758793",
		//                 "ccy": "ETH",
		//                 "deltaBS": "",
		//                 "deltaPA": "",
		//                 "gammaBS": "",
		//                 "gammaPA": "",
		//                 "imr": "",
		//                 "instId": "ETH-USD-210430",
		//                 "instType": "FUTURES",
		//                 "interest": "0",
		//                 "last": "2566.22",
		//                 "lever": "10",
		//                 "liab": "",
		//                 "liabCcy": "",
		//                 "liqPx": "2352.8496681818233",
		//                 "margin": "0.0003896645377994",
		//                 "mgnMode": "isolated",
		//                 "mgnRatio": "11.731726509588816",
		//                 "mmr": "0.0000311811092368",
		//                 "optVal": "",
		//                 "pTime": "1619507761462",
		//                 "pos": "1",
		//                 "posCcy": "",
		//                 "posId": "307173036051017730",
		//                 "posSide": "long",
		//                 "thetaBS": "",
		//                 "thetaPA": "",
		//                 "tradeId": "109844",
		//                 "uTime": "1619507761462",
		//                 "upl": "-0.0000009932766034",
		//                 "uplRatio": "-0.0025490556801078",
		//                 "vegaBS": "",
		//                 "vegaPA": ""
		//             }
		//         ]
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var position interface{} = this.SafeDict(data, 0)
		if IsTrue(IsEqual(position, nil)) {

			return nil
		}

		ch <- this.ParsePosition(position, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#fetchPositions
 * @see https://www.okx.com/docs-v5/en/#rest-api-account-get-positions
 * @see https://www.okx.com/docs-v5/en/#trading-account-rest-api-get-positions-history history
 * @description fetch all open positions
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.instType] MARGIN, SWAP, FUTURES, OPTION
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/?id=position-structure}
 */
func (this *OkxCore) FetchPositions(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes59418 := (<-this.LoadMarkets())
		PanicOnError(retRes59418)
		var request interface{} = map[string]interface{}{}
		if IsTrue(!IsEqual(symbols, nil)) {
			var marketIds interface{} = []interface{}{}
			for i := 0; IsLessThan(i, GetArrayLength(symbols)); i++ {
				var entry interface{} = GetValue(symbols, i)
				var market interface{} = this.Market(entry)
				AppendToArray(&marketIds, GetValue(market, "id"))
			}
			var marketIdsLength interface{} = GetArrayLength(marketIds)
			if IsTrue(IsGreaterThan(marketIdsLength, 0)) {
				AddElementToObject(request, "instId", Join(marketIds, ","))
			}
		}
		var fetchPositionsOptions interface{} = this.SafeDict(this.Options, "fetchPositions", map[string]interface{}{})
		var method interface{} = this.SafeString(fetchPositionsOptions, "method", "privateGetAccountPositions")
		var response interface{} = nil
		if IsTrue(IsEqual(method, "privateGetAccountPositionsHistory")) {

			response = (<-this.PrivateGetAccountPositionsHistory(this.Extend(request, params)))
			PanicOnError(response)
		} else {

			response = (<-this.PrivateGetAccountPositions(this.Extend(request, params)))
			PanicOnError(response)
		}
		//
		//     {
		//         "code": "0",
		//         "msg": "",
		//         "data": [
		//             {
		//                 "adl": "1",
		//                 "availPos": "1",
		//                 "avgPx": "2566.31",
		//                 "cTime": "1619507758793",
		//                 "ccy": "ETH",
		//                 "deltaBS": "",
		//                 "deltaPA": "",
		//                 "gammaBS": "",
		//                 "gammaPA": "",
		//                 "imr": "",
		//                 "instId": "ETH-USD-210430",
		//                 "instType": "FUTURES",
		//                 "interest": "0",
		//                 "last": "2566.22",
		//                 "lever": "10",
		//                 "liab": "",
		//                 "liabCcy": "",
		//                 "liqPx": "2352.8496681818233",
		//                 "margin": "0.0003896645377994",
		//                 "mgnMode": "isolated",
		//                 "mgnRatio": "11.731726509588816",
		//                 "mmr": "0.0000311811092368",
		//                 "optVal": "",
		//                 "pTime": "1619507761462",
		//                 "pos": "1",
		//                 "posCcy": "",
		//                 "posId": "307173036051017730",
		//                 "posSide": "long",
		//                 "thetaBS": "",
		//                 "thetaPA": "",
		//                 "tradeId": "109844",
		//                 "uTime": "1619507761462",
		//                 "upl": "-0.0000009932766034",
		//                 "uplRatio": "-0.0025490556801078",
		//                 "vegaBS": "",
		//                 "vegaPA": ""
		//             }
		//         ]
		//     }
		//
		var positions interface{} = this.SafeList(response, "data", []interface{}{})
		var result interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(positions)); i++ {
			AppendToArray(&result, this.ParsePosition(GetValue(positions, i)))
		}

		ch <- this.FilterByArrayPositions(result, "symbol", this.MarketSymbols(symbols), false)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#fetchPositionsForSymbol
 * @see https://www.okx.com/docs-v5/en/#rest-api-account-get-positions
 * @description fetch all open positions for specific symbol
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.instType] MARGIN (if needed)
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/?id=position-structure}
 */
func (this *OkxCore) FetchPositionsForSymbol(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes603215 := (<-this.FetchPositions([]interface{}{symbol}, params))
		PanicOnError(retRes603215)
		ch <- retRes603215
		return nil

	}()
	return ch
}
func (this *OkxCore) ParsePosition(position interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//        "adl": "3",
	//        "availPos": "1",
	//        "avgPx": "34131.1",
	//        "cTime": "1627227626502",
	//        "ccy": "USDT",
	//        "deltaBS": "",
	//        "deltaPA": "",
	//        "gammaBS": "",
	//        "gammaPA": "",
	//        "imr": "170.66093041794787",
	//        "instId": "BTC-USDT-SWAP",
	//        "instType": "SWAP",
	//        "interest": "0",
	//        "last": "34134.4",
	//        "lever": "2",
	//        "liab": "",
	//        "liabCcy": "",
	//        "liqPx": "12608.959083877446",
	//        "markPx": "4786.459271773621",
	//        "margin": "",
	//        "mgnMode": "cross",
	//        "mgnRatio": "140.49930117599155",
	//        "mmr": "1.3652874433435829",
	//        "notionalUsd": "341.5130010779638",
	//        "optVal": "",
	//        "pos": "1",
	//        "posCcy": "",
	//        "posId": "339552508062380036",
	//        "posSide": "long",
	//        "thetaBS": "",
	//        "thetaPA": "",
	//        "tradeId": "98617799",
	//        "uTime": "1627227626502",
	//        "upl": "0.0108608358957281",
	//        "uplRatio": "0.0000636418743944",
	//        "vegaBS": "",
	//        "vegaPA": ""
	//    }
	// history
	//    {
	//        "cTime":"1708351230102",
	//        "ccy":"USDT",
	//        "closeAvgPx":"1.2567",
	//        "closeTotalPos":"40",
	//        "direction":"short",
	//        "fee":"-0.0351036",
	//        "fundingFee":"0",
	//        "instId":"SUSHI-USDT-SWAP",
	//        "instType":"SWAP",
	//        "lever":"10.0",
	//        "liqPenalty":"0",
	//        "mgnMode":"isolated",
	//        "openAvgPx":"1.2462",
	//        "openMaxPos":"40",
	//        "pnl":"-0.42",
	//        "pnlRatio":"-0.0912982667308618",
	//        "posId":"666159086676836352",
	//        "realizedPnl":"-0.4551036",
	//        "triggerPx":"",
	//        "type":"2",
	//        "uTime":"1708354805699",
	//        "uly":"SUSHI-USDT"
	//    }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(position, "instId")
	market = this.SafeMarket(marketId, market, nil, "contract")
	var symbol interface{} = GetValue(market, "symbol")
	var pos interface{} = this.SafeString(position, "pos") // 'pos' field: One way mode: 0 if position is not open, 1 if open | Two way (hedge) mode: -1 if short, 1 if long, 0 if position is not open
	var contractsAbs interface{} = Precise.StringAbs(pos)
	var side interface{} = this.SafeString2(position, "posSide", "direction")
	var hedged interface{} = !IsEqual(side, "net")
	var contracts interface{} = this.ParseNumber(contractsAbs)
	if IsTrue(GetValue(market, "margin")) {
		// margin position
		if IsTrue(IsEqual(side, "net")) {
			var posCcy interface{} = this.SafeString(position, "posCcy")
			var parsedCurrency interface{} = this.SafeCurrencyCode(posCcy)
			if IsTrue(!IsEqual(parsedCurrency, nil)) {
				side = Ternary(IsTrue((IsEqual(GetValue(market, "base"), parsedCurrency))), "long", "short")
			}
		}
		if IsTrue(IsEqual(side, nil)) {
			side = this.SafeString(position, "direction")
		}
	} else {
		if IsTrue(!IsEqual(pos, nil)) {
			if IsTrue(IsEqual(side, "net")) {
				if IsTrue(Precise.StringGt(pos, "0")) {
					side = "long"
				} else if IsTrue(Precise.StringLt(pos, "0")) {
					side = "short"
				} else {
					side = nil
				}
			}
		}
	}
	var contractSize interface{} = this.SafeNumber(market, "contractSize")
	var contractSizeString interface{} = this.NumberToString(contractSize)
	var markPriceString interface{} = this.SafeString(position, "markPx")
	var notionalString interface{} = this.SafeString(position, "notionalUsd")
	if IsTrue(GetValue(market, "inverse")) {
		notionalString = Precise.StringDiv(Precise.StringMul(contractsAbs, contractSizeString), markPriceString)
	}
	var notional interface{} = this.ParseNumber(notionalString)
	var marginMode interface{} = this.SafeString(position, "mgnMode")
	var initialMarginString interface{} = nil
	var entryPriceString interface{} = this.SafeString2(position, "avgPx", "openAvgPx")
	var unrealizedPnlString interface{} = this.SafeString(position, "upl")
	var leverageString interface{} = this.SafeString(position, "lever")
	var initialMarginPercentage interface{} = nil
	var collateralString interface{} = nil
	if IsTrue(IsEqual(marginMode, "cross")) {
		initialMarginString = this.SafeString(position, "imr")
		collateralString = Precise.StringAdd(initialMarginString, unrealizedPnlString)
	} else if IsTrue(IsEqual(marginMode, "isolated")) {
		initialMarginPercentage = Precise.StringDiv("1", leverageString)
		collateralString = this.SafeString(position, "margin")
	}
	var maintenanceMarginString interface{} = this.SafeString(position, "mmr")
	var maintenanceMargin interface{} = this.ParseNumber(maintenanceMarginString)
	var maintenanceMarginPercentageString interface{} = Precise.StringDiv(maintenanceMarginString, notionalString)
	if IsTrue(IsEqual(initialMarginPercentage, nil)) {
		initialMarginPercentage = this.ParseNumber(Precise.StringDiv(initialMarginString, notionalString, 4))
	} else if IsTrue(IsEqual(initialMarginString, nil)) {
		initialMarginString = Precise.StringDiv(Precise.StringDiv(Precise.StringMul(contractsAbs, contractSizeString), entryPriceString), leverageString)
	}
	var rounder interface{} = "0.00005" // round to closest 0.01%
	var maintenanceMarginPercentage interface{} = this.ParseNumber(Precise.StringDiv(Precise.StringAdd(maintenanceMarginPercentageString, rounder), "1", 4))
	var liquidationPrice interface{} = this.SafeNumber(position, "liqPx")
	var percentageString interface{} = this.SafeString(position, "uplRatio")
	var percentage interface{} = this.ParseNumber(Precise.StringMul(percentageString, "100"))
	var timestamp interface{} = this.SafeInteger(position, "cTime")
	var marginRatio interface{} = this.ParseNumber(Precise.StringDiv(maintenanceMarginString, collateralString, 4))
	return this.SafePosition(map[string]interface{}{
		"info":                        position,
		"id":                          this.SafeString(position, "posId"),
		"symbol":                      symbol,
		"notional":                    notional,
		"marginMode":                  marginMode,
		"liquidationPrice":            liquidationPrice,
		"entryPrice":                  this.ParseNumber(entryPriceString),
		"unrealizedPnl":               this.ParseNumber(unrealizedPnlString),
		"realizedPnl":                 this.SafeNumber(position, "realizedPnl"),
		"percentage":                  percentage,
		"contracts":                   contracts,
		"contractSize":                contractSize,
		"markPrice":                   this.ParseNumber(markPriceString),
		"lastPrice":                   this.SafeNumber(position, "closeAvgPx"),
		"side":                        side,
		"hedged":                      hedged,
		"timestamp":                   timestamp,
		"datetime":                    this.Iso8601(timestamp),
		"lastUpdateTimestamp":         this.SafeInteger(position, "uTime"),
		"maintenanceMargin":           maintenanceMargin,
		"maintenanceMarginPercentage": maintenanceMarginPercentage,
		"collateral":                  this.ParseNumber(collateralString),
		"initialMargin":               this.ParseNumber(initialMarginString),
		"initialMarginPercentage":     this.ParseNumber(initialMarginPercentage),
		"leverage":                    this.ParseNumber(leverageString),
		"marginRatio":                 marginRatio,
		"stopLossPrice":               nil,
		"takeProfitPrice":             nil,
	})
}

/**
 * @method
 * @name okx#transfer
 * @description transfer currency internally between wallets on the same account
 * @see https://www.okx.com/docs-v5/en/#rest-api-funding-funds-transfer
 * @param {string} code unified currency code
 * @param {float} amount amount to transfer
 * @param {string} fromAccount account to transfer from
 * @param {string} toAccount account to transfer to
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/?id=transfer-structure}
 */
func (this *OkxCore) Transfer(code interface{}, amount interface{}, fromAccount interface{}, toAccount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes62178 := (<-this.LoadMarkets())
		PanicOnError(retRes62178)
		var currency interface{} = this.Currency(code)
		var accountsByType interface{} = this.SafeDict(this.Options, "accountsByType", map[string]interface{}{})
		var fromId interface{} = this.SafeString(accountsByType, fromAccount, fromAccount)
		var toId interface{} = this.SafeString(accountsByType, toAccount, toAccount)
		var request interface{} = map[string]interface{}{
			"ccy":  GetValue(currency, "id"),
			"amt":  this.CurrencyToPrecision(code, amount),
			"type": "0",
			"from": fromId,
			"to":   toId,
		}
		if IsTrue(IsEqual(fromId, "master")) {
			AddElementToObject(request, "type", "1")
			AddElementToObject(request, "subAcct", toId)
			AddElementToObject(request, "from", this.SafeString(params, "from", "6"))
			AddElementToObject(request, "to", this.SafeString(params, "to", "6"))
		} else if IsTrue(IsEqual(toId, "master")) {
			AddElementToObject(request, "type", "2")
			AddElementToObject(request, "subAcct", fromId)
			AddElementToObject(request, "from", this.SafeString(params, "from", "6"))
			AddElementToObject(request, "to", this.SafeString(params, "to", "6"))
		}

		response := (<-this.PrivatePostAssetTransfer(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "0",
		//         "msg": "",
		//         "data": [
		//             {
		//                 "transId": "754147",
		//                 "ccy": "USDT",
		//                 "from": "6",
		//                 "amt": "0.1",
		//                 "to": "18"
		//             }
		//         ]
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var rawTransfer interface{} = this.SafeDict(data, 0, map[string]interface{}{})

		ch <- this.ParseTransfer(rawTransfer, currency)
		return nil

	}()
	return ch
}
func (this *OkxCore) ParseTransfer(transfer interface{}, optionalArgs ...interface{}) interface{} {
	//
	// transfer
	//
	//     {
	//         "transId": "754147",
	//         "ccy": "USDT",
	//         "from": "6",
	//         "amt": "0.1",
	//         "to": "18"
	//     }
	//
	// fetchTransfer
	//
	//     {
	//         "amt": "5",
	//         "ccy": "USDT",
	//         "from": "18",
	//         "instId": "",
	//         "state": "success",
	//         "subAcct": "",
	//         "to": "6",
	//         "toInstId": "",
	//         "transId": "464424732",
	//         "type": "0"
	//     }
	//
	// fetchTransfers
	//
	//     {
	//         "bal": "70.6874353780312913",
	//         "balChg": "-4.0000000000000000", // negative means "to funding", positive meand "from funding"
	//         "billId": "588900695232225299",
	//         "ccy": "USDT",
	//         "execType": "",
	//         "fee": "",
	//         "from": "18",
	//         "instId": "",
	//         "instType": "",
	//         "mgnMode": "",
	//         "notes": "To Funding Account",
	//         "ordId": "",
	//         "pnl": "",
	//         "posBal": "",
	//         "posBalChg": "",
	//         "price": "0",
	//         "subType": "12",
	//         "sz": "-4",
	//         "to": "6",
	//         "ts": "1686676866989",
	//         "type": "1"
	//     }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var id interface{} = this.SafeString2(transfer, "transId", "billId")
	var currencyId interface{} = this.SafeString(transfer, "ccy")
	var code interface{} = this.SafeCurrencyCode(currencyId, currency)
	var amount interface{} = this.SafeNumber(transfer, "amt")
	var fromAccountId interface{} = this.SafeString(transfer, "from")
	var toAccountId interface{} = this.SafeString(transfer, "to")
	var accountsById interface{} = this.SafeDict(this.Options, "accountsById", map[string]interface{}{})
	var timestamp interface{} = this.SafeInteger(transfer, "ts")
	var balanceChange interface{} = this.SafeString(transfer, "sz")
	if IsTrue(!IsEqual(balanceChange, nil)) {
		amount = this.ParseNumber(Precise.StringAbs(balanceChange))
	}
	return map[string]interface{}{
		"info":        transfer,
		"id":          id,
		"timestamp":   timestamp,
		"datetime":    this.Iso8601(timestamp),
		"currency":    code,
		"amount":      amount,
		"fromAccount": this.SafeString(accountsById, fromAccountId),
		"toAccount":   this.SafeString(accountsById, toAccountId),
		"status":      this.ParseTransferStatus(this.SafeString(transfer, "state")),
	}
}
func (this *OkxCore) ParseTransferStatus(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"success": "ok",
	}
	return this.SafeString(statuses, status, status)
}
func (this *OkxCore) FetchTransfer(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes63518 := (<-this.LoadMarkets())
		PanicOnError(retRes63518)
		var request interface{} = map[string]interface{}{
			"transId": id,
		}

		response := (<-this.PrivateGetAssetTransferState(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "0",
		//         "data": [
		//             {
		//                 "amt": "5",
		//                 "ccy": "USDT",
		//                 "from": "18",
		//                 "instId": "",
		//                 "state": "success",
		//                 "subAcct": "",
		//                 "to": "6",
		//                 "toInstId": "",
		//                 "transId": "464424732",
		//                 "type": "0"
		//             }
		//         ],
		//         "msg": ""
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var transfer interface{} = this.SafeDict(data, 0)

		ch <- this.ParseTransfer(transfer)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#fetchTransfers
 * @description fetch a history of internal transfers made on an account
 * @see https://www.okx.com/docs-v5/en/#trading-account-rest-api-get-bills-details-last-3-months
 * @param {string} code unified currency code of the currency transferred
 * @param {int} [since] the earliest time in ms to fetch transfers for
 * @param {int} [limit] the maximum number of transfers structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transfer structures]{@link https://docs.ccxt.com/?id=transfer-structure}
 */
func (this *OkxCore) FetchTransfers(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes63948 := (<-this.LoadMarkets())
		PanicOnError(retRes63948)
		var currency interface{} = nil
		var request interface{} = map[string]interface{}{
			"type": "1",
		}
		if IsTrue(!IsEqual(code, nil)) {
			currency = this.Currency(code)
			AddElementToObject(request, "ccy", GetValue(currency, "id"))
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "begin", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}

		response := (<-this.PrivateGetAccountBillsArchive(this.Extend(request, params)))
		PanicOnError(response)
		//
		//    {
		//        "code": "0",
		//        "data": [
		//            {
		//                "bal": "70.6874353780312913",
		//                "balChg": "-4.0000000000000000",
		//                "billId": "588900695232225299",
		//                "ccy": "USDT",
		//                "execType": "",
		//                "fee": "",
		//                "from": "18",
		//                "instId": "",
		//                "instType": "",
		//                "mgnMode": "",
		//                "notes": "To Funding Account",
		//                "ordId": "",
		//                "pnl": "",
		//                "posBal": "",
		//                "posBalChg": "",
		//                "price": "0",
		//                "subType": "12",
		//                "sz": "-4",
		//                "to": "6",
		//                "ts": "1686676866989",
		//                "type": "1"
		//            },
		//            ...
		//        ],
		//        "msg": ""
		//    }
		//
		var transfers interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseTransfers(transfers, currency, since, limit, params)
		return nil

	}()
	return ch
}
func (this *OkxCore) Sign(path interface{}, optionalArgs ...interface{}) interface{} {
	api := GetArg(optionalArgs, 0, "public")
	_ = api
	method := GetArg(optionalArgs, 1, "GET")
	_ = method
	params := GetArg(optionalArgs, 2, map[string]interface{}{})
	_ = params
	headers := GetArg(optionalArgs, 3, nil)
	_ = headers
	body := GetArg(optionalArgs, 4, nil)
	_ = body
	var isArray interface{} = IsArray(params)
	var request interface{} = Add(Add(Add("/api/", this.Version), "/"), this.ImplodeParams(path, params))
	var query interface{} = this.Omit(params, this.ExtractParams(path))
	var url interface{} = Add(this.ImplodeHostname(GetValue(GetValue(this.Urls, "api"), "rest")), request)
	// const type = this.getPathAuthenticationType (path);
	if IsTrue(IsEqual(api, "public")) {
		if IsTrue(GetArrayLength(ObjectKeys(query))) {
			url = Add(url, Add("?", this.Urlencode(query)))
		}
	} else if IsTrue(IsEqual(api, "private")) {
		this.CheckRequiredCredentials()
		// inject id in implicit api call
		if IsTrue(IsTrue(IsEqual(method, "POST")) && IsTrue((IsTrue(IsTrue(IsEqual(path, "trade/batch-orders")) || IsTrue(IsEqual(path, "trade/order-algo"))) || IsTrue(IsEqual(path, "trade/order"))))) {
			var brokerId interface{} = this.SafeString(this.Options, "brokerId", "6b9ad766b55dBCDE")
			if IsTrue(IsArray(params)) {
				for i := 0; IsLessThan(i, GetArrayLength(params)); i++ {
					var entry interface{} = GetValue(params, i)
					var clientOrderId interface{} = this.SafeString(entry, "clOrdId")
					if IsTrue(IsEqual(clientOrderId, nil)) {
						AddElementToObject(entry, "clOrdId", Add(brokerId, this.Uuid16()))
						AddElementToObject(entry, "tag", brokerId)
						AddElementToObject(params, i, entry)
					}
				}
			} else {
				var clientOrderId interface{} = this.SafeString(params, "clOrdId")
				if IsTrue(IsEqual(clientOrderId, nil)) {
					AddElementToObject(params, "clOrdId", Add(brokerId, this.Uuid16()))
					AddElementToObject(params, "tag", brokerId)
				}
			}
		}
		var timestamp interface{} = this.Iso8601(this.Nonce())
		headers = map[string]interface{}{
			"OK-ACCESS-KEY":        this.ApiKey,
			"OK-ACCESS-PASSPHRASE": this.Password,
			"OK-ACCESS-TIMESTAMP":  timestamp,
		}
		var auth interface{} = Add(Add(timestamp, method), request)
		if IsTrue(IsEqual(method, "GET")) {
			if IsTrue(GetArrayLength(ObjectKeys(query))) {
				var urlencodedQuery interface{} = Add("?", this.Urlencode(query))
				url = Add(url, urlencodedQuery)
				auth = Add(auth, urlencodedQuery)
			}
		} else {
			if IsTrue(IsTrue(isArray) || IsTrue(GetArrayLength(ObjectKeys(query)))) {
				body = this.Json(query)
				auth = Add(auth, body)
			}
			AddElementToObject(headers, "Content-Type", "application/json")
		}
		var signature interface{} = this.Hmac(this.Encode(auth), this.Encode(this.Secret), sha256, "base64")
		AddElementToObject(headers, "OK-ACCESS-SIGN", signature)
	}
	return map[string]interface{}{
		"url":     url,
		"method":  method,
		"body":    body,
		"headers": headers,
	}
}
func (this *OkxCore) ParseFundingRate(contract interface{}, optionalArgs ...interface{}) interface{} {
	//
	//    {
	//        "fundingRate": "0.00027815",
	//        "fundingTime": "1634256000000",
	//        "instId": "BTC-USD-SWAP",
	//        "instType": "SWAP",
	//        "nextFundingRate": "0.00017",
	//        "nextFundingTime": "1634284800000"
	//    }
	// ws
	//     {
	//        "fundingRate":"0.0001875391284828",
	//        "fundingTime":"1700726400000",
	//        "instId":"BTC-USD-SWAP",
	//        "instType":"SWAP",
	//        "method": "next_period",
	//        "maxFundingRate":"0.00375",
	//        "minFundingRate":"-0.00375",
	//        "nextFundingRate":"0.0002608059239328",
	//        "nextFundingTime":"1700755200000",
	//        "premium": "0.0001233824646391",
	//        "settFundingRate":"0.0001699799259033",
	//        "settState":"settled",
	//        "ts":"1700724675402"
	//     }
	//
	// in the response above nextFundingRate is actually two funding rates from now
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var nextFundingRateTimestamp interface{} = this.SafeInteger(contract, "nextFundingTime")
	var marketId interface{} = this.SafeString(contract, "instId")
	var symbol interface{} = this.SafeSymbol(marketId, market)
	var nextFundingRate interface{} = this.SafeNumber(contract, "nextFundingRate")
	var fundingTime interface{} = this.SafeInteger(contract, "fundingTime")
	var fundingTimeString interface{} = this.SafeString(contract, "fundingTime")
	var nextFundingTimeString interface{} = this.SafeString(contract, "nextFundingTime")
	var millisecondsInterval interface{} = Precise.StringSub(nextFundingTimeString, fundingTimeString)
	// https://www.okx.com/support/hc/en-us/articles/360053909272--Introduction-to-perpetual-swap-funding-fee
	// > The current interest is 0.
	return map[string]interface{}{
		"info":                     contract,
		"symbol":                   symbol,
		"markPrice":                nil,
		"indexPrice":               nil,
		"interestRate":             this.ParseNumber("0"),
		"estimatedSettlePrice":     nil,
		"timestamp":                nil,
		"datetime":                 nil,
		"fundingRate":              this.SafeNumber(contract, "fundingRate"),
		"fundingTimestamp":         fundingTime,
		"fundingDatetime":          this.Iso8601(fundingTime),
		"nextFundingRate":          nextFundingRate,
		"nextFundingTimestamp":     nextFundingRateTimestamp,
		"nextFundingDatetime":      this.Iso8601(nextFundingRateTimestamp),
		"previousFundingRate":      nil,
		"previousFundingTimestamp": nil,
		"previousFundingDatetime":  nil,
		"interval":                 this.ParseFundingInterval(millisecondsInterval),
	}
}
func (this *OkxCore) ParseFundingInterval(interval interface{}) interface{} {
	var intervals interface{} = map[string]interface{}{
		"3600000":  "1h",
		"14400000": "4h",
		"28800000": "8h",
		"57600000": "16h",
		"86400000": "24h",
	}
	return this.SafeString(intervals, interval, interval)
}

/**
 * @method
 * @name okx#fetchFundingInterval
 * @description fetch the current funding rate interval
 * @see https://www.okx.com/docs-v5/en/#public-data-rest-api-get-funding-rate
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/?id=funding-rate-structure}
 */
func (this *OkxCore) FetchFundingInterval(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes659015 := (<-this.FetchFundingRate(symbol, params))
		PanicOnError(retRes659015)
		ch <- retRes659015
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#fetchFundingRate
 * @description fetch the current funding rate
 * @see https://www.okx.com/docs-v5/en/#public-data-rest-api-get-funding-rate
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/?id=funding-rate-structure}
 */
func (this *OkxCore) FetchFundingRate(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes66038 := (<-this.LoadMarkets())
		PanicOnError(retRes66038)
		var market interface{} = this.Market(symbol)
		if !IsTrue(GetValue(market, "swap")) {
			panic(ExchangeError(Add(this.Id, " fetchFundingRate() is only valid for swap markets")))
		}
		var request interface{} = map[string]interface{}{
			"instId": GetValue(market, "id"),
		}

		response := (<-this.PublicGetPublicFundingRate(this.Extend(request, params)))
		PanicOnError(response)
		//
		//    {
		//        "code": "0",
		//        "data": [
		//            {
		//                "fundingRate": "0.00027815",
		//                "fundingTime": "1634256000000",
		//                "instId": "BTC-USD-SWAP",
		//                "instType": "SWAP",
		//                "nextFundingRate": "0.00017",
		//                "nextFundingTime": "1634284800000"
		//            }
		//        ],
		//        "msg": ""
		//    }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var entry interface{} = this.SafeDict(data, 0, map[string]interface{}{})

		ch <- this.ParseFundingRate(entry, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#fetchFundingRates
 * @description fetches the current funding rates for multiple symbols
 * @see https://www.okx.com/docs-v5/en/#public-data-rest-api-get-funding-rate
 * @param {string[]} symbols unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [funding rates structure]{@link https://docs.ccxt.com/?id=funding-rates-structure}
 */
func (this *OkxCore) FetchFundingRates(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes66438 := (<-this.LoadMarkets())
		PanicOnError(retRes66438)
		symbols = this.MarketSymbols(symbols, "swap", true)
		var request interface{} = map[string]interface{}{
			"instId": "ANY",
		}

		response := (<-this.PublicGetPublicFundingRate(this.Extend(request, params)))
		PanicOnError(response)
		//
		//    {
		//        "code": "0",
		//        "data": [
		//            {
		//                "fundingRate": "0.00027815",
		//                "fundingTime": "1634256000000",
		//                "instId": "BTC-USD-SWAP",
		//                "instType": "SWAP",
		//                "nextFundingRate": "0.00017",
		//                "nextFundingTime": "1634284800000"
		//            }
		//        ],
		//        "msg": ""
		//    }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseFundingRates(data, symbols)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#fetchFundingHistory
 * @description fetch the history of funding payments paid and received on this account
 * @see https://www.okx.com/docs-v5/en/#trading-account-rest-api-get-bills-details-last-3-months
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch funding history for
 * @param {int} [limit] the maximum number of funding history structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding history structure]{@link https://docs.ccxt.com/?id=funding-history-structure}
 */
func (this *OkxCore) FetchFundingHistory(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes66798 := (<-this.LoadMarkets())
		PanicOnError(retRes66798)
		var request interface{} = map[string]interface{}{
			"type": "8",
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", ToString(limit)) // default 100, max 100
		}
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			symbol = GetValue(market, "symbol")
			if IsTrue(GetValue(market, "contract")) {
				if IsTrue(GetValue(market, "linear")) {
					AddElementToObject(request, "ctType", "linear")
					AddElementToObject(request, "ccy", GetValue(market, "quoteId"))
				} else {
					AddElementToObject(request, "ctType", "inverse")
					AddElementToObject(request, "ccy", GetValue(market, "baseId"))
				}
			}
		}
		typeVarqueryVariable := this.HandleMarketTypeAndParams("fetchFundingHistory", market, params)
		typeVar := GetValue(typeVarqueryVariable, 0)
		query := GetValue(typeVarqueryVariable, 1)
		if IsTrue(IsEqual(typeVar, "swap")) {
			AddElementToObject(request, "instType", this.ConvertToInstrumentType(typeVar))
		}
		// AccountBillsArchive has the same cost as AccountBills but supports three months of data

		response := (<-this.PrivateGetAccountBillsArchive(this.Extend(request, query)))
		PanicOnError(response)
		//
		//    {
		//        "bal": "0.0242946200998573",
		//        "balChg": "0.0000148752712240",
		//        "billId": "377970609204146187",
		//        "ccy": "ETH",
		//        "execType": "",
		//        "fee": "0",
		//        "from": "",
		//        "instId": "ETH-USD-SWAP",
		//        "instType": "SWAP",
		//        "mgnMode": "isolated",
		//        "notes": "",
		//        "ordId": "",
		//        "pnl": "0.000014875271224",
		//        "posBal": "0",
		//        "posBalChg": "0",
		//        "subType": "174",
		//        "sz": "9",
		//        "to": "",
		//        "ts": "1636387215588",
		//        "type": "8"
		//    }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var result interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
			var entry interface{} = GetValue(data, i)
			var timestamp interface{} = this.SafeInteger(entry, "ts")
			var instId interface{} = this.SafeString(entry, "instId")
			var marketInner interface{} = this.SafeMarket(instId)
			var currencyId interface{} = this.SafeString(entry, "ccy")
			var code interface{} = this.SafeCurrencyCode(currencyId)
			AppendToArray(&result, map[string]interface{}{
				"info":      entry,
				"symbol":    GetValue(marketInner, "symbol"),
				"code":      code,
				"timestamp": timestamp,
				"datetime":  this.Iso8601(timestamp),
				"id":        this.SafeString(entry, "billId"),
				"amount":    this.SafeNumber(entry, "balChg"),
			})
		}
		var sorted interface{} = this.SortBy(result, "timestamp")

		ch <- this.FilterBySymbolSinceLimit(sorted, symbol, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#setLeverage
 * @description set the level of leverage for a market
 * @see https://www.okx.com/docs-v5/en/#rest-api-account-set-leverage
 * @param {float} leverage the rate of leverage
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] 'cross' or 'isolated'
 * @param {string} [params.posSide] 'long' or 'short' or 'net' for isolated margin long/short mode on futures and swap markets, default is 'net'
 * @returns {object} response from the exchange
 */
func (this *OkxCore) SetLeverage(leverage interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " setLeverage() requires a symbol argument")))
		}
		// WARNING: THIS WILL INCREASE LIQUIDATION PRICE FOR OPEN ISOLATED LONG POSITIONS
		// AND DECREASE LIQUIDATION PRICE FOR OPEN ISOLATED SHORT POSITIONS
		if IsTrue(IsTrue((IsLessThan(leverage, 1))) || IsTrue((IsGreaterThan(leverage, 125)))) {
			panic(BadRequest(Add(this.Id, " setLeverage() leverage should be between 1 and 125")))
		}

		retRes68478 := (<-this.LoadMarkets())
		PanicOnError(retRes68478)
		var market interface{} = this.Market(symbol)
		var marginMode interface{} = nil
		marginModeparamsVariable := this.HandleMarginModeAndParams("setLeverage", params)
		marginMode = GetValue(marginModeparamsVariable, 0)
		params = GetValue(marginModeparamsVariable, 1)
		if IsTrue(IsEqual(marginMode, nil)) {
			marginMode = this.SafeString(params, "mgnMode", "cross") // cross as default marginMode
		}
		if IsTrue(IsTrue((!IsEqual(marginMode, "cross"))) && IsTrue((!IsEqual(marginMode, "isolated")))) {
			panic(BadRequest(Add(this.Id, " setLeverage() requires a marginMode parameter that must be either cross or isolated")))
		}
		var request interface{} = map[string]interface{}{
			"lever":   leverage,
			"mgnMode": marginMode,
			"instId":  GetValue(market, "id"),
		}
		var posSide interface{} = this.SafeString(params, "posSide", "net")
		if IsTrue(IsEqual(marginMode, "isolated")) {
			if IsTrue(IsTrue(IsTrue(!IsEqual(posSide, "long")) && IsTrue(!IsEqual(posSide, "short"))) && IsTrue(!IsEqual(posSide, "net"))) {
				panic(BadRequest(Add(this.Id, " setLeverage() requires the posSide argument to be either \"long\", \"short\" or \"net\"")))
			}
			AddElementToObject(request, "posSide", posSide)
		}

		response := (<-this.PrivatePostAccountSetLeverage(this.Extend(request, params)))
		PanicOnError(response)

		//
		//     {
		//       "code": "0",
		//       "data": [
		//         {
		//           "instId": "BTC-USDT-SWAP",
		//           "lever": "5",
		//           "mgnMode": "isolated",
		//           "posSide": "long"
		//         }
		//       ],
		//       "msg": ""
		//     }
		//
		ch <- response
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#fetchPositionMode
 * @see https://www.okx.com/docs-v5/en/#trading-account-rest-api-get-account-configuration
 * @description fetchs the position mode, hedged or one way, hedged for binance is set identically for all linear markets or all inverse markets
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.accountId] if you have multiple accounts, you must specify the account id to fetch the position mode
 * @returns {object} an object detailing whether the market is in hedged or one-way mode
 */
func (this *OkxCore) FetchPositionMode(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		accounts := (<-this.FetchAccounts())
		PanicOnError(accounts)
		var length interface{} = GetArrayLength(accounts)
		var selectedAccount interface{} = nil
		if IsTrue(IsGreaterThan(length, 1)) {
			var accountId interface{} = this.SafeString(params, "accountId")
			if IsTrue(IsEqual(accountId, nil)) {
				var accountIds interface{} = this.GetListFromObjectValues(accounts, "id")
				panic(ExchangeError(Add(Add(this.Id, " fetchPositionMode() can not detect position mode, because you have multiple accounts. Set params[\"accountId\"] to desired id from: "), Join(accountIds, ", "))))
			} else {
				var accountsById interface{} = this.IndexBy(accounts, "id")
				selectedAccount = this.SafeDict(accountsById, accountId)
			}
		} else {
			selectedAccount = GetValue(accounts, 0)
		}
		var mainAccount interface{} = GetValue(selectedAccount, "info")
		var posMode interface{} = this.SafeString(mainAccount, "posMode") // long_short_mode, net_mode
		var isHedged interface{} = IsEqual(posMode, "long_short_mode")

		ch <- map[string]interface{}{
			"info":   mainAccount,
			"hedged": isHedged,
		}
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#setPositionMode
 * @description set hedged to true or false for a market
 * @see https://www.okx.com/docs-v5/en/#trading-account-rest-api-set-position-mode
 * @param {bool} hedged set to true to use long_short_mode, false for net_mode
 * @param {string} symbol not used by okx setPositionMode
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} response from the exchange
 */
func (this *OkxCore) SetPositionMode(hedged interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		var hedgeMode interface{} = nil
		if IsTrue(hedged) {
			hedgeMode = "long_short_mode"
		} else {
			hedgeMode = "net_mode"
		}
		var request interface{} = map[string]interface{}{
			"posMode": hedgeMode,
		}

		response := (<-this.PrivatePostAccountSetPositionMode(this.Extend(request, params)))
		PanicOnError(response)

		//
		//    {
		//        "code": "0",
		//        "data": [
		//            {
		//                "posMode": "net_mode"
		//            }
		//        ],
		//        "msg": ""
		//    }
		//
		ch <- response
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#setMarginMode
 * @description set margin mode to 'cross' or 'isolated'
 * @see https://www.okx.com/docs-v5/en/#trading-account-rest-api-set-leverage
 * @param {string} marginMode 'cross' or 'isolated'
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.leverage] leverage
 * @returns {object} response from the exchange
 */
func (this *OkxCore) SetMarginMode(marginMode interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " setMarginMode() requires a symbol argument")))
		}
		// WARNING: THIS WILL INCREASE LIQUIDATION PRICE FOR OPEN ISOLATED LONG POSITIONS
		// AND DECREASE LIQUIDATION PRICE FOR OPEN ISOLATED SHORT POSITIONS
		marginMode = ToLower(marginMode)
		if IsTrue(IsTrue((!IsEqual(marginMode, "cross"))) && IsTrue((!IsEqual(marginMode, "isolated")))) {
			panic(BadRequest(Add(this.Id, " setMarginMode() marginMode must be either cross or isolated")))
		}

		retRes69788 := (<-this.LoadMarkets())
		PanicOnError(retRes69788)
		var market interface{} = this.Market(symbol)
		var lever interface{} = this.SafeInteger2(params, "lever", "leverage")
		if IsTrue(IsTrue(IsTrue((IsEqual(lever, nil))) || IsTrue((IsLessThan(lever, 1)))) || IsTrue((IsGreaterThan(lever, 125)))) {
			panic(BadRequest(Add(this.Id, " setMarginMode() params[\"lever\"] should be between 1 and 125")))
		}
		params = this.Omit(params, []interface{}{"leverage"})
		var request interface{} = map[string]interface{}{
			"lever":   lever,
			"mgnMode": marginMode,
			"instId":  GetValue(market, "id"),
		}

		response := (<-this.PrivatePostAccountSetLeverage(this.Extend(request, params)))
		PanicOnError(response)

		//
		//     {
		//       "code": "0",
		//       "data": [
		//         {
		//           "instId": "BTC-USDT-SWAP",
		//           "lever": "5",
		//           "mgnMode": "isolated",
		//           "posSide": "long"
		//         }
		//       ],
		//       "msg": ""
		//     }
		//
		ch <- response
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#fetchCrossBorrowRates
 * @description fetch the borrow interest rates of all currencies
 * @see https://www.okx.com/docs-v5/en/#trading-account-rest-api-get-interest-rate
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [borrow rate structures]{@link https://docs.ccxt.com/?id=borrow-rate-structure}
 */
func (this *OkxCore) FetchCrossBorrowRates(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes70178 := (<-this.LoadMarkets())
		PanicOnError(retRes70178)

		response := (<-this.PrivateGetAccountInterestRate(params))
		PanicOnError(response)
		//
		//    {
		//        "code": "0",
		//        "data": [
		//            {
		//                "ccy": "BTC",
		//                "interestRate": "0.00000833"
		//            }
		//            ...
		//        ],
		//    }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var rates interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
			AppendToArray(&rates, this.ParseBorrowRate(GetValue(data, i)))
		}

		ch <- rates
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#fetchCrossBorrowRate
 * @description fetch the rate of interest to borrow a currency for margin trading
 * @see https://www.okx.com/docs-v5/en/#trading-account-rest-api-get-interest-rate
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [borrow rate structure]{@link https://docs.ccxt.com/?id=borrow-rate-structure}
 */
func (this *OkxCore) FetchCrossBorrowRate(code interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes70498 := (<-this.LoadMarkets())
		PanicOnError(retRes70498)
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"ccy": GetValue(currency, "id"),
		}

		response := (<-this.PrivateGetAccountInterestRate(this.Extend(request, params)))
		PanicOnError(response)
		//
		//    {
		//        "code": "0",
		//        "data": [
		//             {
		//                "ccy": "USDT",
		//                "interestRate": "0.00002065"
		//             }
		//             ...
		//        ],
		//        "msg": ""
		//    }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var rate interface{} = this.SafeDict(data, 0, map[string]interface{}{})

		ch <- this.ParseBorrowRate(rate)
		return nil

	}()
	return ch
}
func (this *OkxCore) ParseBorrowRate(info interface{}, optionalArgs ...interface{}) interface{} {
	//
	//    {
	//        "amt": "992.10341195",
	//        "ccy": "BTC",
	//        "rate": "0.01",
	//        "ts": "1643954400000"
	//    }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var ccy interface{} = this.SafeString(info, "ccy")
	var timestamp interface{} = this.SafeInteger(info, "ts")
	return map[string]interface{}{
		"currency":  this.SafeCurrencyCode(ccy),
		"rate":      this.SafeNumber2(info, "interestRate", "rate"),
		"period":    86400000,
		"timestamp": timestamp,
		"datetime":  this.Iso8601(timestamp),
		"info":      info,
	}
}
func (this *OkxCore) ParseBorrowRateHistories(response interface{}, codes interface{}, since interface{}, limit interface{}) interface{} {
	//
	//    [
	//        {
	//            "amt": "992.10341195",
	//            "ccy": "BTC",
	//            "rate": "0.01",
	//            "ts": "1643954400000"
	//        },
	//        ...
	//    ]
	//
	var borrowRateHistories interface{} = map[string]interface{}{}
	for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
		var item interface{} = GetValue(response, i)
		var code interface{} = this.SafeCurrencyCode(this.SafeString(item, "ccy"))
		if IsTrue(IsTrue(IsEqual(codes, nil)) || IsTrue(this.InArray(code, codes))) {
			if !IsTrue((InOp(borrowRateHistories, code))) {
				AddElementToObject(borrowRateHistories, code, []interface{}{})
			}
			var borrowRateStructure interface{} = this.ParseBorrowRate(item)
			var borrrowRateCode interface{} = GetValue(borrowRateHistories, code)
			AppendToArray(&borrrowRateCode, borrowRateStructure)
		}
	}
	var keys interface{} = ObjectKeys(borrowRateHistories)
	for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
		var code interface{} = GetValue(keys, i)
		AddElementToObject(borrowRateHistories, code, this.FilterByCurrencySinceLimit(GetValue(borrowRateHistories, code), code, since, limit))
	}
	return borrowRateHistories
}

/**
 * @method
 * @name okx#fetchBorrowRateHistories
 * @description retrieves a history of a multiple currencies borrow interest rate at specific time slots, returns all currencies if no symbols passed, default is undefined
 * @see https://www.okx.com/docs-v5/en/#financial-product-savings-get-public-borrow-history-public
 * @param {string[]|undefined} codes list of unified currency codes, default is undefined
 * @param {int} [since] timestamp in ms of the earliest borrowRate, default is undefined
 * @param {int} [limit] max number of borrow rate prices to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [borrow rate structures]{@link https://docs.ccxt.com/?id=borrow-rate-structure} indexed by the market symbol
 */
func (this *OkxCore) FetchBorrowRateHistories(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		codes := GetArg(optionalArgs, 0, nil)
		_ = codes
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes71398 := (<-this.LoadMarkets())
		PanicOnError(retRes71398)
		var request interface{} = map[string]interface{}{}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "before", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}

		response := (<-this.PublicGetFinanceSavingsLendingRateHistory(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "0",
		//         "data": [
		//             {
		//                 "amt": "992.10341195",
		//                 "ccy": "BTC",
		//                 "rate": "0.01",
		//                 "ts": "1643954400000"
		//             },
		//         ],
		//         "msg": ""
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseBorrowRateHistories(data, codes, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#fetchBorrowRateHistory
 * @description retrieves a history of a currencies borrow interest rate at specific time slots
 * @see https://www.okx.com/docs-v5/en/#financial-product-savings-get-public-borrow-history-public
 * @param {string} code unified currency code
 * @param {int} [since] timestamp for the earliest borrow rate
 * @param {int} [limit] the maximum number of [borrow rate structures]{@link https://docs.ccxt.com/?id=borrow-rate-structure} to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of [borrow rate structures]{@link https://docs.ccxt.com/?id=borrow-rate-structure}
 */
func (this *OkxCore) FetchBorrowRateHistory(code interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		since := GetArg(optionalArgs, 0, nil)
		_ = since
		limit := GetArg(optionalArgs, 1, nil)
		_ = limit
		params := GetArg(optionalArgs, 2, map[string]interface{}{})
		_ = params

		retRes71838 := (<-this.LoadMarkets())
		PanicOnError(retRes71838)
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"ccy": GetValue(currency, "id"),
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "before", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}

		response := (<-this.PublicGetFinanceSavingsLendingRateHistory(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "0",
		//         "data": [
		//             {
		//                 "amt": "992.10341195",
		//                 "ccy": "BTC",
		//                 "rate": "0.01",
		//                 "ts": "1643954400000"
		//             },
		//         ],
		//         "msg": ""
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseBorrowRateHistory(data, code, since, limit)
		return nil

	}()
	return ch
}
func (this *OkxCore) ModifyMarginHelper(symbol interface{}, amount interface{}, typeVar interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes72178 := (<-this.LoadMarkets())
		PanicOnError(retRes72178)
		var market interface{} = this.Market(symbol)
		var posSide interface{} = this.SafeString(params, "posSide", "net")
		params = this.Omit(params, []interface{}{"posSide"})
		var request interface{} = map[string]interface{}{
			"instId":  GetValue(market, "id"),
			"amt":     amount,
			"type":    typeVar,
			"posSide": posSide,
		}

		response := (<-this.PrivatePostAccountPositionMarginBalance(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//       "code": "0",
		//       "data": [
		//         {
		//           "amt": "0.01",
		//           "instId": "ETH-USD-SWAP",
		//           "posSide": "net",
		//           "type": "reduce"
		//         }
		//       ],
		//       "msg": ""
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var entry interface{} = this.SafeDict(data, 0, map[string]interface{}{})
		var errorCode interface{} = this.SafeString(response, "code")

		ch <- this.Extend(this.ParseMarginModification(entry, market), map[string]interface{}{
			"status": Ternary(IsTrue((IsEqual(errorCode, "0"))), "ok", "failed"),
		})
		return nil

	}()
	return ch
}
func (this *OkxCore) ParseMarginModification(data interface{}, optionalArgs ...interface{}) interface{} {
	//
	// addMargin/reduceMargin
	//
	//    {
	//        "amt": "0.01",
	//        "instId": "ETH-USD-SWAP",
	//        "posSide": "net",
	//        "type": "reduce"
	//    }
	//
	// fetchMarginAdjustmentHistory
	//
	//    {
	//        bal: '67621.4325135010619812',
	//        balChg: '-10.0000000000000000',
	//        billId: '691293628710342659',
	//        ccy: 'USDT',
	//        clOrdId: '',
	//        execType: '',
	//        fee: '0',
	//        fillFwdPx: '',
	//        fillIdxPx: '',
	//        fillMarkPx: '',
	//        fillMarkVol: '',
	//        fillPxUsd: '',
	//        fillPxVol: '',
	//        fillTime: '1711089244850',
	//        from: '',
	//        instId: 'XRP-USDT-SWAP',
	//        instType: 'SWAP',
	//        interest: '0',
	//        mgnMode: 'isolated',
	//        notes: '',
	//        ordId: '',
	//        pnl: '0',
	//        posBal: '73.12',
	//        posBalChg: '10.00',
	//        px: '',
	//        subType: '160',
	//        sz: '10',
	//        tag: '',
	//        to: '',
	//        tradeId: '0',
	//        ts: '1711089244699',
	//        type: '6'
	//    }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var amountRaw interface{} = this.SafeString2(data, "amt", "posBalChg")
	var typeRaw interface{} = this.SafeString(data, "type")
	var typeVar interface{} = nil
	if IsTrue(IsEqual(typeRaw, "6")) {
		typeVar = Ternary(IsTrue(Precise.StringGt(amountRaw, "0")), "add", "reduce")
	} else {
		typeVar = typeRaw
	}
	var amount interface{} = Precise.StringAbs(amountRaw)
	var marketId interface{} = this.SafeString(data, "instId")
	var responseMarket interface{} = this.SafeMarket(marketId, market)
	var code interface{} = Ternary(IsTrue(GetValue(responseMarket, "inverse")), GetValue(responseMarket, "base"), GetValue(responseMarket, "quote"))
	var timestamp interface{} = this.SafeInteger(data, "ts")
	return map[string]interface{}{
		"info":       data,
		"symbol":     GetValue(responseMarket, "symbol"),
		"type":       typeVar,
		"marginMode": "isolated",
		"amount":     this.ParseNumber(amount),
		"code":       code,
		"total":      nil,
		"status":     nil,
		"timestamp":  timestamp,
		"datetime":   this.Iso8601(timestamp),
	}
}

/**
 * @method
 * @name okx#reduceMargin
 * @description remove margin from a position
 * @see https://www.okx.com/docs-v5/en/#trading-account-rest-api-increase-decrease-margin
 * @param {string} symbol unified market symbol
 * @param {float} amount the amount of margin to remove
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [margin structure]{@link https://docs.ccxt.com/?id=margin-structure}
 */
func (this *OkxCore) ReduceMargin(symbol interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes733615 := (<-this.ModifyMarginHelper(symbol, amount, "reduce", params))
		PanicOnError(retRes733615)
		ch <- retRes733615
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#addMargin
 * @description add margin
 * @see https://www.okx.com/docs-v5/en/#trading-account-rest-api-increase-decrease-margin
 * @param {string} symbol unified market symbol
 * @param {float} amount amount of margin to add
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [margin structure]{@link https://docs.ccxt.com/?id=margin-structure}
 */
func (this *OkxCore) AddMargin(symbol interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes735015 := (<-this.ModifyMarginHelper(symbol, amount, "add", params))
		PanicOnError(retRes735015)
		ch <- retRes735015
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#fetchMarketLeverageTiers
 * @description retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes for a single market
 * @see https://www.okx.com/docs-v5/en/#rest-api-public-data-get-position-tiers
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] 'cross' or 'isolated'
 * @returns {object} a [leverage tiers structure]{@link https://docs.ccxt.com/?id=leverage-tiers-structure}
 */
func (this *OkxCore) FetchMarketLeverageTiers(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes73648 := (<-this.LoadMarkets())
		PanicOnError(retRes73648)
		var market interface{} = this.Market(symbol)
		var typeVar interface{} = Ternary(IsTrue(GetValue(market, "spot")), "MARGIN", this.ConvertToInstrumentType(GetValue(market, "type")))
		var uly interface{} = this.SafeString(GetValue(market, "info"), "uly")
		if !IsTrue(uly) {
			if IsTrue(!IsEqual(typeVar, "MARGIN")) {
				panic(BadRequest(Add(Add(this.Id, " fetchMarketLeverageTiers() cannot fetch leverage tiers for "), symbol)))
			}
		}
		var marginMode interface{} = nil
		marginModeparamsVariable := this.HandleMarginModeAndParams("fetchMarketLeverageTiers", params)
		marginMode = GetValue(marginModeparamsVariable, 0)
		params = GetValue(marginModeparamsVariable, 1)
		if IsTrue(IsEqual(marginMode, nil)) {
			marginMode = this.SafeString(params, "tdMode", "cross") // cross as default marginMode
		}
		var request interface{} = map[string]interface{}{
			"instType": typeVar,
			"tdMode":   marginMode,
			"uly":      uly,
		}
		if IsTrue(IsEqual(typeVar, "MARGIN")) {
			AddElementToObject(request, "instId", GetValue(market, "id"))
		}

		response := (<-this.PublicGetPublicPositionTiers(this.Extend(request, params)))
		PanicOnError(response)
		//
		//    {
		//        "code": "0",
		//        "data": [
		//            {
		//                "baseMaxLoan": "500",
		//                "imr": "0.1",
		//                "instId": "ETH-USDT",
		//                "maxLever": "10",
		//                "maxSz": "500",
		//                "minSz": "0",
		//                "mmr": "0.03",
		//                "optMgnFactor": "0",
		//                "quoteMaxLoan": "200000",
		//                "tier": "1",
		//                "uly": ""
		//            },
		//            ...
		//        ]
		//    }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseMarketLeverageTiers(data, market)
		return nil

	}()
	return ch
}
func (this *OkxCore) ParseMarketLeverageTiers(info interface{}, optionalArgs ...interface{}) interface{} {
	/**
	 * @ignore
	 * @method
	 * @param {object} info Exchange response for 1 market
	 * @param {object} market CCXT market
	 */
	//
	//    [
	//        {
	//            "baseMaxLoan": "500",
	//            "imr": "0.1",
	//            "instId": "ETH-USDT",
	//            "maxLever": "10",
	//            "maxSz": "500",
	//            "minSz": "0",
	//            "mmr": "0.03",
	//            "optMgnFactor": "0",
	//            "quoteMaxLoan": "200000",
	//            "tier": "1",
	//            "uly": ""
	//        },
	//        ...
	//    ]
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var tiers interface{} = []interface{}{}
	for i := 0; IsLessThan(i, GetArrayLength(info)); i++ {
		var tier interface{} = GetValue(info, i)
		var marketId interface{} = this.SafeString(tier, "instId")
		AppendToArray(&tiers, map[string]interface{}{
			"tier":                  this.SafeInteger(tier, "tier"),
			"symbol":                this.SafeSymbol(marketId, market),
			"currency":              GetValue(market, "quote"),
			"minNotional":           this.SafeNumber(tier, "minSz"),
			"maxNotional":           this.SafeNumber(tier, "maxSz"),
			"maintenanceMarginRate": this.SafeNumber(tier, "mmr"),
			"maxLeverage":           this.SafeNumber(tier, "maxLever"),
			"info":                  tier,
		})
	}
	return tiers
}

/**
 * @method
 * @name okx#fetchBorrowInterest
 * @description fetch the interest owed b the user for borrowing currency for margin trading
 * @see https://www.okx.com/docs-v5/en/#rest-api-account-get-interest-accrued-data
 * @param {string} code the unified currency code for the currency of the interest
 * @param {string} symbol the market symbol of an isolated margin market, if undefined, the interest for cross margin markets is returned
 * @param {int} [since] timestamp in ms of the earliest time to receive interest records for
 * @param {int} [limit] the number of [borrow interest structures]{@link https://docs.ccxt.com/?id=borrow-interest-structure} to retrieve
 * @param {object} [params] exchange specific parameters
 * @param {int} [params.type] Loan type 1 - VIP loans 2 - Market loans *Default is Market loans*
 * @param {string} [params.marginMode] 'cross' or 'isolated'
 * @returns {object[]} An list of [borrow interest structures]{@link https://docs.ccxt.com/?id=borrow-interest-structure}
 */
func (this *OkxCore) FetchBorrowInterest(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		symbol := GetArg(optionalArgs, 1, nil)
		_ = symbol
		since := GetArg(optionalArgs, 2, nil)
		_ = since
		limit := GetArg(optionalArgs, 3, nil)
		_ = limit
		params := GetArg(optionalArgs, 4, map[string]interface{}{})
		_ = params

		retRes74708 := (<-this.LoadMarkets())
		PanicOnError(retRes74708)
		var marginMode interface{} = nil
		marginModeparamsVariable := this.HandleMarginModeAndParams("fetchBorrowInterest", params)
		marginMode = GetValue(marginModeparamsVariable, 0)
		params = GetValue(marginModeparamsVariable, 1)
		if IsTrue(IsEqual(marginMode, nil)) {
			marginMode = this.SafeString(params, "mgnMode", "cross") // cross as default marginMode
		}
		var request interface{} = map[string]interface{}{
			"mgnMode": marginMode,
		}
		var market interface{} = nil
		if IsTrue(!IsEqual(code, nil)) {
			var currency interface{} = this.Currency(code)
			AddElementToObject(request, "ccy", GetValue(currency, "id"))
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "before", Subtract(since, 1))
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			AddElementToObject(request, "instId", GetValue(market, "id"))
		}

		response := (<-this.PrivateGetAccountInterestAccrued(this.Extend(request, params)))
		PanicOnError(response)
		//
		//    {
		//        "code": "0",
		//        "data": [
		//            {
		//                "ccy": "USDT",
		//                "instId": "",
		//                "interest": "0.0003960833333334",
		//                "interestRate": "0.0000040833333333",
		//                "liab": "97",
		//                "mgnMode": "",
		//                "ts": "1637312400000",
		//                "type": "1"
		//            },
		//            ...
		//        ],
		//        "msg": ""
		//    }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var interest interface{} = this.ParseBorrowInterests(data)

		ch <- this.FilterByCurrencySinceLimit(interest, code, since, limit)
		return nil

	}()
	return ch
}
func (this *OkxCore) ParseBorrowInterest(info interface{}, optionalArgs ...interface{}) interface{} {
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var instId interface{} = this.SafeString(info, "instId")
	if IsTrue(!IsEqual(instId, nil)) {
		market = this.SafeMarket(instId, market)
	}
	var timestamp interface{} = this.SafeInteger(info, "ts")
	return map[string]interface{}{
		"info":           info,
		"symbol":         this.SafeString(market, "symbol"),
		"currency":       this.SafeCurrencyCode(this.SafeString(info, "ccy")),
		"interest":       this.SafeNumber(info, "interest"),
		"interestRate":   this.SafeNumber(info, "interestRate"),
		"amountBorrowed": this.SafeNumber(info, "liab"),
		"marginMode":     this.SafeString(info, "mgnMode"),
		"timestamp":      timestamp,
		"datetime":       this.Iso8601(timestamp),
	}
}

/**
 * @method
 * @name okx#borrowCrossMargin
 * @description create a loan to borrow margin (need to be VIP 5 and above)
 * @see https://www.okx.com/docs-v5/en/#trading-account-rest-api-vip-loans-borrow-and-repay
 * @param {string} code unified currency code of the currency to borrow
 * @param {float} amount the amount to borrow
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/?id=margin-loan-structure}
 */
func (this *OkxCore) BorrowCrossMargin(code interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes75498 := (<-this.LoadMarkets())
		PanicOnError(retRes75498)
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"ccy":  GetValue(currency, "id"),
			"amt":  this.CurrencyToPrecision(code, amount),
			"side": "borrow",
		}

		response := (<-this.PrivatePostAccountBorrowRepay(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "0",
		//         "data": [
		//             {
		//                 "amt": "102",
		//                 "ccy": "USDT",
		//                 "ordId": "544199684697214976",
		//                 "side": "borrow",
		//                 "state": "1"
		//             }
		//         ],
		//         "msg": ""
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var loan interface{} = this.SafeDict(data, 0, map[string]interface{}{})

		ch <- this.ParseMarginLoan(loan, currency)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#repayCrossMargin
 * @description repay borrowed margin and interest
 * @see https://www.okx.com/docs-v5/en/#trading-account-rest-api-vip-loans-borrow-and-repay
 * @param {string} code unified currency code of the currency to repay
 * @param {float} amount the amount to repay
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.id] the order ID of borrowing, it is necessary while repaying
 * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/?id=margin-loan-structure}
 */
func (this *OkxCore) RepayCrossMargin(code interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes75898 := (<-this.LoadMarkets())
		PanicOnError(retRes75898)
		var id interface{} = this.SafeString2(params, "id", "ordId")
		params = this.Omit(params, "id")
		if IsTrue(IsEqual(id, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " repayCrossMargin() requires an id parameter")))
		}
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"ccy":   GetValue(currency, "id"),
			"amt":   this.CurrencyToPrecision(code, amount),
			"side":  "repay",
			"ordId": id,
		}

		response := (<-this.PrivatePostAccountBorrowRepay(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "0",
		//         "data": [
		//             {
		//                 "amt": "102",
		//                 "ccy": "USDT",
		//                 "ordId": "544199684697214976",
		//                 "side": "repay",
		//                 "state": "1"
		//             }
		//         ],
		//         "msg": ""
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var loan interface{} = this.SafeDict(data, 0, map[string]interface{}{})

		ch <- this.ParseMarginLoan(loan, currency)
		return nil

	}()
	return ch
}
func (this *OkxCore) ParseMarginLoan(info interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "amt": "102",
	//         "availLoan": "97",
	//         "ccy": "USDT",
	//         "loanQuota": "6000000",
	//         "posLoan": "0",
	//         "side": "repay",
	//         "usedLoan": "97"
	//     }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var currencyId interface{} = this.SafeString(info, "ccy")
	return map[string]interface{}{
		"id":        nil,
		"currency":  this.SafeCurrencyCode(currencyId, currency),
		"amount":    this.SafeNumber(info, "amt"),
		"symbol":    nil,
		"timestamp": nil,
		"datetime":  nil,
		"info":      info,
	}
}

/**
 * @method
 * @name okx#fetchOpenInterest
 * @description Retrieves the open interest of a currency
 * @see https://www.okx.com/docs-v5/en/#rest-api-public-data-get-open-interest
 * @param {string} symbol Unified CCXT market symbol
 * @param {object} [params] exchange specific parameters
 * @returns {object} an open interest structure{@link https://docs.ccxt.com/?id=open-interest-structure}
 */
func (this *OkxCore) FetchOpenInterest(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes76578 := (<-this.LoadMarkets())
		PanicOnError(retRes76578)
		var market interface{} = this.Market(symbol)
		if !IsTrue(GetValue(market, "contract")) {
			panic(BadRequest(Add(this.Id, " fetchOpenInterest() supports contract markets only")))
		}
		var typeVar interface{} = this.ConvertToInstrumentType(GetValue(market, "type"))
		var uly interface{} = this.SafeString(GetValue(market, "info"), "uly")
		var request interface{} = map[string]interface{}{
			"instType": typeVar,
			"uly":      uly,
			"instId":   GetValue(market, "id"),
		}

		response := (<-this.PublicGetPublicOpenInterest(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "0",
		//         "data": [
		//             {
		//                 "instId": "BTC-USDT-SWAP",
		//                 "instType": "SWAP",
		//                 "oi": "2125419",
		//                 "oiCcy": "21254.19",
		//                 "ts": "1664005108969"
		//             }
		//         ],
		//         "msg": ""
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseOpenInterest(GetValue(data, 0), market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#fetchOpenInterests
 * @description Retrieves the open interests of some currencies
 * @see https://www.okx.com/docs-v5/en/#rest-api-public-data-get-open-interest
 * @param {string[]} symbols Unified CCXT market symbols
 * @param {object} [params] exchange specific parameters
 * @param {string} params.instType Instrument type, options: 'SWAP', 'FUTURES', 'OPTION', default to 'SWAP'
 * @param {string} params.uly Underlying, Applicable to FUTURES/SWAP/OPTION, if instType is 'OPTION', either uly or instFamily is required
 * @param {string} params.instFamily Instrument family, Applicable to FUTURES/SWAP/OPTION, if instType is 'OPTION', either uly or instFamily is required
 * @returns {object} an dictionary of [open interest structures]{@link https://docs.ccxt.com/?id=open-interest-structure}
 */
func (this *OkxCore) FetchOpenInterests(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes77028 := (<-this.LoadMarkets())
		PanicOnError(retRes77028)
		symbols = this.MarketSymbols(symbols, nil, true, true)
		var market interface{} = nil
		if IsTrue(!IsEqual(symbols, nil)) {
			market = this.Market(GetValue(symbols, 0))
		}
		var marketType interface{} = nil
		marketTypeparamsVariable := this.HandleSubTypeAndParams("fetchOpenInterests", market, params, "swap")
		marketType = GetValue(marketTypeparamsVariable, 0)
		params = GetValue(marketTypeparamsVariable, 1)
		var instType interface{} = "SWAP"
		if IsTrue(IsEqual(marketType, "future")) {
			instType = "FUTURES"
		} else if IsTrue(IsEqual(instType, "option")) {
			instType = "OPTION"
		}
		var request interface{} = map[string]interface{}{
			"instType": instType,
		}
		var uly interface{} = this.SafeString(params, "uly")
		if IsTrue(!IsEqual(uly, nil)) {
			AddElementToObject(request, "uly", uly)
		}
		var instFamily interface{} = this.SafeString(params, "instFamily")
		if IsTrue(!IsEqual(instFamily, nil)) {
			AddElementToObject(request, "instFamily", instFamily)
		}
		if IsTrue(IsTrue(IsTrue(IsEqual(instType, "OPTION")) && IsTrue(IsEqual(uly, nil))) && IsTrue(IsEqual(instFamily, nil))) {
			panic(BadRequest(Add(this.Id, " fetchOpenInterests() requires either uly or instFamily parameter for OPTION markets")))
		}

		response := (<-this.PublicGetPublicOpenInterest(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "0",
		//         "data": [
		//             {
		//                 "instId": "BTC-USDT-SWAP",
		//                 "instType": "SWAP",
		//                 "oi": "2125419",
		//                 "oiCcy": "21254.19",
		//                 "ts": "1664005108969"
		//             }
		//         ],
		//         "msg": ""
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseOpenInterests(data, symbols)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#fetchOpenInterestHistory
 * @description Retrieves the open interest history of a currency
 * @see https://www.okx.com/docs-v5/en/#rest-api-trading-data-get-contracts-open-interest-and-volume
 * @see https://www.okx.com/docs-v5/en/#rest-api-trading-data-get-options-open-interest-and-volume
 * @param {string} symbol Unified CCXT currency code or unified symbol
 * @param {string} timeframe "5m", "1h", or "1d" for option only "1d" or "8h"
 * @param {int} [since] The time in ms of the earliest record to retrieve as a unix timestamp
 * @param {int} [limit] Not used by okx, but parsed internally by CCXT
 * @param {object} [params] Exchange specific parameters
 * @param {int} [params.until] The time in ms of the latest record to retrieve as a unix timestamp
 * @returns An array of [open interest structures]{@link https://docs.ccxt.com/?id=open-interest-structure}
 */
func (this *OkxCore) FetchOpenInterestHistory(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		timeframe := GetArg(optionalArgs, 0, "1d")
		_ = timeframe
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		var options interface{} = this.SafeDict(this.Options, "fetchOpenInterestHistory", map[string]interface{}{})
		var timeframes interface{} = this.SafeDict(options, "timeframes", map[string]interface{}{})
		timeframe = this.SafeString(timeframes, timeframe, timeframe)
		if IsTrue(IsTrue(IsTrue(!IsEqual(timeframe, "5m")) && IsTrue(!IsEqual(timeframe, "1H"))) && IsTrue(!IsEqual(timeframe, "1D"))) {
			panic(BadRequest(Add(this.Id, " fetchOpenInterestHistory cannot only use the 5m, 1h, and 1d timeframe")))
		}

		retRes77698 := (<-this.LoadMarkets())
		PanicOnError(retRes77698)
		// handle unified currency code or symbol
		var currencyId interface{} = nil
		var market interface{} = nil
		if IsTrue(IsTrue((InOp(this.Markets, symbol))) || IsTrue((InOp(this.Markets_by_id, symbol)))) {
			market = this.Market(symbol)
			currencyId = GetValue(market, "baseId")
		} else {
			var currency interface{} = this.Currency(symbol)
			currencyId = GetValue(currency, "id")
		}
		var request interface{} = map[string]interface{}{
			"ccy":    currencyId,
			"period": timeframe,
		}
		var typeVar interface{} = nil
		var response interface{} = nil
		typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchOpenInterestHistory", market, params)
		typeVar = GetValue(typeVarparamsVariable, 0)
		params = GetValue(typeVarparamsVariable, 1)
		if IsTrue(IsEqual(typeVar, "option")) {

			response = (<-this.PublicGetRubikStatOptionOpenInterestVolume(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			if IsTrue(!IsEqual(since, nil)) {
				AddElementToObject(request, "begin", since)
			}
			var until interface{} = this.SafeInteger(params, "until")
			if IsTrue(!IsEqual(until, nil)) {
				AddElementToObject(request, "end", until)
				params = this.Omit(params, []interface{}{"until"})
			}

			response = (<-this.PublicGetRubikStatContractsOpenInterestVolume(this.Extend(request, params)))
			PanicOnError(response)
		}
		//
		//    {
		//        "code": "0",
		//        "data": [
		//            [
		//                "1648221300000",  // timestamp
		//                "2183354317.945",  // open interest (USD)
		//                "74285877.617",  // volume (USD)
		//            ],
		//            ...
		//        ],
		//        "msg": ''
		//    }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseOpenInterestsHistory(data, nil, since, limit)
		return nil

	}()
	return ch
}
func (this *OkxCore) ParseOpenInterest(interest interface{}, optionalArgs ...interface{}) interface{} {
	//
	// fetchOpenInterestHistory
	//
	//    [
	//        "1648221300000",  // timestamp
	//        "2183354317.945",  // open interest (USD) - (coin) for options
	//        "74285877.617",  // volume (USD) - (coin) for options
	//    ]
	//
	// fetchOpenInterest
	//
	//     {
	//         "instId": "BTC-USD-230520-25500-P",
	//         "instType": "OPTION",
	//         "oi": "300",
	//         "oiCcy": "3",
	//         "oiUsd": "3",
	//         "ts": "1684551166251"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var id interface{} = this.SafeString(interest, "instId")
	market = this.SafeMarket(id, market)
	var time interface{} = this.SafeInteger(interest, "ts")
	var timestamp interface{} = this.SafeInteger(interest, 0, time)
	var baseVolume interface{} = nil
	var quoteVolume interface{} = nil
	var openInterestAmount interface{} = nil
	var openInterestValue interface{} = nil
	var typeVar interface{} = this.SafeString(this.Options, "defaultType")
	if IsTrue(IsArray(interest)) {
		if IsTrue(IsEqual(typeVar, "option")) {
			openInterestAmount = this.SafeNumber(interest, 1)
			baseVolume = this.SafeNumber(interest, 2)
		} else {
			openInterestValue = this.SafeNumber(interest, 1)
			quoteVolume = this.SafeNumber(interest, 2)
		}
	} else {
		baseVolume = this.SafeNumber(interest, "oiCcy")
		openInterestAmount = this.SafeNumber(interest, "oi")
		openInterestValue = this.SafeNumber(interest, "oiUsd")
	}
	return this.SafeOpenInterest(map[string]interface{}{
		"symbol":             this.SafeSymbol(id),
		"baseVolume":         baseVolume,
		"quoteVolume":        quoteVolume,
		"openInterestAmount": openInterestAmount,
		"openInterestValue":  openInterestValue,
		"timestamp":          timestamp,
		"datetime":           this.Iso8601(timestamp),
		"info":               interest,
	}, market)
}
func (this *OkxCore) SetSandboxMode(enable interface{}) {
	this.Exchange.SetSandboxMode(enable)
	AddElementToObject(this.Options, "sandboxMode", enable)
	if IsTrue(enable) {
		AddElementToObject(this.Headers, "x-simulated-trading", "1")
	} else if IsTrue(InOp(this.Headers, "x-simulated-trading")) {
		this.Headers = this.Omit(this.Headers, "x-simulated-trading")
	}
}

/**
 * @method
 * @name okx#fetchDepositWithdrawFees
 * @description fetch deposit and withdraw fees
 * @see https://www.okx.com/docs-v5/en/#rest-api-funding-get-currencies
 * @param {string[]|undefined} codes list of unified currency codes
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [fees structures]{@link https://docs.ccxt.com/?id=fee-structure}
 */
func (this *OkxCore) FetchDepositWithdrawFees(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		codes := GetArg(optionalArgs, 0, nil)
		_ = codes
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes78938 := (<-this.LoadMarkets())
		PanicOnError(retRes78938)
		var request interface{} = map[string]interface{}{}
		if IsTrue(!IsEqual(codes, nil)) {
			var ids interface{} = this.CurrencyIds(codes)
			AddElementToObject(request, "ccy", Join(ids, ","))
		}

		response := (<-this.PrivateGetAssetCurrencies(this.Extend(request, params)))
		PanicOnError(response)
		//
		//    {
		//        "code": "0",
		//        "data": [
		//            {
		//                "canDep": true,
		//                "canInternal": false,
		//                "canWd": true,
		//                "ccy": "USDT",
		//                "chain": "USDT-TRC20",
		//                "logoLink": "https://static.coinall.ltd/cdn/assets/imgs/221/5F74EB20302D7761.png",
		//                "mainNet": false,
		//                "maxFee": "1.6",
		//                "maxWd": "8852150",
		//                "minFee": "0.8",
		//                "minWd": "2",
		//                "name": "Tether",
		//                "usedWdQuota": "0",
		//                "wdQuota": "500",
		//                "wdTickSz": "3"
		//            },
		//            {
		//                "canDep": true,
		//                "canInternal": false,
		//                "canWd": true,
		//                "ccy": "USDT",
		//                "chain": "USDT-ERC20",
		//                "logoLink": "https://static.coinall.ltd/cdn/assets/imgs/221/5F74EB20302D7761.png",
		//                "mainNet": false,
		//                "maxFee": "16",
		//                "maxWd": "8852150",
		//                "minFee": "8",
		//                "minWd": "2",
		//                "name": "Tether",
		//                "usedWdQuota": "0",
		//                "wdQuota": "500",
		//                "wdTickSz": "3"
		//            },
		//            ...
		//        ],
		//        "msg": ""
		//    }
		//
		var data interface{} = this.SafeList(response, "data")

		ch <- this.ParseDepositWithdrawFees(data, codes)
		return nil

	}()
	return ch
}
func (this *OkxCore) ParseDepositWithdrawFees(response interface{}, optionalArgs ...interface{}) interface{} {
	//
	// [
	//   {
	//       "canDep": true,
	//       "canInternal": false,
	//       "canWd": true,
	//       "ccy": "USDT",
	//       "chain": "USDT-TRC20",
	//       "logoLink": "https://static.coinall.ltd/cdn/assets/imgs/221/5F74EB20302D7761.png",
	//       "mainNet": false,
	//       "maxFee": "1.6",
	//       "maxWd": "8852150",
	//       "minFee": "0.8",
	//       "minWd": "2",
	//       "name": "Tether",
	//       "usedWdQuota": "0",
	//       "wdQuota": "500",
	//       "wdTickSz": "3"
	//   }
	// ]
	//
	codes := GetArg(optionalArgs, 0, nil)
	_ = codes
	currencyIdKey := GetArg(optionalArgs, 1, nil)
	_ = currencyIdKey
	var depositWithdrawFees interface{} = map[string]interface{}{}
	codes = this.MarketCodes(codes)
	for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
		var feeInfo interface{} = GetValue(response, i)
		var currencyId interface{} = this.SafeString(feeInfo, "ccy")
		var code interface{} = this.SafeCurrencyCode(currencyId)
		if IsTrue(IsTrue((IsEqual(codes, nil))) || IsTrue((this.InArray(code, codes)))) {
			var depositWithdrawFee interface{} = this.SafeValue(depositWithdrawFees, code)
			if IsTrue(IsEqual(depositWithdrawFee, nil)) {
				AddElementToObject(depositWithdrawFees, code, this.DepositWithdrawFee(map[string]interface{}{}))
			}
			AddElementToObject(GetValue(GetValue(depositWithdrawFees, code), "info"), currencyId, feeInfo)
			var chain interface{} = this.SafeString(feeInfo, "chain")
			if IsTrue(IsEqual(chain, nil)) {
				continue
			}
			var chainSplit interface{} = Split(chain, "-")
			var networkId interface{} = this.SafeValue(chainSplit, 1)
			var withdrawFee interface{} = this.SafeNumber(feeInfo, "fee")
			var withdrawResult interface{} = map[string]interface{}{
				"fee":        withdrawFee,
				"percentage": Ternary(IsTrue((!IsEqual(withdrawFee, nil))), false, nil),
			}
			var depositResult interface{} = map[string]interface{}{
				"fee":        nil,
				"percentage": nil,
			}
			var networkCode interface{} = this.NetworkIdToCode(networkId, code)
			AddElementToObject(GetValue(GetValue(depositWithdrawFees, code), "networks"), networkCode, map[string]interface{}{
				"withdraw": withdrawResult,
				"deposit":  depositResult,
			})
		}
	}
	var depositWithdrawCodes interface{} = ObjectKeys(depositWithdrawFees)
	for i := 0; IsLessThan(i, GetArrayLength(depositWithdrawCodes)); i++ {
		var code interface{} = GetValue(depositWithdrawCodes, i)
		var currency interface{} = this.Currency(code)
		AddElementToObject(depositWithdrawFees, code, this.AssignDefaultDepositWithdrawFees(GetValue(depositWithdrawFees, code), currency))
	}
	return depositWithdrawFees
}

/**
 * @method
 * @name okx#fetchSettlementHistory
 * @description fetches historical settlement records
 * @see https://www.okx.com/docs-v5/en/#rest-api-public-data-get-delivery-exercise-history
 * @param {string} symbol unified market symbol to fetch the settlement history for
 * @param {int} [since] timestamp in ms
 * @param {int} [limit] number of records
 * @param {object} [params] exchange specific params
 * @returns {object[]} a list of [settlement history objects]{@link https://docs.ccxt.com/?id=settlement-history-structure}
 */
func (this *OkxCore) FetchSettlementHistory(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchSettlementHistory() requires a symbol argument")))
		}

		retRes80278 := (<-this.LoadMarkets())
		PanicOnError(retRes80278)
		var market interface{} = this.Market(symbol)
		var typeVar interface{} = nil
		typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchSettlementHistory", market, params)
		typeVar = GetValue(typeVarparamsVariable, 0)
		params = GetValue(typeVarparamsVariable, 1)
		if IsTrue(IsTrue(!IsEqual(typeVar, "future")) && IsTrue(!IsEqual(typeVar, "option"))) {
			panic(NotSupported(Add(this.Id, " fetchSettlementHistory() supports futures and options markets only")))
		}
		var request interface{} = map[string]interface{}{
			"instType": this.ConvertToInstrumentType(typeVar),
			"uly":      Add(Add(GetValue(market, "baseId"), "-"), GetValue(market, "quoteId")),
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "before", Subtract(since, 1))
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}

		response := (<-this.PublicGetPublicDeliveryExerciseHistory(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "0",
		//         "data": [
		//             {
		//                 "details": [
		//                     {
		//                         "insId": "BTC-USD-230523-25750-C",
		//                         "px": "27290.1486867000556483",
		//                         "type": "exercised"
		//                     },
		//                 ],
		//                 "ts":"1684656000000"
		//             }
		//         ],
		//         "msg": ""
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var settlements interface{} = this.ParseSettlements(data, market)
		var sorted interface{} = this.SortBy(settlements, "timestamp")

		ch <- this.FilterBySymbolSinceLimit(sorted, GetValue(market, "symbol"), since, limit)
		return nil

	}()
	return ch
}
func (this *OkxCore) ParseSettlement(settlement interface{}, market interface{}) interface{} {
	//
	//     {
	//         "insId": "BTC-USD-230521-28500-P",
	//         "px": "27081.2007345984751516",
	//         "type": "exercised"
	//     }
	//
	var marketId interface{} = this.SafeString(settlement, "insId")
	return map[string]interface{}{
		"info":      settlement,
		"symbol":    this.SafeSymbol(marketId, market),
		"price":     this.SafeNumber(settlement, "px"),
		"timestamp": nil,
		"datetime":  nil,
	}
}
func (this *OkxCore) ParseSettlements(settlements interface{}, market interface{}) interface{} {
	//
	//     {
	//         "details": [
	//             {
	//                 "insId": "BTC-USD-230523-25750-C",
	//                 "px": "27290.1486867000556483",
	//                 "type": "exercised"
	//             },
	//         ],
	//         "ts":"1684656000000"
	//     }
	//
	var result interface{} = []interface{}{}
	for i := 0; IsLessThan(i, GetArrayLength(settlements)); i++ {
		var entry interface{} = GetValue(settlements, i)
		var timestamp interface{} = this.SafeInteger(entry, "ts")
		var details interface{} = this.SafeList(entry, "details", []interface{}{})
		for j := 0; IsLessThan(j, GetArrayLength(details)); j++ {
			var settlement interface{} = this.ParseSettlement(GetValue(details, j), market)
			AppendToArray(&result, this.Extend(settlement, map[string]interface{}{
				"timestamp": timestamp,
				"datetime":  this.Iso8601(timestamp),
			}))
		}
	}
	return result
}

/**
 * @method
 * @name okx#fetchUnderlyingAssets
 * @description fetches the market ids of underlying assets for a specific contract market type
 * @see https://www.okx.com/docs-v5/en/#public-data-rest-api-get-underlying
 * @param {object} [params] exchange specific params
 * @param {string} [params.type] the contract market type, 'option', 'swap' or 'future', the default is 'option'
 * @returns {object[]} a list of [underlying assets]{@link https://docs.ccxt.com/?id=underlying-assets-structure}
 */
func (this *OkxCore) FetchUnderlyingAssets(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes81268 := (<-this.LoadMarkets())
		PanicOnError(retRes81268)
		var marketType interface{} = nil
		marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchUnderlyingAssets", nil, params)
		marketType = GetValue(marketTypeparamsVariable, 0)
		params = GetValue(marketTypeparamsVariable, 1)
		if IsTrue(IsTrue((IsEqual(marketType, nil))) || IsTrue((IsEqual(marketType, "spot")))) {
			marketType = "option"
		}
		if IsTrue(IsTrue(IsTrue((!IsEqual(marketType, "option"))) && IsTrue((!IsEqual(marketType, "swap")))) && IsTrue((!IsEqual(marketType, "future")))) {
			panic(NotSupported(Add(this.Id, " fetchUnderlyingAssets() supports contract markets only")))
		}
		var request interface{} = map[string]interface{}{
			"instType": this.ConvertToInstrumentType(marketType),
		}

		response := (<-this.PublicGetPublicUnderlying(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "0",
		//         "data": [
		//             [
		//                 "BTC-USD",
		//                 "ETH-USD"
		//             ]
		//         ],
		//         "msg": ""
		//     }
		//
		var underlyings interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- GetValue(underlyings, 0)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#fetchGreeks
 * @description fetches an option contracts greeks, financial metrics used to measure the factors that affect the price of an options contract
 * @see https://www.okx.com/docs-v5/en/#public-data-rest-api-get-option-market-data
 * @param {string} symbol unified symbol of the market to fetch greeks for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [greeks structure]{@link https://docs.ccxt.com/?id=greeks-structure}
 */
func (this *OkxCore) FetchGreeks(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes81658 := (<-this.LoadMarkets())
		PanicOnError(retRes81658)
		var market interface{} = this.Market(symbol)
		var marketId interface{} = GetValue(market, "id")
		var optionParts interface{} = Split(marketId, "-")
		var request interface{} = map[string]interface{}{
			"uly":        GetValue(GetValue(market, "info"), "uly"),
			"instFamily": GetValue(GetValue(market, "info"), "instFamily"),
			"expTime":    this.SafeString(optionParts, 2),
		}

		response := (<-this.PublicGetPublicOptSummary(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "0",
		//         "data": [
		//             {
		//                 "askVol": "0",
		//                 "bidVol": "0",
		//                 "delta": "0.5105464486882039",
		//                 "deltaBS": "0.7325502184143025",
		//                 "fwdPx": "37675.80158694987186",
		//                 "gamma": "-0.13183515090501083",
		//                 "gammaBS": "0.000024139685826358558",
		//                 "instId": "BTC-USD-240329-32000-C",
		//                 "instType": "OPTION",
		//                 "lever": "4.504428015946619",
		//                 "markVol": "0.5916253554539876",
		//                 "realVol": "0",
		//                 "theta": "-0.0004202992014012855",
		//                 "thetaBS": "-18.52354631567909",
		//                 "ts": "1699586421976",
		//                 "uly": "BTC-USD",
		//                 "vega": "0.0020207455080045846",
		//                 "vegaBS": "74.44022302387287",
		//                 "volLv": "0.5948549730405797"
		//             },
		//         ],
		//         "msg": ""
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
			var entry interface{} = GetValue(data, i)
			var entryMarketId interface{} = this.SafeString(entry, "instId")
			if IsTrue(IsEqual(entryMarketId, marketId)) {

				ch <- this.ParseGreeks(entry, market)
				return nil
			}
		}

		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#fetchAllGreeks
 * @description fetches all option contracts greeks, financial metrics used to measure the factors that affect the price of an options contract
 * @see https://www.okx.com/docs-v5/en/#public-data-rest-api-get-option-market-data
 * @param {string[]} [symbols] unified symbols of the markets to fetch greeks for, all markets are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} params.uly Underlying, either uly or instFamily is required
 * @param {string} params.instFamily Instrument family, either uly or instFamily is required
 * @returns {object} a [greeks structure]{@link https://docs.ccxt.com/?id=greeks-structure}
 */
func (this *OkxCore) FetchAllGreeks(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes82278 := (<-this.LoadMarkets())
		PanicOnError(retRes82278)
		var request interface{} = map[string]interface{}{}
		symbols = this.MarketSymbols(symbols, nil, true, true, true)
		var symbolsLength interface{} = nil
		if IsTrue(!IsEqual(symbols, nil)) {
			symbolsLength = GetArrayLength(symbols)
		}
		if IsTrue(IsTrue((IsEqual(symbols, nil))) || IsTrue((!IsEqual(symbolsLength, 1)))) {
			var uly interface{} = this.SafeString(params, "uly")
			if IsTrue(!IsEqual(uly, nil)) {
				AddElementToObject(request, "uly", uly)
			}
			var instFamily interface{} = this.SafeString(params, "instFamily")
			if IsTrue(!IsEqual(instFamily, nil)) {
				AddElementToObject(request, "instFamily", instFamily)
			}
			if IsTrue(IsTrue((IsEqual(uly, nil))) && IsTrue((IsEqual(instFamily, nil)))) {
				panic(BadRequest(Add(this.Id, " fetchAllGreeks() requires either a uly or instFamily parameter")))
			}
		}
		var market interface{} = nil
		if IsTrue(!IsEqual(symbols, nil)) {
			if IsTrue(IsEqual(symbolsLength, 1)) {
				market = this.Market(GetValue(symbols, 0))
				var marketId interface{} = GetValue(market, "id")
				var optionParts interface{} = Split(marketId, "-")
				AddElementToObject(request, "uly", GetValue(GetValue(market, "info"), "uly"))
				AddElementToObject(request, "instFamily", GetValue(GetValue(market, "info"), "instFamily"))
				AddElementToObject(request, "expTime", this.SafeString(optionParts, 2))
			}
		}
		params = this.Omit(params, []interface{}{"uly", "instFamily"})

		response := (<-this.PublicGetPublicOptSummary(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "0",
		//         "data": [
		//             {
		//                 "askVol": "0",
		//                 "bidVol": "0",
		//                 "delta": "0.5105464486882039",
		//                 "deltaBS": "0.7325502184143025",
		//                 "fwdPx": "37675.80158694987186",
		//                 "gamma": "-0.13183515090501083",
		//                 "gammaBS": "0.000024139685826358558",
		//                 "instId": "BTC-USD-240329-32000-C",
		//                 "instType": "OPTION",
		//                 "lever": "4.504428015946619",
		//                 "markVol": "0.5916253554539876",
		//                 "realVol": "0",
		//                 "theta": "-0.0004202992014012855",
		//                 "thetaBS": "-18.52354631567909",
		//                 "ts": "1699586421976",
		//                 "uly": "BTC-USD",
		//                 "vega": "0.0020207455080045846",
		//                 "vegaBS": "74.44022302387287",
		//                 "volLv": "0.5948549730405797"
		//             },
		//         ],
		//         "msg": ""
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseAllGreeks(data, symbols)
		return nil

	}()
	return ch
}
func (this *OkxCore) ParseGreeks(greeks interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "askVol": "0",
	//         "bidVol": "0",
	//         "delta": "0.5105464486882039",
	//         "deltaBS": "0.7325502184143025",
	//         "fwdPx": "37675.80158694987186",
	//         "gamma": "-0.13183515090501083",
	//         "gammaBS": "0.000024139685826358558",
	//         "instId": "BTC-USD-240329-32000-C",
	//         "instType": "OPTION",
	//         "lever": "4.504428015946619",
	//         "markVol": "0.5916253554539876",
	//         "realVol": "0",
	//         "theta": "-0.0004202992014012855",
	//         "thetaBS": "-18.52354631567909",
	//         "ts": "1699586421976",
	//         "uly": "BTC-USD",
	//         "vega": "0.0020207455080045846",
	//         "vegaBS": "74.44022302387287",
	//         "volLv": "0.5948549730405797"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var timestamp interface{} = this.SafeInteger(greeks, "ts")
	var marketId interface{} = this.SafeString(greeks, "instId")
	var symbol interface{} = this.SafeSymbol(marketId, market)
	return map[string]interface{}{
		"symbol":                symbol,
		"timestamp":             timestamp,
		"datetime":              this.Iso8601(timestamp),
		"delta":                 this.SafeNumber(greeks, "delta"),
		"gamma":                 this.SafeNumber(greeks, "gamma"),
		"theta":                 this.SafeNumber(greeks, "theta"),
		"vega":                  this.SafeNumber(greeks, "vega"),
		"rho":                   nil,
		"bidSize":               nil,
		"askSize":               nil,
		"bidImpliedVolatility":  this.SafeNumber(greeks, "bidVol"),
		"askImpliedVolatility":  this.SafeNumber(greeks, "askVol"),
		"markImpliedVolatility": this.SafeNumber(greeks, "markVol"),
		"bidPrice":              nil,
		"askPrice":              nil,
		"markPrice":             nil,
		"lastPrice":             nil,
		"underlyingPrice":       nil,
		"info":                  greeks,
	}
}

/**
 * @method
 * @name okx#closePosition
 * @description closes open positions for a market
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-trade-post-close-positions
 * @param {string} symbol Unified CCXT market symbol
 * @param {string} [side] 'buy' or 'sell', leave as undefined in net mode
 * @param {object} [params] extra parameters specific to the okx api endpoint
 * @param {string} [params.clientOrderId] a unique identifier for the order
 * @param {string} [params.marginMode] 'cross' or 'isolated', default is 'cross;
 * @param {string} [params.code] *required in the case of closing cross MARGIN position for Single-currency margin* margin currency
 *
 * EXCHANGE SPECIFIC PARAMETERS
 * @param {boolean} [params.autoCxl] whether any pending orders for closing out needs to be automatically canceled when close position via a market order. false or true, the default is false
 * @param {string} [params.tag] order tag a combination of case-sensitive alphanumerics, all numbers, or all letters of up to 16 characters
 * @returns {object[]} [A list of position structures]{@link https://docs.ccxt.com/?id=position-structure}
 */
func (this *OkxCore) ClosePosition(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		side := GetArg(optionalArgs, 0, nil)
		_ = side
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes83618 := (<-this.LoadMarkets())
		PanicOnError(retRes83618)
		var market interface{} = this.Market(symbol)
		var clientOrderId interface{} = this.SafeString(params, "clientOrderId")
		var code interface{} = this.SafeString(params, "code")
		var marginMode interface{} = nil
		marginModeparamsVariable := this.HandleMarginModeAndParams("closePosition", params, "cross")
		marginMode = GetValue(marginModeparamsVariable, 0)
		params = GetValue(marginModeparamsVariable, 1)
		var request interface{} = map[string]interface{}{
			"instId":  GetValue(market, "id"),
			"mgnMode": marginMode,
		}
		if IsTrue(!IsEqual(side, nil)) {
			if IsTrue((IsEqual(side, "buy"))) {
				AddElementToObject(request, "posSide", "long")
			} else if IsTrue(IsEqual(side, "sell")) {
				AddElementToObject(request, "posSide", "short")
			} else {
				AddElementToObject(request, "posSide", side)
			}
		}
		if IsTrue(!IsEqual(clientOrderId, nil)) {
			AddElementToObject(request, "clOrdId", clientOrderId)
		}
		if IsTrue(!IsEqual(code, nil)) {
			var currency interface{} = this.Currency(code)
			AddElementToObject(request, "ccy", GetValue(currency, "id"))
		}

		response := (<-this.PrivatePostTradeClosePosition(this.Extend(request, params)))
		PanicOnError(response)
		//
		//    {
		//        "code": "1",
		//        "data": [
		//            {
		//                "clOrdId":"e847386590ce4dBCe903bbc394dc88bf",
		//                "ordId":"",
		//                "sCode":"51000",
		//                "sMsg":"Parameter posSide error ",
		//                "tag":"e847386590ce4dBC"
		//            }
		//        ],
		//        "inTime": "1701877077101064",
		//        "msg": "All operations failed",
		//        "outTime": "1701877077102579"
		//    }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var order interface{} = this.SafeDict(data, 0)

		ch <- this.ParseOrder(order, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#fetchOption
 * @description fetches option data that is commonly found in an option chain
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-market-data-get-ticker
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [option chain structure]{@link https://docs.ccxt.com/?id=option-chain-structure}
 */
func (this *OkxCore) FetchOption(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes84208 := (<-this.LoadMarkets())
		PanicOnError(retRes84208)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"instId": GetValue(market, "id"),
		}

		response := (<-this.PublicGetMarketTicker(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "0",
		//         "msg": "",
		//         "data": [
		//             {
		//                 "instType": "OPTION",
		//                 "instId": "BTC-USD-241227-60000-P",
		//                 "last": "",
		//                 "lastSz": "0",
		//                 "askPx": "",
		//                 "askSz": "0",
		//                 "bidPx": "",
		//                 "bidSz": "0",
		//                 "open24h": "",
		//                 "high24h": "",
		//                 "low24h": "",
		//                 "volCcy24h": "0",
		//                 "vol24h": "0",
		//                 "ts": "1711176035035",
		//                 "sodUtc0": "",
		//                 "sodUtc8": ""
		//             }
		//         ]
		//     }
		//
		var result interface{} = this.SafeList(response, "data", []interface{}{})
		var chain interface{} = this.SafeDict(result, 0, map[string]interface{}{})

		ch <- this.ParseOption(chain, nil, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#fetchOptionChain
 * @description fetches data for an underlying asset that is commonly found in an option chain
 * @see https://www.okx.com/docs-v5/en/#order-book-trading-market-data-get-tickers
 * @param {string} code base currency to fetch an option chain for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.uly] the underlying asset, can be obtained from fetchUnderlyingAssets ()
 * @returns {object} a list of [option chain structures]{@link https://docs.ccxt.com/?id=option-chain-structure}
 */
func (this *OkxCore) FetchOptionChain(code interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes84688 := (<-this.LoadMarkets())
		PanicOnError(retRes84688)
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"uly":      Add(GetValue(currency, "code"), "-USD"),
			"instType": "OPTION",
		}

		response := (<-this.PublicGetMarketTickers(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "0",
		//         "msg": "",
		//         "data": [
		//             {
		//                 "instType": "OPTION",
		//                 "instId": "BTC-USD-240323-52000-C",
		//                 "last": "",
		//                 "lastSz": "0",
		//                 "askPx": "",
		//                 "askSz": "0",
		//                 "bidPx": "",
		//                 "bidSz": "0",
		//                 "open24h": "",
		//                 "high24h": "",
		//                 "low24h": "",
		//                 "volCcy24h": "0",
		//                 "vol24h": "0",
		//                 "ts": "1711176207008",
		//                 "sodUtc0": "",
		//                 "sodUtc8": ""
		//             },
		//         ]
		//     }
		//
		var result interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseOptionChain(result, nil, "instId")
		return nil

	}()
	return ch
}
func (this *OkxCore) ParseOption(chain interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "instType": "OPTION",
	//         "instId": "BTC-USD-241227-60000-P",
	//         "last": "",
	//         "lastSz": "0",
	//         "askPx": "",
	//         "askSz": "0",
	//         "bidPx": "",
	//         "bidSz": "0",
	//         "open24h": "",
	//         "high24h": "",
	//         "low24h": "",
	//         "volCcy24h": "0",
	//         "vol24h": "0",
	//         "ts": "1711176035035",
	//         "sodUtc0": "",
	//         "sodUtc8": ""
	//     }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	market := GetArg(optionalArgs, 1, nil)
	_ = market
	var marketId interface{} = this.SafeString(chain, "instId")
	market = this.SafeMarket(marketId, market)
	var timestamp interface{} = this.SafeInteger(chain, "ts")
	return map[string]interface{}{
		"info":              chain,
		"currency":          nil,
		"symbol":            GetValue(market, "symbol"),
		"timestamp":         timestamp,
		"datetime":          this.Iso8601(timestamp),
		"impliedVolatility": nil,
		"openInterest":      nil,
		"bidPrice":          this.SafeNumber(chain, "bidPx"),
		"askPrice":          this.SafeNumber(chain, "askPx"),
		"midPrice":          nil,
		"markPrice":         nil,
		"lastPrice":         this.SafeNumber(chain, "last"),
		"underlyingPrice":   nil,
		"change":            nil,
		"percentage":        nil,
		"baseVolume":        this.SafeNumber(chain, "volCcy24h"),
		"quoteVolume":       nil,
	}
}

/**
 * @method
 * @name okx#fetchConvertQuote
 * @description fetch a quote for converting from one currency to another
 * @see https://www.okx.com/docs-v5/en/#funding-account-rest-api-estimate-quote
 * @param {string} fromCode the currency that you want to sell and convert from
 * @param {string} toCode the currency that you want to buy and convert into
 * @param {float} [amount] how much you want to trade in units of the from currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [conversion structure]{@link https://docs.ccxt.com/?id=conversion-structure}
 */
func (this *OkxCore) FetchConvertQuote(fromCode interface{}, toCode interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		amount := GetArg(optionalArgs, 0, nil)
		_ = amount
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes85628 := (<-this.LoadMarkets())
		PanicOnError(retRes85628)
		var request interface{} = map[string]interface{}{
			"baseCcy":  ToUpper(fromCode),
			"quoteCcy": ToUpper(toCode),
			"rfqSzCcy": ToUpper(fromCode),
			"rfqSz":    this.NumberToString(amount),
			"side":     "sell",
		}

		response := (<-this.PrivatePostAssetConvertEstimateQuote(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "0",
		//         "data": [
		//             {
		//                 "baseCcy": "ETH",
		//                 "baseSz": "0.01023052",
		//                 "clQReqId": "",
		//                 "cnvtPx": "2932.40104429",
		//                 "origRfqSz": "30",
		//                 "quoteCcy": "USDT",
		//                 "quoteId": "quoterETH-USDT16461885104612381",
		//                 "quoteSz": "30",
		//                 "quoteTime": "1646188510461",
		//                 "rfqSz": "30",
		//                 "rfqSzCcy": "USDT",
		//                 "side": "buy",
		//                 "ttlMs": "10000"
		//             }
		//         ],
		//         "msg": ""
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var result interface{} = this.SafeDict(data, 0, map[string]interface{}{})
		var fromCurrencyId interface{} = this.SafeString(result, "baseCcy", fromCode)
		var fromCurrency interface{} = this.Currency(fromCurrencyId)
		var toCurrencyId interface{} = this.SafeString(result, "quoteCcy", toCode)
		var toCurrency interface{} = this.Currency(toCurrencyId)

		ch <- this.ParseConversion(result, fromCurrency, toCurrency)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#createConvertTrade
 * @description convert from one currency to another
 * @see https://www.okx.com/docs-v5/en/#funding-account-rest-api-convert-trade
 * @param {string} id the id of the trade that you want to make
 * @param {string} fromCode the currency that you want to sell and convert from
 * @param {string} toCode the currency that you want to buy and convert into
 * @param {float} [amount] how much you want to trade in units of the from currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [conversion structure]{@link https://docs.ccxt.com/?id=conversion-structure}
 */
func (this *OkxCore) CreateConvertTrade(id interface{}, fromCode interface{}, toCode interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		amount := GetArg(optionalArgs, 0, nil)
		_ = amount
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes86168 := (<-this.LoadMarkets())
		PanicOnError(retRes86168)
		var request interface{} = map[string]interface{}{
			"quoteId":  id,
			"baseCcy":  fromCode,
			"quoteCcy": toCode,
			"szCcy":    fromCode,
			"sz":       this.NumberToString(amount),
			"side":     "sell",
		}

		response := (<-this.PrivatePostAssetConvertTrade(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "0",
		//         "data": [
		//             {
		//                 "baseCcy": "ETH",
		//                 "clTReqId": "",
		//                 "fillBaseSz": "0.01023052",
		//                 "fillPx": "2932.40104429",
		//                 "fillQuoteSz": "30",
		//                 "instId": "ETH-USDT",
		//                 "quoteCcy": "USDT",
		//                 "quoteId": "quoterETH-USDT16461885104612381",
		//                 "side": "buy",
		//                 "state": "fullyFilled",
		//                 "tradeId": "trader16461885203381437",
		//                 "ts": "1646188520338"
		//             }
		//         ],
		//         "msg": ""
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var result interface{} = this.SafeDict(data, 0, map[string]interface{}{})
		var fromCurrencyId interface{} = this.SafeString(result, "baseCcy", fromCode)
		var fromCurrency interface{} = this.Currency(fromCurrencyId)
		var toCurrencyId interface{} = this.SafeString(result, "quoteCcy", toCode)
		var toCurrency interface{} = this.Currency(toCurrencyId)

		ch <- this.ParseConversion(result, fromCurrency, toCurrency)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#fetchConvertTrade
 * @description fetch the data for a conversion trade
 * @see https://www.okx.com/docs-v5/en/#funding-account-rest-api-get-convert-history
 * @param {string} id the id of the trade that you want to fetch
 * @param {string} [code] the unified currency code of the conversion trade
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [conversion structure]{@link https://docs.ccxt.com/?id=conversion-structure}
 */
func (this *OkxCore) FetchConvertTrade(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes86688 := (<-this.LoadMarkets())
		PanicOnError(retRes86688)
		var request interface{} = map[string]interface{}{
			"clTReqId": id,
		}

		response := (<-this.PrivateGetAssetConvertHistory(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "0",
		//         "data": [
		//             {
		//                 "clTReqId": "",
		//                 "instId": "ETH-USDT",
		//                 "side": "buy",
		//                 "fillPx": "2932.401044",
		//                 "baseCcy": "ETH",
		//                 "quoteCcy": "USDT",
		//                 "fillBaseSz": "0.01023052",
		//                 "state": "fullyFilled",
		//                 "tradeId": "trader16461885203381437",
		//                 "fillQuoteSz": "30",
		//                 "ts": "1646188520000"
		//             }
		//         ],
		//         "msg": ""
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var result interface{} = this.SafeDict(data, 0, map[string]interface{}{})
		var fromCurrencyId interface{} = this.SafeString(result, "baseCcy")
		var toCurrencyId interface{} = this.SafeString(result, "quoteCcy")
		var fromCurrency interface{} = nil
		var toCurrency interface{} = nil
		if IsTrue(!IsEqual(fromCurrencyId, nil)) {
			fromCurrency = this.Currency(fromCurrencyId)
		}
		if IsTrue(!IsEqual(toCurrencyId, nil)) {
			toCurrency = this.Currency(toCurrencyId)
		}

		ch <- this.ParseConversion(result, fromCurrency, toCurrency)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#fetchConvertTradeHistory
 * @description fetch the users history of conversion trades
 * @see https://www.okx.com/docs-v5/en/#funding-account-rest-api-get-convert-history
 * @param {string} [code] the unified currency code
 * @param {int} [since] the earliest time in ms to fetch conversions for
 * @param {int} [limit] the maximum number of conversion structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest conversion to fetch
 * @returns {object[]} a list of [conversion structures]{@link https://docs.ccxt.com/?id=conversion-structure}
 */
func (this *OkxCore) FetchConvertTradeHistory(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes87228 := (<-this.LoadMarkets())
		PanicOnError(retRes87228)
		var request interface{} = map[string]interface{}{}
		requestparamsVariable := this.HandleUntilOption("after", request, params)
		request = GetValue(requestparamsVariable, 0)
		params = GetValue(requestparamsVariable, 1)
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "before", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}

		response := (<-this.PrivateGetAssetConvertHistory(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "0",
		//         "data": [
		//             {
		//                 "clTReqId": "",
		//                 "instId": "ETH-USDT",
		//                 "side": "buy",
		//                 "fillPx": "2932.401044",
		//                 "baseCcy": "ETH",
		//                 "quoteCcy": "USDT",
		//                 "fillBaseSz": "0.01023052",
		//                 "state": "fullyFilled",
		//                 "tradeId": "trader16461885203381437",
		//                 "fillQuoteSz": "30",
		//                 "ts": "1646188520000"
		//             }
		//         ],
		//         "msg": ""
		//     }
		//
		var rows interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseConversions(rows, code, "baseCcy", "quoteCcy", since, limit)
		return nil

	}()
	return ch
}
func (this *OkxCore) ParseConversion(conversion interface{}, optionalArgs ...interface{}) interface{} {
	//
	// fetchConvertQuote
	//
	//     {
	//         "baseCcy": "ETH",
	//         "baseSz": "0.01023052",
	//         "clQReqId": "",
	//         "cnvtPx": "2932.40104429",
	//         "origRfqSz": "30",
	//         "quoteCcy": "USDT",
	//         "quoteId": "quoterETH-USDT16461885104612381",
	//         "quoteSz": "30",
	//         "quoteTime": "1646188510461",
	//         "rfqSz": "30",
	//         "rfqSzCcy": "USDT",
	//         "side": "buy",
	//         "ttlMs": "10000"
	//     }
	//
	// createConvertTrade
	//
	//     {
	//         "baseCcy": "ETH",
	//         "clTReqId": "",
	//         "fillBaseSz": "0.01023052",
	//         "fillPx": "2932.40104429",
	//         "fillQuoteSz": "30",
	//         "instId": "ETH-USDT",
	//         "quoteCcy": "USDT",
	//         "quoteId": "quoterETH-USDT16461885104612381",
	//         "side": "buy",
	//         "state": "fullyFilled",
	//         "tradeId": "trader16461885203381437",
	//         "ts": "1646188520338"
	//     }
	//
	// fetchConvertTrade, fetchConvertTradeHistory
	//
	//     {
	//         "clTReqId": "",
	//         "instId": "ETH-USDT",
	//         "side": "buy",
	//         "fillPx": "2932.401044",
	//         "baseCcy": "ETH",
	//         "quoteCcy": "USDT",
	//         "fillBaseSz": "0.01023052",
	//         "state": "fullyFilled",
	//         "tradeId": "trader16461885203381437",
	//         "fillQuoteSz": "30",
	//         "ts": "1646188520000"
	//     }
	//
	fromCurrency := GetArg(optionalArgs, 0, nil)
	_ = fromCurrency
	toCurrency := GetArg(optionalArgs, 1, nil)
	_ = toCurrency
	var timestamp interface{} = this.SafeInteger2(conversion, "quoteTime", "ts")
	var fromCoin interface{} = this.SafeString(conversion, "baseCcy")
	var fromCode interface{} = this.SafeCurrencyCode(fromCoin, fromCurrency)
	var to interface{} = this.SafeString(conversion, "quoteCcy")
	var toCode interface{} = this.SafeCurrencyCode(to, toCurrency)
	return map[string]interface{}{
		"info":         conversion,
		"timestamp":    timestamp,
		"datetime":     this.Iso8601(timestamp),
		"id":           this.SafeStringN(conversion, []interface{}{"clQReqId", "tradeId", "quoteId"}),
		"fromCurrency": fromCode,
		"fromAmount":   this.SafeNumber2(conversion, "baseSz", "fillBaseSz"),
		"toCurrency":   toCode,
		"toAmount":     this.SafeNumber2(conversion, "quoteSz", "fillQuoteSz"),
		"price":        this.SafeNumber2(conversion, "cnvtPx", "fillPx"),
		"fee":          nil,
	}
}

/**
 * @method
 * @name okx#fetchConvertCurrencies
 * @description fetches all available currencies that can be converted
 * @see https://www.okx.com/docs-v5/en/#funding-account-rest-api-get-convert-currencies
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func (this *OkxCore) FetchConvertCurrencies(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes88388 := (<-this.LoadMarkets())
		PanicOnError(retRes88388)

		response := (<-this.PrivateGetAssetConvertCurrencies(params))
		PanicOnError(response)
		//
		//     {
		//         "code": "0",
		//         "data": [
		//             {
		//                 "ccy": "BTC",
		//                 "max": "",
		//                 "min": ""
		//             },
		//         ],
		//         "msg": ""
		//     }
		//
		var result interface{} = map[string]interface{}{}
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
			var entry interface{} = GetValue(data, i)
			var id interface{} = this.SafeString(entry, "ccy")
			var code interface{} = this.SafeCurrencyCode(id)
			AddElementToObject(result, code, map[string]interface{}{
				"info":      entry,
				"id":        id,
				"code":      code,
				"networks":  nil,
				"type":      nil,
				"name":      nil,
				"active":    nil,
				"deposit":   nil,
				"withdraw":  nil,
				"fee":       nil,
				"precision": nil,
				"limits": map[string]interface{}{
					"amount": map[string]interface{}{
						"min": this.SafeNumber(entry, "min"),
						"max": this.SafeNumber(entry, "max"),
					},
					"withdraw": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
					"deposit": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
				},
				"created": nil,
			})
		}

		ch <- result
		return nil

	}()
	return ch
}
func (this *OkxCore) HandleErrors(httpCode interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{} {
	if !IsTrue(response) {
		return nil // fallback to default error handler
	}
	//
	//    {
	//        "code": "1",
	//        "data": [
	//            {
	//                "clOrdId": "",
	//                "ordId": "",
	//                "sCode": "51119",
	//                "sMsg": "Order placement failed due to insufficient balance. ",
	//                "tag": ""
	//            }
	//        ],
	//        "msg": ""
	//    },
	//    {
	//        "code": "58001",
	//        "data": [],
	//        "msg": "Incorrect trade password"
	//    }
	//
	var code interface{} = this.SafeString(response, "code")
	if IsTrue(IsTrue((!IsEqual(code, "0"))) && IsTrue((!IsEqual(code, "2")))) {
		var feedback interface{} = Add(Add(this.Id, " "), body)
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
			var error interface{} = GetValue(data, i)
			var errorCode interface{} = this.SafeString(error, "sCode")
			var message interface{} = this.SafeString(error, "sMsg")
			this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), errorCode, feedback)
			this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), message, feedback)
		}
		this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), code, feedback)
		panic(ExchangeError(feedback))
	}
	return nil
}

/**
 * @method
 * @name okx#fetchMarginAdjustmentHistory
 * @description fetches the history of margin added or reduced from contract isolated positions
 * @see https://www.okx.com/docs-v5/en/#trading-account-rest-api-get-bills-details-last-7-days
 * @see https://www.okx.com/docs-v5/en/#trading-account-rest-api-get-bills-details-last-3-months
 * @param {string} [symbol] not used by okx fetchMarginAdjustmentHistory
 * @param {string} [type] "add" or "reduce"
 * @param {int} [since] the earliest time in ms to fetch margin adjustment history for
 * @param {int} [limit] the maximum number of entries to retrieve
 * @param {object} params extra parameters specific to the exchange api endpoint
 * @param {boolean} [params.auto] true if fetching auto margin increases
 * @returns {object[]} a list of [margin structures]{@link https://docs.ccxt.com/?id=margin-loan-structure}
 */
func (this *OkxCore) FetchMarginAdjustmentHistory(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		typeVar := GetArg(optionalArgs, 1, nil)
		_ = typeVar
		since := GetArg(optionalArgs, 2, nil)
		_ = since
		limit := GetArg(optionalArgs, 3, nil)
		_ = limit
		params := GetArg(optionalArgs, 4, map[string]interface{}{})
		_ = params

		retRes89478 := (<-this.LoadMarkets())
		PanicOnError(retRes89478)
		var auto interface{} = this.SafeBool(params, "auto")
		if IsTrue(IsEqual(typeVar, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchMarginAdjustmentHistory () requires a type argument")))
		}
		var isAdd interface{} = IsEqual(typeVar, "add")
		var subType interface{} = Ternary(IsTrue(isAdd), "160", "161")
		if IsTrue(auto) {
			if IsTrue(isAdd) {
				subType = "162"
			} else {
				panic(BadRequest(Add(Add(this.Id, " cannot fetch margin adjustments for type "), typeVar)))
			}
		}
		var request interface{} = map[string]interface{}{
			"subType": subType,
			"mgnMode": "isolated",
		}
		var until interface{} = this.SafeInteger(params, "until")
		params = this.Omit(params, "until")
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}
		if IsTrue(!IsEqual(until, nil)) {
			AddElementToObject(request, "endTime", until)
		}
		var response interface{} = nil
		var now interface{} = this.Milliseconds()
		var oneWeekAgo interface{} = Subtract(now, 604800000)
		var threeMonthsAgo interface{} = Subtract(now, 7776000000)
		if IsTrue(IsTrue((IsEqual(since, nil))) || IsTrue((IsGreaterThan(since, oneWeekAgo)))) {

			response = (<-this.PrivateGetAccountBills(this.Extend(request, params)))
			PanicOnError(response)
		} else if IsTrue(IsGreaterThan(since, threeMonthsAgo)) {

			response = (<-this.PrivateGetAccountBillsArchive(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			panic(BadRequest(Add(this.Id, " fetchMarginAdjustmentHistory () cannot fetch margin adjustments older than 3 months")))
		}
		//
		//    {
		//        code: '0',
		//        data: [
		//            {
		//                bal: '67621.4325135010619812',
		//                balChg: '-10.0000000000000000',
		//                billId: '691293628710342659',
		//                ccy: 'USDT',
		//                clOrdId: '',
		//                execType: '',
		//                fee: '0',
		//                fillFwdPx: '',
		//                fillIdxPx: '',
		//                fillMarkPx: '',
		//                fillMarkVol: '',
		//                fillPxUsd: '',
		//                fillPxVol: '',
		//                fillTime: '1711089244850',
		//                from: '',
		//                instId: 'XRP-USDT-SWAP',
		//                instType: 'SWAP',
		//                interest: '0',
		//                mgnMode: 'isolated',
		//                notes: '',
		//                ordId: '',
		//                pnl: '0',
		//                posBal: '73.12',
		//                posBalChg: '10.00',
		//                px: '',
		//                subType: '160',
		//                sz: '10',
		//                tag: '',
		//                to: '',
		//                tradeId: '0',
		//                ts: '1711089244699',
		//                type: '6'
		//            }
		//        ],
		//        msg: ''
		//    }
		//
		var data interface{} = this.SafeList(response, "data")
		var modifications interface{} = this.ParseMarginModifications(data)

		ch <- this.FilterBySymbolSinceLimit(modifications, symbol, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#fetchPositionsHistory
 * @description fetches historical positions
 * @see https://www.okx.com/docs-v5/en/#trading-account-rest-api-get-positions-history
 * @param {string} [symbols] unified market symbols
 * @param {int} [since] timestamp in ms of the earliest position to fetch
 * @param {int} [limit] the maximum amount of records to fetch, default=100, max=100
 * @param {object} params extra parameters specific to the exchange api endpoint
 * @param {string} [params.marginMode] "cross" or "isolated"
 *
 * EXCHANGE SPECIFIC PARAMETERS
 * @param {string} [params.instType] margin, swap, futures or option
 * @param {string} [params.type] the type of latest close position 1: close position partially, 2close all, 3liquidation, 4partial liquidation; 5adl, is it is the latest type if there are several types for the same position
 * @param {string} [params.posId] position id, there is attribute expiration, the posid will be expired if it is more than 30 days after the last full close position, then position will use new posid
 * @param {string} [params.before] timestamp in ms of the earliest position to fetch based on the last update time of the position
 * @param {string} [params.after] timestamp in ms of the latest position to fetch based on the last update time of the position
 * @returns {object[]} a list of [position structures]{@link https://docs.ccxt.com/?id=position-structure}
 */
func (this *OkxCore) FetchPositionsHistory(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes90548 := (<-this.LoadMarkets())
		PanicOnError(retRes90548)
		var marginMode interface{} = this.SafeString(params, "marginMode")
		var instType interface{} = this.SafeStringUpper(params, "instType")
		params = this.Omit(params, []interface{}{"until", "marginMode", "instType"})
		if IsTrue(IsEqual(limit, nil)) {
			limit = 100
		}
		var request interface{} = map[string]interface{}{
			"limit": limit,
		}
		if IsTrue(!IsEqual(symbols, nil)) {
			var symbolsLength interface{} = GetArrayLength(symbols)
			if IsTrue(IsEqual(symbolsLength, 1)) {
				var market interface{} = this.Market(GetValue(symbols, 0))
				AddElementToObject(request, "instId", GetValue(market, "id"))
			}
		}
		if IsTrue(!IsEqual(marginMode, nil)) {
			AddElementToObject(request, "mgnMode", marginMode)
		}
		if IsTrue(!IsEqual(instType, nil)) {
			AddElementToObject(request, "instType", instType)
		}

		response := (<-this.PrivateGetAccountPositionsHistory(this.Extend(request, params)))
		PanicOnError(response)
		//
		//    {
		//        code: '0',
		//        data: [
		//            {
		//                cTime: '1708735940395',
		//                ccy: 'USDT',
		//                closeAvgPx: '0.6330444444444444',
		//                closeTotalPos: '27',
		//                direction: 'long',
		//                fee: '-1.69566',
		//                fundingFee: '-11.870404179341788',
		//                instId: 'XRP-USDT-SWAP',
		//                instType: 'SWAP',
		//                lever: '3.0',
		//                liqPenalty: '0',
		//                mgnMode: 'cross',
		//                openAvgPx: '0.623',
		//                openMaxPos: '15',
		//                pnl: '27.11999999999988',
		//                pnlRatio: '0.0241732402722634',
		//                posId: '681423155054862336',
		//                realizedPnl: '13.553935820658092',
		//                triggerPx: '',
		//                type: '2',
		//                uTime: '1711088748170',
		//                uly: 'XRP-USDT'
		//            },
		//            ...
		//        ],
		//        msg: ''
		//    }
		//
		var data interface{} = this.SafeList(response, "data")
		var positions interface{} = this.ParsePositions(data, symbols, params)

		ch <- this.FilterBySinceLimit(positions, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name okx#fetchLongShortRatioHistory
 * @description fetches the long short ratio history for a unified market symbol
 * @see https://www.okx.com/docs-v5/en/#trading-statistics-rest-api-get-contract-long-short-ratio
 * @param {string} symbol unified symbol of the market to fetch the long short ratio for
 * @param {string} [timeframe] the period for the ratio
 * @param {int} [since] the earliest time in ms to fetch ratios for
 * @param {int} [limit] the maximum number of long short ratio structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest ratio to fetch
 * @returns {object[]} an array of [long short ratio structures]{@link https://docs.ccxt.com/?id=long-short-ratio-structure}
 */
func (this *OkxCore) FetchLongShortRatioHistory(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		timeframe := GetArg(optionalArgs, 1, nil)
		_ = timeframe
		since := GetArg(optionalArgs, 2, nil)
		_ = since
		limit := GetArg(optionalArgs, 3, nil)
		_ = limit
		params := GetArg(optionalArgs, 4, map[string]interface{}{})
		_ = params

		retRes91308 := (<-this.LoadMarkets())
		PanicOnError(retRes91308)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"instId": GetValue(market, "id"),
		}
		var until interface{} = this.SafeString2(params, "until", "end")
		params = this.Omit(params, "until")
		if IsTrue(!IsEqual(until, nil)) {
			AddElementToObject(request, "end", until)
		}
		if IsTrue(!IsEqual(timeframe, nil)) {
			AddElementToObject(request, "period", timeframe)
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "begin", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}

		response := (<-this.PublicGetRubikStatContractsLongShortAccountRatioContract(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "0",
		//         "data": [
		//             ["1729323600000", "0.9398602814619824"],
		//             ["1729323300000", "0.9398602814619824"],
		//             ["1729323000000", "0.9398602814619824"],
		//         ],
		//         "msg": ""
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var result interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
			var entry interface{} = GetValue(data, i)
			AppendToArray(&result, map[string]interface{}{
				"timestamp":      this.SafeString(entry, 0),
				"longShortRatio": this.SafeString(entry, 1),
			})
		}

		ch <- this.ParseLongShortRatioHistory(result, market)
		return nil

	}()
	return ch
}
func (this *OkxCore) ParseLongShortRatio(info interface{}, optionalArgs ...interface{}) interface{} {
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var timestamp interface{} = this.SafeInteger(info, "timestamp")
	var symbol interface{} = nil
	if IsTrue(!IsEqual(market, nil)) {
		symbol = GetValue(market, "symbol")
	}
	return map[string]interface{}{
		"info":           info,
		"symbol":         symbol,
		"timestamp":      timestamp,
		"datetime":       this.Iso8601(timestamp),
		"timeframe":      nil,
		"longShortRatio": this.SafeNumber(info, "longShortRatio"),
	}
}

func (this *OkxCore) Init(userConfig map[string]interface{}) {
	this.Exchange = Exchange{}
	this.Exchange.DerivedExchange = this
	this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
}
