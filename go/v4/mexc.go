package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type mexc struct {
	Exchange
}

func NewMexcCore() *mexc {
	p := &mexc{}
	setDefaults(p)
	return p
}

func (this *mexc) Describe() interface{} {
	return this.DeepExtend(this.Exchange.Describe(), map[string]interface{}{
		"id":        "mexc",
		"name":      "MEXC Global",
		"countries": []interface{}{"SC"},
		"rateLimit": 50,
		"version":   "v3",
		"certified": true,
		"pro":       true,
		"has": map[string]interface{}{
			"CORS":                           nil,
			"spot":                           true,
			"margin":                         true,
			"swap":                           true,
			"future":                         false,
			"option":                         false,
			"addMargin":                      true,
			"borrowCrossMargin":              false,
			"borrowIsolatedMargin":           false,
			"borrowMargin":                   false,
			"cancelAllOrders":                true,
			"cancelOrder":                    true,
			"cancelOrders":                   nil,
			"closeAllPositions":              false,
			"closePosition":                  false,
			"createDepositAddress":           true,
			"createMarketBuyOrderWithCost":   true,
			"createMarketOrderWithCost":      true,
			"createMarketSellOrderWithCost":  true,
			"createOrder":                    true,
			"createOrders":                   true,
			"createPostOnlyOrder":            true,
			"createReduceOnlyOrder":          true,
			"createStopLimitOrder":           true,
			"createStopMarketOrder":          true,
			"createStopOrder":                true,
			"createTriggerOrder":             true,
			"deposit":                        nil,
			"editOrder":                      nil,
			"fetchAccounts":                  true,
			"fetchBalance":                   true,
			"fetchBidsAsks":                  true,
			"fetchBorrowInterest":            false,
			"fetchBorrowRate":                false,
			"fetchBorrowRateHistories":       false,
			"fetchBorrowRateHistory":         false,
			"fetchBorrowRates":               false,
			"fetchBorrowRatesPerSymbol":      false,
			"fetchCanceledOrders":            true,
			"fetchClosedOrder":               nil,
			"fetchClosedOrders":              true,
			"fetchCrossBorrowRate":           false,
			"fetchCrossBorrowRates":          false,
			"fetchCurrencies":                true,
			"fetchDeposit":                   nil,
			"fetchDepositAddress":            true,
			"fetchDepositAddresses":          nil,
			"fetchDepositAddressesByNetwork": true,
			"fetchDeposits":                  true,
			"fetchDepositWithdrawFee":        "emulated",
			"fetchDepositWithdrawFees":       true,
			"fetchFundingHistory":            true,
			"fetchFundingInterval":           true,
			"fetchFundingIntervals":          false,
			"fetchFundingRate":               true,
			"fetchFundingRateHistory":        true,
			"fetchFundingRates":              false,
			"fetchIndexOHLCV":                true,
			"fetchIsolatedBorrowRate":        false,
			"fetchIsolatedBorrowRates":       false,
			"fetchIsolatedPositions":         false,
			"fetchL2OrderBook":               true,
			"fetchLedger":                    nil,
			"fetchLedgerEntry":               nil,
			"fetchLeverage":                  true,
			"fetchLeverages":                 false,
			"fetchLeverageTiers":             true,
			"fetchMarginAdjustmentHistory":   false,
			"fetchMarginMode":                false,
			"fetchMarketLeverageTiers":       "emulated",
			"fetchMarkets":                   true,
			"fetchMarkOHLCV":                 true,
			"fetchMyTrades":                  true,
			"fetchOHLCV":                     true,
			"fetchOpenInterest":              false,
			"fetchOpenInterestHistory":       false,
			"fetchOpenOrder":                 nil,
			"fetchOpenOrders":                true,
			"fetchOrder":                     true,
			"fetchOrderBook":                 true,
			"fetchOrderBooks":                nil,
			"fetchOrders":                    true,
			"fetchOrderTrades":               true,
			"fetchPosition":                  "emulated",
			"fetchPositionHistory":           "emulated",
			"fetchPositionMode":              true,
			"fetchPositions":                 true,
			"fetchPositionsHistory":          true,
			"fetchPositionsRisk":             nil,
			"fetchPremiumIndexOHLCV":         false,
			"fetchStatus":                    true,
			"fetchTicker":                    true,
			"fetchTickers":                   true,
			"fetchTime":                      true,
			"fetchTrades":                    true,
			"fetchTradingFee":                true,
			"fetchTradingFees":               false,
			"fetchTradingLimits":             nil,
			"fetchTransactionFee":            "emulated",
			"fetchTransactionFees":           true,
			"fetchTransactions":              nil,
			"fetchTransfer":                  true,
			"fetchTransfers":                 true,
			"fetchWithdrawal":                nil,
			"fetchWithdrawals":               true,
			"reduceMargin":                   true,
			"repayCrossMargin":               false,
			"repayIsolatedMargin":            false,
			"setLeverage":                    true,
			"setMarginMode":                  true,
			"setPositionMode":                true,
			"signIn":                         nil,
			"transfer":                       nil,
			"withdraw":                       true,
		},
		"urls": map[string]interface{}{
			"logo": "https://user-images.githubusercontent.com/1294454/137283979-8b2a818d-8633-461b-bfca-de89e8c446b2.jpg",
			"api": map[string]interface{}{
				"spot": map[string]interface{}{
					"public":  "https://api.mexc.com",
					"private": "https://api.mexc.com",
				},
				"spot2": map[string]interface{}{
					"public":  "https://www.mexc.com/open/api/v2",
					"private": "https://www.mexc.com/open/api/v2",
				},
				"contract": map[string]interface{}{
					"public":  "https://contract.mexc.com/api/v1/contract",
					"private": "https://contract.mexc.com/api/v1/private",
				},
				"broker": map[string]interface{}{
					"private": "https://api.mexc.com/api/v3/broker",
				},
			},
			"www":      "https://www.mexc.com/",
			"doc":      []interface{}{"https://mexcdevelop.github.io/apidocs/"},
			"fees":     []interface{}{"https://www.mexc.com/fee"},
			"referral": "https://www.mexc.com/register?inviteCode=mexc-1FQ1GNu1",
		},
		"api": map[string]interface{}{
			"spot": map[string]interface{}{
				"public": map[string]interface{}{
					"get": map[string]interface{}{
						"ping":              1,
						"time":              1,
						"exchangeInfo":      10,
						"depth":             1,
						"trades":            5,
						"historicalTrades":  1,
						"aggTrades":         1,
						"klines":            1,
						"avgPrice":          1,
						"ticker/24hr":       1,
						"ticker/price":      1,
						"ticker/bookTicker": 1,
						"etf/info":          1,
					},
				},
				"private": map[string]interface{}{
					"get": map[string]interface{}{
						"order":                                 2,
						"openOrders":                            3,
						"allOrders":                             10,
						"account":                               10,
						"myTrades":                              10,
						"tradeFee":                              10,
						"sub-account/list":                      1,
						"sub-account/apiKey":                    1,
						"capital/config/getall":                 10,
						"capital/deposit/hisrec":                1,
						"capital/withdraw/history":              1,
						"capital/withdraw/address":              10,
						"capital/deposit/address":               10,
						"capital/transfer":                      1,
						"capital/transfer/tranId":               1,
						"capital/transfer/internal":             1,
						"capital/sub-account/universalTransfer": 1,
						"capital/convert":                       1,
						"capital/convert/list":                  1,
						"margin/loan":                           1,
						"margin/allOrders":                      1,
						"margin/myTrades":                       1,
						"margin/openOrders":                     1,
						"margin/maxTransferable":                1,
						"margin/priceIndex":                     1,
						"margin/order":                          1,
						"margin/isolated/account":               1,
						"margin/maxBorrowable":                  1,
						"margin/repay":                          1,
						"margin/isolated/pair":                  1,
						"margin/forceLiquidationRec":            1,
						"margin/isolatedMarginData":             1,
						"margin/isolatedMarginTier":             1,
						"rebate/taxQuery":                       1,
						"rebate/detail":                         1,
						"rebate/detail/kickback":                1,
						"rebate/referCode":                      1,
						"rebate/affiliate/commission":           1,
						"rebate/affiliate/withdraw":             1,
						"rebate/affiliate/commission/detail":    1,
						"mxDeduct/enable":                       1,
						"userDataStream":                        1,
						"selfSymbols":                           1,
					},
					"post": map[string]interface{}{
						"order":                                 1,
						"order/test":                            1,
						"sub-account/virtualSubAccount":         1,
						"sub-account/apiKey":                    1,
						"sub-account/futures":                   1,
						"sub-account/margin":                    1,
						"batchOrders":                           10,
						"capital/withdraw/apply":                1,
						"capital/withdraw":                      1,
						"capital/transfer":                      1,
						"capital/transfer/internal":             1,
						"capital/deposit/address":               1,
						"capital/sub-account/universalTransfer": 1,
						"capital/convert":                       10,
						"mxDeduct/enable":                       1,
						"userDataStream":                        1,
					},
					"put": map[string]interface{}{
						"userDataStream": 1,
					},
					"delete": map[string]interface{}{
						"order":              1,
						"openOrders":         1,
						"sub-account/apiKey": 1,
						"margin/order":       1,
						"margin/openOrders":  1,
						"userDataStream":     1,
						"capital/withdraw":   1,
					},
				},
			},
			"contract": map[string]interface{}{
				"public": map[string]interface{}{
					"get": map[string]interface{}{
						"ping":                           2,
						"detail":                         100,
						"support_currencies":             2,
						"depth/{symbol}":                 2,
						"depth_commits/{symbol}/{limit}": 2,
						"index_price/{symbol}":           2,
						"fair_price/{symbol}":            2,
						"funding_rate/{symbol}":          2,
						"kline/{symbol}":                 2,
						"kline/index_price/{symbol}":     2,
						"kline/fair_price/{symbol}":      2,
						"deals/{symbol}":                 2,
						"ticker":                         2,
						"risk_reverse":                   2,
						"risk_reverse/history":           2,
						"funding_rate/history":           2,
					},
				},
				"private": map[string]interface{}{
					"get": map[string]interface{}{
						"account/assets":                          2,
						"account/asset/{currency}":                2,
						"account/transfer_record":                 2,
						"position/list/history_positions":         2,
						"position/open_positions":                 2,
						"position/funding_records":                2,
						"position/position_mode":                  2,
						"order/list/open_orders/{symbol}":         2,
						"order/list/history_orders":               2,
						"order/external/{symbol}/{external_oid}":  2,
						"order/get/{order_id}":                    2,
						"order/batch_query":                       8,
						"order/deal_details/{order_id}":           2,
						"order/list/order_deals":                  2,
						"planorder/list/orders":                   2,
						"stoporder/list/orders":                   2,
						"stoporder/order_details/{stop_order_id}": 2,
						"account/risk_limit":                      2,
						"account/tiered_fee_rate":                 2,
						"position/leverage":                       2,
					},
					"post": map[string]interface{}{
						"position/change_margin":        2,
						"position/change_leverage":      2,
						"position/change_position_mode": 2,
						"order/submit":                  2,
						"order/submit_batch":            40,
						"order/cancel":                  2,
						"order/cancel_with_external":    2,
						"order/cancel_all":              2,
						"account/change_risk_level":     2,
						"planorder/place":               2,
						"planorder/cancel":              2,
						"planorder/cancel_all":          2,
						"stoporder/cancel":              2,
						"stoporder/cancel_all":          2,
						"stoporder/change_price":        2,
						"stoporder/change_plan_price":   2,
					},
				},
			},
			"spot2": map[string]interface{}{
				"public": map[string]interface{}{
					"get": map[string]interface{}{
						"market/symbols":             1,
						"market/coin/list":           2,
						"common/timestamp":           1,
						"common/ping":                2,
						"market/ticker":              1,
						"market/depth":               1,
						"market/deals":               1,
						"market/kline":               1,
						"market/api_default_symbols": 2,
					},
				},
				"private": map[string]interface{}{
					"get": map[string]interface{}{
						"account/info":                   1,
						"order/open_orders":              1,
						"order/list":                     1,
						"order/query":                    1,
						"order/deals":                    1,
						"order/deal_detail":              1,
						"asset/deposit/address/list":     2,
						"asset/deposit/list":             2,
						"asset/address/list":             2,
						"asset/withdraw/list":            2,
						"asset/internal/transfer/record": 10,
						"account/balance":                10,
						"asset/internal/transfer/info":   10,
						"market/api_symbols":             2,
					},
					"post": map[string]interface{}{
						"order/place":                1,
						"order/place_batch":          1,
						"order/advanced/place_batch": 1,
						"asset/withdraw":             2,
						"asset/internal/transfer":    10,
					},
					"delete": map[string]interface{}{
						"order/cancel":           1,
						"order/cancel_by_symbol": 1,
						"asset/withdraw":         2,
					},
				},
			},
			"broker": map[string]interface{}{
				"private": map[string]interface{}{
					"get": map[string]interface{}{
						"sub-account/universalTransfer":    1,
						"sub-account/list":                 1,
						"sub-account/apiKey":               1,
						"capital/deposit/subAddress":       1,
						"capital/deposit/subHisrec":        1,
						"capital/deposit/subHisrec/getall": 1,
					},
					"post": map[string]interface{}{
						"sub-account/virtualSubAccount": 1,
						"sub-account/apiKey":            1,
						"capital/deposit/subAddress":    1,
						"capital/withdraw/apply":        1,
						"sub-account/universalTransfer": 1,
						"sub-account/futures":           1,
					},
					"delete": map[string]interface{}{
						"sub-account/apiKey": 1,
					},
				},
			},
		},
		"precisionMode": TICK_SIZE,
		"timeframes": map[string]interface{}{
			"1m":  "1m",
			"5m":  "5m",
			"15m": "15m",
			"30m": "30m",
			"1h":  "1h",
			"4h":  "4h",
			"8h":  "8h",
			"1d":  "1d",
			"1w":  "1w",
			"1M":  "1M",
		},
		"fees": map[string]interface{}{
			"trading": map[string]interface{}{
				"tierBased":  false,
				"percentage": true,
				"maker":      this.ParseNumber("0.002"),
				"taker":      this.ParseNumber("0.002"),
			},
		},
		"options": map[string]interface{}{
			"adjustForTimeDifference": false,
			"timeDifference":          0,
			"unavailableContracts": map[string]interface{}{
				"BTC/USDT:USDT": true,
				"LTC/USDT:USDT": true,
				"ETH/USDT:USDT": true,
			},
			"fetchMarkets": map[string]interface{}{
				"types": map[string]interface{}{
					"spot": true,
					"swap": map[string]interface{}{
						"linear":  true,
						"inverse": false,
					},
				},
			},
			"useCcxtTradeId": true,
			"timeframes": map[string]interface{}{
				"spot": map[string]interface{}{
					"1m":  "1m",
					"5m":  "5m",
					"15m": "15m",
					"30m": "30m",
					"1h":  "60m",
					"4h":  "4h",
					"1d":  "1d",
					"1w":  "1W",
					"1M":  "1M",
				},
				"swap": map[string]interface{}{
					"1m":  "Min1",
					"5m":  "Min5",
					"15m": "Min15",
					"30m": "Min30",
					"1h":  "Min60",
					"4h":  "Hour4",
					"8h":  "Hour8",
					"1d":  "Day1",
					"1w":  "Week1",
					"1M":  "Month1",
				},
			},
			"defaultType":    "spot",
			"defaultNetwork": "ETH",
			"defaultNetworks": map[string]interface{}{
				"ETH":  "ETH",
				"USDT": "ERC20",
				"USDC": "ERC20",
				"BTC":  "BTC",
				"LTC":  "LTC",
			},
			"networks": map[string]interface{}{
				"ZKSYNC":   "ZKSYNCERA",
				"TRC20":    "TRX",
				"TON":      "TONCOIN",
				"ARBITRUM": "ARB",
				"STX":      "STACKS",
				"LUNC":     "LUNA",
				"STARK":    "STARKNET",
				"APT":      "APTOS",
				"PEAQ":     "PEAQEVM",
				"AVAXC":    "AVAX_CCHAIN",
				"ERC20":    "ETH",
				"ACA":      "ACALA",
				"BEP20":    "BSC",
				"OPTIMISM": "OP",
				"ASTR":     "ASTAR",
				"BTM":      "BTM2",
				"CRC20":    "CRONOS",
				"DOT":      "DOTASSETHUB",
				"ETHF":     "ETF",
				"HRC20":    "HECO",
				"OASIS":    "ROSE",
				"OKC":      "OKT",
				"RSK":      "RBTC",
			},
			"networksById": map[string]interface{}{
				"BNB Smart Chain(BEP20-RACAV1)": "BSC",
				"BNB Smart Chain(BEP20-RACAV2)": "BSC",
				"BNB Smart Chain(BEP20)":        "BSC",
				"Ethereum(ERC20)":               "ERC20",
			},
			"recvWindow":     Multiply(5, 1000),
			"maxTimeTillEnd": Subtract(Multiply(Multiply(90, 86400), 1000), 1),
			"broker":         "CCXT",
		},
		"features": map[string]interface{}{
			"default": map[string]interface{}{
				"sandbox": false,
				"createOrder": map[string]interface{}{
					"marginMode":       true,
					"triggerPrice":     false,
					"triggerDirection": false,
					"triggerPriceType": map[string]interface{}{
						"last":  false,
						"mark":  false,
						"index": false,
					},
					"stopLossPrice":              false,
					"takeProfitPrice":            false,
					"attachedStopLossTakeProfit": nil,
					"timeInForce": map[string]interface{}{
						"IOC": true,
						"FOK": true,
						"PO":  true,
						"GTD": false,
					},
					"hedged":                 true,
					"trailing":               false,
					"leverage":               true,
					"marketBuyByCost":        true,
					"marketBuyRequiresPrice": false,
					"selfTradePrevention":    false,
					"iceberg":                false,
				},
				"createOrders": map[string]interface{}{
					"max": 20,
				},
				"fetchMyTrades": map[string]interface{}{
					"marginMode":     false,
					"limit":          100,
					"daysBack":       30,
					"untilDays":      nil,
					"symbolRequired": true,
				},
				"fetchOrder": map[string]interface{}{
					"marginMode":     false,
					"trigger":        false,
					"trailing":       false,
					"symbolRequired": true,
				},
				"fetchOpenOrders": map[string]interface{}{
					"marginMode":     true,
					"limit":          nil,
					"trigger":        false,
					"trailing":       false,
					"symbolRequired": true,
				},
				"fetchOrders": map[string]interface{}{
					"marginMode":     true,
					"limit":          1000,
					"daysBack":       7,
					"untilDays":      7,
					"trigger":        false,
					"trailing":       false,
					"symbolRequired": true,
				},
				"fetchClosedOrders": map[string]interface{}{
					"marginMode":       true,
					"limit":            1000,
					"daysBack":         7,
					"daysBackCanceled": 7,
					"untilDays":        7,
					"trigger":          false,
					"trailing":         false,
					"symbolRequired":   true,
				},
				"fetchOHLCV": map[string]interface{}{
					"limit": 1000,
				},
			},
			"spot": map[string]interface{}{
				"extends": "default",
				"fetchCurrencies": map[string]interface{}{
					"private": true,
				},
			},
			"forDerivs": map[string]interface{}{
				"extends": "default",
				"createOrder": map[string]interface{}{
					"triggerPrice": true,
					"triggerPriceType": map[string]interface{}{
						"last":  true,
						"mark":  true,
						"index": true,
					},
					"triggerDirection": true,
					"stopLossPrice":    false,
					"takeProfitPrice":  false,
					"hedged":           true,
					"leverage":         true,
					"marketBuyByCost":  false,
				},
				"createOrders": nil,
				"fetchMyTrades": map[string]interface{}{
					"marginMode": false,
					"limit":      100,
					"daysBack":   90,
					"untilDays":  90,
				},
				"fetchOrder": map[string]interface{}{
					"marginMode": false,
				},
				"fetchOpenOrders": map[string]interface{}{
					"marginMode": false,
					"limit":      100,
					"trigger":    true,
					"trailing":   false,
				},
				"fetchOrders": map[string]interface{}{
					"marginMode": false,
					"limit":      100,
					"daysBack":   90,
					"untilDays":  90,
					"trigger":    true,
					"trailing":   false,
				},
				"fetchClosedOrders": map[string]interface{}{
					"marginMode":       false,
					"limit":            100,
					"daysBack":         90,
					"daysBackCanceled": nil,
					"untilDays":        90,
					"trigger":          true,
					"trailing":         false,
				},
				"fetchOHLCV": map[string]interface{}{
					"limit": 2000,
				},
			},
			"swap": map[string]interface{}{
				"linear": map[string]interface{}{
					"extends": "forDerivs",
				},
				"inverse": map[string]interface{}{
					"extends": "forDerivs",
				},
			},
			"future": map[string]interface{}{
				"linear":  nil,
				"inverse": nil,
			},
		},
		"commonCurrencies": map[string]interface{}{
			"BEYONDPROTOCOL": "BEYOND",
			"BIFI":           "BIFIF",
			"BYN":            "BEYONDFI",
			"COFI":           "COFIX",
			"DFI":            "DFISTARTER",
			"DFT":            "DFUTURE",
			"DRK":            "DRK",
			"EGC":            "EGORASCREDIT",
			"FLUX1":          "FLUX",
			"FLUX":           "FLUX1",
			"FREE":           "FREEROSSDAO",
			"GAS":            "GASDAO",
			"GASNEO":         "GAS",
			"GMT":            "GMTTOKEN",
			"STEPN":          "GMT",
			"HERO":           "STEPHERO",
			"MIMO":           "MIMOSA",
			"PROS":           "PROSFINANCE",
			"SIN":            "SINCITYTOKEN",
			"SOUL":           "SOULSWAP",
			"XBT":            "XBT",
		},
		"exceptions": map[string]interface{}{
			"exact": map[string]interface{}{
				"-1128":  BadRequest,
				"-2011":  BadRequest,
				"-1121":  BadSymbol,
				"10101":  InsufficientFunds,
				"2009":   InvalidOrder,
				"2011":   BadRequest,
				"30004":  InsufficientFunds,
				"33333":  BadRequest,
				"44444":  BadRequest,
				"1002":   InvalidOrder,
				"30019":  BadRequest,
				"30005":  InvalidOrder,
				"2003":   InvalidOrder,
				"2005":   InsufficientFunds,
				"400":    BadRequest,
				"600":    BadRequest,
				"70011":  PermissionDenied,
				"88004":  InsufficientFunds,
				"88009":  ExchangeError,
				"88013":  InvalidOrder,
				"88015":  InsufficientFunds,
				"700003": InvalidNonce,
				"26":     ExchangeError,
				"602":    AuthenticationError,
				"10001":  AuthenticationError,
				"10007":  BadSymbol,
				"10015":  BadRequest,
				"10072":  BadRequest,
				"10073":  BadRequest,
				"10095":  InvalidOrder,
				"10096":  InvalidOrder,
				"10097":  InvalidOrder,
				"10098":  InvalidOrder,
				"10099":  BadRequest,
				"10100":  BadRequest,
				"10102":  InvalidOrder,
				"10103":  ExchangeError,
				"10200":  BadRequest,
				"10201":  BadRequest,
				"10202":  BadRequest,
				"10206":  BadRequest,
				"10211":  BadRequest,
				"10212":  BadRequest,
				"10216":  ExchangeError,
				"10219":  ExchangeError,
				"10222":  BadRequest,
				"10232":  BadRequest,
				"10259":  ExchangeError,
				"10265":  ExchangeError,
				"10268":  BadRequest,
				"20001":  ExchangeError,
				"20002":  ExchangeError,
				"22222":  BadRequest,
				"30000":  ExchangeError,
				"30001":  InvalidOrder,
				"30002":  InvalidOrder,
				"30003":  InvalidOrder,
				"30010":  InvalidOrder,
				"30014":  InvalidOrder,
				"30016":  InvalidOrder,
				"30018":  AccountSuspended,
				"30020":  AuthenticationError,
				"30021":  BadRequest,
				"30025":  InvalidOrder,
				"30026":  BadRequest,
				"30027":  InvalidOrder,
				"30028":  InvalidOrder,
				"30029":  InvalidOrder,
				"30032":  InvalidOrder,
				"30041":  InvalidOrder,
				"60005":  ExchangeError,
				"700001": AuthenticationError,
				"700002": AuthenticationError,
				"700004": BadRequest,
				"700005": InvalidNonce,
				"700006": BadRequest,
				"700007": AuthenticationError,
				"700008": BadRequest,
				"700013": AuthenticationError,
				"730001": BadRequest,
				"730002": BadRequest,
				"730000": ExchangeError,
				"730003": ExchangeError,
				"730100": ExchangeError,
				"730600": BadRequest,
				"730601": BadRequest,
				"730602": BadRequest,
				"730700": BadRequest,
				"730701": BadRequest,
				"730702": BadRequest,
				"730703": BadRequest,
				"730704": BadRequest,
				"730705": BadRequest,
				"730706": BadRequest,
				"730707": BadRequest,
				"730101": BadRequest,
				"140001": BadRequest,
				"140002": AuthenticationError,
			},
			"broad": map[string]interface{}{
				"Order quantity error, please try to modify.": BadRequest,
				"Combination of optional parameters invalid":  BadRequest,
				"api market order is disabled":                BadRequest,
				"Contract not allow place order!":             InvalidOrder,
				"Oversold":                                    InsufficientFunds,
				"Insufficient position":                       InsufficientFunds,
				"Insufficient balance!":                       InsufficientFunds,
				"Bid price is great than max allow price":     InvalidOrder,
				"Invalid symbol.":                             BadSymbol,
				"Param error!":                                BadRequest,
				"maintenance":                                 OnMaintenance,
			},
		},
	})
}

/**
 * @method
 * @name mexc#fetchStatus
 * @description the latest known information on the availability of the exchange API
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#test-connectivity
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-the-server-time
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [status structure]{@link https://docs.ccxt.com/#/?id=exchange-status-structure}
 */
func (this *mexc) FetchStatus(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		marketTypequeryVariable := this.HandleMarketTypeAndParams("fetchStatus", nil, params)
		marketType := GetValue(marketTypequeryVariable, 0)
		query := GetValue(marketTypequeryVariable, 1)
		var response interface{} = nil
		var status interface{} = nil
		var updated interface{} = nil
		if IsTrue(IsEqual(marketType, "spot")) {

			response = (<-this.SpotPublicGetPing(query))
			PanicOnError(response)
			//
			//     {}
			//
			var keys interface{} = ObjectKeys(response)
			var length interface{} = GetArrayLength(keys)
			status = Ternary(IsTrue(length), this.Json(response), "ok")
		} else if IsTrue(IsEqual(marketType, "swap")) {

			response = (<-this.ContractPublicGetPing(query))
			PanicOnError(response)
			//
			//     {"success":true,"code":"0","data":"1648124374985"}
			//
			status = Ternary(IsTrue(this.SafeValue(response, "success")), "ok", this.Json(response))
			updated = this.SafeInteger(response, "data")
		}

		ch <- map[string]interface{}{
			"status":  status,
			"updated": updated,
			"url":     nil,
			"eta":     nil,
			"info":    response,
		}
		return nil

	}()
	return ch
}

/**
 * @method
 * @name mexc#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#check-server-time
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-the-server-time
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func (this *mexc) FetchTime(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		marketTypequeryVariable := this.HandleMarketTypeAndParams("fetchTime", nil, params)
		marketType := GetValue(marketTypequeryVariable, 0)
		query := GetValue(marketTypequeryVariable, 1)
		var response interface{} = nil
		if IsTrue(IsEqual(marketType, "spot")) {

			response = (<-this.SpotPublicGetTime(query))
			PanicOnError(response)

			//
			//     {"serverTime": "1647519277579"}
			//
			ch <- this.SafeInteger(response, "serverTime")
			return nil
		} else if IsTrue(IsEqual(marketType, "swap")) {

			response = (<-this.ContractPublicGetPing(query))
			PanicOnError(response)

			//
			//     {"success":true,"code":"0","data":"1648124374985"}
			//
			ch <- this.SafeInteger(response, "data")
			return nil
		}

		return nil

	}()
	return ch
}

/**
 * @method
 * @name mexc#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#query-the-currency-information
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func (this *mexc) FetchCurrencies(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		// this endpoint requires authentication
		// while fetchCurrencies is a public API method by design
		// therefore we check the keys here
		// and fallback to generating the currencies from the markets
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		if !IsTrue(this.CheckRequiredCredentials(false)) {

			ch <- map[string]interface{}{}
			return nil
		}

		response := (<-this.SpotPrivateGetCapitalConfigGetall(params))
		PanicOnError(response)
		//
		// {
		//     "coin": "QANX",
		//     "name": "QANplatform",
		//     "networkList": [
		//       {
		//         "coin": "QANX",
		//         "depositDesc": null,
		//         "depositEnable": true,
		//         "minConfirm": "0",
		//         "name": "QANplatform",
		//         "network": "BEP20(BSC)",
		//         "withdrawEnable": false,
		//         "withdrawFee": "42.000000000000000000",
		//         "withdrawIntegerMultiple": null,
		//         "withdrawMax": "24000000.000000000000000000",
		//         "withdrawMin": "20.000000000000000000",
		//         "sameAddress": false,
		//         "contract": "0xAAA7A10a8ee237ea61E8AC46C50A8Db8bCC1baaa"
		//       },
		//       {
		//         "coin": "QANX",
		//         "depositDesc": null,
		//         "depositEnable": true,
		//         "minConfirm": "0",
		//         "name": "QANplatform",
		//         "network": "ERC20",
		//         "withdrawEnable": true,
		//         "withdrawFee": "2732.000000000000000000",
		//         "withdrawIntegerMultiple": null,
		//         "withdrawMax": "24000000.000000000000000000",
		//         "withdrawMin": "240.000000000000000000",
		//         "sameAddress": false,
		//         "contract": "0xAAA7A10a8ee237ea61E8AC46C50A8Db8bCC1baaa"
		//       }
		//     ]
		//   }
		//
		var result interface{} = map[string]interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
			var currency interface{} = GetValue(response, i)
			var id interface{} = this.SafeString(currency, "coin")
			var code interface{} = this.SafeCurrencyCode(id)
			var networks interface{} = map[string]interface{}{}
			var chains interface{} = this.SafeValue(currency, "networkList", []interface{}{})
			for j := 0; IsLessThan(j, GetArrayLength(chains)); j++ {
				var chain interface{} = GetValue(chains, j)
				var networkId interface{} = this.SafeString2(chain, "netWork", "network")
				var network interface{} = this.NetworkIdToCode(networkId)
				AddElementToObject(networks, network, map[string]interface{}{
					"info":      chain,
					"id":        networkId,
					"network":   network,
					"active":    nil,
					"deposit":   this.SafeBool(chain, "depositEnable", false),
					"withdraw":  this.SafeBool(chain, "withdrawEnable", false),
					"fee":       this.SafeNumber(chain, "withdrawFee"),
					"precision": nil,
					"limits": map[string]interface{}{
						"withdraw": map[string]interface{}{
							"min": this.SafeString(chain, "withdrawMin"),
							"max": this.SafeString(chain, "withdrawMax"),
						},
					},
					"contract": this.SafeString(chain, "contract"),
				})
			}
			AddElementToObject(result, code, this.SafeCurrencyStructure(map[string]interface{}{
				"info":      currency,
				"id":        id,
				"code":      code,
				"name":      this.SafeString(currency, "name"),
				"active":    nil,
				"deposit":   nil,
				"withdraw":  nil,
				"fee":       nil,
				"precision": nil,
				"limits": map[string]interface{}{
					"amount": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
				},
				"type":     "crypto",
				"networks": networks,
			}))
		}

		ch <- result
		return nil

	}()
	return ch
}

/**
 * @method
 * @name mexc#fetchMarkets
 * @description retrieves data on all markets for mexc
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#exchange-information
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-the-contract-information
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func (this *mexc) FetchMarkets(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		if IsTrue(GetValue(this.Options, "adjustForTimeDifference")) {

			retRes116312 := (<-this.LoadTimeDifference())
			PanicOnError(retRes116312)
		}
		var spotMarketPromise interface{} = this.FetchSpotMarkets(params)
		var swapMarketPromise interface{} = this.FetchSwapMarkets(params)
		spotMarketswapMarketVariable := (<-promiseAll([]interface{}{spotMarketPromise, swapMarketPromise}))
		spotMarket := GetValue(spotMarketswapMarketVariable, 0)
		swapMarket := GetValue(spotMarketswapMarketVariable, 1)

		ch <- this.ArrayConcat(spotMarket, swapMarket)
		return nil

	}()
	return ch
}

/**
 * @ignore
 * @method
 * @name mexc#fetchMarkets
 * @description retrieves data on all spot markets for mexc
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#exchange-information
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func (this *mexc) FetchSpotMarkets(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		response := (<-this.SpotPublicGetExchangeInfo(params))
		PanicOnError(response)
		//
		//     {
		//         "timezone": "CST",
		//         "serverTime": 1647521860402,
		//         "rateLimits": [],
		//         "exchangeFilters": [],
		//         "symbols": [
		//           {
		//                "symbol": "OGNUSDT",
		//                "status": "1",
		//                "baseAsset": "OGN",
		//                "baseAssetPrecision": "2",
		//                "quoteAsset": "USDT",
		//                "quoteAssetPrecision": "4",
		//                "orderTypes": [
		//                    "LIMIT",
		//                    "LIMIT_MAKER"
		//                ],
		//                "baseCommissionPrecision": "2",
		//                "quoteCommissionPrecision": "4",
		//                "quoteOrderQtyMarketAllowed": false,
		//                "isSpotTradingAllowed": true,
		//                "isMarginTradingAllowed": true,
		//                "permissions": [
		//                    "SPOT",
		//                    "MARGIN"
		//                ],
		//                "filters": [],
		//                "baseSizePrecision": "0.01", // this turned out to be a minimum base amount for order
		//                "maxQuoteAmount": "5000000",
		//                "makerCommission": "0.002",
		//                "takerCommission": "0.002"
		//                "quoteAmountPrecision": "5", // this turned out to be a minimum cost amount for order
		//                "quotePrecision": "4", // deprecated in favor of 'quoteAssetPrecision' ( https://dev.binance.vision/t/what-is-the-difference-between-quoteprecision-and-quoteassetprecision/4333 )
		//                // note, "icebergAllowed" & "ocoAllowed" fields were recently removed
		//            },
		//         ]
		//     }
		//
		// Notes:
		// - 'quoteAssetPrecision' & 'baseAssetPrecision' are not currency's real blockchain precision (to view currency's actual individual precision, refer to fetchCurrencies() method).
		//
		var data interface{} = this.SafeValue(response, "symbols", []interface{}{})
		var result interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
			var market interface{} = GetValue(data, i)
			var id interface{} = this.SafeString(market, "symbol")
			var baseId interface{} = this.SafeString(market, "baseAsset")
			var quoteId interface{} = this.SafeString(market, "quoteAsset")
			var base interface{} = this.SafeCurrencyCode(baseId)
			var quote interface{} = this.SafeCurrencyCode(quoteId)
			var status interface{} = this.SafeString(market, "status")
			var isSpotTradingAllowed interface{} = this.SafeValue(market, "isSpotTradingAllowed")
			var active interface{} = false
			if IsTrue(IsTrue((IsEqual(status, "1"))) && IsTrue((isSpotTradingAllowed))) {
				active = true
			}
			var isMarginTradingAllowed interface{} = this.SafeValue(market, "isMarginTradingAllowed")
			var makerCommission interface{} = this.SafeNumber(market, "makerCommission")
			var takerCommission interface{} = this.SafeNumber(market, "takerCommission")
			var maxQuoteAmount interface{} = this.SafeNumber(market, "maxQuoteAmount")
			AppendToArray(&result, map[string]interface{}{
				"id":             id,
				"symbol":         Add(Add(base, "/"), quote),
				"base":           base,
				"quote":          quote,
				"settle":         nil,
				"baseId":         baseId,
				"quoteId":        quoteId,
				"settleId":       nil,
				"type":           "spot",
				"spot":           true,
				"margin":         isMarginTradingAllowed,
				"swap":           false,
				"future":         false,
				"option":         false,
				"active":         active,
				"contract":       false,
				"linear":         nil,
				"inverse":        nil,
				"taker":          takerCommission,
				"maker":          makerCommission,
				"contractSize":   nil,
				"expiry":         nil,
				"expiryDatetime": nil,
				"strike":         nil,
				"optionType":     nil,
				"precision": map[string]interface{}{
					"amount": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "baseAssetPrecision"))),
					"price":  this.ParseNumber(this.ParsePrecision(this.SafeString(market, "quoteAssetPrecision"))),
				},
				"limits": map[string]interface{}{
					"leverage": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
					"amount": map[string]interface{}{
						"min": this.SafeNumber(market, "baseSizePrecision"),
						"max": nil,
					},
					"price": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
					"cost": map[string]interface{}{
						"min": this.SafeNumber(market, "quoteAmountPrecision"),
						"max": maxQuoteAmount,
					},
				},
				"created": nil,
				"info":    market,
			})
		}

		ch <- result
		return nil

	}()
	return ch
}

/**
 * @ignore
 * @method
 * @name mexc#fetchMarkets
 * @description retrieves data on all swap markets for mexc
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-the-contract-information
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func (this *mexc) FetchSwapMarkets(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		var currentRl interface{} = this.RateLimit
		this.SetProperty(this, "rateLimit", 10) // see comment: https://github.com/ccxt/ccxt/pull/23698

		response := (<-this.ContractPublicGetDetail(params))
		PanicOnError(response)
		this.SetProperty(this, "rateLimit", currentRl)
		//
		//     {
		//         "success":true,
		//         "code":0,
		//         "data":[
		//             {
		//                 "symbol":"BTC_USDT",
		//                 "displayName":"BTC_USDT永续",
		//                 "displayNameEn":"BTC_USDT SWAP",
		//                 "positionOpenType":3,
		//                 "baseCoin":"BTC",
		//                 "quoteCoin":"USDT",
		//                 "settleCoin":"USDT",
		//                 "contractSize":0.0001,
		//                 "minLeverage":1,
		//                 "maxLeverage":125,
		//                 "priceScale":2, // seems useless atm, as it's just how UI shows the price, i.e. 29583.50 for BTC/USDT:USDT, while price ticksize is 0.5
		//                 "volScale":0, // probably: contract amount precision
		//                 "amountScale":4, // probably: quote currency precision
		//                 "priceUnit":0.5, // price tick size
		//                 "volUnit":1, // probably: contract tick size
		//                 "minVol":1,
		//                 "maxVol":1000000,
		//                 "bidLimitPriceRate":0.1,
		//                 "askLimitPriceRate":0.1,
		//                 "takerFeeRate":0.0006,
		//                 "makerFeeRate":0.0002,
		//                 "maintenanceMarginRate":0.004,
		//                 "initialMarginRate":0.008,
		//                 "riskBaseVol":10000,
		//                 "riskIncrVol":200000,
		//                 "riskIncrMmr":0.004,
		//                 "riskIncrImr":0.004,
		//                 "riskLevelLimit":5,
		//                 "priceCoefficientVariation":0.1,
		//                 "indexOrigin":["BINANCE","GATEIO","HUOBI","MXC"],
		//                 "state":0, // 0 enabled, 1 delivery, 2 completed, 3 offline, 4 pause
		//                 "isNew":false,
		//                 "isHot":true,
		//                 "isHidden":false
		//             },
		//         ]
		//     }
		//
		var data interface{} = this.SafeValue(response, "data", []interface{}{})
		var result interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
			var market interface{} = GetValue(data, i)
			var id interface{} = this.SafeString(market, "symbol")
			var baseId interface{} = this.SafeString(market, "baseCoin")
			var quoteId interface{} = this.SafeString(market, "quoteCoin")
			var settleId interface{} = this.SafeString(market, "settleCoin")
			var base interface{} = this.SafeCurrencyCode(baseId)
			var quote interface{} = this.SafeCurrencyCode(quoteId)
			var settle interface{} = this.SafeCurrencyCode(settleId)
			var state interface{} = this.SafeString(market, "state")
			var isLinear interface{} = IsEqual(quote, settle)
			AppendToArray(&result, map[string]interface{}{
				"id":             id,
				"symbol":         Add(Add(Add(Add(base, "/"), quote), ":"), settle),
				"base":           base,
				"quote":          quote,
				"settle":         settle,
				"baseId":         baseId,
				"quoteId":        quoteId,
				"settleId":       settleId,
				"type":           "swap",
				"spot":           false,
				"margin":         false,
				"swap":           true,
				"future":         false,
				"option":         false,
				"active":         (IsEqual(state, "0")),
				"contract":       true,
				"linear":         isLinear,
				"inverse":        !IsTrue(isLinear),
				"taker":          this.SafeNumber(market, "takerFeeRate"),
				"maker":          this.SafeNumber(market, "makerFeeRate"),
				"contractSize":   this.SafeNumber(market, "contractSize"),
				"expiry":         nil,
				"expiryDatetime": nil,
				"strike":         nil,
				"optionType":     nil,
				"precision": map[string]interface{}{
					"amount": this.SafeNumber(market, "volUnit"),
					"price":  this.SafeNumber(market, "priceUnit"),
				},
				"limits": map[string]interface{}{
					"leverage": map[string]interface{}{
						"min": this.SafeNumber(market, "minLeverage"),
						"max": this.SafeNumber(market, "maxLeverage"),
					},
					"amount": map[string]interface{}{
						"min": this.SafeNumber(market, "minVol"),
						"max": this.SafeNumber(market, "maxVol"),
					},
					"price": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
					"cost": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
				},
				"created": nil,
				"info":    market,
			})
		}

		ch <- result
		return nil

	}()
	return ch
}

/**
 * @method
 * @name mexc#fetchOrderBook
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#order-book
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-the-contract-s-depth-information
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func (this *mexc) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		limit := GetArg(optionalArgs, 0, nil)
		_ = limit
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes14368 := (<-this.LoadMarkets())
		PanicOnError(retRes14368)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}
		var orderbook interface{} = nil
		if IsTrue(GetValue(market, "spot")) {

			response := (<-this.SpotPublicGetDepth(this.Extend(request, params)))
			PanicOnError(response)
			//
			//     {
			//         "lastUpdateId": "744267132",
			//         "bids": [
			//             ["40838.50","0.387864"],
			//             ["40837.95","0.008400"],
			//         ],
			//         "asks": [
			//             ["40838.61","6.544908"],
			//             ["40838.88","0.498000"],
			//         ]
			//     }
			//
			var spotTimestamp interface{} = this.SafeInteger(response, "timestamp")
			orderbook = this.ParseOrderBook(response, symbol, spotTimestamp)
			AddElementToObject(orderbook, "nonce", this.SafeInteger(response, "lastUpdateId"))
		} else if IsTrue(GetValue(market, "swap")) {

			response := (<-this.ContractPublicGetDepthSymbol(this.Extend(request, params)))
			PanicOnError(response)
			//
			//     {
			//         "success":true,
			//         "code":0,
			//         "data":{
			//             "asks":[
			//                 [3445.72,48379,1],
			//                 [3445.75,34994,1],
			//             ],
			//             "bids":[
			//                 [3445.55,44081,1],
			//                 [3445.51,24857,1],
			//             ],
			//             "version":2827730444,
			//             "timestamp":1634117846232
			//         }
			//     }
			//
			var data interface{} = this.SafeValue(response, "data")
			var timestamp interface{} = this.SafeInteger(data, "timestamp")
			orderbook = this.ParseOrderBook(data, symbol, timestamp)
			AddElementToObject(orderbook, "nonce", this.SafeInteger(data, "version"))
		}

		ch <- orderbook
		return nil

	}()
	return ch
}
func (this *mexc) ParseBidAsk(bidask interface{}, optionalArgs ...interface{}) interface{} {
	priceKey := GetArg(optionalArgs, 0, 0)
	_ = priceKey
	amountKey := GetArg(optionalArgs, 1, 1)
	_ = amountKey
	countOrIdKey := GetArg(optionalArgs, 2, 2)
	_ = countOrIdKey
	var countKey interface{} = 2
	var price interface{} = this.SafeNumber(bidask, priceKey)
	var amount interface{} = this.SafeNumber(bidask, amountKey)
	var count interface{} = this.SafeNumber(bidask, countKey)
	if IsTrue(!IsEqual(count, nil)) {
		return []interface{}{price, amount, count}
	}
	return []interface{}{price, amount}
}

/**
 * @method
 * @name mexc#fetchTrades
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#recent-trades-list
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#compressed-aggregate-trades-list
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-contract-transaction-data
 * @description get the list of most recent trades for a particular symbol
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] *spot only* *since must be defined* the latest time in ms to fetch entries for
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func (this *mexc) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		since := GetArg(optionalArgs, 0, nil)
		_ = since
		limit := GetArg(optionalArgs, 1, nil)
		_ = limit
		params := GetArg(optionalArgs, 2, map[string]interface{}{})
		_ = params

		retRes15178 := (<-this.LoadMarkets())
		PanicOnError(retRes15178)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}
		var trades interface{} = nil
		if IsTrue(GetValue(market, "spot")) {
			var until interface{} = this.SafeIntegerN(params, []interface{}{"endTime", "until"})
			if IsTrue(!IsEqual(since, nil)) {
				AddElementToObject(request, "startTime", since)
				if IsTrue(IsEqual(until, nil)) {
					panic(ArgumentsRequired(Add(this.Id, " fetchTrades() requires an until parameter when since is provided")))
				}
			}
			if IsTrue(!IsEqual(until, nil)) {
				if IsTrue(IsEqual(since, nil)) {
					panic(ArgumentsRequired(Add(this.Id, " fetchTrades() requires a since parameter when until is provided")))
				}
				AddElementToObject(request, "endTime", until)
			}
			var method interface{} = this.SafeString(this.Options, "fetchTradesMethod", "spotPublicGetAggTrades")
			method = this.SafeString(params, "method", method) // AggTrades, HistoricalTrades, Trades
			params = this.Omit(params, []interface{}{"method"})
			if IsTrue(IsEqual(method, "spotPublicGetAggTrades")) {

				trades = (<-this.SpotPublicGetAggTrades(this.Extend(request, params)))
				PanicOnError(trades)
			} else if IsTrue(IsEqual(method, "spotPublicGetHistoricalTrades")) {

				trades = (<-this.SpotPublicGetHistoricalTrades(this.Extend(request, params)))
				PanicOnError(trades)
			} else if IsTrue(IsEqual(method, "spotPublicGetTrades")) {

				trades = (<-this.SpotPublicGetTrades(this.Extend(request, params)))
				PanicOnError(trades)
			} else {
				panic(NotSupported(Add(this.Id, " fetchTrades() not support this method")))
			}
		} else if IsTrue(GetValue(market, "swap")) {

			response := (<-this.ContractPublicGetDealsSymbol(this.Extend(request, params)))
			PanicOnError(response)
			//
			//     {
			//         "success": true,
			//         "code": 0,
			//         "data": [
			//             {
			//                 "p": 31199,
			//                 "v": 18,
			//                 "T": 1,
			//                 "O": 3,
			//                 "M": 2,
			//                 "t": 1609831235985
			//             },
			//         ]
			//     }
			//
			trades = this.SafeValue(response, "data")
		}

		ch <- this.ParseTrades(trades, market, since, limit)
		return nil

	}()
	return ch
}
func (this *mexc) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{} {
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var id interface{} = nil
	var timestamp interface{} = nil
	var orderId interface{} = nil
	var symbol interface{} = nil
	var fee interface{} = nil
	var typeVar interface{} = nil
	var side interface{} = nil
	var takerOrMaker interface{} = nil
	var priceString interface{} = nil
	var amountString interface{} = nil
	var costString interface{} = nil
	// if swap
	if IsTrue(InOp(trade, "v")) {
		//
		// swap: fetchTrades
		//
		//     {
		//         "p": 31199,
		//         "v": 18,
		//         "T": 1,
		//         "O": 3,
		//         "M": 2,
		//         "t": 1609831235985
		//     }
		//
		timestamp = this.SafeInteger(trade, "t")
		market = this.SafeMarket(nil, market)
		symbol = GetValue(market, "symbol")
		priceString = this.SafeString(trade, "p")
		amountString = this.SafeString(trade, "v")
		side = this.ParseOrderSide(this.SafeString(trade, "T"))
		takerOrMaker = "taker"
	} else {
		//
		// spot: fetchTrades (for aggTrades)
		//
		//         {
		//             "a": null,
		//             "f": null,
		//             "l": null,
		//             "p": "40679",
		//             "q": "0.001309",
		//             "T": 1647551328000,
		//             "m": true,
		//             "M": true
		//         }
		//
		// spot: fetchMyTrades, fetchOrderTrades
		//
		//         {
		//             "symbol": "BTCUSDT",
		//             "id": "133948532984922113",
		//             "orderId": "133948532531949568",
		//             "orderListId": "-1",
		//             "price": "41995.51",
		//             "qty": "0.0002",
		//             "quoteQty": "8.399102",
		//             "commission": "0.016798204",
		//             "commissionAsset": "USDT",
		//             "time": "1647718055000",
		//             "isBuyer": true,
		//             "isMaker": false,
		//             "isBestMatch": true
		//         }
		//
		// swap: fetchMyTrades, fetchOrderTrades
		//
		//         {
		//             "id": "299444585",
		//             "symbol": "STEPN_USDT",
		//             "side": "1",
		//             "vol": "1",
		//             "price": "2.45455",
		//             "feeCurrency": "USDT",
		//             "fee": "0.00147273",
		//             "timestamp": "1648924557000",
		//             "profit": "0",
		//             "category": "1",
		//             "orderId": "265307163526610432",
		//             "positionMode": "1",
		//             "taker": true
		//         }
		//
		var marketId interface{} = this.SafeString(trade, "symbol")
		market = this.SafeMarket(marketId, market)
		symbol = GetValue(market, "symbol")
		id = this.SafeString2(trade, "id", "a")
		priceString = this.SafeString2(trade, "price", "p")
		orderId = this.SafeString(trade, "orderId")
		// if swap
		if IsTrue(InOp(trade, "positionMode")) {
			timestamp = this.SafeInteger(trade, "timestamp")
			amountString = this.SafeString(trade, "vol")
			side = this.ParseOrderSide(this.SafeString(trade, "side"))
			fee = map[string]interface{}{
				"cost":     this.SafeString(trade, "fee"),
				"currency": this.SafeCurrencyCode(this.SafeString(trade, "feeCurrency")),
			}
			takerOrMaker = Ternary(IsTrue(this.SafeValue(trade, "taker")), "taker", "maker")
		} else {
			timestamp = this.SafeInteger2(trade, "time", "T")
			amountString = this.SafeString2(trade, "qty", "q")
			costString = this.SafeString(trade, "quoteQty")
			var isBuyer interface{} = this.SafeValue(trade, "isBuyer")
			var isMaker interface{} = this.SafeValue(trade, "isMaker")
			var buyerMaker interface{} = this.SafeValue2(trade, "isBuyerMaker", "m")
			if IsTrue(!IsEqual(isMaker, nil)) {
				takerOrMaker = Ternary(IsTrue(isMaker), "maker", "taker")
			}
			if IsTrue(!IsEqual(isBuyer, nil)) {
				side = Ternary(IsTrue(isBuyer), "buy", "sell")
			}
			if IsTrue(!IsEqual(buyerMaker, nil)) {
				side = Ternary(IsTrue(buyerMaker), "sell", "buy")
				takerOrMaker = "taker"
			}
			var feeAsset interface{} = this.SafeString(trade, "commissionAsset")
			if IsTrue(!IsEqual(feeAsset, nil)) {
				fee = map[string]interface{}{
					"cost":     this.SafeString(trade, "commission"),
					"currency": this.SafeCurrencyCode(feeAsset),
				}
			}
		}
	}
	if IsTrue(IsTrue(IsEqual(id, nil)) && IsTrue(this.SafeBool(this.Options, "useCcxtTradeId", true))) {
		id = this.CreateCcxtTradeId(timestamp, side, amountString, priceString, takerOrMaker)
	}
	return this.SafeTrade(map[string]interface{}{
		"id":           id,
		"order":        orderId,
		"timestamp":    timestamp,
		"datetime":     this.Iso8601(timestamp),
		"symbol":       symbol,
		"type":         typeVar,
		"side":         side,
		"takerOrMaker": takerOrMaker,
		"price":        priceString,
		"amount":       amountString,
		"cost":         costString,
		"fee":          fee,
		"info":         trade,
	}, market)
}

/**
 * @method
 * @name mexc#fetchOHLCV
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#kline-candlestick-data
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#k-line-data
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest candle to fetch
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func (this *mexc) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		timeframe := GetArg(optionalArgs, 0, "1m")
		_ = timeframe
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes17678 := (<-this.LoadMarkets())
		PanicOnError(retRes17678)
		var market interface{} = this.Market(symbol)
		var maxLimit interface{} = Ternary(IsTrue((GetValue(market, "spot"))), 1000, 2000)
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchOHLCV", "paginate", false)
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {

			retRes177319 := (<-this.FetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, params, maxLimit))
			PanicOnError(retRes177319)
			ch <- retRes177319
			return nil
		}
		var options interface{} = this.SafeValue(this.Options, "timeframes", map[string]interface{}{})
		var timeframes interface{} = this.SafeValue(options, GetValue(market, "type"), map[string]interface{}{})
		var timeframeValue interface{} = this.SafeString(timeframes, timeframe)
		var duration interface{} = Multiply(this.ParseTimeframe(timeframe), 1000)
		var request interface{} = map[string]interface{}{
			"symbol":   GetValue(market, "id"),
			"interval": timeframeValue,
		}
		var candles interface{} = nil
		if IsTrue(GetValue(market, "spot")) {
			var until interface{} = this.SafeIntegerN(params, []interface{}{"until", "endTime"})
			if IsTrue(!IsEqual(since, nil)) {
				AddElementToObject(request, "startTime", since)
				if IsTrue(IsEqual(until, nil)) {
					// we have to calculate it assuming we can get at most 2000 entries per request
					var end interface{} = this.Sum(since, Multiply(maxLimit, duration))
					var now interface{} = this.Milliseconds()
					AddElementToObject(request, "endTime", mathMin(end, now))
				}
			}
			if IsTrue(!IsEqual(limit, nil)) {
				AddElementToObject(request, "limit", limit)
			}
			if IsTrue(!IsEqual(until, nil)) {
				params = this.Omit(params, []interface{}{"until"})
				AddElementToObject(request, "endTime", until)
			}

			response := (<-this.SpotPublicGetKlines(this.Extend(request, params)))
			PanicOnError(response)
			//
			//     [
			//       [
			//         1640804880000,
			//         "47482.36",
			//         "47482.36",
			//         "47416.57",
			//         "47436.1",
			//         "3.550717",
			//         1640804940000,
			//         "168387.3"
			//       ],
			//     ]
			//
			candles = response
		} else if IsTrue(GetValue(market, "swap")) {
			var until interface{} = this.SafeIntegerProductN(params, []interface{}{"until", "endTime"}, 0.001)
			if IsTrue(!IsEqual(since, nil)) {
				AddElementToObject(request, "start", this.ParseToInt(Divide(since, 1000)))
			}
			if IsTrue(!IsEqual(until, nil)) {
				params = this.Omit(params, []interface{}{"until"})
				AddElementToObject(request, "end", until)
			}
			var priceType interface{} = this.SafeString(params, "price", "default")
			params = this.Omit(params, "price")
			var response interface{} = nil
			if IsTrue(IsEqual(priceType, "default")) {

				response = (<-this.ContractPublicGetKlineSymbol(this.Extend(request, params)))
				PanicOnError(response)
			} else if IsTrue(IsEqual(priceType, "index")) {

				response = (<-this.ContractPublicGetKlineIndexPriceSymbol(this.Extend(request, params)))
				PanicOnError(response)
			} else if IsTrue(IsEqual(priceType, "mark")) {

				response = (<-this.ContractPublicGetKlineFairPriceSymbol(this.Extend(request, params)))
				PanicOnError(response)
			} else {
				panic(NotSupported(Add(this.Id, " fetchOHLCV() not support this price type, [default, index, mark]")))
			}
			//
			//     {
			//         "success":true,
			//         "code":0,
			//         "data":{
			//             "time":[1634052300,1634052360,1634052420],
			//             "open":[3492.2,3491.3,3495.65],
			//             "close":[3491.3,3495.65,3495.2],
			//             "high":[3495.85,3496.55,3499.4],
			//             "low":[3491.15,3490.9,3494.2],
			//             "vol":[1740.0,351.0,314.0],
			//             "amount":[60793.623,12260.4885,10983.1375],
			//         }
			//     }
			//
			var data interface{} = this.SafeValue(response, "data")
			candles = this.ConvertTradingViewToOHLCV(data, "time", "open", "high", "low", "close", "vol")
		}

		ch <- this.ParseOHLCVs(candles, market, timeframe, since, limit)
		return nil

	}()
	return ch
}
func (this *mexc) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{} {
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	return []interface{}{this.SafeInteger(ohlcv, 0), this.SafeNumber(ohlcv, 1), this.SafeNumber(ohlcv, 2), this.SafeNumber(ohlcv, 3), this.SafeNumber(ohlcv, 4), this.SafeNumber(ohlcv, 5)}
}

/**
 * @method
 * @name mexc#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#24hr-ticker-price-change-statistics
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-contract-trend-data
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func (this *mexc) FetchTickers(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes18828 := (<-this.LoadMarkets())
		PanicOnError(retRes18828)
		var request interface{} = map[string]interface{}{}
		var market interface{} = nil
		var isSingularMarket interface{} = false
		if IsTrue(!IsEqual(symbols, nil)) {
			var length interface{} = GetArrayLength(symbols)
			isSingularMarket = IsEqual(length, 1)
			var firstSymbol interface{} = this.SafeString(symbols, 0)
			market = this.Market(firstSymbol)
		}
		marketTypequeryVariable := this.HandleMarketTypeAndParams("fetchTickers", market, params)
		marketType := GetValue(marketTypequeryVariable, 0)
		query := GetValue(marketTypequeryVariable, 1)
		var tickers interface{} = nil
		if IsTrue(isSingularMarket) {
			AddElementToObject(request, "symbol", GetValue(market, "id"))
		}
		if IsTrue(IsEqual(marketType, "spot")) {

			tickers = (<-this.SpotPublicGetTicker24hr(this.Extend(request, query)))
			PanicOnError(tickers)
		} else if IsTrue(IsEqual(marketType, "swap")) {

			response := (<-this.ContractPublicGetTicker(this.Extend(request, query)))
			PanicOnError(response)
			//
			//     {
			//         "success":true,
			//         "code":0,
			//         "data":[
			//             {
			//                 "symbol":"ETH_USDT",
			//                 "lastPrice":3581.3,
			//                 "bid1":3581.25,
			//                 "ask1":3581.5,
			//                 "volume24":4045530,
			//                 "amount24":141331823.5755,
			//                 "holdVol":5832946,
			//                 "lower24Price":3413.4,
			//                 "high24Price":3588.7,
			//                 "riseFallRate":0.0275,
			//                 "riseFallValue":95.95,
			//                 "indexPrice":3580.7852,
			//                 "fairPrice":3581.08,
			//                 "fundingRate":0.000063,
			//                 "maxBidPrice":3938.85,
			//                 "minAskPrice":3222.7,
			//                 "timestamp":1634162885016
			//             },
			//         ]
			//     }
			//
			tickers = this.SafeValue(response, "data", []interface{}{})
		}
		// when it's single symbol request, the returned structure is different (singular object) for both spot & swap, thus we need to wrap inside array
		if IsTrue(isSingularMarket) {
			tickers = []interface{}{tickers}
		}

		ch <- this.ParseTickers(tickers, symbols)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name mexc#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#24hr-ticker-price-change-statistics
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-contract-trend-data
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func (this *mexc) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes19728 := (<-this.LoadMarkets())
		PanicOnError(retRes19728)
		var market interface{} = this.Market(symbol)
		marketTypequeryVariable := this.HandleMarketTypeAndParams("fetchTicker", market, params)
		marketType := GetValue(marketTypequeryVariable, 0)
		query := GetValue(marketTypequeryVariable, 1)
		var ticker interface{} = nil
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		if IsTrue(IsEqual(marketType, "spot")) {

			ticker = (<-this.SpotPublicGetTicker24hr(this.Extend(request, query)))
			PanicOnError(ticker)
		} else if IsTrue(IsEqual(marketType, "swap")) {

			response := (<-this.ContractPublicGetTicker(this.Extend(request, query)))
			PanicOnError(response)
			//
			//     {
			//         "success":true,
			//         "code":0,
			//         "data":{
			//             "symbol":"ETH_USDT",
			//             "lastPrice":3581.3,
			//             "bid1":3581.25,
			//             "ask1":3581.5,
			//             "volume24":4045530,
			//             "amount24":141331823.5755,
			//             "holdVol":5832946,
			//             "lower24Price":3413.4,
			//             "high24Price":3588.7,
			//             "riseFallRate":0.0275,
			//             "riseFallValue":95.95,
			//             "indexPrice":3580.7852,
			//             "fairPrice":3581.08,
			//             "fundingRate":0.000063,
			//             "maxBidPrice":3938.85,
			//             "minAskPrice":3222.7,
			//             "timestamp":1634162885016
			//         }
			//     }
			//
			ticker = this.SafeValue(response, "data", map[string]interface{}{})
		}

		// when it's single symbol request, the returned structure is different (singular object) for both spot & swap, thus we need to wrap inside array
		ch <- this.ParseTicker(ticker, market)
		return nil

	}()
	return ch
}
func (this *mexc) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{} {
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(ticker, "symbol")
	market = this.SafeMarket(marketId, market)
	var timestamp interface{} = nil
	var bid interface{} = nil
	var ask interface{} = nil
	var bidVolume interface{} = nil
	var askVolume interface{} = nil
	var baseVolume interface{} = nil
	var quoteVolume interface{} = nil
	var open interface{} = nil
	var high interface{} = nil
	var low interface{} = nil
	var changePcnt interface{} = nil
	var changeValue interface{} = nil
	var prevClose interface{} = nil
	var isSwap interface{} = this.SafeValue(market, "swap")
	// if swap
	if IsTrue(IsTrue(isSwap) || IsTrue((InOp(ticker, "timestamp")))) {
		//
		//     {
		//         "symbol": "ETH_USDT",
		//         "lastPrice": 3581.3,
		//         "bid1": 3581.25,
		//         "ask1": 3581.5,
		//         "volume24": 4045530,
		//         "amount24": 141331823.5755,
		//         "holdVol": 5832946,
		//         "lower24Price": 3413.4,
		//         "high24Price": 3588.7,
		//         "riseFallRate": 0.0275,
		//         "riseFallValue": 95.95,
		//         "indexPrice": 3580.7852,
		//         "fairPrice": 3581.08,
		//         "fundingRate": 0.000063,
		//         "maxBidPrice": 3938.85,
		//         "minAskPrice": 3222.7,
		//         "timestamp": 1634162885016
		//     }
		//
		timestamp = this.SafeInteger(ticker, "timestamp")
		bid = this.SafeString(ticker, "bid1")
		ask = this.SafeString(ticker, "ask1")
		baseVolume = this.SafeString(ticker, "volume24")
		quoteVolume = this.SafeString(ticker, "amount24")
		high = this.SafeString(ticker, "high24Price")
		low = this.SafeString(ticker, "lower24Price")
		changeValue = this.SafeString(ticker, "riseFallValue")
		changePcnt = this.SafeString(ticker, "riseFallRate")
		changePcnt = Precise.StringMul(changePcnt, "100")
	} else {
		//
		//     {
		//         "symbol": "BTCUSDT",
		//         "priceChange": "184.34",
		//         "priceChangePercent": "0.00400048",
		//         "prevClosePrice": "46079.37",
		//         "lastPrice": "46263.71",
		//         "lastQty": "",
		//         "bidPrice": "46260.38",
		//         "bidQty": "",
		//         "askPrice": "46260.41",
		//         "askQty": "",
		//         "openPrice": "46079.37",
		//         "highPrice": "47550.01",
		//         "lowPrice": "45555.5",
		//         "volume": "1732.461487",
		//         "quoteVolume": null,
		//         "openTime": 1641349500000,
		//         "closeTime": 1641349582808,
		//         "count": null
		//     }
		//
		timestamp = this.SafeInteger(ticker, "closeTime")
		bid = this.SafeString(ticker, "bidPrice")
		ask = this.SafeString(ticker, "askPrice")
		bidVolume = this.SafeString(ticker, "bidQty")
		askVolume = this.SafeString(ticker, "askQty")
		if IsTrue(Precise.StringEq(bidVolume, "0")) {
			bidVolume = nil
		}
		if IsTrue(Precise.StringEq(askVolume, "0")) {
			askVolume = nil
		}
		baseVolume = this.SafeString(ticker, "volume")
		quoteVolume = this.SafeString(ticker, "quoteVolume")
		open = this.SafeString(ticker, "openPrice")
		high = this.SafeString(ticker, "highPrice")
		low = this.SafeString(ticker, "lowPrice")
		prevClose = this.SafeString(ticker, "prevClosePrice")
		changeValue = this.SafeString(ticker, "priceChange")
		changePcnt = this.SafeString(ticker, "priceChangePercent")
		changePcnt = Precise.StringMul(changePcnt, "100")
	}
	return this.SafeTicker(map[string]interface{}{
		"symbol":        GetValue(market, "symbol"),
		"timestamp":     timestamp,
		"datetime":      this.Iso8601(timestamp),
		"open":          open,
		"high":          high,
		"low":           low,
		"close":         this.SafeString(ticker, "lastPrice"),
		"bid":           bid,
		"bidVolume":     bidVolume,
		"ask":           ask,
		"askVolume":     askVolume,
		"vwap":          nil,
		"previousClose": prevClose,
		"change":        changeValue,
		"percentage":    changePcnt,
		"average":       nil,
		"baseVolume":    baseVolume,
		"quoteVolume":   quoteVolume,
		"info":          ticker,
	}, market)
}

/**
 * @method
 * @name mexc#fetchBidsAsks
 * @description fetches the bid and ask price and volume for multiple markets
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#symbol-order-book-ticker
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the bids and asks for, all markets are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func (this *mexc) FetchBidsAsks(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes21638 := (<-this.LoadMarkets())
		PanicOnError(retRes21638)
		var market interface{} = nil
		var isSingularMarket interface{} = false
		if IsTrue(!IsEqual(symbols, nil)) {
			var length interface{} = GetArrayLength(symbols)
			isSingularMarket = IsEqual(length, 1)
			market = this.Market(GetValue(symbols, 0))
		}
		marketTypequeryVariable := this.HandleMarketTypeAndParams("fetchBidsAsks", market, params)
		marketType := GetValue(marketTypequeryVariable, 0)
		query := GetValue(marketTypequeryVariable, 1)
		var tickers interface{} = nil
		if IsTrue(IsEqual(marketType, "spot")) {

			tickers = (<-this.SpotPublicGetTickerBookTicker(query))
			PanicOnError(tickers)
		} else if IsTrue(IsEqual(marketType, "swap")) {
			panic(NotSupported(Add(Add(Add(this.Id, " fetchBidsAsks() is not available for "), marketType), " markets")))
		}
		// when it's single symbol request, the returned structure is different (singular object) for both spot & swap, thus we need to wrap inside array
		if IsTrue(isSingularMarket) {
			tickers = []interface{}{tickers}
		}

		ch <- this.ParseTickers(tickers, symbols)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name mexc#createMarketBuyOrderWithCost
 * @description create a market buy order by providing the symbol and cost
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#new-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {float} cost how much you want to trade in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *mexc) CreateMarketBuyOrderWithCost(symbol interface{}, cost interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes22078 := (<-this.LoadMarkets())
		PanicOnError(retRes22078)
		var market interface{} = this.Market(symbol)
		if !IsTrue(GetValue(market, "spot")) {
			panic(NotSupported(Add(this.Id, " createMarketBuyOrderWithCost() supports spot orders only")))
		}
		var req interface{} = map[string]interface{}{
			"cost": cost,
		}

		retRes221515 := (<-this.CreateOrder(symbol, "market", "buy", 0, nil, this.Extend(req, params)))
		PanicOnError(retRes221515)
		ch <- retRes221515
		return nil

	}()
	return ch
}

/**
 * @method
 * @name mexc#createMarketSellOrderWithCost
 * @description create a market sell order by providing the symbol and cost
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#new-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {float} cost how much you want to trade in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *mexc) CreateMarketSellOrderWithCost(symbol interface{}, cost interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes22298 := (<-this.LoadMarkets())
		PanicOnError(retRes22298)
		var market interface{} = this.Market(symbol)
		if !IsTrue(GetValue(market, "spot")) {
			panic(NotSupported(Add(this.Id, " createMarketBuyOrderWithCost() supports spot orders only")))
		}
		var req interface{} = map[string]interface{}{
			"cost": cost,
		}

		retRes223715 := (<-this.CreateOrder(symbol, "market", "sell", 0, nil, this.Extend(req, params)))
		PanicOnError(retRes223715)
		ch <- retRes223715
		return nil

	}()
	return ch
}

/**
 * @method
 * @name mexc#createOrder
 * @description create a trade order
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#new-order
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#order-under-maintenance
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#trigger-order-under-maintenance
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] only 'isolated' is supported for spot-margin trading
 * @param {float} [params.triggerPrice] The price at which a trigger order is triggered at
 * @param {bool} [params.postOnly] if true, the order will only be posted if it will be a maker order
 * @param {bool} [params.reduceOnly] *contract only* indicates if this order is to reduce the size of a position
 * @param {bool} [params.hedged] *swap only* true for hedged mode, false for one way mode, default is false
 * @param {string} [params.timeInForce] 'IOC' or 'FOK', default is 'GTC'
 * EXCHANGE SPECIFIC PARAMETERS
 * @param {int} [params.leverage] *contract only* leverage is necessary on isolated margin
 * @param {long} [params.positionId] *contract only* it is recommended to fill in this parameter when closing a position
 * @param {string} [params.externalOid] *contract only* external order ID
 * @param {int} [params.positionMode] *contract only*  1:hedge, 2:one-way, default: the user's current config
 * @param {boolean} [params.test] *spot only* whether to use the test endpoint or not, default is false
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *mexc) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		price := GetArg(optionalArgs, 0, nil)
		_ = price
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes22688 := (<-this.LoadMarkets())
		PanicOnError(retRes22688)
		var market interface{} = this.Market(symbol)
		marginModequeryVariable := this.HandleMarginModeAndParams("createOrder", params)
		marginMode := GetValue(marginModequeryVariable, 0)
		query := GetValue(marginModequeryVariable, 1)
		if IsTrue(GetValue(market, "spot")) {

			retRes227219 := (<-this.CreateSpotOrder(market, typeVar, side, amount, price, marginMode, query))
			PanicOnError(retRes227219)
			ch <- retRes227219
			return nil
		} else {

			retRes227419 := (<-this.CreateSwapOrder(market, typeVar, side, amount, price, marginMode, query))
			PanicOnError(retRes227419)
			ch <- retRes227419
			return nil
		}

	}()
	return ch
}
func (this *mexc) CreateSpotOrderRequest(market interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{} {
	price := GetArg(optionalArgs, 0, nil)
	_ = price
	marginMode := GetArg(optionalArgs, 1, nil)
	_ = marginMode
	params := GetArg(optionalArgs, 2, map[string]interface{}{})
	_ = params
	var symbol interface{} = GetValue(market, "symbol")
	var orderSide interface{} = ToUpper(side)
	var request interface{} = map[string]interface{}{
		"symbol": GetValue(market, "id"),
		"side":   orderSide,
		"type":   ToUpper(typeVar),
	}
	if IsTrue(IsEqual(typeVar, "market")) {
		var cost interface{} = this.SafeNumber2(params, "cost", "quoteOrderQty")
		params = this.Omit(params, "cost")
		if IsTrue(!IsEqual(cost, nil)) {
			amount = cost
			AddElementToObject(request, "quoteOrderQty", this.CostToPrecision(symbol, amount))
		} else {
			if IsTrue(IsEqual(price, nil)) {
				AddElementToObject(request, "quantity", this.AmountToPrecision(symbol, amount))
			} else {
				var amountString interface{} = this.NumberToString(amount)
				var priceString interface{} = this.NumberToString(price)
				var quoteAmount interface{} = Precise.StringMul(amountString, priceString)
				amount = quoteAmount
				AddElementToObject(request, "quoteOrderQty", this.CostToPrecision(symbol, amount))
			}
		}
	} else {
		AddElementToObject(request, "quantity", this.AmountToPrecision(symbol, amount))
	}
	if IsTrue(!IsEqual(price, nil)) {
		AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
	}
	var clientOrderId interface{} = this.SafeString(params, "clientOrderId")
	if IsTrue(!IsEqual(clientOrderId, nil)) {
		AddElementToObject(request, "newClientOrderId", clientOrderId)
		params = this.Omit(params, []interface{}{"type", "clientOrderId"})
	}
	if IsTrue(!IsEqual(marginMode, nil)) {
		if IsTrue(!IsEqual(marginMode, "isolated")) {
			panic(BadRequest(Add(Add(Add(this.Id, " createOrder() does not support marginMode "), marginMode), " for spot-margin trading")))
		}
	}
	var postOnly interface{} = nil
	postOnlyparamsVariable := this.HandlePostOnly(IsEqual(typeVar, "market"), IsEqual(typeVar, "LIMIT_MAKER"), params)
	postOnly = GetValue(postOnlyparamsVariable, 0)
	params = GetValue(postOnlyparamsVariable, 1)
	if IsTrue(postOnly) {
		AddElementToObject(request, "type", "LIMIT_MAKER")
	}
	var tif interface{} = this.SafeString(params, "timeInForce")
	if IsTrue(!IsEqual(tif, nil)) {
		params = this.Omit(params, "timeInForce")
		if IsTrue(IsEqual(tif, "IOC")) {
			AddElementToObject(request, "type", "IMMEDIATE_OR_CANCEL")
		} else if IsTrue(IsEqual(tif, "FOK")) {
			AddElementToObject(request, "type", "FILL_OR_KILL")
		}
	}
	return this.Extend(request, params)
}

/**
 * @ignore
 * @method
 * @name mexc#createSpotOrder
 * @description create a trade order
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#new-order
 * @param {string} market unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {string} [marginMode] only 'isolated' is supported for spot-margin trading
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {bool} [params.postOnly] if true, the order will only be posted if it will be a maker order
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *mexc) CreateSpotOrder(market interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		price := GetArg(optionalArgs, 0, nil)
		_ = price
		marginMode := GetArg(optionalArgs, 1, nil)
		_ = marginMode
		params := GetArg(optionalArgs, 2, map[string]interface{}{})
		_ = params

		retRes23538 := (<-this.LoadMarkets())
		PanicOnError(retRes23538)
		var test interface{} = this.SafeBool(params, "test", false)
		params = this.Omit(params, "test")
		var request interface{} = this.CreateSpotOrderRequest(market, typeVar, side, amount, price, marginMode, params)
		var response interface{} = nil
		if IsTrue(test) {

			response = (<-this.SpotPrivatePostOrderTest(request))
			PanicOnError(response)
		} else {

			response = (<-this.SpotPrivatePostOrder(request))
			PanicOnError(response)
		}
		//
		// spot
		//
		//     {
		//         "symbol": "BTCUSDT",
		//         "orderId": "123738410679123456",
		//         "orderListId": -1
		//     }
		//
		// margin
		//
		//     {
		//         "symbol": "BTCUSDT",
		//         "orderId": "762634301354414080",
		//         "clientOrderId": null,
		//         "isIsolated": true,
		//         "transactTime": 1661992652132
		//     }
		//
		var order interface{} = this.ParseOrder(response, market)
		AddElementToObject(order, "side", side)
		AddElementToObject(order, "type", typeVar)
		if IsTrue(IsEqual(this.SafeString(order, "price"), nil)) {
			AddElementToObject(order, "price", price)
		}
		if IsTrue(IsEqual(this.SafeString(order, "amount"), nil)) {
			AddElementToObject(order, "amount", amount)
		}

		ch <- order
		return nil

	}()
	return ch
}

/**
 * @ignore
 * @method
 * @name mexc#createSwapOrder
 * @description create a trade order
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#new-order
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#order-under-maintenance
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#trigger-order-under-maintenance
 * @param {string} market unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {string} [marginMode] only 'isolated' is supported for spot-margin trading
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {float} [params.triggerPrice] The price at which a trigger order is triggered at
 * @param {bool} [params.postOnly] if true, the order will only be posted if it will be a maker order
 * @param {bool} [params.reduceOnly] indicates if this order is to reduce the size of a position
 * @param {bool} [params.hedged] *swap only* true for hedged mode, false for one way mode, default is false
 *
 * EXCHANGE SPECIFIC PARAMETERS
 * @param {int} [params.leverage] leverage is necessary on isolated margin
 * @param {long} [params.positionId] it is recommended to fill in this parameter when closing a position
 * @param {string} [params.externalOid] external order ID
 * @param {int} [params.positionMode] 1:hedge, 2:one-way, default: the user's current config
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *mexc) CreateSwapOrder(market interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		price := GetArg(optionalArgs, 0, nil)
		_ = price
		marginMode := GetArg(optionalArgs, 1, nil)
		_ = marginMode
		params := GetArg(optionalArgs, 2, map[string]interface{}{})
		_ = params

		retRes24228 := (<-this.LoadMarkets())
		PanicOnError(retRes24228)
		var symbol interface{} = GetValue(market, "symbol")
		var unavailableContracts interface{} = this.SafeValue(this.Options, "unavailableContracts", map[string]interface{}{})
		var isContractUnavaiable interface{} = this.SafeBool(unavailableContracts, symbol, false)
		if IsTrue(isContractUnavaiable) {
			panic(NotSupported(Add(Add(this.Id, " createSwapOrder() does not support yet this symbol:"), symbol)))
		}
		var openType interface{} = nil
		if IsTrue(!IsEqual(marginMode, nil)) {
			if IsTrue(IsEqual(marginMode, "cross")) {
				openType = 2
			} else if IsTrue(IsEqual(marginMode, "isolated")) {
				openType = 1
			} else {
				panic(ArgumentsRequired(Add(this.Id, " createSwapOrder() marginMode parameter should be either \"cross\" or \"isolated\"")))
			}
		} else {
			openType = this.SafeInteger(params, "openType", 2) // defaulting to cross margin
		}
		if IsTrue(IsTrue(IsTrue(IsTrue(IsTrue(IsTrue(IsTrue(IsTrue((!IsEqual(typeVar, "limit"))) && IsTrue((!IsEqual(typeVar, "market")))) && IsTrue((!IsEqual(typeVar, 1)))) && IsTrue((!IsEqual(typeVar, 2)))) && IsTrue((!IsEqual(typeVar, 3)))) && IsTrue((!IsEqual(typeVar, 4)))) && IsTrue((!IsEqual(typeVar, 5)))) && IsTrue((!IsEqual(typeVar, 6)))) {
			panic(InvalidOrder(Add(this.Id, " createSwapOrder() order type must either limit, market, or 1 for limit orders, 2 for post-only orders, 3 for IOC orders, 4 for FOK orders, 5 for market orders or 6 to convert market price to current price")))
		}
		var postOnly interface{} = nil
		postOnlyparamsVariable := this.HandlePostOnly(IsEqual(typeVar, "market"), IsEqual(typeVar, 2), params)
		postOnly = GetValue(postOnlyparamsVariable, 0)
		params = GetValue(postOnlyparamsVariable, 1)
		if IsTrue(postOnly) {
			typeVar = 2
		} else if IsTrue(IsEqual(typeVar, "limit")) {
			typeVar = 1
		} else if IsTrue(IsEqual(typeVar, "market")) {
			typeVar = 6
		}
		var request interface{} = map[string]interface{}{
			"symbol":   GetValue(market, "id"),
			"vol":      ParseFloat(this.AmountToPrecision(symbol, amount)),
			"type":     typeVar,
			"openType": openType,
		}
		if IsTrue(IsTrue(IsTrue((!IsEqual(typeVar, 5))) && IsTrue((!IsEqual(typeVar, 6)))) && IsTrue((!IsEqual(typeVar, "market")))) {
			AddElementToObject(request, "price", ParseFloat(this.PriceToPrecision(symbol, price)))
		}
		if IsTrue(IsEqual(openType, 1)) {
			var leverage interface{} = this.SafeInteger(params, "leverage")
			if IsTrue(IsEqual(leverage, nil)) {
				panic(ArgumentsRequired(Add(this.Id, " createSwapOrder() requires a leverage parameter for isolated margin orders")))
			}
		}
		var reduceOnly interface{} = this.SafeBool(params, "reduceOnly", false)
		var hedged interface{} = this.SafeBool(params, "hedged", false)
		var sideInteger interface{} = nil
		if IsTrue(hedged) {
			if IsTrue(reduceOnly) {
				params = this.Omit(params, "reduceOnly") // hedged mode does not accept this parameter
				side = Ternary(IsTrue((IsEqual(side, "buy"))), "sell", "buy")
			}
			sideInteger = Ternary(IsTrue((IsEqual(side, "buy"))), 1, 3)
			AddElementToObject(request, "positionMode", 1)
		} else {
			if IsTrue(reduceOnly) {
				sideInteger = Ternary(IsTrue((IsEqual(side, "buy"))), 2, 4)
			} else {
				sideInteger = Ternary(IsTrue((IsEqual(side, "buy"))), 1, 3)
			}
		}
		AddElementToObject(request, "side", sideInteger)
		var clientOrderId interface{} = this.SafeString2(params, "clientOrderId", "externalOid")
		if IsTrue(!IsEqual(clientOrderId, nil)) {
			AddElementToObject(request, "externalOid", clientOrderId)
		}
		var triggerPrice interface{} = this.SafeNumber2(params, "triggerPrice", "stopPrice")
		params = this.Omit(params, []interface{}{"clientOrderId", "externalOid", "postOnly", "stopPrice", "triggerPrice", "hedged"})
		var response interface{} = nil
		if IsTrue(triggerPrice) {
			AddElementToObject(request, "triggerPrice", this.PriceToPrecision(symbol, triggerPrice))
			AddElementToObject(request, "triggerType", this.SafeInteger(params, "triggerType", 1))
			AddElementToObject(request, "executeCycle", this.SafeInteger(params, "executeCycle", 1))
			AddElementToObject(request, "trend", this.SafeInteger(params, "trend", 1))
			AddElementToObject(request, "orderType", this.SafeInteger(params, "orderType", 1))

			response = (<-this.ContractPrivatePostPlanorderPlace(this.Extend(request, params)))
			PanicOnError(response)
		} else {

			response = (<-this.ContractPrivatePostOrderSubmit(this.Extend(request, params)))
			PanicOnError(response)
		}
		//
		// Swap
		//     {"code":200,"data":"2ff3163e8617443cb9c6fc19d42b1ca4"}
		//
		// Trigger
		//     {"success":true,"code":0,"data":259208506303929856}
		//
		var data interface{} = this.SafeString(response, "data")

		ch <- this.SafeOrder(map[string]interface{}{
			"id": data,
		}, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name mexc#createOrders
 * @description *spot only*  *all orders must have the same symbol* create a list of trade orders
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#batch-orders
 * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
 * @param {object} [params] extra parameters specific to api endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *mexc) CreateOrders(orders interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes25448 := (<-this.LoadMarkets())
		PanicOnError(retRes25448)
		var ordersRequests interface{} = []interface{}{}
		var symbol interface{} = nil
		for i := 0; IsLessThan(i, GetArrayLength(orders)); i++ {
			var rawOrder interface{} = GetValue(orders, i)
			var marketId interface{} = this.SafeString(rawOrder, "symbol")
			var market interface{} = this.Market(marketId)
			if !IsTrue(GetValue(market, "spot")) {
				panic(NotSupported(Add(this.Id, " createOrders() is only supported for spot markets")))
			}
			if IsTrue(IsEqual(symbol, nil)) {
				symbol = marketId
			} else {
				if IsTrue(!IsEqual(symbol, marketId)) {
					panic(BadRequest(Add(this.Id, " createOrders() requires all orders to have the same symbol")))
				}
			}
			var typeVar interface{} = this.SafeString(rawOrder, "type")
			var side interface{} = this.SafeString(rawOrder, "side")
			var amount interface{} = this.SafeValue(rawOrder, "amount")
			var price interface{} = this.SafeValue(rawOrder, "price")
			var orderParams interface{} = this.SafeValue(rawOrder, "params", map[string]interface{}{})
			var marginMode interface{} = nil
			marginModeparamsVariable := this.HandleMarginModeAndParams("createOrder", params)
			marginMode = GetValue(marginModeparamsVariable, 0)
			params = GetValue(marginModeparamsVariable, 1)
			var orderRequest interface{} = this.CreateSpotOrderRequest(market, typeVar, side, amount, price, marginMode, orderParams)
			AppendToArray(&ordersRequests, orderRequest)
		}
		var request interface{} = map[string]interface{}{
			"batchOrders": this.Json(ordersRequests),
		}

		response := (<-this.SpotPrivatePostBatchOrders(request))
		PanicOnError(response)

		//
		// [
		//     {
		//       "symbol": "BTCUSDT",
		//       "orderId": "1196315350023612316",
		//       "newClientOrderId": "hio8279hbdsds",
		//       "orderListId": -1
		//     },
		//     {
		//       "newClientOrderId": "123456",
		//       "msg": "The minimum transaction volume cannot be less than:0.5USDT",
		//       "code": 30002
		//     },
		//     {
		//       "symbol": "BTCUSDT",
		//       "orderId": "1196315350023612318",
		//       "orderListId": -1
		//     }
		// ]
		//
		ch <- this.ParseOrders(response)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name mexc#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#query-order
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#query-the-order-based-on-the-order-number
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] only 'isolated' is supported, for spot-margin trading
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *mexc) FetchOrder(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchOrder() requires a symbol argument")))
		}

		retRes26148 := (<-this.LoadMarkets())
		PanicOnError(retRes26148)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		var data interface{} = nil
		if IsTrue(GetValue(market, "spot")) {
			var clientOrderId interface{} = this.SafeString(params, "clientOrderId")
			if IsTrue(!IsEqual(clientOrderId, nil)) {
				params = this.Omit(params, "clientOrderId")
				AddElementToObject(request, "origClientOrderId", clientOrderId)
			} else {
				AddElementToObject(request, "orderId", id)
			}
			marginModequeryVariable := this.HandleMarginModeAndParams("fetchOrder", params)
			marginMode := GetValue(marginModequeryVariable, 0)
			query := GetValue(marginModequeryVariable, 1)
			if IsTrue(!IsEqual(marginMode, nil)) {
				if IsTrue(!IsEqual(marginMode, "isolated")) {
					panic(BadRequest(Add(Add(Add(this.Id, " fetchOrder() does not support marginMode "), marginMode), " for spot-margin trading")))
				}

				data = (<-this.SpotPrivateGetMarginOrder(this.Extend(request, query)))
				PanicOnError(data)
			} else {

				data = (<-this.SpotPrivateGetOrder(this.Extend(request, query)))
				PanicOnError(data)
			}
		} else if IsTrue(GetValue(market, "swap")) {
			AddElementToObject(request, "order_id", id)

			response := (<-this.ContractPrivateGetOrderGetOrderId(this.Extend(request, params)))
			PanicOnError(response)
			//
			//     {
			//         "success": true,
			//         "code": "0",
			//         "data": {
			//             "orderId": "264995729269765120",
			//             "symbol": "STEPN_USDT",
			//             "positionId": "0",
			//             "price": "2.2",
			//             "vol": "15",
			//             "leverage": "20",
			//             "side": "1",
			//             "category": "1",
			//             "orderType": "1",
			//             "dealAvgPrice": "0",
			//             "dealVol": "0",
			//             "orderMargin": "2.2528",
			//             "takerFee": "0",
			//             "makerFee": "0",
			//             "profit": "0",
			//             "feeCurrency": "USDT",
			//             "openType": "1",
			//             "state": "2",
			//             "externalOid": "_m_0e9520c256744d64b942985189026d20",
			//             "errorCode": "0",
			//             "usedMargin": "0",
			//             "createTime": "1648850305236",
			//             "updateTime": "1648850305245",
			//             "positionMode": "1"
			//         }
			//     }
			//
			data = this.SafeValue(response, "data")
		}

		ch <- this.ParseOrder(data, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name mexc#fetchOrders
 * @description fetches information on multiple orders made by the user
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#all-orders
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-all-of-the-user-39-s-historical-orders
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#gets-the-trigger-order-list
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch orders for
 * @param {string} [params.marginMode] only 'isolated' is supported, for spot-margin trading
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *mexc) FetchOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes27378 := (<-this.LoadMarkets())
		PanicOnError(retRes27378)
		var request interface{} = map[string]interface{}{}
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			AddElementToObject(request, "symbol", GetValue(market, "id"))
		}
		var until interface{} = this.SafeInteger(params, "until")
		params = this.Omit(params, "until")
		marketTypequeryVariable := this.HandleMarketTypeAndParams("fetchOrders", market, params)
		marketType := GetValue(marketTypequeryVariable, 0)
		query := GetValue(marketTypequeryVariable, 1)
		if IsTrue(IsEqual(marketType, "spot")) {
			if IsTrue(IsEqual(symbol, nil)) {
				panic(ArgumentsRequired(Add(this.Id, " fetchOrders() requires a symbol argument for spot market")))
			}
			marginModequeryInnerVariable := this.HandleMarginModeAndParams("fetchOrders", params)
			marginMode := GetValue(marginModequeryInnerVariable, 0)
			queryInner := GetValue(marginModequeryInnerVariable, 1)
			if IsTrue(!IsEqual(since, nil)) {
				AddElementToObject(request, "startTime", since)
			}
			if IsTrue(!IsEqual(until, nil)) {
				AddElementToObject(request, "endTime", until)
			}
			if IsTrue(!IsEqual(limit, nil)) {
				AddElementToObject(request, "limit", limit)
			}
			var response interface{} = nil
			if IsTrue(!IsEqual(marginMode, nil)) {
				if IsTrue(!IsEqual(marginMode, "isolated")) {
					panic(BadRequest(Add(Add(Add(this.Id, " fetchOrders() does not support marginMode "), marginMode), " for spot-margin trading")))
				}

				response = (<-this.SpotPrivateGetMarginAllOrders(this.Extend(request, queryInner)))
				PanicOnError(response)
			} else {

				response = (<-this.SpotPrivateGetAllOrders(this.Extend(request, queryInner)))
				PanicOnError(response)
			}

			//
			// spot
			//
			//     [
			//         {
			//             "symbol": "BTCUSDT",
			//             "orderId": "133949373632483328",
			//             "orderListId": "-1",
			//             "clientOrderId": null,
			//             "price": "45000",
			//             "origQty": "0.0002",
			//             "executedQty": "0",
			//             "cummulativeQuoteQty": "0",
			//             "status": "NEW",
			//             "timeInForce": null,
			//             "type": "LIMIT",
			//             "side": "SELL",
			//             "stopPrice": null,
			//             "icebergQty": null,
			//             "time": "1647718255000",
			//             "updateTime": "1647718255000",
			//             "isWorking": true,
			//             "origQuoteOrderQty": "9"
			//         },
			//     ]
			//
			// margin
			//
			//     [
			//         {
			//             "symbol": "BTCUSDT",
			//             "orderId": "763307297891028992",
			//             "orderListId": "-1",
			//             "clientOrderId": null,
			//             "price": "18000",
			//             "origQty": "0.0014",
			//             "executedQty": "0",
			//             "cummulativeQuoteQty": "0",
			//             "status": "NEW",
			//             "type": "LIMIT",
			//             "side": "BUY",
			//             "isIsolated": true,
			//             "isWorking": true,
			//             "time": 1662153107000,
			//             "updateTime": 1662153107000
			//         }
			//     ]
			//
			ch <- this.ParseOrders(response, market, since, limit)
			return nil
		} else {
			if IsTrue(!IsEqual(since, nil)) {
				AddElementToObject(request, "start_time", since)
				var end interface{} = this.SafeInteger(params, "end_time", until)
				if IsTrue(IsEqual(end, nil)) {
					AddElementToObject(request, "end_time", this.Sum(since, GetValue(this.Options, "maxTimeTillEnd")))
				} else {
					if IsTrue(IsGreaterThan((Subtract(end, since)), GetValue(this.Options, "maxTimeTillEnd"))) {
						panic(BadRequest(Add(this.Id, " end is invalid, i.e. exceeds allowed 90 days.")))
					} else {
						AddElementToObject(request, "end_time", until)
					}
				}
			} else if IsTrue(!IsEqual(until, nil)) {
				AddElementToObject(request, "start_time", this.Sum(until, Multiply(GetValue(this.Options, "maxTimeTillEnd"), OpNeg(1))))
				AddElementToObject(request, "end_time", until)
			}
			if IsTrue(!IsEqual(limit, nil)) {
				AddElementToObject(request, "page_size", limit)
			}
			var method interface{} = this.SafeString(this.Options, "fetchOrders", "contractPrivateGetOrderListHistoryOrders")
			method = this.SafeString(query, "method", method)
			var ordersOfRegular interface{} = []interface{}{}
			var ordersOfTrigger interface{} = []interface{}{}
			if IsTrue(IsEqual(method, "contractPrivateGetOrderListHistoryOrders")) {

				response := (<-this.ContractPrivateGetOrderListHistoryOrders(this.Extend(request, query)))
				PanicOnError(response)
				//
				//     {
				//         "success": true,
				//         "code": "0",
				//         "data": [
				//             {
				//                 "orderId": "265230764677709315",
				//                 "symbol": "STEPN_USDT",
				//                 "positionId": "0",
				//                 "price": "2.1",
				//                 "vol": "102",
				//                 "leverage": "20",
				//                 "side": "1",
				//                 "category": "1",
				//                 "orderType": "1",
				//                 "dealAvgPrice": "0",
				//                 "dealVol": "0",
				//                 "orderMargin": "10.96704",
				//                 "takerFee": "0",
				//                 "makerFee": "0",
				//                 "profit": "0",
				//                 "feeCurrency": "USDT",
				//                 "openType": "1",
				//                 "state": "2",
				//                 "externalOid": "_m_7e42f8df6b324c869e4e200397e2b00f",
				//                 "errorCode": "0",
				//                 "usedMargin": "0",
				//                 "createTime": "1648906342000",
				//                 "updateTime": "1648906342000",
				//                 "positionMode": "1"
				//             },
				//          ]
				//     }
				//
				ordersOfRegular = this.SafeValue(response, "data")
			} else {
				// the Planorder endpoints work not only for stop-market orders, but also for stop-limit orders that were supposed to have a separate endpoint

				response := (<-this.ContractPrivateGetPlanorderListOrders(this.Extend(request, query)))
				PanicOnError(response)
				//
				//     {
				//         "success": true,
				//         "code": "0",
				//         "data": [
				//             {
				//                 "symbol": "STEPN_USDT",
				//                 "leverage": "20",
				//                 "side": "1",
				//                 "vol": "13",
				//                 "openType": "1",
				//                 "state": "1",
				//                 "orderType": "1",
				//                 "errorCode": "0",
				//                 "createTime": "1648984276000",
				//                 "updateTime": "1648984276000",
				//                 "id": "265557643326564352",
				//                 "triggerType": "1",
				//                 "triggerPrice": "3",
				//                 "price": "2.9", // not present in stop-market, but in stop-limit order
				//                 "executeCycle": "87600",
				//                 "trend": "1",
				//             },
				//         ]
				//     }
				//
				ordersOfTrigger = this.SafeValue(response, "data")
			}
			var merged interface{} = this.ArrayConcat(ordersOfTrigger, ordersOfRegular)

			ch <- this.ParseOrders(merged, market, since, limit, params)
			return nil
		}

	}()
	return ch
}
func (this *mexc) FetchOrdersByIds(ids interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes29178 := (<-this.LoadMarkets())
		PanicOnError(retRes29178)
		var request interface{} = map[string]interface{}{}
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			AddElementToObject(request, "symbol", GetValue(market, "id"))
		}
		marketTypequeryVariable := this.HandleMarketTypeAndParams("fetchOrdersByIds", market, params)
		marketType := GetValue(marketTypequeryVariable, 0)
		query := GetValue(marketTypequeryVariable, 1)
		if IsTrue(IsEqual(marketType, "spot")) {
			panic(BadRequest(Add(Add(this.Id, " fetchOrdersByIds() is not supported for "), marketType)))
		} else {
			AddElementToObject(request, "order_ids", Join(ids, ","))

			response := (<-this.ContractPrivateGetOrderBatchQuery(this.Extend(request, query)))
			PanicOnError(response)
			//
			//     {
			//         "success": true,
			//         "code": "0",
			//         "data": [
			//             {
			//                 "orderId": "265230764677709315",
			//                 "symbol": "STEPN_USDT",
			//                 "positionId": "0",
			//                 "price": "2.1",
			//                 "vol": "102",
			//                 "leverage": "20",
			//                 "side": "1",
			//                 "category": "1",
			//                 "orderType": "1",
			//                 "dealAvgPrice": "0",
			//                 "dealVol": "0",
			//                 "orderMargin": "10.96704",
			//                 "takerFee": "0",
			//                 "makerFee": "0",
			//                 "profit": "0",
			//                 "feeCurrency": "USDT",
			//                 "openType": "1",
			//                 "state": "2",
			//                 "externalOid": "_m_7e42f8df6b324c869e4e200397e2b00f",
			//                 "errorCode": "0",
			//                 "usedMargin": "0",
			//                 "createTime": "1648906342000",
			//                 "updateTime": "1648906342000",
			//                 "positionMode": "1"
			//             }
			//         ]
			//     }
			//
			var data interface{} = this.SafeList(response, "data")

			ch <- this.ParseOrders(data, market)
			return nil
		}

	}()
	return ch
}

/**
 * @method
 * @name mexc#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#current-open-orders
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-all-of-the-user-39-s-historical-orders
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#gets-the-trigger-order-list
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] only 'isolated' is supported, for spot-margin trading
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *mexc) FetchOpenOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes29848 := (<-this.LoadMarkets())
		PanicOnError(retRes29848)
		var request interface{} = map[string]interface{}{}
		var market interface{} = nil
		var marketType interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
		}
		marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchOpenOrders", market, params)
		marketType = GetValue(marketTypeparamsVariable, 0)
		params = GetValue(marketTypeparamsVariable, 1)
		if IsTrue(IsEqual(marketType, "spot")) {
			if IsTrue(IsEqual(symbol, nil)) {
				panic(ArgumentsRequired(Add(this.Id, " fetchOpenOrders() requires a symbol argument for spot market")))
			}
			AddElementToObject(request, "symbol", GetValue(market, "id"))
			marginModequeryVariable := this.HandleMarginModeAndParams("fetchOpenOrders", params)
			marginMode := GetValue(marginModequeryVariable, 0)
			query := GetValue(marginModequeryVariable, 1)
			var response interface{} = nil
			if IsTrue(!IsEqual(marginMode, nil)) {
				if IsTrue(!IsEqual(marginMode, "isolated")) {
					panic(BadRequest(Add(Add(Add(this.Id, " fetchOpenOrders() does not support marginMode "), marginMode), " for spot-margin trading")))
				}

				response = (<-this.SpotPrivateGetMarginOpenOrders(this.Extend(request, query)))
				PanicOnError(response)
			} else {

				response = (<-this.SpotPrivateGetOpenOrders(this.Extend(request, query)))
				PanicOnError(response)
			}

			//
			// spot
			//
			//     [
			//         {
			//             "symbol": "BTCUSDT",
			//             "orderId": "133949373632483328",
			//             "orderListId": "-1",
			//             "clientOrderId": "",
			//             "price": "45000",
			//             "origQty": "0.0002",
			//             "executedQty": "0",
			//             "cummulativeQuoteQty": "0",
			//             "status": "NEW",
			//             "timeInForce": null,
			//             "type": "LIMIT",
			//             "side": "SELL",
			//             "stopPrice": null,
			//             "icebergQty": null,
			//             "time": "1647718255199",
			//             "updateTime": null,
			//             "isWorking": true,
			//             "origQuoteOrderQty": "9"
			//         }
			//     ]
			//
			// margin
			//
			//     [
			//         {
			//             "symbol": "BTCUSDT",
			//             "orderId": "764547676405633024",
			//             "orderListId": "-1",
			//             "clientOrderId": null,
			//             "price": "18000",
			//             "origQty": "0.0013",
			//             "executedQty": "0",
			//             "cummulativeQuoteQty": "0",
			//             "status": "NEW",
			//             "type": "LIMIT",
			//             "side": "BUY",
			//             "isIsolated": true,
			//             "isWorking": true,
			//             "time": 1662448836000,
			//             "updateTime": 1662448836000
			//         }
			//     ]
			//
			ch <- this.ParseOrders(response, market, since, limit)
			return nil
		} else {

			retRes305819 := (<-this.FetchOrdersByState(2, symbol, since, limit, params))
			PanicOnError(retRes305819)
			// TO_DO: another possible way is through: open_orders/{symbol}, but as they have same ratelimits, and less granularity, i think historical orders are more convenient, as it supports more params (however, theoretically, open-orders endpoint might be sligthly fast)
			ch <- retRes305819
			return nil
		}

	}()
	return ch
}

/**
 * @method
 * @name mexc#fetchClosedOrders
 * @description fetches information on multiple closed orders made by the user
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#all-orders
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-all-of-the-user-39-s-historical-orders
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#gets-the-trigger-order-list
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *mexc) FetchClosedOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes307615 := (<-this.FetchOrdersByState(3, symbol, since, limit, params))
		PanicOnError(retRes307615)
		ch <- retRes307615
		return nil

	}()
	return ch
}

/**
 * @method
 * @name mexc#fetchCanceledOrders
 * @description fetches information on multiple canceled orders made by the user
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#all-orders
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-all-of-the-user-39-s-historical-orders
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#gets-the-trigger-order-list
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] timestamp in ms of the earliest order, default is undefined
 * @param {int} [limit] max number of orders to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *mexc) FetchCanceledOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes309315 := (<-this.FetchOrdersByState(4, symbol, since, limit, params))
		PanicOnError(retRes309315)
		ch <- retRes309315
		return nil

	}()
	return ch
}
func (this *mexc) FetchOrdersByState(state interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes30978 := (<-this.LoadMarkets())
		PanicOnError(retRes30978)
		var request interface{} = map[string]interface{}{}
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
		}
		marketTypeVariable := this.HandleMarketTypeAndParams("fetchOrdersByState", market, params)
		marketType := GetValue(marketTypeVariable, 0)
		if IsTrue(IsEqual(marketType, "spot")) {
			panic(NotSupported(Add(Add(this.Id, " fetchOrdersByState() is not supported for "), marketType)))
		} else {
			AddElementToObject(request, "states", state)

			retRes310819 := (<-this.FetchOrders(symbol, since, limit, this.Extend(request, params)))
			PanicOnError(retRes310819)
			ch <- retRes310819
			return nil
		}

	}()
	return ch
}

/**
 * @method
 * @name mexc#cancelOrder
 * @description cancels an open order
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#cancel-order
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#cancel-the-order-under-maintenance
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#cancel-the-stop-limit-trigger-order-under-maintenance
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] only 'isolated' is supported for spot-margin trading
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *mexc) CancelOrder(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes31268 := (<-this.LoadMarkets())
		PanicOnError(retRes31268)
		var request interface{} = map[string]interface{}{}
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			AddElementToObject(request, "symbol", GetValue(market, "id"))
		}
		var marketType interface{} = nil
		marketTypeparamsVariable := this.HandleMarketTypeAndParams("cancelOrder", market, params)
		marketType = GetValue(marketTypeparamsVariable, 0)
		params = GetValue(marketTypeparamsVariable, 1)
		marginModequeryVariable := this.HandleMarginModeAndParams("cancelOrder", params)
		marginMode := GetValue(marginModequeryVariable, 0)
		query := GetValue(marginModequeryVariable, 1)
		var data interface{} = nil
		if IsTrue(IsEqual(marketType, "spot")) {
			if IsTrue(IsEqual(symbol, nil)) {
				panic(ArgumentsRequired(Add(this.Id, " cancelOrder() requires a symbol argument")))
			}
			var requestInner interface{} = map[string]interface{}{
				"symbol": GetValue(market, "id"),
			}
			var clientOrderId interface{} = this.SafeString(params, "clientOrderId")
			if IsTrue(!IsEqual(clientOrderId, nil)) {
				params = this.Omit(query, "clientOrderId")
				AddElementToObject(requestInner, "origClientOrderId", clientOrderId)
			} else {
				AddElementToObject(requestInner, "orderId", id)
			}
			if IsTrue(!IsEqual(marginMode, nil)) {
				if IsTrue(!IsEqual(marginMode, "isolated")) {
					panic(BadRequest(Add(Add(Add(this.Id, " cancelOrder() does not support marginMode "), marginMode), " for spot-margin trading")))
				}

				data = (<-this.SpotPrivateDeleteMarginOrder(this.Extend(requestInner, query)))
				PanicOnError(data)
			} else {

				data = (<-this.SpotPrivateDeleteOrder(this.Extend(requestInner, query)))
				PanicOnError(data)
			}
		} else {
			// TODO: PlanorderCancel endpoint has bug atm. waiting for fix.
			var method interface{} = this.SafeString(this.Options, "cancelOrder", "contractPrivatePostOrderCancel") // contractPrivatePostOrderCancel, contractPrivatePostPlanorderCancel
			method = this.SafeString(query, "method", method)
			var response interface{} = nil
			if IsTrue(IsEqual(method, "contractPrivatePostOrderCancel")) {

				response = (<-this.ContractPrivatePostOrderCancel([]interface{}{id}))
				PanicOnError(response) // the request cannot be changed or extended. This is the only way to send.
			} else if IsTrue(IsEqual(method, "contractPrivatePostPlanorderCancel")) {

				response = (<-this.ContractPrivatePostPlanorderCancel([]interface{}{id}))
				PanicOnError(response) // the request cannot be changed or extended. This is the only way to send.
			} else {
				panic(NotSupported(Add(this.Id, " cancelOrder() not support this method")))
			}
			//
			//     {
			//         "success": true,
			//         "code": "0",
			//         "data": [
			//             {
			//                 "orderId": "264995729269765120",
			//                 "errorCode": "0",         // if already canceled: "2041"; if doesn't exist: "2040"
			//                 "errorMsg": "success",    // if already canceled: "order state cannot be cancelled"; if doesn't exist: "order not exist"
			//             }
			//         ]
			//     }
			//
			data = this.SafeValue(response, "data")
			var order interface{} = this.SafeValue(data, 0)
			var errorMsg interface{} = this.SafeValue(order, "errorMsg", "")
			if IsTrue(!IsEqual(errorMsg, "success")) {
				panic(InvalidOrder(Add(Add(Add(Add(this.Id, " cancelOrder() the order with id "), id), " cannot be cancelled: "), errorMsg)))
			}
		}

		ch <- this.ParseOrder(data, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name mexc#cancelOrders
 * @description cancel multiple orders
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#cancel-the-order-under-maintenance
 * @param {string[]} ids order ids
 * @param {string} symbol unified market symbol, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *mexc) CancelOrders(ids interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes32398 := (<-this.LoadMarkets())
		PanicOnError(retRes32398)
		var market interface{} = Ternary(IsTrue((!IsEqual(symbol, nil))), this.Market(symbol), nil)
		marketTypeVariable := this.HandleMarketTypeAndParams("cancelOrders", market, params)
		marketType := GetValue(marketTypeVariable, 0)
		if IsTrue(IsEqual(marketType, "spot")) {
			panic(BadRequest(Add(Add(this.Id, " cancelOrders() is not supported for "), marketType)))
		} else {

			response := (<-this.ContractPrivatePostOrderCancel(ids))
			PanicOnError(response) // the request cannot be changed or extended. The only way to send.
			//
			//     {
			//         "success": true,
			//         "code": "0",
			//         "data": [
			//             {
			//                 "orderId": "264995729269765120",
			//                 "errorCode": "0",         // if already canceled: "2041"
			//                 "errorMsg": "success",    // if already canceled: "order state cannot be cancelled"
			//             },
			//         ]
			//     }
			//
			var data interface{} = this.SafeList(response, "data")

			ch <- this.ParseOrders(data, market)
			return nil
		}

	}()
	return ch
}

/**
 * @method
 * @name mexc#cancelAllOrders
 * @description cancel all open orders
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#cancel-all-open-orders-on-a-symbol
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#cancel-all-orders-under-a-contract-under-maintenance
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#cancel-all-trigger-orders-under-maintenance
 * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] only 'isolated' is supported for spot-margin trading
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *mexc) CancelAllOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes32778 := (<-this.LoadMarkets())
		PanicOnError(retRes32778)
		var market interface{} = Ternary(IsTrue((!IsEqual(symbol, nil))), this.Market(symbol), nil)
		var request interface{} = map[string]interface{}{}
		var marketType interface{} = nil
		marketTypeparamsVariable := this.HandleMarketTypeAndParams("cancelAllOrders", market, params)
		marketType = GetValue(marketTypeparamsVariable, 0)
		params = GetValue(marketTypeparamsVariable, 1)
		marginModequeryVariable := this.HandleMarginModeAndParams("cancelAllOrders", params)
		marginMode := GetValue(marginModequeryVariable, 0)
		query := GetValue(marginModequeryVariable, 1)
		if IsTrue(IsEqual(marketType, "spot")) {
			if IsTrue(IsEqual(symbol, nil)) {
				panic(ArgumentsRequired(Add(this.Id, " cancelAllOrders() requires a symbol argument on spot")))
			}
			AddElementToObject(request, "symbol", GetValue(market, "id"))
			var response interface{} = nil
			if IsTrue(!IsEqual(marginMode, nil)) {
				if IsTrue(!IsEqual(marginMode, "isolated")) {
					panic(BadRequest(Add(Add(Add(this.Id, " cancelAllOrders() does not support marginMode "), marginMode), " for spot-margin trading")))
				}

				response = (<-this.SpotPrivateDeleteMarginOpenOrders(this.Extend(request, query)))
				PanicOnError(response)
			} else {

				response = (<-this.SpotPrivateDeleteOpenOrders(this.Extend(request, query)))
				PanicOnError(response)
			}

			//
			// spot
			//
			//     [
			//         {
			//             "symbol": "BTCUSDT",
			//             "orderId": "133926492139692032",
			//             "price": "30000",
			//             "origQty": "0.0002",
			//             "type": "LIMIT",
			//             "side": "BUY"
			//         },
			//     ]
			//
			// margin
			//
			//     [
			//         {
			//             "symbol": "BTCUSDT",
			//             "orderId": "762640232574226432",
			//             "orderListId": "-1",
			//             "clientOrderId": null,
			//             "price": "18000",
			//             "origQty": "0.00147",
			//             "executedQty": "0",
			//             "cummulativeQuoteQty": "0",
			//             "status": "NEW",
			//             "type": "LIMIT",
			//             "side": "BUY",
			//             "isIsolated": true,
			//             "isWorking": true,
			//             "time": 1661994066000,
			//             "updateTime": 1661994066000
			//         }
			//     ]
			//
			ch <- this.ParseOrders(response, market)
			return nil
		} else {
			if IsTrue(!IsEqual(symbol, nil)) {
				AddElementToObject(request, "symbol", GetValue(market, "id"))
			}
			// method can be either: contractPrivatePostOrderCancelAll or contractPrivatePostPlanorderCancelAll
			// the Planorder endpoints work not only for stop-market orders but also for stop-limit orders that are supposed to have separate endpoint
			var method interface{} = this.SafeString(this.Options, "cancelAllOrders", "contractPrivatePostOrderCancelAll")
			method = this.SafeString(query, "method", method)
			var response interface{} = nil
			if IsTrue(IsEqual(method, "contractPrivatePostOrderCancelAll")) {

				response = (<-this.ContractPrivatePostOrderCancelAll(this.Extend(request, query)))
				PanicOnError(response)
			} else if IsTrue(IsEqual(method, "contractPrivatePostPlanorderCancelAll")) {

				response = (<-this.ContractPrivatePostPlanorderCancelAll(this.Extend(request, query)))
				PanicOnError(response)
			}
			//
			//     {
			//         "success": true,
			//         "code": "0"
			//     }
			//
			var data interface{} = this.SafeList(response, "data", []interface{}{})

			ch <- this.ParseOrders(data, market)
			return nil
		}

	}()
	return ch
}
func (this *mexc) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{} {
	//
	// spot
	//    createOrder
	//
	//    {
	//        "symbol": "FARTCOINUSDT",
	//        "orderId": "C02__342252993005723644225",
	//        "orderListId": "-1",
	//        "price": "1.1",
	//        "origQty": "6.3",
	//        "type": "IMMEDIATE_OR_CANCEL",
	//        "side": "SELL",
	//        "transactTime": "1745852205223"
	//    }
	//
	//    unknown endpoint on spot
	//
	//    {
	//         "symbol": "BTCUSDT",
	//         "orderId": "123738410679123456",
	//         "orderListId": -1
	//    }
	//
	// margin: createOrder
	//
	//     {
	//         "symbol": "BTCUSDT",
	//         "orderId": "762634301354414080",
	//         "clientOrderId": null,
	//         "isIsolated": true,
	//         "transactTime": 1661992652132
	//     }
	//
	// spot: cancelOrder, cancelAllOrders
	//
	//     {
	//         "symbol": "BTCUSDT",
	//         "orderId": "133926441921286144",
	//         "price": "30000",
	//         "origQty": "0.0002",
	//         "type": "LIMIT",
	//         "side": "BUY"
	//     }
	//
	// margin: cancelOrder, cancelAllOrders
	//
	//     {
	//         "symbol": "BTCUSDT",
	//         "orderId": "762640232574226432",
	//         "orderListId": "-1",
	//         "clientOrderId": null,
	//         "price": "18000",
	//         "origQty": "0.00147",
	//         "executedQty": "0",
	//         "cummulativeQuoteQty": "0",
	//         "status": "NEW",
	//         "type": "LIMIT",
	//         "side": "BUY",
	//         "isIsolated": true,
	//         "isWorking": true,
	//         "time": 1661994066000,
	//         "updateTime": 1661994066000
	//     }
	//
	// spot: fetchOrder, fetchOpenOrders, fetchOrders
	//
	//     {
	//         "symbol": "BTCUSDT",
	//         "orderId": "133734823834147272",
	//         "orderListId": "-1",
	//         "clientOrderId": null,
	//         "price": "30000",
	//         "origQty": "0.0002",
	//         "executedQty": "0",
	//         "cummulativeQuoteQty": "0",
	//         "status": "CANCELED",
	//         "timeInForce": null,
	//         "type": "LIMIT",
	//         "side": "BUY",
	//         "stopPrice": null,
	//         "icebergQty": null,
	//         "time": "1647667102000",
	//         "updateTime": "1647708567000",
	//         "isWorking": true,
	//         "origQuoteOrderQty": "6"
	//     }
	//
	// margin: fetchOrder, fetchOrders
	//
	//     {
	//         "symbol": "BTCUSDT",
	//         "orderId": "763307297891028992",
	//         "orderListId": "-1",
	//         "clientOrderId": null,
	//         "price": "18000",
	//         "origQty": "0.0014",
	//         "executedQty": "0",
	//         "cummulativeQuoteQty": "0",
	//         "status": "NEW",
	//         "type": "LIMIT",
	//         "side": "BUY",
	//         "isIsolated": true,
	//         "isWorking": true,
	//         "time": 1662153107000,
	//         "updateTime": 1662153107000
	//     }
	//
	// swap: createOrder
	//
	//     2ff3163e8617443cb9c6fc19d42b1ca4
	//
	// swap: fetchOrder, fetchOrders
	//
	//     regular
	//     {
	//         "orderId": "264995729269765120",
	//         "symbol": "STEPN_USDT",
	//         "positionId": "0",
	//         "price": "2.2",
	//         "vol": "15",
	//         "leverage": "20",
	//         "side": "1", // TODO: not unified
	//         "category": "1",
	//         "orderType": "1", // TODO: not unified
	//         "dealAvgPrice": "0",
	//         "dealVol": "0",
	//         "orderMargin": "2.2528",
	//         "takerFee": "0",
	//         "makerFee": "0",
	//         "profit": "0",
	//         "feeCurrency": "USDT",
	//         "openType": "1",
	//         "state": "2", // TODO
	//         "externalOid": "_m_0e9520c256744d64b942985189026d20",
	//         "errorCode": "0",
	//         "usedMargin": "0",
	//         "createTime": "1648850305236",
	//         "updateTime": "1648850305245",
	//         "positionMode": "1"
	//     }
	//
	//     stop
	//     {
	//         "id": "265557643326564352",
	//         "triggerType": "1",
	//         "triggerPrice": "3",
	//         "price": "2.9", // not present in stop-market, but in stop-limit order
	//         "executeCycle": "87600",
	//         "trend": "1",
	//          // below keys are same as in regular order structure
	//         "symbol": "STEPN_USDT",
	//         "leverage": "20",
	//         "side": "1",
	//         "vol": "13",
	//         "openType": "1",
	//         "state": "1",
	//         "orderType": "1",
	//         "errorCode": "0",
	//         "createTime": "1648984276000",
	//         "updateTime": "1648984276000",
	//     }
	//
	// createOrders error
	//
	//     {
	//         "newClientOrderId": "123456",
	//         "msg": "The minimum transaction volume cannot be less than:0.5USDT",
	//         "code": 30002
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var code interface{} = this.SafeInteger(order, "code")
	if IsTrue(!IsEqual(code, nil)) {
		// error upon placing multiple orders
		return this.SafeOrder(map[string]interface{}{
			"info":          order,
			"status":        "rejected",
			"clientOrderId": this.SafeString(order, "newClientOrderId"),
		})
	}
	var id interface{} = nil
	if IsTrue(IsString(order)) {
		id = order
	} else {
		id = this.SafeString2(order, "orderId", "id")
	}
	var timeInForce interface{} = this.ParseOrderTimeInForce(this.SafeString(order, "timeInForce"))
	var typeRaw interface{} = this.SafeString(order, "type")
	if IsTrue(IsEqual(timeInForce, nil)) {
		timeInForce = this.GetTifFromRawOrderType(typeRaw)
	}
	var marketId interface{} = this.SafeString(order, "symbol")
	market = this.SafeMarket(marketId, market)
	var timestamp interface{} = this.SafeIntegerN(order, []interface{}{"time", "createTime", "transactTime"})
	var fee interface{} = nil
	var feeCurrency interface{} = this.SafeString(order, "feeCurrency")
	if IsTrue(!IsEqual(feeCurrency, nil)) {
		var takerFee interface{} = this.SafeString(order, "takerFee")
		var makerFee interface{} = this.SafeString(order, "makerFee")
		var feeSum interface{} = Precise.StringAdd(takerFee, makerFee)
		fee = map[string]interface{}{
			"currency": feeCurrency,
			"cost":     this.ParseNumber(feeSum),
		}
	}
	return this.SafeOrder(map[string]interface{}{
		"id":                 id,
		"clientOrderId":      this.SafeString(order, "clientOrderId"),
		"timestamp":          timestamp,
		"datetime":           this.Iso8601(timestamp),
		"lastTradeTimestamp": nil,
		"status":             this.ParseOrderStatus(this.SafeString2(order, "status", "state")),
		"symbol":             GetValue(market, "symbol"),
		"type":               this.ParseOrderType(typeRaw),
		"timeInForce":        timeInForce,
		"side":               this.ParseOrderSide(this.SafeString(order, "side")),
		"price":              this.SafeNumber(order, "price"),
		"triggerPrice":       this.SafeNumber2(order, "stopPrice", "triggerPrice"),
		"average":            this.SafeNumber(order, "dealAvgPrice"),
		"amount":             this.SafeNumber2(order, "origQty", "vol"),
		"cost":               this.SafeNumber(order, "cummulativeQuoteQty"),
		"filled":             this.SafeNumber2(order, "executedQty", "dealVol"),
		"remaining":          nil,
		"fee":                fee,
		"trades":             nil,
		"info":               order,
	}, market)
}
func (this *mexc) ParseOrderSide(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"BUY":  "buy",
		"SELL": "sell",
		"1":    "buy",
		"2":    "sell",
	}
	return this.SafeString(statuses, status, status)
}
func (this *mexc) ParseOrderType(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"MARKET":              "market",
		"LIMIT":               "limit",
		"LIMIT_MAKER":         "limit",
		"IMMEDIATE_OR_CANCEL": "limit",
		"FILL_OR_KILL":        "limit",
	}
	return this.SafeString(statuses, status, status)
}
func (this *mexc) ParseOrderStatus(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"NEW":                "open",
		"FILLED":             "closed",
		"CANCELED":           "canceled",
		"PARTIALLY_FILLED":   "open",
		"PARTIALLY_CANCELED": "canceled",
		"2":                  "open",
		"3":                  "closed",
		"4":                  "canceled",
	}
	return this.SafeString(statuses, status, status)
}
func (this *mexc) ParseOrderTimeInForce(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"GTC": "GTC",
		"FOK": "FOK",
		"IOC": "IOC",
	}
	return this.SafeString(statuses, status, status)
}
func (this *mexc) GetTifFromRawOrderType(optionalArgs ...interface{}) interface{} {
	orderType := GetArg(optionalArgs, 0, nil)
	_ = orderType
	var statuses interface{} = map[string]interface{}{
		"LIMIT":               "GTC",
		"LIMIT_MAKER":         "POST_ONLY",
		"IMMEDIATE_OR_CANCEL": "IOC",
		"FILL_OR_KILL":        "FOK",
		"MARKET":              "IOC",
	}
	return this.SafeString(statuses, orderType, orderType)
}
func (this *mexc) FetchAccountHelper(typeVar interface{}, params interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		if IsTrue(IsEqual(typeVar, "spot")) {

			retRes365019 := (<-this.SpotPrivateGetAccount(params))
			PanicOnError(retRes365019)
			ch <- retRes365019
			return nil
		} else if IsTrue(IsEqual(typeVar, "swap")) {

			response := (<-this.ContractPrivateGetAccountAssets(params))
			PanicOnError(response)

			//
			//     {
			//         "success":true,
			//         "code":0,
			//         "data":[
			//            {
			//              "currency":"BSV",
			//              "positionMargin":0,
			//              "availableBalance":0,
			//              "cashBalance":0,
			//              "frozenBalance":0,
			//              "equity":0,
			//              "unrealized":0,
			//              "bonus":0
			//           },
			//         ]
			//     }
			//
			ch <- this.SafeValue(response, "data")
			return nil
		}

		return nil

	}()
	return ch
}

/**
 * @method
 * @name mexc#fetchAccounts
 * @description fetch all the accounts associated with a profile
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#account-information
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-all-informations-of-user-39-s-asset
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/#/?id=account-structure} indexed by the account type
 */
func (this *mexc) FetchAccounts(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		// TODO: is the below endpoints suitable for fetchAccounts?
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		marketTypequeryVariable := this.HandleMarketTypeAndParams("fetchAccounts", nil, params)
		marketType := GetValue(marketTypequeryVariable, 0)
		query := GetValue(marketTypequeryVariable, 1)

		retRes37168 := (<-this.LoadMarkets())
		PanicOnError(retRes37168)

		response := (<-this.FetchAccountHelper(marketType, query))
		PanicOnError(response)
		var data interface{} = this.SafeValue(response, "balances", []interface{}{})
		var result interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
			var account interface{} = GetValue(data, i)
			var currencyId interface{} = this.SafeString2(account, "asset", "currency")
			var code interface{} = this.SafeCurrencyCode(currencyId)
			AppendToArray(&result, map[string]interface{}{
				"id":   this.SafeString(account, "id"),
				"type": this.SafeString(account, "type"),
				"code": code,
				"info": account,
			})
		}

		ch <- result
		return nil

	}()
	return ch
}

/**
 * @method
 * @name mexc#fetchTradingFee
 * @description fetch the trading fees for a market
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#query-mx-deduct-status
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func (this *mexc) FetchTradingFee(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes37448 := (<-this.LoadMarkets())
		PanicOnError(retRes37448)
		var market interface{} = this.Market(symbol)
		if !IsTrue(GetValue(market, "spot")) {
			panic(BadRequest(Add(this.Id, " fetchTradingFee() supports spot markets only")))
		}
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}

		response := (<-this.SpotPrivateGetTradeFee(this.Extend(request, params)))
		PanicOnError(response)
		//
		//  {
		//      "data":{
		//        "makerCommission":0.003000000000000000,
		//        "takerCommission":0.003000000000000000
		//      },
		//      "code":0,
		//      "msg":"success",
		//      "timestamp":1669109672717
		//  }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})

		ch <- map[string]interface{}{
			"info":       data,
			"symbol":     symbol,
			"maker":      this.SafeNumber(data, "makerCommission"),
			"taker":      this.SafeNumber(data, "takerCommission"),
			"percentage": nil,
			"tierBased":  nil,
		}
		return nil

	}()
	return ch
}
func (this *mexc) CustomParseBalance(response interface{}, marketType interface{}) interface{} {
	//
	// spot
	//
	//     {
	//         "asset": "USDT",
	//         "free": "0.000000000674",
	//         "locked": "0"
	//     }
	//
	// swap
	//
	//     {
	//         "currency": "BSV",
	//         "positionMargin": 0,
	//         "availableBalance": 0,
	//         "cashBalance": 0,
	//         "frozenBalance": 0,
	//         "equity": 0,
	//         "unrealized": 0,
	//         "bonus": 0
	//     }
	//
	// margin
	//
	//     {
	//         "baseAsset": {
	//             "asset": "BTC",
	//             "borrowEnabled": true,
	//             "borrowed": "0",
	//             "free": "0",
	//             "interest": "0",
	//             "locked": "0",
	//             "netAsset": "0",
	//             "netAssetOfBtc": "0",
	//             "repayEnabled": true,
	//             "totalAsset": "0"
	//         }
	//         "quoteAsset": {
	//             "asset": "USDT",
	//             "borrowEnabled": true,
	//             "borrowed": "0",
	//             "free": "10",
	//             "interest": "0",
	//             "locked": "0",
	//             "netAsset": "10",
	//             "netAssetOfBtc": "0",
	//             "repayEnabled": true,
	//             "totalAsset": "10"
	//         }
	//         "symbol": "BTCUSDT",
	//         "isolatedCreated": true,
	//         "enabled": true,
	//         "marginLevel": "999",
	//         "marginRatio": "9",
	//         "indexPrice": "16741.137068965517241379",
	//         "liquidatePrice": "--",
	//         "liquidateRate": "--",
	//         "tradeEnabled": true
	//     }
	//
	var wallet interface{} = nil
	if IsTrue(IsEqual(marketType, "margin")) {
		wallet = this.SafeValue(response, "assets", []interface{}{})
	} else if IsTrue(IsEqual(marketType, "swap")) {
		wallet = this.SafeValue(response, "data", []interface{}{})
	} else {
		wallet = this.SafeValue(response, "balances", []interface{}{})
	}
	var result interface{} = map[string]interface{}{
		"info": response,
	}
	if IsTrue(IsEqual(marketType, "margin")) {
		for i := 0; IsLessThan(i, GetArrayLength(wallet)); i++ {
			var entry interface{} = GetValue(wallet, i)
			var marketId interface{} = this.SafeString(entry, "symbol")
			var symbol interface{} = this.SafeSymbol(marketId, nil)
			var base interface{} = this.SafeValue(entry, "baseAsset", map[string]interface{}{})
			var quote interface{} = this.SafeValue(entry, "quoteAsset", map[string]interface{}{})
			var baseCode interface{} = this.SafeCurrencyCode(this.SafeString(base, "asset"))
			var quoteCode interface{} = this.SafeCurrencyCode(this.SafeString(quote, "asset"))
			var subResult interface{} = map[string]interface{}{}
			AddElementToObject(subResult, baseCode, this.ParseBalanceHelper(base))
			AddElementToObject(subResult, quoteCode, this.ParseBalanceHelper(quote))
			AddElementToObject(result, symbol, this.SafeBalance(subResult))
		}
		return result
	} else if IsTrue(IsEqual(marketType, "swap")) {
		for i := 0; IsLessThan(i, GetArrayLength(wallet)); i++ {
			var entry interface{} = GetValue(wallet, i)
			var currencyId interface{} = this.SafeString(entry, "currency")
			var code interface{} = this.SafeCurrencyCode(currencyId)
			var account interface{} = this.Account()
			AddElementToObject(account, "free", this.SafeString(entry, "availableBalance"))
			AddElementToObject(account, "used", this.SafeString(entry, "frozenBalance"))
			AddElementToObject(result, code, account)
		}
		return this.SafeBalance(result)
	} else {
		for i := 0; IsLessThan(i, GetArrayLength(wallet)); i++ {
			var entry interface{} = GetValue(wallet, i)
			var currencyId interface{} = this.SafeString(entry, "asset")
			var code interface{} = this.SafeCurrencyCode(currencyId)
			var account interface{} = this.Account()
			AddElementToObject(account, "free", this.SafeString(entry, "free"))
			AddElementToObject(account, "used", this.SafeString(entry, "locked"))
			AddElementToObject(result, code, account)
		}
		return this.SafeBalance(result)
	}
}
func (this *mexc) ParseBalanceHelper(entry interface{}) interface{} {
	var account interface{} = this.Account()
	AddElementToObject(account, "used", this.SafeString(entry, "locked"))
	AddElementToObject(account, "free", this.SafeString(entry, "free"))
	AddElementToObject(account, "total", this.SafeString(entry, "totalAsset"))
	var debt interface{} = this.SafeString(entry, "borrowed")
	var interest interface{} = this.SafeString(entry, "interest")
	AddElementToObject(account, "debt", Precise.StringAdd(debt, interest))
	return account
}

/**
 * @method
 * @name mexc#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#account-information
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-all-informations-of-user-39-s-asset
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#isolated-account
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.symbols] // required for margin, market id's separated by commas
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func (this *mexc) FetchBalance(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes39088 := (<-this.LoadMarkets())
		PanicOnError(retRes39088)
		var marketType interface{} = nil
		var request interface{} = map[string]interface{}{}
		marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchBalance", nil, params)
		marketType = GetValue(marketTypeparamsVariable, 0)
		params = GetValue(marketTypeparamsVariable, 1)
		var marginMode interface{} = this.SafeString(params, "marginMode")
		var isMargin interface{} = this.SafeBool(params, "margin", false)
		params = this.Omit(params, []interface{}{"margin", "marginMode"})
		var response interface{} = nil
		if IsTrue(IsTrue(IsTrue((!IsEqual(marginMode, nil))) || IsTrue((isMargin))) || IsTrue((IsEqual(marketType, "margin")))) {
			var parsedSymbols interface{} = nil
			var symbol interface{} = this.SafeString(params, "symbol")
			if IsTrue(IsEqual(symbol, nil)) {
				var symbols interface{} = this.SafeValue(params, "symbols")
				if IsTrue(!IsEqual(symbols, nil)) {
					parsedSymbols = Join(this.MarketIds(symbols), ",")
				}
			} else {
				var market interface{} = this.Market(symbol)
				parsedSymbols = GetValue(market, "id")
			}
			this.CheckRequiredArgument("fetchBalance", parsedSymbols, "symbol or symbols")
			marketType = "margin"
			AddElementToObject(request, "symbols", parsedSymbols)
			params = this.Omit(params, []interface{}{"symbol", "symbols"})

			response = (<-this.SpotPrivateGetMarginIsolatedAccount(this.Extend(request, params)))
			PanicOnError(response)
		} else if IsTrue(IsEqual(marketType, "spot")) {

			response = (<-this.SpotPrivateGetAccount(this.Extend(request, params)))
			PanicOnError(response)
		} else if IsTrue(IsEqual(marketType, "swap")) {

			response = (<-this.ContractPrivateGetAccountAssets(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			panic(NotSupported(Add(this.Id, " fetchBalance() not support this method")))
		}

		//
		// spot
		//
		//     {
		//         "makerCommission": 0,
		//         "takerCommission": 20,
		//         "buyerCommission": 0,
		//         "sellerCommission": 0,
		//         "canTrade": true,
		//         "canWithdraw": true,
		//         "canDeposit": true,
		//         "updateTime": null,
		//         "accountType": "SPOT",
		//         "balances": [
		//             {
		//                 "asset": "USDT",
		//                 "free": "0.000000000674",
		//                 "locked": "0"
		//             },
		//         ],
		//         "permissions": ["SPOT"]
		//     }
		//
		// swap
		//
		//     {
		//         "success": true,
		//         "code": 0,
		//         "data": [
		//             {
		//                 "currency": "BSV",
		//                 "positionMargin": 0,
		//                 "availableBalance": 0,
		//                 "cashBalance": 0,
		//                 "frozenBalance": 0,
		//                 "equity": 0,
		//                 "unrealized": 0,
		//                 "bonus": 0
		//             },
		//         ]
		//     }
		//
		// margin
		//
		//     {
		//         "assets": [
		//             {
		//                 "baseAsset": {
		//                     "asset": "BTC",
		//                     "borrowEnabled": true,
		//                     "borrowed": "0",
		//                     "free": "0",
		//                     "interest": "0",
		//                     "locked": "0",
		//                     "netAsset": "0",
		//                     "netAssetOfBtc": "0",
		//                     "repayEnabled": true,
		//                     "totalAsset": "0"
		//                 },
		//                 "quoteAsset": {
		//                     "asset": "USDT",
		//                     "borrowEnabled": true,
		//                     "borrowed": "0",
		//                     "free": "10",
		//                     "interest": "0",
		//                     "locked": "0",
		//                     "netAsset": "10",
		//                     "netAssetOfBtc": "0",
		//                     "repayEnabled": true,
		//                     "totalAsset": "10"
		//                 },
		//                 "symbol": "BTCUSDT",
		//                 "isolatedCreated": true,
		//                 "enabled": true,
		//                 "marginLevel": "999",
		//                 "marginRatio": "9",
		//                 "indexPrice": "16741.137068965517241379",
		//                 "liquidatePrice": "--",
		//                 "liquidateRate": "--",
		//                 "tradeEnabled": true
		//             }
		//         ]
		//     }
		//
		ch <- this.CustomParseBalance(response, marketType)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name mexc#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#account-trade-list
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-all-transaction-details-of-the-user-s-order
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch trades for
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func (this *mexc) FetchMyTrades(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchMyTrades() requires a symbol argument")))
		}

		retRes40448 := (<-this.LoadMarkets())
		PanicOnError(retRes40448)
		var market interface{} = this.Market(symbol)
		var marketType interface{} = nil
		marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchMyTrades", market, params)
		marketType = GetValue(marketTypeparamsVariable, 0)
		params = GetValue(marketTypeparamsVariable, 1)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		var trades interface{} = nil
		if IsTrue(IsEqual(marketType, "spot")) {
			if IsTrue(!IsEqual(since, nil)) {
				AddElementToObject(request, "startTime", since)
			}
			if IsTrue(!IsEqual(limit, nil)) {
				AddElementToObject(request, "limit", limit)
			}
			var until interface{} = this.SafeInteger(params, "until")
			if IsTrue(!IsEqual(until, nil)) {
				params = this.Omit(params, "until")
				AddElementToObject(request, "endTime", until)
			}

			trades = (<-this.SpotPrivateGetMyTrades(this.Extend(request, params)))
			PanicOnError(trades)
		} else {
			if IsTrue(!IsEqual(since, nil)) {
				AddElementToObject(request, "start_time", since)
				var end interface{} = this.SafeInteger(params, "end_time")
				if IsTrue(IsEqual(end, nil)) {
					AddElementToObject(request, "end_time", this.Sum(since, GetValue(this.Options, "maxTimeTillEnd")))
				}
			}
			if IsTrue(!IsEqual(limit, nil)) {
				AddElementToObject(request, "page_size", limit)
			}

			response := (<-this.ContractPrivateGetOrderListOrderDeals(this.Extend(request, params)))
			PanicOnError(response)
			//
			//     {
			//         "success": true,
			//         "code": "0",
			//         "data": [
			//             {
			//                 "id": "299444585",
			//                 "symbol": "STEPN_USDT",
			//                 "side": "1",
			//                 "vol": "1",
			//                 "price": "2.45455",
			//                 "feeCurrency": "USDT",
			//                 "fee": "0.00147273",
			//                 "timestamp": "1648924557000",
			//                 "profit": "0",
			//                 "category": "1",
			//                 "orderId": "265307163526610432",
			//                 "positionMode": "1",
			//                 "taker": true
			//             }
			//         ]
			//     }
			//
			trades = this.SafeValue(response, "data")
		}

		ch <- this.ParseTrades(trades, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name mexc#fetchOrderTrades
 * @description fetch all the trades made from a single order
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#account-trade-list
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#query-the-order-based-on-the-order-number
 * @param {string} id order id
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func (this *mexc) FetchOrderTrades(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes41408 := (<-this.LoadMarkets())
		PanicOnError(retRes41408)
		var request interface{} = map[string]interface{}{}
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
		}
		marketTypequeryVariable := this.HandleMarketTypeAndParams("fetchOrderTrades", market, params)
		marketType := GetValue(marketTypequeryVariable, 0)
		query := GetValue(marketTypequeryVariable, 1)
		var trades interface{} = nil
		if IsTrue(IsEqual(marketType, "spot")) {
			if IsTrue(IsEqual(symbol, nil)) {
				panic(ArgumentsRequired(Add(this.Id, " fetchOrderTrades() requires a symbol argument")))
			}
			AddElementToObject(request, "symbol", GetValue(market, "id"))
			AddElementToObject(request, "orderId", id)

			trades = (<-this.SpotPrivateGetMyTrades(this.Extend(request, query)))
			PanicOnError(trades)
		} else {
			AddElementToObject(request, "order_id", id)

			response := (<-this.ContractPrivateGetOrderDealDetailsOrderId(this.Extend(request, query)))
			PanicOnError(response)
			//
			//     {
			//         "success": true,
			//         "code": "0",
			//         "data": [
			//             {
			//                 "id": "299444585",
			//                 "symbol": "STEPN_USDT",
			//                 "side": "1",
			//                 "vol": "1",
			//                 "price": "2.45455",
			//                 "feeCurrency": "USDT",
			//                 "fee": "0.00147273",
			//                 "timestamp": "1648924557000",
			//                 "profit": "0",
			//                 "category": "1",
			//                 "orderId": "265307163526610432",
			//                 "positionMode": "1",
			//                 "taker": true
			//             }
			//         ]
			//     }
			//
			trades = this.SafeValue(response, "data")
		}

		ch <- this.ParseTrades(trades, market, since, limit, query)
		return nil

	}()
	return ch
}
func (this *mexc) ModifyMarginHelper(symbol interface{}, amount interface{}, addOrReduce interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		var positionId interface{} = this.SafeInteger(params, "positionId")
		if IsTrue(IsEqual(positionId, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " modifyMarginHelper() requires a positionId parameter")))
		}

		retRes42128 := (<-this.LoadMarkets())
		PanicOnError(retRes42128)
		var request interface{} = map[string]interface{}{
			"positionId": positionId,
			"amount":     amount,
			"type":       addOrReduce,
		}

		response := (<-this.ContractPrivatePostPositionChangeMargin(this.Extend(request, params)))
		PanicOnError(response)

		//
		//     {
		//         "success": true,
		//         "code": 0
		//     }
		ch <- response
		return nil

	}()
	return ch
}

/**
 * @method
 * @name mexc#reduceMargin
 * @description remove margin from a position
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#increase-or-decrease-margin
 * @param {string} symbol unified market symbol
 * @param {float} amount the amount of margin to remove
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=reduce-margin-structure}
 */
func (this *mexc) ReduceMargin(symbol interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes423815 := (<-this.ModifyMarginHelper(symbol, amount, "SUB", params))
		PanicOnError(retRes423815)
		ch <- retRes423815
		return nil

	}()
	return ch
}

/**
 * @method
 * @name mexc#addMargin
 * @description add margin
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#increase-or-decrease-margin
 * @param {string} symbol unified market symbol
 * @param {float} amount amount of margin to add
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=add-margin-structure}
 */
func (this *mexc) AddMargin(symbol interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes425215 := (<-this.ModifyMarginHelper(symbol, amount, "ADD", params))
		PanicOnError(retRes425215)
		ch <- retRes425215
		return nil

	}()
	return ch
}

/**
 * @method
 * @name mexc#setLeverage
 * @description set the level of leverage for a market
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#switch-leverage
 * @param {float} leverage the rate of leverage
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} response from the exchange
 */
func (this *mexc) SetLeverage(leverage interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes42668 := (<-this.LoadMarkets())
		PanicOnError(retRes42668)
		var request interface{} = map[string]interface{}{
			"leverage": leverage,
		}
		var positionId interface{} = this.SafeInteger(params, "positionId")
		if IsTrue(IsEqual(positionId, nil)) {
			var openType interface{} = this.SafeNumber(params, "openType")         // 1 or 2
			var positionType interface{} = this.SafeNumber(params, "positionType") // 1 or 2
			var market interface{} = Ternary(IsTrue((!IsEqual(symbol, nil))), this.Market(symbol), nil)
			if IsTrue(IsTrue(IsTrue((IsEqual(openType, nil))) || IsTrue((IsEqual(positionType, nil)))) || IsTrue((IsEqual(market, nil)))) {
				panic(ArgumentsRequired(Add(this.Id, " setLeverage() requires a positionId parameter or a symbol argument with openType and positionType parameters, use openType 1 or 2 for isolated or cross margin respectively, use positionType 1 or 2 for long or short positions")))
			} else {
				AddElementToObject(request, "openType", openType)
				AddElementToObject(request, "symbol", GetValue(market, "id"))
				AddElementToObject(request, "positionType", positionType)
			}
		} else {
			AddElementToObject(request, "positionId", positionId)
		}

		retRes428515 := (<-this.ContractPrivatePostPositionChangeLeverage(this.Extend(request, params)))
		PanicOnError(retRes428515)
		ch <- retRes428515
		return nil

	}()
	return ch
}

/**
 * @method
 * @name mexc#fetchFundingHistory
 * @description fetch the history of funding payments paid and received on this account
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-details-of-user-s-funding-rate
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch funding history for
 * @param {int} [limit] the maximum number of funding history structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding history structure]{@link https://docs.ccxt.com/#/?id=funding-history-structure}
 */
func (this *mexc) FetchFundingHistory(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes43008 := (<-this.LoadMarkets())
		PanicOnError(retRes43008)
		var market interface{} = nil
		var request interface{} = map[string]interface{}{}
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			AddElementToObject(request, "symbol", GetValue(market, "id"))
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "page_size", limit)
		}

		response := (<-this.ContractPrivateGetPositionFundingRecords(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "success": true,
		//         "code": 0,
		//         "data": {
		//             "pageSize": 20,
		//             "totalCount": 2,
		//             "totalPage": 1,
		//             "currentPage": 1,
		//             "resultList": [
		//                 {
		//                     "id": 7423910,
		//                     "symbol": "BTC_USDT",
		//                     "positionType": 1,
		//                     "positionValue": 29.30024,
		//                     "funding": 0.00076180624,
		//                     "rate": -0.000026,
		//                     "settleTime": 1643299200000
		//                 },
		//                 {
		//                     "id": 7416473,
		//                     "symbol": "BTC_USDT",
		//                     "positionType": 1,
		//                     "positionValue": 28.9188,
		//                     "funding": 0.0014748588,
		//                     "rate": -0.000051,
		//                     "settleTime": 1643270400000
		//                 }
		//             ]
		//         }
		//     }
		//
		var data interface{} = this.SafeValue(response, "data", map[string]interface{}{})
		var resultList interface{} = this.SafeValue(data, "resultList", []interface{}{})
		var result interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(resultList)); i++ {
			var entry interface{} = GetValue(resultList, i)
			var timestamp interface{} = this.SafeInteger(entry, "settleTime")
			AppendToArray(&result, map[string]interface{}{
				"info":      entry,
				"symbol":    symbol,
				"code":      nil,
				"timestamp": timestamp,
				"datetime":  this.Iso8601(timestamp),
				"id":        this.SafeNumber(entry, "id"),
				"amount":    this.SafeNumber(entry, "funding"),
			})
		}

		ch <- result
		return nil

	}()
	return ch
}
func (this *mexc) ParseFundingRate(contract interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "symbol": "BTC_USDT",
	//         "fundingRate": 0.000014,
	//         "maxFundingRate": 0.003,
	//         "minFundingRate": -0.003,
	//         "collectCycle": 8,
	//         "nextSettleTime": 1643241600000,
	//         "timestamp": 1643240373359
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var nextFundingRate interface{} = this.SafeNumber(contract, "fundingRate")
	var nextFundingTimestamp interface{} = this.SafeInteger(contract, "nextSettleTime")
	var marketId interface{} = this.SafeString(contract, "symbol")
	var symbol interface{} = this.SafeSymbol(marketId, market, nil, "contract")
	var timestamp interface{} = this.SafeInteger(contract, "timestamp")
	var interval interface{} = this.SafeString(contract, "collectCycle")
	var intervalString interface{} = nil
	if IsTrue(!IsEqual(interval, nil)) {
		intervalString = Add(interval, "h")
	}
	return map[string]interface{}{
		"info":                     contract,
		"symbol":                   symbol,
		"markPrice":                nil,
		"indexPrice":               nil,
		"interestRate":             nil,
		"estimatedSettlePrice":     nil,
		"timestamp":                timestamp,
		"datetime":                 this.Iso8601(timestamp),
		"fundingRate":              nextFundingRate,
		"fundingTimestamp":         nextFundingTimestamp,
		"fundingDatetime":          this.Iso8601(nextFundingTimestamp),
		"nextFundingRate":          nil,
		"nextFundingTimestamp":     nil,
		"nextFundingDatetime":      nil,
		"previousFundingRate":      nil,
		"previousFundingTimestamp": nil,
		"previousFundingDatetime":  nil,
		"interval":                 intervalString,
	}
}

/**
 * @method
 * @name mexc#fetchFundingInterval
 * @description fetch the current funding rate interval
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-contract-funding-rate
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
 */
func (this *mexc) FetchFundingInterval(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes442115 := (<-this.FetchFundingRate(symbol, params))
		PanicOnError(retRes442115)
		ch <- retRes442115
		return nil

	}()
	return ch
}

/**
 * @method
 * @name mexc#fetchFundingRate
 * @description fetch the current funding rate
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-contract-funding-rate
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
 */
func (this *mexc) FetchFundingRate(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes44348 := (<-this.LoadMarkets())
		PanicOnError(retRes44348)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}

		response := (<-this.ContractPublicGetFundingRateSymbol(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "success": true,
		//         "code": 0,
		//         "data": {
		//             "symbol": "BTC_USDT",
		//             "fundingRate": 0.000014,
		//             "maxFundingRate": 0.003,
		//             "minFundingRate": -0.003,
		//             "collectCycle": 8,
		//             "nextSettleTime": 1643241600000,
		//             "timestamp": 1643240373359
		//         }
		//     }
		//
		var result interface{} = this.SafeValue(response, "data", map[string]interface{}{})

		ch <- this.ParseFundingRate(result, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name mexc#fetchFundingRateHistory
 * @description fetches historical funding rate prices
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-contract-funding-rate-history
 * @param {string} symbol unified symbol of the market to fetch the funding rate history for
 * @param {int} [since] not used by mexc, but filtered internally by ccxt
 * @param {int} [limit] mexc limit is page_size default 20, maximum is 100
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
 */
func (this *mexc) FetchFundingRateHistory(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchFundingRateHistory() requires a symbol argument")))
		}

		retRes44748 := (<-this.LoadMarkets())
		PanicOnError(retRes44748)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "page_size", limit)
		}

		response := (<-this.ContractPublicGetFundingRateHistory(this.Extend(request, params)))
		PanicOnError(response)
		//
		//    {
		//        "success": true,
		//        "code": 0,
		//        "data": {
		//            "pageSize": 2,
		//            "totalCount": 21,
		//            "totalPage": 11,
		//            "currentPage": 1,
		//            "resultList": [
		//                {
		//                    "symbol": "BTC_USDT",
		//                    "fundingRate": 0.000266,
		//                    "settleTime": 1609804800000
		//                },
		//                {
		//                    "symbol": "BTC_USDT",
		//                    "fundingRate": 0.00029,
		//                    "settleTime": 1609776000000
		//                }
		//            ]
		//        }
		//    }
		//
		var data interface{} = this.SafeValue(response, "data")
		var result interface{} = this.SafeValue(data, "resultList", []interface{}{})
		var rates interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(result)); i++ {
			var entry interface{} = GetValue(result, i)
			var marketId interface{} = this.SafeString(entry, "symbol")
			var symbolInner interface{} = this.SafeSymbol(marketId)
			var timestamp interface{} = this.SafeInteger(entry, "settleTime")
			AppendToArray(&rates, map[string]interface{}{
				"info":        entry,
				"symbol":      symbolInner,
				"fundingRate": this.SafeNumber(entry, "fundingRate"),
				"timestamp":   timestamp,
				"datetime":    this.Iso8601(timestamp),
			})
		}
		var sorted interface{} = this.SortBy(rates, "timestamp")

		ch <- this.FilterBySymbolSinceLimit(sorted, GetValue(market, "symbol"), since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name mexc#fetchLeverageTiers
 * @description retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes, if a market has a leverage tier of 0, then the leverage tiers cannot be obtained for this market
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-the-contract-information
 * @param {string[]} [symbols] list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [leverage tiers structures]{@link https://docs.ccxt.com/#/?id=leverage-tiers-structure}, indexed by market symbols
 */
func (this *mexc) FetchLeverageTiers(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes45398 := (<-this.LoadMarkets())
		PanicOnError(retRes45398)
		symbols = this.MarketSymbols(symbols, "swap", true, true)

		response := (<-this.ContractPublicGetDetail(params))
		PanicOnError(response)
		//
		//     {
		//         "success":true,
		//         "code":0,
		//         "data":[
		//             {
		//                 "symbol": "BTC_USDT",
		//                 "displayName": "BTC_USDT永续",
		//                 "displayNameEn": "BTC_USDT SWAP",
		//                 "positionOpenType": 3,
		//                 "baseCoin": "BTC",
		//                 "quoteCoin": "USDT",
		//                 "settleCoin": "USDT",
		//                 "contractSize": 0.0001,
		//                 "minLeverage": 1,
		//                 "maxLeverage": 125,
		//                 "priceScale": 2,
		//                 "volScale": 0,
		//                 "amountScale": 4,
		//                 "priceUnit": 0.5,
		//                 "volUnit": 1,
		//                 "minVol": 1,
		//                 "maxVol": 1000000,
		//                 "bidLimitPriceRate": 0.1,
		//                 "askLimitPriceRate": 0.1,
		//                 "takerFeeRate": 0.0006,
		//                 "makerFeeRate": 0.0002,
		//                 "maintenanceMarginRate": 0.004,
		//                 "initialMarginRate": 0.008,
		//                 "riskBaseVol": 10000,
		//                 "riskIncrVol": 200000,
		//                 "riskIncrMmr": 0.004,
		//                 "riskIncrImr": 0.004,
		//                 "riskLevelLimit": 5,
		//                 "priceCoefficientVariation": 0.1,
		//                 "indexOrigin": ["BINANCE","GATEIO","HUOBI","MXC"],
		//                 "state": 0, // 0 enabled, 1 delivery, 2 completed, 3 offline, 4 pause
		//                 "isNew": false,
		//                 "isHot": true,
		//                 "isHidden": false
		//             },
		//             ...
		//         ]
		//     }
		//
		var data interface{} = this.SafeList(response, "data")

		ch <- this.ParseLeverageTiers(data, symbols, "symbol")
		return nil

	}()
	return ch
}
func (this *mexc) ParseMarketLeverageTiers(info interface{}, optionalArgs ...interface{}) interface{} {
	//
	//    {
	//        "symbol": "BTC_USDT",
	//        "displayName": "BTC_USDT永续",
	//        "displayNameEn": "BTC_USDT SWAP",
	//        "positionOpenType": 3,
	//        "baseCoin": "BTC",
	//        "quoteCoin": "USDT",
	//        "settleCoin": "USDT",
	//        "contractSize": 0.0001,
	//        "minLeverage": 1,
	//        "maxLeverage": 125,
	//        "priceScale": 2,
	//        "volScale": 0,
	//        "amountScale": 4,
	//        "priceUnit": 0.5,
	//        "volUnit": 1,
	//        "minVol": 1,
	//        "maxVol": 1000000,
	//        "bidLimitPriceRate": 0.1,
	//        "askLimitPriceRate": 0.1,
	//        "takerFeeRate": 0.0006,
	//        "makerFeeRate": 0.0002,
	//        "maintenanceMarginRate": 0.004,
	//        "initialMarginRate": 0.008,
	//        "riskBaseVol": 10000,
	//        "riskIncrVol": 200000,
	//        "riskIncrMmr": 0.004,
	//        "riskIncrImr": 0.004,
	//        "riskLevelLimit": 5,
	//        "priceCoefficientVariation": 0.1,
	//        "indexOrigin": ["BINANCE","GATEIO","HUOBI","MXC"],
	//        "state": 0, // 0 enabled, 1 delivery, 2 completed, 3 offline, 4 pause
	//        "isNew": false,
	//        "isHot": true,
	//        "isHidden": false
	//    }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(info, "symbol")
	var maintenanceMarginRate interface{} = this.SafeString(info, "maintenanceMarginRate")
	var initialMarginRate interface{} = this.SafeString(info, "initialMarginRate")
	var maxVol interface{} = this.SafeString(info, "maxVol")
	var riskIncrVol interface{} = this.SafeString(info, "riskIncrVol")
	var riskIncrMmr interface{} = this.SafeString(info, "riskIncrMmr")
	var riskIncrImr interface{} = this.SafeString(info, "riskIncrImr")
	var floor interface{} = "0"
	var tiers interface{} = []interface{}{}
	var quoteId interface{} = this.SafeString(info, "quoteCoin")
	if IsTrue(IsEqual(riskIncrVol, "0")) {
		return []interface{}{map[string]interface{}{
			"tier":                  0,
			"symbol":                this.SafeSymbol(marketId, market, nil, "contract"),
			"currency":              this.SafeCurrencyCode(quoteId),
			"minNotional":           nil,
			"maxNotional":           nil,
			"maintenanceMarginRate": nil,
			"maxLeverage":           this.SafeNumber(info, "maxLeverage"),
			"info":                  info,
		}}
	}
	for Precise.StringLt(floor, maxVol) {
		var cap interface{} = Precise.StringAdd(floor, riskIncrVol)
		AppendToArray(&tiers, map[string]interface{}{
			"tier":                  this.ParseNumber(Precise.StringDiv(cap, riskIncrVol)),
			"symbol":                this.SafeSymbol(marketId, market, nil, "contract"),
			"currency":              this.SafeCurrencyCode(quoteId),
			"minNotional":           this.ParseNumber(floor),
			"maxNotional":           this.ParseNumber(cap),
			"maintenanceMarginRate": this.ParseNumber(maintenanceMarginRate),
			"maxLeverage":           this.ParseNumber(Precise.StringDiv("1", initialMarginRate)),
			"info":                  info,
		})
		initialMarginRate = Precise.StringAdd(initialMarginRate, riskIncrImr)
		maintenanceMarginRate = Precise.StringAdd(maintenanceMarginRate, riskIncrMmr)
		floor = cap
	}
	return tiers
}
func (this *mexc) ParseDepositAddress(depositAddress interface{}, optionalArgs ...interface{}) interface{} {
	//
	//    {
	//        coin: "USDT",
	//        network: "BNB Smart Chain(BEP20)",
	//        address: "0x0d48003e0c27c5de62b97c9b4cdb31fdd29da619",
	//        memo:  null
	//    }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var address interface{} = this.SafeString(depositAddress, "address")
	var currencyId interface{} = this.SafeString(depositAddress, "coin")
	var networkId interface{} = this.SafeString(depositAddress, "netWork")
	this.CheckAddress(address)
	return map[string]interface{}{
		"info":     depositAddress,
		"currency": this.SafeCurrencyCode(currencyId, currency),
		"network":  this.NetworkIdToCode(networkId, currencyId),
		"address":  address,
		"tag":      this.SafeString(depositAddress, "memo"),
	}
}

/**
 * @method
 * @name mexc#fetchDepositAddressesByNetwork
 * @description fetch a dictionary of addresses for a currency, indexed by network
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#deposit-address-supporting-network
 * @param {string} code unified currency code of the currency for the deposit address
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [address structures]{@link https://docs.ccxt.com/#/?id=address-structure} indexed by the network
 */
func (this *mexc) FetchDepositAddressesByNetwork(code interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes47058 := (<-this.LoadMarkets())
		PanicOnError(retRes47058)
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"coin": GetValue(currency, "id"),
		}
		var networkCode interface{} = this.SafeString(params, "network")
		var networkId interface{} = nil
		if IsTrue(!IsEqual(networkCode, nil)) {
			// createDepositAddress and fetchDepositAddress use a different network-id compared to withdraw
			var networkUnified interface{} = this.NetworkIdToCode(networkCode, code)
			var networks interface{} = this.SafeDict(currency, "networks", map[string]interface{}{})
			if IsTrue(InOp(networks, networkUnified)) {
				var network interface{} = this.SafeDict(networks, networkUnified, map[string]interface{}{})
				var networkInfo interface{} = this.SafeValue(network, "info", map[string]interface{}{})
				networkId = this.SafeString(networkInfo, "network")
			} else {
				networkId = this.NetworkCodeToId(networkCode, code)
			}
		}
		if IsTrue(!IsEqual(networkId, nil)) {
			AddElementToObject(request, "network", networkId)
		}
		params = this.Omit(params, "network")

		response := (<-this.SpotPrivateGetCapitalDepositAddress(this.Extend(request, params)))
		PanicOnError(response)
		//
		//    [
		//        {
		//            coin: "USDT",
		//            network: "BNB Smart Chain(BEP20)",
		//            address: "0x0d48003e0c27c5de62b97c9b4cdb31fdd29da619",
		//            memo:  null
		//        }
		//        ...
		//    ]
		//
		var addressStructures interface{} = this.ParseDepositAddresses(response, nil, false)

		ch <- this.IndexBy(addressStructures, "network")
		return nil

	}()
	return ch
}

/**
 * @method
 * @name mexc#createDepositAddress
 * @description create a currency deposit address
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#generate-deposit-address-supporting-network
 * @param {string} code unified currency code of the currency for the deposit address
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.network] the blockchain network name
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func (this *mexc) CreateDepositAddress(code interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes47558 := (<-this.LoadMarkets())
		PanicOnError(retRes47558)
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"coin": GetValue(currency, "id"),
		}
		var networkCode interface{} = this.SafeString(params, "network")
		if IsTrue(IsEqual(networkCode, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " createDepositAddress requires a `network` parameter")))
		}
		// createDepositAddress and fetchDepositAddress use a different network-id compared to withdraw
		var networkId interface{} = nil
		var networkUnified interface{} = this.NetworkIdToCode(networkCode, code)
		var networks interface{} = this.SafeDict(currency, "networks", map[string]interface{}{})
		if IsTrue(InOp(networks, networkUnified)) {
			var network interface{} = this.SafeDict(networks, networkUnified, map[string]interface{}{})
			var networkInfo interface{} = this.SafeValue(network, "info", map[string]interface{}{})
			networkId = this.SafeString(networkInfo, "network")
		} else {
			networkId = this.NetworkCodeToId(networkCode, code)
		}
		if IsTrue(!IsEqual(networkId, nil)) {
			AddElementToObject(request, "network", networkId)
		}
		params = this.Omit(params, "network")

		response := (<-this.SpotPrivatePostCapitalDepositAddress(this.Extend(request, params)))
		PanicOnError(response)

		//     {
		//        "coin": "EOS",
		//        "network": "EOS",
		//        "address": "zzqqqqqqqqqq",
		//        "memo": "MX10068"
		//     }
		ch <- this.ParseDepositAddress(response, currency)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name mexc#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#deposit-address-supporting-network
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.network] the chain of currency, this only apply for multi-chain currency, and there is no need for single chain currency
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func (this *mexc) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		var network interface{} = this.SafeString(params, "network")
		var addressStructures interface{} = (<-this.FetchDepositAddressesByNetwork(code, params))
		var result interface{} = nil
		if IsTrue(!IsEqual(network, nil)) {
			result = this.SafeDict(addressStructures, this.NetworkIdToCode(network, code))
		} else {
			var options interface{} = this.SafeDict(this.Options, "defaultNetworks")
			var defaultNetworkForCurrency interface{} = this.SafeString(options, code)
			if IsTrue(!IsEqual(defaultNetworkForCurrency, nil)) {
				result = this.SafeDict(addressStructures, defaultNetworkForCurrency)
			} else {
				var keys interface{} = ObjectKeys(addressStructures)
				var key interface{} = this.SafeString(keys, 0)
				result = this.SafeDict(addressStructures, key)
			}
		}
		if IsTrue(IsEqual(result, nil)) {
			panic(InvalidAddress(Add(Add(Add(Add(Add(this.Id, " fetchDepositAddress() cannot find a deposit address for "), code), ", and network"), network), "consider creating one using .createDepositAddress() method or in MEXC website")))
		}

		ch <- result
		return nil

	}()
	return ch
}

/**
 * @method
 * @name mexc#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#deposit-history-supporting-network
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func (this *mexc) FetchDeposits(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes48348 := (<-this.LoadMarkets())
		PanicOnError(retRes48348)
		var request interface{} = map[string]interface{}{}
		var currency interface{} = nil
		if IsTrue(!IsEqual(code, nil)) {
			currency = this.Currency(code)
			AddElementToObject(request, "coin", GetValue(currency, "id"))
			// currently mexc does not have network names unified so for certain things we might need TRX or TRC-20
			// due to that I'm applying the network parameter directly so the user can control it on its side
			var rawNetwork interface{} = this.SafeString(params, "network")
			if IsTrue(!IsEqual(rawNetwork, nil)) {
				params = this.Omit(params, "network")
				AddElementToObject(request, "coin", Add(Add(GetValue(request, "coin"), "-"), rawNetwork))
			}
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			if IsTrue(IsGreaterThan(limit, 1000)) {
				panic(ExchangeError("This exchange supports a maximum limit of 1000"))
			}
			AddElementToObject(request, "limit", limit)
		}

		response := (<-this.SpotPrivateGetCapitalDepositHisrec(this.Extend(request, params)))
		PanicOnError(response)

		//
		// [
		//     {
		//         "amount": "10",
		//         "coin": "USDC-TRX",
		//         "network": "TRX",
		//         "status": "5",
		//         "address": "TSMcEDDvkqY9dz8RkFnrS86U59GwEZjfvh",
		//         "txId": "51a8f49e6f03f2c056e71fe3291aa65e1032880be855b65cecd0595a1b8af95b:0",
		//         "insertTime": "1664805021000",
		//         "unlockConfirm": "200",
		//         "confirmTimes": "203",
		//         "memo": "xxyy1122",
		//         "transHash": "51a8f49e6f03f2c056e71fe3291aa65e1032880be855b65cecd0595a1b8af95b",
		//         "updateTime": "1664805621000",
		//         "netWork: "TRX"
		//     }
		// ]
		//
		ch <- this.ParseTransactions(response, currency, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name mexc#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#withdraw-history-supporting-network
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawals structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func (this *mexc) FetchWithdrawals(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes48988 := (<-this.LoadMarkets())
		PanicOnError(retRes48988)
		var request interface{} = map[string]interface{}{}
		var currency interface{} = nil
		if IsTrue(!IsEqual(code, nil)) {
			currency = this.Currency(code)
			AddElementToObject(request, "coin", GetValue(currency, "id"))
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			if IsTrue(IsGreaterThan(limit, 1000)) {
				panic(ExchangeError("This exchange supports a maximum limit of 1000"))
			}
			AddElementToObject(request, "limit", limit)
		}

		response := (<-this.SpotPrivateGetCapitalWithdrawHistory(this.Extend(request, params)))
		PanicOnError(response)

		//
		// [
		//     {
		//       "id": "adcd1c8322154de691b815eedcd10c42",
		//       "txId": "0xc8c918cd69b2246db493ef6225a72ffdc664f15b08da3e25c6879b271d05e9d0:0",
		//       "coin": "USDC-MATIC",
		//       "network": "MATIC",
		//       "address": "0xeE6C7a415995312ED52c53a0f8f03e165e0A5D62",
		//       "amount": "2",
		//       "transferType": "0",
		//       "status": "7",
		//       "transactionFee": "1",
		//       "confirmNo": null,
		//       "applyTime": "1664882739000",
		//       "remark": '',
		//       "memo": null,
		//       "explorerUrl": "https://etherscan.io/tx/0xc8c918cd69b2246db493ef6225a72ffdc664f15b08da3e25c6879b271d05e9d0",
		//       "transHash": "0xc8c918cd69b2246db493ef6225a72ffdc664f15b08da3e25c6879b271d05e9d0",
		//       "updateTime": "1664882799000",
		//       "netWork: "MATIC"
		//     }
		// ]
		//
		ch <- this.ParseTransactions(response, currency, since, limit)
		return nil

	}()
	return ch
}
func (this *mexc) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{} {
	//
	// fetchDeposits
	//
	// {
	//     "amount": "10",
	//     "coin": "USDC-TRX",
	//     "network": "TRX",
	//     "status": "5",
	//     "address": "TSMcEDDvkqY9dz8RkFnrS86U59GwEZjfvh",
	//     "txId": "51a8f49e6f03f2c056e71fe3291aa65e1032880be855b65cecd0595a1b8af95b:0",
	//     "insertTime": "1664805021000",
	//     "unlockConfirm": "200",
	//     "confirmTimes": "203",
	//     "memo": "xxyy1122",
	//     "transHash": "51a8f49e6f03f2c056e71fe3291aa65e1032880be855b65cecd0595a1b8af95b",
	//     "updateTime": "1664805621000",
	//     "netWork: "TRX"
	// }
	//
	// fetchWithdrawals
	//
	// {
	//     "id": "adcd1c8322154de691b815eedcd10c42",
	//     "txId": "0xc8c918cd69b2246db493ef6225a72ffdc664f15b08da3e25c6879b271d05e9d0:0",
	//     "coin": "USDC-MATIC",
	//     "network": "MATIC",
	//     "address": "0xeE6C7a415995312ED52c53a0f8f03e165e0A5D62",
	//     "amount": "2",
	//     "transferType": "0",
	//     "status": "7",
	//     "transactionFee": "1",
	//     "confirmNo": null,
	//     "applyTime": "1664882739000",
	//     "remark": "",
	//     "memo": null,
	//     "explorerUrl": "https://etherscan.io/tx/0xc8c918cd69b2246db493ef6225a72ffdc664f15b08da3e25c6879b271d05e9d0",
	//     "transHash": "0xc8c918cd69b2246db493ef6225a72ffdc664f15b08da3e25c6879b271d05e9d0",
	//     "updateTime": "1664882799000",
	//     "netWork: "MATIC"
	//   }
	//
	// withdraw
	//
	//     {
	//         "id":"25fb2831fb6d4fc7aa4094612a26c81d"
	//     }
	//
	// internal withdraw (aka internal-transfer)
	//
	//     {
	//         "tranId":"ad36f0e9c9a24ae794b36fa4f152e471"
	//     }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var id interface{} = this.SafeString2(transaction, "id", "tranId")
	var typeVar interface{} = Ternary(IsTrue((IsEqual(id, nil))), "deposit", "withdrawal")
	var timestamp interface{} = this.SafeInteger2(transaction, "insertTime", "applyTime")
	var updated interface{} = this.SafeInteger(transaction, "updateTime")
	var currencyId interface{} = nil
	var currencyWithNetwork interface{} = this.SafeString(transaction, "coin")
	if IsTrue(!IsEqual(currencyWithNetwork, nil)) {
		currencyId = GetValue(Split(currencyWithNetwork, "-"), 0)
	}
	var network interface{} = nil
	var rawNetwork interface{} = this.SafeString(transaction, "network")
	if IsTrue(!IsEqual(rawNetwork, nil)) {
		network = this.NetworkIdToCode(rawNetwork)
	}
	var code interface{} = this.SafeCurrencyCode(currencyId, currency)
	var status interface{} = this.ParseTransactionStatusByType(this.SafeString(transaction, "status"), typeVar)
	var amountString interface{} = this.SafeString(transaction, "amount")
	var address interface{} = this.SafeString(transaction, "address")
	var txid interface{} = this.SafeString2(transaction, "transHash", "txId")
	var fee interface{} = nil
	var feeCostString interface{} = this.SafeString(transaction, "transactionFee")
	if IsTrue(!IsEqual(feeCostString, nil)) {
		fee = map[string]interface{}{
			"cost":     this.ParseNumber(feeCostString),
			"currency": code,
		}
	}
	if IsTrue(IsEqual(typeVar, "withdrawal")) {
		// mexc withdrawal amount includes the fee
		amountString = Precise.StringSub(amountString, feeCostString)
	}
	return map[string]interface{}{
		"info":        transaction,
		"id":          id,
		"txid":        txid,
		"timestamp":   timestamp,
		"datetime":    this.Iso8601(timestamp),
		"network":     network,
		"address":     address,
		"addressTo":   address,
		"addressFrom": nil,
		"tag":         this.SafeString(transaction, "memo"),
		"tagTo":       nil,
		"tagFrom":     nil,
		"type":        typeVar,
		"amount":      this.ParseNumber(amountString),
		"currency":    code,
		"status":      status,
		"updated":     updated,
		"comment":     this.SafeString(transaction, "remark"),
		"internal":    nil,
		"fee":         fee,
	}
}
func (this *mexc) ParseTransactionStatusByType(status interface{}, optionalArgs ...interface{}) interface{} {
	typeVar := GetArg(optionalArgs, 0, nil)
	_ = typeVar
	var statusesByType interface{} = map[string]interface{}{
		"deposit": map[string]interface{}{
			"1": "failed",
			"2": "pending",
			"3": "pending",
			"4": "pending",
			"5": "ok",
			"6": "pending",
			"7": "failed",
		},
		"withdrawal": map[string]interface{}{
			"1":  "pending",
			"2":  "pending",
			"3":  "pending",
			"4":  "pending",
			"5":  "pending",
			"6":  "pending",
			"7":  "ok",
			"8":  "failed",
			"9":  "canceled",
			"10": "pending",
		},
	}
	var statuses interface{} = this.SafeValue(statusesByType, typeVar, map[string]interface{}{})
	return this.SafeString(statuses, status, status)
}

/**
 * @method
 * @name mexc#fetchPosition
 * @description fetch data on a single open contract trade position
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-the-user-s-history-position-information
 * @param {string} symbol unified market symbol of the market the position is held in, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func (this *mexc) FetchPosition(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes50948 := (<-this.LoadMarkets())
		PanicOnError(retRes50948)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}

		response := (<-this.FetchPositions(nil, this.Extend(request, params)))
		PanicOnError(response)

		ch <- this.SafeValue(response, 0)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name mexc#fetchPositions
 * @description fetch all open positions
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-the-user-s-history-position-information
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func (this *mexc) FetchPositions(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes51138 := (<-this.LoadMarkets())
		PanicOnError(retRes51138)

		response := (<-this.ContractPrivateGetPositionOpenPositions(params))
		PanicOnError(response)
		//
		//     {
		//         "success": true,
		//         "code": 0,
		//         "data": [
		//             {
		//                 "positionId": 1394650,
		//                 "symbol": "ETH_USDT",
		//                 "positionType": 1,
		//                 "openType": 1,
		//                 "state": 1,
		//                 "holdVol": 1,
		//                 "frozenVol": 0,
		//                 "closeVol": 0,
		//                 "holdAvgPrice": 1217.3,
		//                 "openAvgPrice": 1217.3,
		//                 "closeAvgPrice": 0,
		//                 "liquidatePrice": 1211.2,
		//                 "oim": 0.1290338,
		//                 "im": 0.1290338,
		//                 "holdFee": 0,
		//                 "realised": -0.0073,
		//                 "leverage": 100,
		//                 "createTime": 1609991676000,
		//                 "updateTime": 1609991676000,
		//                 "autoAddIm": false
		//             }
		//         ]
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParsePositions(data, symbols)
		return nil

	}()
	return ch
}
func (this *mexc) ParsePosition(position interface{}, optionalArgs ...interface{}) interface{} {
	//
	// fetchPositions
	//
	//     {
	//         "positionId": 1394650,
	//         "symbol": "ETH_USDT",
	//         "positionType": 1,
	//         "openType": 1,
	//         "state": 1,
	//         "holdVol": 1,
	//         "frozenVol": 0,
	//         "closeVol": 0,
	//         "holdAvgPrice": 1217.3,
	//         "openAvgPrice": 1217.3,
	//         "closeAvgPrice": 0,
	//         "liquidatePrice": 1211.2,
	//         "oim": 0.1290338,
	//         "im": 0.1290338,
	//         "holdFee": 0,
	//         "realised": -0.0073,
	//         "leverage": 100,
	//         "createTime": 1609991676000,
	//         "updateTime": 1609991676000,
	//         "autoAddIm": false
	//     }
	//
	// fetchPositionsHistory
	//
	//    {
	//        positionId: '390281084',
	//        symbol: 'RVN_USDT',
	//        positionType: '1',
	//        openType: '2',
	//        state: '3',
	//        holdVol: '0',
	//        frozenVol: '0',
	//        closeVol: '1141',
	//        holdAvgPrice: '0.03491',
	//        holdAvgPriceFullyScale: '0.03491',
	//        openAvgPrice: '0.03491',
	//        openAvgPriceFullyScale: '0.03491',
	//        closeAvgPrice: '0.03494',
	//        liquidatePrice: '0.03433',
	//        oim: '0',
	//        im: '0',
	//        holdFee: '0',
	//        realised: '0.1829',
	//        leverage: '50',
	//        createTime: '1711512408000',
	//        updateTime: '1711512553000',
	//        autoAddIm: false,
	//        version: '4',
	//        profitRatio: '0.0227',
	//        newOpenAvgPrice: '0.03491',
	//        newCloseAvgPrice: '0.03494',
	//        closeProfitLoss: '0.3423',
	//        fee: '0.1593977',
	//        positionShowStatus: 'CLOSED'
	//    }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	market = this.SafeMarket(this.SafeString(position, "symbol"), market, nil, "swap")
	var symbol interface{} = GetValue(market, "symbol")
	var contracts interface{} = this.SafeString(position, "holdVol")
	var entryPrice interface{} = this.SafeNumber(position, "openAvgPrice")
	var initialMargin interface{} = this.SafeString(position, "im")
	var rawSide interface{} = this.SafeString(position, "positionType")
	var side interface{} = Ternary(IsTrue((IsEqual(rawSide, "1"))), "long", "short")
	var openType interface{} = this.SafeString(position, "margin_mode")
	var marginType interface{} = Ternary(IsTrue((IsEqual(openType, "1"))), "isolated", "cross")
	var leverage interface{} = this.SafeNumber(position, "leverage")
	var liquidationPrice interface{} = this.SafeNumber(position, "liquidatePrice")
	var timestamp interface{} = this.SafeInteger(position, "updateTime")
	return this.SafePosition(map[string]interface{}{
		"info":                        position,
		"id":                          nil,
		"symbol":                      symbol,
		"contracts":                   this.ParseNumber(contracts),
		"contractSize":                nil,
		"entryPrice":                  entryPrice,
		"collateral":                  nil,
		"side":                        side,
		"unrealizedPnl":               nil,
		"leverage":                    this.ParseNumber(leverage),
		"percentage":                  nil,
		"marginMode":                  marginType,
		"notional":                    nil,
		"markPrice":                   nil,
		"lastPrice":                   nil,
		"liquidationPrice":            liquidationPrice,
		"initialMargin":               this.ParseNumber(initialMargin),
		"initialMarginPercentage":     nil,
		"maintenanceMargin":           nil,
		"maintenanceMarginPercentage": nil,
		"marginRatio":                 nil,
		"timestamp":                   timestamp,
		"datetime":                    this.Iso8601(timestamp),
		"hedged":                      nil,
		"stopLossPrice":               nil,
		"takeProfitPrice":             nil,
		"lastUpdateTimestamp":         nil,
	})
}

/**
 * @method
 * @name mexc#fetchTransfer
 * @description fetches a transfer
 * @see https://mexcdevelop.github.io/apidocs/spot_v2_en/#internal-assets-transfer-order-inquiry
 * @param {string} id transfer id
 * @param {string} [code] not used by mexc fetchTransfer
 * @param {object} params extra parameters specific to the exchange api endpoint
 * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func (this *mexc) FetchTransfer(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		marketTypequeryVariable := this.HandleMarketTypeAndParams("fetchTransfer", nil, params)
		marketType := GetValue(marketTypequeryVariable, 0)
		query := GetValue(marketTypequeryVariable, 1)

		retRes52658 := (<-this.LoadMarkets())
		PanicOnError(retRes52658)
		if IsTrue(IsEqual(marketType, "spot")) {
			var request interface{} = map[string]interface{}{
				"transact_id": id,
			}

			response := (<-this.Spot2PrivateGetAssetInternalTransferInfo(this.Extend(request, query)))
			PanicOnError(response)
			//
			//     {
			//         "code": "200",
			//         "data": {
			//             "currency": "USDT",
			//             "amount": "1",
			//             "transact_id": "954877a2ef54499db9b28a7cf9ebcf41",
			//             "from": "MAIN",
			//             "to": "CONTRACT",
			//             "transact_state": "SUCCESS"
			//         }
			//     }
			//
			var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})

			ch <- this.ParseTransfer(data)
			return nil
		} else if IsTrue(IsEqual(marketType, "swap")) {
			panic(BadRequest(Add(Add(this.Id, " fetchTransfer() is not supported for "), marketType)))
		}

		return nil

	}()
	return ch
}

/**
 * @method
 * @name mexc#fetchTransfers
 * @description fetch a history of internal transfers made on an account
 * @see https://mexcdevelop.github.io/apidocs/spot_v2_en/#get-internal-assets-transfer-records
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-the-user-39-s-asset-transfer-records
 * @param {string} code unified currency code of the currency transferred
 * @param {int} [since] the earliest time in ms to fetch transfers for
 * @param {int} [limit] the maximum number of  transfers structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transfer structures]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func (this *mexc) FetchTransfers(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		marketTypequeryVariable := this.HandleMarketTypeAndParams("fetchTransfers", nil, params)
		marketType := GetValue(marketTypequeryVariable, 0)
		query := GetValue(marketTypequeryVariable, 1)

		retRes53068 := (<-this.LoadMarkets())
		PanicOnError(retRes53068)
		var request interface{} = map[string]interface{}{}
		var currency interface{} = nil
		var resultList interface{} = nil
		if IsTrue(!IsEqual(code, nil)) {
			currency = this.Currency(code)
			AddElementToObject(request, "currency", GetValue(currency, "id"))
		}
		if IsTrue(IsEqual(marketType, "spot")) {
			if IsTrue(!IsEqual(since, nil)) {
				AddElementToObject(request, "start_time", since)
			}
			if IsTrue(!IsEqual(limit, nil)) {
				if IsTrue(IsGreaterThan(limit, 50)) {
					panic(ExchangeError("This exchange supports a maximum limit of 50"))
				}
				AddElementToObject(request, "page-size", limit)
			}

			response := (<-this.Spot2PrivateGetAssetInternalTransferRecord(this.Extend(request, query)))
			PanicOnError(response)
			//
			//     {
			//         "code": "200",
			//         "data": {
			//             "total_page": "1",
			//             "total_size": "5",
			//             "result_list": [{
			//                     "currency": "USDT",
			//                     "amount": "1",
			//                     "transact_id": "954877a2ef54499db9b28a7cf9ebcf41",
			//                     "from": "MAIN",
			//                     "to": "CONTRACT",
			//                     "transact_state": "SUCCESS"
			//                 },
			//                 ...
			//             ]
			//         }
			//     }
			//
			var data interface{} = this.SafeValue(response, "data", map[string]interface{}{})
			resultList = this.SafeValue(data, "result_list", []interface{}{})
		} else if IsTrue(IsEqual(marketType, "swap")) {
			if IsTrue(!IsEqual(limit, nil)) {
				AddElementToObject(request, "page_size", limit)
			}

			response := (<-this.ContractPrivateGetAccountTransferRecord(this.Extend(request, query)))
			PanicOnError(response)
			var data interface{} = this.SafeValue(response, "data")
			resultList = this.SafeValue(data, "resultList")
		}

		ch <- this.ParseTransfers(resultList, currency, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name mexc#transfer
 * @description transfer currency internally between wallets on the same account
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#user-universal-transfer
 * @param {string} code unified currency code
 * @param {float} amount amount to transfer
 * @param {string} fromAccount account to transfer from
 * @param {string} toAccount account to transfer to
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.symbol] market symbol required for margin account transfers eg:BTCUSDT
 * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func (this *mexc) Transfer(code interface{}, amount interface{}, fromAccount interface{}, toAccount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes53958 := (<-this.LoadMarkets())
		PanicOnError(retRes53958)
		var currency interface{} = this.Currency(code)
		var accounts interface{} = map[string]interface{}{
			"spot":   "SPOT",
			"swap":   "FUTURES",
			"margin": "ISOLATED_MARGIN",
		}
		var fromId interface{} = this.SafeString(accounts, fromAccount)
		var toId interface{} = this.SafeString(accounts, toAccount)
		if IsTrue(IsEqual(fromId, nil)) {
			var keys interface{} = ObjectKeys(accounts)
			panic(ExchangeError(Add(Add(this.Id, " fromAccount must be one of "), Join(keys, ", "))))
		}
		if IsTrue(IsEqual(toId, nil)) {
			var keys interface{} = ObjectKeys(accounts)
			panic(ExchangeError(Add(Add(this.Id, " toAccount must be one of "), Join(keys, ", "))))
		}
		var request interface{} = map[string]interface{}{
			"asset":           GetValue(currency, "id"),
			"amount":          amount,
			"fromAccountType": fromId,
			"toAccountType":   toId,
		}
		if IsTrue(IsTrue((IsEqual(fromId, "ISOLATED_MARGIN"))) || IsTrue((IsEqual(toId, "ISOLATED_MARGIN")))) {
			var symbol interface{} = this.SafeString(params, "symbol")
			params = this.Omit(params, "symbol")
			if IsTrue(IsEqual(symbol, nil)) {
				panic(ArgumentsRequired(Add(this.Id, " transfer() requires a symbol argument for isolated margin")))
			}
			var market interface{} = this.Market(symbol)
			AddElementToObject(request, "symbol", GetValue(market, "id"))
		}

		response := (<-this.SpotPrivatePostCapitalTransfer(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "tranId": "ebb06123e6a64f4ab234b396c548d57e"
		//     }
		//
		var transaction interface{} = this.ParseTransfer(response, currency)

		ch <- this.Extend(transaction, map[string]interface{}{
			"amount":      amount,
			"fromAccount": fromAccount,
			"toAccount":   toAccount,
		})
		return nil

	}()
	return ch
}
func (this *mexc) ParseTransfer(transfer interface{}, optionalArgs ...interface{}) interface{} {
	//
	// spot: fetchTransfer
	//
	//     {
	//         "currency": "USDT",
	//         "amount": "1",
	//         "transact_id": "b60c1df8e7b24b268858003f374ecb75",
	//         "from": "MAIN",
	//         "to": "CONTRACT",
	//         "transact_state": "WAIT"
	//     }
	//
	// swap: fetchTransfer
	//
	//     {
	//         "currency": "USDT",
	//         "amount": "22.90213135",
	//         "txid": "fa8a1e7bf05940a3b7025856dc48d025",
	//         "id": "2980812",
	//         "type": "IN",
	//         "state": "SUCCESS",
	//         "createTime": "1648849076000",
	//         "updateTime": "1648849076000"
	//     }
	//
	// transfer
	//
	//     {
	//         "tranId": "ebb06123e6a64f4ab234b396c548d57e"
	//     }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var currencyId interface{} = this.SafeString(transfer, "currency")
	var id interface{} = this.SafeStringN(transfer, []interface{}{"transact_id", "txid", "tranId"})
	var timestamp interface{} = this.SafeInteger(transfer, "createTime")
	var datetime interface{} = Ternary(IsTrue((!IsEqual(timestamp, nil))), this.Iso8601(timestamp), nil)
	var direction interface{} = this.SafeString(transfer, "type")
	var accountFrom interface{} = nil
	var accountTo interface{} = nil
	if IsTrue(!IsEqual(direction, nil)) {
		accountFrom = Ternary(IsTrue((IsEqual(direction, "IN"))), "MAIN", "CONTRACT")
		accountTo = Ternary(IsTrue((IsEqual(direction, "IN"))), "CONTRACT", "MAIN")
	} else {
		accountFrom = this.SafeString(transfer, "from")
		accountTo = this.SafeString(transfer, "to")
	}
	return map[string]interface{}{
		"info":        transfer,
		"id":          id,
		"timestamp":   timestamp,
		"datetime":    datetime,
		"currency":    this.SafeCurrencyCode(currencyId, currency),
		"amount":      this.SafeNumber(transfer, "amount"),
		"fromAccount": this.ParseAccountId(accountFrom),
		"toAccount":   this.ParseAccountId(accountTo),
		"status":      this.ParseTransferStatus(this.SafeString2(transfer, "transact_state", "state")),
	}
}
func (this *mexc) ParseAccountId(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"MAIN":     "spot",
		"CONTRACT": "swap",
	}
	return this.SafeString(statuses, status, status)
}
func (this *mexc) ParseTransferStatus(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"SUCCESS": "ok",
		"FAILED":  "failed",
		"WAIT":    "pending",
	}
	return this.SafeString(statuses, status, status)
}

/**
 * @method
 * @name mexc#withdraw
 * @description make a withdrawal
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#withdraw-new
 * @see https://www.mexc.com/api-docs/spot-v3/wallet-endpoints#internal-transfer
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {object} [params.internal] false by default, set to true for an "internal transfer"
 * @param {object} [params.toAccountType] skipped by default, set to 'EMAIL|UID|MOBILE' when making an "internal transfer"
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func (this *mexc) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		tag := GetArg(optionalArgs, 0, nil)
		_ = tag
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes55338 := (<-this.LoadMarkets())
		PanicOnError(retRes55338)
		var currency interface{} = this.Currency(code)
		tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params)
		tag = GetValue(tagparamsVariable, 0)
		params = GetValue(tagparamsVariable, 1)
		var internal interface{} = this.SafeBool(params, "internal", false)
		if IsTrue(internal) {
			params = this.Omit(params, "internal")
			var requestForInternal interface{} = map[string]interface{}{
				"asset":     GetValue(currency, "id"),
				"amount":    amount,
				"toAccount": address,
			}
			var toAccountType interface{} = this.SafeString(params, "toAccountType")
			if IsTrue(IsEqual(toAccountType, nil)) {
				panic(ArgumentsRequired(Add(this.Id, " withdraw() requires a toAccountType parameter for internal transfer to be of: EMAIL | UID | MOBILE")))
			}

			responseForInternal := (<-this.SpotPrivatePostCapitalTransferInternal(this.Extend(requestForInternal, params)))
			PanicOnError(responseForInternal)

			//
			//     {
			//       "id":"7213fea8e94b4a5593d507237e5a555b"
			//     }
			//
			ch <- this.ParseTransaction(responseForInternal, currency)
			return nil
		}
		var networks interface{} = this.SafeDict(this.Options, "networks", map[string]interface{}{})
		var network interface{} = this.SafeString2(params, "network", "netWork") // this line allows the user to specify either ERC20 or ETH
		network = this.SafeString(networks, network, network)                    // handle ETH > ERC-20 alias
		network = this.NetworkCodeToId(network, GetValue(currency, "code"))
		this.CheckAddress(address)
		var request interface{} = map[string]interface{}{
			"coin":    GetValue(currency, "id"),
			"address": address,
			"amount":  amount,
		}
		if IsTrue(!IsEqual(tag, nil)) {
			AddElementToObject(request, "memo", tag)
		}
		if IsTrue(!IsEqual(network, nil)) {
			AddElementToObject(request, "netWork", network)
			params = this.Omit(params, []interface{}{"network", "netWork"})
		}

		response := (<-this.SpotPrivatePostCapitalWithdraw(this.Extend(request, params)))
		PanicOnError(response)

		//
		//     {
		//       "id":"7213fea8e94b4a5593d507237e5a555b"
		//     }
		//
		ch <- this.ParseTransaction(response, currency)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name mexc#setPositionMode
 * @description set hedged to true or false for a market
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#change-position-mode
 * @param {bool} hedged set to true to use dualSidePosition
 * @param {string} symbol not used by mexc setPositionMode ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} response from the exchange
 */
func (this *mexc) SetPositionMode(hedged interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		var request interface{} = map[string]interface{}{
			"positionMode": Ternary(IsTrue(hedged), 1, 2),
		}

		response := (<-this.ContractPrivatePostPositionChangePositionMode(this.Extend(request, params)))
		PanicOnError(response)

		//
		//     {
		//         "success":true,
		//         "code":0
		//     }
		//
		ch <- response
		return nil

	}()
	return ch
}

/**
 * @method
 * @name mexc#fetchPositionMode
 * @description fetchs the position mode, hedged or one way, hedged for binance is set identically for all linear markets or all inverse markets
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-position-mode
 * @param {string} symbol not used by mexc fetchPositionMode
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an object detailing whether the market is in hedged or one-way mode
 */
func (this *mexc) FetchPositionMode(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		response := (<-this.ContractPrivateGetPositionPositionMode(params))
		PanicOnError(response)
		//
		//     {
		//         "success":true,
		//         "code":0,
		//         "data":2
		//     }
		//
		var positionMode interface{} = this.SafeInteger(response, "data")

		ch <- map[string]interface{}{
			"info":   response,
			"hedged": (IsEqual(positionMode, 1)),
		}
		return nil

	}()
	return ch
}

/**
 * @method
 * @name mexc#fetchTransactionFees
 * @description fetch deposit and withdrawal fees
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#query-the-currency-information
 * @param {string[]|undefined} codes returns fees for all currencies if undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func (this *mexc) FetchTransactionFees(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		codes := GetArg(optionalArgs, 0, nil)
		_ = codes
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes56418 := (<-this.LoadMarkets())
		PanicOnError(retRes56418)

		response := (<-this.SpotPrivateGetCapitalConfigGetall(params))
		PanicOnError(response)

		//
		//    [
		//       {
		//           "coin": "AGLD",
		//           "name": "Adventure Gold",
		//           "networkList": [
		//               {
		//                   "coin": "AGLD",
		//                   "depositDesc": null,
		//                   "depositEnable": true,
		//                   "minConfirm": "0",
		//                   "name": "Adventure Gold",
		//                   "network": "ERC20",
		//                   "withdrawEnable": true,
		//                   "withdrawFee": "10.000000000000000000",
		//                   "withdrawIntegerMultiple": null,
		//                   "withdrawMax": "1200000.000000000000000000",
		//                   "withdrawMin": "20.000000000000000000",
		//                   "sameAddress": false,
		//                   "contract": "0x32353a6c91143bfd6c7d363b546e62a9a2489a20",
		//                   "withdrawTips": null,
		//                   "depositTips": null
		//               }
		//               ...
		//           ]
		//       },
		//       ...
		//    ]
		//
		ch <- this.ParseTransactionFees(response, codes)
		return nil

	}()
	return ch
}
func (this *mexc) ParseTransactionFees(response interface{}, optionalArgs ...interface{}) interface{} {
	codes := GetArg(optionalArgs, 0, nil)
	_ = codes
	var withdrawFees interface{} = map[string]interface{}{}
	for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
		var entry interface{} = GetValue(response, i)
		var currencyId interface{} = this.SafeString(entry, "coin")
		var currency interface{} = this.SafeCurrency(currencyId)
		var code interface{} = this.SafeString(currency, "code")
		if IsTrue(IsTrue((IsEqual(codes, nil))) || IsTrue((this.InArray(code, codes)))) {
			AddElementToObject(withdrawFees, code, this.ParseTransactionFee(entry, currency))
		}
	}
	return map[string]interface{}{
		"withdraw": withdrawFees,
		"deposit":  map[string]interface{}{},
		"info":     response,
	}
}
func (this *mexc) ParseTransactionFee(transaction interface{}, optionalArgs ...interface{}) interface{} {
	//
	//    {
	//        "coin": "AGLD",
	//        "name": "Adventure Gold",
	//        "networkList": [
	//            {
	//                "coin": "AGLD",
	//                "depositDesc": null,
	//                "depositEnable": true,
	//                "minConfirm": "0",
	//                "name": "Adventure Gold",
	//                "network": "ERC20",
	//                "withdrawEnable": true,
	//                "withdrawFee": "10.000000000000000000",
	//                "withdrawIntegerMultiple": null,
	//                "withdrawMax": "1200000.000000000000000000",
	//                "withdrawMin": "20.000000000000000000",
	//                "sameAddress": false,
	//                "contract": "0x32353a6c91143bfd6c7d363b546e62a9a2489a20",
	//                "withdrawTips": null,
	//                "depositTips": null
	//            }
	//            ...
	//        ]
	//    }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var networkList interface{} = this.SafeValue(transaction, "networkList", []interface{}{})
	var result interface{} = map[string]interface{}{}
	for j := 0; IsLessThan(j, GetArrayLength(networkList)); j++ {
		var networkEntry interface{} = GetValue(networkList, j)
		var networkId interface{} = this.SafeString(networkEntry, "network")
		var networkCode interface{} = this.SafeString(GetValue(this.Options, "networks"), networkId, networkId)
		var fee interface{} = this.SafeNumber(networkEntry, "withdrawFee")
		AddElementToObject(result, networkCode, fee)
	}
	return result
}

/**
 * @method
 * @name mexc#fetchDepositWithdrawFees
 * @description fetch deposit and withdrawal fees
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#query-the-currency-information
 * @param {string[]|undefined} codes returns fees for all currencies if undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func (this *mexc) FetchDepositWithdrawFees(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		codes := GetArg(optionalArgs, 0, nil)
		_ = codes
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes57428 := (<-this.LoadMarkets())
		PanicOnError(retRes57428)

		response := (<-this.SpotPrivateGetCapitalConfigGetall(params))
		PanicOnError(response)

		//
		//    [
		//       {
		//           "coin": "AGLD",
		//           "name": "Adventure Gold",
		//           "networkList": [
		//               {
		//                   "coin": "AGLD",
		//                   "depositDesc": null,
		//                   "depositEnable": true,
		//                   "minConfirm": "0",
		//                   "name": "Adventure Gold",
		//                   "network": "ERC20",
		//                   "withdrawEnable": true,
		//                   "withdrawFee": "10.000000000000000000",
		//                   "withdrawIntegerMultiple": null,
		//                   "withdrawMax": "1200000.000000000000000000",
		//                   "withdrawMin": "20.000000000000000000",
		//                   "sameAddress": false,
		//                   "contract": "0x32353a6c91143bfd6c7d363b546e62a9a2489a20",
		//                   "withdrawTips": null,
		//                   "depositTips": null
		//               }
		//               ...
		//           ]
		//       },
		//       ...
		//    ]
		//
		ch <- this.ParseDepositWithdrawFees(response, codes, "coin")
		return nil

	}()
	return ch
}
func (this *mexc) ParseDepositWithdrawFee(fee interface{}, optionalArgs ...interface{}) interface{} {
	//
	//    {
	//        "coin": "AGLD",
	//        "name": "Adventure Gold",
	//        "networkList": [
	//            {
	//                "coin": "AGLD",
	//                "depositDesc": null,
	//                "depositEnable": true,
	//                "minConfirm": "0",
	//                "name": "Adventure Gold",
	//                "network": "ERC20",
	//                "withdrawEnable": true,
	//                "withdrawFee": "10.000000000000000000",
	//                "withdrawIntegerMultiple": null,
	//                "withdrawMax": "1200000.000000000000000000",
	//                "withdrawMin": "20.000000000000000000",
	//                "sameAddress": false,
	//                "contract": "0x32353a6c91143bfd6c7d363b546e62a9a2489a20",
	//                "withdrawTips": null,
	//                "depositTips": null
	//            }
	//            ...
	//        ]
	//    }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var networkList interface{} = this.SafeValue(fee, "networkList", []interface{}{})
	var result interface{} = this.DepositWithdrawFee(fee)
	for j := 0; IsLessThan(j, GetArrayLength(networkList)); j++ {
		var networkEntry interface{} = GetValue(networkList, j)
		var networkId interface{} = this.SafeString(networkEntry, "network")
		var networkCode interface{} = this.NetworkIdToCode(networkId, this.SafeString(currency, "code"))
		AddElementToObject(GetValue(result, "networks"), networkCode, map[string]interface{}{
			"withdraw": map[string]interface{}{
				"fee":        this.SafeNumber(networkEntry, "withdrawFee"),
				"percentage": nil,
			},
			"deposit": map[string]interface{}{
				"fee":        nil,
				"percentage": nil,
			},
		})
	}
	return this.AssignDefaultDepositWithdrawFees(result)
}

/**
 * @method
 * @name mexc#fetchLeverage
 * @description fetch the set leverage for a market
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-leverage
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [leverage structure]{@link https://docs.ccxt.com/#/?id=leverage-structure}
 */
func (this *mexc) FetchLeverage(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes58338 := (<-this.LoadMarkets())
		PanicOnError(retRes58338)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}

		response := (<-this.ContractPrivateGetPositionLeverage(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "success": true,
		//         "code": 0,
		//         "data": [
		//             {
		//                 "level": 1,
		//                 "maxVol": 463300,
		//                 "mmr": 0.004,
		//                 "imr": 0.005,
		//                 "positionType": 1,
		//                 "openType": 1,
		//                 "leverage": 20,
		//                 "limitBySys": false,
		//                 "currentMmr": 0.004
		//             },
		//             {
		//                 "level": 1,
		//                 "maxVol": 463300,
		//                 "mmr": 0.004,
		//                 "imr": 0.005,
		//                 "positionType": 2,
		//                 "openType": 1,
		//                 "leverage": 20,
		//                 "limitBySys": false,
		//                 "currentMmr": 0.004
		//             }
		//         ]
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseLeverage(data, market)
		return nil

	}()
	return ch
}
func (this *mexc) ParseLeverage(leverage interface{}, optionalArgs ...interface{}) interface{} {
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marginMode interface{} = nil
	var longLeverage interface{} = nil
	var shortLeverage interface{} = nil
	for i := 0; IsLessThan(i, GetArrayLength(leverage)); i++ {
		var entry interface{} = GetValue(leverage, i)
		var openType interface{} = this.SafeInteger(entry, "openType")
		var positionType interface{} = this.SafeInteger(entry, "positionType")
		if IsTrue(IsEqual(positionType, 1)) {
			longLeverage = this.SafeInteger(entry, "leverage")
		} else if IsTrue(IsEqual(positionType, 2)) {
			shortLeverage = this.SafeInteger(entry, "leverage")
		}
		marginMode = Ternary(IsTrue((IsEqual(openType, 1))), "isolated", "cross")
	}
	return map[string]interface{}{
		"info":          leverage,
		"symbol":        GetValue(market, "symbol"),
		"marginMode":    marginMode,
		"longLeverage":  longLeverage,
		"shortLeverage": shortLeverage,
	}
}
func (this *mexc) HandleMarginModeAndParams(methodName interface{}, optionalArgs ...interface{}) interface{} {
	/**
	 * @ignore
	 * @method
	 * @description marginMode specified by params["marginMode"], this.options["marginMode"], this.options["defaultMarginMode"], params["margin"] = true or this.options["defaultType"] = 'margin'
	 * @param {object} [params] extra parameters specific to the exchange API endpoint
	 * @param {bool} [params.margin] true for trading spot-margin
	 * @returns {Array} the marginMode in lowercase
	 */
	params := GetArg(optionalArgs, 0, map[string]interface{}{})
	_ = params
	defaultValue := GetArg(optionalArgs, 1, nil)
	_ = defaultValue
	var defaultType interface{} = this.SafeString(this.Options, "defaultType")
	var isMargin interface{} = this.SafeBool(params, "margin", false)
	var marginMode interface{} = nil
	marginModeparamsVariable := this.Exchange.HandleMarginModeAndParams(methodName, params, defaultValue)
	marginMode = GetValue(marginModeparamsVariable, 0)
	params = GetValue(marginModeparamsVariable, 1)
	if IsTrue(IsTrue((IsEqual(defaultType, "margin"))) || IsTrue((IsEqual(isMargin, true)))) {
		marginMode = "isolated"
	}
	return []interface{}{marginMode, params}
}

/**
 * @method
 * @name mexc#fetchPositionsHistory
 * @description fetches historical positions
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-the-user-s-history-position-information
 * @param {string[]} [symbols] unified contract symbols
 * @param {int} [since] not used by mexc fetchPositionsHistory
 * @param {int} [limit] the maximum amount of candles to fetch, default=1000
 * @param {object} [params] extra parameters specific to the exchange api endpoint
 *
 * EXCHANGE SPECIFIC PARAMETERS
 * @param {int} [params.type] position type，1: long, 2: short
 * @param {int} [params.page_num] current page number, default is 1
 * @returns {object[]} a list of [position structures]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func (this *mexc) FetchPositionsHistory(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes59328 := (<-this.LoadMarkets())
		PanicOnError(retRes59328)
		var request interface{} = map[string]interface{}{}
		if IsTrue(!IsEqual(symbols, nil)) {
			var symbolsLength interface{} = GetArrayLength(symbols)
			if IsTrue(IsEqual(symbolsLength, 1)) {
				var market interface{} = this.Market(GetValue(symbols, 0))
				AddElementToObject(request, "symbol", GetValue(market, "id"))
			}
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "page_size", limit)
		}

		response := (<-this.ContractPrivateGetPositionListHistoryPositions(this.Extend(request, params)))
		PanicOnError(response)
		//
		//    {
		//        success: true,
		//        code: '0',
		//        data: [
		//            {
		//                positionId: '390281084',
		//                symbol: 'RVN_USDT',
		//                positionType: '1',
		//                openType: '2',
		//                state: '3',
		//                holdVol: '0',
		//                frozenVol: '0',
		//                closeVol: '1141',
		//                holdAvgPrice: '0.03491',
		//                holdAvgPriceFullyScale: '0.03491',
		//                openAvgPrice: '0.03491',
		//                openAvgPriceFullyScale: '0.03491',
		//                closeAvgPrice: '0.03494',
		//                liquidatePrice: '0.03433',
		//                oim: '0',
		//                im: '0',
		//                holdFee: '0',
		//                realised: '0.1829',
		//                leverage: '50',
		//                createTime: '1711512408000',
		//                updateTime: '1711512553000',
		//                autoAddIm: false,
		//                version: '4',
		//                profitRatio: '0.0227',
		//                newOpenAvgPrice: '0.03491',
		//                newCloseAvgPrice: '0.03494',
		//                closeProfitLoss: '0.3423',
		//                fee: '0.1593977',
		//                positionShowStatus: 'CLOSED'
		//            },
		//            ...
		//        ]
		//    }
		//
		var data interface{} = this.SafeList(response, "data")
		var positions interface{} = this.ParsePositions(data, symbols, params)

		ch <- this.FilterBySinceLimit(positions, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name mexc#setMarginMode
 * @description set margin mode to 'cross' or 'isolated'
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#switch-leverage
 * @param {string} marginMode 'cross' or 'isolated'
 * @param {string} [symbol] required when there is no position, else provide params["positionId"]
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.positionId] required when a position is set
 * @param {string} [params.direction] "long" or "short" required when there is no position
 * @returns {object} response from the exchange
 */
func (this *mexc) SetMarginMode(marginMode interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes60038 := (<-this.LoadMarkets())
		PanicOnError(retRes60038)
		var market interface{} = this.Market(symbol)
		if IsTrue(GetValue(market, "spot")) {
			panic(BadSymbol(Add(this.Id, " setMarginMode() supports contract markets only")))
		}
		marginMode = ToLower(marginMode)
		if IsTrue(IsTrue(!IsEqual(marginMode, "isolated")) && IsTrue(!IsEqual(marginMode, "cross"))) {
			panic(BadRequest(Add(this.Id, " setMarginMode() marginMode argument should be isolated or cross")))
		}
		var leverage interface{} = this.SafeInteger(params, "leverage")
		if IsTrue(IsEqual(leverage, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " setMarginMode() requires a leverage parameter")))
		}
		var direction interface{} = this.SafeStringLower2(params, "direction", "positionId")
		var request interface{} = map[string]interface{}{
			"leverage": leverage,
			"openType": Ternary(IsTrue((IsEqual(marginMode, "isolated"))), 1, 2),
		}
		if IsTrue(!IsEqual(symbol, nil)) {
			AddElementToObject(request, "symbol", GetValue(market, "id"))
		}
		if IsTrue(!IsEqual(direction, nil)) {
			AddElementToObject(request, "positionType", Ternary(IsTrue((IsEqual(direction, "short"))), 2, 1))
		}
		params = this.Omit(params, "direction")

		response := (<-this.ContractPrivatePostPositionChangeLeverage(this.Extend(request, params)))
		PanicOnError(response)

		//
		// { success: true, code: '0' }
		//
		ch <- this.ParseLeverage(response, market) // tmp revert type
		return nil

	}()
	return ch
}
func (this *mexc) Nonce() interface{} {
	return Subtract(this.Milliseconds(), this.SafeInteger(this.Options, "timeDifference", 0))
}
func (this *mexc) Sign(path interface{}, optionalArgs ...interface{}) interface{} {
	api := GetArg(optionalArgs, 0, "public")
	_ = api
	method := GetArg(optionalArgs, 1, "GET")
	_ = method
	params := GetArg(optionalArgs, 2, map[string]interface{}{})
	_ = params
	headers := GetArg(optionalArgs, 3, nil)
	_ = headers
	body := GetArg(optionalArgs, 4, nil)
	_ = body
	var section interface{} = this.SafeString(api, 0)
	var access interface{} = this.SafeString(api, 1)
	pathparamsVariable := this.ResolvePath(path, params)
	path = GetValue(pathparamsVariable, 0)
	params = GetValue(pathparamsVariable, 1)
	var url interface{} = nil
	if IsTrue(IsTrue(IsEqual(section, "spot")) || IsTrue(IsEqual(section, "broker"))) {
		if IsTrue(IsEqual(section, "broker")) {
			url = Add(Add(GetValue(GetValue(GetValue(this.Urls, "api"), section), access), "/"), path)
		} else {
			url = Add(Add(Add(Add(GetValue(GetValue(GetValue(this.Urls, "api"), section), access), "/api/"), this.Version), "/"), path)
		}
		var urlParams interface{} = params
		if IsTrue(IsEqual(access, "private")) {
			if IsTrue(IsTrue(IsEqual(section, "broker")) && IsTrue((IsTrue(IsTrue((IsEqual(method, "POST"))) || IsTrue((IsEqual(method, "PUT")))) || IsTrue((IsEqual(method, "DELETE")))))) {
				urlParams = map[string]interface{}{
					"timestamp":  this.Nonce(),
					"recvWindow": this.SafeInteger(this.Options, "recvWindow", 5000),
				}
				body = this.Json(params)
			} else {
				AddElementToObject(urlParams, "timestamp", this.Nonce())
				AddElementToObject(urlParams, "recvWindow", this.SafeInteger(this.Options, "recvWindow", 5000))
			}
		}
		var paramsEncoded interface{} = ""
		if IsTrue(GetArrayLength(ObjectKeys(urlParams))) {
			paramsEncoded = this.Urlencode(urlParams)
			url = Add(url, Add("?", paramsEncoded))
		}
		if IsTrue(IsEqual(access, "private")) {
			this.CheckRequiredCredentials()
			var signature interface{} = this.Hmac(this.Encode(paramsEncoded), this.Encode(this.Secret), sha256)
			url = Add(url, Add(Add("&", "signature="), signature))
			headers = map[string]interface{}{
				"X-MEXC-APIKEY": this.ApiKey,
				"source":        this.SafeString(this.Options, "broker", "CCXT"),
			}
		}
		if IsTrue(IsTrue(IsTrue((IsEqual(method, "POST"))) || IsTrue((IsEqual(method, "PUT")))) || IsTrue((IsEqual(method, "DELETE")))) {
			AddElementToObject(headers, "Content-Type", "application/json")
		}
	} else if IsTrue(IsTrue(IsEqual(section, "contract")) || IsTrue(IsEqual(section, "spot2"))) {
		url = Add(Add(GetValue(GetValue(GetValue(this.Urls, "api"), section), access), "/"), this.ImplodeParams(path, params))
		params = this.Omit(params, this.ExtractParams(path))
		if IsTrue(IsEqual(access, "public")) {
			if IsTrue(GetArrayLength(ObjectKeys(params))) {
				url = Add(url, Add("?", this.Urlencode(params)))
			}
		} else {
			this.CheckRequiredCredentials()
			var timestamp interface{} = ToString(this.Nonce())
			var auth interface{} = ""
			headers = map[string]interface{}{
				"ApiKey":       this.ApiKey,
				"Request-Time": timestamp,
				"Content-Type": "application/json",
				"source":       this.SafeString(this.Options, "broker", "CCXT"),
			}
			if IsTrue(IsEqual(method, "POST")) {
				auth = this.Json(params)
				body = auth
			} else {
				params = this.Keysort(params)
				if IsTrue(GetArrayLength(ObjectKeys(params))) {
					auth = Add(auth, this.Urlencode(params))
					url = Add(url, Add("?", auth))
				}
			}
			auth = Add(Add(this.ApiKey, timestamp), auth)
			var signature interface{} = this.Hmac(this.Encode(auth), this.Encode(this.Secret), sha256)
			AddElementToObject(headers, "Signature", signature)
		}
	}
	return map[string]interface{}{
		"url":     url,
		"method":  method,
		"body":    body,
		"headers": headers,
	}
}
func (this *mexc) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{} {
	if IsTrue(IsEqual(response, nil)) {
		return nil
	}
	// spot
	//     {"code":-1128,"msg":"Combination of optional parameters invalid.","_extend":null}
	//     {"success":false,"code":123456,"message":"Order quantity error...."}
	//
	// contract
	//
	//     {"code":10232,"msg":"The currency not exist"}
	//     {"code":10216,"msg":"No available deposit address"}
	//     {"success":true, "code":0, "data":1634095541710}
	//
	var success interface{} = this.SafeBool(response, "success", false) // v1
	if IsTrue(IsEqual(success, true)) {
		return nil
	}
	var responseCode interface{} = this.SafeString(response, "code", nil)
	if IsTrue(IsTrue(IsTrue((!IsEqual(responseCode, nil))) && IsTrue((!IsEqual(responseCode, "200")))) && IsTrue((!IsEqual(responseCode, "0")))) {
		var feedback interface{} = Add(Add(this.Id, " "), body)
		this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), body, feedback)
		this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), responseCode, feedback)
		panic(ExchangeError(feedback))
	}
	return nil
}

func (this *mexc) Init(userConfig map[string]interface{}) {
	this.Exchange = Exchange{}
	this.Exchange.DerivedExchange = this
	this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
}
