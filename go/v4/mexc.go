package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type mexc struct {
    Exchange

}

func NewMexcCore() mexc {
   p := mexc{}
   setDefaults(&p)
   return p
}

func  (this *mexc) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "mexc",
        "name": "MEXC Global",
        "countries": []interface{}{"SC"},
        "rateLimit": 50,
        "version": "v3",
        "certified": true,
        "pro": true,
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": true,
            "swap": true,
            "future": false,
            "option": false,
            "addMargin": true,
            "borrowCrossMargin": false,
            "borrowIsolatedMargin": false,
            "borrowMargin": false,
            "cancelAllOrders": true,
            "cancelOrder": true,
            "cancelOrders": nil,
            "closeAllPositions": false,
            "closePosition": false,
            "createDepositAddress": true,
            "createMarketBuyOrderWithCost": true,
            "createMarketOrderWithCost": true,
            "createMarketSellOrderWithCost": true,
            "createOrder": true,
            "createOrders": true,
            "createPostOnlyOrder": true,
            "createReduceOnlyOrder": true,
            "createStopLimitOrder": true,
            "createStopMarketOrder": true,
            "createStopOrder": true,
            "createTriggerOrder": true,
            "deposit": nil,
            "editOrder": nil,
            "fetchAccounts": true,
            "fetchBalance": true,
            "fetchBidsAsks": true,
            "fetchBorrowInterest": false,
            "fetchBorrowRate": false,
            "fetchBorrowRateHistories": false,
            "fetchBorrowRateHistory": false,
            "fetchBorrowRates": false,
            "fetchBorrowRatesPerSymbol": false,
            "fetchCanceledOrders": true,
            "fetchClosedOrder": nil,
            "fetchClosedOrders": true,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchCurrencies": true,
            "fetchDeposit": nil,
            "fetchDepositAddress": true,
            "fetchDepositAddresses": nil,
            "fetchDepositAddressesByNetwork": true,
            "fetchDeposits": true,
            "fetchDepositWithdrawFee": "emulated",
            "fetchDepositWithdrawFees": true,
            "fetchFundingHistory": true,
            "fetchFundingInterval": true,
            "fetchFundingIntervals": false,
            "fetchFundingRate": true,
            "fetchFundingRateHistory": true,
            "fetchFundingRates": false,
            "fetchIndexOHLCV": true,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchIsolatedPositions": false,
            "fetchL2OrderBook": true,
            "fetchLedger": nil,
            "fetchLedgerEntry": nil,
            "fetchLeverage": true,
            "fetchLeverages": false,
            "fetchLeverageTiers": true,
            "fetchMarginAdjustmentHistory": false,
            "fetchMarginMode": false,
            "fetchMarketLeverageTiers": "emulated",
            "fetchMarkets": true,
            "fetchMarkOHLCV": true,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenInterest": false,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrder": nil,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrderBooks": nil,
            "fetchOrders": true,
            "fetchOrderTrades": true,
            "fetchPosition": "emulated",
            "fetchPositionHistory": "emulated",
            "fetchPositionMode": true,
            "fetchPositions": true,
            "fetchPositionsHistory": true,
            "fetchPositionsRisk": nil,
            "fetchPremiumIndexOHLCV": false,
            "fetchStatus": true,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTime": true,
            "fetchTrades": true,
            "fetchTradingFee": true,
            "fetchTradingFees": false,
            "fetchTradingLimits": nil,
            "fetchTransactionFee": "emulated",
            "fetchTransactionFees": true,
            "fetchTransactions": nil,
            "fetchTransfer": true,
            "fetchTransfers": true,
            "fetchWithdrawal": nil,
            "fetchWithdrawals": true,
            "reduceMargin": true,
            "repayCrossMargin": false,
            "repayIsolatedMargin": false,
            "setLeverage": true,
            "setMarginMode": true,
            "setPositionMode": true,
            "signIn": nil,
            "transfer": nil,
            "withdraw": true,
        },
        "urls": map[string]interface{} {
            "logo": "https://user-images.githubusercontent.com/1294454/137283979-8b2a818d-8633-461b-bfca-de89e8c446b2.jpg",
            "api": map[string]interface{} {
                "spot": map[string]interface{} {
                    "public": "https://api.mexc.com",
                    "private": "https://api.mexc.com",
                },
                "spot2": map[string]interface{} {
                    "public": "https://www.mexc.com/open/api/v2",
                    "private": "https://www.mexc.com/open/api/v2",
                },
                "contract": map[string]interface{} {
                    "public": "https://contract.mexc.com/api/v1/contract",
                    "private": "https://contract.mexc.com/api/v1/private",
                },
                "broker": map[string]interface{} {
                    "private": "https://api.mexc.com/api/v3/broker",
                },
            },
            "www": "https://www.mexc.com/",
            "doc": []interface{}{"https://mexcdevelop.github.io/apidocs/"},
            "fees": []interface{}{"https://www.mexc.com/fee"},
            "referral": "https://www.mexc.com/register?inviteCode=mexc-1FQ1GNu1",
        },
        "api": map[string]interface{} {
            "spot": map[string]interface{} {
                "public": map[string]interface{} {
                    "get": map[string]interface{} {
                        "ping": 1,
                        "time": 1,
                        "exchangeInfo": 10,
                        "depth": 1,
                        "trades": 5,
                        "historicalTrades": 1,
                        "aggTrades": 1,
                        "klines": 1,
                        "avgPrice": 1,
                        "ticker/24hr": 1,
                        "ticker/price": 1,
                        "ticker/bookTicker": 1,
                        "etf/info": 1,
                    },
                },
                "private": map[string]interface{} {
                    "get": map[string]interface{} {
                        "order": 2,
                        "openOrders": 3,
                        "allOrders": 10,
                        "account": 10,
                        "myTrades": 10,
                        "tradeFee": 10,
                        "sub-account/list": 1,
                        "sub-account/apiKey": 1,
                        "capital/config/getall": 10,
                        "capital/deposit/hisrec": 1,
                        "capital/withdraw/history": 1,
                        "capital/withdraw/address": 10,
                        "capital/deposit/address": 10,
                        "capital/transfer": 1,
                        "capital/transfer/tranId": 1,
                        "capital/transfer/internal": 1,
                        "capital/sub-account/universalTransfer": 1,
                        "capital/convert": 1,
                        "capital/convert/list": 1,
                        "margin/loan": 1,
                        "margin/allOrders": 1,
                        "margin/myTrades": 1,
                        "margin/openOrders": 1,
                        "margin/maxTransferable": 1,
                        "margin/priceIndex": 1,
                        "margin/order": 1,
                        "margin/isolated/account": 1,
                        "margin/maxBorrowable": 1,
                        "margin/repay": 1,
                        "margin/isolated/pair": 1,
                        "margin/forceLiquidationRec": 1,
                        "margin/isolatedMarginData": 1,
                        "margin/isolatedMarginTier": 1,
                        "rebate/taxQuery": 1,
                        "rebate/detail": 1,
                        "rebate/detail/kickback": 1,
                        "rebate/referCode": 1,
                        "rebate/affiliate/commission": 1,
                        "rebate/affiliate/withdraw": 1,
                        "rebate/affiliate/commission/detail": 1,
                        "mxDeduct/enable": 1,
                        "userDataStream": 1,
                        "selfSymbols": 1,
                    },
                    "post": map[string]interface{} {
                        "order": 1,
                        "order/test": 1,
                        "sub-account/virtualSubAccount": 1,
                        "sub-account/apiKey": 1,
                        "sub-account/futures": 1,
                        "sub-account/margin": 1,
                        "batchOrders": 10,
                        "capital/withdraw/apply": 1,
                        "capital/withdraw": 1,
                        "capital/transfer": 1,
                        "capital/transfer/internal": 1,
                        "capital/deposit/address": 1,
                        "capital/sub-account/universalTransfer": 1,
                        "capital/convert": 10,
                        "mxDeduct/enable": 1,
                        "userDataStream": 1,
                    },
                    "put": map[string]interface{} {
                        "userDataStream": 1,
                    },
                    "delete": map[string]interface{} {
                        "order": 1,
                        "openOrders": 1,
                        "sub-account/apiKey": 1,
                        "margin/order": 1,
                        "margin/openOrders": 1,
                        "userDataStream": 1,
                        "capital/withdraw": 1,
                    },
                },
            },
            "contract": map[string]interface{} {
                "public": map[string]interface{} {
                    "get": map[string]interface{} {
                        "ping": 2,
                        "detail": 100,
                        "support_currencies": 2,
                        "depth/{symbol}": 2,
                        "depth_commits/{symbol}/{limit}": 2,
                        "index_price/{symbol}": 2,
                        "fair_price/{symbol}": 2,
                        "funding_rate/{symbol}": 2,
                        "kline/{symbol}": 2,
                        "kline/index_price/{symbol}": 2,
                        "kline/fair_price/{symbol}": 2,
                        "deals/{symbol}": 2,
                        "ticker": 2,
                        "risk_reverse": 2,
                        "risk_reverse/history": 2,
                        "funding_rate/history": 2,
                    },
                },
                "private": map[string]interface{} {
                    "get": map[string]interface{} {
                        "account/assets": 2,
                        "account/asset/{currency}": 2,
                        "account/transfer_record": 2,
                        "position/list/history_positions": 2,
                        "position/open_positions": 2,
                        "position/funding_records": 2,
                        "position/position_mode": 2,
                        "order/list/open_orders/{symbol}": 2,
                        "order/list/history_orders": 2,
                        "order/external/{symbol}/{external_oid}": 2,
                        "order/get/{order_id}": 2,
                        "order/batch_query": 8,
                        "order/deal_details/{order_id}": 2,
                        "order/list/order_deals": 2,
                        "planorder/list/orders": 2,
                        "stoporder/list/orders": 2,
                        "stoporder/order_details/{stop_order_id}": 2,
                        "account/risk_limit": 2,
                        "account/tiered_fee_rate": 2,
                        "position/leverage": 2,
                    },
                    "post": map[string]interface{} {
                        "position/change_margin": 2,
                        "position/change_leverage": 2,
                        "position/change_position_mode": 2,
                        "order/submit": 2,
                        "order/submit_batch": 40,
                        "order/cancel": 2,
                        "order/cancel_with_external": 2,
                        "order/cancel_all": 2,
                        "account/change_risk_level": 2,
                        "planorder/place": 2,
                        "planorder/cancel": 2,
                        "planorder/cancel_all": 2,
                        "stoporder/cancel": 2,
                        "stoporder/cancel_all": 2,
                        "stoporder/change_price": 2,
                        "stoporder/change_plan_price": 2,
                    },
                },
            },
            "spot2": map[string]interface{} {
                "public": map[string]interface{} {
                    "get": map[string]interface{} {
                        "market/symbols": 1,
                        "market/coin/list": 2,
                        "common/timestamp": 1,
                        "common/ping": 2,
                        "market/ticker": 1,
                        "market/depth": 1,
                        "market/deals": 1,
                        "market/kline": 1,
                        "market/api_default_symbols": 2,
                    },
                },
                "private": map[string]interface{} {
                    "get": map[string]interface{} {
                        "account/info": 1,
                        "order/open_orders": 1,
                        "order/list": 1,
                        "order/query": 1,
                        "order/deals": 1,
                        "order/deal_detail": 1,
                        "asset/deposit/address/list": 2,
                        "asset/deposit/list": 2,
                        "asset/address/list": 2,
                        "asset/withdraw/list": 2,
                        "asset/internal/transfer/record": 10,
                        "account/balance": 10,
                        "asset/internal/transfer/info": 10,
                        "market/api_symbols": 2,
                    },
                    "post": map[string]interface{} {
                        "order/place": 1,
                        "order/place_batch": 1,
                        "order/advanced/place_batch": 1,
                        "asset/withdraw": 2,
                        "asset/internal/transfer": 10,
                    },
                    "delete": map[string]interface{} {
                        "order/cancel": 1,
                        "order/cancel_by_symbol": 1,
                        "asset/withdraw": 2,
                    },
                },
            },
            "broker": map[string]interface{} {
                "private": map[string]interface{} {
                    "get": map[string]interface{} {
                        "sub-account/universalTransfer": 1,
                        "sub-account/list": 1,
                        "sub-account/apiKey": 1,
                        "capital/deposit/subAddress": 1,
                        "capital/deposit/subHisrec": 1,
                        "capital/deposit/subHisrec/getall": 1,
                    },
                    "post": map[string]interface{} {
                        "sub-account/virtualSubAccount": 1,
                        "sub-account/apiKey": 1,
                        "capital/deposit/subAddress": 1,
                        "capital/withdraw/apply": 1,
                        "sub-account/universalTransfer": 1,
                        "sub-account/futures": 1,
                    },
                    "delete": map[string]interface{} {
                        "sub-account/apiKey": 1,
                    },
                },
            },
        },
        "precisionMode": TICK_SIZE,
        "timeframes": map[string]interface{} {
            "1m": "1m",
            "5m": "5m",
            "15m": "15m",
            "30m": "30m",
            "1h": "1h",
            "4h": "4h",
            "8h": "8h",
            "1d": "1d",
            "1w": "1w",
            "1M": "1M",
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "tierBased": false,
                "percentage": true,
                "maker": this.ParseNumber("0.002"),
                "taker": this.ParseNumber("0.002"),
            },
        },
        "options": map[string]interface{} {
            "adjustForTimeDifference": false,
            "timeDifference": 0,
            "unavailableContracts": map[string]interface{} {
                "BTC/USDT:USDT": true,
                "LTC/USDT:USDT": true,
                "ETH/USDT:USDT": true,
            },
            "fetchMarkets": map[string]interface{} {
                "types": map[string]interface{} {
                    "spot": true,
                    "swap": map[string]interface{} {
                        "linear": true,
                        "inverse": false,
                    },
                },
            },
            "timeframes": map[string]interface{} {
                "spot": map[string]interface{} {
                    "1m": "1m",
                    "5m": "5m",
                    "15m": "15m",
                    "30m": "30m",
                    "1h": "60m",
                    "4h": "4h",
                    "1d": "1d",
                    "1w": "1W",
                    "1M": "1M",
                },
                "swap": map[string]interface{} {
                    "1m": "Min1",
                    "5m": "Min5",
                    "15m": "Min15",
                    "30m": "Min30",
                    "1h": "Min60",
                    "4h": "Hour4",
                    "8h": "Hour8",
                    "1d": "Day1",
                    "1w": "Week1",
                    "1M": "Month1",
                },
            },
            "defaultType": "spot",
            "defaultNetwork": "ETH",
            "defaultNetworks": map[string]interface{} {
                "ETH": "ETH",
                "USDT": "ERC20",
                "USDC": "ERC20",
                "BTC": "BTC",
                "LTC": "LTC",
            },
            "networks": map[string]interface{} {
                "ZKSYNC": "ZKSYNCERA",
                "TRC20": "TRX",
                "TON": "TONCOIN",
                "AVAXC": "AVAX_CCHAIN",
                "ERC20": "ETH",
                "ACA": "ACALA",
                "BEP20": "BSC",
                "OPTIMISM": "OP",
                "ASTR": "ASTAR",
                "BTM": "BTM2",
                "CRC20": "CRONOS",
                "ETHF": "ETF",
                "HRC20": "HECO",
                "OASIS": "ROSE",
                "OKC": "OKT",
                "RSK": "RBTC",
            },
            "networksById": map[string]interface{} {
                "BNB Smart Chain(BEP20-RACAV1)": "BSC",
                "BNB Smart Chain(BEP20-RACAV2)": "BSC",
                "BNB Smart Chain(BEP20)": "BSC",
            },
            "recvWindow": Multiply(5, 1000),
            "maxTimeTillEnd": Subtract(Multiply(Multiply(90, 86400), 1000), 1),
            "broker": "CCXT",
        },
        "features": map[string]interface{} {
            "default": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": true,
                    "triggerPrice": false,
                    "triggerDirection": false,
                    "triggerPriceType": map[string]interface{} {
                        "last": false,
                        "mark": false,
                        "index": false,
                    },
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": true,
                        "FOK": true,
                        "PO": true,
                        "GTD": false,
                    },
                    "hedged": true,
                    "trailing": false,
                    "leverage": true,
                    "marketBuyByCost": true,
                    "marketBuyRequiresPrice": false,
                    "selfTradePrevention": false,
                    "iceberg": false,
                },
                "createOrders": map[string]interface{} {
                    "max": 20,
                },
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": 30,
                    "untilDays": nil,
                    "symbolRequired": true,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": true,
                    "limit": nil,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchOrders": map[string]interface{} {
                    "marginMode": true,
                    "limit": 1000,
                    "daysBack": 7,
                    "untilDays": 7,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchClosedOrders": map[string]interface{} {
                    "marginMode": true,
                    "limit": 1000,
                    "daysBack": 7,
                    "daysBackCanceled": 7,
                    "untilDays": 7,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchOHLCV": map[string]interface{} {
                    "limit": 1000,
                },
            },
            "spot": map[string]interface{} {
                "extends": "default",
            },
            "forDerivs": map[string]interface{} {
                "extends": "default",
                "createOrder": map[string]interface{} {
                    "triggerPrice": true,
                    "triggerPriceType": map[string]interface{} {
                        "last": true,
                        "mark": true,
                        "index": true,
                    },
                    "triggerDirection": true,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "hedged": true,
                    "leverage": true,
                    "marketBuyByCost": false,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": 90,
                    "untilDays": 90,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "trigger": true,
                    "trailing": false,
                },
                "fetchOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": 90,
                    "untilDays": 90,
                    "trigger": true,
                    "trailing": false,
                },
                "fetchClosedOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": 90,
                    "daysBackCanceled": nil,
                    "untilDays": 90,
                    "trigger": true,
                    "trailing": false,
                },
                "fetchOHLCV": map[string]interface{} {
                    "limit": 2000,
                },
            },
            "swap": map[string]interface{} {
                "linear": map[string]interface{} {
                    "extends": "forDerivs",
                },
                "inverse": map[string]interface{} {
                    "extends": "forDerivs",
                },
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "commonCurrencies": map[string]interface{} {
            "BEYONDPROTOCOL": "BEYOND",
            "BIFI": "BIFIF",
            "BYN": "BEYONDFI",
            "COFI": "COFIX",
            "DFI": "DFISTARTER",
            "DFT": "DFUTURE",
            "DRK": "DRK",
            "EGC": "EGORASCREDIT",
            "FLUX1": "FLUX",
            "FLUX": "FLUX1",
            "FREE": "FREEROSSDAO",
            "GAS": "GASDAO",
            "GASNEO": "GAS",
            "GMT": "GMTTOKEN",
            "STEPN": "GMT",
            "HERO": "STEPHERO",
            "MIMO": "MIMOSA",
            "PROS": "PROSFINANCE",
            "SIN": "SINCITYTOKEN",
            "SOUL": "SOULSWAP",
        },
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "-1128": BadRequest,
                "-2011": BadRequest,
                "-1121": BadSymbol,
                "10101": InsufficientFunds,
                "2009": InvalidOrder,
                "2011": BadRequest,
                "30004": InsufficientFunds,
                "33333": BadRequest,
                "44444": BadRequest,
                "1002": InvalidOrder,
                "30019": BadRequest,
                "30005": InvalidOrder,
                "2003": InvalidOrder,
                "2005": InsufficientFunds,
                "400": BadRequest,
                "600": BadRequest,
                "70011": PermissionDenied,
                "88004": InsufficientFunds,
                "88009": ExchangeError,
                "88013": InvalidOrder,
                "88015": InsufficientFunds,
                "700003": InvalidNonce,
                "26": ExchangeError,
                "602": AuthenticationError,
                "10001": AuthenticationError,
                "10007": BadSymbol,
                "10015": BadRequest,
                "10072": BadRequest,
                "10073": BadRequest,
                "10095": InvalidOrder,
                "10096": InvalidOrder,
                "10097": InvalidOrder,
                "10098": InvalidOrder,
                "10099": BadRequest,
                "10100": BadRequest,
                "10102": InvalidOrder,
                "10103": ExchangeError,
                "10200": BadRequest,
                "10201": BadRequest,
                "10202": BadRequest,
                "10206": BadRequest,
                "10211": BadRequest,
                "10212": BadRequest,
                "10216": ExchangeError,
                "10219": ExchangeError,
                "10222": BadRequest,
                "10232": BadRequest,
                "10259": ExchangeError,
                "10265": ExchangeError,
                "10268": BadRequest,
                "20001": ExchangeError,
                "20002": ExchangeError,
                "22222": BadRequest,
                "30000": ExchangeError,
                "30001": InvalidOrder,
                "30002": InvalidOrder,
                "30003": InvalidOrder,
                "30010": InvalidOrder,
                "30014": InvalidOrder,
                "30016": InvalidOrder,
                "30018": AccountSuspended,
                "30020": AuthenticationError,
                "30021": BadRequest,
                "30025": InvalidOrder,
                "30026": BadRequest,
                "30027": InvalidOrder,
                "30028": InvalidOrder,
                "30029": InvalidOrder,
                "30032": InvalidOrder,
                "30041": InvalidOrder,
                "60005": ExchangeError,
                "700001": AuthenticationError,
                "700002": AuthenticationError,
                "700004": BadRequest,
                "700005": InvalidNonce,
                "700006": BadRequest,
                "700007": AuthenticationError,
                "700008": BadRequest,
                "700013": AuthenticationError,
                "730001": BadRequest,
                "730002": BadRequest,
                "730000": ExchangeError,
                "730003": ExchangeError,
                "730100": ExchangeError,
                "730600": BadRequest,
                "730601": BadRequest,
                "730602": BadRequest,
                "730700": BadRequest,
                "730701": BadRequest,
                "730702": BadRequest,
                "730703": BadRequest,
                "730704": BadRequest,
                "730705": BadRequest,
                "730706": BadRequest,
                "730707": BadRequest,
                "730101": BadRequest,
                "140001": BadRequest,
                "140002": AuthenticationError,
            },
            "broad": map[string]interface{} {
                "Order quantity error, please try to modify.": BadRequest,
                "Combination of optional parameters invalid": BadRequest,
                "api market order is disabled": BadRequest,
                "Contract not allow place order!": InvalidOrder,
                "Oversold": InsufficientFunds,
                "Insufficient position": InsufficientFunds,
                "Insufficient balance!": InsufficientFunds,
                "Bid price is great than max allow price": InvalidOrder,
                "Invalid symbol.": BadSymbol,
                "Param error!": BadRequest,
                "maintenance": OnMaintenance,
            },
        },
    })
}
/**
 * @method
 * @name mexc#fetchStatus
 * @description the latest known information on the availability of the exchange API
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#test-connectivity
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-the-server-time
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [status structure]{@link https://docs.ccxt.com/#/?id=exchange-status-structure}
 */
func  (this *mexc) FetchStatus(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            marketTypequeryVariable := this.HandleMarketTypeAndParams("fetchStatus", nil, params);
            marketType := GetValue(marketTypequeryVariable,0);
            query := GetValue(marketTypequeryVariable,1)
            var response interface{} = nil
            var status interface{} = nil
            var updated interface{} = nil
            if IsTrue(IsEqual(marketType, "spot")) {
                
        response = (<-this.SpotPublicGetPing(query))
                PanicOnError(response)
                //
                //     {}
                //
                var keys interface{} = ObjectKeys(response)
                var length interface{} =         GetArrayLength(keys)
                status = Ternary(IsTrue(length), this.Json(response), "ok")
            } else if IsTrue(IsEqual(marketType, "swap")) {
                
        response = (<-this.ContractPublicGetPing(query))
                PanicOnError(response)
                //
                //     {"success":true,"code":"0","data":"1648124374985"}
                //
                status = Ternary(IsTrue(this.SafeValue(response, "success")), "ok", this.Json(response))
                updated = this.SafeInteger(response, "data")
            }
        
            ch <- map[string]interface{} {
                "status": status,
                "updated": updated,
                "url": nil,
                "eta": nil,
                "info": response,
            }
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mexc#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#check-server-time
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-the-server-time
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func  (this *mexc) FetchTime(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            marketTypequeryVariable := this.HandleMarketTypeAndParams("fetchTime", nil, params);
            marketType := GetValue(marketTypequeryVariable,0);
            query := GetValue(marketTypequeryVariable,1)
            var response interface{} = nil
            if IsTrue(IsEqual(marketType, "spot")) {
                
        response = (<-this.SpotPublicGetTime(query))
                PanicOnError(response)
        
                        //
                //     {"serverTime": "1647519277579"}
                //
        ch <- this.SafeInteger(response, "serverTime")
                return nil
            } else if IsTrue(IsEqual(marketType, "swap")) {
                
        response = (<-this.ContractPublicGetPing(query))
                PanicOnError(response)
        
                        //
                //     {"success":true,"code":"0","data":"1648124374985"}
                //
        ch <- this.SafeInteger(response, "data")
                return nil
            }
        
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mexc#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#query-the-currency-information
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func  (this *mexc) FetchCurrencies(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    // this endpoint requires authentication
            // while fetchCurrencies is a public API method by design
            // therefore we check the keys here
            // and fallback to generating the currencies from the markets
            params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            if !IsTrue(this.CheckRequiredCredentials(false)) {
        
                return nil
            }
        
            response:= (<-this.SpotPrivateGetCapitalConfigGetall(params))
            PanicOnError(response)
            //
            // {
            //     "coin": "QANX",
            //     "name": "QANplatform",
            //     "networkList": [
            //       {
            //         "coin": "QANX",
            //         "depositDesc": null,
            //         "depositEnable": true,
            //         "minConfirm": "0",
            //         "name": "QANplatform",
            //         "network": "BEP20(BSC)",
            //         "withdrawEnable": false,
            //         "withdrawFee": "42.000000000000000000",
            //         "withdrawIntegerMultiple": null,
            //         "withdrawMax": "24000000.000000000000000000",
            //         "withdrawMin": "20.000000000000000000",
            //         "sameAddress": false,
            //         "contract": "0xAAA7A10a8ee237ea61E8AC46C50A8Db8bCC1baaa"
            //       },
            //       {
            //         "coin": "QANX",
            //         "depositDesc": null,
            //         "depositEnable": true,
            //         "minConfirm": "0",
            //         "name": "QANplatform",
            //         "network": "ERC20",
            //         "withdrawEnable": true,
            //         "withdrawFee": "2732.000000000000000000",
            //         "withdrawIntegerMultiple": null,
            //         "withdrawMax": "24000000.000000000000000000",
            //         "withdrawMin": "240.000000000000000000",
            //         "sameAddress": false,
            //         "contract": "0xAAA7A10a8ee237ea61E8AC46C50A8Db8bCC1baaa"
            //       }
            //     ]
            //   }
            //
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
                var currency interface{} = GetValue(response, i)
                var id interface{} = this.SafeString(currency, "coin")
                var code interface{} = this.SafeCurrencyCode(id)
                var name interface{} = this.SafeString(currency, "name")
                var currencyActive interface{} = false
                var currencyFee interface{} = nil
                var currencyWithdrawMin interface{} = nil
                var currencyWithdrawMax interface{} = nil
                var depositEnabled interface{} = false
                var withdrawEnabled interface{} = false
                var networks interface{} = map[string]interface{} {}
                var chains interface{} = this.SafeValue(currency, "networkList", []interface{}{})
                for j := 0; IsLessThan(j, GetArrayLength(chains)); j++ {
                    var chain interface{} = GetValue(chains, j)
                    var networkId interface{} = this.SafeString2(chain, "netWork", "network")
                    var network interface{} = this.NetworkIdToCode(networkId)
                    var isDepositEnabled interface{} = this.SafeBool(chain, "depositEnable", false)
                    var isWithdrawEnabled interface{} = this.SafeBool(chain, "withdrawEnable", false)
                    var active interface{} =             (IsTrue(isDepositEnabled) && IsTrue(isWithdrawEnabled))
                    currencyActive = IsTrue(active) || IsTrue(currencyActive)
                    var withdrawMin interface{} = this.SafeString(chain, "withdrawMin")
                    var withdrawMax interface{} = this.SafeString(chain, "withdrawMax")
                    currencyWithdrawMin = Ternary(IsTrue((IsEqual(currencyWithdrawMin, nil))), withdrawMin, currencyWithdrawMin)
                    currencyWithdrawMax = Ternary(IsTrue((IsEqual(currencyWithdrawMax, nil))), withdrawMax, currencyWithdrawMax)
                    var fee interface{} = this.SafeNumber(chain, "withdrawFee")
                    currencyFee = Ternary(IsTrue((IsEqual(currencyFee, nil))), fee, currencyFee)
                    if IsTrue(Precise.StringGt(currencyWithdrawMin, withdrawMin)) {
                        currencyWithdrawMin = withdrawMin
                    }
                    if IsTrue(Precise.StringLt(currencyWithdrawMax, withdrawMax)) {
                        currencyWithdrawMax = withdrawMax
                    }
                    if IsTrue(isDepositEnabled) {
                        depositEnabled = true
                    }
                    if IsTrue(isWithdrawEnabled) {
                        withdrawEnabled = true
                    }
                    AddElementToObject(networks, network, map[string]interface{} {
            "info": chain,
            "id": networkId,
            "network": network,
            "active": active,
            "deposit": isDepositEnabled,
            "withdraw": isWithdrawEnabled,
            "fee": fee,
            "precision": nil,
            "limits": map[string]interface{} {
                "withdraw": map[string]interface{} {
                    "min": withdrawMin,
                    "max": withdrawMax,
                },
            },
        })
                }
                var networkKeys interface{} = ObjectKeys(networks)
                var networkKeysLength interface{} =         GetArrayLength(networkKeys)
                if IsTrue(IsTrue((IsEqual(networkKeysLength, 1))) || IsTrue((InOp(networks, "NONE")))) {
                    var defaultNetwork interface{} = this.SafeValue2(networks, "NONE", Subtract(networkKeysLength, 1))
                    if IsTrue(!IsEqual(defaultNetwork, nil)) {
                        currencyFee = GetValue(defaultNetwork, "fee")
                    }
                }
                AddElementToObject(result, code, map[string]interface{} {
            "info": currency,
            "id": id,
            "code": code,
            "name": name,
            "active": currencyActive,
            "deposit": depositEnabled,
            "withdraw": withdrawEnabled,
            "fee": currencyFee,
            "precision": nil,
            "limits": map[string]interface{} {
                "amount": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
                "withdraw": map[string]interface{} {
                    "min": currencyWithdrawMin,
                    "max": currencyWithdrawMax,
                },
            },
            "networks": networks,
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mexc#fetchMarkets
 * @description retrieves data on all markets for mexc
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#exchange-information
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-the-contract-information
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *mexc) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            if IsTrue(GetValue(this.Options, "adjustForTimeDifference")) {
        
                retRes118912 := (<-this.LoadTimeDifference())
                PanicOnError(retRes118912)
            }
            var spotMarketPromise interface{} = this.FetchSpotMarkets(params)
            var swapMarketPromise interface{} = this.FetchSwapMarkets(params)
            spotMarketswapMarketVariable := (<-promiseAll([]interface{}{spotMarketPromise, swapMarketPromise}));
            spotMarket := GetValue(spotMarketswapMarketVariable,0);
            swapMarket := GetValue(spotMarketswapMarketVariable,1)
        
            ch <- this.ArrayConcat(spotMarket, swapMarket)
            return nil
        
            }()
            return ch
        }
/**
 * @ignore
 * @method
 * @name mexc#fetchMarkets
 * @description retrieves data on all spot markets for mexc
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#exchange-information
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *mexc) FetchSpotMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.SpotPublicGetExchangeInfo(params))
            PanicOnError(response)
            //
            //     {
            //         "timezone": "CST",
            //         "serverTime": 1647521860402,
            //         "rateLimits": [],
            //         "exchangeFilters": [],
            //         "symbols": [
            //           {
            //                "symbol": "OGNUSDT",
            //                "status": "1",
            //                "baseAsset": "OGN",
            //                "baseAssetPrecision": "2",
            //                "quoteAsset": "USDT",
            //                "quoteAssetPrecision": "4",
            //                "orderTypes": [
            //                    "LIMIT",
            //                    "LIMIT_MAKER"
            //                ],
            //                "baseCommissionPrecision": "2",
            //                "quoteCommissionPrecision": "4",
            //                "quoteOrderQtyMarketAllowed": false,
            //                "isSpotTradingAllowed": true,
            //                "isMarginTradingAllowed": true,
            //                "permissions": [
            //                    "SPOT",
            //                    "MARGIN"
            //                ],
            //                "filters": [],
            //                "baseSizePrecision": "0.01", // this turned out to be a minimum base amount for order
            //                "maxQuoteAmount": "5000000",
            //                "makerCommission": "0.002",
            //                "takerCommission": "0.002"
            //                "quoteAmountPrecision": "5", // this turned out to be a minimum cost amount for order
            //                "quotePrecision": "4", // deprecated in favor of 'quoteAssetPrecision' ( https://dev.binance.vision/t/what-is-the-difference-between-quoteprecision-and-quoteassetprecision/4333 )
            //                // note, "icebergAllowed" & "ocoAllowed" fields were recently removed
            //            },
            //         ]
            //     }
            //
            // Notes:
            // - 'quoteAssetPrecision' & 'baseAssetPrecision' are not currency's real blockchain precision (to view currency's actual individual precision, refer to fetchCurrencies() method).
            //
            var data interface{} = this.SafeValue(response, "symbols", []interface{}{})
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
                var market interface{} = GetValue(data, i)
                var id interface{} = this.SafeString(market, "symbol")
                var baseId interface{} = this.SafeString(market, "baseAsset")
                var quoteId interface{} = this.SafeString(market, "quoteAsset")
                var base interface{} = this.SafeCurrencyCode(baseId)
                var quote interface{} = this.SafeCurrencyCode(quoteId)
                var status interface{} = this.SafeString(market, "status")
                var isSpotTradingAllowed interface{} = this.SafeValue(market, "isSpotTradingAllowed")
                var active interface{} = false
                if IsTrue(IsTrue((IsEqual(status, "1"))) && IsTrue((isSpotTradingAllowed))) {
                    active = true
                }
                var isMarginTradingAllowed interface{} = this.SafeValue(market, "isMarginTradingAllowed")
                var makerCommission interface{} = this.SafeNumber(market, "makerCommission")
                var takerCommission interface{} = this.SafeNumber(market, "takerCommission")
                var maxQuoteAmount interface{} = this.SafeNumber(market, "maxQuoteAmount")
                AppendToArray(&result,map[string]interface{} {
                    "id": id,
                    "symbol": Add(Add(base, "/"), quote),
                    "base": base,
                    "quote": quote,
                    "settle": nil,
                    "baseId": baseId,
                    "quoteId": quoteId,
                    "settleId": nil,
                    "type": "spot",
                    "spot": true,
                    "margin": isMarginTradingAllowed,
                    "swap": false,
                    "future": false,
                    "option": false,
                    "active": active,
                    "contract": false,
                    "linear": nil,
                    "inverse": nil,
                    "taker": takerCommission,
                    "maker": makerCommission,
                    "contractSize": nil,
                    "expiry": nil,
                    "expiryDatetime": nil,
                    "strike": nil,
                    "optionType": nil,
                    "precision": map[string]interface{} {
                        "amount": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "baseAssetPrecision"))),
                        "price": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "quoteAssetPrecision"))),
                    },
                    "limits": map[string]interface{} {
                        "leverage": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "amount": map[string]interface{} {
                            "min": this.SafeNumber(market, "baseSizePrecision"),
                            "max": nil,
                        },
                        "price": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "cost": map[string]interface{} {
                            "min": this.SafeNumber(market, "quoteAmountPrecision"),
                            "max": maxQuoteAmount,
                        },
                    },
                    "created": nil,
                    "info": market,
                })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @ignore
 * @method
 * @name mexc#fetchMarkets
 * @description retrieves data on all swap markets for mexc
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-the-contract-information
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *mexc) FetchSwapMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var currentRl interface{} = this.RateLimit
            this.SetProperty(this, "rateLimit", 10) // see comment: https://github.com/ccxt/ccxt/pull/23698
        
            response:= (<-this.ContractPublicGetDetail(params))
            PanicOnError(response)
            this.SetProperty(this, "rateLimit", currentRl)
            //
            //     {
            //         "success":true,
            //         "code":0,
            //         "data":[
            //             {
            //                 "symbol":"BTC_USDT",
            //                 "displayName":"BTC_USDT永续",
            //                 "displayNameEn":"BTC_USDT SWAP",
            //                 "positionOpenType":3,
            //                 "baseCoin":"BTC",
            //                 "quoteCoin":"USDT",
            //                 "settleCoin":"USDT",
            //                 "contractSize":0.0001,
            //                 "minLeverage":1,
            //                 "maxLeverage":125,
            //                 "priceScale":2, // seems useless atm, as it's just how UI shows the price, i.e. 29583.50 for BTC/USDT:USDT, while price ticksize is 0.5
            //                 "volScale":0, // probably: contract amount precision
            //                 "amountScale":4, // probably: quote currency precision
            //                 "priceUnit":0.5, // price tick size
            //                 "volUnit":1, // probably: contract tick size
            //                 "minVol":1,
            //                 "maxVol":1000000,
            //                 "bidLimitPriceRate":0.1,
            //                 "askLimitPriceRate":0.1,
            //                 "takerFeeRate":0.0006,
            //                 "makerFeeRate":0.0002,
            //                 "maintenanceMarginRate":0.004,
            //                 "initialMarginRate":0.008,
            //                 "riskBaseVol":10000,
            //                 "riskIncrVol":200000,
            //                 "riskIncrMmr":0.004,
            //                 "riskIncrImr":0.004,
            //                 "riskLevelLimit":5,
            //                 "priceCoefficientVariation":0.1,
            //                 "indexOrigin":["BINANCE","GATEIO","HUOBI","MXC"],
            //                 "state":0, // 0 enabled, 1 delivery, 2 completed, 3 offline, 4 pause
            //                 "isNew":false,
            //                 "isHot":true,
            //                 "isHidden":false
            //             },
            //         ]
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", []interface{}{})
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
                var market interface{} = GetValue(data, i)
                var id interface{} = this.SafeString(market, "symbol")
                var baseId interface{} = this.SafeString(market, "baseCoin")
                var quoteId interface{} = this.SafeString(market, "quoteCoin")
                var settleId interface{} = this.SafeString(market, "settleCoin")
                var base interface{} = this.SafeCurrencyCode(baseId)
                var quote interface{} = this.SafeCurrencyCode(quoteId)
                var settle interface{} = this.SafeCurrencyCode(settleId)
                var state interface{} = this.SafeString(market, "state")
                var isLinear interface{} = IsEqual(quote, settle)
                AppendToArray(&result,map[string]interface{} {
                    "id": id,
                    "symbol": Add(Add(Add(Add(base, "/"), quote), ":"), settle),
                    "base": base,
                    "quote": quote,
                    "settle": settle,
                    "baseId": baseId,
                    "quoteId": quoteId,
                    "settleId": settleId,
                    "type": "swap",
                    "spot": false,
                    "margin": false,
                    "swap": true,
                    "future": false,
                    "option": false,
                    "active": (IsEqual(state, "0")),
                    "contract": true,
                    "linear": isLinear,
                    "inverse": !IsTrue(isLinear),
                    "taker": this.SafeNumber(market, "takerFeeRate"),
                    "maker": this.SafeNumber(market, "makerFeeRate"),
                    "contractSize": this.SafeNumber(market, "contractSize"),
                    "expiry": nil,
                    "expiryDatetime": nil,
                    "strike": nil,
                    "optionType": nil,
                    "precision": map[string]interface{} {
                        "amount": this.SafeNumber(market, "volUnit"),
                        "price": this.SafeNumber(market, "priceUnit"),
                    },
                    "limits": map[string]interface{} {
                        "leverage": map[string]interface{} {
                            "min": this.SafeNumber(market, "minLeverage"),
                            "max": this.SafeNumber(market, "maxLeverage"),
                        },
                        "amount": map[string]interface{} {
                            "min": this.SafeNumber(market, "minVol"),
                            "max": this.SafeNumber(market, "maxVol"),
                        },
                        "price": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "cost": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                    },
                    "created": nil,
                    "info": market,
                })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mexc#fetchOrderBook
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#order-book
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-the-contract-s-depth-information
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *mexc) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes14628 := (<-this.LoadMarkets())
            PanicOnError(retRes14628)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            var orderbook interface{} = nil
            if IsTrue(GetValue(market, "spot")) {
        
                response:= (<-this.SpotPublicGetDepth(this.Extend(request, params)))
                PanicOnError(response)
                //
                //     {
                //         "lastUpdateId": "744267132",
                //         "bids": [
                //             ["40838.50","0.387864"],
                //             ["40837.95","0.008400"],
                //         ],
                //         "asks": [
                //             ["40838.61","6.544908"],
                //             ["40838.88","0.498000"],
                //         ]
                //     }
                //
                var spotTimestamp interface{} = this.SafeInteger(response, "timestamp")
                orderbook = this.ParseOrderBook(response, symbol, spotTimestamp)
                AddElementToObject(orderbook, "nonce", this.SafeInteger(response, "lastUpdateId"))
            } else if IsTrue(GetValue(market, "swap")) {
        
                response:= (<-this.ContractPublicGetDepthSymbol(this.Extend(request, params)))
                PanicOnError(response)
                //
                //     {
                //         "success":true,
                //         "code":0,
                //         "data":{
                //             "asks":[
                //                 [3445.72,48379,1],
                //                 [3445.75,34994,1],
                //             ],
                //             "bids":[
                //                 [3445.55,44081,1],
                //                 [3445.51,24857,1],
                //             ],
                //             "version":2827730444,
                //             "timestamp":1634117846232
                //         }
                //     }
                //
                var data interface{} = this.SafeValue(response, "data")
                var timestamp interface{} = this.SafeInteger(data, "timestamp")
                orderbook = this.ParseOrderBook(data, symbol, timestamp)
                AddElementToObject(orderbook, "nonce", this.SafeInteger(data, "version"))
            }
        
            ch <- orderbook
            return nil
        
            }()
            return ch
        }
func  (this *mexc) ParseBidAsk(bidask interface{}, optionalArgs ...interface{}) interface{}  {
    priceKey := GetArg(optionalArgs, 0, 0)
    _ = priceKey
    amountKey := GetArg(optionalArgs, 1, 1)
    _ = amountKey
    countOrIdKey := GetArg(optionalArgs, 2, 2)
    _ = countOrIdKey
    var countKey interface{} = 2
    var price interface{} = this.SafeNumber(bidask, priceKey)
    var amount interface{} = this.SafeNumber(bidask, amountKey)
    var count interface{} = this.SafeNumber(bidask, countKey)
    if IsTrue(!IsEqual(count, nil)) {
        return []interface{}{price, amount, count}
    }
    return []interface{}{price, amount}
}
/**
 * @method
 * @name mexc#fetchTrades
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#recent-trades-list
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#compressed-aggregate-trades-list
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-contract-transaction-data
 * @description get the list of most recent trades for a particular symbol
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] *spot only* *since must be defined* the latest time in ms to fetch entries for
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *mexc) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes15438 := (<-this.LoadMarkets())
            PanicOnError(retRes15438)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            var trades interface{} = nil
            if IsTrue(GetValue(market, "spot")) {
                var until interface{} = this.SafeIntegerN(params, []interface{}{"endTime", "until"})
                if IsTrue(!IsEqual(since, nil)) {
                    AddElementToObject(request, "startTime", since)
                    if IsTrue(IsEqual(until, nil)) {
                        panic(ArgumentsRequired(Add(this.Id, " fetchTrades() requires an until parameter when since is provided")))
                    }
                }
                if IsTrue(!IsEqual(until, nil)) {
                    if IsTrue(IsEqual(since, nil)) {
                        panic(ArgumentsRequired(Add(this.Id, " fetchTrades() requires a since parameter when until is provided")))
                    }
                    AddElementToObject(request, "endTime", until)
                }
                var method interface{} = this.SafeString(this.Options, "fetchTradesMethod", "spotPublicGetAggTrades")
                method = this.SafeString(params, "method", method) // AggTrades, HistoricalTrades, Trades
                params = this.Omit(params, []interface{}{"method"})
                if IsTrue(IsEqual(method, "spotPublicGetAggTrades")) {
                    
        trades = (<-this.SpotPublicGetAggTrades(this.Extend(request, params)))
                    PanicOnError(trades)
                } else if IsTrue(IsEqual(method, "spotPublicGetHistoricalTrades")) {
                    
        trades = (<-this.SpotPublicGetHistoricalTrades(this.Extend(request, params)))
                    PanicOnError(trades)
                } else if IsTrue(IsEqual(method, "spotPublicGetTrades")) {
                    
        trades = (<-this.SpotPublicGetTrades(this.Extend(request, params)))
                    PanicOnError(trades)
                } else {
                    panic(NotSupported(Add(this.Id, " fetchTrades() not support this method")))
                }
            } else if IsTrue(GetValue(market, "swap")) {
        
                response:= (<-this.ContractPublicGetDealsSymbol(this.Extend(request, params)))
                PanicOnError(response)
                //
                //     {
                //         "success": true,
                //         "code": 0,
                //         "data": [
                //             {
                //                 "p": 31199,
                //                 "v": 18,
                //                 "T": 1,
                //                 "O": 3,
                //                 "M": 2,
                //                 "t": 1609831235985
                //             },
                //         ]
                //     }
                //
                trades = this.SafeValue(response, "data")
            }
        
            ch <- this.ParseTrades(trades, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *mexc) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = nil
    var timestamp interface{} = nil
    var orderId interface{} = nil
    var symbol interface{} = nil
    var fee interface{} = nil
    var typeVar interface{} = nil
    var side interface{} = nil
    var takerOrMaker interface{} = nil
    var priceString interface{} = nil
    var amountString interface{} = nil
    var costString interface{} = nil
    // if swap
    if IsTrue(InOp(trade, "v")) {
        //
        // swap: fetchTrades
        //
        //     {
        //         "p": 31199,
        //         "v": 18,
        //         "T": 1,
        //         "O": 3,
        //         "M": 2,
        //         "t": 1609831235985
        //     }
        //
        timestamp = this.SafeInteger(trade, "t")
        market = this.SafeMarket(nil, market)
        symbol = GetValue(market, "symbol")
        priceString = this.SafeString(trade, "p")
        amountString = this.SafeString(trade, "v")
        side = this.ParseOrderSide(this.SafeString(trade, "T"))
        takerOrMaker = "taker"
    } else {
        //
        // spot: fetchTrades (for aggTrades)
        //
        //         {
        //             "a": null,
        //             "f": null,
        //             "l": null,
        //             "p": "40679",
        //             "q": "0.001309",
        //             "T": 1647551328000,
        //             "m": true,
        //             "M": true
        //         }
        //
        // spot: fetchMyTrades, fetchOrderTrades
        //
        //         {
        //             "symbol": "BTCUSDT",
        //             "id": "133948532984922113",
        //             "orderId": "133948532531949568",
        //             "orderListId": "-1",
        //             "price": "41995.51",
        //             "qty": "0.0002",
        //             "quoteQty": "8.399102",
        //             "commission": "0.016798204",
        //             "commissionAsset": "USDT",
        //             "time": "1647718055000",
        //             "isBuyer": true,
        //             "isMaker": false,
        //             "isBestMatch": true
        //         }
        //
        // swap: fetchMyTrades, fetchOrderTrades
        //
        //         {
        //             "id": "299444585",
        //             "symbol": "STEPN_USDT",
        //             "side": "1",
        //             "vol": "1",
        //             "price": "2.45455",
        //             "feeCurrency": "USDT",
        //             "fee": "0.00147273",
        //             "timestamp": "1648924557000",
        //             "profit": "0",
        //             "category": "1",
        //             "orderId": "265307163526610432",
        //             "positionMode": "1",
        //             "taker": true
        //         }
        //
        var marketId interface{} = this.SafeString(trade, "symbol")
        market = this.SafeMarket(marketId, market)
        symbol = GetValue(market, "symbol")
        id = this.SafeString2(trade, "id", "a")
        priceString = this.SafeString2(trade, "price", "p")
        orderId = this.SafeString(trade, "orderId")
        // if swap
        if IsTrue(InOp(trade, "positionMode")) {
            timestamp = this.SafeInteger(trade, "timestamp")
            amountString = this.SafeString(trade, "vol")
            side = this.ParseOrderSide(this.SafeString(trade, "side"))
            fee = map[string]interface{} {
                "cost": this.SafeString(trade, "fee"),
                "currency": this.SafeCurrencyCode(this.SafeString(trade, "feeCurrency")),
            }
            takerOrMaker = Ternary(IsTrue(this.SafeValue(trade, "taker")), "taker", "maker")
        } else {
            timestamp = this.SafeInteger2(trade, "time", "T")
            amountString = this.SafeString2(trade, "qty", "q")
            costString = this.SafeString(trade, "quoteQty")
            var isBuyer interface{} = this.SafeValue(trade, "isBuyer")
            var isMaker interface{} = this.SafeValue(trade, "isMaker")
            var buyerMaker interface{} = this.SafeValue2(trade, "isBuyerMaker", "m")
            if IsTrue(!IsEqual(isMaker, nil)) {
                takerOrMaker = Ternary(IsTrue(isMaker), "maker", "taker")
            }
            if IsTrue(!IsEqual(isBuyer, nil)) {
                side = Ternary(IsTrue(isBuyer), "buy", "sell")
            }
            if IsTrue(!IsEqual(buyerMaker, nil)) {
                side = Ternary(IsTrue(buyerMaker), "sell", "buy")
                takerOrMaker = "taker"
            }
            var feeAsset interface{} = this.SafeString(trade, "commissionAsset")
            if IsTrue(!IsEqual(feeAsset, nil)) {
                fee = map[string]interface{} {
                    "cost": this.SafeString(trade, "commission"),
                    "currency": this.SafeCurrencyCode(feeAsset),
                }
            }
        }
    }
    if IsTrue(IsEqual(id, nil)) {
        id = this.SyntheticTradeId(market, timestamp, side, amountString, priceString, typeVar, takerOrMaker)
    }
    return this.SafeTrade(map[string]interface{} {
        "id": id,
        "order": orderId,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "type": typeVar,
        "side": side,
        "takerOrMaker": takerOrMaker,
        "price": priceString,
        "amount": amountString,
        "cost": costString,
        "fee": fee,
        "info": trade,
    }, market)
}
func  (this *mexc) SyntheticTradeId(optionalArgs ...interface{}) interface{}  {
    // TODO: can be unified method? this approach is being used by multiple exchanges (mexc, woo-coinsbit, dydx, ...)
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    timestamp := GetArg(optionalArgs, 1, nil)
    _ = timestamp
    side := GetArg(optionalArgs, 2, nil)
    _ = side
    amount := GetArg(optionalArgs, 3, nil)
    _ = amount
    price := GetArg(optionalArgs, 4, nil)
    _ = price
    orderType := GetArg(optionalArgs, 5, nil)
    _ = orderType
    takerOrMaker := GetArg(optionalArgs, 6, nil)
    _ = takerOrMaker
    var id interface{} = ""
    if IsTrue(!IsEqual(timestamp, nil)) {
        id = Add(Add(this.NumberToString(timestamp), "-"), this.SafeString(market, "id", "_"))
        if IsTrue(!IsEqual(side, nil)) {
            id = Add(id, Add("-", side))
        }
        if IsTrue(!IsEqual(amount, nil)) {
            id = Add(id, Add("-", this.NumberToString(amount)))
        }
        if IsTrue(!IsEqual(price, nil)) {
            id = Add(id, Add("-", this.NumberToString(price)))
        }
        if IsTrue(!IsEqual(takerOrMaker, nil)) {
            id = Add(id, Add("-", takerOrMaker))
        }
        if IsTrue(!IsEqual(orderType, nil)) {
            id = Add(id, Add("-", orderType))
        }
    }
    return id
}
/**
 * @method
 * @name mexc#fetchOHLCV
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#kline-candlestick-data
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#k-line-data
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest candle to fetch
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *mexc) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes18178 := (<-this.LoadMarkets())
            PanicOnError(retRes18178)
            var market interface{} = this.Market(symbol)
            var maxLimit interface{} = Ternary(IsTrue((GetValue(market, "spot"))), 1000, 2000)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchOHLCV", "paginate", false);
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes182319 :=  (<-this.FetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, params, maxLimit))
                    PanicOnError(retRes182319)
                    ch <- retRes182319
                    return nil
            }
            var options interface{} = this.SafeValue(this.Options, "timeframes", map[string]interface{} {})
            var timeframes interface{} = this.SafeValue(options, GetValue(market, "type"), map[string]interface{} {})
            var timeframeValue interface{} = this.SafeString(timeframes, timeframe)
            var duration interface{} = Multiply(this.ParseTimeframe(timeframe), 1000)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "interval": timeframeValue,
            }
            var candles interface{} = nil
            if IsTrue(GetValue(market, "spot")) {
                var until interface{} = this.SafeIntegerN(params, []interface{}{"until", "endTime"})
                if IsTrue(!IsEqual(since, nil)) {
                    AddElementToObject(request, "startTime", since)
                    if IsTrue(IsEqual(until, nil)) {
                        // we have to calculate it assuming we can get at most 2000 entries per request
                        var end interface{} = this.Sum(since, Multiply(maxLimit, duration))
                        var now interface{} = this.Milliseconds()
                        AddElementToObject(request, "endTime", mathMin(end, now))
                    }
                }
                if IsTrue(!IsEqual(limit, nil)) {
                    AddElementToObject(request, "limit", limit)
                }
                if IsTrue(!IsEqual(until, nil)) {
                    params = this.Omit(params, []interface{}{"until"})
                    AddElementToObject(request, "endTime", until)
                }
        
                response:= (<-this.SpotPublicGetKlines(this.Extend(request, params)))
                PanicOnError(response)
                //
                //     [
                //       [
                //         1640804880000,
                //         "47482.36",
                //         "47482.36",
                //         "47416.57",
                //         "47436.1",
                //         "3.550717",
                //         1640804940000,
                //         "168387.3"
                //       ],
                //     ]
                //
                candles = response
            } else if IsTrue(GetValue(market, "swap")) {
                var until interface{} = this.SafeIntegerProductN(params, []interface{}{"until", "endTime"}, 0.001)
                if IsTrue(!IsEqual(since, nil)) {
                    AddElementToObject(request, "start", this.ParseToInt(Divide(since, 1000)))
                }
                if IsTrue(!IsEqual(until, nil)) {
                    params = this.Omit(params, []interface{}{"until"})
                    AddElementToObject(request, "end", until)
                }
                var priceType interface{} = this.SafeString(params, "price", "default")
                params = this.Omit(params, "price")
                var response interface{} = nil
                if IsTrue(IsEqual(priceType, "default")) {
                    
        response = (<-this.ContractPublicGetKlineSymbol(this.Extend(request, params)))
                    PanicOnError(response)
                } else if IsTrue(IsEqual(priceType, "index")) {
                    
        response = (<-this.ContractPublicGetKlineIndexPriceSymbol(this.Extend(request, params)))
                    PanicOnError(response)
                } else if IsTrue(IsEqual(priceType, "mark")) {
                    
        response = (<-this.ContractPublicGetKlineFairPriceSymbol(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    panic(NotSupported(Add(this.Id, " fetchOHLCV() not support this price type, [default, index, mark]")))
                }
                //
                //     {
                //         "success":true,
                //         "code":0,
                //         "data":{
                //             "time":[1634052300,1634052360,1634052420],
                //             "open":[3492.2,3491.3,3495.65],
                //             "close":[3491.3,3495.65,3495.2],
                //             "high":[3495.85,3496.55,3499.4],
                //             "low":[3491.15,3490.9,3494.2],
                //             "vol":[1740.0,351.0,314.0],
                //             "amount":[60793.623,12260.4885,10983.1375],
                //         }
                //     }
                //
                var data interface{} = this.SafeValue(response, "data")
                candles = this.ConvertTradingViewToOHLCV(data, "time", "open", "high", "low", "close", "vol")
            }
        
            ch <- this.ParseOHLCVs(candles, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *mexc) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.SafeInteger(ohlcv, 0), this.SafeNumber(ohlcv, 1), this.SafeNumber(ohlcv, 2), this.SafeNumber(ohlcv, 3), this.SafeNumber(ohlcv, 4), this.SafeNumber(ohlcv, 5)}
}
/**
 * @method
 * @name mexc#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#24hr-ticker-price-change-statistics
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-contract-trend-data
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *mexc) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes19328 := (<-this.LoadMarkets())
            PanicOnError(retRes19328)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            var isSingularMarket interface{} = false
            if IsTrue(!IsEqual(symbols, nil)) {
                var length interface{} =         GetArrayLength(symbols)
                isSingularMarket = IsEqual(length, 1)
                var firstSymbol interface{} = this.SafeString(symbols, 0)
                market = this.Market(firstSymbol)
            }
            marketTypequeryVariable := this.HandleMarketTypeAndParams("fetchTickers", market, params);
            marketType := GetValue(marketTypequeryVariable,0);
            query := GetValue(marketTypequeryVariable,1)
            var tickers interface{} = nil
            if IsTrue(isSingularMarket) {
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            if IsTrue(IsEqual(marketType, "spot")) {
                
        tickers = (<-this.SpotPublicGetTicker24hr(this.Extend(request, query)))
                PanicOnError(tickers)
            } else if IsTrue(IsEqual(marketType, "swap")) {
        
                response:= (<-this.ContractPublicGetTicker(this.Extend(request, query)))
                PanicOnError(response)
                //
                //     {
                //         "success":true,
                //         "code":0,
                //         "data":[
                //             {
                //                 "symbol":"ETH_USDT",
                //                 "lastPrice":3581.3,
                //                 "bid1":3581.25,
                //                 "ask1":3581.5,
                //                 "volume24":4045530,
                //                 "amount24":141331823.5755,
                //                 "holdVol":5832946,
                //                 "lower24Price":3413.4,
                //                 "high24Price":3588.7,
                //                 "riseFallRate":0.0275,
                //                 "riseFallValue":95.95,
                //                 "indexPrice":3580.7852,
                //                 "fairPrice":3581.08,
                //                 "fundingRate":0.000063,
                //                 "maxBidPrice":3938.85,
                //                 "minAskPrice":3222.7,
                //                 "timestamp":1634162885016
                //             },
                //         ]
                //     }
                //
                tickers = this.SafeValue(response, "data", []interface{}{})
            }
            // when it's single symbol request, the returned structure is different (singular object) for both spot & swap, thus we need to wrap inside array
            if IsTrue(isSingularMarket) {
                tickers = []interface{}{tickers}
            }
        
            ch <- this.ParseTickers(tickers, symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mexc#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#24hr-ticker-price-change-statistics
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-contract-trend-data
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *mexc) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes20228 := (<-this.LoadMarkets())
            PanicOnError(retRes20228)
            var market interface{} = this.Market(symbol)
            marketTypequeryVariable := this.HandleMarketTypeAndParams("fetchTicker", market, params);
            marketType := GetValue(marketTypequeryVariable,0);
            query := GetValue(marketTypequeryVariable,1)
            var ticker interface{} = nil
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(IsEqual(marketType, "spot")) {
                
        ticker = (<-this.SpotPublicGetTicker24hr(this.Extend(request, query)))
                PanicOnError(ticker)
            } else if IsTrue(IsEqual(marketType, "swap")) {
        
                response:= (<-this.ContractPublicGetTicker(this.Extend(request, query)))
                PanicOnError(response)
                //
                //     {
                //         "success":true,
                //         "code":0,
                //         "data":{
                //             "symbol":"ETH_USDT",
                //             "lastPrice":3581.3,
                //             "bid1":3581.25,
                //             "ask1":3581.5,
                //             "volume24":4045530,
                //             "amount24":141331823.5755,
                //             "holdVol":5832946,
                //             "lower24Price":3413.4,
                //             "high24Price":3588.7,
                //             "riseFallRate":0.0275,
                //             "riseFallValue":95.95,
                //             "indexPrice":3580.7852,
                //             "fairPrice":3581.08,
                //             "fundingRate":0.000063,
                //             "maxBidPrice":3938.85,
                //             "minAskPrice":3222.7,
                //             "timestamp":1634162885016
                //         }
                //     }
                //
                ticker = this.SafeValue(response, "data", map[string]interface{} {})
            }
        
                // when it's single symbol request, the returned structure is different (singular object) for both spot & swap, thus we need to wrap inside array
        ch <- this.ParseTicker(ticker, market)
            return nil
        
            }()
            return ch
        }
func  (this *mexc) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(ticker, "symbol")
    market = this.SafeMarket(marketId, market)
    var timestamp interface{} = nil
    var bid interface{} = nil
    var ask interface{} = nil
    var bidVolume interface{} = nil
    var askVolume interface{} = nil
    var baseVolume interface{} = nil
    var quoteVolume interface{} = nil
    var open interface{} = nil
    var high interface{} = nil
    var low interface{} = nil
    var changePcnt interface{} = nil
    var changeValue interface{} = nil
    var prevClose interface{} = nil
    var isSwap interface{} = this.SafeValue(market, "swap")
    // if swap
    if IsTrue(IsTrue(isSwap) || IsTrue((InOp(ticker, "timestamp")))) {
        //
        //     {
        //         "symbol": "ETH_USDT",
        //         "lastPrice": 3581.3,
        //         "bid1": 3581.25,
        //         "ask1": 3581.5,
        //         "volume24": 4045530,
        //         "amount24": 141331823.5755,
        //         "holdVol": 5832946,
        //         "lower24Price": 3413.4,
        //         "high24Price": 3588.7,
        //         "riseFallRate": 0.0275,
        //         "riseFallValue": 95.95,
        //         "indexPrice": 3580.7852,
        //         "fairPrice": 3581.08,
        //         "fundingRate": 0.000063,
        //         "maxBidPrice": 3938.85,
        //         "minAskPrice": 3222.7,
        //         "timestamp": 1634162885016
        //     }
        //
        timestamp = this.SafeInteger(ticker, "timestamp")
        bid = this.SafeString(ticker, "bid1")
        ask = this.SafeString(ticker, "ask1")
        baseVolume = this.SafeString(ticker, "volume24")
        quoteVolume = this.SafeString(ticker, "amount24")
        high = this.SafeString(ticker, "high24Price")
        low = this.SafeString(ticker, "lower24Price")
        changeValue = this.SafeString(ticker, "riseFallValue")
        changePcnt = this.SafeString(ticker, "riseFallRate")
        changePcnt = Precise.StringMul(changePcnt, "100")
    } else {
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "priceChange": "184.34",
        //         "priceChangePercent": "0.00400048",
        //         "prevClosePrice": "46079.37",
        //         "lastPrice": "46263.71",
        //         "lastQty": "",
        //         "bidPrice": "46260.38",
        //         "bidQty": "",
        //         "askPrice": "46260.41",
        //         "askQty": "",
        //         "openPrice": "46079.37",
        //         "highPrice": "47550.01",
        //         "lowPrice": "45555.5",
        //         "volume": "1732.461487",
        //         "quoteVolume": null,
        //         "openTime": 1641349500000,
        //         "closeTime": 1641349582808,
        //         "count": null
        //     }
        //
        timestamp = this.SafeInteger(ticker, "closeTime")
        bid = this.SafeString(ticker, "bidPrice")
        ask = this.SafeString(ticker, "askPrice")
        bidVolume = this.SafeString(ticker, "bidQty")
        askVolume = this.SafeString(ticker, "askQty")
        if IsTrue(Precise.StringEq(bidVolume, "0")) {
            bidVolume = nil
        }
        if IsTrue(Precise.StringEq(askVolume, "0")) {
            askVolume = nil
        }
        baseVolume = this.SafeString(ticker, "volume")
        quoteVolume = this.SafeString(ticker, "quoteVolume")
        open = this.SafeString(ticker, "openPrice")
        high = this.SafeString(ticker, "highPrice")
        low = this.SafeString(ticker, "lowPrice")
        prevClose = this.SafeString(ticker, "prevClosePrice")
        changeValue = this.SafeString(ticker, "priceChange")
        changePcnt = this.SafeString(ticker, "priceChangePercent")
        changePcnt = Precise.StringMul(changePcnt, "100")
    }
    return this.SafeTicker(map[string]interface{} {
        "symbol": GetValue(market, "symbol"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "open": open,
        "high": high,
        "low": low,
        "close": this.SafeString(ticker, "lastPrice"),
        "bid": bid,
        "bidVolume": bidVolume,
        "ask": ask,
        "askVolume": askVolume,
        "vwap": nil,
        "previousClose": prevClose,
        "change": changeValue,
        "percentage": changePcnt,
        "average": nil,
        "baseVolume": baseVolume,
        "quoteVolume": quoteVolume,
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name mexc#fetchBidsAsks
 * @description fetches the bid and ask price and volume for multiple markets
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#symbol-order-book-ticker
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the bids and asks for, all markets are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *mexc) FetchBidsAsks(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes22138 := (<-this.LoadMarkets())
            PanicOnError(retRes22138)
            var market interface{} = nil
            var isSingularMarket interface{} = false
            if IsTrue(!IsEqual(symbols, nil)) {
                var length interface{} =         GetArrayLength(symbols)
                isSingularMarket = IsEqual(length, 1)
                market = this.Market(GetValue(symbols, 0))
            }
            marketTypequeryVariable := this.HandleMarketTypeAndParams("fetchBidsAsks", market, params);
            marketType := GetValue(marketTypequeryVariable,0);
            query := GetValue(marketTypequeryVariable,1)
            var tickers interface{} = nil
            if IsTrue(IsEqual(marketType, "spot")) {
                
        tickers = (<-this.SpotPublicGetTickerBookTicker(query))
                PanicOnError(tickers)
            } else if IsTrue(IsEqual(marketType, "swap")) {
                panic(NotSupported(Add(Add(Add(this.Id, " fetchBidsAsks() is not available for "), marketType), " markets")))
            }
            // when it's single symbol request, the returned structure is different (singular object) for both spot & swap, thus we need to wrap inside array
            if IsTrue(isSingularMarket) {
                tickers = []interface{}{tickers}
            }
        
            ch <- this.ParseTickers(tickers, symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mexc#createMarketBuyOrderWithCost
 * @description create a market buy order by providing the symbol and cost
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#new-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {float} cost how much you want to trade in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *mexc) CreateMarketBuyOrderWithCost(symbol interface{}, cost interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes22578 := (<-this.LoadMarkets())
            PanicOnError(retRes22578)
            var market interface{} = this.Market(symbol)
            if !IsTrue(GetValue(market, "spot")) {
                panic(NotSupported(Add(this.Id, " createMarketBuyOrderWithCost() supports spot orders only")))
            }
            AddElementToObject(params, "cost", cost)
        
                retRes226315 :=  (<-this.CreateOrder(symbol, "market", "buy", 0, nil, params))
                PanicOnError(retRes226315)
                ch <- retRes226315
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mexc#createMarketSellOrderWithCost
 * @description create a market sell order by providing the symbol and cost
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#new-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {float} cost how much you want to trade in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *mexc) CreateMarketSellOrderWithCost(symbol interface{}, cost interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes22778 := (<-this.LoadMarkets())
            PanicOnError(retRes22778)
            var market interface{} = this.Market(symbol)
            if !IsTrue(GetValue(market, "spot")) {
                panic(NotSupported(Add(this.Id, " createMarketBuyOrderWithCost() supports spot orders only")))
            }
            AddElementToObject(params, "cost", cost)
        
                retRes228315 :=  (<-this.CreateOrder(symbol, "market", "sell", 0, nil, params))
                PanicOnError(retRes228315)
                ch <- retRes228315
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mexc#createOrder
 * @description create a trade order
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#new-order
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#order-under-maintenance
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#trigger-order-under-maintenance
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] only 'isolated' is supported for spot-margin trading
 * @param {float} [params.triggerPrice] The price at which a trigger order is triggered at
 * @param {bool} [params.postOnly] if true, the order will only be posted if it will be a maker order
 * @param {bool} [params.reduceOnly] *contract only* indicates if this order is to reduce the size of a position
 * @param {bool} [params.hedged] *swap only* true for hedged mode, false for one way mode, default is false
 * @param {string} [params.timeInForce] 'IOC' or 'FOK', default is 'GTC'
 * EXCHANGE SPECIFIC PARAMETERS
 * @param {int} [params.leverage] *contract only* leverage is necessary on isolated margin
 * @param {long} [params.positionId] *contract only* it is recommended to fill in this parameter when closing a position
 * @param {string} [params.externalOid] *contract only* external order ID
 * @param {int} [params.positionMode] *contract only*  1:hedge, 2:one-way, default: the user's current config
 * @param {boolean} [params.test] *spot only* whether to use the test endpoint or not, default is false
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *mexc) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes23148 := (<-this.LoadMarkets())
            PanicOnError(retRes23148)
            var market interface{} = this.Market(symbol)
            marginModequeryVariable := this.HandleMarginModeAndParams("createOrder", params);
            marginMode := GetValue(marginModequeryVariable,0);
            query := GetValue(marginModequeryVariable,1)
            if IsTrue(GetValue(market, "spot")) {
        
                    retRes231819 :=  (<-this.CreateSpotOrder(market, typeVar, side, amount, price, marginMode, query))
                    PanicOnError(retRes231819)
                    ch <- retRes231819
                    return nil
            } else {
        
                    retRes232019 :=  (<-this.CreateSwapOrder(market, typeVar, side, amount, price, marginMode, query))
                    PanicOnError(retRes232019)
                    ch <- retRes232019
                    return nil
            }
                return nil
            }()
            return ch
        }
func  (this *mexc) CreateSpotOrderRequest(market interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    price := GetArg(optionalArgs, 0, nil)
    _ = price
    marginMode := GetArg(optionalArgs, 1, nil)
    _ = marginMode
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    var symbol interface{} = GetValue(market, "symbol")
    var orderSide interface{} = ToUpper(side)
    var request interface{} = map[string]interface{} {
        "symbol": GetValue(market, "id"),
        "side": orderSide,
        "type": ToUpper(typeVar),
    }
    if IsTrue(IsEqual(typeVar, "market")) {
        var cost interface{} = this.SafeNumber2(params, "cost", "quoteOrderQty")
        params = this.Omit(params, "cost")
        if IsTrue(!IsEqual(cost, nil)) {
            amount = cost
            AddElementToObject(request, "quoteOrderQty", this.CostToPrecision(symbol, amount))
        } else {
            if IsTrue(IsEqual(price, nil)) {
                AddElementToObject(request, "quantity", this.AmountToPrecision(symbol, amount))
            } else {
                var amountString interface{} = this.NumberToString(amount)
                var priceString interface{} = this.NumberToString(price)
                var quoteAmount interface{} = Precise.StringMul(amountString, priceString)
                amount = quoteAmount
                AddElementToObject(request, "quoteOrderQty", this.CostToPrecision(symbol, amount))
            }
        }
    } else {
        AddElementToObject(request, "quantity", this.AmountToPrecision(symbol, amount))
    }
    if IsTrue(!IsEqual(price, nil)) {
        AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
    }
    var clientOrderId interface{} = this.SafeString(params, "clientOrderId")
    if IsTrue(!IsEqual(clientOrderId, nil)) {
        AddElementToObject(request, "newClientOrderId", clientOrderId)
        params = this.Omit(params, []interface{}{"type", "clientOrderId"})
    }
    if IsTrue(!IsEqual(marginMode, nil)) {
        if IsTrue(!IsEqual(marginMode, "isolated")) {
            panic(BadRequest(Add(Add(Add(this.Id, " createOrder() does not support marginMode "), marginMode), " for spot-margin trading")))
        }
    }
    var postOnly interface{} = nil
    postOnlyparamsVariable := this.HandlePostOnly(IsEqual(typeVar, "market"), IsEqual(typeVar, "LIMIT_MAKER"), params);
    postOnly = GetValue(postOnlyparamsVariable,0);
    params = GetValue(postOnlyparamsVariable,1)
    if IsTrue(postOnly) {
        AddElementToObject(request, "type", "LIMIT_MAKER")
    }
    var tif interface{} = this.SafeString(params, "timeInForce")
    if IsTrue(!IsEqual(tif, nil)) {
        params = this.Omit(params, "timeInForce")
        if IsTrue(IsEqual(tif, "IOC")) {
            AddElementToObject(request, "type", "IMMEDIATE_OR_CANCEL")
        } else if IsTrue(IsEqual(tif, "FOK")) {
            AddElementToObject(request, "type", "FILL_OR_KILL")
        }
    }
    return this.Extend(request, params)
}
/**
 * @ignore
 * @method
 * @name mexc#createSpotOrder
 * @description create a trade order
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#new-order
 * @param {string} market unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {string} [marginMode] only 'isolated' is supported for spot-margin trading
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {bool} [params.postOnly] if true, the order will only be posted if it will be a maker order
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *mexc) CreateSpotOrder(market interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            marginMode := GetArg(optionalArgs, 1, nil)
            _ = marginMode
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes23998 := (<-this.LoadMarkets())
            PanicOnError(retRes23998)
            var test interface{} = this.SafeBool(params, "test", false)
            params = this.Omit(params, "test")
            var request interface{} = this.CreateSpotOrderRequest(market, typeVar, side, amount, price, marginMode, params)
            var response interface{} = nil
            if IsTrue(test) {
                
        response = (<-this.SpotPrivatePostOrderTest(request))
                PanicOnError(response)
            } else {
                
        response = (<-this.SpotPrivatePostOrder(request))
                PanicOnError(response)
            }
            //
            // spot
            //
            //     {
            //         "symbol": "BTCUSDT",
            //         "orderId": "123738410679123456",
            //         "orderListId": -1
            //     }
            //
            // margin
            //
            //     {
            //         "symbol": "BTCUSDT",
            //         "orderId": "762634301354414080",
            //         "clientOrderId": null,
            //         "isIsolated": true,
            //         "transactTime": 1661992652132
            //     }
            //
            var order interface{} = this.ParseOrder(response, market)
            AddElementToObject(order, "side", side)
            AddElementToObject(order, "type", typeVar)
            if IsTrue(IsEqual(this.SafeString(order, "price"), nil)) {
                AddElementToObject(order, "price", price)
            }
            if IsTrue(IsEqual(this.SafeString(order, "amount"), nil)) {
                AddElementToObject(order, "amount", amount)
            }
        
            ch <- order
            return nil
        
            }()
            return ch
        }
/**
 * @ignore
 * @method
 * @name mexc#createSwapOrder
 * @description create a trade order
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#new-order
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#order-under-maintenance
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#trigger-order-under-maintenance
 * @param {string} market unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {string} [marginMode] only 'isolated' is supported for spot-margin trading
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {float} [params.triggerPrice] The price at which a trigger order is triggered at
 * @param {bool} [params.postOnly] if true, the order will only be posted if it will be a maker order
 * @param {bool} [params.reduceOnly] indicates if this order is to reduce the size of a position
 * @param {bool} [params.hedged] *swap only* true for hedged mode, false for one way mode, default is false
 *
 * EXCHANGE SPECIFIC PARAMETERS
 * @param {int} [params.leverage] leverage is necessary on isolated margin
 * @param {long} [params.positionId] it is recommended to fill in this parameter when closing a position
 * @param {string} [params.externalOid] external order ID
 * @param {int} [params.positionMode] 1:hedge, 2:one-way, default: the user's current config
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *mexc) CreateSwapOrder(market interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            marginMode := GetArg(optionalArgs, 1, nil)
            _ = marginMode
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes24688 := (<-this.LoadMarkets())
            PanicOnError(retRes24688)
            var symbol interface{} = GetValue(market, "symbol")
            var unavailableContracts interface{} = this.SafeValue(this.Options, "unavailableContracts", map[string]interface{} {})
            var isContractUnavaiable interface{} = this.SafeBool(unavailableContracts, symbol, false)
            if IsTrue(isContractUnavaiable) {
                panic(NotSupported(Add(Add(this.Id, " createSwapOrder() does not support yet this symbol:"), symbol)))
            }
            var openType interface{} = nil
            if IsTrue(!IsEqual(marginMode, nil)) {
                if IsTrue(IsEqual(marginMode, "cross")) {
                    openType = 2
                } else if IsTrue(IsEqual(marginMode, "isolated")) {
                    openType = 1
                } else {
                    panic(ArgumentsRequired(Add(this.Id, " createSwapOrder() marginMode parameter should be either \"cross\" or \"isolated\"")))
                }
            } else {
                openType = this.SafeInteger(params, "openType", 2) // defaulting to cross margin
            }
            if IsTrue(IsTrue(IsTrue(IsTrue(IsTrue(IsTrue(IsTrue(IsTrue((!IsEqual(typeVar, "limit"))) && IsTrue((!IsEqual(typeVar, "market")))) && IsTrue((!IsEqual(typeVar, 1)))) && IsTrue((!IsEqual(typeVar, 2)))) && IsTrue((!IsEqual(typeVar, 3)))) && IsTrue((!IsEqual(typeVar, 4)))) && IsTrue((!IsEqual(typeVar, 5)))) && IsTrue((!IsEqual(typeVar, 6)))) {
                panic(InvalidOrder(Add(this.Id, " createSwapOrder() order type must either limit, market, or 1 for limit orders, 2 for post-only orders, 3 for IOC orders, 4 for FOK orders, 5 for market orders or 6 to convert market price to current price")))
            }
            var postOnly interface{} = nil
            postOnlyparamsVariable := this.HandlePostOnly(IsEqual(typeVar, "market"), IsEqual(typeVar, 2), params);
            postOnly = GetValue(postOnlyparamsVariable,0);
            params = GetValue(postOnlyparamsVariable,1)
            if IsTrue(postOnly) {
                typeVar = 2
            } else if IsTrue(IsEqual(typeVar, "limit")) {
                typeVar = 1
            } else if IsTrue(IsEqual(typeVar, "market")) {
                typeVar = 6
            }
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "vol": ParseFloat(this.AmountToPrecision(symbol, amount)),
                "type": typeVar,
                "openType": openType,
            }
            if IsTrue(IsTrue(IsTrue((!IsEqual(typeVar, 5))) && IsTrue((!IsEqual(typeVar, 6)))) && IsTrue((!IsEqual(typeVar, "market")))) {
                AddElementToObject(request, "price", ParseFloat(this.PriceToPrecision(symbol, price)))
            }
            if IsTrue(IsEqual(openType, 1)) {
                var leverage interface{} = this.SafeInteger(params, "leverage")
                if IsTrue(IsEqual(leverage, nil)) {
                    panic(ArgumentsRequired(Add(this.Id, " createSwapOrder() requires a leverage parameter for isolated margin orders")))
                }
            }
            var reduceOnly interface{} = this.SafeBool(params, "reduceOnly", false)
            var hedged interface{} = this.SafeBool(params, "hedged", false)
            var sideInteger interface{} = nil
            if IsTrue(hedged) {
                if IsTrue(reduceOnly) {
                    params = this.Omit(params, "reduceOnly") // hedged mode does not accept this parameter
                    side = Ternary(IsTrue((IsEqual(side, "buy"))), "sell", "buy")
                }
                sideInteger = Ternary(IsTrue((IsEqual(side, "buy"))), 1, 3)
                AddElementToObject(request, "positionMode", 1)
            } else {
                if IsTrue(reduceOnly) {
                    sideInteger = Ternary(IsTrue((IsEqual(side, "buy"))), 2, 4)
                } else {
                    sideInteger = Ternary(IsTrue((IsEqual(side, "buy"))), 1, 3)
                }
            }
            AddElementToObject(request, "side", sideInteger)
            var clientOrderId interface{} = this.SafeString2(params, "clientOrderId", "externalOid")
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                AddElementToObject(request, "externalOid", clientOrderId)
            }
            var triggerPrice interface{} = this.SafeNumber2(params, "triggerPrice", "stopPrice")
            params = this.Omit(params, []interface{}{"clientOrderId", "externalOid", "postOnly", "stopPrice", "triggerPrice", "hedged"})
            var response interface{} = nil
            if IsTrue(triggerPrice) {
                AddElementToObject(request, "triggerPrice", this.PriceToPrecision(symbol, triggerPrice))
                AddElementToObject(request, "triggerType", this.SafeInteger(params, "triggerType", 1))
                AddElementToObject(request, "executeCycle", this.SafeInteger(params, "executeCycle", 1))
                AddElementToObject(request, "trend", this.SafeInteger(params, "trend", 1))
                AddElementToObject(request, "orderType", this.SafeInteger(params, "orderType", 1))
                
        response = (<-this.ContractPrivatePostPlanorderPlace(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.ContractPrivatePostOrderSubmit(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            // Swap
            //     {"code":200,"data":"2ff3163e8617443cb9c6fc19d42b1ca4"}
            //
            // Trigger
            //     {"success":true,"code":0,"data":259208506303929856}
            //
            var data interface{} = this.SafeString(response, "data")
        
            ch <- this.SafeOrder(map[string]interface{} {
                "id": data,
            }, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mexc#createOrders
 * @description *spot only*  *all orders must have the same symbol* create a list of trade orders
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#batch-orders
 * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
 * @param {object} [params] extra parameters specific to api endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *mexc) CreateOrders(orders interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes25908 := (<-this.LoadMarkets())
            PanicOnError(retRes25908)
            var ordersRequests interface{} = []interface{}{}
            var symbol interface{} = nil
            for i := 0; IsLessThan(i, GetArrayLength(orders)); i++ {
                var rawOrder interface{} = GetValue(orders, i)
                var marketId interface{} = this.SafeString(rawOrder, "symbol")
                var market interface{} = this.Market(marketId)
                if !IsTrue(GetValue(market, "spot")) {
                    panic(NotSupported(Add(this.Id, " createOrders() is only supported for spot markets")))
                }
                if IsTrue(IsEqual(symbol, nil)) {
                    symbol = marketId
                } else {
                    if IsTrue(!IsEqual(symbol, marketId)) {
                        panic(BadRequest(Add(this.Id, " createOrders() requires all orders to have the same symbol")))
                    }
                }
                var typeVar interface{} = this.SafeString(rawOrder, "type")
                var side interface{} = this.SafeString(rawOrder, "side")
                var amount interface{} = this.SafeValue(rawOrder, "amount")
                var price interface{} = this.SafeValue(rawOrder, "price")
                var orderParams interface{} = this.SafeValue(rawOrder, "params", map[string]interface{} {})
                var marginMode interface{} = nil
                marginModeparamsVariable := this.HandleMarginModeAndParams("createOrder", params);
                marginMode = GetValue(marginModeparamsVariable,0);
                params = GetValue(marginModeparamsVariable,1)
                var orderRequest interface{} = this.CreateSpotOrderRequest(market, typeVar, side, amount, price, marginMode, orderParams)
                AppendToArray(&ordersRequests,orderRequest)
            }
            var request interface{} = map[string]interface{} {
                "batchOrders": this.Json(ordersRequests),
            }
        
            response:= (<-this.SpotPrivatePostBatchOrders(request))
            PanicOnError(response)
        
                //
            // [
            //     {
            //       "symbol": "BTCUSDT",
            //       "orderId": "1196315350023612316",
            //       "newClientOrderId": "hio8279hbdsds",
            //       "orderListId": -1
            //     },
            //     {
            //       "newClientOrderId": "123456",
            //       "msg": "The minimum transaction volume cannot be less than:0.5USDT",
            //       "code": 30002
            //     },
            //     {
            //       "symbol": "BTCUSDT",
            //       "orderId": "1196315350023612318",
            //       "orderListId": -1
            //     }
            // ]
            //
        ch <- this.ParseOrders(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mexc#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#query-order
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#query-the-order-based-on-the-order-number
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] only 'isolated' is supported, for spot-margin trading
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *mexc) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchOrder() requires a symbol argument")))
            }
        
            retRes26608 := (<-this.LoadMarkets())
            PanicOnError(retRes26608)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var data interface{} = nil
            if IsTrue(GetValue(market, "spot")) {
                var clientOrderId interface{} = this.SafeString(params, "clientOrderId")
                if IsTrue(!IsEqual(clientOrderId, nil)) {
                    params = this.Omit(params, "clientOrderId")
                    AddElementToObject(request, "origClientOrderId", clientOrderId)
                } else {
                    AddElementToObject(request, "orderId", id)
                }
                marginModequeryVariable := this.HandleMarginModeAndParams("fetchOrder", params);
                marginMode := GetValue(marginModequeryVariable,0);
                query := GetValue(marginModequeryVariable,1)
                if IsTrue(!IsEqual(marginMode, nil)) {
                    if IsTrue(!IsEqual(marginMode, "isolated")) {
                        panic(BadRequest(Add(Add(Add(this.Id, " fetchOrder() does not support marginMode "), marginMode), " for spot-margin trading")))
                    }
                    
        data = (<-this.SpotPrivateGetMarginOrder(this.Extend(request, query)))
                    PanicOnError(data)
                } else {
                    
        data = (<-this.SpotPrivateGetOrder(this.Extend(request, query)))
                    PanicOnError(data)
                }
            } else if IsTrue(GetValue(market, "swap")) {
                AddElementToObject(request, "order_id", id)
        
                response:= (<-this.ContractPrivateGetOrderGetOrderId(this.Extend(request, params)))
                PanicOnError(response)
                //
                //     {
                //         "success": true,
                //         "code": "0",
                //         "data": {
                //             "orderId": "264995729269765120",
                //             "symbol": "STEPN_USDT",
                //             "positionId": "0",
                //             "price": "2.2",
                //             "vol": "15",
                //             "leverage": "20",
                //             "side": "1",
                //             "category": "1",
                //             "orderType": "1",
                //             "dealAvgPrice": "0",
                //             "dealVol": "0",
                //             "orderMargin": "2.2528",
                //             "takerFee": "0",
                //             "makerFee": "0",
                //             "profit": "0",
                //             "feeCurrency": "USDT",
                //             "openType": "1",
                //             "state": "2",
                //             "externalOid": "_m_0e9520c256744d64b942985189026d20",
                //             "errorCode": "0",
                //             "usedMargin": "0",
                //             "createTime": "1648850305236",
                //             "updateTime": "1648850305245",
                //             "positionMode": "1"
                //         }
                //     }
                //
                data = this.SafeValue(response, "data")
            }
        
            ch <- this.ParseOrder(data, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mexc#fetchOrders
 * @description fetches information on multiple orders made by the user
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#all-orders
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-all-of-the-user-39-s-historical-orders
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#gets-the-trigger-order-list
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch orders for
 * @param {string} [params.marginMode] only 'isolated' is supported, for spot-margin trading
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *mexc) FetchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes27838 := (<-this.LoadMarkets())
            PanicOnError(retRes27838)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            var until interface{} = this.SafeInteger(params, "until")
            params = this.Omit(params, "until")
            marketTypequeryVariable := this.HandleMarketTypeAndParams("fetchOrders", market, params);
            marketType := GetValue(marketTypequeryVariable,0);
            query := GetValue(marketTypequeryVariable,1)
            if IsTrue(IsEqual(marketType, "spot")) {
                if IsTrue(IsEqual(symbol, nil)) {
                    panic(ArgumentsRequired(Add(this.Id, " fetchOrders() requires a symbol argument for spot market")))
                }
                marginModequeryInnerVariable := this.HandleMarginModeAndParams("fetchOrders", params);
                marginMode := GetValue(marginModequeryInnerVariable,0);
                queryInner := GetValue(marginModequeryInnerVariable,1)
                if IsTrue(!IsEqual(since, nil)) {
                    AddElementToObject(request, "startTime", since)
                }
                if IsTrue(!IsEqual(until, nil)) {
                    AddElementToObject(request, "endTime", until)
                }
                if IsTrue(!IsEqual(limit, nil)) {
                    AddElementToObject(request, "limit", limit)
                }
                var response interface{} = nil
                if IsTrue(!IsEqual(marginMode, nil)) {
                    if IsTrue(!IsEqual(marginMode, "isolated")) {
                        panic(BadRequest(Add(Add(Add(this.Id, " fetchOrders() does not support marginMode "), marginMode), " for spot-margin trading")))
                    }
                    
        response = (<-this.SpotPrivateGetMarginAllOrders(this.Extend(request, queryInner)))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.SpotPrivateGetAllOrders(this.Extend(request, queryInner)))
                    PanicOnError(response)
                }
        
                        //
                // spot
                //
                //     [
                //         {
                //             "symbol": "BTCUSDT",
                //             "orderId": "133949373632483328",
                //             "orderListId": "-1",
                //             "clientOrderId": null,
                //             "price": "45000",
                //             "origQty": "0.0002",
                //             "executedQty": "0",
                //             "cummulativeQuoteQty": "0",
                //             "status": "NEW",
                //             "timeInForce": null,
                //             "type": "LIMIT",
                //             "side": "SELL",
                //             "stopPrice": null,
                //             "icebergQty": null,
                //             "time": "1647718255000",
                //             "updateTime": "1647718255000",
                //             "isWorking": true,
                //             "origQuoteOrderQty": "9"
                //         },
                //     ]
                //
                // margin
                //
                //     [
                //         {
                //             "symbol": "BTCUSDT",
                //             "orderId": "763307297891028992",
                //             "orderListId": "-1",
                //             "clientOrderId": null,
                //             "price": "18000",
                //             "origQty": "0.0014",
                //             "executedQty": "0",
                //             "cummulativeQuoteQty": "0",
                //             "status": "NEW",
                //             "type": "LIMIT",
                //             "side": "BUY",
                //             "isIsolated": true,
                //             "isWorking": true,
                //             "time": 1662153107000,
                //             "updateTime": 1662153107000
                //         }
                //     ]
                //
        ch <- this.ParseOrders(response, market, since, limit)
                return nil
            } else {
                if IsTrue(!IsEqual(since, nil)) {
                    AddElementToObject(request, "start_time", since)
                    var end interface{} = this.SafeInteger(params, "end_time", until)
                    if IsTrue(IsEqual(end, nil)) {
                        AddElementToObject(request, "end_time", this.Sum(since, GetValue(this.Options, "maxTimeTillEnd")))
                    } else {
                        if IsTrue(IsGreaterThan((Subtract(end, since)), GetValue(this.Options, "maxTimeTillEnd"))) {
                            panic(BadRequest(Add(this.Id, " end is invalid, i.e. exceeds allowed 90 days.")))
                        } else {
                            AddElementToObject(request, "end_time", until)
                        }
                    }
                } else if IsTrue(!IsEqual(until, nil)) {
                    AddElementToObject(request, "start_time", this.Sum(until, Multiply(GetValue(this.Options, "maxTimeTillEnd"), OpNeg(1))))
                    AddElementToObject(request, "end_time", until)
                }
                if IsTrue(!IsEqual(limit, nil)) {
                    AddElementToObject(request, "page_size", limit)
                }
                var method interface{} = this.SafeString(this.Options, "fetchOrders", "contractPrivateGetOrderListHistoryOrders")
                method = this.SafeString(query, "method", method)
                var ordersOfRegular interface{} = []interface{}{}
                var ordersOfTrigger interface{} = []interface{}{}
                if IsTrue(IsEqual(method, "contractPrivateGetOrderListHistoryOrders")) {
        
                    response:= (<-this.ContractPrivateGetOrderListHistoryOrders(this.Extend(request, query)))
                    PanicOnError(response)
                    //
                    //     {
                    //         "success": true,
                    //         "code": "0",
                    //         "data": [
                    //             {
                    //                 "orderId": "265230764677709315",
                    //                 "symbol": "STEPN_USDT",
                    //                 "positionId": "0",
                    //                 "price": "2.1",
                    //                 "vol": "102",
                    //                 "leverage": "20",
                    //                 "side": "1",
                    //                 "category": "1",
                    //                 "orderType": "1",
                    //                 "dealAvgPrice": "0",
                    //                 "dealVol": "0",
                    //                 "orderMargin": "10.96704",
                    //                 "takerFee": "0",
                    //                 "makerFee": "0",
                    //                 "profit": "0",
                    //                 "feeCurrency": "USDT",
                    //                 "openType": "1",
                    //                 "state": "2",
                    //                 "externalOid": "_m_7e42f8df6b324c869e4e200397e2b00f",
                    //                 "errorCode": "0",
                    //                 "usedMargin": "0",
                    //                 "createTime": "1648906342000",
                    //                 "updateTime": "1648906342000",
                    //                 "positionMode": "1"
                    //             },
                    //          ]
                    //     }
                    //
                    ordersOfRegular = this.SafeValue(response, "data")
                } else {
                    // the Planorder endpoints work not only for stop-market orders, but also for stop-limit orders that were supposed to have a separate endpoint
        
                    response:= (<-this.ContractPrivateGetPlanorderListOrders(this.Extend(request, query)))
                    PanicOnError(response)
                    //
                    //     {
                    //         "success": true,
                    //         "code": "0",
                    //         "data": [
                    //             {
                    //                 "symbol": "STEPN_USDT",
                    //                 "leverage": "20",
                    //                 "side": "1",
                    //                 "vol": "13",
                    //                 "openType": "1",
                    //                 "state": "1",
                    //                 "orderType": "1",
                    //                 "errorCode": "0",
                    //                 "createTime": "1648984276000",
                    //                 "updateTime": "1648984276000",
                    //                 "id": "265557643326564352",
                    //                 "triggerType": "1",
                    //                 "triggerPrice": "3",
                    //                 "price": "2.9", // not present in stop-market, but in stop-limit order
                    //                 "executeCycle": "87600",
                    //                 "trend": "1",
                    //             },
                    //         ]
                    //     }
                    //
                    ordersOfTrigger = this.SafeValue(response, "data")
                }
                var merged interface{} = this.ArrayConcat(ordersOfTrigger, ordersOfRegular)
        
                ch <- this.ParseOrders(merged, market, since, limit, params)
                return nil
            }
                return nil
            }()
            return ch
        }
func  (this *mexc) FetchOrdersByIds(ids interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes29638 := (<-this.LoadMarkets())
            PanicOnError(retRes29638)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            marketTypequeryVariable := this.HandleMarketTypeAndParams("fetchOrdersByIds", market, params);
            marketType := GetValue(marketTypequeryVariable,0);
            query := GetValue(marketTypequeryVariable,1)
            if IsTrue(IsEqual(marketType, "spot")) {
                panic(BadRequest(Add(Add(this.Id, " fetchOrdersByIds() is not supported for "), marketType)))
            } else {
                AddElementToObject(request, "order_ids", Join(ids, ","))
        
                response:= (<-this.ContractPrivateGetOrderBatchQuery(this.Extend(request, query)))
                PanicOnError(response)
                //
                //     {
                //         "success": true,
                //         "code": "0",
                //         "data": [
                //             {
                //                 "orderId": "265230764677709315",
                //                 "symbol": "STEPN_USDT",
                //                 "positionId": "0",
                //                 "price": "2.1",
                //                 "vol": "102",
                //                 "leverage": "20",
                //                 "side": "1",
                //                 "category": "1",
                //                 "orderType": "1",
                //                 "dealAvgPrice": "0",
                //                 "dealVol": "0",
                //                 "orderMargin": "10.96704",
                //                 "takerFee": "0",
                //                 "makerFee": "0",
                //                 "profit": "0",
                //                 "feeCurrency": "USDT",
                //                 "openType": "1",
                //                 "state": "2",
                //                 "externalOid": "_m_7e42f8df6b324c869e4e200397e2b00f",
                //                 "errorCode": "0",
                //                 "usedMargin": "0",
                //                 "createTime": "1648906342000",
                //                 "updateTime": "1648906342000",
                //                 "positionMode": "1"
                //             }
                //         ]
                //     }
                //
                var data interface{} = this.SafeList(response, "data")
        
                ch <- this.ParseOrders(data, market)
                return nil
            }
                return nil
            }()
            return ch
        }
/**
 * @method
 * @name mexc#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#current-open-orders
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-all-of-the-user-39-s-historical-orders
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#gets-the-trigger-order-list
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] only 'isolated' is supported, for spot-margin trading
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *mexc) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes30308 := (<-this.LoadMarkets())
            PanicOnError(retRes30308)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            var marketType interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchOpenOrders", market, params);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            if IsTrue(IsEqual(marketType, "spot")) {
                if IsTrue(IsEqual(symbol, nil)) {
                    panic(ArgumentsRequired(Add(this.Id, " fetchOpenOrders() requires a symbol argument for spot market")))
                }
                AddElementToObject(request, "symbol", GetValue(market, "id"))
                marginModequeryVariable := this.HandleMarginModeAndParams("fetchOpenOrders", params);
                marginMode := GetValue(marginModequeryVariable,0);
                query := GetValue(marginModequeryVariable,1)
                var response interface{} = nil
                if IsTrue(!IsEqual(marginMode, nil)) {
                    if IsTrue(!IsEqual(marginMode, "isolated")) {
                        panic(BadRequest(Add(Add(Add(this.Id, " fetchOpenOrders() does not support marginMode "), marginMode), " for spot-margin trading")))
                    }
                    
        response = (<-this.SpotPrivateGetMarginOpenOrders(this.Extend(request, query)))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.SpotPrivateGetOpenOrders(this.Extend(request, query)))
                    PanicOnError(response)
                }
        
                        //
                // spot
                //
                //     [
                //         {
                //             "symbol": "BTCUSDT",
                //             "orderId": "133949373632483328",
                //             "orderListId": "-1",
                //             "clientOrderId": "",
                //             "price": "45000",
                //             "origQty": "0.0002",
                //             "executedQty": "0",
                //             "cummulativeQuoteQty": "0",
                //             "status": "NEW",
                //             "timeInForce": null,
                //             "type": "LIMIT",
                //             "side": "SELL",
                //             "stopPrice": null,
                //             "icebergQty": null,
                //             "time": "1647718255199",
                //             "updateTime": null,
                //             "isWorking": true,
                //             "origQuoteOrderQty": "9"
                //         }
                //     ]
                //
                // margin
                //
                //     [
                //         {
                //             "symbol": "BTCUSDT",
                //             "orderId": "764547676405633024",
                //             "orderListId": "-1",
                //             "clientOrderId": null,
                //             "price": "18000",
                //             "origQty": "0.0013",
                //             "executedQty": "0",
                //             "cummulativeQuoteQty": "0",
                //             "status": "NEW",
                //             "type": "LIMIT",
                //             "side": "BUY",
                //             "isIsolated": true,
                //             "isWorking": true,
                //             "time": 1662448836000,
                //             "updateTime": 1662448836000
                //         }
                //     ]
                //
        ch <- this.ParseOrders(response, market, since, limit)
                return nil
            } else {
        
                    retRes310419 :=  (<-this.FetchOrdersByState(2, symbol, since, limit, params))
                    PanicOnError(retRes310419)
                            // TO_DO: another possible way is through: open_orders/{symbol}, but as they have same ratelimits, and less granularity, i think historical orders are more convenient, as it supports more params (however, theoretically, open-orders endpoint might be sligthly fast)
        ch <- retRes310419
                    return nil
            }
                return nil
            }()
            return ch
        }
/**
 * @method
 * @name mexc#fetchClosedOrders
 * @description fetches information on multiple closed orders made by the user
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#all-orders
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-all-of-the-user-39-s-historical-orders
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#gets-the-trigger-order-list
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *mexc) FetchClosedOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
                retRes312215 :=  (<-this.FetchOrdersByState(3, symbol, since, limit, params))
                PanicOnError(retRes312215)
                ch <- retRes312215
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mexc#fetchCanceledOrders
 * @description fetches information on multiple canceled orders made by the user
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#all-orders
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-all-of-the-user-39-s-historical-orders
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#gets-the-trigger-order-list
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] timestamp in ms of the earliest order, default is undefined
 * @param {int} [limit] max number of orders to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *mexc) FetchCanceledOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
                retRes313915 :=  (<-this.FetchOrdersByState(4, symbol, since, limit, params))
                PanicOnError(retRes313915)
                ch <- retRes313915
                return nil
        
            }()
            return ch
        }
func  (this *mexc) FetchOrdersByState(state interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes31438 := (<-this.LoadMarkets())
            PanicOnError(retRes31438)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            marketTypeVariable := this.HandleMarketTypeAndParams("fetchOrdersByState", market, params);
            marketType := GetValue(marketTypeVariable,0)
            if IsTrue(IsEqual(marketType, "spot")) {
                panic(NotSupported(Add(Add(this.Id, " fetchOrdersByState() is not supported for "), marketType)))
            } else {
                AddElementToObject(request, "states", state)
        
                    retRes315419 :=  (<-this.FetchOrders(symbol, since, limit, this.Extend(request, params)))
                    PanicOnError(retRes315419)
                    ch <- retRes315419
                    return nil
            }
                return nil
            }()
            return ch
        }
/**
 * @method
 * @name mexc#cancelOrder
 * @description cancels an open order
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#cancel-order
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#cancel-the-order-under-maintenance
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#cancel-the-stop-limit-trigger-order-under-maintenance
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] only 'isolated' is supported for spot-margin trading
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *mexc) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes31728 := (<-this.LoadMarkets())
            PanicOnError(retRes31728)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            var marketType interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("cancelOrder", market, params);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            marginModequeryVariable := this.HandleMarginModeAndParams("cancelOrder", params);
            marginMode := GetValue(marginModequeryVariable,0);
            query := GetValue(marginModequeryVariable,1)
            var data interface{} = nil
            if IsTrue(IsEqual(marketType, "spot")) {
                if IsTrue(IsEqual(symbol, nil)) {
                    panic(ArgumentsRequired(Add(this.Id, " cancelOrder() requires a symbol argument")))
                }
                var requestInner interface{} = map[string]interface{} {
                    "symbol": GetValue(market, "id"),
                }
                var clientOrderId interface{} = this.SafeString(params, "clientOrderId")
                if IsTrue(!IsEqual(clientOrderId, nil)) {
                    params = this.Omit(query, "clientOrderId")
                    AddElementToObject(requestInner, "origClientOrderId", clientOrderId)
                } else {
                    AddElementToObject(requestInner, "orderId", id)
                }
                if IsTrue(!IsEqual(marginMode, nil)) {
                    if IsTrue(!IsEqual(marginMode, "isolated")) {
                        panic(BadRequest(Add(Add(Add(this.Id, " cancelOrder() does not support marginMode "), marginMode), " for spot-margin trading")))
                    }
                    
        data = (<-this.SpotPrivateDeleteMarginOrder(this.Extend(requestInner, query)))
                    PanicOnError(data)
                } else {
                    
        data = (<-this.SpotPrivateDeleteOrder(this.Extend(requestInner, query)))
                    PanicOnError(data)
                }
            } else {
                // TODO: PlanorderCancel endpoint has bug atm. waiting for fix.
                var method interface{} = this.SafeString(this.Options, "cancelOrder", "contractPrivatePostOrderCancel") // contractPrivatePostOrderCancel, contractPrivatePostPlanorderCancel
                method = this.SafeString(query, "method", method)
                var response interface{} = nil
                if IsTrue(IsEqual(method, "contractPrivatePostOrderCancel")) {
                    
        response = (<-this.ContractPrivatePostOrderCancel([]interface{}{id}))
                    PanicOnError(response) // the request cannot be changed or extended. This is the only way to send.
                } else if IsTrue(IsEqual(method, "contractPrivatePostPlanorderCancel")) {
                    
        response = (<-this.ContractPrivatePostPlanorderCancel([]interface{}{id}))
                    PanicOnError(response) // the request cannot be changed or extended. This is the only way to send.
                } else {
                    panic(NotSupported(Add(this.Id, " cancelOrder() not support this method")))
                }
                //
                //     {
                //         "success": true,
                //         "code": "0",
                //         "data": [
                //             {
                //                 "orderId": "264995729269765120",
                //                 "errorCode": "0",         // if already canceled: "2041"; if doesn't exist: "2040"
                //                 "errorMsg": "success",    // if already canceled: "order state cannot be cancelled"; if doesn't exist: "order not exist"
                //             }
                //         ]
                //     }
                //
                data = this.SafeValue(response, "data")
                var order interface{} = this.SafeValue(data, 0)
                var errorMsg interface{} = this.SafeValue(order, "errorMsg", "")
                if IsTrue(!IsEqual(errorMsg, "success")) {
                    panic(InvalidOrder(Add(Add(Add(Add(this.Id, " cancelOrder() the order with id "), id), " cannot be cancelled: "), errorMsg)))
                }
            }
        
            ch <- this.ParseOrder(data, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mexc#cancelOrders
 * @description cancel multiple orders
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#cancel-the-order-under-maintenance
 * @param {string[]} ids order ids
 * @param {string} symbol unified market symbol, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *mexc) CancelOrders(ids interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes32858 := (<-this.LoadMarkets())
            PanicOnError(retRes32858)
            var market interface{} = Ternary(IsTrue((!IsEqual(symbol, nil))), this.Market(symbol), nil)
            marketTypeVariable := this.HandleMarketTypeAndParams("cancelOrders", market, params);
            marketType := GetValue(marketTypeVariable,0)
            if IsTrue(IsEqual(marketType, "spot")) {
                panic(BadRequest(Add(Add(this.Id, " cancelOrders() is not supported for "), marketType)))
            } else {
        
                response:= (<-this.ContractPrivatePostOrderCancel(ids))
                PanicOnError(response) // the request cannot be changed or extended. The only way to send.
                //
                //     {
                //         "success": true,
                //         "code": "0",
                //         "data": [
                //             {
                //                 "orderId": "264995729269765120",
                //                 "errorCode": "0",         // if already canceled: "2041"
                //                 "errorMsg": "success",    // if already canceled: "order state cannot be cancelled"
                //             },
                //         ]
                //     }
                //
                var data interface{} = this.SafeList(response, "data")
        
                ch <- this.ParseOrders(data, market)
                return nil
            }
                return nil
            }()
            return ch
        }
/**
 * @method
 * @name mexc#cancelAllOrders
 * @description cancel all open orders
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#cancel-all-open-orders-on-a-symbol
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#cancel-all-orders-under-a-contract-under-maintenance
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#cancel-all-trigger-orders-under-maintenance
 * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] only 'isolated' is supported for spot-margin trading
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *mexc) CancelAllOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes33238 := (<-this.LoadMarkets())
            PanicOnError(retRes33238)
            var market interface{} = Ternary(IsTrue((!IsEqual(symbol, nil))), this.Market(symbol), nil)
            var request interface{} = map[string]interface{} {}
            var marketType interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("cancelAllOrders", market, params);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            marginModequeryVariable := this.HandleMarginModeAndParams("cancelAllOrders", params);
            marginMode := GetValue(marginModequeryVariable,0);
            query := GetValue(marginModequeryVariable,1)
            if IsTrue(IsEqual(marketType, "spot")) {
                if IsTrue(IsEqual(symbol, nil)) {
                    panic(ArgumentsRequired(Add(this.Id, " cancelAllOrders() requires a symbol argument on spot")))
                }
                AddElementToObject(request, "symbol", GetValue(market, "id"))
                var response interface{} = nil
                if IsTrue(!IsEqual(marginMode, nil)) {
                    if IsTrue(!IsEqual(marginMode, "isolated")) {
                        panic(BadRequest(Add(Add(Add(this.Id, " cancelAllOrders() does not support marginMode "), marginMode), " for spot-margin trading")))
                    }
                    
        response = (<-this.SpotPrivateDeleteMarginOpenOrders(this.Extend(request, query)))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.SpotPrivateDeleteOpenOrders(this.Extend(request, query)))
                    PanicOnError(response)
                }
        
                        //
                // spot
                //
                //     [
                //         {
                //             "symbol": "BTCUSDT",
                //             "orderId": "133926492139692032",
                //             "price": "30000",
                //             "origQty": "0.0002",
                //             "type": "LIMIT",
                //             "side": "BUY"
                //         },
                //     ]
                //
                // margin
                //
                //     [
                //         {
                //             "symbol": "BTCUSDT",
                //             "orderId": "762640232574226432",
                //             "orderListId": "-1",
                //             "clientOrderId": null,
                //             "price": "18000",
                //             "origQty": "0.00147",
                //             "executedQty": "0",
                //             "cummulativeQuoteQty": "0",
                //             "status": "NEW",
                //             "type": "LIMIT",
                //             "side": "BUY",
                //             "isIsolated": true,
                //             "isWorking": true,
                //             "time": 1661994066000,
                //             "updateTime": 1661994066000
                //         }
                //     ]
                //
        ch <- this.ParseOrders(response, market)
                return nil
            } else {
                if IsTrue(!IsEqual(symbol, nil)) {
                    AddElementToObject(request, "symbol", GetValue(market, "id"))
                }
                // method can be either: contractPrivatePostOrderCancelAll or contractPrivatePostPlanorderCancelAll
                // the Planorder endpoints work not only for stop-market orders but also for stop-limit orders that are supposed to have separate endpoint
                var method interface{} = this.SafeString(this.Options, "cancelAllOrders", "contractPrivatePostOrderCancelAll")
                method = this.SafeString(query, "method", method)
                var response interface{} = nil
                if IsTrue(IsEqual(method, "contractPrivatePostOrderCancelAll")) {
                    
        response = (<-this.ContractPrivatePostOrderCancelAll(this.Extend(request, query)))
                    PanicOnError(response)
                } else if IsTrue(IsEqual(method, "contractPrivatePostPlanorderCancelAll")) {
                    
        response = (<-this.ContractPrivatePostPlanorderCancelAll(this.Extend(request, query)))
                    PanicOnError(response)
                }
                //
                //     {
                //         "success": true,
                //         "code": "0"
                //     }
                //
                var data interface{} = this.SafeList(response, "data", []interface{}{})
        
                ch <- this.ParseOrders(data, market)
                return nil
            }
                return nil
            }()
            return ch
        }
func  (this *mexc) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // spot: createOrder
    //
    //     {
    //         "symbol": "BTCUSDT",
    //         "orderId": "123738410679123456",
    //         "orderListId": -1
    //     }
    //
    // margin: createOrder
    //
    //     {
    //         "symbol": "BTCUSDT",
    //         "orderId": "762634301354414080",
    //         "clientOrderId": null,
    //         "isIsolated": true,
    //         "transactTime": 1661992652132
    //     }
    //
    // spot: cancelOrder, cancelAllOrders
    //
    //     {
    //         "symbol": "BTCUSDT",
    //         "orderId": "133926441921286144",
    //         "price": "30000",
    //         "origQty": "0.0002",
    //         "type": "LIMIT",
    //         "side": "BUY"
    //     }
    //
    // margin: cancelOrder, cancelAllOrders
    //
    //     {
    //         "symbol": "BTCUSDT",
    //         "orderId": "762640232574226432",
    //         "orderListId": "-1",
    //         "clientOrderId": null,
    //         "price": "18000",
    //         "origQty": "0.00147",
    //         "executedQty": "0",
    //         "cummulativeQuoteQty": "0",
    //         "status": "NEW",
    //         "type": "LIMIT",
    //         "side": "BUY",
    //         "isIsolated": true,
    //         "isWorking": true,
    //         "time": 1661994066000,
    //         "updateTime": 1661994066000
    //     }
    //
    // spot: fetchOrder, fetchOpenOrders, fetchOrders
    //
    //     {
    //         "symbol": "BTCUSDT",
    //         "orderId": "133734823834147272",
    //         "orderListId": "-1",
    //         "clientOrderId": null,
    //         "price": "30000",
    //         "origQty": "0.0002",
    //         "executedQty": "0",
    //         "cummulativeQuoteQty": "0",
    //         "status": "CANCELED",
    //         "timeInForce": null,
    //         "type": "LIMIT",
    //         "side": "BUY",
    //         "stopPrice": null,
    //         "icebergQty": null,
    //         "time": "1647667102000",
    //         "updateTime": "1647708567000",
    //         "isWorking": true,
    //         "origQuoteOrderQty": "6"
    //     }
    //
    // margin: fetchOrder, fetchOrders
    //
    //     {
    //         "symbol": "BTCUSDT",
    //         "orderId": "763307297891028992",
    //         "orderListId": "-1",
    //         "clientOrderId": null,
    //         "price": "18000",
    //         "origQty": "0.0014",
    //         "executedQty": "0",
    //         "cummulativeQuoteQty": "0",
    //         "status": "NEW",
    //         "type": "LIMIT",
    //         "side": "BUY",
    //         "isIsolated": true,
    //         "isWorking": true,
    //         "time": 1662153107000,
    //         "updateTime": 1662153107000
    //     }
    //
    // swap: createOrder
    //
    //     2ff3163e8617443cb9c6fc19d42b1ca4
    //
    // swap: fetchOrder, fetchOrders
    //
    //     regular
    //     {
    //         "orderId": "264995729269765120",
    //         "symbol": "STEPN_USDT",
    //         "positionId": "0",
    //         "price": "2.2",
    //         "vol": "15",
    //         "leverage": "20",
    //         "side": "1", // TODO: not unified
    //         "category": "1",
    //         "orderType": "1", // TODO: not unified
    //         "dealAvgPrice": "0",
    //         "dealVol": "0",
    //         "orderMargin": "2.2528",
    //         "takerFee": "0",
    //         "makerFee": "0",
    //         "profit": "0",
    //         "feeCurrency": "USDT",
    //         "openType": "1",
    //         "state": "2", // TODO
    //         "externalOid": "_m_0e9520c256744d64b942985189026d20",
    //         "errorCode": "0",
    //         "usedMargin": "0",
    //         "createTime": "1648850305236",
    //         "updateTime": "1648850305245",
    //         "positionMode": "1"
    //     }
    //
    //     stop
    //     {
    //         "id": "265557643326564352",
    //         "triggerType": "1",
    //         "triggerPrice": "3",
    //         "price": "2.9", // not present in stop-market, but in stop-limit order
    //         "executeCycle": "87600",
    //         "trend": "1",
    //          // below keys are same as in regular order structure
    //         "symbol": "STEPN_USDT",
    //         "leverage": "20",
    //         "side": "1",
    //         "vol": "13",
    //         "openType": "1",
    //         "state": "1",
    //         "orderType": "1",
    //         "errorCode": "0",
    //         "createTime": "1648984276000",
    //         "updateTime": "1648984276000",
    //     }
    //
    // createOrders error
    //
    //     {
    //         "newClientOrderId": "123456",
    //         "msg": "The minimum transaction volume cannot be less than:0.5USDT",
    //         "code": 30002
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var code interface{} = this.SafeInteger(order, "code")
    if IsTrue(!IsEqual(code, nil)) {
        // error upon placing multiple orders
        return this.SafeOrder(map[string]interface{} {
            "info": order,
            "status": "rejected",
            "clientOrderId": this.SafeString(order, "newClientOrderId"),
        })
    }
    var id interface{} = nil
    if IsTrue(IsString(order)) {
        id = order
    } else {
        id = this.SafeString2(order, "orderId", "id")
    }
    var marketId interface{} = this.SafeString(order, "symbol")
    market = this.SafeMarket(marketId, market)
    var timestamp interface{} = this.SafeIntegerN(order, []interface{}{"time", "createTime", "transactTime"})
    var fee interface{} = nil
    var feeCurrency interface{} = this.SafeString(order, "feeCurrency")
    if IsTrue(!IsEqual(feeCurrency, nil)) {
        var takerFee interface{} = this.SafeString(order, "takerFee")
        var makerFee interface{} = this.SafeString(order, "makerFee")
        var feeSum interface{} = Precise.StringAdd(takerFee, makerFee)
        fee = map[string]interface{} {
            "currency": feeCurrency,
            "cost": this.ParseNumber(feeSum),
        }
    }
    return this.SafeOrder(map[string]interface{} {
        "id": id,
        "clientOrderId": this.SafeString(order, "clientOrderId"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "status": this.ParseOrderStatus(this.SafeString2(order, "status", "state")),
        "symbol": GetValue(market, "symbol"),
        "type": this.ParseOrderType(this.SafeString(order, "type")),
        "timeInForce": this.ParseOrderTimeInForce(this.SafeString(order, "timeInForce")),
        "side": this.ParseOrderSide(this.SafeString(order, "side")),
        "price": this.SafeNumber(order, "price"),
        "triggerPrice": this.SafeNumber2(order, "stopPrice", "triggerPrice"),
        "average": this.SafeNumber(order, "dealAvgPrice"),
        "amount": this.SafeNumber2(order, "origQty", "vol"),
        "cost": this.SafeNumber(order, "cummulativeQuoteQty"),
        "filled": this.SafeNumber2(order, "executedQty", "dealVol"),
        "remaining": nil,
        "fee": fee,
        "trades": nil,
        "info": order,
    }, market)
}
func  (this *mexc) ParseOrderSide(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "BUY": "buy",
        "SELL": "sell",
        "1": "buy",
        "2": "sell",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *mexc) ParseOrderType(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "MARKET": "market",
        "LIMIT": "limit",
        "LIMIT_MAKER": "limit",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *mexc) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "NEW": "open",
        "FILLED": "closed",
        "CANCELED": "canceled",
        "PARTIALLY_FILLED": "open",
        "PARTIALLY_CANCELED": "canceled",
        "2": "open",
        "3": "closed",
        "4": "canceled",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *mexc) ParseOrderTimeInForce(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "GTC": "GTC",
        "FOK": "FOK",
        "IOC": "IOC",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *mexc) FetchAccountHelper(typeVar interface{}, params interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    if IsTrue(IsEqual(typeVar, "spot")) {
        
                    retRes366319 :=  (<-this.SpotPrivateGetAccount(params))
                    PanicOnError(retRes366319)
                    ch <- retRes366319
                    return nil
            } else if IsTrue(IsEqual(typeVar, "swap")) {
        
                response:= (<-this.ContractPrivateGetAccountAssets(params))
                PanicOnError(response)
        
                        //
                //     {
                //         "success":true,
                //         "code":0,
                //         "data":[
                //            {
                //              "currency":"BSV",
                //              "positionMargin":0,
                //              "availableBalance":0,
                //              "cashBalance":0,
                //              "frozenBalance":0,
                //              "equity":0,
                //              "unrealized":0,
                //              "bonus":0
                //           },
                //         ]
                //     }
                //
        ch <- this.SafeValue(response, "data")
                return nil
            }
        
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mexc#fetchAccounts
 * @description fetch all the accounts associated with a profile
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#account-information
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-all-informations-of-user-39-s-asset
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/#/?id=account-structure} indexed by the account type
 */
func  (this *mexc) FetchAccounts(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    // TODO: is the below endpoints suitable for fetchAccounts?
            params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            marketTypequeryVariable := this.HandleMarketTypeAndParams("fetchAccounts", nil, params);
            marketType := GetValue(marketTypequeryVariable,0);
            query := GetValue(marketTypequeryVariable,1)
        
            retRes37298 := (<-this.LoadMarkets())
            PanicOnError(retRes37298)
        
            response:= (<-this.FetchAccountHelper(marketType, query))
            PanicOnError(response)
            var data interface{} = this.SafeValue(response, "balances", []interface{}{})
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
                var account interface{} = GetValue(data, i)
                var currencyId interface{} = this.SafeString2(account, "asset", "currency")
                var code interface{} = this.SafeCurrencyCode(currencyId)
                AppendToArray(&result,map[string]interface{} {
                    "id": this.SafeString(account, "id"),
                    "type": this.SafeString(account, "type"),
                    "code": code,
                    "info": account,
                })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mexc#fetchTradingFee
 * @description fetch the trading fees for a market
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#query-mx-deduct-status
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func  (this *mexc) FetchTradingFee(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes37578 := (<-this.LoadMarkets())
            PanicOnError(retRes37578)
            var market interface{} = this.Market(symbol)
            if !IsTrue(GetValue(market, "spot")) {
                panic(BadRequest(Add(this.Id, " fetchTradingFee() supports spot markets only")))
            }
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.SpotPrivateGetTradeFee(this.Extend(request, params)))
            PanicOnError(response)
            //
            //  {
            //      "data":{
            //        "makerCommission":0.003000000000000000,
            //        "takerCommission":0.003000000000000000
            //      },
            //      "code":0,
            //      "msg":"success",
            //      "timestamp":1669109672717
            //  }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- map[string]interface{} {
                "info": data,
                "symbol": symbol,
                "maker": this.SafeNumber(data, "makerCommission"),
                "taker": this.SafeNumber(data, "takerCommission"),
                "percentage": nil,
                "tierBased": nil,
            }
            return nil
        
            }()
            return ch
        }
func  (this *mexc) CustomParseBalance(response interface{}, marketType interface{}) interface{}  {
    //
    // spot
    //
    //     {
    //         "asset": "USDT",
    //         "free": "0.000000000674",
    //         "locked": "0"
    //     }
    //
    // swap
    //
    //     {
    //         "currency": "BSV",
    //         "positionMargin": 0,
    //         "availableBalance": 0,
    //         "cashBalance": 0,
    //         "frozenBalance": 0,
    //         "equity": 0,
    //         "unrealized": 0,
    //         "bonus": 0
    //     }
    //
    // margin
    //
    //     {
    //         "baseAsset": {
    //             "asset": "BTC",
    //             "borrowEnabled": true,
    //             "borrowed": "0",
    //             "free": "0",
    //             "interest": "0",
    //             "locked": "0",
    //             "netAsset": "0",
    //             "netAssetOfBtc": "0",
    //             "repayEnabled": true,
    //             "totalAsset": "0"
    //         }
    //         "quoteAsset": {
    //             "asset": "USDT",
    //             "borrowEnabled": true,
    //             "borrowed": "0",
    //             "free": "10",
    //             "interest": "0",
    //             "locked": "0",
    //             "netAsset": "10",
    //             "netAssetOfBtc": "0",
    //             "repayEnabled": true,
    //             "totalAsset": "10"
    //         }
    //         "symbol": "BTCUSDT",
    //         "isolatedCreated": true,
    //         "enabled": true,
    //         "marginLevel": "999",
    //         "marginRatio": "9",
    //         "indexPrice": "16741.137068965517241379",
    //         "liquidatePrice": "--",
    //         "liquidateRate": "--",
    //         "tradeEnabled": true
    //     }
    //
    var wallet interface{} = nil
    if IsTrue(IsEqual(marketType, "margin")) {
        wallet = this.SafeValue(response, "assets", []interface{}{})
    } else if IsTrue(IsEqual(marketType, "swap")) {
        wallet = this.SafeValue(response, "data", []interface{}{})
    } else {
        wallet = this.SafeValue(response, "balances", []interface{}{})
    }
    var result interface{} = map[string]interface{} {
        "info": response,
    }
    if IsTrue(IsEqual(marketType, "margin")) {
        for i := 0; IsLessThan(i, GetArrayLength(wallet)); i++ {
            var entry interface{} = GetValue(wallet, i)
            var marketId interface{} = this.SafeString(entry, "symbol")
            var symbol interface{} = this.SafeSymbol(marketId, nil)
            var base interface{} = this.SafeValue(entry, "baseAsset", map[string]interface{} {})
            var quote interface{} = this.SafeValue(entry, "quoteAsset", map[string]interface{} {})
            var baseCode interface{} = this.SafeCurrencyCode(this.SafeString(base, "asset"))
            var quoteCode interface{} = this.SafeCurrencyCode(this.SafeString(quote, "asset"))
            var subResult interface{} = map[string]interface{} {}
            AddElementToObject(subResult, baseCode, this.ParseBalanceHelper(base))
            AddElementToObject(subResult, quoteCode, this.ParseBalanceHelper(quote))
            AddElementToObject(result, symbol, this.SafeBalance(subResult))
        }
        return result
    } else if IsTrue(IsEqual(marketType, "swap")) {
        for i := 0; IsLessThan(i, GetArrayLength(wallet)); i++ {
            var entry interface{} = GetValue(wallet, i)
            var currencyId interface{} = this.SafeString(entry, "currency")
            var code interface{} = this.SafeCurrencyCode(currencyId)
            var account interface{} = this.Account()
            AddElementToObject(account, "free", this.SafeString(entry, "availableBalance"))
            AddElementToObject(account, "used", this.SafeString(entry, "frozenBalance"))
            AddElementToObject(result, code, account)
        }
        return this.SafeBalance(result)
    } else {
        for i := 0; IsLessThan(i, GetArrayLength(wallet)); i++ {
            var entry interface{} = GetValue(wallet, i)
            var currencyId interface{} = this.SafeString(entry, "asset")
            var code interface{} = this.SafeCurrencyCode(currencyId)
            var account interface{} = this.Account()
            AddElementToObject(account, "free", this.SafeString(entry, "free"))
            AddElementToObject(account, "used", this.SafeString(entry, "locked"))
            AddElementToObject(result, code, account)
        }
        return this.SafeBalance(result)
    }
}
func  (this *mexc) ParseBalanceHelper(entry interface{}) interface{}  {
    var account interface{} = this.Account()
    AddElementToObject(account, "used", this.SafeString(entry, "locked"))
    AddElementToObject(account, "free", this.SafeString(entry, "free"))
    AddElementToObject(account, "total", this.SafeString(entry, "totalAsset"))
    var debt interface{} = this.SafeString(entry, "borrowed")
    var interest interface{} = this.SafeString(entry, "interest")
    AddElementToObject(account, "debt", Precise.StringAdd(debt, interest))
    return account
}
/**
 * @method
 * @name mexc#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#account-information
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-all-informations-of-user-39-s-asset
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#isolated-account
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.symbols] // required for margin, market id's separated by commas
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *mexc) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes39218 := (<-this.LoadMarkets())
            PanicOnError(retRes39218)
            var marketType interface{} = nil
            var request interface{} = map[string]interface{} {}
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchBalance", nil, params);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            var marginMode interface{} = this.SafeString(params, "marginMode")
            var isMargin interface{} = this.SafeBool(params, "margin", false)
            params = this.Omit(params, []interface{}{"margin", "marginMode"})
            var response interface{} = nil
            if IsTrue(IsTrue(IsTrue((!IsEqual(marginMode, nil))) || IsTrue((isMargin))) || IsTrue((IsEqual(marketType, "margin")))) {
                var parsedSymbols interface{} = nil
                var symbol interface{} = this.SafeString(params, "symbol")
                if IsTrue(IsEqual(symbol, nil)) {
                    var symbols interface{} = this.SafeValue(params, "symbols")
                    if IsTrue(!IsEqual(symbols, nil)) {
                        parsedSymbols = Join(this.MarketIds(symbols), ",")
                    }
                } else {
                    var market interface{} = this.Market(symbol)
                    parsedSymbols = GetValue(market, "id")
                }
                this.CheckRequiredArgument("fetchBalance", parsedSymbols, "symbol or symbols")
                marketType = "margin"
                AddElementToObject(request, "symbols", parsedSymbols)
                params = this.Omit(params, []interface{}{"symbol", "symbols"})
                
        response = (<-this.SpotPrivateGetMarginIsolatedAccount(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(marketType, "spot")) {
                
        response = (<-this.SpotPrivateGetAccount(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(marketType, "swap")) {
                
        response = (<-this.ContractPrivateGetAccountAssets(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                panic(NotSupported(Add(this.Id, " fetchBalance() not support this method")))
            }
        
                //
            // spot
            //
            //     {
            //         "makerCommission": 0,
            //         "takerCommission": 20,
            //         "buyerCommission": 0,
            //         "sellerCommission": 0,
            //         "canTrade": true,
            //         "canWithdraw": true,
            //         "canDeposit": true,
            //         "updateTime": null,
            //         "accountType": "SPOT",
            //         "balances": [
            //             {
            //                 "asset": "USDT",
            //                 "free": "0.000000000674",
            //                 "locked": "0"
            //             },
            //         ],
            //         "permissions": ["SPOT"]
            //     }
            //
            // swap
            //
            //     {
            //         "success": true,
            //         "code": 0,
            //         "data": [
            //             {
            //                 "currency": "BSV",
            //                 "positionMargin": 0,
            //                 "availableBalance": 0,
            //                 "cashBalance": 0,
            //                 "frozenBalance": 0,
            //                 "equity": 0,
            //                 "unrealized": 0,
            //                 "bonus": 0
            //             },
            //         ]
            //     }
            //
            // margin
            //
            //     {
            //         "assets": [
            //             {
            //                 "baseAsset": {
            //                     "asset": "BTC",
            //                     "borrowEnabled": true,
            //                     "borrowed": "0",
            //                     "free": "0",
            //                     "interest": "0",
            //                     "locked": "0",
            //                     "netAsset": "0",
            //                     "netAssetOfBtc": "0",
            //                     "repayEnabled": true,
            //                     "totalAsset": "0"
            //                 },
            //                 "quoteAsset": {
            //                     "asset": "USDT",
            //                     "borrowEnabled": true,
            //                     "borrowed": "0",
            //                     "free": "10",
            //                     "interest": "0",
            //                     "locked": "0",
            //                     "netAsset": "10",
            //                     "netAssetOfBtc": "0",
            //                     "repayEnabled": true,
            //                     "totalAsset": "10"
            //                 },
            //                 "symbol": "BTCUSDT",
            //                 "isolatedCreated": true,
            //                 "enabled": true,
            //                 "marginLevel": "999",
            //                 "marginRatio": "9",
            //                 "indexPrice": "16741.137068965517241379",
            //                 "liquidatePrice": "--",
            //                 "liquidateRate": "--",
            //                 "tradeEnabled": true
            //             }
            //         ]
            //     }
            //
        ch <- this.CustomParseBalance(response, marketType)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mexc#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#account-trade-list
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-all-transaction-details-of-the-user-s-order
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch trades for
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *mexc) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchMyTrades() requires a symbol argument")))
            }
        
            retRes40578 := (<-this.LoadMarkets())
            PanicOnError(retRes40578)
            var market interface{} = this.Market(symbol)
            var marketType interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchMyTrades", market, params);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var trades interface{} = nil
            if IsTrue(IsEqual(marketType, "spot")) {
                if IsTrue(!IsEqual(since, nil)) {
                    AddElementToObject(request, "startTime", since)
                }
                if IsTrue(!IsEqual(limit, nil)) {
                    AddElementToObject(request, "limit", limit)
                }
                var until interface{} = this.SafeInteger(params, "until")
                if IsTrue(!IsEqual(until, nil)) {
                    params = this.Omit(params, "until")
                    AddElementToObject(request, "endTime", until)
                }
                
        trades = (<-this.SpotPrivateGetMyTrades(this.Extend(request, params)))
                PanicOnError(trades)
            } else {
                if IsTrue(!IsEqual(since, nil)) {
                    AddElementToObject(request, "start_time", since)
                    var end interface{} = this.SafeInteger(params, "end_time")
                    if IsTrue(IsEqual(end, nil)) {
                        AddElementToObject(request, "end_time", this.Sum(since, GetValue(this.Options, "maxTimeTillEnd")))
                    }
                }
                if IsTrue(!IsEqual(limit, nil)) {
                    AddElementToObject(request, "page_size", limit)
                }
        
                response:= (<-this.ContractPrivateGetOrderListOrderDeals(this.Extend(request, params)))
                PanicOnError(response)
                //
                //     {
                //         "success": true,
                //         "code": "0",
                //         "data": [
                //             {
                //                 "id": "299444585",
                //                 "symbol": "STEPN_USDT",
                //                 "side": "1",
                //                 "vol": "1",
                //                 "price": "2.45455",
                //                 "feeCurrency": "USDT",
                //                 "fee": "0.00147273",
                //                 "timestamp": "1648924557000",
                //                 "profit": "0",
                //                 "category": "1",
                //                 "orderId": "265307163526610432",
                //                 "positionMode": "1",
                //                 "taker": true
                //             }
                //         ]
                //     }
                //
                trades = this.SafeValue(response, "data")
            }
        
            ch <- this.ParseTrades(trades, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mexc#fetchOrderTrades
 * @description fetch all the trades made from a single order
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#account-trade-list
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#query-the-order-based-on-the-order-number
 * @param {string} id order id
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *mexc) FetchOrderTrades(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes41538 := (<-this.LoadMarkets())
            PanicOnError(retRes41538)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            marketTypequeryVariable := this.HandleMarketTypeAndParams("fetchOrderTrades", market, params);
            marketType := GetValue(marketTypequeryVariable,0);
            query := GetValue(marketTypequeryVariable,1)
            var trades interface{} = nil
            if IsTrue(IsEqual(marketType, "spot")) {
                if IsTrue(IsEqual(symbol, nil)) {
                    panic(ArgumentsRequired(Add(this.Id, " fetchOrderTrades() requires a symbol argument")))
                }
                AddElementToObject(request, "symbol", GetValue(market, "id"))
                AddElementToObject(request, "orderId", id)
                
        trades = (<-this.SpotPrivateGetMyTrades(this.Extend(request, query)))
                PanicOnError(trades)
            } else {
                AddElementToObject(request, "order_id", id)
        
                response:= (<-this.ContractPrivateGetOrderDealDetailsOrderId(this.Extend(request, query)))
                PanicOnError(response)
                //
                //     {
                //         "success": true,
                //         "code": "0",
                //         "data": [
                //             {
                //                 "id": "299444585",
                //                 "symbol": "STEPN_USDT",
                //                 "side": "1",
                //                 "vol": "1",
                //                 "price": "2.45455",
                //                 "feeCurrency": "USDT",
                //                 "fee": "0.00147273",
                //                 "timestamp": "1648924557000",
                //                 "profit": "0",
                //                 "category": "1",
                //                 "orderId": "265307163526610432",
                //                 "positionMode": "1",
                //                 "taker": true
                //             }
                //         ]
                //     }
                //
                trades = this.SafeValue(response, "data")
            }
        
            ch <- this.ParseTrades(trades, market, since, limit, query)
            return nil
        
            }()
            return ch
        }
func  (this *mexc) ModifyMarginHelper(symbol interface{}, amount interface{}, addOrReduce interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var positionId interface{} = this.SafeInteger(params, "positionId")
            if IsTrue(IsEqual(positionId, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " modifyMarginHelper() requires a positionId parameter")))
            }
        
            retRes42258 := (<-this.LoadMarkets())
            PanicOnError(retRes42258)
            var request interface{} = map[string]interface{} {
                "positionId": positionId,
                "amount": amount,
                "type": addOrReduce,
            }
        
            response:= (<-this.ContractPrivatePostPositionChangeMargin(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "success": true,
            //         "code": 0
            //     }
        ch <- response
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mexc#reduceMargin
 * @description remove margin from a position
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#increase-or-decrease-margin
 * @param {string} symbol unified market symbol
 * @param {float} amount the amount of margin to remove
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=reduce-margin-structure}
 */
func  (this *mexc) ReduceMargin(symbol interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes425115 :=  (<-this.ModifyMarginHelper(symbol, amount, "SUB", params))
                PanicOnError(retRes425115)
                ch <- retRes425115
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mexc#addMargin
 * @description add margin
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#increase-or-decrease-margin
 * @param {string} symbol unified market symbol
 * @param {float} amount amount of margin to add
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=add-margin-structure}
 */
func  (this *mexc) AddMargin(symbol interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes426515 :=  (<-this.ModifyMarginHelper(symbol, amount, "ADD", params))
                PanicOnError(retRes426515)
                ch <- retRes426515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mexc#setLeverage
 * @description set the level of leverage for a market
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#switch-leverage
 * @param {float} leverage the rate of leverage
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} response from the exchange
 */
func  (this *mexc) SetLeverage(leverage interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes42798 := (<-this.LoadMarkets())
            PanicOnError(retRes42798)
            var request interface{} = map[string]interface{} {
                "leverage": leverage,
            }
            var positionId interface{} = this.SafeInteger(params, "positionId")
            if IsTrue(IsEqual(positionId, nil)) {
                var openType interface{} = this.SafeNumber(params, "openType") // 1 or 2
                var positionType interface{} = this.SafeNumber(params, "positionType") // 1 or 2
                var market interface{} = Ternary(IsTrue((!IsEqual(symbol, nil))), this.Market(symbol), nil)
                if IsTrue(IsTrue(IsTrue((IsEqual(openType, nil))) || IsTrue((IsEqual(positionType, nil)))) || IsTrue((IsEqual(market, nil)))) {
                    panic(ArgumentsRequired(Add(this.Id, " setLeverage() requires a positionId parameter or a symbol argument with openType and positionType parameters, use openType 1 or 2 for isolated or cross margin respectively, use positionType 1 or 2 for long or short positions")))
                } else {
                    AddElementToObject(request, "openType", openType)
                    AddElementToObject(request, "symbol", GetValue(market, "id"))
                    AddElementToObject(request, "positionType", positionType)
                }
            } else {
                AddElementToObject(request, "positionId", positionId)
            }
        
                retRes429815 :=  (<-this.ContractPrivatePostPositionChangeLeverage(this.Extend(request, params)))
                PanicOnError(retRes429815)
                ch <- retRes429815
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mexc#fetchFundingHistory
 * @description fetch the history of funding payments paid and received on this account
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-details-of-user-s-funding-rate
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch funding history for
 * @param {int} [limit] the maximum number of funding history structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding history structure]{@link https://docs.ccxt.com/#/?id=funding-history-structure}
 */
func  (this *mexc) FetchFundingHistory(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes43138 := (<-this.LoadMarkets())
            PanicOnError(retRes43138)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "page_size", limit)
            }
        
            response:= (<-this.ContractPrivateGetPositionFundingRecords(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "code": 0,
            //         "data": {
            //             "pageSize": 20,
            //             "totalCount": 2,
            //             "totalPage": 1,
            //             "currentPage": 1,
            //             "resultList": [
            //                 {
            //                     "id": 7423910,
            //                     "symbol": "BTC_USDT",
            //                     "positionType": 1,
            //                     "positionValue": 29.30024,
            //                     "funding": 0.00076180624,
            //                     "rate": -0.000026,
            //                     "settleTime": 1643299200000
            //                 },
            //                 {
            //                     "id": 7416473,
            //                     "symbol": "BTC_USDT",
            //                     "positionType": 1,
            //                     "positionValue": 28.9188,
            //                     "funding": 0.0014748588,
            //                     "rate": -0.000051,
            //                     "settleTime": 1643270400000
            //                 }
            //             ]
            //         }
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
            var resultList interface{} = this.SafeValue(data, "resultList", []interface{}{})
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(resultList)); i++ {
                var entry interface{} = GetValue(resultList, i)
                var timestamp interface{} = this.SafeInteger(entry, "settleTime")
                AppendToArray(&result,map[string]interface{} {
                    "info": entry,
                    "symbol": symbol,
                    "code": nil,
                    "timestamp": timestamp,
                    "datetime": this.Iso8601(timestamp),
                    "id": this.SafeNumber(entry, "id"),
                    "amount": this.SafeNumber(entry, "funding"),
                })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *mexc) ParseFundingRate(contract interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "symbol": "BTC_USDT",
    //         "fundingRate": 0.000014,
    //         "maxFundingRate": 0.003,
    //         "minFundingRate": -0.003,
    //         "collectCycle": 8,
    //         "nextSettleTime": 1643241600000,
    //         "timestamp": 1643240373359
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var nextFundingRate interface{} = this.SafeNumber(contract, "fundingRate")
    var nextFundingTimestamp interface{} = this.SafeInteger(contract, "nextSettleTime")
    var marketId interface{} = this.SafeString(contract, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId, market, nil, "contract")
    var timestamp interface{} = this.SafeInteger(contract, "timestamp")
    var interval interface{} = this.SafeString(contract, "collectCycle")
    var intervalString interface{} = nil
    if IsTrue(!IsEqual(interval, nil)) {
        intervalString = Add(interval, "h")
    }
    return map[string]interface{} {
        "info": contract,
        "symbol": symbol,
        "markPrice": nil,
        "indexPrice": nil,
        "interestRate": nil,
        "estimatedSettlePrice": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "fundingRate": nextFundingRate,
        "fundingTimestamp": nextFundingTimestamp,
        "fundingDatetime": this.Iso8601(nextFundingTimestamp),
        "nextFundingRate": nil,
        "nextFundingTimestamp": nil,
        "nextFundingDatetime": nil,
        "previousFundingRate": nil,
        "previousFundingTimestamp": nil,
        "previousFundingDatetime": nil,
        "interval": intervalString,
    }
}
/**
 * @method
 * @name mexc#fetchFundingInterval
 * @description fetch the current funding rate interval
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-contract-funding-rate
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
 */
func  (this *mexc) FetchFundingInterval(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes443415 :=  (<-this.FetchFundingRate(symbol, params))
                PanicOnError(retRes443415)
                ch <- retRes443415
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mexc#fetchFundingRate
 * @description fetch the current funding rate
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-contract-funding-rate
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
 */
func  (this *mexc) FetchFundingRate(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes44478 := (<-this.LoadMarkets())
            PanicOnError(retRes44478)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.ContractPublicGetFundingRateSymbol(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "code": 0,
            //         "data": {
            //             "symbol": "BTC_USDT",
            //             "fundingRate": 0.000014,
            //             "maxFundingRate": 0.003,
            //             "minFundingRate": -0.003,
            //             "collectCycle": 8,
            //             "nextSettleTime": 1643241600000,
            //             "timestamp": 1643240373359
            //         }
            //     }
            //
            var result interface{} = this.SafeValue(response, "data", map[string]interface{} {})
        
            ch <- this.ParseFundingRate(result, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mexc#fetchFundingRateHistory
 * @description fetches historical funding rate prices
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-contract-funding-rate-history
 * @param {string} symbol unified symbol of the market to fetch the funding rate history for
 * @param {int} [since] not used by mexc, but filtered internally by ccxt
 * @param {int} [limit] mexc limit is page_size default 20, maximum is 100
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
 */
func  (this *mexc) FetchFundingRateHistory(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchFundingRateHistory() requires a symbol argument")))
            }
        
            retRes44878 := (<-this.LoadMarkets())
            PanicOnError(retRes44878)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "page_size", limit)
            }
        
            response:= (<-this.ContractPublicGetFundingRateHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "success": true,
            //        "code": 0,
            //        "data": {
            //            "pageSize": 2,
            //            "totalCount": 21,
            //            "totalPage": 11,
            //            "currentPage": 1,
            //            "resultList": [
            //                {
            //                    "symbol": "BTC_USDT",
            //                    "fundingRate": 0.000266,
            //                    "settleTime": 1609804800000
            //                },
            //                {
            //                    "symbol": "BTC_USDT",
            //                    "fundingRate": 0.00029,
            //                    "settleTime": 1609776000000
            //                }
            //            ]
            //        }
            //    }
            //
            var data interface{} = this.SafeValue(response, "data")
            var result interface{} = this.SafeValue(data, "resultList", []interface{}{})
            var rates interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(result)); i++ {
                var entry interface{} = GetValue(result, i)
                var marketId interface{} = this.SafeString(entry, "symbol")
                var symbolInner interface{} = this.SafeSymbol(marketId)
                var timestamp interface{} = this.SafeInteger(entry, "settleTime")
                AppendToArray(&rates,map[string]interface{} {
                    "info": entry,
                    "symbol": symbolInner,
                    "fundingRate": this.SafeNumber(entry, "fundingRate"),
                    "timestamp": timestamp,
                    "datetime": this.Iso8601(timestamp),
                })
            }
            var sorted interface{} = this.SortBy(rates, "timestamp")
        
            ch <- this.FilterBySymbolSinceLimit(sorted, GetValue(market, "symbol"), since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mexc#fetchLeverageTiers
 * @description retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes, if a market has a leverage tier of 0, then the leverage tiers cannot be obtained for this market
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-the-contract-information
 * @param {string[]} [symbols] list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [leverage tiers structures]{@link https://docs.ccxt.com/#/?id=leverage-tiers-structure}, indexed by market symbols
 */
func  (this *mexc) FetchLeverageTiers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes45528 := (<-this.LoadMarkets())
            PanicOnError(retRes45528)
            symbols = this.MarketSymbols(symbols, "swap", true, true)
        
            response:= (<-this.ContractPublicGetDetail(params))
            PanicOnError(response)
            //
            //     {
            //         "success":true,
            //         "code":0,
            //         "data":[
            //             {
            //                 "symbol": "BTC_USDT",
            //                 "displayName": "BTC_USDT永续",
            //                 "displayNameEn": "BTC_USDT SWAP",
            //                 "positionOpenType": 3,
            //                 "baseCoin": "BTC",
            //                 "quoteCoin": "USDT",
            //                 "settleCoin": "USDT",
            //                 "contractSize": 0.0001,
            //                 "minLeverage": 1,
            //                 "maxLeverage": 125,
            //                 "priceScale": 2,
            //                 "volScale": 0,
            //                 "amountScale": 4,
            //                 "priceUnit": 0.5,
            //                 "volUnit": 1,
            //                 "minVol": 1,
            //                 "maxVol": 1000000,
            //                 "bidLimitPriceRate": 0.1,
            //                 "askLimitPriceRate": 0.1,
            //                 "takerFeeRate": 0.0006,
            //                 "makerFeeRate": 0.0002,
            //                 "maintenanceMarginRate": 0.004,
            //                 "initialMarginRate": 0.008,
            //                 "riskBaseVol": 10000,
            //                 "riskIncrVol": 200000,
            //                 "riskIncrMmr": 0.004,
            //                 "riskIncrImr": 0.004,
            //                 "riskLevelLimit": 5,
            //                 "priceCoefficientVariation": 0.1,
            //                 "indexOrigin": ["BINANCE","GATEIO","HUOBI","MXC"],
            //                 "state": 0, // 0 enabled, 1 delivery, 2 completed, 3 offline, 4 pause
            //                 "isNew": false,
            //                 "isHot": true,
            //                 "isHidden": false
            //             },
            //             ...
            //         ]
            //     }
            //
            var data interface{} = this.SafeList(response, "data")
        
            ch <- this.ParseLeverageTiers(data, symbols, "symbol")
            return nil
        
            }()
            return ch
        }
func  (this *mexc) ParseMarketLeverageTiers(info interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "symbol": "BTC_USDT",
    //        "displayName": "BTC_USDT永续",
    //        "displayNameEn": "BTC_USDT SWAP",
    //        "positionOpenType": 3,
    //        "baseCoin": "BTC",
    //        "quoteCoin": "USDT",
    //        "settleCoin": "USDT",
    //        "contractSize": 0.0001,
    //        "minLeverage": 1,
    //        "maxLeverage": 125,
    //        "priceScale": 2,
    //        "volScale": 0,
    //        "amountScale": 4,
    //        "priceUnit": 0.5,
    //        "volUnit": 1,
    //        "minVol": 1,
    //        "maxVol": 1000000,
    //        "bidLimitPriceRate": 0.1,
    //        "askLimitPriceRate": 0.1,
    //        "takerFeeRate": 0.0006,
    //        "makerFeeRate": 0.0002,
    //        "maintenanceMarginRate": 0.004,
    //        "initialMarginRate": 0.008,
    //        "riskBaseVol": 10000,
    //        "riskIncrVol": 200000,
    //        "riskIncrMmr": 0.004,
    //        "riskIncrImr": 0.004,
    //        "riskLevelLimit": 5,
    //        "priceCoefficientVariation": 0.1,
    //        "indexOrigin": ["BINANCE","GATEIO","HUOBI","MXC"],
    //        "state": 0, // 0 enabled, 1 delivery, 2 completed, 3 offline, 4 pause
    //        "isNew": false,
    //        "isHot": true,
    //        "isHidden": false
    //    }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(info, "symbol")
    var maintenanceMarginRate interface{} = this.SafeString(info, "maintenanceMarginRate")
    var initialMarginRate interface{} = this.SafeString(info, "initialMarginRate")
    var maxVol interface{} = this.SafeString(info, "maxVol")
    var riskIncrVol interface{} = this.SafeString(info, "riskIncrVol")
    var riskIncrMmr interface{} = this.SafeString(info, "riskIncrMmr")
    var riskIncrImr interface{} = this.SafeString(info, "riskIncrImr")
    var floor interface{} = "0"
    var tiers interface{} = []interface{}{}
    var quoteId interface{} = this.SafeString(info, "quoteCoin")
    if IsTrue(IsEqual(riskIncrVol, "0")) {
        return []interface{}{map[string]interface{} {
    "tier": 0,
    "symbol": this.SafeSymbol(marketId, market, nil, "contract"),
    "currency": this.SafeCurrencyCode(quoteId),
    "minNotional": nil,
    "maxNotional": nil,
    "maintenanceMarginRate": nil,
    "maxLeverage": this.SafeNumber(info, "maxLeverage"),
    "info": info,
}}
    }
    for Precise.StringLt(floor, maxVol) {
        var cap interface{} = Precise.StringAdd(floor, riskIncrVol)
        AppendToArray(&tiers,map[string]interface{} {
            "tier": this.ParseNumber(Precise.StringDiv(cap, riskIncrVol)),
            "symbol": this.SafeSymbol(marketId, market, nil, "contract"),
            "currency": this.SafeCurrencyCode(quoteId),
            "minNotional": this.ParseNumber(floor),
            "maxNotional": this.ParseNumber(cap),
            "maintenanceMarginRate": this.ParseNumber(maintenanceMarginRate),
            "maxLeverage": this.ParseNumber(Precise.StringDiv("1", initialMarginRate)),
            "info": info,
        })
        initialMarginRate = Precise.StringAdd(initialMarginRate, riskIncrImr)
        maintenanceMarginRate = Precise.StringAdd(maintenanceMarginRate, riskIncrMmr)
        floor = cap
    }
    return tiers
}
func  (this *mexc) ParseDepositAddress(depositAddress interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        coin: "USDT",
    //        network: "BNB Smart Chain(BEP20)",
    //        address: "0x0d48003e0c27c5de62b97c9b4cdb31fdd29da619",
    //        memo:  null
    //    }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var address interface{} = this.SafeString(depositAddress, "address")
    var currencyId interface{} = this.SafeString(depositAddress, "coin")
    var networkId interface{} = this.SafeString(depositAddress, "netWork")
    this.CheckAddress(address)
    return map[string]interface{} {
        "info": depositAddress,
        "currency": this.SafeCurrencyCode(currencyId, currency),
        "network": this.NetworkIdToCode(networkId, currencyId),
        "address": address,
        "tag": this.SafeString(depositAddress, "memo"),
    }
}
/**
 * @method
 * @name mexc#fetchDepositAddressesByNetwork
 * @description fetch a dictionary of addresses for a currency, indexed by network
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#deposit-address-supporting-network
 * @param {string} code unified currency code of the currency for the deposit address
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [address structures]{@link https://docs.ccxt.com/#/?id=address-structure} indexed by the network
 */
func  (this *mexc) FetchDepositAddressesByNetwork(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes47188 := (<-this.LoadMarkets())
            PanicOnError(retRes47188)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "coin": GetValue(currency, "id"),
            }
            var networkCode interface{} = this.SafeString(params, "network")
            var networkId interface{} = nil
            if IsTrue(!IsEqual(networkCode, nil)) {
                // createDepositAddress and fetchDepositAddress use a different network-id compared to withdraw
                var networkUnified interface{} = this.NetworkIdToCode(networkCode, code)
                var networks interface{} = this.SafeDict(currency, "networks", map[string]interface{} {})
                if IsTrue(InOp(networks, networkUnified)) {
                    var network interface{} = this.SafeDict(networks, networkUnified, map[string]interface{} {})
                    var networkInfo interface{} = this.SafeValue(network, "info", map[string]interface{} {})
                    networkId = this.SafeString(networkInfo, "network")
                } else {
                    networkId = this.NetworkCodeToId(networkCode, code)
                }
            }
            if IsTrue(!IsEqual(networkId, nil)) {
                AddElementToObject(request, "network", networkId)
            }
            params = this.Omit(params, "network")
        
            response:= (<-this.SpotPrivateGetCapitalDepositAddress(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    [
            //        {
            //            coin: "USDT",
            //            network: "BNB Smart Chain(BEP20)",
            //            address: "0x0d48003e0c27c5de62b97c9b4cdb31fdd29da619",
            //            memo:  null
            //        }
            //        ...
            //    ]
            //
            var addressStructures interface{} = this.ParseDepositAddresses(response, nil, false)
        
            ch <- this.IndexBy(addressStructures, "network")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mexc#createDepositAddress
 * @description create a currency deposit address
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#generate-deposit-address-supporting-network
 * @param {string} code unified currency code of the currency for the deposit address
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.network] the blockchain network name
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *mexc) CreateDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes47688 := (<-this.LoadMarkets())
            PanicOnError(retRes47688)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "coin": GetValue(currency, "id"),
            }
            var networkCode interface{} = this.SafeString(params, "network")
            if IsTrue(IsEqual(networkCode, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " createDepositAddress requires a `network` parameter")))
            }
            // createDepositAddress and fetchDepositAddress use a different network-id compared to withdraw
            var networkId interface{} = nil
            var networkUnified interface{} = this.NetworkIdToCode(networkCode, code)
            var networks interface{} = this.SafeDict(currency, "networks", map[string]interface{} {})
            if IsTrue(InOp(networks, networkUnified)) {
                var network interface{} = this.SafeDict(networks, networkUnified, map[string]interface{} {})
                var networkInfo interface{} = this.SafeValue(network, "info", map[string]interface{} {})
                networkId = this.SafeString(networkInfo, "network")
            } else {
                networkId = this.NetworkCodeToId(networkCode, code)
            }
            if IsTrue(!IsEqual(networkId, nil)) {
                AddElementToObject(request, "network", networkId)
            }
            params = this.Omit(params, "network")
        
            response:= (<-this.SpotPrivatePostCapitalDepositAddress(this.Extend(request, params)))
            PanicOnError(response)
        
                //     {
            //        "coin": "EOS",
            //        "network": "EOS",
            //        "address": "zzqqqqqqqqqq",
            //        "memo": "MX10068"
            //     }
        ch <- this.ParseDepositAddress(response, currency)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mexc#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#deposit-address-supporting-network
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.network] the chain of currency, this only apply for multi-chain currency, and there is no need for single chain currency
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *mexc) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var network interface{} = this.SafeString(params, "network")
            var addressStructures interface{} = (<-this.FetchDepositAddressesByNetwork(code, params))
            var result interface{} = nil
            if IsTrue(!IsEqual(network, nil)) {
                result = this.SafeDict(addressStructures, this.NetworkIdToCode(network, code))
            } else {
                var options interface{} = this.SafeDict(this.Options, "defaultNetworks")
                var defaultNetworkForCurrency interface{} = this.SafeString(options, code)
                if IsTrue(!IsEqual(defaultNetworkForCurrency, nil)) {
                    result = this.SafeDict(addressStructures, defaultNetworkForCurrency)
                } else {
                    var keys interface{} = ObjectKeys(addressStructures)
                    var key interface{} = this.SafeString(keys, 0)
                    result = this.SafeDict(addressStructures, key)
                }
            }
            if IsTrue(IsEqual(result, nil)) {
                panic(InvalidAddress(Add(Add(Add(Add(Add(this.Id, " fetchDepositAddress() cannot find a deposit address for "), code), ", and network"), network), "consider creating one using .createDepositAddress() method or in MEXC website")))
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mexc#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#deposit-history-supporting-network
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *mexc) FetchDeposits(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes48478 := (<-this.LoadMarkets())
            PanicOnError(retRes48478)
            var request interface{} = map[string]interface{} {}
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "coin", GetValue(currency, "id"))
                // currently mexc does not have network names unified so for certain things we might need TRX or TRC-20
                // due to that I'm applying the network parameter directly so the user can control it on its side
                var rawNetwork interface{} = this.SafeString(params, "network")
                if IsTrue(!IsEqual(rawNetwork, nil)) {
                    params = this.Omit(params, "network")
                    AddElementToObject(request, "coin", Add(Add(GetValue(request, "coin"), "-"), rawNetwork))
                }
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                if IsTrue(IsGreaterThan(limit, 1000)) {
                    panic(ExchangeError("This exchange supports a maximum limit of 1000"))
                }
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.SpotPrivateGetCapitalDepositHisrec(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            // [
            //     {
            //         "amount": "10",
            //         "coin": "USDC-TRX",
            //         "network": "TRX",
            //         "status": "5",
            //         "address": "TSMcEDDvkqY9dz8RkFnrS86U59GwEZjfvh",
            //         "txId": "51a8f49e6f03f2c056e71fe3291aa65e1032880be855b65cecd0595a1b8af95b",
            //         "insertTime": "1664805021000",
            //         "unlockConfirm": "200",
            //         "confirmTimes": "203",
            //         "memo": "xxyy1122"
            //     }
            // ]
            //
        ch <- this.ParseTransactions(response, currency, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mexc#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#withdraw-history-supporting-network
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawals structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *mexc) FetchWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes49088 := (<-this.LoadMarkets())
            PanicOnError(retRes49088)
            var request interface{} = map[string]interface{} {}
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "coin", GetValue(currency, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                if IsTrue(IsGreaterThan(limit, 1000)) {
                    panic(ExchangeError("This exchange supports a maximum limit of 1000"))
                }
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.SpotPrivateGetCapitalWithdrawHistory(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            // [
            //     {
            //       "id": "adcd1c8322154de691b815eedcd10c42",
            //       "txId": "0xc8c918cd69b2246db493ef6225a72ffdc664f15b08da3e25c6879b271d05e9d0",
            //       "coin": "USDC-MATIC",
            //       "network": "MATIC",
            //       "address": "0xeE6C7a415995312ED52c53a0f8f03e165e0A5D62",
            //       "amount": "2",
            //       "transferType": "0",
            //       "status": "7",
            //       "transactionFee": "1",
            //       "confirmNo": null,
            //       "applyTime": "1664882739000",
            //       "remark": '',
            //       "memo": null
            //     }
            // ]
            //
        ch <- this.ParseTransactions(response, currency, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *mexc) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchDeposits
    //
    // {
    //     "amount": "10",
    //     "coin": "USDC-TRX",
    //     "network": "TRX",
    //     "status": "5",
    //     "address": "TSMcEDDvkqY9dz8RkFnrS86U59GwEZjfvh",
    //     "txId": "51a8f49e6f03f2c056e71fe3291aa65e1032880be855b65cecd0595a1b8af95b",
    //     "insertTime": "1664805021000",
    //     "unlockConfirm": "200",
    //     "confirmTimes": "203",
    //     "memo": "xxyy1122"
    // }
    //
    // fetchWithdrawals
    //
    // {
    //     "id": "adcd1c8322154de691b815eedcd10c42",
    //     "txId": "0xc8c918cd69b2246db493ef6225a72ffdc664f15b08da3e25c6879b271d05e9d0",
    //     "coin": "USDC-MATIC",
    //     "network": "MATIC",
    //     "address": "0xeE6C7a415995312ED52c53a0f8f03e165e0A5D62",
    //     "amount": "2",
    //     "transferType": "0",
    //     "status": "7",
    //     "transactionFee": "1",
    //     "confirmNo": null,
    //     "applyTime": "1664882739000",
    //     "remark": '',
    //     "memo": null
    //   }
    //
    // withdraw
    //
    //     {
    //         "id":"25fb2831fb6d4fc7aa4094612a26c81d"
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var id interface{} = this.SafeString(transaction, "id")
    var typeVar interface{} = Ternary(IsTrue((IsEqual(id, nil))), "deposit", "withdrawal")
    var timestamp interface{} = this.SafeInteger2(transaction, "insertTime", "applyTime")
    var currencyId interface{} = nil
    var currencyWithNetwork interface{} = this.SafeString(transaction, "coin")
    if IsTrue(!IsEqual(currencyWithNetwork, nil)) {
        currencyId = GetValue(Split(currencyWithNetwork, "-"), 0)
    }
    var network interface{} = nil
    var rawNetwork interface{} = this.SafeString(transaction, "network")
    if IsTrue(!IsEqual(rawNetwork, nil)) {
        network = this.NetworkIdToCode(rawNetwork)
    }
    var code interface{} = this.SafeCurrencyCode(currencyId, currency)
    var status interface{} = this.ParseTransactionStatusByType(this.SafeString(transaction, "status"), typeVar)
    var amountString interface{} = this.SafeString(transaction, "amount")
    var address interface{} = this.SafeString(transaction, "address")
    var txid interface{} = this.SafeString(transaction, "txId")
    var fee interface{} = nil
    var feeCostString interface{} = this.SafeString(transaction, "transactionFee")
    if IsTrue(!IsEqual(feeCostString, nil)) {
        fee = map[string]interface{} {
            "cost": this.ParseNumber(feeCostString),
            "currency": code,
        }
    }
    if IsTrue(IsEqual(typeVar, "withdrawal")) {
        // mexc withdrawal amount includes the fee
        amountString = Precise.StringSub(amountString, feeCostString)
    }
    return map[string]interface{} {
        "info": transaction,
        "id": id,
        "txid": txid,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "network": network,
        "address": address,
        "addressTo": address,
        "addressFrom": nil,
        "tag": this.SafeString(transaction, "memo"),
        "tagTo": nil,
        "tagFrom": nil,
        "type": typeVar,
        "amount": this.ParseNumber(amountString),
        "currency": code,
        "status": status,
        "updated": nil,
        "comment": nil,
        "internal": nil,
        "fee": fee,
    }
}
func  (this *mexc) ParseTransactionStatusByType(status interface{}, optionalArgs ...interface{}) interface{}  {
    typeVar := GetArg(optionalArgs, 0, nil)
    _ = typeVar
    var statusesByType interface{} = map[string]interface{} {
        "deposit": map[string]interface{} {
            "1": "failed",
            "2": "pending",
            "3": "pending",
            "4": "pending",
            "5": "ok",
            "6": "pending",
            "7": "failed",
        },
        "withdrawal": map[string]interface{} {
            "1": "pending",
            "2": "pending",
            "3": "pending",
            "4": "pending",
            "5": "pending",
            "6": "pending",
            "7": "ok",
            "8": "failed",
            "9": "canceled",
            "10": "pending",
        },
    }
    var statuses interface{} = this.SafeValue(statusesByType, typeVar, map[string]interface{} {})
    return this.SafeString(statuses, status, status)
}
/**
 * @method
 * @name mexc#fetchPosition
 * @description fetch data on a single open contract trade position
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-the-user-s-history-position-information
 * @param {string} symbol unified market symbol of the market the position is held in, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *mexc) FetchPosition(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes50868 := (<-this.LoadMarkets())
            PanicOnError(retRes50868)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.FetchPositions(nil, this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.SafeValue(response, 0)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mexc#fetchPositions
 * @description fetch all open positions
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-the-user-s-history-position-information
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *mexc) FetchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes51058 := (<-this.LoadMarkets())
            PanicOnError(retRes51058)
        
            response:= (<-this.ContractPrivateGetPositionOpenPositions(params))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "code": 0,
            //         "data": [
            //             {
            //                 "positionId": 1394650,
            //                 "symbol": "ETH_USDT",
            //                 "positionType": 1,
            //                 "openType": 1,
            //                 "state": 1,
            //                 "holdVol": 1,
            //                 "frozenVol": 0,
            //                 "closeVol": 0,
            //                 "holdAvgPrice": 1217.3,
            //                 "openAvgPrice": 1217.3,
            //                 "closeAvgPrice": 0,
            //                 "liquidatePrice": 1211.2,
            //                 "oim": 0.1290338,
            //                 "im": 0.1290338,
            //                 "holdFee": 0,
            //                 "realised": -0.0073,
            //                 "leverage": 100,
            //                 "createTime": 1609991676000,
            //                 "updateTime": 1609991676000,
            //                 "autoAddIm": false
            //             }
            //         ]
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParsePositions(data, symbols)
            return nil
        
            }()
            return ch
        }
func  (this *mexc) ParsePosition(position interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchPositions
    //
    //     {
    //         "positionId": 1394650,
    //         "symbol": "ETH_USDT",
    //         "positionType": 1,
    //         "openType": 1,
    //         "state": 1,
    //         "holdVol": 1,
    //         "frozenVol": 0,
    //         "closeVol": 0,
    //         "holdAvgPrice": 1217.3,
    //         "openAvgPrice": 1217.3,
    //         "closeAvgPrice": 0,
    //         "liquidatePrice": 1211.2,
    //         "oim": 0.1290338,
    //         "im": 0.1290338,
    //         "holdFee": 0,
    //         "realised": -0.0073,
    //         "leverage": 100,
    //         "createTime": 1609991676000,
    //         "updateTime": 1609991676000,
    //         "autoAddIm": false
    //     }
    //
    // fetchPositionsHistory
    //
    //    {
    //        positionId: '390281084',
    //        symbol: 'RVN_USDT',
    //        positionType: '1',
    //        openType: '2',
    //        state: '3',
    //        holdVol: '0',
    //        frozenVol: '0',
    //        closeVol: '1141',
    //        holdAvgPrice: '0.03491',
    //        holdAvgPriceFullyScale: '0.03491',
    //        openAvgPrice: '0.03491',
    //        openAvgPriceFullyScale: '0.03491',
    //        closeAvgPrice: '0.03494',
    //        liquidatePrice: '0.03433',
    //        oim: '0',
    //        im: '0',
    //        holdFee: '0',
    //        realised: '0.1829',
    //        leverage: '50',
    //        createTime: '1711512408000',
    //        updateTime: '1711512553000',
    //        autoAddIm: false,
    //        version: '4',
    //        profitRatio: '0.0227',
    //        newOpenAvgPrice: '0.03491',
    //        newCloseAvgPrice: '0.03494',
    //        closeProfitLoss: '0.3423',
    //        fee: '0.1593977',
    //        positionShowStatus: 'CLOSED'
    //    }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    market = this.SafeMarket(this.SafeString(position, "symbol"), market)
    var symbol interface{} = GetValue(market, "symbol")
    var contracts interface{} = this.SafeString(position, "holdVol")
    var entryPrice interface{} = this.SafeNumber(position, "openAvgPrice")
    var initialMargin interface{} = this.SafeString(position, "im")
    var rawSide interface{} = this.SafeString(position, "positionType")
    var side interface{} = Ternary(IsTrue((IsEqual(rawSide, "1"))), "long", "short")
    var openType interface{} = this.SafeString(position, "margin_mode")
    var marginType interface{} = Ternary(IsTrue((IsEqual(openType, "1"))), "isolated", "cross")
    var leverage interface{} = this.SafeNumber(position, "leverage")
    var liquidationPrice interface{} = this.SafeNumber(position, "liquidatePrice")
    var timestamp interface{} = this.SafeInteger(position, "updateTime")
    return this.SafePosition(map[string]interface{} {
        "info": position,
        "id": nil,
        "symbol": symbol,
        "contracts": this.ParseNumber(contracts),
        "contractSize": nil,
        "entryPrice": entryPrice,
        "collateral": nil,
        "side": side,
        "unrealizedPnl": nil,
        "leverage": this.ParseNumber(leverage),
        "percentage": nil,
        "marginMode": marginType,
        "notional": nil,
        "markPrice": nil,
        "lastPrice": nil,
        "liquidationPrice": liquidationPrice,
        "initialMargin": this.ParseNumber(initialMargin),
        "initialMarginPercentage": nil,
        "maintenanceMargin": nil,
        "maintenanceMarginPercentage": nil,
        "marginRatio": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "hedged": nil,
        "stopLossPrice": nil,
        "takeProfitPrice": nil,
        "lastUpdateTimestamp": nil,
    })
}
/**
 * @method
 * @name mexc#fetchTransfer
 * @description fetches a transfer
 * @see https://mexcdevelop.github.io/apidocs/spot_v2_en/#internal-assets-transfer-order-inquiry
 * @param {string} id transfer id
 * @param {string} [code] not used by mexc fetchTransfer
 * @param {object} params extra parameters specific to the exchange api endpoint
 * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func  (this *mexc) FetchTransfer(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            marketTypequeryVariable := this.HandleMarketTypeAndParams("fetchTransfer", nil, params);
            marketType := GetValue(marketTypequeryVariable,0);
            query := GetValue(marketTypequeryVariable,1)
        
            retRes52578 := (<-this.LoadMarkets())
            PanicOnError(retRes52578)
            if IsTrue(IsEqual(marketType, "spot")) {
                var request interface{} = map[string]interface{} {
                    "transact_id": id,
                }
        
                response:= (<-this.Spot2PrivateGetAssetInternalTransferInfo(this.Extend(request, query)))
                PanicOnError(response)
                //
                //     {
                //         "code": "200",
                //         "data": {
                //             "currency": "USDT",
                //             "amount": "1",
                //             "transact_id": "954877a2ef54499db9b28a7cf9ebcf41",
                //             "from": "MAIN",
                //             "to": "CONTRACT",
                //             "transact_state": "SUCCESS"
                //         }
                //     }
                //
                var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
                ch <- this.ParseTransfer(data)
                return nil
            } else if IsTrue(IsEqual(marketType, "swap")) {
                panic(BadRequest(Add(Add(this.Id, " fetchTransfer() is not supported for "), marketType)))
            }
        
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mexc#fetchTransfers
 * @description fetch a history of internal transfers made on an account
 * @see https://mexcdevelop.github.io/apidocs/spot_v2_en/#get-internal-assets-transfer-records
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-the-user-39-s-asset-transfer-records
 * @param {string} code unified currency code of the currency transferred
 * @param {int} [since] the earliest time in ms to fetch transfers for
 * @param {int} [limit] the maximum number of  transfers structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transfer structures]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func  (this *mexc) FetchTransfers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            marketTypequeryVariable := this.HandleMarketTypeAndParams("fetchTransfers", nil, params);
            marketType := GetValue(marketTypequeryVariable,0);
            query := GetValue(marketTypequeryVariable,1)
        
            retRes52988 := (<-this.LoadMarkets())
            PanicOnError(retRes52988)
            var request interface{} = map[string]interface{} {}
            var currency interface{} = nil
            var resultList interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "currency", GetValue(currency, "id"))
            }
            if IsTrue(IsEqual(marketType, "spot")) {
                if IsTrue(!IsEqual(since, nil)) {
                    AddElementToObject(request, "start_time", since)
                }
                if IsTrue(!IsEqual(limit, nil)) {
                    if IsTrue(IsGreaterThan(limit, 50)) {
                        panic(ExchangeError("This exchange supports a maximum limit of 50"))
                    }
                    AddElementToObject(request, "page-size", limit)
                }
        
                response:= (<-this.Spot2PrivateGetAssetInternalTransferRecord(this.Extend(request, query)))
                PanicOnError(response)
                //
                //     {
                //         "code": "200",
                //         "data": {
                //             "total_page": "1",
                //             "total_size": "5",
                //             "result_list": [{
                //                     "currency": "USDT",
                //                     "amount": "1",
                //                     "transact_id": "954877a2ef54499db9b28a7cf9ebcf41",
                //                     "from": "MAIN",
                //                     "to": "CONTRACT",
                //                     "transact_state": "SUCCESS"
                //                 },
                //                 ...
                //             ]
                //         }
                //     }
                //
                var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
                resultList = this.SafeValue(data, "result_list", []interface{}{})
            } else if IsTrue(IsEqual(marketType, "swap")) {
                if IsTrue(!IsEqual(limit, nil)) {
                    AddElementToObject(request, "page_size", limit)
                }
        
                response:= (<-this.ContractPrivateGetAccountTransferRecord(this.Extend(request, query)))
                PanicOnError(response)
                var data interface{} = this.SafeValue(response, "data")
                resultList = this.SafeValue(data, "resultList")
            }
        
            ch <- this.ParseTransfers(resultList, currency, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mexc#transfer
 * @description transfer currency internally between wallets on the same account
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#user-universal-transfer
 * @param {string} code unified currency code
 * @param {float} amount amount to transfer
 * @param {string} fromAccount account to transfer from
 * @param {string} toAccount account to transfer to
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.symbol] market symbol required for margin account transfers eg:BTCUSDT
 * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func  (this *mexc) Transfer(code interface{}, amount interface{}, fromAccount interface{}, toAccount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes53878 := (<-this.LoadMarkets())
            PanicOnError(retRes53878)
            var currency interface{} = this.Currency(code)
            var accounts interface{} = map[string]interface{} {
                "spot": "SPOT",
                "swap": "FUTURES",
                "margin": "ISOLATED_MARGIN",
            }
            var fromId interface{} = this.SafeString(accounts, fromAccount)
            var toId interface{} = this.SafeString(accounts, toAccount)
            if IsTrue(IsEqual(fromId, nil)) {
                var keys interface{} = ObjectKeys(accounts)
                panic(ExchangeError(Add(Add(this.Id, " fromAccount must be one of "), Join(keys, ", "))))
            }
            if IsTrue(IsEqual(toId, nil)) {
                var keys interface{} = ObjectKeys(accounts)
                panic(ExchangeError(Add(Add(this.Id, " toAccount must be one of "), Join(keys, ", "))))
            }
            var request interface{} = map[string]interface{} {
                "asset": GetValue(currency, "id"),
                "amount": amount,
                "fromAccountType": fromId,
                "toAccountType": toId,
            }
            if IsTrue(IsTrue((IsEqual(fromId, "ISOLATED_MARGIN"))) || IsTrue((IsEqual(toId, "ISOLATED_MARGIN")))) {
                var symbol interface{} = this.SafeString(params, "symbol")
                params = this.Omit(params, "symbol")
                if IsTrue(IsEqual(symbol, nil)) {
                    panic(ArgumentsRequired(Add(this.Id, " transfer() requires a symbol argument for isolated margin")))
                }
                var market interface{} = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
        
            response:= (<-this.SpotPrivatePostCapitalTransfer(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "tranId": "ebb06123e6a64f4ab234b396c548d57e"
            //     }
            //
            var transaction interface{} = this.ParseTransfer(response, currency)
        
            ch <- this.Extend(transaction, map[string]interface{} {
                "amount": amount,
                "fromAccount": fromAccount,
                "toAccount": toAccount,
            })
            return nil
        
            }()
            return ch
        }
func  (this *mexc) ParseTransfer(transfer interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // spot: fetchTransfer
    //
    //     {
    //         "currency": "USDT",
    //         "amount": "1",
    //         "transact_id": "b60c1df8e7b24b268858003f374ecb75",
    //         "from": "MAIN",
    //         "to": "CONTRACT",
    //         "transact_state": "WAIT"
    //     }
    //
    // swap: fetchTransfer
    //
    //     {
    //         "currency": "USDT",
    //         "amount": "22.90213135",
    //         "txid": "fa8a1e7bf05940a3b7025856dc48d025",
    //         "id": "2980812",
    //         "type": "IN",
    //         "state": "SUCCESS",
    //         "createTime": "1648849076000",
    //         "updateTime": "1648849076000"
    //     }
    //
    // transfer
    //
    //     {
    //         "tranId": "ebb06123e6a64f4ab234b396c548d57e"
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var currencyId interface{} = this.SafeString(transfer, "currency")
    var id interface{} = this.SafeStringN(transfer, []interface{}{"transact_id", "txid", "tranId"})
    var timestamp interface{} = this.SafeInteger(transfer, "createTime")
    var datetime interface{} = Ternary(IsTrue((!IsEqual(timestamp, nil))), this.Iso8601(timestamp), nil)
    var direction interface{} = this.SafeString(transfer, "type")
    var accountFrom interface{} = nil
    var accountTo interface{} = nil
    if IsTrue(!IsEqual(direction, nil)) {
        accountFrom = Ternary(IsTrue((IsEqual(direction, "IN"))), "MAIN", "CONTRACT")
        accountTo = Ternary(IsTrue((IsEqual(direction, "IN"))), "CONTRACT", "MAIN")
    } else {
        accountFrom = this.SafeString(transfer, "from")
        accountTo = this.SafeString(transfer, "to")
    }
    return map[string]interface{} {
        "info": transfer,
        "id": id,
        "timestamp": timestamp,
        "datetime": datetime,
        "currency": this.SafeCurrencyCode(currencyId, currency),
        "amount": this.SafeNumber(transfer, "amount"),
        "fromAccount": this.ParseAccountId(accountFrom),
        "toAccount": this.ParseAccountId(accountTo),
        "status": this.ParseTransferStatus(this.SafeString2(transfer, "transact_state", "state")),
    }
}
func  (this *mexc) ParseAccountId(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "MAIN": "spot",
        "CONTRACT": "swap",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *mexc) ParseTransferStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "SUCCESS": "ok",
        "FAILED": "failed",
        "WAIT": "pending",
    }
    return this.SafeString(statuses, status, status)
}
/**
 * @method
 * @name mexc#withdraw
 * @description make a withdrawal
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#withdraw-new
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *mexc) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes55228 := (<-this.LoadMarkets())
            PanicOnError(retRes55228)
            var currency interface{} = this.Currency(code)
            tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params);
            tag = GetValue(tagparamsVariable,0);
            params = GetValue(tagparamsVariable,1)
            var networks interface{} = this.SafeDict(this.Options, "networks", map[string]interface{} {})
            var network interface{} = this.SafeString2(params, "network", "netWork") // this line allows the user to specify either ERC20 or ETH
            network = this.SafeString(networks, network, network) // handle ETH > ERC-20 alias
            network = this.NetworkCodeToId(network, GetValue(currency, "code"))
            this.CheckAddress(address)
            var request interface{} = map[string]interface{} {
                "coin": GetValue(currency, "id"),
                "address": address,
                "amount": amount,
            }
            if IsTrue(!IsEqual(tag, nil)) {
                AddElementToObject(request, "memo", tag)
            }
            if IsTrue(!IsEqual(network, nil)) {
                AddElementToObject(request, "netWork", network)
                params = this.Omit(params, []interface{}{"network", "netWork"})
            }
        
            response:= (<-this.SpotPrivatePostCapitalWithdraw(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //       "id":"7213fea8e94b4a5593d507237e5a555b"
            //     }
            //
        ch <- this.ParseTransaction(response, currency)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mexc#setPositionMode
 * @description set hedged to true or false for a market
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#change-position-mode
 * @param {bool} hedged set to true to use dualSidePosition
 * @param {string} symbol not used by mexc setPositionMode ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} response from the exchange
 */
func  (this *mexc) SetPositionMode(hedged interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "positionMode": Ternary(IsTrue(hedged), 1, 2),
            }
        
            response:= (<-this.ContractPrivatePostPositionChangePositionMode(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "success":true,
            //         "code":0
            //     }
            //
        ch <- response
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mexc#fetchPositionMode
 * @description fetchs the position mode, hedged or one way, hedged for binance is set identically for all linear markets or all inverse markets
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-position-mode
 * @param {string} symbol not used by mexc fetchPositionMode
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an object detailing whether the market is in hedged or one-way mode
 */
func  (this *mexc) FetchPositionMode(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            response:= (<-this.ContractPrivateGetPositionPositionMode(params))
            PanicOnError(response)
            //
            //     {
            //         "success":true,
            //         "code":0,
            //         "data":2
            //     }
            //
            var positionMode interface{} = this.SafeInteger(response, "data")
        
            ch <- map[string]interface{} {
                "info": response,
                "hedged": (IsEqual(positionMode, 1)),
            }
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mexc#fetchTransactionFees
 * @description fetch deposit and withdrawal fees
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#query-the-currency-information
 * @param {string[]|undefined} codes returns fees for all currencies if undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func  (this *mexc) FetchTransactionFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    codes := GetArg(optionalArgs, 0, nil)
            _ = codes
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes56108 := (<-this.LoadMarkets())
            PanicOnError(retRes56108)
        
            response:= (<-this.SpotPrivateGetCapitalConfigGetall(params))
            PanicOnError(response)
        
                //
            //    [
            //       {
            //           "coin": "AGLD",
            //           "name": "Adventure Gold",
            //           "networkList": [
            //               {
            //                   "coin": "AGLD",
            //                   "depositDesc": null,
            //                   "depositEnable": true,
            //                   "minConfirm": "0",
            //                   "name": "Adventure Gold",
            //                   "network": "ERC20",
            //                   "withdrawEnable": true,
            //                   "withdrawFee": "10.000000000000000000",
            //                   "withdrawIntegerMultiple": null,
            //                   "withdrawMax": "1200000.000000000000000000",
            //                   "withdrawMin": "20.000000000000000000",
            //                   "sameAddress": false,
            //                   "contract": "0x32353a6c91143bfd6c7d363b546e62a9a2489a20",
            //                   "withdrawTips": null,
            //                   "depositTips": null
            //               }
            //               ...
            //           ]
            //       },
            //       ...
            //    ]
            //
        ch <- this.ParseTransactionFees(response, codes)
            return nil
        
            }()
            return ch
        }
func  (this *mexc) ParseTransactionFees(response interface{}, optionalArgs ...interface{}) interface{}  {
    codes := GetArg(optionalArgs, 0, nil)
    _ = codes
    var withdrawFees interface{} = map[string]interface{} {}
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        var entry interface{} = GetValue(response, i)
        var currencyId interface{} = this.SafeString(entry, "coin")
        var currency interface{} = this.SafeCurrency(currencyId)
        var code interface{} = this.SafeString(currency, "code")
        if IsTrue(IsTrue((IsEqual(codes, nil))) || IsTrue((this.InArray(code, codes)))) {
            AddElementToObject(withdrawFees, code, this.ParseTransactionFee(entry, currency))
        }
    }
    return map[string]interface{} {
        "withdraw": withdrawFees,
        "deposit": map[string]interface{} {},
        "info": response,
    }
}
func  (this *mexc) ParseTransactionFee(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "coin": "AGLD",
    //        "name": "Adventure Gold",
    //        "networkList": [
    //            {
    //                "coin": "AGLD",
    //                "depositDesc": null,
    //                "depositEnable": true,
    //                "minConfirm": "0",
    //                "name": "Adventure Gold",
    //                "network": "ERC20",
    //                "withdrawEnable": true,
    //                "withdrawFee": "10.000000000000000000",
    //                "withdrawIntegerMultiple": null,
    //                "withdrawMax": "1200000.000000000000000000",
    //                "withdrawMin": "20.000000000000000000",
    //                "sameAddress": false,
    //                "contract": "0x32353a6c91143bfd6c7d363b546e62a9a2489a20",
    //                "withdrawTips": null,
    //                "depositTips": null
    //            }
    //            ...
    //        ]
    //    }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var networkList interface{} = this.SafeValue(transaction, "networkList", []interface{}{})
    var result interface{} = map[string]interface{} {}
    for j := 0; IsLessThan(j, GetArrayLength(networkList)); j++ {
        var networkEntry interface{} = GetValue(networkList, j)
        var networkId interface{} = this.SafeString(networkEntry, "network")
        var networkCode interface{} = this.SafeString(GetValue(this.Options, "networks"), networkId, networkId)
        var fee interface{} = this.SafeNumber(networkEntry, "withdrawFee")
        AddElementToObject(result, networkCode, fee)
    }
    return result
}
/**
 * @method
 * @name mexc#fetchDepositWithdrawFees
 * @description fetch deposit and withdrawal fees
 * @see https://mexcdevelop.github.io/apidocs/spot_v3_en/#query-the-currency-information
 * @param {string[]|undefined} codes returns fees for all currencies if undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func  (this *mexc) FetchDepositWithdrawFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    codes := GetArg(optionalArgs, 0, nil)
            _ = codes
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes57118 := (<-this.LoadMarkets())
            PanicOnError(retRes57118)
        
            response:= (<-this.SpotPrivateGetCapitalConfigGetall(params))
            PanicOnError(response)
        
                //
            //    [
            //       {
            //           "coin": "AGLD",
            //           "name": "Adventure Gold",
            //           "networkList": [
            //               {
            //                   "coin": "AGLD",
            //                   "depositDesc": null,
            //                   "depositEnable": true,
            //                   "minConfirm": "0",
            //                   "name": "Adventure Gold",
            //                   "network": "ERC20",
            //                   "withdrawEnable": true,
            //                   "withdrawFee": "10.000000000000000000",
            //                   "withdrawIntegerMultiple": null,
            //                   "withdrawMax": "1200000.000000000000000000",
            //                   "withdrawMin": "20.000000000000000000",
            //                   "sameAddress": false,
            //                   "contract": "0x32353a6c91143bfd6c7d363b546e62a9a2489a20",
            //                   "withdrawTips": null,
            //                   "depositTips": null
            //               }
            //               ...
            //           ]
            //       },
            //       ...
            //    ]
            //
        ch <- this.ParseDepositWithdrawFees(response, codes, "coin")
            return nil
        
            }()
            return ch
        }
func  (this *mexc) ParseDepositWithdrawFee(fee interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "coin": "AGLD",
    //        "name": "Adventure Gold",
    //        "networkList": [
    //            {
    //                "coin": "AGLD",
    //                "depositDesc": null,
    //                "depositEnable": true,
    //                "minConfirm": "0",
    //                "name": "Adventure Gold",
    //                "network": "ERC20",
    //                "withdrawEnable": true,
    //                "withdrawFee": "10.000000000000000000",
    //                "withdrawIntegerMultiple": null,
    //                "withdrawMax": "1200000.000000000000000000",
    //                "withdrawMin": "20.000000000000000000",
    //                "sameAddress": false,
    //                "contract": "0x32353a6c91143bfd6c7d363b546e62a9a2489a20",
    //                "withdrawTips": null,
    //                "depositTips": null
    //            }
    //            ...
    //        ]
    //    }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var networkList interface{} = this.SafeValue(fee, "networkList", []interface{}{})
    var result interface{} = this.DepositWithdrawFee(fee)
    for j := 0; IsLessThan(j, GetArrayLength(networkList)); j++ {
        var networkEntry interface{} = GetValue(networkList, j)
        var networkId interface{} = this.SafeString(networkEntry, "network")
        var networkCode interface{} = this.NetworkIdToCode(networkId, this.SafeString(currency, "code"))
        AddElementToObject(GetValue(result, "networks"), networkCode, map[string]interface{} {
    "withdraw": map[string]interface{} {
        "fee": this.SafeNumber(networkEntry, "withdrawFee"),
        "percentage": nil,
    },
    "deposit": map[string]interface{} {
        "fee": nil,
        "percentage": nil,
    },
})
    }
    return this.AssignDefaultDepositWithdrawFees(result)
}
/**
 * @method
 * @name mexc#fetchLeverage
 * @description fetch the set leverage for a market
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-leverage
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [leverage structure]{@link https://docs.ccxt.com/#/?id=leverage-structure}
 */
func  (this *mexc) FetchLeverage(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes58028 := (<-this.LoadMarkets())
            PanicOnError(retRes58028)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.ContractPrivateGetPositionLeverage(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "code": 0,
            //         "data": [
            //             {
            //                 "level": 1,
            //                 "maxVol": 463300,
            //                 "mmr": 0.004,
            //                 "imr": 0.005,
            //                 "positionType": 1,
            //                 "openType": 1,
            //                 "leverage": 20,
            //                 "limitBySys": false,
            //                 "currentMmr": 0.004
            //             },
            //             {
            //                 "level": 1,
            //                 "maxVol": 463300,
            //                 "mmr": 0.004,
            //                 "imr": 0.005,
            //                 "positionType": 2,
            //                 "openType": 1,
            //                 "leverage": 20,
            //                 "limitBySys": false,
            //                 "currentMmr": 0.004
            //             }
            //         ]
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseLeverage(data, market)
            return nil
        
            }()
            return ch
        }
func  (this *mexc) ParseLeverage(leverage interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marginMode interface{} = nil
    var longLeverage interface{} = nil
    var shortLeverage interface{} = nil
    for i := 0; IsLessThan(i, GetArrayLength(leverage)); i++ {
        var entry interface{} = GetValue(leverage, i)
        var openType interface{} = this.SafeInteger(entry, "openType")
        var positionType interface{} = this.SafeInteger(entry, "positionType")
        if IsTrue(IsEqual(positionType, 1)) {
            longLeverage = this.SafeInteger(entry, "leverage")
        } else if IsTrue(IsEqual(positionType, 2)) {
            shortLeverage = this.SafeInteger(entry, "leverage")
        }
        marginMode = Ternary(IsTrue((IsEqual(openType, 1))), "isolated", "cross")
    }
    return map[string]interface{} {
        "info": leverage,
        "symbol": GetValue(market, "symbol"),
        "marginMode": marginMode,
        "longLeverage": longLeverage,
        "shortLeverage": shortLeverage,
    }
}
func  (this *mexc) HandleMarginModeAndParams(methodName interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @description marginMode specified by params["marginMode"], this.options["marginMode"], this.options["defaultMarginMode"], params["margin"] = true or this.options["defaultType"] = 'margin'
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @param {bool} [params.margin] true for trading spot-margin
    * @returns {Array} the marginMode in lowercase
    */
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    defaultValue := GetArg(optionalArgs, 1, nil)
    _ = defaultValue
    var defaultType interface{} = this.SafeString(this.Options, "defaultType")
    var isMargin interface{} = this.SafeBool(params, "margin", false)
    var marginMode interface{} = nil
    marginModeparamsVariable := this.Exchange.HandleMarginModeAndParams(methodName, params, defaultValue);
    marginMode = GetValue(marginModeparamsVariable,0);
    params = GetValue(marginModeparamsVariable,1)
    if IsTrue(IsTrue((IsEqual(defaultType, "margin"))) || IsTrue((IsEqual(isMargin, true)))) {
        marginMode = "isolated"
    }
    return []interface{}{marginMode, params}
}
/**
 * @method
 * @name mexc#fetchPositionsHistory
 * @description fetches historical positions
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#get-the-user-s-history-position-information
 * @param {string[]} [symbols] unified contract symbols
 * @param {int} [since] not used by mexc fetchPositionsHistory
 * @param {int} [limit] the maximum amount of candles to fetch, default=1000
 * @param {object} [params] extra parameters specific to the exchange api endpoint
 *
 * EXCHANGE SPECIFIC PARAMETERS
 * @param {int} [params.type] position type，1: long, 2: short
 * @param {int} [params.page_num] current page number, default is 1
 * @returns {object[]} a list of [position structures]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *mexc) FetchPositionsHistory(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes59018 := (<-this.LoadMarkets())
            PanicOnError(retRes59018)
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbols, nil)) {
                var symbolsLength interface{} =         GetArrayLength(symbols)
                if IsTrue(IsEqual(symbolsLength, 1)) {
                    var market interface{} = this.Market(GetValue(symbols, 0))
                    AddElementToObject(request, "symbol", GetValue(market, "id"))
                }
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "page_size", limit)
            }
        
            response:= (<-this.ContractPrivateGetPositionListHistoryPositions(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        success: true,
            //        code: '0',
            //        data: [
            //            {
            //                positionId: '390281084',
            //                symbol: 'RVN_USDT',
            //                positionType: '1',
            //                openType: '2',
            //                state: '3',
            //                holdVol: '0',
            //                frozenVol: '0',
            //                closeVol: '1141',
            //                holdAvgPrice: '0.03491',
            //                holdAvgPriceFullyScale: '0.03491',
            //                openAvgPrice: '0.03491',
            //                openAvgPriceFullyScale: '0.03491',
            //                closeAvgPrice: '0.03494',
            //                liquidatePrice: '0.03433',
            //                oim: '0',
            //                im: '0',
            //                holdFee: '0',
            //                realised: '0.1829',
            //                leverage: '50',
            //                createTime: '1711512408000',
            //                updateTime: '1711512553000',
            //                autoAddIm: false,
            //                version: '4',
            //                profitRatio: '0.0227',
            //                newOpenAvgPrice: '0.03491',
            //                newCloseAvgPrice: '0.03494',
            //                closeProfitLoss: '0.3423',
            //                fee: '0.1593977',
            //                positionShowStatus: 'CLOSED'
            //            },
            //            ...
            //        ]
            //    }
            //
            var data interface{} = this.SafeList(response, "data")
            var positions interface{} = this.ParsePositions(data, symbols, params)
        
            ch <- this.FilterBySinceLimit(positions, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mexc#setMarginMode
 * @description set margin mode to 'cross' or 'isolated'
 * @see https://mexcdevelop.github.io/apidocs/contract_v1_en/#switch-leverage
 * @param {string} marginMode 'cross' or 'isolated'
 * @param {string} [symbol] required when there is no position, else provide params["positionId"]
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.positionId] required when a position is set
 * @param {string} [params.direction] "long" or "short" required when there is no position
 * @returns {object} response from the exchange
 */
func  (this *mexc) SetMarginMode(marginMode interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes59728 := (<-this.LoadMarkets())
            PanicOnError(retRes59728)
            var market interface{} = this.Market(symbol)
            if IsTrue(GetValue(market, "spot")) {
                panic(BadSymbol(Add(this.Id, " setMarginMode() supports contract markets only")))
            }
            marginMode = ToLower(marginMode)
            if IsTrue(IsTrue(!IsEqual(marginMode, "isolated")) && IsTrue(!IsEqual(marginMode, "cross"))) {
                panic(BadRequest(Add(this.Id, " setMarginMode() marginMode argument should be isolated or cross")))
            }
            var leverage interface{} = this.SafeInteger(params, "leverage")
            if IsTrue(IsEqual(leverage, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " setMarginMode() requires a leverage parameter")))
            }
            var direction interface{} = this.SafeStringLower2(params, "direction", "positionId")
            var request interface{} = map[string]interface{} {
                "leverage": leverage,
                "openType": Ternary(IsTrue((IsEqual(marginMode, "isolated"))), 1, 2),
            }
            if IsTrue(!IsEqual(symbol, nil)) {
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(direction, nil)) {
                AddElementToObject(request, "positionType", Ternary(IsTrue((IsEqual(direction, "short"))), 2, 1))
            }
            params = this.Omit(params, "direction")
        
            response:= (<-this.ContractPrivatePostPositionChangeLeverage(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            // { success: true, code: '0' }
            //
        ch <- this.ParseLeverage(response, market)
            return nil
        
            }()
            return ch
        }
func  (this *mexc) Nonce() interface{}  {
    return Subtract(this.Milliseconds(), this.SafeInteger(this.Options, "timeDifference", 0))
}
func  (this *mexc) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var section interface{} = this.SafeString(api, 0)
    var access interface{} = this.SafeString(api, 1)
    pathparamsVariable := this.ResolvePath(path, params);
    path = GetValue(pathparamsVariable,0);
    params = GetValue(pathparamsVariable,1)
    var url interface{} = nil
    if IsTrue(IsTrue(IsEqual(section, "spot")) || IsTrue(IsEqual(section, "broker"))) {
        if IsTrue(IsEqual(section, "broker")) {
            url = Add(Add(GetValue(GetValue(GetValue(this.Urls, "api"), section), access), "/"), path)
        } else {
            url = Add(Add(Add(Add(GetValue(GetValue(GetValue(this.Urls, "api"), section), access), "/api/"), this.Version), "/"), path)
        }
        var urlParams interface{} = params
        if IsTrue(IsEqual(access, "private")) {
            if IsTrue(IsTrue(IsEqual(section, "broker")) && IsTrue((IsTrue(IsTrue((IsEqual(method, "POST"))) || IsTrue((IsEqual(method, "PUT")))) || IsTrue((IsEqual(method, "DELETE")))))) {
                urlParams = map[string]interface{} {
                    "timestamp": this.Nonce(),
                    "recvWindow": this.SafeInteger(this.Options, "recvWindow", 5000),
                }
                body = this.Json(params)
            } else {
                AddElementToObject(urlParams, "timestamp", this.Nonce())
                AddElementToObject(urlParams, "recvWindow", this.SafeInteger(this.Options, "recvWindow", 5000))
            }
        }
        var paramsEncoded interface{} = ""
        if IsTrue(GetArrayLength(ObjectKeys(urlParams))) {
            paramsEncoded = this.Urlencode(urlParams)
            url = Add(url, Add("?", paramsEncoded))
        }
        if IsTrue(IsEqual(access, "private")) {
            this.CheckRequiredCredentials()
            var signature interface{} = this.Hmac(this.Encode(paramsEncoded), this.Encode(this.Secret), sha256)
            url = Add(url, Add(Add("&", "signature="), signature))
            headers = map[string]interface{} {
                "X-MEXC-APIKEY": this.ApiKey,
                "source": this.SafeString(this.Options, "broker", "CCXT"),
            }
        }
        if IsTrue(IsTrue(IsTrue((IsEqual(method, "POST"))) || IsTrue((IsEqual(method, "PUT")))) || IsTrue((IsEqual(method, "DELETE")))) {
            AddElementToObject(headers, "Content-Type", "application/json")
        }
    } else if IsTrue(IsTrue(IsEqual(section, "contract")) || IsTrue(IsEqual(section, "spot2"))) {
        url = Add(Add(GetValue(GetValue(GetValue(this.Urls, "api"), section), access), "/"), this.ImplodeParams(path, params))
        params = this.Omit(params, this.ExtractParams(path))
        if IsTrue(IsEqual(access, "public")) {
            if IsTrue(GetArrayLength(ObjectKeys(params))) {
                url = Add(url, Add("?", this.Urlencode(params)))
            }
        } else {
            this.CheckRequiredCredentials()
            var timestamp interface{} = ToString(this.Nonce())
            var auth interface{} = ""
            headers = map[string]interface{} {
                "ApiKey": this.ApiKey,
                "Request-Time": timestamp,
                "Content-Type": "application/json",
                "source": this.SafeString(this.Options, "broker", "CCXT"),
            }
            if IsTrue(IsEqual(method, "POST")) {
                auth = this.Json(params)
                body = auth
            } else {
                params = this.Keysort(params)
                if IsTrue(GetArrayLength(ObjectKeys(params))) {
                    auth = Add(auth, this.Urlencode(params))
                    url = Add(url, Add("?", auth))
                }
            }
            auth = Add(Add(this.ApiKey, timestamp), auth)
            var signature interface{} = this.Hmac(this.Encode(auth), this.Encode(this.Secret), sha256)
            AddElementToObject(headers, "Signature", signature)
        }
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *mexc) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsEqual(response, nil)) {
        return nil
    }
    // spot
    //     {"code":-1128,"msg":"Combination of optional parameters invalid.","_extend":null}
    //     {"success":false,"code":123456,"message":"Order quantity error...."}
    //
    // contract
    //
    //     {"code":10232,"msg":"The currency not exist"}
    //     {"code":10216,"msg":"No available deposit address"}
    //     {"success":true, "code":0, "data":1634095541710}
    //
    var success interface{} = this.SafeBool(response, "success", false) // v1
    if IsTrue(IsEqual(success, true)) {
        return nil
    }
    var responseCode interface{} = this.SafeString(response, "code", nil)
    if IsTrue(IsTrue(IsTrue((!IsEqual(responseCode, nil))) && IsTrue((!IsEqual(responseCode, "200")))) && IsTrue((!IsEqual(responseCode, "0")))) {
        var feedback interface{} = Add(Add(this.Id, " "), body)
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), body, feedback)
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), responseCode, feedback)
        panic(ExchangeError(feedback))
    }
    return nil
}


func (this *mexc) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
