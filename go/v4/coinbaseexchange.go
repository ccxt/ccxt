package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type coinbaseexchange struct {
    Exchange

}

func NewCoinbaseexchangeCore() coinbaseexchange {
   p := coinbaseexchange{}
   setDefaults(&p)
   return p
}

func  (this *coinbaseexchange) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "coinbaseexchange",
        "name": "Coinbase Exchange",
        "countries": []interface{}{"US"},
        "rateLimit": 100,
        "userAgent": GetValue(this.UserAgents, "chrome"),
        "pro": true,
        "has": map[string]interface{} {
            "CORS": true,
            "spot": true,
            "margin": false,
            "swap": false,
            "future": false,
            "option": false,
            "cancelAllOrders": true,
            "cancelOrder": true,
            "createDepositAddress": true,
            "createOrder": true,
            "createStopLimitOrder": true,
            "createStopMarketOrder": true,
            "createStopOrder": true,
            "fetchAccounts": true,
            "fetchBalance": true,
            "fetchClosedOrders": true,
            "fetchCurrencies": true,
            "fetchDepositAddress": false,
            "fetchDeposits": true,
            "fetchDepositsWithdrawals": true,
            "fetchFundingHistory": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchLedger": true,
            "fetchMarginMode": false,
            "fetchMarkets": true,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrders": true,
            "fetchOrderTrades": true,
            "fetchPosition": false,
            "fetchPositionHistory": false,
            "fetchPositionMode": false,
            "fetchPositions": false,
            "fetchPositionsForSymbol": false,
            "fetchPositionsHistory": false,
            "fetchPositionsRisk": false,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTime": true,
            "fetchTrades": true,
            "fetchTradingFee": false,
            "fetchTradingFees": true,
            "fetchTransactions": "emulated",
            "fetchWithdrawals": true,
            "withdraw": true,
        },
        "timeframes": map[string]interface{} {
            "1m": 60,
            "5m": 300,
            "15m": 900,
            "1h": 3600,
            "6h": 21600,
            "1d": 86400,
        },
        "hostname": "exchange.coinbase.com",
        "urls": map[string]interface{} {
            "test": map[string]interface{} {
                "public": "https://api-public.sandbox.exchange.coinbase.com",
                "private": "https://api-public.sandbox.exchange.coinbase.com",
            },
            "logo": "https://github.com/ccxt/ccxt/assets/43336371/34a65553-88aa-4a38-a714-064bd228b97e",
            "api": map[string]interface{} {
                "public": "https://api.{hostname}",
                "private": "https://api.{hostname}",
            },
            "www": "https://coinbase.com/",
            "doc": "https://docs.cloud.coinbase.com/exchange/docs/",
            "fees": []interface{}{"https://docs.pro.coinbase.com/#fees", "https://support.pro.coinbase.com/customer/en/portal/articles/2945310-fees"},
        },
        "requiredCredentials": map[string]interface{} {
            "apiKey": true,
            "secret": true,
            "password": true,
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": []interface{}{"currencies", "products", "products/{id}", "products/{id}/book", "products/{id}/candles", "products/{id}/stats", "products/{id}/ticker", "products/{id}/trades", "time", "products/spark-lines", "products/volume-summary"},
            },
            "private": map[string]interface{} {
                "get": []interface{}{"address-book", "accounts", "accounts/{id}", "accounts/{id}/holds", "accounts/{id}/ledger", "accounts/{id}/transfers", "coinbase-accounts", "fills", "funding", "fees", "margin/profile_information", "margin/buying_power", "margin/withdrawal_power", "margin/withdrawal_power_all", "margin/exit_plan", "margin/liquidation_history", "margin/position_refresh_amounts", "margin/status", "oracle", "orders", "orders/{id}", "orders/client:{client_oid}", "otc/orders", "payment-methods", "position", "profiles", "profiles/{id}", "reports/{report_id}", "transfers", "transfers/{transfer_id}", "users/self/exchange-limits", "users/self/hold-balances", "users/self/trailing-volume", "withdrawals/fee-estimate", "conversions/{conversion_id}", "conversions/fees"},
                "post": []interface{}{"conversions", "deposits/coinbase-account", "deposits/payment-method", "coinbase-accounts/{id}/addresses", "funding/repay", "orders", "position/close", "profiles/margin-transfer", "profiles/transfer", "reports", "withdrawals/coinbase", "withdrawals/coinbase-account", "withdrawals/crypto", "withdrawals/payment-method"},
                "delete": []interface{}{"orders", "orders/client:{client_oid}", "orders/{id}"},
            },
        },
        "commonCurrencies": map[string]interface{} {
            "CGLD": "CELO",
        },
        "precisionMode": TICK_SIZE,
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "tierBased": true,
                "percentage": true,
                "maker": this.ParseNumber("0.004"),
                "taker": this.ParseNumber("0.006"),
            },
            "funding": map[string]interface{} {
                "tierBased": false,
                "percentage": false,
                "withdraw": map[string]interface{} {
                    "BCH": 0,
                    "BTC": 0,
                    "LTC": 0,
                    "ETH": 0,
                    "EUR": 0.15,
                    "USD": 25,
                },
                "deposit": map[string]interface{} {
                    "BCH": 0,
                    "BTC": 0,
                    "LTC": 0,
                    "ETH": 0,
                    "EUR": 0.15,
                    "USD": 10,
                },
            },
        },
        "features": map[string]interface{} {
            "default": map[string]interface{} {
                "sandbox": true,
                "createOrder": map[string]interface{} {
                    "marginMode": true,
                    "triggerPrice": true,
                    "triggerPriceType": nil,
                    "triggerDirection": false,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": true,
                        "FOK": true,
                        "PO": true,
                        "GTD": true,
                    },
                    "hedged": false,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyByCost": false,
                    "marketBuyRequiresPrice": false,
                    "selfTradePrevention": false,
                    "iceberg": true,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": 100000,
                    "untilDays": 100000,
                    "symbolRequired": true,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": 100000,
                    "untilDays": 100000,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchClosedOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": 100000,
                    "daysBackCanceled": 1,
                    "untilDays": 100000,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOHLCV": map[string]interface{} {
                    "limit": 300,
                },
            },
            "spot": map[string]interface{} {
                "extends": "default",
            },
            "swap": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "Insufficient funds": InsufficientFunds,
                "NotFound": OrderNotFound,
                "Invalid API Key": AuthenticationError,
                "invalid signature": AuthenticationError,
                "Invalid Passphrase": AuthenticationError,
                "Invalid order id": InvalidOrder,
                "Private rate limit exceeded": RateLimitExceeded,
                "Trading pair not available": PermissionDenied,
                "Product not found": InvalidOrder,
            },
            "broad": map[string]interface{} {
                "Order already done": OrderNotFound,
                "order not found": OrderNotFound,
                "price too small": InvalidOrder,
                "price too precise": InvalidOrder,
                "under maintenance": OnMaintenance,
                "size is too small": InvalidOrder,
                "Cancel only mode": OnMaintenance,
            },
        },
    })
}
/**
 * @method
 * @name coinbaseexchange#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_getcurrencies
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func  (this *coinbaseexchange) FetchCurrencies(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetCurrencies(params))
            PanicOnError(response)
            //
            //     [
            //         {
            //             "id": "XTZ",
            //             "name": "Tezos",
            //             "min_size": "0.000001",
            //             "status": "online",
            //             "message": '',
            //             "max_precision": "0.000001",
            //             "convertible_to": [],
            //             "details": {
            //                 "type": "crypto",
            //                 "symbol": "Τ",
            //                 "network_confirmations": 60,
            //                 "sort_order": 53,
            //                 "crypto_address_link": "https://tzstats.com/{{address}}",
            //                 "crypto_transaction_link": "https://tzstats.com/{{txId}}",
            //                 "push_payment_methods": [ "crypto" ],
            //                 "group_types": [],
            //                 "display_name": '',
            //                 "processing_time_seconds": 0,
            //                 "min_withdrawal_amount": 1
            //             }
            //         }
            //     ]
            //
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
                var currency interface{} = GetValue(response, i)
                var id interface{} = this.SafeString(currency, "id")
                var name interface{} = this.SafeString(currency, "name")
                var code interface{} = this.SafeCurrencyCode(id)
                var details interface{} = this.SafeValue(currency, "details", map[string]interface{} {})
                var status interface{} = this.SafeString(currency, "status")
                var active interface{} =         (IsEqual(status, "online"))
                AddElementToObject(result, code, map[string]interface{} {
            "id": id,
            "code": code,
            "info": currency,
            "type": this.SafeString(details, "type"),
            "name": name,
            "active": active,
            "deposit": nil,
            "withdraw": nil,
            "fee": nil,
            "precision": this.SafeNumber(currency, "max_precision"),
            "limits": map[string]interface{} {
                "amount": map[string]interface{} {
                    "min": this.SafeNumber(details, "min_size"),
                    "max": nil,
                },
                "withdraw": map[string]interface{} {
                    "min": this.SafeNumber(details, "min_withdrawal_amount"),
                    "max": nil,
                },
            },
            "networks": map[string]interface{} {},
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbaseexchange#fetchMarkets
 * @description retrieves data on all markets for coinbaseexchange
 * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_getproducts
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *coinbaseexchange) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetProducts(params))
            PanicOnError(response)
            //
            //     [
            //         {
            //             "id": "BTCAUCTION-USD",
            //             "base_currency": "BTC",
            //             "quote_currency": "USD",
            //             "base_min_size": "0.000016",
            //             "base_max_size": "1500",
            //             "quote_increment": "0.01",
            //             "base_increment": "0.00000001",
            //             "display_name": "BTCAUCTION/USD",
            //             "min_market_funds": "1",
            //             "max_market_funds": "20000000",
            //             "margin_enabled": false,
            //             "fx_stablecoin": false,
            //             "max_slippage_percentage": "0.02000000",
            //             "post_only": false,
            //             "limit_only": false,
            //             "cancel_only": true,
            //             "trading_disabled": false,
            //             "status": "online",
            //             "status_message": '',
            //             "auction_mode": false
            //         },
            //         {
            //             "id": "BTC-USD",
            //             "base_currency": "BTC",
            //             "quote_currency": "USD",
            //             "base_min_size": "0.000016",
            //             "base_max_size": "1500",
            //             "quote_increment": "0.01",
            //             "base_increment": "0.00000001",
            //             "display_name": "BTC/USD",
            //             "min_market_funds": "1",
            //             "max_market_funds": "20000000",
            //             "margin_enabled": false,
            //             "fx_stablecoin": false,
            //             "max_slippage_percentage": "0.02000000",
            //             "post_only": false,
            //             "limit_only": false,
            //             "cancel_only": false,
            //             "trading_disabled": false,
            //             "status": "online",
            //             "status_message": '',
            //             "auction_mode": false
            //         }
            //     ]
            //
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
                var market interface{} = GetValue(response, i)
                var id interface{} = this.SafeString(market, "id")
                baseIdquoteIdVariable := Split(id, "-");
                baseId := GetValue(baseIdquoteIdVariable,0);
                quoteId := GetValue(baseIdquoteIdVariable,1)
                // BTCAUCTION-USD vs BTC-USD conflict workaround, see the output sample above
                // const baseId = this.safeString (market, 'base_currency');
                // const quoteId = this.safeString (market, 'quote_currency');
                var base interface{} = this.SafeCurrencyCode(baseId)
                var quote interface{} = this.SafeCurrencyCode(quoteId)
                var status interface{} = this.SafeString(market, "status")
                AppendToArray(&result,this.Extend(GetValue(this.Fees, "trading"), map[string]interface{} {
                    "id": id,
                    "symbol": Add(Add(base, "/"), quote),
                    "base": base,
                    "quote": quote,
                    "settle": nil,
                    "baseId": baseId,
                    "quoteId": quoteId,
                    "settleId": nil,
                    "type": "spot",
                    "spot": true,
                    "margin": this.SafeValue(market, "margin_enabled"),
                    "swap": false,
                    "future": false,
                    "option": false,
                    "active": (IsEqual(status, "online")),
                    "contract": false,
                    "linear": nil,
                    "inverse": nil,
                    "contractSize": nil,
                    "expiry": nil,
                    "expiryDatetime": nil,
                    "strike": nil,
                    "optionType": nil,
                    "precision": map[string]interface{} {
                        "amount": this.SafeNumber(market, "base_increment"),
                        "price": this.SafeNumber(market, "quote_increment"),
                    },
                    "limits": map[string]interface{} {
                        "leverage": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "amount": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "price": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "cost": map[string]interface{} {
                            "min": this.SafeNumber(market, "min_market_funds"),
                            "max": nil,
                        },
                    },
                    "created": nil,
                    "info": market,
                }))
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbaseexchange#fetchAccounts
 * @description fetch all the accounts associated with a profile
 * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_getaccounts
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/#/?id=account-structure} indexed by the account type
 */
func  (this *coinbaseexchange) FetchAccounts(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes5278 := (<-this.LoadMarkets())
            PanicOnError(retRes5278)
        
            response:= (<-this.PrivateGetAccounts(params))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "id": "4aac9c60-cbda-4396-9da4-4aa71e95fba0",
            //             "currency": "BTC",
            //             "balance": "0.0000000000000000",
            //             "available": "0",
            //             "hold": "0.0000000000000000",
            //             "profile_id": "b709263e-f42a-4c7d-949a-a95c83d065da"
            //         },
            //         {
            //             "id": "f75fa69a-1ad1-4a80-bd61-ee7faa6135a3",
            //             "currency": "USDC",
            //             "balance": "0.0000000000000000",
            //             "available": "0",
            //             "hold": "0.0000000000000000",
            //             "profile_id": "b709263e-f42a-4c7d-949a-a95c83d065da"
            //         },
            //     ]
            //
        ch <- this.ParseAccounts(response, params)
            return nil
        
            }()
            return ch
        }
func  (this *coinbaseexchange) ParseAccount(account interface{}) interface{}  {
    //
    //     {
    //         "id": "4aac9c60-cbda-4396-9da4-4aa71e95fba0",
    //         "currency": "BTC",
    //         "balance": "0.0000000000000000",
    //         "available": "0",
    //         "hold": "0.0000000000000000",
    //         "profile_id": "b709263e-f42a-4c7d-949a-a95c83d065da"
    //     }
    //
    var currencyId interface{} = this.SafeString(account, "currency")
    return map[string]interface{} {
        "id": this.SafeString(account, "id"),
        "type": nil,
        "code": this.SafeCurrencyCode(currencyId),
        "info": account,
    }
}
func  (this *coinbaseexchange) ParseBalance(response interface{}) interface{}  {
    var result interface{} = map[string]interface{} {
        "info": response,
    }
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        var balance interface{} = GetValue(response, i)
        var currencyId interface{} = this.SafeString(balance, "currency")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        AddElementToObject(account, "free", this.SafeString(balance, "available"))
        AddElementToObject(account, "used", this.SafeString(balance, "hold"))
        AddElementToObject(account, "total", this.SafeString(balance, "balance"))
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name coinbaseexchange#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_getaccounts
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *coinbaseexchange) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes5968 := (<-this.LoadMarkets())
            PanicOnError(retRes5968)
        
            response:= (<-this.PrivateGetAccounts(params))
            PanicOnError(response)
        
            ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbaseexchange#fetchOrderBook
 * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_getproductbook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *coinbaseexchange) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes6128 := (<-this.LoadMarkets())
            PanicOnError(retRes6128)
            // level 1 - only the best bid and ask
            // level 2 - top 50 bids and asks (aggregated)
            // level 3 - full order book (non aggregated)
            var request interface{} = map[string]interface{} {
                "id": this.MarketId(symbol),
                "level": 2,
            }
        
            response:= (<-this.PublicGetProductsIdBook(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "sequence":1924393896,
            //         "bids":[
            //             ["0.01825","24.34811287",2],
            //             ["0.01824","72.5463",3],
            //             ["0.01823","424.54298049",6],
            //         ],
            //         "asks":[
            //             ["0.01826","171.10414904",4],
            //             ["0.01827","22.60427028",1],
            //             ["0.01828","397.46018784",7],
            //         ]
            //     }
            //
            var orderbook interface{} = this.ParseOrderBook(response, symbol)
            AddElementToObject(orderbook, "nonce", this.SafeInteger(response, "sequence"))
        
            ch <- orderbook
            return nil
        
            }()
            return ch
        }
func  (this *coinbaseexchange) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTickers
    //
    //      [
    //         1639472400, // timestamp
    //         4.26, // low
    //         4.38, // high
    //         4.35, // open
    //         4.27 // close
    //      ]
    //
    // fetchTicker
    //
    //     publicGetProductsIdTicker
    //
    //     {
    //         "trade_id":843439,
    //         "price":"0.997999",
    //         "size":"80.29769",
    //         "time":"2020-01-28T02:13:33.012523Z",
    //         "bid":"0.997094",
    //         "ask":"0.998",
    //         "volume":"1903188.03750000"
    //     }
    //
    //     publicGetProductsIdStats
    //
    //     {
    //         "open": "34.19000000",
    //         "high": "95.70000000",
    //         "low": "7.06000000",
    //         "volume": "2.41000000"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = nil
    var bid interface{} = nil
    var ask interface{} = nil
    var last interface{} = nil
    var high interface{} = nil
    var low interface{} = nil
    var open interface{} = nil
    var volume interface{} = nil
    var symbol interface{} = Ternary(IsTrue((IsEqual(market, nil))), nil, GetValue(market, "symbol"))
    if IsTrue(IsArray(ticker)) {
        last = this.SafeString(ticker, 4)
        timestamp = this.Milliseconds()
    } else {
        timestamp = this.Parse8601(this.SafeValue(ticker, "time"))
        bid = this.SafeString(ticker, "bid")
        ask = this.SafeString(ticker, "ask")
        high = this.SafeString(ticker, "high")
        low = this.SafeString(ticker, "low")
        open = this.SafeString(ticker, "open")
        last = this.SafeString2(ticker, "price", "last")
        volume = this.SafeString(ticker, "volume")
    }
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": high,
        "low": low,
        "bid": bid,
        "bidVolume": nil,
        "ask": ask,
        "askVolume": nil,
        "vwap": nil,
        "open": open,
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": nil,
        "percentage": nil,
        "average": nil,
        "baseVolume": volume,
        "quoteVolume": nil,
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name coinbaseexchange#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_getproduct
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *coinbaseexchange) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes7328 := (<-this.LoadMarkets())
            PanicOnError(retRes7328)
            symbols = this.MarketSymbols(symbols)
            var request interface{} = map[string]interface{} {}
        
            response:= (<-this.PublicGetProductsSparkLines(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         YYY-USD: [
            //             [
            //                 1639472400, // timestamp
            //                 4.26, // low
            //                 4.38, // high
            //                 4.35, // open
            //                 4.27 // close
            //             ],
            //             [
            //                 1639468800,
            //                 4.31,
            //                 4.45,
            //                 4.35,
            //                 4.35
            //             ],
            //         ]
            //     }
            //
            var result interface{} = map[string]interface{} {}
            var marketIds interface{} = ObjectKeys(response)
            var delimiter interface{} = "-"
            for i := 0; IsLessThan(i, GetArrayLength(marketIds)); i++ {
                var marketId interface{} = GetValue(marketIds, i)
                var entry interface{} = this.SafeValue(response, marketId, []interface{}{})
                var first interface{} = this.SafeValue(entry, 0, []interface{}{})
                var market interface{} = this.SafeMarket(marketId, nil, delimiter)
                var symbol interface{} = GetValue(market, "symbol")
                AddElementToObject(result, symbol, this.ParseTicker(first, market))
            }
        
            ch <- this.FilterByArrayTickers(result, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbaseexchange#fetchTicker
 * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_getproductticker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *coinbaseexchange) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes7808 := (<-this.LoadMarkets())
            PanicOnError(retRes7808)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "id": GetValue(market, "id"),
            }
            // publicGetProductsIdTicker or publicGetProductsIdStats
            var method interface{} = this.SafeString(this.Options, "fetchTickerMethod", "publicGetProductsIdTicker")
        
            response:= (<-this.callDynamically(method, this.Extend(request, params)))
            PanicOnError(response)
        
                //
            // publicGetProductsIdTicker
            //
            //     {
            //         "trade_id":843439,
            //         "price":"0.997999",
            //         "size":"80.29769",
            //         "time":"2020-01-28T02:13:33.012523Z",
            //         "bid":"0.997094",
            //         "ask":"0.998",
            //         "volume":"1903188.03750000"
            //     }
            //
            // publicGetProductsIdStats
            //
            //     {
            //         "open": "34.19000000",
            //         "high": "95.70000000",
            //         "low": "7.06000000",
            //         "volume": "2.41000000"
            //     }
            //
        ch <- this.ParseTicker(response, market)
            return nil
        
            }()
            return ch
        }
func  (this *coinbaseexchange) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "type": "match",
    //         "trade_id": 82047307,
    //         "maker_order_id": "0f358725-2134-435e-be11-753912a326e0",
    //         "taker_order_id": "252b7002-87a3-425c-ac73-f5b9e23f3caf",
    //         "order_id": "d50ec984-77a8-460a-b958-66f114b0de9b",
    //         "side": "sell",
    //         "size": "0.00513192",
    //         "price": "9314.78",
    //         "product_id": "BTC-USD",
    //         "profile_id": "6244401d-c078-40d9-b305-7ad3551bc3b0",
    //         "sequence": 12038915443,
    //         "time": "2020-01-31T20:03:41.158814Z"
    //         "created_at": "2014-11-07T22:19:28.578544Z",
    //         "liquidity": "T",
    //         "fee": "0.00025",
    //         "settled": true,
    //         "usd_volume": "0.0924556000000000",
    //         "user_id": "595eb864313c2b02ddf2937d"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.Parse8601(this.SafeString2(trade, "time", "created_at"))
    var marketId interface{} = this.SafeString(trade, "product_id")
    market = this.SafeMarket(marketId, market, "-")
    var feeRate interface{} = nil
    var takerOrMaker interface{} = nil
    var cost interface{} = nil
    var feeCurrencyId interface{} = this.SafeStringLower(market, "quoteId")
    if IsTrue(!IsEqual(feeCurrencyId, nil)) {
        var costField interface{} = Add(feeCurrencyId, "_value")
        cost = this.SafeString(trade, costField)
        var liquidity interface{} = this.SafeString(trade, "liquidity")
        if IsTrue(!IsEqual(liquidity, nil)) {
            takerOrMaker = Ternary(IsTrue((IsEqual(liquidity, "T"))), "taker", "maker")
            feeRate = this.SafeString(market, takerOrMaker)
        }
    }
    var feeCost interface{} = this.SafeString2(trade, "fill_fees", "fee")
    var fee interface{} = map[string]interface{} {
        "cost": feeCost,
        "currency": GetValue(market, "quote"),
        "rate": feeRate,
    }
    var id interface{} = this.SafeString(trade, "trade_id")
    var side interface{} = Ternary(IsTrue((IsEqual(GetValue(trade, "side"), "buy"))), "sell", "buy")
    var orderId interface{} = this.SafeString(trade, "order_id")
    // Coinbase Pro returns inverted side to fetchMyTrades vs fetchTrades
    var makerOrderId interface{} = this.SafeString(trade, "maker_order_id")
    var takerOrderId interface{} = this.SafeString(trade, "taker_order_id")
    if IsTrue(IsTrue((!IsEqual(orderId, nil))) || IsTrue((IsTrue((!IsEqual(makerOrderId, nil))) && IsTrue((!IsEqual(takerOrderId, nil)))))) {
        side = Ternary(IsTrue((IsEqual(GetValue(trade, "side"), "buy"))), "buy", "sell")
    }
    var price interface{} = this.SafeString(trade, "price")
    var amount interface{} = this.SafeString(trade, "size")
    return this.SafeTrade(map[string]interface{} {
        "id": id,
        "order": orderId,
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": GetValue(market, "symbol"),
        "type": nil,
        "takerOrMaker": takerOrMaker,
        "side": side,
        "price": price,
        "amount": amount,
        "fee": fee,
        "cost": cost,
    }, market)
}
/**
 * @method
 * @name coinbaseexchange#fetchMyTrades
 * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_getfills
 * @description fetch all trades made by the user
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch trades for
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *coinbaseexchange) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchMyTrades() requires a symbol argument")))
            }
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchMyTrades", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes90619 :=  (<-this.FetchPaginatedCallDynamic("fetchMyTrades", symbol, since, limit, params, 100))
                    PanicOnError(retRes90619)
                    ch <- retRes90619
                    return nil
            }
        
            retRes9088 := (<-this.LoadMarkets())
            PanicOnError(retRes9088)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "product_id": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_date", this.Iso8601(since))
            }
            var until interface{} = this.SafeValue2(params, "until", "end_date")
            if IsTrue(!IsEqual(until, nil)) {
                params = this.Omit(params, []interface{}{"until"})
                AddElementToObject(request, "end_date", this.Iso8601(until))
            }
        
            response:= (<-this.PrivateGetFills(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseTrades(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbaseexchange#fetchTrades
 * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_getproducttrades
 * @description get the list of most recent trades for a particular symbol
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *coinbaseexchange) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes9408 := (<-this.LoadMarkets())
            PanicOnError(retRes9408)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "id": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit) // default 100
            }
        
            response:= (<-this.PublicGetProductsIdTrades(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //    [
            //        {
            //            "trade_id": "15035219",
            //            "side": "sell",
            //            "size": "0.27426731",
            //            "price": "25820.42000000",
            //            "time": "2023-09-10T13:47:41.447577Z"
            //        },
            //    ]
            //
        ch <- this.ParseTrades(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbaseexchange#fetchTradingFees
 * @description fetch the trading fees for multiple markets
 * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_getfees
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
 */
func  (this *coinbaseexchange) FetchTradingFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes9728 := (<-this.LoadMarkets())
            PanicOnError(retRes9728)
        
            response:= (<-this.PrivateGetFees(params))
            PanicOnError(response)
            //
            //    {
            //        "maker_fee_rate": "0.0050",
            //        "taker_fee_rate": "0.0050",
            //        "usd_volume": "43806.92"
            //    }
            //
            var maker interface{} = this.SafeNumber(response, "maker_fee_rate")
            var taker interface{} = this.SafeNumber(response, "taker_fee_rate")
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(this.Symbols)); i++ {
                var symbol interface{} = GetValue(this.Symbols, i)
                AddElementToObject(result, symbol, map[string]interface{} {
            "info": response,
            "symbol": symbol,
            "maker": maker,
            "taker": taker,
            "percentage": true,
            "tierBased": true,
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *coinbaseexchange) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     [
    //         1591514160,
    //         0.02507,
    //         0.02507,
    //         0.02507,
    //         0.02507,
    //         0.02816506
    //     ]
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.SafeTimestamp(ohlcv, 0), this.SafeNumber(ohlcv, 3), this.SafeNumber(ohlcv, 2), this.SafeNumber(ohlcv, 1), this.SafeNumber(ohlcv, 4), this.SafeNumber(ohlcv, 5)}
}
/**
 * @method
 * @name coinbaseexchange#fetchOHLCV
 * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_getproductcandles
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch trades for
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *coinbaseexchange) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes10348 := (<-this.LoadMarkets())
            PanicOnError(retRes10348)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchOHLCV", "paginate", false);
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes103819 :=  (<-this.FetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, params, 300))
                    PanicOnError(retRes103819)
                    ch <- retRes103819
                    return nil
            }
            var market interface{} = this.Market(symbol)
            var parsedTimeframe interface{} = this.SafeInteger(this.Timeframes, timeframe)
            var request interface{} = map[string]interface{} {
                "id": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(parsedTimeframe, nil)) {
                AddElementToObject(request, "granularity", parsedTimeframe)
            } else {
                AddElementToObject(request, "granularity", timeframe)
            }
            var until interface{} = this.SafeValue2(params, "until", "end")
            params = this.Omit(params, []interface{}{"until"})
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start", this.Iso8601(since))
                if IsTrue(IsEqual(limit, nil)) {
                    // https://docs.pro.coinbase.com/#get-historic-rates
                    limit = 300 // max = 300
                } else {
                    limit = mathMin(300, limit)
                }
                if IsTrue(IsEqual(until, nil)) {
                    var parsedTimeframeMilliseconds interface{} = Multiply(parsedTimeframe, 1000)
                    if IsTrue(this.IsRoundNumber(Mod(since, parsedTimeframeMilliseconds))) {
                        AddElementToObject(request, "end", this.Iso8601(this.Sum(Multiply((Subtract(limit, 1)), parsedTimeframeMilliseconds), since)))
                    } else {
                        AddElementToObject(request, "end", this.Iso8601(this.Sum(Multiply(limit, parsedTimeframeMilliseconds), since)))
                    }
                } else {
                    AddElementToObject(request, "end", this.Iso8601(until))
                }
            }
        
            response:= (<-this.PublicGetProductsIdCandles(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         [1591514160,0.02507,0.02507,0.02507,0.02507,0.02816506],
            //         [1591514100,0.02507,0.02507,0.02507,0.02507,1.63830323],
            //         [1591514040,0.02505,0.02507,0.02505,0.02507,0.19918178]
            //     ]
            //
        ch <- this.ParseOHLCVs(response, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbaseexchange#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func  (this *coinbaseexchange) FetchTime(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetTime(params))
            PanicOnError(response)
        
                //
            //     {
            //         "iso":"2020-05-12T08:00:51.504Z",
            //         "epoch":1589270451.504
            //     }
            //
        ch <- this.SafeTimestamp(response, "epoch")
            return nil
        
            }()
            return ch
        }
func  (this *coinbaseexchange) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "pending": "open",
        "active": "open",
        "open": "open",
        "done": "closed",
        "canceled": "canceled",
        "canceling": "open",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *coinbaseexchange) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // createOrder
    //
    //     {
    //         "id": "d0c5340b-6d6c-49d9-b567-48c4bfca13d2",
    //         "price": "0.10000000",
    //         "size": "0.01000000",
    //         "product_id": "BTC-USD",
    //         "side": "buy",
    //         "stp": "dc",
    //         "type": "limit",
    //         "time_in_force": "GTC",
    //         "post_only": false,
    //         "created_at": "2016-12-08T20:02:28.53864Z",
    //         "fill_fees": "0.0000000000000000",
    //         "filled_size": "0.00000000",
    //         "executed_value": "0.0000000000000000",
    //         "status": "pending",
    //         "settled": false
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.Parse8601(this.SafeString(order, "created_at"))
    var marketId interface{} = this.SafeString(order, "product_id")
    market = this.SafeMarket(marketId, market, "-")
    var status interface{} = this.ParseOrderStatus(this.SafeString(order, "status"))
    var doneReason interface{} = this.SafeString(order, "done_reason")
    if IsTrue(IsTrue((IsEqual(status, "closed"))) && IsTrue((IsEqual(doneReason, "canceled")))) {
        status = "canceled"
    }
    var price interface{} = this.SafeString(order, "price")
    var filled interface{} = this.SafeString(order, "filled_size")
    var amount interface{} = this.SafeString(order, "size", filled)
    var cost interface{} = this.SafeString(order, "executed_value")
    var feeCost interface{} = this.SafeNumber(order, "fill_fees")
    var fee interface{} = nil
    if IsTrue(!IsEqual(feeCost, nil)) {
        fee = map[string]interface{} {
            "cost": feeCost,
            "currency": GetValue(market, "quote"),
            "rate": nil,
        }
    }
    var id interface{} = this.SafeString(order, "id")
    var typeVar interface{} = this.SafeString(order, "type")
    var side interface{} = this.SafeString(order, "side")
    var timeInForce interface{} = this.SafeString(order, "time_in_force")
    var postOnly interface{} = this.SafeValue(order, "post_only")
    var triggerPrice interface{} = this.SafeNumber(order, "stop_price")
    var clientOrderId interface{} = this.SafeString(order, "client_oid")
    return this.SafeOrder(map[string]interface{} {
        "id": id,
        "clientOrderId": clientOrderId,
        "info": order,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "status": status,
        "symbol": GetValue(market, "symbol"),
        "type": typeVar,
        "timeInForce": timeInForce,
        "postOnly": postOnly,
        "side": side,
        "price": price,
        "triggerPrice": triggerPrice,
        "cost": cost,
        "amount": amount,
        "filled": filled,
        "remaining": nil,
        "fee": fee,
        "average": nil,
        "trades": nil,
    }, market)
}
/**
 * @method
 * @name coinbaseexchange#fetchOrder
 * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_getorder
 * @description fetches information on an order made by the user
 * @param {string} id the order id
 * @param {string} symbol not used by coinbaseexchange fetchOrder
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinbaseexchange) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes11988 := (<-this.LoadMarkets())
            PanicOnError(retRes11988)
            var request interface{} = map[string]interface{} {}
            var clientOrderId interface{} = this.SafeString2(params, "clientOrderId", "client_oid")
            var method interface{} = nil
            if IsTrue(IsEqual(clientOrderId, nil)) {
                method = "privateGetOrdersId"
                AddElementToObject(request, "id", id)
            } else {
                method = "privateGetOrdersClientClientOid"
                AddElementToObject(request, "client_oid", clientOrderId)
                params = this.Omit(params, []interface{}{"clientOrderId", "client_oid"})
            }
        
            response:= (<-this.callDynamically(method, this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseOrder(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbaseexchange#fetchOrderTrades
 * @description fetch all the trades made from a single order
 * @param {string} id order id
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *coinbaseexchange) FetchOrderTrades(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes12268 := (<-this.LoadMarkets())
            PanicOnError(retRes12268)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var request interface{} = map[string]interface{} {
                "order_id": id,
            }
        
            response:= (<-this.PrivateGetFills(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseTrades(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbaseexchange#fetchOrders
 * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_getorders
 * @description fetches information on multiple orders made by the user
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch open orders for
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinbaseexchange) FetchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "status": "all",
            }
        
                retRes125415 :=  (<-this.FetchOpenOrders(symbol, since, limit, this.Extend(request, params)))
                PanicOnError(retRes125415)
                ch <- retRes125415
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbaseexchange#fetchOpenOrders
 * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_getorders
 * @description fetch all unfilled currently open orders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch open orders for
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinbaseexchange) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes12718 := (<-this.LoadMarkets())
            PanicOnError(retRes12718)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchOpenOrders", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes127519 :=  (<-this.FetchPaginatedCallDynamic("fetchOpenOrders", symbol, since, limit, params, 100))
                    PanicOnError(retRes127519)
                    ch <- retRes127519
                    return nil
            }
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "product_id", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit) // default 100
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_date", this.Iso8601(since))
            }
            var until interface{} = this.SafeValue2(params, "until", "end_date")
            if IsTrue(!IsEqual(until, nil)) {
                params = this.Omit(params, []interface{}{"until"})
                AddElementToObject(request, "end_date", this.Iso8601(until))
            }
        
            response:= (<-this.PrivateGetOrders(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseOrders(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbaseexchange#fetchClosedOrders
 * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_getorders
 * @description fetches information on multiple closed orders made by the user
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch open orders for
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinbaseexchange) FetchClosedOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "status": "done",
            }
        
                retRes131415 :=  (<-this.FetchOpenOrders(symbol, since, limit, this.Extend(request, params)))
                PanicOnError(retRes131415)
                ch <- retRes131415
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbaseexchange#createOrder
 * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_postorders
 * @description create a trade order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinbaseexchange) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes13318 := (<-this.LoadMarkets())
            PanicOnError(retRes13318)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "type": typeVar,
                "side": side,
                "product_id": GetValue(market, "id"),
            }
            var clientOrderId interface{} = this.SafeString2(params, "clientOrderId", "client_oid")
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                AddElementToObject(request, "client_oid", clientOrderId)
            }
            var triggerPrice interface{} = this.SafeNumberN(params, []interface{}{"stopPrice", "stop_price", "triggerPrice"})
            if IsTrue(!IsEqual(triggerPrice, nil)) {
                AddElementToObject(request, "stop_price", this.PriceToPrecision(symbol, triggerPrice))
            }
            var timeInForce interface{} = this.SafeString2(params, "timeInForce", "time_in_force")
            if IsTrue(!IsEqual(timeInForce, nil)) {
                AddElementToObject(request, "time_in_force", timeInForce)
            }
            var postOnly interface{} = this.SafeValue2(params, "postOnly", "post_only", false)
            if IsTrue(postOnly) {
                AddElementToObject(request, "post_only", true)
            }
            params = this.Omit(params, []interface{}{"timeInForce", "time_in_force", "stopPrice", "stop_price", "clientOrderId", "client_oid", "postOnly", "post_only", "triggerPrice"})
            if IsTrue(IsEqual(typeVar, "limit")) {
                AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
                AddElementToObject(request, "size", this.AmountToPrecision(symbol, amount))
            } else if IsTrue(IsEqual(typeVar, "market")) {
                var cost interface{} = this.SafeNumber2(params, "cost", "funds")
                if IsTrue(IsEqual(cost, nil)) {
                    if IsTrue(!IsEqual(price, nil)) {
                        cost = Multiply(amount, price)
                    }
                } else {
                    params = this.Omit(params, []interface{}{"cost", "funds"})
                }
                if IsTrue(!IsEqual(cost, nil)) {
                    AddElementToObject(request, "funds", this.CostToPrecision(symbol, cost))
                } else {
                    AddElementToObject(request, "size", this.AmountToPrecision(symbol, amount))
                }
            }
        
            response:= (<-this.PrivatePostOrders(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "id": "d0c5340b-6d6c-49d9-b567-48c4bfca13d2",
            //         "price": "0.10000000",
            //         "size": "0.01000000",
            //         "product_id": "BTC-USD",
            //         "side": "buy",
            //         "stp": "dc",
            //         "type": "limit",
            //         "time_in_force": "GTC",
            //         "post_only": false,
            //         "created_at": "2016-12-08T20:02:28.53864Z",
            //         "fill_fees": "0.0000000000000000",
            //         "filled_size": "0.00000000",
            //         "executed_value": "0.0000000000000000",
            //         "status": "pending",
            //         "settled": false
            //     }
            //
        ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbaseexchange#cancelOrder
 * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_deleteorder
 * @description cancels an open order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinbaseexchange) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes14228 := (<-this.LoadMarkets())
            PanicOnError(retRes14228)
            var request interface{} = map[string]interface{} {}
            var clientOrderId interface{} = this.SafeString2(params, "clientOrderId", "client_oid")
            var method interface{} = nil
            if IsTrue(IsEqual(clientOrderId, nil)) {
                method = "privateDeleteOrdersId"
                AddElementToObject(request, "id", id)
            } else {
                method = "privateDeleteOrdersClientClientOid"
                AddElementToObject(request, "client_oid", clientOrderId)
                params = this.Omit(params, []interface{}{"clientOrderId", "client_oid"})
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "product_id", GetValue(market, "symbol")) // the request will be more performant if you include it
            }
        
                retRes144115 :=  (<-this.callDynamically(method, this.Extend(request, params)))
                PanicOnError(retRes144115)
                ch <- retRes144115
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbaseexchange#cancelAllOrders
 * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_deleteorders
 * @description cancel all open orders
 * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinbaseexchange) CancelAllOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes14548 := (<-this.LoadMarkets())
            PanicOnError(retRes14548)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "product_id", GetValue(market, "symbol")) // the request will be more performant if you include it
            }
        
                retRes146115 :=  (<-this.PrivateDeleteOrders(this.Extend(request, params)))
                PanicOnError(retRes146115)
                ch <- retRes146115
                return nil
        
            }()
            return ch
        }
func  (this *coinbaseexchange) FetchPaymentMethods(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes146515 :=  (<-this.PrivateGetPaymentMethods(params))
                PanicOnError(retRes146515)
                ch <- retRes146515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbaseexchange#withdraw
 * @description make a withdrawal
 * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_postwithdrawpaymentmethod
 * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_postwithdrawcoinbaseaccount
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *coinbaseexchange) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params);
            tag = GetValue(tagparamsVariable,0);
            params = GetValue(tagparamsVariable,1)
            this.CheckAddress(address)
        
            retRes14848 := (<-this.LoadMarkets())
            PanicOnError(retRes14848)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "currency": GetValue(currency, "id"),
                "amount": amount,
            }
            var method interface{} = "privatePostWithdrawals"
            if IsTrue(InOp(params, "payment_method_id")) {
                method = Add(method, "PaymentMethod")
            } else if IsTrue(InOp(params, "coinbase_account_id")) {
                method = Add(method, "CoinbaseAccount")
            } else {
                method = Add(method, "Crypto")
                AddElementToObject(request, "crypto_address", address)
                if IsTrue(!IsEqual(tag, nil)) {
                    AddElementToObject(request, "destination_tag", tag)
                }
            }
        
            response:= (<-this.callDynamically(method, this.Extend(request, params)))
            PanicOnError(response)
            if !IsTrue(response) {
                panic(ExchangeError(Add(Add(this.Id, " withdraw() error: "), this.Json(response))))
            }
        
            ch <- this.ParseTransaction(response, currency)
            return nil
        
            }()
            return ch
        }
func  (this *coinbaseexchange) ParseLedgerEntryType(typeVar interface{}) interface{}  {
    var types interface{} = map[string]interface{} {
        "transfer": "transfer",
        "match": "trade",
        "fee": "fee",
        "rebate": "rebate",
        "conversion": "trade",
    }
    return this.SafeString(types, typeVar, typeVar)
}
func  (this *coinbaseexchange) ParseLedgerEntry(item interface{}, optionalArgs ...interface{}) interface{}  {
    //  {
    //      "id": "12087495079",
    //      "amount": "-0.0100000000000000",
    //      "balance": "0.0645419900000000",
    //      "created_at": "2021-10-28T17:14:32.593168Z",
    //      "type": "transfer",
    //      "details": {
    //          "from": "2f74edf7-1440-4586-86dc-ae58c5693691",
    //          "profile_transfer_id": "3ef093ad-2482-40d1-8ede-2f89cff5099e",
    //          "to": "dda99503-4980-4b60-9549-0b770ee51336"
    //      }
    //  },
    //  {
    //     "id": "11740725774",
    //     "amount": "-1.7565669701255000",
    //     "balance": "0.0016490047745000",
    //     "created_at": "2021-10-22T03:47:34.764122Z",
    //     "type": "fee",
    //     "details": {
    //         "order_id": "ad06abf4-95ab-432a-a1d8-059ef572e296",
    //         "product_id": "ETH-DAI",
    //         "trade_id": "1740617"
    //     }
    //  }
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var id interface{} = this.SafeString(item, "id")
    var amountString interface{} = this.SafeString(item, "amount")
    var direction interface{} = nil
    var afterString interface{} = this.SafeString(item, "balance")
    var beforeString interface{} = Precise.StringSub(afterString, amountString)
    if IsTrue(Precise.StringLt(amountString, "0")) {
        direction = "out"
        amountString = Precise.StringAbs(amountString)
    } else {
        direction = "in"
    }
    var amount interface{} = this.ParseNumber(amountString)
    var after interface{} = this.ParseNumber(afterString)
    var before interface{} = this.ParseNumber(beforeString)
    var timestamp interface{} = this.Parse8601(this.SafeValue(item, "created_at"))
    var typeVar interface{} = this.ParseLedgerEntryType(this.SafeString(item, "type"))
    var code interface{} = this.SafeCurrencyCode(nil, currency)
    var details interface{} = this.SafeValue(item, "details", map[string]interface{} {})
    var account interface{} = nil
    var referenceAccount interface{} = nil
    var referenceId interface{} = nil
    if IsTrue(IsEqual(typeVar, "transfer")) {
        account = this.SafeString(details, "from")
        referenceAccount = this.SafeString(details, "to")
        referenceId = this.SafeString(details, "profile_transfer_id")
    } else {
        referenceId = this.SafeString(details, "order_id")
    }
    var status interface{} = "ok"
    return this.SafeLedgerEntry(map[string]interface{} {
        "info": item,
        "id": id,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "direction": direction,
        "account": account,
        "referenceAccount": referenceAccount,
        "referenceId": referenceId,
        "type": typeVar,
        "currency": code,
        "amount": amount,
        "before": before,
        "after": after,
        "status": status,
        "fee": nil,
    }, currency)
}
/**
 * @method
 * @name coinbaseexchange#fetchLedger
 * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
 * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_getaccountledger
 * @param {string} code unified currency code, default is undefined
 * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
 * @param {int} [limit] max number of ledger entries to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch trades for
 * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger}
 */
func  (this *coinbaseexchange) FetchLedger(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    // https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_getaccountledger
            code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(code, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchLedger() requires a code param")))
            }
        
            retRes16108 := (<-this.LoadMarkets())
            PanicOnError(retRes16108)
        
            retRes16118 := (<-this.LoadAccounts())
            PanicOnError(retRes16118)
            var currency interface{} = this.Currency(code)
            var accountsByCurrencyCode interface{} = this.IndexBy(this.Accounts, "code")
            var account interface{} = this.SafeValue(accountsByCurrencyCode, code)
            if IsTrue(IsEqual(account, nil)) {
                panic(ExchangeError(Add(Add(this.Id, " fetchLedger() could not find account id for "), code)))
            }
            var request interface{} = map[string]interface{} {
                "id": GetValue(account, "id"),
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_date", this.Iso8601(since))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit) // default 100
            }
            var until interface{} = this.SafeValue2(params, "until", "end_date")
            if IsTrue(!IsEqual(until, nil)) {
                params = this.Omit(params, []interface{}{"until"})
                AddElementToObject(request, "end_date", this.Iso8601(until))
            }
        
            response:= (<-this.PrivateGetAccountsIdLedger(this.Extend(request, params)))
            PanicOnError(response)
            for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
                AddElementToObject(GetValue(response, i), "currency", code)
            }
        
            ch <- this.ParseLedger(response, currency, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbaseexchange#fetchDepositsWithdrawals
 * @description fetch history of deposits and withdrawals
 * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_gettransfers
 * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_getaccounttransfers
 * @param {string} [code] unified currency code for the currency of the deposit/withdrawals, default is undefined
 * @param {int} [since] timestamp in ms of the earliest deposit/withdrawal, default is undefined
 * @param {int} [limit] max number of deposit/withdrawals to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.id] account id, when defined, the endpoint used is '/accounts/{account_id}/transfers/' instead of '/transfers/'
 * @returns {object} a list of [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *coinbaseexchange) FetchDepositsWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes16598 := (<-this.LoadMarkets())
            PanicOnError(retRes16598)
        
            retRes16608 := (<-this.LoadAccounts())
            PanicOnError(retRes16608)
            var currency interface{} = nil
            var id interface{} = this.SafeString(params, "id") // account id
            if IsTrue(IsEqual(id, nil)) {
                if IsTrue(!IsEqual(code, nil)) {
                    currency = this.Currency(code)
                    var accountsByCurrencyCode interface{} = this.IndexBy(this.Accounts, "code")
                    var account interface{} = this.SafeValue(accountsByCurrencyCode, code)
                    if IsTrue(IsEqual(account, nil)) {
                        panic(ExchangeError(Add(Add(this.Id, " fetchDepositsWithdrawals() could not find account id for "), code)))
                    }
                    id = GetValue(account, "id")
                }
            }
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(id, nil)) {
                AddElementToObject(request, "id", id)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            var response interface{} = nil
            if IsTrue(IsEqual(id, nil)) {
                
        response = (<-this.PrivateGetTransfers(this.Extend(request, params)))
                PanicOnError(response)
                //
                //    [
                //        {
                //            "id": "bee6fd7c-afb2-4e47-8298-671d09997d16",
                //            "type": "deposit",
                //            "created_at": "2022-12-21 00:48:45.477503+00",
                //            "completed_at": null,
                //            "account_id": "sal3802-36bd-46be-a7b8-alsjf383sldak",
                //            "user_id": "6382048209f92as392039dlks2",
                //            "amount": "0.01000000",
                //            "details": {
                //                "network": "litecoin",
                //                "crypto_address": "MKemtnCFUYKsNWaf5EMYMpwSszcXWFDtTY",
                //                "coinbase_account_id": "fl2b6925-f6ba-403n-jj03-40fl435n430f",
                //                "coinbase_transaction_id": "63a25bb13cb5cf0001d2cf17", // withdrawals only
                //                "crypto_transaction_hash": "752f35570736341e2a253f7041a34cf1e196fc56128c900fd03d99da899d94c1",
                //                "tx_service_transaction_id": "1873249104",
                //                "coinbase_payment_method_id": ""
                //            },
                //            "canceled_at": null,
                //            "processed_at": null,
                //            "user_nonce": null,
                //            "idem": "5e3201b0-e390-5k3k-a913-c32932049242",
                //            "profile_id": "k3k302a8-c4dk-4f49-9d39-3203923wpk39",
                //            "currency": "LTC"
                //        }
                //    ]
                //
                for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
                    var account_id interface{} = this.SafeString(GetValue(response, i), "account_id")
                    var account interface{} = this.SafeValue(this.AccountsById, account_id)
                    var codeInner interface{} = this.SafeString(account, "code")
                    AddElementToObject(GetValue(response, i), "currency", codeInner)
                }
            } else {
                
        response = (<-this.PrivateGetAccountsIdTransfers(this.Extend(request, params)))
                PanicOnError(response)
                //
                //    [
                //        {
                //            "id": "bee6fd7c-afb2-4e47-8298-671d09997d16",
                //            "type": "deposit",
                //            "created_at": "2022-12-21 00:48:45.477503+00",
                //            "completed_at": null,
                //            "amount": "0.01000000",
                //            "details": {
                //                "network": "litecoin",
                //                "crypto_address": "MKemtnCFUYKsNWaf5EMYMpwSszcXWFDtTY",
                //                "coinbase_account_id": "fl2b6925-f6ba-403n-jj03-40fl435n430f",
                //                "coinbase_transaction_id": "63a25bb13cb5cf0001d2cf17", // withdrawals only
                //                "crypto_transaction_hash": "752f35570736341e2a253f7041a34cf1e196fc56128c900fd03d99da899d94c1",
                //                "tx_service_transaction_id": "1873249104",
                //                "coinbase_payment_method_id": ""
                //            },
                //            "canceled_at": null,
                //            "processed_at": null,
                //            "user_nonce": null,
                //            "idem": "5e3201b0-e390-5k3k-a913-c32932049242",
                //            "profile_id": "k3k302a8-c4dk-4f49-9d39-3203923wpk39",
                //            "currency": "LTC"
                //        }
                //    ]
                //
                for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
                    AddElementToObject(GetValue(response, i), "currency", code)
                }
            }
        
            ch <- this.ParseTransactions(response, currency, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbaseexchange#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_gettransfers
 * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_getaccounttransfers
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *coinbaseexchange) FetchDeposits(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
                retRes176615 :=  (<-this.FetchDepositsWithdrawals(code, since, limit, this.Extend(map[string]interface{} {
                "type": "deposit",
            }, params)))
                PanicOnError(retRes176615)
                ch <- retRes176615
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinbaseexchange#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_gettransfers
 * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_getaccounttransfers
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawals structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *coinbaseexchange) FetchWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
                retRes178215 :=  (<-this.FetchDepositsWithdrawals(code, since, limit, this.Extend(map[string]interface{} {
                "type": "withdraw",
            }, params)))
                PanicOnError(retRes178215)
                ch <- retRes178215
                return nil
        
            }()
            return ch
        }
func  (this *coinbaseexchange) ParseTransactionStatus(transaction interface{}) interface{}  {
    var canceled interface{} = this.SafeValue(transaction, "canceled_at")
    if IsTrue(canceled) {
        return "canceled"
    }
    var processed interface{} = this.SafeValue(transaction, "processed_at")
    var completed interface{} = this.SafeValue(transaction, "completed_at")
    if IsTrue(completed) {
        return "ok"
    } else if IsTrue(IsTrue(processed) && !IsTrue(completed)) {
        return "failed"
    } else {
        return "pending"
    }
}
func  (this *coinbaseexchange) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // privateGetTransfers
    //
    //    [
    //        {
    //            "id": "bee6fd7c-afb2-4e47-8298-671d09997d16",
    //            "type": "deposit",
    //            "created_at": "2022-12-21 00:48:45.477503+00",
    //            "completed_at": null,
    //            "account_id": "sal3802-36bd-46be-a7b8-alsjf383sldak",     // only from privateGetTransfers
    //            "user_id": "6382048209f92as392039dlks2",                  // only from privateGetTransfers
    //            "amount": "0.01000000",
    //            "details": {
    //                "network": "litecoin",
    //                "crypto_address": "MKemtnCFUYKsNWaf5EMYMpwSszcXWFDtTY",
    //                "coinbase_account_id": "fl2b6925-f6ba-403n-jj03-40fl435n430f",
    //                "coinbase_transaction_id": "63a25bb13cb5cf0001d2cf17", // withdrawals only
    //                "crypto_transaction_hash": "752f35570736341e2a253f7041a34cf1e196fc56128c900fd03d99da899d94c1",
    //                "tx_service_transaction_id": "1873249104",
    //                "coinbase_payment_method_id": ""
    //            },
    //            "canceled_at": null,
    //            "processed_at": null,
    //            "user_nonce": null,
    //            "idem": "5e3201b0-e390-5k3k-a913-c32932049242",
    //            "profile_id": "k3k302a8-c4dk-4f49-9d39-3203923wpk39",
    //            "currency": "LTC"
    //        }
    //    ]
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var details interface{} = this.SafeValue(transaction, "details", map[string]interface{} {})
    var timestamp interface{} = this.Parse8601(this.SafeString(transaction, "created_at"))
    var currencyId interface{} = this.SafeString(transaction, "currency")
    var code interface{} = this.SafeCurrencyCode(currencyId, currency)
    var amount interface{} = this.SafeNumber(transaction, "amount")
    var typeVar interface{} = this.SafeString(transaction, "type")
    var address interface{} = this.SafeString(details, "crypto_address")
    address = this.SafeString(transaction, "crypto_address", address)
    var fee interface{} = map[string]interface{} {
        "currency": nil,
        "cost": nil,
        "rate": nil,
    }
    if IsTrue(IsEqual(typeVar, "withdraw")) {
        typeVar = "withdrawal"
        address = this.SafeString(details, "sent_to_address", address)
        var feeCost interface{} = this.SafeNumber(details, "fee")
        if IsTrue(!IsEqual(feeCost, nil)) {
            if IsTrue(!IsEqual(amount, nil)) {
                amount = Subtract(amount, feeCost)
            }
            AddElementToObject(fee, "cost", feeCost)
            AddElementToObject(fee, "currency", code)
        }
    }
    var networkId interface{} = this.SafeString(details, "network")
    return map[string]interface{} {
        "info": transaction,
        "id": this.SafeString(transaction, "id"),
        "txid": this.SafeString(details, "crypto_transaction_hash"),
        "type": typeVar,
        "currency": code,
        "network": this.NetworkIdToCode(networkId),
        "amount": amount,
        "status": this.ParseTransactionStatus(transaction),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "address": address,
        "addressFrom": nil,
        "addressTo": this.SafeString(details, "crypto_address"),
        "tag": this.SafeString(details, "destination_tag"),
        "tagFrom": nil,
        "tagTo": nil,
        "updated": this.Parse8601(this.SafeString(transaction, "processed_at")),
        "comment": nil,
        "internal": false,
        "fee": fee,
    }
}
/**
 * @method
 * @name coinbaseexchange#createDepositAddress
 * @description create a currency deposit address
 * @see https://docs.cloud.coinbase.com/exchange/reference/exchangerestapi_postcoinbaseaccountaddresses
 * @param {string} code unified currency code of the currency for the deposit address
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *coinbaseexchange) CreateDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes18928 := (<-this.LoadMarkets())
            PanicOnError(retRes18928)
            var currency interface{} = this.Currency(code)
            var accounts interface{} = this.SafeValue(this.Options, "coinbaseAccounts")
            if IsTrue(IsEqual(accounts, nil)) {
                
        accounts = (<-this.PrivateGetCoinbaseAccounts())
                PanicOnError(accounts)
                AddElementToObject(this.Options, "coinbaseAccounts", accounts) // cache it
                AddElementToObject(this.Options, "coinbaseAccountsByCurrencyId", this.IndexBy(accounts, "currency"))
            }
            var currencyId interface{} = GetValue(currency, "id")
            var account interface{} = this.SafeValue(GetValue(this.Options, "coinbaseAccountsByCurrencyId"), currencyId)
            if IsTrue(IsEqual(account, nil)) {
                panic(InvalidAddress(Add(Add(Add(Add(Add(this.Id, " createDepositAddress() could not find currency code "), code), " with id = "), currencyId), " in this.options[\\'coinbaseAccountsByCurrencyId\\']")))
            }
            var request interface{} = map[string]interface{} {
                "id": GetValue(account, "id"),
            }
        
            response:= (<-this.PrivatePostCoinbaseAccountsIdAddresses(this.Extend(request, params)))
            PanicOnError(response)
            var address interface{} = this.SafeString(response, "address")
            var tag interface{} = this.SafeString(response, "destination_tag")
        
            ch <- map[string]interface{} {
                "currency": code,
                "address": this.CheckAddress(address),
                "tag": tag,
                "info": response,
            }
            return nil
        
            }()
            return ch
        }
func  (this *coinbaseexchange) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var request interface{} = Add("/", this.ImplodeParams(path, params))
    var query interface{} = this.Omit(params, this.ExtractParams(path))
    if IsTrue(IsEqual(method, "GET")) {
        if IsTrue(GetArrayLength(ObjectKeys(query))) {
            request = Add(request, Add("?", this.Urlencode(query)))
        }
    }
    var url interface{} = Add(this.ImplodeHostname(GetValue(GetValue(this.Urls, "api"), api)), request)
    if IsTrue(IsEqual(api, "private")) {
        this.CheckRequiredCredentials()
        var nonce interface{} = ToString(this.Nonce())
        var payload interface{} = ""
        if IsTrue(!IsEqual(method, "GET")) {
            if IsTrue(GetArrayLength(ObjectKeys(query))) {
                body = this.Json(query)
                payload = body
            }
        }
        var what interface{} = Add(Add(Add(nonce, method), request), payload)
        var secret interface{} = nil
        
        {		ret__ := func(this *coinbaseexchange) (ret_ interface{}) {
        		defer func() {
        			if e := recover(); e != nil {
                        if e == "break" {
        				    return
        			    }
        				ret_ = func(this *coinbaseexchange) interface{} {
        					// catch block:
                                        panic(AuthenticationError(Add(this.Id, " sign() invalid base64 secret")))
                            return nil
        				}(this)
        			}
        		}()
        		// try block:
                            secret = this.Base64ToBinary(this.Secret)
        		return nil
        	}(this)
        	if ret__ != nil {
        		return ret__
        	}
        }
        var signature interface{} = this.Hmac(this.Encode(what), secret, sha256, "base64")
        headers = map[string]interface{} {
            "CB-ACCESS-KEY": this.ApiKey,
            "CB-ACCESS-SIGN": signature,
            "CB-ACCESS-TIMESTAMP": nonce,
            "CB-ACCESS-PASSPHRASE": this.Password,
            "Content-Type": "application/json",
        }
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *coinbaseexchange) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsTrue((IsEqual(code, 400))) || IsTrue((IsEqual(code, 404)))) {
        if IsTrue(IsEqual(GetValue(body, 0), "{")) {
            var message interface{} = this.SafeString(response, "message")
            var feedback interface{} = Add(Add(this.Id, " "), message)
            this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), message, feedback)
            this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), message, feedback)
            panic(ExchangeError(feedback))
        }
        panic(ExchangeError(Add(Add(this.Id, " "), body)))
    }
    return nil
}
func  (this *coinbaseexchange) Request(path interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    api := GetArg(optionalArgs, 0, "public")
            _ = api
            method := GetArg(optionalArgs, 1, "GET")
            _ = method
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
            headers := GetArg(optionalArgs, 3, nil)
            _ = headers
            body := GetArg(optionalArgs, 4, nil)
            _ = body
            config := GetArg(optionalArgs, 5, map[string]interface{} {})
            _ = config
        
            response:= (<-this.Fetch2(path, api, method, params, headers, body, config))
            PanicOnError(response)
            if IsTrue(!IsString(response)) {
                if IsTrue(InOp(response, "message")) {
                    panic(ExchangeError(Add(Add(this.Id, " "), this.Json(response))))
                }
            }
        
            ch <- response
            return nil
        
            }()
            return ch
        }


func (this *coinbaseexchange) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
