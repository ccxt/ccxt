package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type coinmetro struct {
    Exchange

}

func NewCoinmetroCore() coinmetro {
   p := coinmetro{}
   setDefaults(&p)
   return p
}

func  (this *coinmetro) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "coinmetro",
        "name": "Coinmetro",
        "countries": []interface{}{"EE"},
        "version": "v1",
        "rateLimit": 200,
        "certified": false,
        "pro": false,
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": true,
            "swap": false,
            "future": false,
            "option": false,
            "addMargin": false,
            "borrowCrossMargin": true,
            "borrowIsolatedMargin": false,
            "cancelAllOrders": false,
            "cancelOrder": true,
            "cancelOrders": false,
            "closeAllPositions": false,
            "closePosition": true,
            "createDepositAddress": false,
            "createOrder": true,
            "createPostOnlyOrder": false,
            "createReduceOnlyOrder": false,
            "createStopLimitOrder": true,
            "createStopMarketOrder": true,
            "createStopOrder": true,
            "deposit": false,
            "editOrder": false,
            "fetchAccounts": false,
            "fetchBalance": true,
            "fetchBidsAsks": true,
            "fetchBorrowInterest": false,
            "fetchBorrowRateHistories": false,
            "fetchBorrowRateHistory": false,
            "fetchCanceledAndClosedOrders": true,
            "fetchCanceledOrders": false,
            "fetchClosedOrder": false,
            "fetchClosedOrders": false,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchCurrencies": true,
            "fetchDeposit": false,
            "fetchDepositAddress": false,
            "fetchDepositAddresses": false,
            "fetchDepositAddressesByNetwork": false,
            "fetchDeposits": false,
            "fetchDepositsWithdrawals": false,
            "fetchDepositWithdrawFee": false,
            "fetchDepositWithdrawFees": false,
            "fetchFundingHistory": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchIndexOHLCV": false,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchL3OrderBook": false,
            "fetchLedger": true,
            "fetchLeverage": false,
            "fetchLeverageTiers": false,
            "fetchMarketLeverageTiers": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrder": false,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrderBooks": false,
            "fetchOrders": false,
            "fetchOrderTrades": false,
            "fetchPosition": false,
            "fetchPositions": false,
            "fetchPositionsRisk": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchStatus": false,
            "fetchTicker": false,
            "fetchTickers": true,
            "fetchTime": false,
            "fetchTrades": true,
            "fetchTradingFee": false,
            "fetchTradingFees": false,
            "fetchTradingLimits": false,
            "fetchTransactionFee": false,
            "fetchTransactionFees": false,
            "fetchTransactions": false,
            "fetchTransfers": false,
            "fetchWithdrawal": false,
            "fetchWithdrawals": false,
            "fetchWithdrawalWhitelist": false,
            "reduceMargin": false,
            "repayCrossMargin": false,
            "repayIsolatedMargin": false,
            "sandbox": true,
            "setLeverage": false,
            "setMargin": false,
            "setMarginMode": false,
            "setPositionMode": false,
            "signIn": false,
            "transfer": false,
            "withdraw": false,
            "ws": false,
        },
        "timeframes": map[string]interface{} {
            "1m": "60000",
            "5m": "300000",
            "30m": "1800000",
            "4h": "14400000",
            "1d": "86400000",
        },
        "urls": map[string]interface{} {
            "logo": "https://github.com/ccxt/ccxt/assets/43336371/e86f87ec-6ba3-4410-962b-f7988c5db539",
            "api": map[string]interface{} {
                "public": "https://api.coinmetro.com",
                "private": "https://api.coinmetro.com",
            },
            "test": map[string]interface{} {
                "public": "https://api.coinmetro.com/open",
                "private": "https://api.coinmetro.com/open",
            },
            "www": "https://coinmetro.com/",
            "doc": []interface{}{"https://documenter.getpostman.com/view/3653795/SVfWN6KS"},
            "fees": "https://help.coinmetro.com/hc/en-gb/articles/6844007317789-What-are-the-fees-on-Coinmetro-",
            "referral": "https://go.coinmetro.com/?ref=crypto24",
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": map[string]interface{} {
                    "demo/temp": 1,
                    "exchange/candles/{pair}/{timeframe}/{from}/{to}": 3,
                    "exchange/prices": 1,
                    "exchange/ticks/{pair}/{from}": 3,
                    "assets": 1,
                    "markets": 1,
                    "exchange/book/{pair}": 3,
                    "exchange/bookUpdates/{pair}/{from}": 1,
                },
            },
            "private": map[string]interface{} {
                "get": map[string]interface{} {
                    "users/balances": 1,
                    "users/wallets": 1,
                    "users/wallets/history/{since}": 1.67,
                    "exchange/orders/status/{orderID}": 1,
                    "exchange/orders/active": 1,
                    "exchange/orders/history/{since}": 1.67,
                    "exchange/fills/{since}": 1.67,
                    "exchange/margin": 1,
                },
                "post": map[string]interface{} {
                    "jwt": 1,
                    "jwtDevice": 1,
                    "devices": 1,
                    "jwt-read-only": 1,
                    "exchange/orders/create": 1,
                    "exchange/orders/modify/{orderID}": 1,
                    "exchange/swap": 1,
                    "exchange/swap/confirm/{swapId}": 1,
                    "exchange/orders/close/{orderID}": 1,
                    "exchange/orders/hedge": 1,
                },
                "put": map[string]interface{} {
                    "jwt": 1,
                    "exchange/orders/cancel/{orderID}": 1,
                    "users/margin/collateral": 1,
                    "users/margin/primary/{currency}": 1,
                },
            },
        },
        "requiredCredentials": map[string]interface{} {
            "apiKey": false,
            "secret": false,
            "uid": true,
            "token": true,
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "feeSide": "get",
                "tierBased": false,
                "percentage": true,
                "taker": this.ParseNumber("0.001"),
                "maker": this.ParseNumber("0"),
            },
        },
        "precisionMode": TICK_SIZE,
        "options": map[string]interface{} {
            "currenciesByIdForParseMarket": nil,
            "currencyIdsListForParseMarket": []interface{}{"QRDO"},
        },
        "features": map[string]interface{} {
            "spot": map[string]interface{} {
                "sandbox": true,
                "createOrder": map[string]interface{} {
                    "marginMode": true,
                    "triggerPrice": true,
                    "triggerPriceType": nil,
                    "triggerDirection": false,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": map[string]interface{} {
                        "triggerPriceType": nil,
                        "price": false,
                    },
                    "timeInForce": map[string]interface{} {
                        "IOC": true,
                        "FOK": true,
                        "PO": false,
                        "GTD": true,
                    },
                    "hedged": false,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyByCost": true,
                    "marketBuyRequiresPrice": false,
                    "selfTradePrevention": false,
                    "iceberg": true,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": nil,
                    "daysBack": 100000,
                    "untilDays": nil,
                    "symbolRequired": false,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": nil,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": nil,
                    "daysBack": 100000,
                    "untilDays": nil,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchClosedOrders": nil,
                "fetchOHLCV": map[string]interface{} {
                    "limit": 1000,
                },
            },
            "swap": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "Both buyingCurrency and sellingCurrency are required": InvalidOrder,
                "One and only one of buyingQty and sellingQty is required": InvalidOrder,
                "Invalid buyingCurrency": InvalidOrder,
                "Invalid \\'from\\'": BadRequest,
                "Invalid sellingCurrency": InvalidOrder,
                "Invalid buyingQty": InvalidOrder,
                "Invalid sellingQty": InvalidOrder,
                "Insufficient balance": InsufficientFunds,
                "Expiration date is in the past or too near in the future": InvalidOrder,
                "Forbidden": PermissionDenied,
                "Order Not Found": OrderNotFound,
                "since must be a millisecond timestamp": BadRequest,
                "This pair is disabled on margin": BadSymbol,
            },
            "broad": map[string]interface{} {
                "accessing from a new IP": PermissionDenied,
                "available to allocate as collateral": InsufficientFunds,
                "At least": BadRequest,
                "collateral is not allowed": BadRequest,
                "Insufficient liquidity": InvalidOrder,
                "Insufficient order size": InvalidOrder,
                "Invalid quantity": InvalidOrder,
                "Invalid Stop Loss": InvalidOrder,
                "Invalid stop price!": InvalidOrder,
                "Not enough balance": InsufficientFunds,
                "Not enough margin": InsufficientFunds,
                "orderType missing": BadRequest,
                "Server Timeout": ExchangeError,
                "Time in force has to be IOC or FOK for market orders": InvalidOrder,
                "Too many attempts": RateLimitExceeded,
            },
        },
    })
}
/**
 * @method
 * @name coinmetro#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see https://documenter.getpostman.com/view/3653795/SVfWN6KS#d5876d43-a3fe-4479-8c58-24d0f044edfb
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func  (this *coinmetro) FetchCurrencies(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetAssets(params))
            PanicOnError(response)
            //
            //     [
            //         {
            //             "symbol": "BTC",
            //             "name": "Bitcoin",
            //             "color": "#FFA500",
            //             "type": "coin",
            //             "canDeposit": true,
            //             "canWithdraw": true,
            //             "canTrade": true,
            //             "notabeneDecimals": 8,
            //             "canMarket": true,
            //             "maxSwap": 10000,
            //             "digits": 6,
            //             "multiplier": 1000000,
            //             "bookDigits": 8,
            //             "bookMultiplier": 100000000,
            //             "sentimentData": {
            //                 "sentiment": 51.59555555555555,
            //                 "interest": 1.127511216044664
            //             },
            //             "minQty": 0.0001
            //         },
            //         {
            //             "symbol": "EUR",
            //             "name": "Euro",
            //             "color": "#1246FF",
            //             "type": "fiat",
            //             "canDeposit": true,
            //             "canWithdraw": true,
            //             "canTrade": true,
            //             "canMarket": true,
            //             "maxSwap": 10000,
            //             "digits": 2,
            //             "multiplier": 100,
            //             "bookDigits": 3,
            //             "bookMultiplier": 1000,
            //             "minQty": 5
            //         }
            //         ...
            //     ]
            //
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
                var currency interface{} = GetValue(response, i)
                var id interface{} = this.SafeString(currency, "symbol")
                var code interface{} = this.SafeCurrencyCode(id)
                var withdraw interface{} = this.SafeValue(currency, "canWithdraw")
                var deposit interface{} = this.SafeValue(currency, "canDeposit")
                var canTrade interface{} = this.SafeValue(currency, "canTrade")
                var active interface{} = Ternary(IsTrue(canTrade), withdraw, true)
                var minAmount interface{} = this.SafeNumber(currency, "minQty")
                AddElementToObject(result, code, this.SafeCurrencyStructure(map[string]interface{} {
            "id": id,
            "code": code,
            "name": code,
            "info": currency,
            "active": active,
            "deposit": deposit,
            "withdraw": withdraw,
            "fee": nil,
            "precision": this.ParseNumber(this.ParsePrecision(this.SafeString(currency, "digits"))),
            "limits": map[string]interface{} {
                "amount": map[string]interface{} {
                    "min": minAmount,
                    "max": nil,
                },
                "withdraw": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
            },
            "networks": map[string]interface{} {},
        }))
            }
            if IsTrue(IsEqual(this.SafeValue(this.Options, "currenciesByIdForParseMarket"), nil)) {
                var currenciesById interface{} = this.IndexBy(result, "id")
                AddElementToObject(this.Options, "currenciesByIdForParseMarket", currenciesById)
                var currentCurrencyIdsList interface{} = this.SafeList(this.Options, "currencyIdsListForParseMarket", []interface{}{})
                var currencyIdsList interface{} = ObjectKeys(currenciesById)
                for i := 0; IsLessThan(i, GetArrayLength(currencyIdsList)); i++ {
                    AppendToArray(&currentCurrencyIdsList,GetValue(currencyIdsList, i))
                }
                AddElementToObject(this.Options, "currencyIdsListForParseMarket", currentCurrencyIdsList)
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinmetro#fetchMarkets
 * @description retrieves data on all markets for coinmetro
 * @see https://documenter.getpostman.com/view/3653795/SVfWN6KS#9fd18008-338e-4863-b07d-722878a46832
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *coinmetro) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetMarkets(params))
            PanicOnError(response)
            if IsTrue(IsEqual(this.SafeValue(this.Options, "currenciesByIdForParseMarket"), nil)) {
        
                retRes42812 := (<-this.FetchCurrencies())
                PanicOnError(retRes42812)
            }
        
                //
            //     [
            //         {
            //             "pair": "YFIEUR",
            //             "precision": 5,
            //             "margin": false
            //         },
            //         {
            //             "pair": "BTCEUR",
            //             "precision": 2,
            //             "margin": true
            //         },
            //         ...
            //     ]
            //
        ch <- this.ParseMarkets(response)
            return nil
        
            }()
            return ch
        }
func  (this *coinmetro) ParseMarket(market interface{}) interface{}  {
    var id interface{} = this.SafeString(market, "pair")
    var parsedMarketId interface{} = this.ParseMarketId(id)
    var baseId interface{} = this.SafeString(parsedMarketId, "baseId")
    var quoteId interface{} = this.SafeString(parsedMarketId, "quoteId")
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    var basePrecisionAndLimits interface{} = this.ParseMarketPrecisionAndLimits(baseId)
    var quotePrecisionAndLimits interface{} = this.ParseMarketPrecisionAndLimits(quoteId)
    var margin interface{} = this.SafeBool(market, "margin", false)
    var tradingFees interface{} = this.SafeValue(this.Fees, "trading", map[string]interface{} {})
    return this.SafeMarketStructure(map[string]interface{} {
        "id": id,
        "symbol": Add(Add(base, "/"), quote),
        "base": base,
        "quote": quote,
        "settle": nil,
        "baseId": baseId,
        "quoteId": quoteId,
        "settleId": nil,
        "type": "spot",
        "spot": true,
        "margin": margin,
        "swap": false,
        "future": false,
        "option": false,
        "active": true,
        "contract": false,
        "linear": nil,
        "inverse": nil,
        "taker": this.SafeNumber(tradingFees, "taker"),
        "maker": this.SafeNumber(tradingFees, "maker"),
        "contractSize": nil,
        "expiry": nil,
        "expiryDatetime": nil,
        "strike": nil,
        "optionType": nil,
        "precision": map[string]interface{} {
            "amount": GetValue(basePrecisionAndLimits, "precision"),
            "price": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "precision"))),
        },
        "limits": map[string]interface{} {
            "leverage": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "amount": map[string]interface{} {
                "min": GetValue(basePrecisionAndLimits, "minLimit"),
                "max": nil,
            },
            "price": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "cost": map[string]interface{} {
                "min": GetValue(quotePrecisionAndLimits, "minLimit"),
                "max": nil,
            },
        },
        "created": nil,
        "info": market,
    })
}
func  (this *coinmetro) ParseMarketId(marketId interface{}) interface{}  {
    var baseId interface{} = nil
    var quoteId interface{} = nil
    var currencyIds interface{} = this.SafeValue(this.Options, "currencyIdsListForParseMarket", []interface{}{})
    // Bubble sort by length (longest first)
    var currencyIdsLength interface{} =     GetArrayLength(currencyIds)
    for i := 0; IsLessThan(i, currencyIdsLength); i++ {
        for j := 0; IsLessThan(j, Subtract(Subtract(currencyIdsLength, i), 1)); j++ {
            var a interface{} = GetValue(currencyIds, j)
            var b interface{} = GetValue(currencyIds, Add(j, 1))
            if IsTrue(IsLessThan(GetArrayLength(a), GetArrayLength(b))) {
                AddElementToObject(currencyIds, j, b)
                AddElementToObject(currencyIds, Add(j, 1), a)
            }
        }
    }
    for i := 0; IsLessThan(i, GetArrayLength(currencyIds)); i++ {
        var currencyId interface{} = GetValue(currencyIds, i)
        var entryIndex interface{} = GetIndexOf(marketId, currencyId)
        if IsTrue(IsEqual(entryIndex, 0)) {
            var restId interface{} = Replace(marketId, currencyId, "")
            if IsTrue(this.InArray(restId, currencyIds)) {
                if IsTrue(IsEqual(entryIndex, 0)) {
                    baseId = currencyId
                    quoteId = restId
                } else {
                    baseId = restId
                    quoteId = currencyId
                }
                break
            }
        }
    }
    var result interface{} = map[string]interface{} {
        "baseId": baseId,
        "quoteId": quoteId,
    }
    return result
}
func  (this *coinmetro) ParseMarketPrecisionAndLimits(currencyId interface{}) interface{}  {
    var currencies interface{} = this.SafeValue(this.Options, "currenciesByIdForParseMarket", map[string]interface{} {})
    var currency interface{} = this.SafeValue(currencies, currencyId, map[string]interface{} {})
    var limits interface{} = this.SafeValue(currency, "limits", map[string]interface{} {})
    var amountLimits interface{} = this.SafeValue(limits, "amount", map[string]interface{} {})
    var minLimit interface{} = this.SafeNumber(amountLimits, "min")
    var result interface{} = map[string]interface{} {
        "precision": this.SafeNumber(currency, "precision"),
        "minLimit": minLimit,
    }
    return result
}
/**
 * @method
 * @name coinmetro#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://documenter.getpostman.com/view/3653795/SVfWN6KS#13cfb5bc-7bfb-4847-85e1-e0f35dfb3573
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch entries for
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *coinmetro) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes5798 := (<-this.LoadMarkets())
            PanicOnError(retRes5798)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "pair": GetValue(market, "id"),
                "timeframe": this.SafeString(this.Timeframes, timeframe, timeframe),
            }
            var until interface{} = nil
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "from", since)
                if IsTrue(!IsEqual(limit, nil)) {
                    var duration interface{} = Multiply(this.ParseTimeframe(timeframe), 1000)
                    until = this.Sum(since, Multiply(duration, (limit)))
                }
            } else {
                AddElementToObject(request, "from", ":from") // this endpoint doesn't accept empty from and to params (setting them into the value described in the documentation)
            }
            until = this.SafeInteger(params, "until", until)
            if IsTrue(!IsEqual(until, nil)) {
                params = this.Omit(params, []interface{}{"until"})
                AddElementToObject(request, "to", until)
            } else {
                AddElementToObject(request, "to", ":to")
            }
        
            response:= (<-this.PublicGetExchangeCandlesPairTimeframeFromTo(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "candleHistory": [
            //             {
            //                 "pair": "ETHUSDT",
            //                 "timeframe": 86400000,
            //                 "timestamp": 1697673600000,
            //                 "c": 1567.4409353098604,
            //                 "h": 1566.7514068472303,
            //                 "l": 1549.4563666936847,
            //                 "o": 1563.4490341395904,
            //                 "v": 0
            //             },
            //             {
            //                 "pair": "ETHUSDT",
            //                 "timeframe": 86400000,
            //                 "timestamp": 1697760000000,
            //                 "c": 1603.7831363339324,
            //                 "h": 1625.0356823666407,
            //                 "l": 1565.4629390011505,
            //                 "o": 1566.8387619426028,
            //                 "v": 0
            //             },
            //             ...
            //         ]
            //     }
            //
            var candleHistory interface{} = this.SafeList(response, "candleHistory", []interface{}{})
        
            ch <- this.ParseOHLCVs(candleHistory, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *coinmetro) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.SafeInteger(ohlcv, "timestamp"), this.SafeNumber(ohlcv, "o"), this.SafeNumber(ohlcv, "h"), this.SafeNumber(ohlcv, "l"), this.SafeNumber(ohlcv, "c"), this.SafeNumber(ohlcv, "v")}
}
/**
 * @method
 * @name coinmetro#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://documenter.getpostman.com/view/3653795/SVfWN6KS#6ee5d698-06da-4570-8c84-914185e05065
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch (default 200, max 500)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *coinmetro) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes6578 := (<-this.LoadMarkets())
            PanicOnError(retRes6578)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "pair": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "from", since)
            } else {
                // this endpoint accepts empty from param
                AddElementToObject(request, "from", "")
            }
        
            response:= (<-this.PublicGetExchangeTicksPairFrom(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "tickHistory": [
            //             {
            //                 "pair": "ETHUSDT",
            //                 "price": 2077.5623,
            //                 "qty": 0.002888,
            //                 "timestamp": 1700684689420,
            //                 "seqNum": 10644554718
            //             },
            //             {
            //                 "pair": "ETHUSDT",
            //                 "price": 2078.3848,
            //                 "qty": 0.003368,
            //                 "timestamp": 1700684738410,
            //                 "seqNum": 10644559561
            //             },
            //             {
            //                 "pair": "ETHUSDT",
            //                 "price": 2077.1513,
            //                 "qty": 0.00337,
            //                 "timestamp": 1700684816853,
            //                 "seqNum": 10644567113
            //             },
            //             ...
            //         ]
            //     }
            //
            var tickHistory interface{} = this.SafeList(response, "tickHistory", []interface{}{})
        
            ch <- this.ParseTrades(tickHistory, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinmetro#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://documenter.getpostman.com/view/3653795/SVfWN6KS#4d48ae69-8ee2-44d1-a268-71f84e557b7b
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve (default 500, max 1000)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *coinmetro) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes7138 := (<-this.LoadMarkets())
            PanicOnError(retRes7138)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "since", since)
            } else {
                // the exchange requires a value for the since param
                AddElementToObject(request, "since", 0)
            }
        
            response:= (<-this.PrivateGetExchangeFillsSince(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "pair": "ETHUSDC",
            //             "seqNumber": 10873722343,
            //             "timestamp": 1702570610747,
            //             "qty": 0.002,
            //             "price": 2282,
            //             "side": "buy",
            //             "orderID": "65671262d93d9525ac009e36170257061073952c6423a8c5b4d6c"
            //         },
            //         ...
            //     ]
            //
        ch <- this.ParseTrades(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *coinmetro) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTrades
    //     {
    //         "pair": "ETHUSDT",
    //         "price": 2077.1513,
    //         "qty": 0.00337,
    //         "timestamp": 1700684816853,
    //         "seqNum": 10644567113
    //     },
    //
    // fetchMyTrades
    //     {
    //         "pair": "ETHUSDC",
    //         "seqNumber": 10873722343,
    //         "timestamp": 1702570610747,
    //         "qty": 0.002,
    //         "price": 2282,
    //         "side": "buy",
    //         "orderID": "65671262d93d9525ac009e36170257061073952c6423a8c5b4d6c"
    //     }
    //
    // fetchOrders
    //     {
    //         "_id": "657b31d360a9542449381bdc",
    //         "seqNumber": 10873722343,
    //         "timestamp": 1702570610747,
    //         "qty": 0.002,
    //         "price": 2282,
    //         "side": "buy"
    //     }
    //
    //    {
    //        "pair":"ETHUSDC",
    //        "seqNumber":"10873722343",
    //        "timestamp":"1702570610747",
    //        "qty":"0.002",
    //        "price":"2282",
    //        "side":"buy",
    //        "orderID":"65671262d93d9525ac009e36170257061073952c6423a8c5b4d6c",
    //        "userID":"65671262d93d9525ac009e36"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString2(trade, "symbol", "pair")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = GetValue(market, "symbol")
    var id interface{} = this.SafeStringN(trade, []interface{}{"_id", "seqNum", "seqNumber"})
    var timestamp interface{} = this.SafeInteger(trade, "timestamp")
    var priceString interface{} = this.SafeString(trade, "price")
    var amountString interface{} = this.SafeString(trade, "qty")
    var order interface{} = this.SafeString(trade, "orderID")
    var side interface{} = this.SafeString(trade, "side")
    return this.SafeTrade(map[string]interface{} {
        "id": id,
        "order": order,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "type": nil,
        "side": side,
        "takerOrMaker": nil,
        "price": priceString,
        "amount": amountString,
        "cost": nil,
        "fee": nil,
        "info": trade,
    }, market)
}
/**
 * @method
 * @name coinmetro#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://documenter.getpostman.com/view/3653795/SVfWN6KS#26ad80d7-8c46-41b5-9208-386f439a8b87
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return (default 100, max 200)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *coinmetro) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes8238 := (<-this.LoadMarkets())
            PanicOnError(retRes8238)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "pair": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetExchangeBookPair(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "book": {
            //             "pair": "ETHUSDT",
            //             "seqNumber": 10800409239,
            //             "ask": {
            //                 "2354.2861": 3.75,
            //                 "2354.3138": 19,
            //                 "2354.7538": 80,
            //                 "2355.5430": 260,
            //                 "2356.4611": 950,
            //                 "2361.7150": 1500,
            //                 "206194.0000": 0.01
            //             },
            //             "bid": {
            //                 "2352.6339": 3.75,
            //                 "2352.6002": 19,
            //                 "2352.2402": 80,
            //                 "2351.4582": 260,
            //                 "2349.3111": 950,
            //                 "2343.8601": 1500,
            //                 "1.0000": 5
            //             },
            //             "checksum": 2108177337
            //         }
            //     }
            //
            var book interface{} = this.SafeValue(response, "book", map[string]interface{} {})
            var rawBids interface{} = this.SafeValue(book, "bid", map[string]interface{} {})
            var rawAsks interface{} = this.SafeValue(book, "ask", map[string]interface{} {})
            var rawOrderbook interface{} = map[string]interface{} {
                "bids": rawBids,
                "asks": rawAsks,
            }
            var orderbook interface{} = this.ParseOrderBook(rawOrderbook, symbol)
            AddElementToObject(orderbook, "nonce", this.SafeInteger(book, "seqNumber"))
        
            ch <- orderbook
            return nil
        
            }()
            return ch
        }
func  (this *coinmetro) ParseBidsAsks(bidasks interface{}, optionalArgs ...interface{}) interface{}  {
    priceKey := GetArg(optionalArgs, 0, 0)
    _ = priceKey
    amountKey := GetArg(optionalArgs, 1, 1)
    _ = amountKey
    countOrIdKey := GetArg(optionalArgs, 2, 2)
    _ = countOrIdKey
    var prices interface{} = ObjectKeys(bidasks)
    var result interface{} = []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(prices)); i++ {
        var priceString interface{} = this.SafeString(prices, i)
        var price interface{} = this.SafeNumber(prices, i)
        var volume interface{} = this.SafeNumber(bidasks, priceString)
        AppendToArray(&result,[]interface{}{price, volume})
    }
    return result
}
/**
 * @method
 * @name coinmetro#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://documenter.getpostman.com/view/3653795/SVfWN6KS#6ecd1cd1-f162-45a3-8b3b-de690332a485
 * @param {string[]} [symbols] unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *coinmetro) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes8908 := (<-this.LoadMarkets())
            PanicOnError(retRes8908)
        
            response:= (<-this.PublicGetExchangePrices(params))
            PanicOnError(response)
            //
            //     {
            //         "latestPrices": [
            //             {
            //                 "pair": "PERPEUR",
            //                 "timestamp": 1702549840393,
            //                 "price": 0.7899997816001223,
            //                 "qty": 1e-12,
            //                 "ask": 0.8,
            //                 "bid": 0.7799995632002446
            //             },
            //             {
            //                 "pair": "PERPUSD",
            //                 "timestamp": 1702549841973,
            //                 "price": 0.8615317721366659,
            //                 "qty": 1e-12,
            //                 "ask": 0.8742333599999257,
            //                 "bid": 0.8490376365388491
            //             },
            //             ...
            //         ],
            //         "24hInfo": [
            //             {
            //                 "delta": 0.25396444229149906,
            //                 "h": 0.78999978160012,
            //                 "l": 0.630001740844,
            //                 "v": 54.910000002833996,
            //                 "pair": "PERPEUR",
            //                 "sentimentData": {
            //                     "sentiment": 36.71333333333333,
            //                     "interest": 0.47430830039525695
            //                     }
            //                 },
            //             {
            //                 "delta": 0.26915154078134096,
            //                 "h": 0.86220315458898,
            //                 "l": 0.67866757035154,
            //                 "v": 2.835000000000001e-9,
            //                 "pair": "PERPUSD",
            //                 "sentimentData": {
            //                     "sentiment": 36.71333333333333,
            //                     "interest": 0.47430830039525695
            //                 }
            //             },
            //             ...
            //         ]
            //     }
            //
            var latestPrices interface{} = this.SafeValue(response, "latestPrices", []interface{}{})
            var twentyFourHInfos interface{} = this.SafeValue(response, "24hInfo", []interface{}{})
            var tickersObject interface{} = map[string]interface{} {}
            // merging info from two lists into one
            for i := 0; IsLessThan(i, GetArrayLength(latestPrices)); i++ {
                var latestPrice interface{} = GetValue(latestPrices, i)
                var marketId interface{} = this.SafeString(latestPrice, "pair")
                if IsTrue(!IsEqual(marketId, nil)) {
                    AddElementToObject(tickersObject, marketId, latestPrice)
                }
            }
            for i := 0; IsLessThan(i, GetArrayLength(twentyFourHInfos)); i++ {
                var twentyFourHInfo interface{} = GetValue(twentyFourHInfos, i)
                var marketId interface{} = this.SafeString(twentyFourHInfo, "pair")
                if IsTrue(!IsEqual(marketId, nil)) {
                    var latestPrice interface{} = this.SafeValue(tickersObject, marketId, map[string]interface{} {})
                    AddElementToObject(tickersObject, marketId, this.Extend(twentyFourHInfo, latestPrice))
                }
            }
            var tickers interface{} = ObjectValues(tickersObject)
        
            ch <- this.ParseTickers(tickers, symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinmetro#fetchBidsAsks
 * @description fetches the bid and ask price and volume for multiple markets
 * @see https://documenter.getpostman.com/view/3653795/SVfWN6KS#6ecd1cd1-f162-45a3-8b3b-de690332a485
 * @param {string[]} [symbols] unified symbols of the markets to fetch the bids and asks for, all markets are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *coinmetro) FetchBidsAsks(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes9738 := (<-this.LoadMarkets())
            PanicOnError(retRes9738)
        
            response:= (<-this.PublicGetExchangePrices(params))
            PanicOnError(response)
            var latestPrices interface{} = this.SafeList(response, "latestPrices", []interface{}{})
        
            ch <- this.ParseTickers(latestPrices, symbols)
            return nil
        
            }()
            return ch
        }
func  (this *coinmetro) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "pair": "PERPUSD",
    //         "timestamp": 1702549841973,
    //         "price": 0.8615317721366659,
    //         "qty": 1e-12,
    //         "ask": 0.8742333599999257,
    //         "bid": 0.8490376365388491
    //         "delta": 0.26915154078134096,
    //         "h": 0.86220315458898,
    //         "l": 0.67866757035154,
    //         "v": 2.835000000000001e-9,
    //         "sentimentData": {
    //             "sentiment": 36.71333333333333,
    //             "interest": 0.47430830039525695
    //         }
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(ticker, "pair")
    market = this.SafeMarket(marketId, market)
    var timestamp interface{} = this.SafeInteger(ticker, "timestamp")
    var bid interface{} = this.SafeString(ticker, "bid")
    var ask interface{} = this.SafeString(ticker, "ask")
    var high interface{} = this.SafeString(ticker, "h")
    var low interface{} = this.SafeString(ticker, "l")
    var last interface{} = this.SafeString(ticker, "price")
    var baseVolume interface{} = this.SafeString(ticker, "v")
    var delta interface{} = this.SafeString(ticker, "delta")
    var percentage interface{} = Precise.StringMul(delta, "100")
    return this.SafeTicker(map[string]interface{} {
        "symbol": GetValue(market, "symbol"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "open": nil,
        "high": high,
        "low": low,
        "close": nil,
        "last": last,
        "bid": bid,
        "bidVolume": nil,
        "ask": ask,
        "askVolume": nil,
        "vwap": nil,
        "previousClose": nil,
        "change": nil,
        "percentage": percentage,
        "average": nil,
        "baseVolume": baseVolume,
        "quoteVolume": nil,
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name coinmetro#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://documenter.getpostman.com/view/3653795/SVfWN6KS#741a1dcc-7307-40d0-acca-28d003d1506a
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *coinmetro) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes10428 := (<-this.LoadMarkets())
            PanicOnError(retRes10428)
        
            response:= (<-this.PrivateGetUsersWallets(params))
            PanicOnError(response)
            var list interface{} = this.SafeList(response, "list", []interface{}{})
        
            ch <- this.ParseBalance(list)
            return nil
        
            }()
            return ch
        }
func  (this *coinmetro) ParseBalance(balances interface{}) interface{}  {
    //
    //     [
    //         {
    //             "xcmLocks": [],
    //             "xcmLockAmounts": [],
    //             "refList": [],
    //             "balanceHistory": [],
    //             "_id": "5fecd3c998e75c2e4d63f7c3",
    //             "currency": "BTC",
    //             "label": "BTC",
    //             "userId": "5fecd3c97fbfed1521db23bd",
    //             "__v": 0,
    //             "balance": 0.5,
    //             "createdAt": "2020-12-30T19:23:53.646Z",
    //             "disabled": false,
    //             "updatedAt": "2020-12-30T19:23:53.653Z",
    //             "reserved": 0,
    //             "id": "5fecd3c998e75c2e4d63f7c3"
    //         },
    //         ...
    //     ]
    //
    var result interface{} = map[string]interface{} {
        "info": balances,
    }
    for i := 0; IsLessThan(i, GetArrayLength(balances)); i++ {
        var balanceEntry interface{} = this.SafeDict(balances, i, map[string]interface{} {})
        var currencyId interface{} = this.SafeString(balanceEntry, "currency")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        AddElementToObject(account, "total", this.SafeString(balanceEntry, "balance"))
        AddElementToObject(account, "used", this.SafeString(balanceEntry, "reserved"))
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name coinmetro#fetchLedger
 * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
 * @see https://documenter.getpostman.com/view/3653795/SVfWN6KS#4e7831f7-a0e7-4c3e-9336-1d0e5dcb15cf
 * @param {string} [code] unified currency code, default is undefined
 * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
 * @param {int} [limit] max number of ledger entries to return (default 200, max 500)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch entries for
 * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger}
 */
func  (this *coinmetro) FetchLedger(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes10998 := (<-this.LoadMarkets())
            PanicOnError(retRes10998)
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "since", since)
            } else {
                // this endpoint accepts empty since param
                AddElementToObject(request, "since", "")
            }
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
            }
        
            response:= (<-this.PrivateGetUsersWalletsHistorySince(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "list": [
            //             {
            //                 "currency": "USDC",
            //                 "label": "USDC",
            //                 "userId": "65671262d93d9525ac009e36",
            //                 "balance": 0,
            //                 "disabled": false,
            //                 "balanceHistory": [
            //                     {
            //                         "description": "Deposit - 657973a9b6eadf0f33d70100",
            //                         "JSONdata": {
            //                             "fees": 0,
            //                             "notes": "Via Crypto",
            //                             "txHash": "0x2e4875185b0f312d8e24b2d26d46bf9877db798b608ad2ff97b2b8bc7d8134e5",
            //                             "last4Digits": null,
            //                             "IBAN": null,
            //                             "alternativeChain": "polygon",
            //                             "referenceId": "657973a9b6eadf0f33d70100",
            //                             "status": "completed",
            //                             "tracked": true
            //                         },
            //                         "amount": 99,
            //                         "timestamp": "2023-12-13T09:04:51.270Z",
            //                         "amountEUR": 91.79310117335974
            //                     },
            //                     {
            //                         "description": "Order 65671262d93d9525ac009e36170257061073952c6423a8c5b4d6c SeqNum 10873722342",
            //                         "JSONdata": {
            //                             "price": "2282.00 ETH/USDC",
            //                             "fees": 0,
            //                             "notes": "Order 3a8c5b4d6c"
            //                         },
            //                         "amount": -4.564,
            //                         "timestamp": "2023-12-14T16:16:50.760Z",
            //                         "amountEUR": -4.150043849187587
            //                     },
            //                     ...
            //                 ]
            //             },
            //             {
            //                 "currency": "ETH",
            //                 "label": "ETH",
            //                 "userId": "65671262d93d9525ac009e36",
            //                 "balance": 0,
            //                 "disabled": false,
            //                 "balanceHistory": [
            //                     {
            //                         "description": "Order 65671262d93d9525ac009e36170257061073952c6423a8c5b4d6c SeqNum 10873722342",
            //                         "JSONdata": {
            //                             "price": "2282.00 ETH/USDC",
            //                             "fees": 0.000002,
            //                             "notes": "Order 3a8c5b4d6c"
            //                         },
            //                         "amount": 0.001998,
            //                         "timestamp": "2023-12-14T16:16:50.761Z",
            //                         "amountEUR": 4.144849415806856
            //                     },
            //                     ...
            //                 ]
            //             },
            //             {
            //                 "currency": "DOGE",
            //                 "label": "DOGE",
            //                 "userId": "65671262d93d9525ac009e36",
            //                 "balance": 0,
            //                 "disabled": false,
            //                 "balanceHistory": [
            //                     {
            //                         "description": "Order 65671262d93d9525ac009e361702905785319b5d9016dc20736034d13ca6a - Swap",
            //                         "JSONdata": {
            //                             "swap": true,
            //                             "subtype": "swap",
            //                             "fees": 0,
            //                             "price": "0.0905469 DOGE/USDC",
            //                             "notes": "Swap 034d13ca6a"
            //                         },
            //                         "amount": 70,
            //                         "timestamp": "2023-12-18T13:23:05.836Z",
            //                         "amountEUR": 5.643627624549227
            //                     }
            //                 ]
            //             },
            //             ...
            //         ]
            //     }
            //
            var ledgerByCurrencies interface{} = this.SafeValue(response, "list", []interface{}{})
            var ledger interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(ledgerByCurrencies)); i++ {
                var currencyLedger interface{} = GetValue(ledgerByCurrencies, i)
                var currencyId interface{} = this.SafeString(currencyLedger, "currency")
                var balanceHistory interface{} = this.SafeValue(currencyLedger, "balanceHistory", []interface{}{})
                for j := 0; IsLessThan(j, GetArrayLength(balanceHistory)); j++ {
                    var rawLedgerEntry interface{} = GetValue(balanceHistory, j)
                    AddElementToObject(rawLedgerEntry, "currencyId", currencyId)
                    AppendToArray(&ledger,rawLedgerEntry)
                }
            }
        
            ch <- this.ParseLedger(ledger, currency, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *coinmetro) ParseLedgerEntry(item interface{}, optionalArgs ...interface{}) interface{}  {
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var datetime interface{} = this.SafeString(item, "timestamp")
    var currencyId interface{} = this.SafeString(item, "currencyId")
    item = this.Omit(item, "currencyId")
    currency = this.SafeCurrency(currencyId, currency)
    var description interface{} = this.SafeString(item, "description", "")
    typeVarreferenceIdVariable := this.ParseLedgerEntryDescription(description);
    typeVar := GetValue(typeVarreferenceIdVariable,0);
    referenceId := GetValue(typeVarreferenceIdVariable,1)
    var JSONdata interface{} = this.SafeValue(item, "JSONdata", map[string]interface{} {})
    var feeCost interface{} = this.SafeString(JSONdata, "fees")
    var fee interface{} = map[string]interface{} {
        "cost": feeCost,
        "currency": nil,
    }
    var amount interface{} = this.SafeString(item, "amount")
    var direction interface{} = nil
    if IsTrue(!IsEqual(amount, nil)) {
        if IsTrue(Precise.StringLt(amount, "0")) {
            direction = "out"
            amount = Precise.StringAbs(amount)
        } else if IsTrue(Precise.StringGt(amount, "0")) {
            direction = "in"
        }
    }
    return this.SafeLedgerEntry(map[string]interface{} {
        "info": item,
        "id": nil,
        "timestamp": this.Parse8601(datetime),
        "datetime": datetime,
        "direction": direction,
        "account": nil,
        "referenceId": referenceId,
        "referenceAccount": nil,
        "type": typeVar,
        "currency": currency,
        "amount": amount,
        "before": nil,
        "after": nil,
        "status": nil,
        "fee": fee,
    }, currency)
}
func  (this *coinmetro) ParseLedgerEntryDescription(description interface{}) interface{}  {
    var descriptionArray interface{} = []interface{}{}
    if IsTrue(!IsEqual(description, nil)) {
        descriptionArray = Split(description, " ")
    }
    var typeVar interface{} = nil
    var referenceId interface{} = nil
    var length interface{} =     GetArrayLength(descriptionArray)
    if IsTrue(IsGreaterThan(length, 1)) {
        typeVar = this.ParseLedgerEntryType(GetValue(descriptionArray, 0))
        if IsTrue(!IsEqual(GetValue(descriptionArray, 1), "-")) {
            referenceId = GetValue(descriptionArray, 1)
        } else {
            referenceId = this.SafeString(descriptionArray, 2)
        }
    }
    return []interface{}{typeVar, referenceId}
}
func  (this *coinmetro) ParseLedgerEntryType(typeVar interface{}) interface{}  {
    var types interface{} = map[string]interface{} {
        "Deposit": "transaction",
        "Withdraw": "transaction",
        "Order": "trade",
    }
    return this.SafeString(types, typeVar, typeVar)
}
/**
 * @method
 * @name coinmetro#createOrder
 * @description create a trade order
 * @see https://documenter.getpostman.com/view/3653795/SVfWN6KS#a4895a1d-3f50-40ae-8231-6962ef06c771
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {float} [params.cost] the quote quantity that can be used as an alternative for the amount in market orders
 * @param {string} [params.timeInForce] "GTC", "IOC", "FOK", "GTD"
 * @param {number} [params.expirationTime] timestamp in millisecond, for GTD orders only
 * @param {float} [params.triggerPrice] the price at which a trigger order is triggered at
 * @param {float} [params.stopLossPrice] *margin only* The price at which a stop loss order is triggered at
 * @param {float} [params.takeProfitPrice] *margin only* The price at which a take profit order is triggered at
 * @param {bool} [params.margin] true for creating a margin order
 * @param {string} [params.fillStyle] fill style of the limit order: "sell" fulfills selling quantity "buy" fulfills buying quantity "base" fulfills base currency quantity "quote" fulfills quote currency quantity
 * @param {string} [params.clientOrderId] client's comment
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinmetro) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes13088 := (<-this.LoadMarkets())
            PanicOnError(retRes13088)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {}
            AddElementToObject(request, "orderType", typeVar)
            var formattedAmount interface{} = nil
            if IsTrue(!IsEqual(amount, nil)) {
                formattedAmount = this.AmountToPrecision(symbol, amount)
            }
            var cost interface{} = this.SafeValue(params, "cost")
            params = this.Omit(params, "cost")
            if IsTrue(IsEqual(typeVar, "limit")) {
                if IsTrue(IsTrue((IsEqual(price, nil))) && IsTrue((IsEqual(cost, nil)))) {
                    panic(ArgumentsRequired(Add(Add(Add(this.Id, " createOrder() requires a price or params.cost argument for a "), typeVar), " order")))
                } else if IsTrue(IsTrue((!IsEqual(price, nil))) && IsTrue((!IsEqual(amount, nil)))) {
                    var costString interface{} = Precise.StringMul(this.NumberToString(price), this.NumberToString(formattedAmount))
                    cost = this.ParseToNumeric(costString)
                }
            }
            var precisedCost interface{} = nil
            if IsTrue(!IsEqual(cost, nil)) {
                precisedCost = this.CostToPrecision(symbol, cost)
            }
            if IsTrue(IsEqual(side, "sell")) {
                request = this.HandleCreateOrderSide(GetValue(market, "baseId"), GetValue(market, "quoteId"), formattedAmount, precisedCost, request)
            } else if IsTrue(IsEqual(side, "buy")) {
                request = this.HandleCreateOrderSide(GetValue(market, "quoteId"), GetValue(market, "baseId"), precisedCost, formattedAmount, request)
            }
            var timeInForce interface{} = this.SafeValue(params, "timeInForce")
            if IsTrue(!IsEqual(timeInForce, nil)) {
                params = this.Omit(params, "timeInForce")
                AddElementToObject(request, "timeInForce", this.EncodeOrderTimeInForce(timeInForce))
            }
            var triggerPrice interface{} = this.SafeString2(params, "triggerPrice", "stopPrice")
            if IsTrue(!IsEqual(triggerPrice, nil)) {
                params = this.Omit(params, []interface{}{"triggerPrice"})
                AddElementToObject(request, "stopPrice", this.PriceToPrecision(symbol, triggerPrice))
            }
            var userData interface{} = this.SafeValue(params, "userData", map[string]interface{} {})
            var comment interface{} = this.SafeString2(params, "clientOrderId", "comment")
            if IsTrue(!IsEqual(comment, nil)) {
                params = this.Omit(params, []interface{}{"clientOrderId"})
                AddElementToObject(userData, "comment", comment)
            }
            var stopLossPrice interface{} = this.SafeString(params, "stopLossPrice")
            if IsTrue(!IsEqual(stopLossPrice, nil)) {
                params = this.Omit(params, "stopLossPrice")
                AddElementToObject(userData, "stopLoss", this.PriceToPrecision(symbol, stopLossPrice))
            }
            var takeProfitPrice interface{} = this.SafeString(params, "takeProfitPrice")
            if IsTrue(!IsEqual(takeProfitPrice, nil)) {
                params = this.Omit(params, "takeProfitPrice")
                AddElementToObject(userData, "takeProfit", this.PriceToPrecision(symbol, takeProfitPrice))
            }
            if !IsTrue(this.IsEmpty(userData)) {
                AddElementToObject(request, "userData", userData)
            }
        
            response:= (<-this.PrivatePostExchangeOrdersCreate(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "userID": "65671262d93d9525ac009e36",
            //         "orderID": "65671262d93d9525ac009e36170257448481749b7ee2893bafec2",
            //         "orderType": "market",
            //         "buyingCurrency": "ETH",
            //         "sellingCurrency": "USDC",
            //         "buyingQty": 0.002,
            //         "timeInForce": 4,
            //         "boughtQty": 0.002,
            //         "soldQty": 4.587,
            //         "creationTime": 1702574484829,
            //         "seqNumber": 10874285330,
            //         "firstFillTime": 1702574484831,
            //         "lastFillTime": 1702574484831,
            //         "fills": [
            //             {
            //                 "seqNumber": 10874285329,
            //                 "timestamp": 1702574484831,
            //                 "qty": 0.002,
            //                 "price": 2293.5,
            //                 "side": "buy"
            //             }
            //         ],
            //         "completionTime": 1702574484831,
            //         "takerQty": 0.002
            //     }
            //
        ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
func  (this *coinmetro) HandleCreateOrderSide(sellingCurrency interface{}, buyingCurrency interface{}, sellingQty interface{}, buyingQty interface{}, optionalArgs ...interface{}) interface{}  {
    request := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = request
    AddElementToObject(request, "sellingCurrency", sellingCurrency)
    AddElementToObject(request, "buyingCurrency", buyingCurrency)
    if IsTrue(!IsEqual(sellingQty, nil)) {
        AddElementToObject(request, "sellingQty", sellingQty)
    }
    if IsTrue(!IsEqual(buyingQty, nil)) {
        AddElementToObject(request, "buyingQty", buyingQty)
    }
    return request
}
func  (this *coinmetro) EncodeOrderTimeInForce(timeInForce interface{}) interface{}  {
    var timeInForceTypes interface{} = map[string]interface{} {
        "GTC": 1,
        "IOC": 2,
        "GTD": 3,
        "FOK": 4,
    }
    return this.SafeValue(timeInForceTypes, timeInForce, timeInForce)
}
/**
 * @method
 * @name coinmetro#cancelOrder
 * @description cancels an open order
 * @see https://documenter.getpostman.com/view/3653795/SVfWN6KS#eaea86da-16ca-4c56-9f00-5b1cb2ad89f8
 * @see https://documenter.getpostman.com/view/3653795/SVfWN6KS#47f913fb-8cab-49f4-bc78-d980e6ced316
 * @param {string} id order id
 * @param {string} symbol not used by coinmetro cancelOrder ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.margin] true for cancelling a margin order
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinmetro) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes14328 := (<-this.LoadMarkets())
            PanicOnError(retRes14328)
            var request interface{} = map[string]interface{} {
                "orderID": id,
            }
            var marginMode interface{} = nil
            paramsparamsVariable := this.HandleMarginModeAndParams("cancelOrder", params);
            params = GetValue(paramsparamsVariable,0);
            params = GetValue(paramsparamsVariable,1)
            var isMargin interface{} = this.SafeBool(params, "margin", false)
            params = this.Omit(params, "margin")
            var response interface{} = nil
            if IsTrue(IsTrue(isMargin) || IsTrue((!IsEqual(marginMode, nil)))) {
                
        response = (<-this.PrivatePostExchangeOrdersCloseOrderID(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PrivatePutExchangeOrdersCancelOrderID(this.Extend(request, params)))
                PanicOnError(response)
            }
        
                //
            //     {
            //         "userID": "65671262d93d9525ac009e36",
            //         "orderID": "65671262d93d9525ac009e3617026635256739c996fe17d7cd5d4",
            //         "orderType": "limit",
            //         "buyingCurrency": "ETH",
            //         "sellingCurrency": "USDC",
            //         "fillStyle": "sell",
            //         "orderPlatform": "trade-v3",
            //         "timeInForce": 1,
            //         "buyingQty": 0.005655,
            //         "sellingQty": 11.31,
            //         "boughtQty": 0,
            //         "soldQty": 0,
            //         "creationTime": 1702663525713,
            //         "seqNumber": 10915220048,
            //         "completionTime": 1702928369053
            //     }
            //
        ch <- this.ParseOrder(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinmetro#closePosition
 * @description closes an open position
 * @see https://documenter.getpostman.com/view/3653795/SVfWN6KS#47f913fb-8cab-49f4-bc78-d980e6ced316
 * @param {string} symbol not used by coinmetro closePosition ()
 * @param {string} [side] not used by coinmetro closePosition ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.orderID] order id
 * @param {number} [params.fraction] fraction of order to close, between 0 and 1 (defaults to 1)
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinmetro) ClosePosition(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    side := GetArg(optionalArgs, 0, nil)
            _ = side
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes14818 := (<-this.LoadMarkets())
            PanicOnError(retRes14818)
            var orderId interface{} = this.SafeString(params, "orderId")
            if IsTrue(IsEqual(orderId, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " closePosition() requires a orderId parameter")))
            }
            var request interface{} = map[string]interface{} {
                "orderID": orderId,
            }
        
            response:= (<-this.PrivatePostExchangeOrdersCloseOrderID(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "userID": "65671262d93d9525ac009e36",
            //         "orderID": "65671262d93d9525ac009e3617030152811996e5b352556d3d7d8_CL",
            //         "orderType": "market",
            //         "buyingCurrency": "ETH",
            //         "sellingCurrency": "EUR",
            //         "margin": true,
            //         "buyingQty": 0.03,
            //         "timeInForce": 4,
            //         "boughtQty": 0.03,
            //         "soldQty": 59.375,
            //         "creationTime": 1703015488482,
            //         "seqNumber": 10925321179,
            //         "firstFillTime": 1703015488483,
            //         "lastFillTime": 1703015488483,
            //         "fills": [
            //             {
            //                 "seqNumber": 10925321178,
            //                 "timestamp": 1703015488483,
            //                 "qty": 0.03,
            //                 "price": 1979.1666666666667,
            //                 "side": "buy"
            //             }
            //         ],
            //         "completionTime": 1703015488483,
            //         "takerQty": 0.03
            //     }
            //
        ch <- this.ParseOrder(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinmetro#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://documenter.getpostman.com/view/3653795/SVfWN6KS#518afd7a-4338-439c-a651-d4fdaa964138
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of open order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinmetro) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes15348 := (<-this.LoadMarkets())
            PanicOnError(retRes15348)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
        
            response:= (<-this.PrivateGetExchangeOrdersActive(params))
            PanicOnError(response)
            var orders interface{} = this.ParseOrders(response, market, since, limit)
            for i := 0; IsLessThan(i, GetArrayLength(orders)); i++ {
                var order interface{} = GetValue(orders, i)
                AddElementToObject(order, "status", "open")
            }
        
            ch <- orders
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinmetro#fetchCanceledAndClosedOrders
 * @description fetches information on multiple canceled and closed orders made by the user
 * @see https://documenter.getpostman.com/view/3653795/SVfWN6KS#4d48ae69-8ee2-44d1-a268-71f84e557b7b
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinmetro) FetchCanceledAndClosedOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes15608 := (<-this.LoadMarkets())
            PanicOnError(retRes15608)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "since", since)
            }
        
            response:= (<-this.PrivateGetExchangeOrdersHistorySince(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseOrders(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinmetro#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://documenter.getpostman.com/view/3653795/SVfWN6KS#95bbed87-db1c-47a7-a03e-aa247e91d5a6
 * @param {int|string} id order id
 * @param {string} symbol not used by coinmetro fetchOrder ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinmetro) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes15848 := (<-this.LoadMarkets())
            PanicOnError(retRes15848)
            var request interface{} = map[string]interface{} {
                "orderID": id,
            }
        
            response:= (<-this.PrivateGetExchangeOrdersStatusOrderID(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "_id": "657b4e6d60a954244939ac6f",
            //         "userID": "65671262d93d9525ac009e36",
            //         "orderID": "65671262d93d9525ac009e361702576531985b78465468b9cc544",
            //         "orderType": "market",
            //         "buyingCurrency": "ETH",
            //         "sellingCurrency": "USDC",
            //         "buyingQty": 0.004,
            //         "timeInForce": 4,
            //         "boughtQty": 0.004,
            //         "soldQty": 9.236,
            //         "creationTime": 1702576531995,
            //         "seqNumber": 10874644062,
            //         "firstFillTime": 1702576531995,
            //         "lastFillTime": 1702576531995,
            //         "fills": [
            //             {
            //                 "_id": "657b4e6d60a954244939ac70",
            //                 "seqNumber": 10874644061,
            //                 "timestamp": 1702576531995,
            //                 "qty": 0.004,
            //                 "price": 2309,
            //                 "side": "buy"
            //             }
            //         ],
            //         "completionTime": 1702576531995,
            //         "takerQty": 0.004,
            //         "fees": 0.000004,
            //         "isAncillary": false,
            //         "margin": false,
            //         "trade": false,
            //         "canceled": false
            //     }
            //
        ch <- this.ParseOrder(response)
            return nil
        
            }()
            return ch
        }
func  (this *coinmetro) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // createOrder market
    //     {
    //         "userID": "65671262d93d9525ac009e36",
    //         "orderID": "65671262d93d9525ac009e36170257448481749b7ee2893bafec2",
    //         "orderType": "market",
    //         "buyingCurrency": "ETH",
    //         "sellingCurrency": "USDC",
    //         "buyingQty": 0.002,
    //         "timeInForce": 4,
    //         "boughtQty": 0.002,
    //         "soldQty": 4.587,
    //         "creationTime": 1702574484829,
    //         "seqNumber": 10874285330,
    //         "firstFillTime": 1702574484831,
    //         "lastFillTime": 1702574484831,
    //         "fills": [
    //             {
    //                 "seqNumber": 10874285329,
    //                 "timestamp": 1702574484831,
    //                 "qty": 0.002,
    //                 "price": 2293.5,
    //                 "side": "buy"
    //             }
    //         ],
    //         "completionTime": 1702574484831,
    //         "takerQty": 0.002
    //     }
    //
    // createOrder limit
    //     {
    //         "userID": "65671262d93d9525ac009e36",
    //         "orderID": "65671262d93d9525ac009e3617026635256739c996fe17d7cd5d4",
    //         "orderType": "limit",
    //         "buyingCurrency": "ETH",
    //         "sellingCurrency": "USDC",
    //         "fillStyle": "sell",
    //         "orderPlatform": "trade-v3",
    //         "timeInForce": 1,
    //         "buyingQty": 0.005655,
    //         "sellingQty": 11.31,
    //         "boughtQty": 0,
    //         "soldQty": 0,
    //         "creationTime": 1702663525713,
    //         "seqNumber": 10885528683,
    //         "fees": 0,
    //         "fills": [],
    //         "isAncillary": false,
    //         "margin": false,
    //         "trade": false
    //     }
    //
    // fetchOrders market
    //     {
    //         "userID": "65671262d93d9525ac009e36",
    //         "orderID": "65671262d93d9525ac009e36170257061073952c6423a8c5b4d6c",
    //         "orderType": "market",
    //         "buyingCurrency": "ETH",
    //         "sellingCurrency": "USDC",
    //         "buyingQty": 0.002,
    //         "timeInForce": 4,
    //         "boughtQty": 0.002,
    //         "soldQty": 4.564,
    //         "creationTime": 1702570610746,
    //         "seqNumber": 10873722344,
    //         "firstFillTime": 1702570610747,
    //         "lastFillTime": 1702570610747,
    //         "fills": [
    //             {
    //                 "_id": "657b31d360a9542449381bdc",
    //                 "seqNumber": 10873722343,
    //                 "timestamp": 1702570610747,
    //                 "qty": 0.002,
    //                 "price": 2282,
    //                 "side": "buy"
    //             }
    //         ],
    //         "completionTime": 1702570610747,
    //         "takerQty": 0.002,
    //         "fees": 0.000002,
    //         "isAncillary": false,
    //         "margin": false,
    //         "trade": false,
    //         "canceled": false,
    //         "__v": 0
    //     }
    //
    // fetchOrders margin
    //     {
    //         "userData": {
    //             "takeProfit": 1700,
    //             "stopLoss": 2100
    //         },
    //         "_id": "658201d060a95424499394a2",
    //         "seqNumber": 10925300213,
    //         "orderType": "limit",
    //         "buyingCurrency": "EUR",
    //         "sellingCurrency": "ETH",
    //         "userID": "65671262d93d9525ac009e36",
    //         "closedQty": 0.03,
    //         "sellingQty": 0.03,
    //         "buyingQty": 58.8,
    //         "creationTime": 1703015281205,
    //         "margin": true,
    //         "timeInForce": 1,
    //         "boughtQty": 59.31,
    //         "orderID": "65671262d93d9525ac009e3617030152811996e5b352556d3d7d8",
    //         "lastFillTime": 1703015281206,
    //         "soldQty": 0.03,
    //         "closedTime": 1703015488488,
    //         "closedVal": 59.375,
    //         "trade": true,
    //         "takerQty": 59.31,
    //         "firstFillTime": 1703015281206,
    //         "completionTime": 1703015281206,
    //         "fills": [
    //             {
    //                 "_id": "658201d060a95424499394a3",
    //                 "seqNumber": 10925300212,
    //                 "side": "sell",
    //                 "price": 1977,
    //                 "qty": 0.03,
    //                 "timestamp": 1703015281206
    //             },
    //             {
    //                 "_id": "658201d060a95424499394a4",
    //                 "seqNumber": 10925321178,
    //                 "timestamp": 1703015488483,
    //                 "qty": 0.03,
    //                 "price": 1979.1666666666667,
    //                 "side": "buy"
    //             }
    //         ],
    //         "fees": 0.11875000200000001,
    //         "settledQtys": {
    //             "ETH": -0.000092842104710025
    //         },
    //         "isAncillary": false,
    //         "canceled": false
    //     }
    //
    // fetchOrder
    //     {
    //         "_id": "657b4e6d60a954244939ac6f",
    //         "userID": "65671262d93d9525ac009e36",
    //         "orderID": "65671262d93d9525ac009e361702576531985b78465468b9cc544",
    //         "orderType": "market",
    //         "buyingCurrency": "ETH",
    //         "sellingCurrency": "USDC",
    //         "buyingQty": 0.004,
    //         "timeInForce": 4,
    //         "boughtQty": 0.004,
    //         "soldQty": 9.236,
    //         "creationTime": 1702576531995,
    //         "seqNumber": 10874644062,
    //         "firstFillTime": 1702576531995,
    //         "lastFillTime": 1702576531995,
    //         "fills": [
    //             {
    //                 "_id": "657b4e6d60a954244939ac70",
    //                 "seqNumber": 10874644061,
    //                 "timestamp": 1702576531995,
    //                 "qty": 0.004,
    //                 "price": 2309,
    //                 "side": "buy"
    //             }
    //         ],
    //         "completionTime": 1702576531995,
    //         "takerQty": 0.004,
    //         "fees": 0.000004,
    //         "isAncillary": false,
    //         "margin": false,
    //         "trade": false,
    //         "canceled": false
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger(order, "creationTime")
    var isCanceled interface{} = this.SafeValue(order, "canceled")
    var status interface{} = nil
    if IsTrue(IsEqual(isCanceled, true)) {
        if IsTrue(IsEqual(timestamp, nil)) {
            timestamp = this.SafeInteger(order, "completionTime") // market orders with bad price gain IOC - we mark them as 'rejected'?
            status = "rejected" // these orders don't have the 'creationTime` param and have 'canceled': true
        } else {
            status = "canceled"
        }
    } else {
        status = this.SafeString(order, "status")
        order = this.Omit(order, "status") // we mark orders from fetchOpenOrders with param 'status': 'open'
    }
    var typeVar interface{} = this.SafeString(order, "orderType")
    var buyingQty interface{} = this.SafeString(order, "buyingQty")
    var sellingQty interface{} = this.SafeString(order, "sellingQty")
    var boughtQty interface{} = this.SafeString(order, "boughtQty")
    var soldQty interface{} = this.SafeString(order, "soldQty")
    if IsTrue(IsEqual(typeVar, "market")) {
        if IsTrue(IsTrue(IsTrue((IsEqual(buyingQty, nil))) && IsTrue((!IsEqual(boughtQty, nil)))) && IsTrue((!IsEqual(boughtQty, "0")))) {
            buyingQty = boughtQty
        }
        if IsTrue(IsTrue(IsTrue((IsEqual(sellingQty, nil))) && IsTrue((!IsEqual(soldQty, nil)))) && IsTrue((!IsEqual(soldQty, "0")))) {
            sellingQty = soldQty
        }
    }
    var buyingCurrencyId interface{} = this.SafeString(order, "buyingCurrency", "")
    var sellingCurrencyId interface{} = this.SafeString(order, "sellingCurrency", "")
    var byuingIdPlusSellingId interface{} = Add(buyingCurrencyId, sellingCurrencyId)
    var sellingIdPlusBuyingId interface{} = Add(sellingCurrencyId, buyingCurrencyId)
    var side interface{} = nil
    var marketId interface{} = nil
    var baseAmount interface{} = buyingQty
    var quoteAmount interface{} = buyingQty
    var filled interface{} = nil
    var cost interface{} = nil
    var feeInBaseOrQuote interface{} = nil
    var marketsById interface{} = this.IndexBy(this.Markets, "id")
    if IsTrue(!IsEqual(this.SafeValue(marketsById, byuingIdPlusSellingId), nil)) {
        side = "buy"
        marketId = byuingIdPlusSellingId
        quoteAmount = sellingQty
        filled = boughtQty
        cost = soldQty
        feeInBaseOrQuote = "base"
    } else if IsTrue(!IsEqual(this.SafeValue(marketsById, sellingIdPlusBuyingId), nil)) {
        side = "sell"
        marketId = sellingIdPlusBuyingId
        baseAmount = sellingQty
        filled = soldQty
        cost = boughtQty
        feeInBaseOrQuote = "quote"
    }
    var price interface{} = nil
    if IsTrue(IsTrue((!IsEqual(baseAmount, nil))) && IsTrue((!IsEqual(quoteAmount, nil)))) {
        price = Precise.StringDiv(quoteAmount, baseAmount)
    }
    market = this.SafeMarket(marketId, market)
    var fee interface{} = nil
    var feeCost interface{} = this.SafeString(order, "fees")
    if IsTrue(IsTrue((!IsEqual(feeCost, nil))) && IsTrue((!IsEqual(feeInBaseOrQuote, nil)))) {
        fee = map[string]interface{} {
            "currency": GetValue(market, feeInBaseOrQuote),
            "cost": feeCost,
            "rate": nil,
        }
    }
    var trades interface{} = this.SafeValue(order, "fills", []interface{}{})
    var userData interface{} = this.SafeValue(order, "userData", map[string]interface{} {})
    var clientOrderId interface{} = this.SafeString(userData, "comment")
    var takeProfitPrice interface{} = this.SafeString(userData, "takeProfit")
    var stopLossPrice interface{} = this.SafeString(userData, "stopLoss")
    return this.SafeOrder(map[string]interface{} {
        "id": this.SafeString(order, "orderID"),
        "clientOrderId": clientOrderId,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": this.SafeInteger(order, "lastFillTime"),
        "status": status,
        "symbol": GetValue(market, "symbol"),
        "type": typeVar,
        "timeInForce": this.ParseOrderTimeInForce(this.SafeInteger(order, "timeInForce")),
        "side": side,
        "price": price,
        "triggerPrice": this.SafeString(order, "stopPrice"),
        "takeProfitPrice": takeProfitPrice,
        "stopLossPrice": stopLossPrice,
        "average": nil,
        "amount": baseAmount,
        "cost": cost,
        "filled": filled,
        "remaining": nil,
        "fee": fee,
        "fees": nil,
        "trades": trades,
        "info": order,
    }, market)
}
func  (this *coinmetro) ParseOrderTimeInForce(timeInForce interface{}) interface{}  {
    var timeInForceTypes interface{} = []interface{}{nil, "GTC", "IOC", "GTD", "FOK"}
    return this.SafeValue(timeInForceTypes, timeInForce, timeInForce)
}
/**
 * @method
 * @name coinmetro#borrowCrossMargin
 * @description create a loan to borrow margin
 * @see https://documenter.getpostman.com/view/3653795/SVfWN6KS#5b90b3b9-e5db-4d07-ac9d-d680a06fd110
 * @param {string} code unified currency code of the currency to borrow
 * @param {float} amount the amount to borrow
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
 */
func  (this *coinmetro) BorrowCrossMargin(code interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes19268 := (<-this.LoadMarkets())
            PanicOnError(retRes19268)
            var currency interface{} = this.Currency(code)
            var currencyId interface{} = GetValue(currency, "id")
            var request interface{} = map[string]interface{} {}
            AddElementToObject(request, currencyId, this.CurrencyToPrecision(code, amount))
        
            response:= (<-this.PrivatePutUsersMarginCollateral(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     { "message": "OK" }
            //
            var result interface{} = this.SafeValue(response, "result", map[string]interface{} {})
            var transaction interface{} = this.ParseMarginLoan(result, currency)
        
            ch <- this.Extend(transaction, map[string]interface{} {
                "amount": amount,
            })
            return nil
        
            }()
            return ch
        }
func  (this *coinmetro) ParseMarginLoan(info interface{}, optionalArgs ...interface{}) interface{}  {
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var currencyId interface{} = this.SafeString(info, "coin")
    return map[string]interface{} {
        "id": nil,
        "currency": this.SafeCurrencyCode(currencyId, currency),
        "amount": nil,
        "symbol": nil,
        "timestamp": nil,
        "datetime": nil,
        "info": info,
    }
}
func  (this *coinmetro) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var request interface{} = this.Omit(params, this.ExtractParams(path))
    var endpoint interface{} = Add("/", this.ImplodeParams(path, params))
    var url interface{} = Add(GetValue(GetValue(this.Urls, "api"), api), endpoint)
    var query interface{} = this.Urlencode(request)
    if IsTrue(IsEqual(headers, nil)) {
        headers = map[string]interface{} {}
    }
    AddElementToObject(headers, "CCXT", "true")
    if IsTrue(IsEqual(api, "private")) {
        if IsTrue(IsTrue((IsEqual(this.Uid, nil))) && IsTrue((!IsEqual(this.ApiKey, nil)))) {
            this.Uid = this.ApiKey
        }
        if IsTrue(IsTrue((IsEqual(this.Token, nil))) && IsTrue((!IsEqual(this.Secret, nil)))) {
            this.Token = this.Secret
        }
        if IsTrue(IsEqual(url, "https://api.coinmetro.com/jwt")) {
            AddElementToObject(headers, "X-Device-Id", "bypass")
            if IsTrue(!IsEqual(this.Twofa, nil)) {
                AddElementToObject(headers, "X-OTP", this.Twofa)
            }
        } else if IsTrue(IsEqual(url, "https://api.coinmetro.com/jwtDevice")) {
            AddElementToObject(headers, "X-Device-Id", this.Uid)
            if IsTrue(!IsEqual(this.Twofa, nil)) {
                AddElementToObject(headers, "X-OTP", this.Twofa)
            }
        } else {
            AddElementToObject(headers, "Authorization", Add("Bearer ", this.Token))
            if !IsTrue(StartsWith(url, "https://api.coinmetro.com/open")) {
                this.CheckRequiredCredentials()
                AddElementToObject(headers, "X-Device-Id", this.Uid)
            }
        }
        if IsTrue(IsTrue((IsEqual(method, "POST"))) || IsTrue((IsEqual(method, "PUT")))) {
            AddElementToObject(headers, "Content-Type", "application/x-www-form-urlencoded")
            body = this.Urlencode(request)
        }
    } else if IsTrue(!IsEqual(GetArrayLength(query), 0)) {
        url = Add(url, Add("?", query))
    }
    for EndsWith(url, "/") {
        url = Slice(url, 0, Subtract(GetLength(url), 1))
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *coinmetro) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsEqual(response, nil)) {
        return nil
    }
    if IsTrue(IsTrue(IsTrue((!IsEqual(code, 200))) && IsTrue((!IsEqual(code, 201)))) && IsTrue((!IsEqual(code, 202)))) {
        var feedback interface{} = Add(Add(this.Id, " "), body)
        var message interface{} = this.SafeString(response, "message")
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), message, feedback)
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), message, feedback)
        panic(ExchangeError(feedback))
    }
    return nil
}


func (this *coinmetro) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
