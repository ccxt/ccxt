package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type hitbtc struct {
    Exchange

}

func NewHitbtcCore() hitbtc {
   p := hitbtc{}
   setDefaults(&p)
   return p
}

func  (this *hitbtc) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "hitbtc",
        "name": "HitBTC",
        "countries": []interface{}{"HK"},
        "rateLimit": 3.333,
        "version": "3",
        "has": map[string]interface{} {
            "CORS": false,
            "spot": true,
            "margin": true,
            "swap": true,
            "future": false,
            "option": nil,
            "addMargin": true,
            "cancelAllOrders": true,
            "cancelOrder": true,
            "closePosition": false,
            "createDepositAddress": true,
            "createOrder": true,
            "createPostOnlyOrder": true,
            "createReduceOnlyOrder": true,
            "createStopLimitOrder": true,
            "createStopMarketOrder": true,
            "createStopOrder": true,
            "editOrder": true,
            "fetchAccounts": false,
            "fetchBalance": true,
            "fetchBorrowRateHistories": nil,
            "fetchBorrowRateHistory": nil,
            "fetchClosedOrders": true,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchCurrencies": true,
            "fetchDepositAddress": true,
            "fetchDepositAddresses": false,
            "fetchDepositAddressesByNetwork": false,
            "fetchDeposits": true,
            "fetchDepositsWithdrawals": true,
            "fetchDepositWithdrawFee": "emulated",
            "fetchDepositWithdrawFees": true,
            "fetchFundingHistory": nil,
            "fetchFundingRate": true,
            "fetchFundingRateHistory": true,
            "fetchFundingRates": true,
            "fetchIndexOHLCV": true,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchLeverage": true,
            "fetchLeverageTiers": nil,
            "fetchLiquidations": false,
            "fetchMarginMode": "emulated",
            "fetchMarginModes": true,
            "fetchMarketLeverageTiers": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": true,
            "fetchMyLiquidations": false,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenInterest": true,
            "fetchOpenInterestHistory": false,
            "fetchOpenInterests": true,
            "fetchOpenOrder": true,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrderBooks": true,
            "fetchOrders": false,
            "fetchOrderTrades": true,
            "fetchPosition": true,
            "fetchPositions": true,
            "fetchPremiumIndexOHLCV": true,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTrades": true,
            "fetchTradingFee": true,
            "fetchTradingFees": true,
            "fetchTransactions": "emulated",
            "fetchWithdrawals": true,
            "reduceMargin": true,
            "sandbox": true,
            "setLeverage": true,
            "setMargin": false,
            "setMarginMode": false,
            "setPositionMode": false,
            "transfer": true,
            "withdraw": true,
        },
        "precisionMode": TICK_SIZE,
        "urls": map[string]interface{} {
            "logo": "https://user-images.githubusercontent.com/1294454/27766555-8eaec20e-5edc-11e7-9c5b-6dc69fc42f5e.jpg",
            "test": map[string]interface{} {
                "public": "https://api.demo.hitbtc.com/api/3",
                "private": "https://api.demo.hitbtc.com/api/3",
            },
            "api": map[string]interface{} {
                "public": "https://api.hitbtc.com/api/3",
                "private": "https://api.hitbtc.com/api/3",
            },
            "www": "https://hitbtc.com",
            "referral": "https://hitbtc.com/?ref_id=5a5d39a65d466",
            "doc": []interface{}{"https://api.hitbtc.com", "https://github.com/hitbtc-com/hitbtc-api/blob/master/APIv2.md"},
            "fees": []interface{}{"https://hitbtc.com/fees-and-limits", "https://support.hitbtc.com/hc/en-us/articles/115005148605-Fees-and-limits"},
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": map[string]interface{} {
                    "public/currency": 10,
                    "public/currency/{currency}": 10,
                    "public/symbol": 10,
                    "public/symbol/{symbol}": 10,
                    "public/ticker": 10,
                    "public/ticker/{symbol}": 10,
                    "public/price/rate": 10,
                    "public/price/history": 10,
                    "public/price/ticker": 10,
                    "public/price/ticker/{symbol}": 10,
                    "public/trades": 10,
                    "public/trades/{symbol}": 10,
                    "public/orderbook": 10,
                    "public/orderbook/{symbol}": 10,
                    "public/candles": 10,
                    "public/candles/{symbol}": 10,
                    "public/converted/candles": 10,
                    "public/converted/candles/{symbol}": 10,
                    "public/futures/info": 10,
                    "public/futures/info/{symbol}": 10,
                    "public/futures/history/funding": 10,
                    "public/futures/history/funding/{symbol}": 10,
                    "public/futures/candles/index_price": 10,
                    "public/futures/candles/index_price/{symbol}": 10,
                    "public/futures/candles/mark_price": 10,
                    "public/futures/candles/mark_price/{symbol}": 10,
                    "public/futures/candles/premium_index": 10,
                    "public/futures/candles/premium_index/{symbol}": 10,
                    "public/futures/candles/open_interest": 10,
                    "public/futures/candles/open_interest/{symbol}": 10,
                },
            },
            "private": map[string]interface{} {
                "get": map[string]interface{} {
                    "spot/balance": 15,
                    "spot/balance/{currency}": 15,
                    "spot/order": 1,
                    "spot/order/{client_order_id}": 1,
                    "spot/fee": 15,
                    "spot/fee/{symbol}": 15,
                    "spot/history/order": 15,
                    "spot/history/trade": 15,
                    "margin/account": 1,
                    "margin/account/isolated/{symbol}": 1,
                    "margin/account/cross/{currency}": 1,
                    "margin/order": 1,
                    "margin/order/{client_order_id}": 1,
                    "margin/config": 15,
                    "margin/history/order": 15,
                    "margin/history/trade": 15,
                    "margin/history/positions": 15,
                    "margin/history/clearing": 15,
                    "futures/balance": 15,
                    "futures/balance/{currency}": 15,
                    "futures/account": 1,
                    "futures/account/isolated/{symbol}": 1,
                    "futures/order": 1,
                    "futures/order/{client_order_id}": 1,
                    "futures/config": 15,
                    "futures/fee": 15,
                    "futures/fee/{symbol}": 15,
                    "futures/history/order": 15,
                    "futures/history/trade": 15,
                    "futures/history/positions": 15,
                    "futures/history/clearing": 15,
                    "wallet/balance": 30,
                    "wallet/balance/{currency}": 30,
                    "wallet/crypto/address": 30,
                    "wallet/crypto/address/recent-deposit": 30,
                    "wallet/crypto/address/recent-withdraw": 30,
                    "wallet/crypto/address/check-mine": 30,
                    "wallet/transactions": 30,
                    "wallet/transactions/{tx_id}": 30,
                    "wallet/crypto/fee/estimate": 30,
                    "wallet/airdrops": 30,
                    "wallet/amount-locks": 30,
                    "sub-account": 15,
                    "sub-account/acl": 15,
                    "sub-account/balance/{subAccID}": 15,
                    "sub-account/crypto/address/{subAccID}/{currency}": 15,
                },
                "post": map[string]interface{} {
                    "spot/order": 1,
                    "spot/order/list": 1,
                    "margin/order": 1,
                    "margin/order/list": 1,
                    "futures/order": 1,
                    "futures/order/list": 1,
                    "wallet/crypto/address": 30,
                    "wallet/crypto/withdraw": 30,
                    "wallet/convert": 30,
                    "wallet/transfer": 30,
                    "wallet/internal/withdraw": 30,
                    "wallet/crypto/check-offchain-available": 30,
                    "wallet/crypto/fees/estimate": 30,
                    "wallet/airdrops/{id}/claim": 30,
                    "sub-account/freeze": 15,
                    "sub-account/activate": 15,
                    "sub-account/transfer": 15,
                    "sub-account/acl": 15,
                },
                "patch": map[string]interface{} {
                    "spot/order/{client_order_id}": 1,
                    "margin/order/{client_order_id}": 1,
                    "futures/order/{client_order_id}": 1,
                },
                "delete": map[string]interface{} {
                    "spot/order": 1,
                    "spot/order/{client_order_id}": 1,
                    "margin/position": 1,
                    "margin/position/isolated/{symbol}": 1,
                    "margin/order": 1,
                    "margin/order/{client_order_id}": 1,
                    "futures/position": 1,
                    "futures/position/{margin_mode}/{symbol}": 1,
                    "futures/order": 1,
                    "futures/order/{client_order_id}": 1,
                    "wallet/crypto/withdraw/{id}": 30,
                },
                "put": map[string]interface{} {
                    "margin/account/isolated/{symbol}": 1,
                    "futures/account/isolated/{symbol}": 1,
                    "wallet/crypto/withdraw/{id}": 30,
                },
            },
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "tierBased": true,
                "percentage": true,
                "taker": this.ParseNumber("0.0009"),
                "maker": this.ParseNumber("0.0009"),
                "tiers": map[string]interface{} {
                    "maker": []interface{}{[]interface{}{this.ParseNumber("0"), this.ParseNumber("0.0009")}, []interface{}{this.ParseNumber("10"), this.ParseNumber("0.0007")}, []interface{}{this.ParseNumber("100"), this.ParseNumber("0.0006")}, []interface{}{this.ParseNumber("500"), this.ParseNumber("0.0005")}, []interface{}{this.ParseNumber("1000"), this.ParseNumber("0.0003")}, []interface{}{this.ParseNumber("5000"), this.ParseNumber("0.0002")}, []interface{}{this.ParseNumber("10000"), this.ParseNumber("0.0001")}, []interface{}{this.ParseNumber("20000"), this.ParseNumber("0")}, []interface{}{this.ParseNumber("50000"), this.ParseNumber("-0.0001")}, []interface{}{this.ParseNumber("100000"), this.ParseNumber("-0.0001")}},
                    "taker": []interface{}{[]interface{}{this.ParseNumber("0"), this.ParseNumber("0.0009")}, []interface{}{this.ParseNumber("10"), this.ParseNumber("0.0008")}, []interface{}{this.ParseNumber("100"), this.ParseNumber("0.0007")}, []interface{}{this.ParseNumber("500"), this.ParseNumber("0.0007")}, []interface{}{this.ParseNumber("1000"), this.ParseNumber("0.0006")}, []interface{}{this.ParseNumber("5000"), this.ParseNumber("0.0006")}, []interface{}{this.ParseNumber("10000"), this.ParseNumber("0.0005")}, []interface{}{this.ParseNumber("20000"), this.ParseNumber("0.0004")}, []interface{}{this.ParseNumber("50000"), this.ParseNumber("0.0003")}, []interface{}{this.ParseNumber("100000"), this.ParseNumber("0.0002")}},
                },
            },
        },
        "features": map[string]interface{} {
            "default": map[string]interface{} {
                "sandbox": true,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": true,
                    "triggerPriceType": nil,
                    "triggerDirection": false,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": true,
                        "FOK": true,
                        "PO": true,
                        "GTD": true,
                    },
                    "hedged": false,
                    "selfTradePrevention": false,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyByCost": false,
                    "marketBuyRequiresPrice": false,
                    "iceberg": true,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": true,
                    "limit": 1000,
                    "daysBack": 100000,
                    "untilDays": 100000,
                    "symbolRequired": false,
                    "marketType": true,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": true,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                    "marketType": true,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": true,
                    "limit": 1000,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                    "marketType": true,
                },
                "fetchOrders": nil,
                "fetchClosedOrders": map[string]interface{} {
                    "marginMode": true,
                    "limit": 1000,
                    "daysBack": 100000,
                    "daysBackCanceled": 1,
                    "untilDays": 100000,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                    "marketType": true,
                },
                "fetchOHLCV": map[string]interface{} {
                    "limit": 1000,
                },
            },
            "spot": map[string]interface{} {
                "extends": "default",
            },
            "forDerivatives": map[string]interface{} {
                "extends": "default",
                "createOrder": map[string]interface{} {
                    "marginMode": true,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                },
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                },
                "fetchClosedOrders": map[string]interface{} {
                    "marginMode": false,
                },
            },
            "swap": map[string]interface{} {
                "linear": map[string]interface{} {
                    "extends": "forDerivatives",
                },
                "inverse": map[string]interface{} {
                    "extends": "forDerivatives",
                },
            },
            "future": map[string]interface{} {
                "linear": map[string]interface{} {
                    "extends": "forDerivatives",
                },
                "inverse": map[string]interface{} {
                    "extends": "forDerivatives",
                },
            },
        },
        "timeframes": map[string]interface{} {
            "1m": "M1",
            "3m": "M3",
            "5m": "M5",
            "15m": "M15",
            "30m": "M30",
            "1h": "H1",
            "4h": "H4",
            "1d": "D1",
            "1w": "D7",
            "1M": "1M",
        },
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "429": RateLimitExceeded,
                "500": ExchangeError,
                "503": ExchangeNotAvailable,
                "504": ExchangeNotAvailable,
                "600": PermissionDenied,
                "800": ExchangeError,
                "1002": AuthenticationError,
                "1003": PermissionDenied,
                "1004": AuthenticationError,
                "1005": AuthenticationError,
                "2001": BadSymbol,
                "2002": BadRequest,
                "2003": BadRequest,
                "2010": BadRequest,
                "2011": BadRequest,
                "2012": BadRequest,
                "2020": BadRequest,
                "2022": BadRequest,
                "2024": InvalidOrder,
                "10001": BadRequest,
                "10021": AccountSuspended,
                "10022": BadRequest,
                "20001": InsufficientFunds,
                "20002": OrderNotFound,
                "20003": ExchangeError,
                "20004": ExchangeError,
                "20005": ExchangeError,
                "20006": ExchangeError,
                "20007": ExchangeError,
                "20008": InvalidOrder,
                "20009": InvalidOrder,
                "20010": OnMaintenance,
                "20011": ExchangeError,
                "20012": ExchangeError,
                "20014": ExchangeError,
                "20016": ExchangeError,
                "20018": ExchangeError,
                "20031": ExchangeError,
                "20032": ExchangeError,
                "20033": ExchangeError,
                "20034": ExchangeError,
                "20040": ExchangeError,
                "20041": ExchangeError,
                "20042": ExchangeError,
                "20043": ExchangeError,
                "20044": PermissionDenied,
                "20045": InvalidOrder,
                "20047": InvalidOrder,
                "20048": InvalidOrder,
                "20049": InvalidOrder,
                "20080": ExchangeError,
                "21001": ExchangeError,
                "21003": AccountSuspended,
                "21004": AccountSuspended,
                "22004": ExchangeError,
                "22008": ExchangeError,
            },
            "broad": map[string]interface{} {},
        },
        "options": map[string]interface{} {
            "defaultNetwork": "ERC20",
            "defaultNetworks": map[string]interface{} {
                "ETH": "ETH",
                "USDT": "TRC20",
            },
            "networks": map[string]interface{} {
                "BTC": "btc",
                "OMNI": "BTC",
                "ETH": "eth",
                "ERC20": "ETH",
                "ETC": "ETC",
                "BEP20": "BSC",
                "TRC20": "TRX",
                "NEAR": "NEAR",
                "DGB": "DGB",
                "AE": "AE",
                "AR": "AR",
                "ADA": "ADA",
                "CHZ": "CHZ",
                "ABBC": "ABBC",
                "ALGO": "ALGO",
                "APT": "APT",
                "ATOM": "ATOM",
                "AVAXC": "AVAC",
                "AVAXX": "AVAX",
                "BSV": "BCHSV",
                "BEP2": "BNB",
                "CELO": "CELO",
                "CKB": "CKB",
                "CTXC": "CTXC",
                "DASH": "DASH",
                "DCR": "DCR",
                "DOGE": "doge",
                "EGLD": "EGLD",
                "EOS": "EOS",
                "ETHW": "ETHW",
                "EVER": "EVER",
                "FET": "FET",
                "FIL": "FIL",
                "FLOW": "FLOW",
                "GLMR": "GLMR",
                "GRIN": "GRIN",
                "HBAR": "HBAR",
                "HIVE": "HIVE",
                "HYDRA": "HYDRA",
                "ICP": "ICP",
                "ICX": "ICX",
                "IOST": "IOST",
                "IOTA": "IOTA",
                "IOTX": "IOTX",
                "KAVA": "KAVA",
                "KLAY": "KIM",
                "KOMODO": "KMD",
                "KSM": "KSM",
                "LSK": "LSK",
                "LTC": "ltc",
                "MINA": "MINA",
                "MOVR": "MOVR",
                "NANO": "NANO",
                "NEO": "NEO",
                "ONE": "ONE",
                "ONT": "ONT",
                "OPTIMISM": "OP",
                "PLCU": "PLCU",
                "MATIC": "POLYGON",
                "QTUM": "QTUM",
                "REI": "REI",
                "OASIS": "ROSE",
                "RVN": "RVN",
                "SC": "SC",
                "SCRT": "SCRT",
                "SOL": "SOL",
                "STEEM": "STEEM",
                "THETA": "Theta",
                "TRUE": "TRUE",
                "VET": "VET",
                "VSYS": "VSYS",
                "WAVES": "WAVES",
                "WAX": "WAX",
                "XCH": "XCH",
                "XEC": "XEC",
                "NEM": "XEM",
                "XLM": "XLM",
                "XMR": "xmr",
                "XRD": "XRD",
                "XRP": "XRP",
                "XTZ": "XTZ",
                "XVG": "XVG",
                "XYM": "XYM",
                "ZEC": "ZEC",
                "ZEN": "ZEN",
                "ZIL": "ZIL",
            },
            "accountsByType": map[string]interface{} {
                "spot": "spot",
                "funding": "wallet",
                "swap": "derivatives",
                "future": "derivatives",
            },
            "withdraw": map[string]interface{} {
                "includeFee": false,
            },
        },
        "commonCurrencies": map[string]interface{} {
            "AUTO": "Cube",
            "BCC": "BCC",
            "BDP": "BidiPass",
            "BET": "DAO.Casino",
            "BIT": "BitRewards",
            "BOX": "BOX Token",
            "CPT": "Cryptaur",
            "GET": "Themis",
            "GMT": "GMT Token",
            "HSR": "HC",
            "IQ": "IQ.Cash",
            "LNC": "LinkerCoin",
            "PLA": "PlayChip",
            "PNT": "Penta",
            "SBTC": "Super Bitcoin",
            "STEPN": "GMT",
            "STX": "STOX",
            "TV": "Tokenville",
            "XMT": "MTL",
            "XPNT": "PNT",
        },
    })
}
func  (this *hitbtc) Nonce() interface{}  {
    return this.Milliseconds()
}
/**
 * @method
 * @name hitbtc#fetchMarkets
 * @description retrieves data on all markets for hitbtc
 * @see https://api.hitbtc.com/#symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *hitbtc) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetPublicSymbol(params))
            PanicOnError(response)
            //
            //     {
            //         "AAVEUSDT_PERP":{
            //             "type":"futures",
            //             "expiry":null,
            //             "underlying":"AAVE",
            //             "base_currency":null,
            //             "quote_currency":"USDT",
            //             "quantity_increment":"0.01",
            //             "tick_size":"0.001",
            //             "take_rate":"0.0005",
            //             "make_rate":"0.0002",
            //             "fee_currency":"USDT",
            //             "margin_trading":true,
            //             "max_initial_leverage":"50.00"
            //         },
            //         "MANAUSDT":{
            //             "type":"spot",
            //             "base_currency":"MANA",
            //             "quote_currency":"USDT",
            //             "quantity_increment":"1",
            //             "tick_size":"0.0000001",
            //             "take_rate":"0.0025",
            //             "make_rate":"0.001",
            //             "fee_currency":"USDT",
            //             "margin_trading":true,
            //             "max_initial_leverage":"5.00"
            //         },
            //     }
            //
            var result interface{} = []interface{}{}
            var ids interface{} = ObjectKeys(response)
            for i := 0; IsLessThan(i, GetArrayLength(ids)); i++ {
                var id interface{} = GetValue(ids, i)
                if IsTrue(EndsWith(id, "_BQX")) {
                    continue
                }
                var market interface{} = this.SafeValue(response, id)
                var marketType interface{} = this.SafeString(market, "type")
                var expiry interface{} = this.SafeInteger(market, "expiry")
                var contract interface{} =         (IsEqual(marketType, "futures"))
                var spot interface{} =         (IsEqual(marketType, "spot"))
                var marginTrading interface{} = this.SafeBool(market, "margin_trading", false)
                var margin interface{} = IsTrue(spot) && IsTrue(marginTrading)
                var future interface{} =         (!IsEqual(expiry, nil))
                var swap interface{} =         (IsTrue(contract) && !IsTrue(future))
                var option interface{} = false
                var baseId interface{} = this.SafeString2(market, "base_currency", "underlying")
                var quoteId interface{} = this.SafeString(market, "quote_currency")
                var feeCurrencyId interface{} = this.SafeString(market, "fee_currency")
                var base interface{} = this.SafeCurrencyCode(baseId)
                var quote interface{} = this.SafeCurrencyCode(quoteId)
                var feeCurrency interface{} = this.SafeCurrencyCode(feeCurrencyId)
                var settleId interface{} = nil
                var settle interface{} = nil
                var symbol interface{} = Add(Add(base, "/"), quote)
                var typeVar interface{} = "spot"
                var contractSize interface{} = nil
                var linear interface{} = nil
                var inverse interface{} = nil
                if IsTrue(contract) {
                    contractSize = this.ParseNumber("1")
                    settleId = feeCurrencyId
                    settle = this.SafeCurrencyCode(settleId)
                    linear = (IsTrue((!IsEqual(quote, nil))) && IsTrue((IsEqual(quote, settle))))
                    inverse = !IsTrue(linear)
                    symbol = Add(Add(symbol, ":"), settle)
                    if IsTrue(future) {
                        symbol = Add(Add(symbol, "-"), expiry)
                        typeVar = "future"
                    } else {
                        typeVar = "swap"
                    }
                }
                var lotString interface{} = this.SafeString(market, "quantity_increment")
                var stepString interface{} = this.SafeString(market, "tick_size")
                var lot interface{} = this.ParseNumber(lotString)
                var step interface{} = this.ParseNumber(stepString)
                AppendToArray(&result,map[string]interface{} {
                    "id": id,
                    "symbol": symbol,
                    "base": base,
                    "quote": quote,
                    "settle": settle,
                    "baseId": baseId,
                    "quoteId": quoteId,
                    "settleId": settleId,
                    "type": typeVar,
                    "spot": spot,
                    "margin": margin,
                    "swap": swap,
                    "future": future,
                    "option": option,
                    "active": true,
                    "contract": contract,
                    "linear": linear,
                    "inverse": inverse,
                    "taker": this.SafeNumber(market, "take_rate"),
                    "maker": this.SafeNumber(market, "make_rate"),
                    "contractSize": contractSize,
                    "expiry": expiry,
                    "expiryDatetime": nil,
                    "strike": nil,
                    "optionType": nil,
                    "feeCurrency": feeCurrency,
                    "precision": map[string]interface{} {
                        "amount": lot,
                        "price": step,
                    },
                    "limits": map[string]interface{} {
                        "leverage": map[string]interface{} {
                            "min": this.ParseNumber("1"),
                            "max": this.SafeNumber(market, "max_initial_leverage", 1),
                        },
                        "amount": map[string]interface{} {
                            "min": lot,
                            "max": nil,
                        },
                        "price": map[string]interface{} {
                            "min": step,
                            "max": nil,
                        },
                        "cost": map[string]interface{} {
                            "min": this.ParseNumber(Precise.StringMul(lotString, stepString)),
                            "max": nil,
                        },
                    },
                    "created": nil,
                    "info": market,
                })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hitbtc#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see https://api.hitbtc.com/#currencies
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func  (this *hitbtc) FetchCurrencies(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetPublicCurrency(params))
            PanicOnError(response)
            //
            //     {
            //       "WEALTH": {
            //         "full_name": "ConnectWealth",
            //         "payin_enabled": false,
            //         "payout_enabled": false,
            //         "transfer_enabled": true,
            //         "precision_transfer": "0.001",
            //         "networks": [
            //           {
            //             "network": "ETH",
            //             "protocol": "ERC20",
            //             "default": true,
            //             "payin_enabled": false,
            //             "payout_enabled": false,
            //             "precision_payout": "0.001",
            //             "payout_fee": "0.016800000000",
            //             "payout_is_payment_id": false,
            //             "payin_payment_id": false,
            //             "payin_confirmations": "2"
            //           }
            //         ]
            //       }
            //     }
            //
            var result interface{} = map[string]interface{} {}
            var currencies interface{} = ObjectKeys(response)
            for i := 0; IsLessThan(i, GetArrayLength(currencies)); i++ {
                var currencyId interface{} = GetValue(currencies, i)
                var code interface{} = this.SafeCurrencyCode(currencyId)
                var entry interface{} = GetValue(response, currencyId)
                var name interface{} = this.SafeString(entry, "full_name")
                var precision interface{} = this.SafeNumber(entry, "precision_transfer")
                var payinEnabled interface{} = this.SafeBool(entry, "payin_enabled", false)
                var payoutEnabled interface{} = this.SafeBool(entry, "payout_enabled", false)
                var transferEnabled interface{} = this.SafeBool(entry, "transfer_enabled", false)
                var active interface{} = IsTrue(IsTrue(payinEnabled) && IsTrue(payoutEnabled)) && IsTrue(transferEnabled)
                var rawNetworks interface{} = this.SafeValue(entry, "networks", []interface{}{})
                var networks interface{} = map[string]interface{} {}
                var fee interface{} = nil
                var depositEnabled interface{} = nil
                var withdrawEnabled interface{} = nil
                for j := 0; IsLessThan(j, GetArrayLength(rawNetworks)); j++ {
                    var rawNetwork interface{} = GetValue(rawNetworks, j)
                    var networkId interface{} = this.SafeString2(rawNetwork, "protocol", "network")
                    var networkCode interface{} = this.NetworkIdToCode(networkId)
                    networkCode = Ternary(IsTrue((!IsEqual(networkCode, nil))), ToUpper(networkCode), nil)
                    fee = this.SafeNumber(rawNetwork, "payout_fee")
                    var networkPrecision interface{} = this.SafeNumber(rawNetwork, "precision_payout")
                    var payinEnabledNetwork interface{} = this.SafeBool(rawNetwork, "payin_enabled", false)
                    var payoutEnabledNetwork interface{} = this.SafeBool(rawNetwork, "payout_enabled", false)
                    var activeNetwork interface{} = IsTrue(payinEnabledNetwork) && IsTrue(payoutEnabledNetwork)
                    if IsTrue(IsTrue(payinEnabledNetwork) && !IsTrue(depositEnabled)) {
                        depositEnabled = true
                    } else if !IsTrue(payinEnabledNetwork) {
                        depositEnabled = false
                    }
                    if IsTrue(IsTrue(payoutEnabledNetwork) && !IsTrue(withdrawEnabled)) {
                        withdrawEnabled = true
                    } else if !IsTrue(payoutEnabledNetwork) {
                        withdrawEnabled = false
                    }
                    AddElementToObject(networks, networkCode, map[string]interface{} {
            "info": rawNetwork,
            "id": networkId,
            "network": networkCode,
            "fee": fee,
            "active": activeNetwork,
            "deposit": payinEnabledNetwork,
            "withdraw": payoutEnabledNetwork,
            "precision": networkPrecision,
            "limits": map[string]interface{} {
                "withdraw": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
            },
        })
                }
                var networksKeys interface{} = ObjectKeys(networks)
                var networksLength interface{} =         GetArrayLength(networksKeys)
                AddElementToObject(result, code, map[string]interface{} {
            "info": entry,
            "code": code,
            "id": currencyId,
            "precision": precision,
            "name": name,
            "active": active,
            "deposit": depositEnabled,
            "withdraw": withdrawEnabled,
            "networks": networks,
            "fee": Ternary(IsTrue((IsLessThanOrEqual(networksLength, 1))), fee, nil),
            "limits": map[string]interface{} {
                "amount": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
            },
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hitbtc#createDepositAddress
 * @description create a currency deposit address
 * @see https://api.hitbtc.com/#generate-deposit-crypto-address
 * @param {string} code unified currency code of the currency for the deposit address
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *hitbtc) CreateDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes10268 := (<-this.LoadMarkets())
            PanicOnError(retRes10268)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "currency": GetValue(currency, "id"),
            }
            var network interface{} = this.SafeStringUpper(params, "network")
            if IsTrue(IsTrue((!IsEqual(network, nil))) && IsTrue((IsEqual(code, "USDT")))) {
                var networks interface{} = this.SafeValue(this.Options, "networks")
                var parsedNetwork interface{} = this.SafeString(networks, network)
                if IsTrue(!IsEqual(parsedNetwork, nil)) {
                    AddElementToObject(request, "currency", parsedNetwork)
                }
                params = this.Omit(params, "network")
            }
        
            response:= (<-this.PrivatePostWalletCryptoAddress(this.Extend(request, params)))
            PanicOnError(response)
            //
            //  {"currency":"ETH","address":"0xd0d9aea60c41988c3e68417e2616065617b7afd3"}
            //
            var currencyId interface{} = this.SafeString(response, "currency")
        
            ch <- map[string]interface{} {
                "currency": this.SafeCurrencyCode(currencyId),
                "address": this.SafeString(response, "address"),
                "tag": this.SafeString(response, "payment_id"),
                "network": nil,
                "info": response,
            }
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hitbtc#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account
 * @see https://api.hitbtc.com/#get-deposit-crypto-address
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *hitbtc) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes10648 := (<-this.LoadMarkets())
            PanicOnError(retRes10648)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "currency": GetValue(currency, "id"),
            }
            var network interface{} = this.SafeStringUpper(params, "network")
            if IsTrue(IsTrue((!IsEqual(network, nil))) && IsTrue((IsEqual(code, "USDT")))) {
                var networks interface{} = this.SafeValue(this.Options, "networks")
                var parsedNetwork interface{} = this.SafeString(networks, network)
                if IsTrue(!IsEqual(parsedNetwork, nil)) {
                    AddElementToObject(request, "currency", parsedNetwork)
                }
                params = this.Omit(params, "network")
            }
        
            response:= (<-this.PrivateGetWalletCryptoAddress(this.Extend(request, params)))
            PanicOnError(response)
            //
            //  [{"currency":"ETH","address":"0xd0d9aea60c41988c3e68417e2616065617b7afd3"}]
            //
            var firstAddress interface{} = this.SafeValue(response, 0)
            var address interface{} = this.SafeString(firstAddress, "address")
            var currencyId interface{} = this.SafeString(firstAddress, "currency")
            var tag interface{} = this.SafeString(firstAddress, "payment_id")
            var parsedCode interface{} = this.SafeCurrencyCode(currencyId)
        
            ch <- map[string]interface{} {
                "info": response,
                "currency": parsedCode,
                "network": nil,
                "address": address,
                "tag": tag,
            }
            return nil
        
            }()
            return ch
        }
func  (this *hitbtc) ParseBalance(response interface{}) interface{}  {
    var result interface{} = map[string]interface{} {
        "info": response,
    }
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        var entry interface{} = GetValue(response, i)
        var currencyId interface{} = this.SafeString(entry, "currency")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        AddElementToObject(account, "free", this.SafeString(entry, "available"))
        AddElementToObject(account, "used", this.SafeString(entry, "reserved"))
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name hitbtc#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://api.hitbtc.com/#wallet-balance
 * @see https://api.hitbtc.com/#get-spot-trading-balance
 * @see https://api.hitbtc.com/#get-trading-balance
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *hitbtc) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var typeVar interface{} = this.SafeStringLower(params, "type", "spot")
            params = this.Omit(params, []interface{}{"type"})
            var accountsByType interface{} = this.SafeValue(this.Options, "accountsByType", map[string]interface{} {})
            var account interface{} = this.SafeString(accountsByType, typeVar, typeVar)
            var response interface{} = nil
            if IsTrue(IsEqual(account, "wallet")) {
                
        response = (<-this.PrivateGetWalletBalance(params))
                PanicOnError(response)
            } else if IsTrue(IsEqual(account, "spot")) {
                
        response = (<-this.PrivateGetSpotBalance(params))
                PanicOnError(response)
            } else if IsTrue(IsEqual(account, "derivatives")) {
                
        response = (<-this.PrivateGetFuturesBalance(params))
                PanicOnError(response)
            } else {
                var keys interface{} = ObjectKeys(accountsByType)
                panic(BadRequest(Add(Add(this.Id, " fetchBalance() type parameter must be one of "), Join(keys, ", "))))
            }
        
                //
            //     [
            //       {
            //         "currency": "PAXG",
            //         "available": "0",
            //         "reserved": "0",
            //         "reserved_margin": "0",
            //       },
            //       ...
            //     ]
            //
        ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hitbtc#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://api.hitbtc.com/#tickers
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *hitbtc) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes11608 := (<-this.LoadMarkets())
            PanicOnError(retRes11608)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetPublicTickerSymbol(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "ask": "0.020572",
            //         "bid": "0.020566",
            //         "last": "0.020574",
            //         "low": "0.020388",
            //         "high": "0.021084",
            //         "open": "0.020913",
            //         "volume": "138444.3666",
            //         "volume_quote": "2853.6874972480",
            //         "timestamp": "2021-06-02T17:52:36.731Z"
            //     }
            //
        ch <- this.ParseTicker(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hitbtc#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://api.hitbtc.com/#tickers
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *hitbtc) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes11928 := (<-this.LoadMarkets())
            PanicOnError(retRes11928)
            symbols = this.MarketSymbols(symbols)
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbols, nil)) {
                var marketIds interface{} = this.MarketIds(symbols)
                var delimited interface{} = Join(marketIds, ",")
                AddElementToObject(request, "symbols", delimited)
            }
        
            response:= (<-this.PublicGetPublicTicker(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //       "BTCUSDT": {
            //         "ask": "63049.06",
            //         "bid": "63046.41",
            //         "last": "63048.36",
            //         "low": "62010.00",
            //         "high": "66657.99",
            //         "open": "64839.75",
            //         "volume": "15272.13278",
            //         "volume_quote": "976312127.6277998",
            //         "timestamp": "2021-10-22T04:25:47.573Z"
            //       }
            //     }
            //
            var result interface{} = map[string]interface{} {}
            var keys interface{} = ObjectKeys(response)
            for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
                var marketId interface{} = GetValue(keys, i)
                var market interface{} = this.SafeMarket(marketId)
                var symbol interface{} = GetValue(market, "symbol")
                var entry interface{} = GetValue(response, marketId)
                AddElementToObject(result, symbol, this.ParseTicker(entry, market))
            }
        
            ch <- this.FilterByArrayTickers(result, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
func  (this *hitbtc) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //       "ask": "62756.01",
    //       "bid": "62754.09",
    //       "last": "62755.87",
    //       "low": "62010.00",
    //       "high": "66657.99",
    //       "open": "65089.27",
    //       "volume": "16719.50366",
    //       "volume_quote": "1063422878.8156828",
    //       "timestamp": "2021-10-22T07:29:14.585Z"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.Parse8601(GetValue(ticker, "timestamp"))
    var symbol interface{} = this.SafeSymbol(nil, market)
    var baseVolume interface{} = this.SafeString(ticker, "volume")
    var quoteVolume interface{} = this.SafeString(ticker, "volume_quote")
    var open interface{} = this.SafeString(ticker, "open")
    var last interface{} = this.SafeString(ticker, "last")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeString(ticker, "high"),
        "low": this.SafeString(ticker, "low"),
        "bid": this.SafeString(ticker, "bid"),
        "bidVolume": nil,
        "ask": this.SafeString(ticker, "ask"),
        "askVolume": nil,
        "vwap": nil,
        "open": open,
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": nil,
        "percentage": nil,
        "average": nil,
        "baseVolume": baseVolume,
        "quoteVolume": quoteVolume,
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name hitbtc#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://api.hitbtc.com/#trades
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *hitbtc) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes12848 := (<-this.LoadMarkets())
            PanicOnError(retRes12848)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", mathMin(limit, 1000))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "from", since)
            }
            var response interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
                
        response = (<-this.PublicGetPublicTradesSymbol(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PublicGetPublicTrades(this.Extend(request, params)))
                PanicOnError(response)
            }
            if IsTrue(!IsEqual(symbol, nil)) {
        
                ch <- this.ParseTrades(response, market)
                return nil
            }
            var trades interface{} = []interface{}{}
            var marketIds interface{} = ObjectKeys(response)
            for i := 0; IsLessThan(i, GetArrayLength(marketIds)); i++ {
                var marketId interface{} = GetValue(marketIds, i)
                var marketInner interface{} = this.Market(marketId)
                var rawTrades interface{} = GetValue(response, marketId)
                var parsed interface{} = this.ParseTrades(rawTrades, marketInner)
                trades = this.ArrayConcat(trades, parsed)
            }
        
            ch <- trades
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hitbtc#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://api.hitbtc.com/#spot-trades-history
 * @see https://api.hitbtc.com/#futures-trades-history
 * @see https://api.hitbtc.com/#margin-trades-history
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] 'cross' or 'isolated' only 'isolated' is supported
 * @param {bool} [params.margin] true for fetching margin trades
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *hitbtc) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes13328 := (<-this.LoadMarkets())
            PanicOnError(retRes13328)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "from", since)
            }
            var marketType interface{} = nil
            var marginMode interface{} = nil
            var response interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchMyTrades", market, params);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            marginModeparamsVariable := this.HandleMarginModeAndParams("fetchMyTrades", params);
            marginMode = GetValue(marginModeparamsVariable,0);
            params = GetValue(marginModeparamsVariable,1)
            params = this.Omit(params, []interface{}{"marginMode", "margin"})
            if IsTrue(!IsEqual(marginMode, nil)) {
                
        response = (<-this.PrivateGetMarginHistoryTrade(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                if IsTrue(IsEqual(marketType, "spot")) {
                    
        response = (<-this.PrivateGetSpotHistoryTrade(this.Extend(request, params)))
                    PanicOnError(response)
                } else if IsTrue(IsEqual(marketType, "swap")) {
                    
        response = (<-this.PrivateGetFuturesHistoryTrade(this.Extend(request, params)))
                    PanicOnError(response)
                } else if IsTrue(IsEqual(marketType, "margin")) {
                    
        response = (<-this.PrivateGetMarginHistoryTrade(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    panic(NotSupported(Add(this.Id, " fetchMyTrades() not support this market type")))
                }
            }
        
            ch <- this.ParseTrades(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *hitbtc) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // createOrder (market)
    //
    //  {
    //      "id": "1569252895",
    //      "position_id": "0",
    //      "quantity": "10",
    //      "price": "0.03919424",
    //      "fee": "0.000979856000",
    //      "timestamp": "2022-01-25T19:38:36.153Z",
    //      "taker": true
    //  }
    //
    // fetchTrades
    //
    //  {
    //      "id": 974786185,
    //      "price": "0.032462",
    //      "qty": "0.3673",
    //      "side": "buy",
    //      "timestamp": "2020-10-16T12:57:39.846Z"
    //  }
    //
    // fetchMyTrades spot
    //
    //  {
    //      "id": 277210397,
    //      "clientOrderId": "6e102f3e7f3f4e04aeeb1cdc95592f1a",
    //      "orderId": 28102855393,
    //      "symbol": "ETHBTC",
    //      "side": "sell",
    //      "quantity": "0.002",
    //      "price": "0.073365",
    //      "fee": "0.000000147",
    //      "timestamp": "2018-04-28T18:39:55.345Z",
    //      "taker": true
    //  }
    //
    // fetchMyTrades swap and margin
    //
    //  {
    //      "id": 4718564,
    //      "order_id": 58730811958,
    //      "client_order_id": "475c47d97f867f09726186eb22b4c3d4",
    //      "symbol": "BTCUSDT_PERP",
    //      "side": "sell",
    //      "quantity": "0.0001",
    //      "price": "41118.51",
    //      "fee": "0.002055925500",
    //      "timestamp": "2022-03-17T05:23:17.795Z",
    //      "taker": true,
    //      "position_id": 2350122,
    //      "pnl": "0.002255000000",
    //      "liquidation": false
    //  }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.Parse8601(GetValue(trade, "timestamp"))
    var marketId interface{} = this.SafeString(trade, "symbol")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = GetValue(market, "symbol")
    var fee interface{} = nil
    var feeCostString interface{} = this.SafeString(trade, "fee")
    var taker interface{} = this.SafeValue(trade, "taker")
    var takerOrMaker interface{} = nil
    if IsTrue(!IsEqual(taker, nil)) {
        takerOrMaker = Ternary(IsTrue(taker), "taker", "maker")
    } else {
        takerOrMaker = "taker" // the only case when `taker` field is missing, is public fetchTrades and it must be taker
    }
    if IsTrue(!IsEqual(feeCostString, nil)) {
        var info interface{} = this.SafeValue(market, "info", map[string]interface{} {})
        var feeCurrency interface{} = this.SafeString(info, "fee_currency")
        var feeCurrencyCode interface{} = this.SafeCurrencyCode(feeCurrency)
        fee = map[string]interface{} {
            "cost": feeCostString,
            "currency": feeCurrencyCode,
        }
    }
    // we use clientOrderId as the order id with this exchange intentionally
    // because most of their endpoints will require clientOrderId
    // explained here: https://github.com/ccxt/ccxt/issues/5674
    var orderId interface{} = this.SafeString2(trade, "clientOrderId", "client_order_id")
    var priceString interface{} = this.SafeString(trade, "price")
    var amountString interface{} = this.SafeString2(trade, "quantity", "qty")
    var side interface{} = this.SafeString(trade, "side")
    var id interface{} = this.SafeString(trade, "id")
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "id": id,
        "order": orderId,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "type": nil,
        "side": side,
        "takerOrMaker": takerOrMaker,
        "price": priceString,
        "amount": amountString,
        "cost": nil,
        "fee": fee,
    }, market)
}
func  (this *hitbtc) FetchTransactionsHelper(types interface{}, code interface{}, since interface{}, limit interface{}, params interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                
            retRes14728 := (<-this.LoadMarkets())
            PanicOnError(retRes14728)
            var request interface{} = map[string]interface{} {
                "types": types,
            }
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "currencies", GetValue(currency, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "from", this.Iso8601(since))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.PrivateGetWalletTransactions(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //       {
            //         "id": "101609495",
            //         "created_at": "2018-03-06T22:05:06.507Z",
            //         "updated_at": "2018-03-06T22:11:45.03Z",
            //         "status": "SUCCESS",
            //         "type": "DEPOSIT",
            //         "subtype": "BLOCKCHAIN",
            //         "native": {
            //           "tx_id": "e20b0965-4024-44d0-b63f-7fb8996a6706",
            //           "index": "881652766",
            //           "currency": "ETH",
            //           "amount": "0.01418088",
            //           "hash": "d95dbbff3f9234114f1211ab0ba2a94f03f394866fd5749d74a1edab80e6c5d3",
            //           "address": "0xd9259302c32c0a0295d86a39185c9e14f6ba0a0d",
            //           "confirmations": "20",
            //           "senders": [
            //             "0x243bec9256c9a3469da22103891465b47583d9f1"
            //           ]
            //         }
            //       }
            //     ]
            //
        ch <- this.ParseTransactions(response, currency, since, limit, params)
            return nil
        
            }()
            return ch
        }
func  (this *hitbtc) ParseTransactionStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "CREATED": "pending",
        "PENDING": "pending",
        "FAILED": "failed",
        "ROLLED_BACK": "failed",
        "SUCCESS": "ok",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *hitbtc) ParseTransactionType(typeVar interface{}) interface{}  {
    var types interface{} = map[string]interface{} {
        "DEPOSIT": "deposit",
        "WITHDRAW": "withdrawal",
    }
    return this.SafeString(types, typeVar, typeVar)
}
func  (this *hitbtc) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // transaction
    //
    //     {
    //       "id": "101609495",
    //       "created_at": "2018-03-06T22:05:06.507Z",
    //       "updated_at": "2018-03-06T22:11:45.03Z",
    //       "status": "SUCCESS",
    //       "type": "DEPOSIT", // DEPOSIT, WITHDRAW, ..
    //       "subtype": "BLOCKCHAIN",
    //       "native": {
    //         "tx_id": "e20b0965-4024-44d0-b63f-7fb8996a6706",
    //         "index": "881652766",
    //         "currency": "ETH",
    //         "amount": "0.01418088",
    //         "hash": "d95dbbff3f9234114f1211ab0ba2a94f03f394866fd5749d74a1edab80e6c5d3",
    //         "address": "0xd9259302c32c0a0295d86a39185c9e14f6ba0a0d",
    //         "confirmations": "20",
    //         "senders": [
    //           "0x243bec9256c9a3469da22103891465b47583d9f1"
    //         ],
    //         "fee": "1.22" // only for WITHDRAW
    //       }
    //     },
    //     "operation_id": "084cfcd5-06b9-4826-882e-fdb75ec3625d", // only for WITHDRAW
    //     "commit_risk": {}
    // withdraw
    //
    //     {
    //         "id":"084cfcd5-06b9-4826-882e-fdb75ec3625d"
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var id interface{} = this.SafeString2(transaction, "operation_id", "id")
    var timestamp interface{} = this.Parse8601(this.SafeString(transaction, "created_at"))
    var updated interface{} = this.Parse8601(this.SafeString(transaction, "updated_at"))
    var typeVar interface{} = this.ParseTransactionType(this.SafeString(transaction, "type"))
    var status interface{} = this.ParseTransactionStatus(this.SafeString(transaction, "status"))
    var native interface{} = this.SafeValue(transaction, "native", map[string]interface{} {})
    var currencyId interface{} = this.SafeString(native, "currency")
    var code interface{} = this.SafeCurrencyCode(currencyId)
    var txhash interface{} = this.SafeString(native, "hash")
    var address interface{} = this.SafeString(native, "address")
    var addressTo interface{} = address
    var tag interface{} = this.SafeString(native, "payment_id")
    var tagTo interface{} = tag
    var sender interface{} = this.SafeValue(native, "senders")
    var addressFrom interface{} = this.SafeString(sender, 0)
    var amount interface{} = this.SafeNumber(native, "amount")
    var subType interface{} = this.SafeString(transaction, "subtype")
    var internal interface{} = IsEqual(subType, "OFFCHAIN")
    // https://api.hitbtc.com/#check-if-offchain-is-available
    var fee interface{} = map[string]interface{} {
        "currency": nil,
        "cost": nil,
        "rate": nil,
    }
    var feeCost interface{} = this.SafeNumber(native, "fee")
    if IsTrue(!IsEqual(feeCost, nil)) {
        AddElementToObject(fee, "currency", code)
        AddElementToObject(fee, "cost", feeCost)
    }
    return map[string]interface{} {
        "info": transaction,
        "id": id,
        "txid": txhash,
        "type": typeVar,
        "currency": code,
        "network": nil,
        "amount": amount,
        "status": status,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "address": address,
        "addressFrom": addressFrom,
        "addressTo": addressTo,
        "tag": tag,
        "tagFrom": nil,
        "tagTo": tagTo,
        "updated": updated,
        "comment": nil,
        "internal": internal,
        "fee": fee,
    }
}
/**
 * @method
 * @name hitbtc#fetchDepositsWithdrawals
 * @description fetch history of deposits and withdrawals
 * @see https://api.hitbtc.com/#get-transactions-history
 * @param {string} [code] unified currency code for the currency of the deposit/withdrawals, default is undefined
 * @param {int} [since] timestamp in ms of the earliest deposit/withdrawal, default is undefined
 * @param {int} [limit] max number of deposit/withdrawals to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *hitbtc) FetchDepositsWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
                retRes163215 :=  (<-this.FetchTransactionsHelper("DEPOSIT,WITHDRAW", code, since, limit, params))
                PanicOnError(retRes163215)
                ch <- retRes163215
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hitbtc#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://api.hitbtc.com/#get-transactions-history
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *hitbtc) FetchDeposits(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
                retRes164715 :=  (<-this.FetchTransactionsHelper("DEPOSIT", code, since, limit, params))
                PanicOnError(retRes164715)
                ch <- retRes164715
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hitbtc#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @see https://api.hitbtc.com/#get-transactions-history
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawals structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *hitbtc) FetchWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
                retRes166215 :=  (<-this.FetchTransactionsHelper("WITHDRAW", code, since, limit, params))
                PanicOnError(retRes166215)
                ch <- retRes166215
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hitbtc#fetchOrderBooks
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data for multiple markets
 * @see https://api.hitbtc.com/#order-books
 * @param {string[]} [symbols] list of unified market symbols, all symbols fetched if undefined, default is undefined
 * @param {int} [limit] max number of entries per orderbook to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbol
 */
func  (this *hitbtc) FetchOrderBooks(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes16768 := (<-this.LoadMarkets())
            PanicOnError(retRes16768)
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbols, nil)) {
                var marketIdsInner interface{} = this.MarketIds(symbols)
                AddElementToObject(request, "symbols", Join(marketIdsInner, ","))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "depth", limit)
            }
        
            response:= (<-this.PublicGetPublicOrderbook(this.Extend(request, params)))
            PanicOnError(response)
            var result interface{} = map[string]interface{} {}
            var marketIds interface{} = ObjectKeys(response)
            for i := 0; IsLessThan(i, GetArrayLength(marketIds)); i++ {
                var marketId interface{} = GetValue(marketIds, i)
                var orderbook interface{} = GetValue(response, marketId)
                var symbol interface{} = this.SafeSymbol(marketId)
                var timestamp interface{} = this.Parse8601(this.SafeString(orderbook, "timestamp"))
                AddElementToObject(result, symbol, this.ParseOrderBook(GetValue(response, marketId), symbol, timestamp, "bid", "ask"))
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hitbtc#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://api.hitbtc.com/#order-books
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *hitbtc) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes17098 := (<-this.LoadMarkets())
            PanicOnError(retRes17098)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "depth", limit)
            }
        
            response:= (<-this.PublicGetPublicOrderbookSymbol(this.Extend(request, params)))
            PanicOnError(response)
            var timestamp interface{} = this.Parse8601(this.SafeString(response, "timestamp"))
        
            ch <- this.ParseOrderBook(response, symbol, timestamp, "bid", "ask")
            return nil
        
            }()
            return ch
        }
func  (this *hitbtc) ParseTradingFee(fee interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "symbol":"ARVUSDT", // returned from fetchTradingFees only
    //         "take_rate":"0.0009",
    //         "make_rate":"0.0009"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var taker interface{} = this.SafeNumber(fee, "take_rate")
    var maker interface{} = this.SafeNumber(fee, "make_rate")
    var marketId interface{} = this.SafeString(fee, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    return map[string]interface{} {
        "info": fee,
        "symbol": symbol,
        "taker": taker,
        "maker": maker,
        "percentage": nil,
        "tierBased": nil,
    }
}
/**
 * @method
 * @name hitbtc#fetchTradingFee
 * @description fetch the trading fees for a market
 * @see https://api.hitbtc.com/#get-trading-commission
 * @see https://api.hitbtc.com/#get-trading-commission-2
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func  (this *hitbtc) FetchTradingFee(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes17558 := (<-this.LoadMarkets())
            PanicOnError(retRes17558)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var response interface{} = nil
            if IsTrue(IsEqual(GetValue(market, "type"), "spot")) {
                
        response = (<-this.PrivateGetSpotFeeSymbol(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(GetValue(market, "type"), "swap")) {
                
        response = (<-this.PrivateGetFuturesFeeSymbol(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                panic(NotSupported(Add(this.Id, " fetchTradingFee() not support this market type")))
            }
        
                //
            //     {
            //         "take_rate":"0.0009",
            //         "make_rate":"0.0009"
            //     }
            //
        ch <- this.ParseTradingFee(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hitbtc#fetchTradingFees
 * @description fetch the trading fees for multiple markets
 * @see https://api.hitbtc.com/#get-all-trading-commissions
 * @see https://api.hitbtc.com/#get-all-trading-commissions-2
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
 */
func  (this *hitbtc) FetchTradingFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes17878 := (<-this.LoadMarkets())
            PanicOnError(retRes17878)
            marketTypequeryVariable := this.HandleMarketTypeAndParams("fetchTradingFees", nil, params);
            marketType := GetValue(marketTypequeryVariable,0);
            query := GetValue(marketTypequeryVariable,1)
            var response interface{} = nil
            if IsTrue(IsEqual(marketType, "spot")) {
                
        response = (<-this.PrivateGetSpotFee(query))
                PanicOnError(response)
            } else if IsTrue(IsEqual(marketType, "swap")) {
                
        response = (<-this.PrivateGetFuturesFee(query))
                PanicOnError(response)
            } else {
                panic(NotSupported(Add(this.Id, " fetchTradingFees() not support this market type")))
            }
            //
            //     [
            //         {
            //             "symbol":"ARVUSDT",
            //             "take_rate":"0.0009",
            //             "make_rate":"0.0009"
            //         }
            //     ]
            //
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
                var fee interface{} = this.ParseTradingFee(GetValue(response, i))
                var symbol interface{} = GetValue(fee, "symbol")
                AddElementToObject(result, symbol, fee)
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hitbtc#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://api.hitbtc.com/#candles
 * @see https://api.hitbtc.com/#futures-index-price-candles
 * @see https://api.hitbtc.com/#futures-mark-price-candles
 * @see https://api.hitbtc.com/#futures-premium-index-candles
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest funding rate
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *hitbtc) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes18338 := (<-this.LoadMarkets())
            PanicOnError(retRes18338)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchOHLCV", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes183719 :=  (<-this.FetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, params, 1000))
                    PanicOnError(retRes183719)
                    ch <- retRes183719
                    return nil
            }
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "period": this.SafeString(this.Timeframes, timeframe, timeframe),
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "from", this.Iso8601(since))
            }
            requestparamsVariable := this.HandleUntilOption("until", request, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", mathMin(limit, 1000))
            }
            var price interface{} = this.SafeString(params, "price")
            params = this.Omit(params, "price")
            var response interface{} = nil
            if IsTrue(IsEqual(price, "mark")) {
                
        response = (<-this.PublicGetPublicFuturesCandlesMarkPriceSymbol(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(price, "index")) {
                
        response = (<-this.PublicGetPublicFuturesCandlesIndexPriceSymbol(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(price, "premiumIndex")) {
                
        response = (<-this.PublicGetPublicFuturesCandlesPremiumIndexSymbol(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PublicGetPublicCandlesSymbol(this.Extend(request, params)))
                PanicOnError(response)
            }
        
                //
            // Spot and Swap
            //
            //     [
            //         {
            //             "timestamp": "2021-10-25T07:38:00.000Z",
            //             "open": "4173.391",
            //             "close": "4170.923",
            //             "min": "4170.923",
            //             "max": "4173.986",
            //             "volume": "0.1879",
            //             "volume_quote": "784.2517846"
            //         }
            //     ]
            //
            // Mark, Index and Premium Index
            //
            //     [
            //         {
            //             "timestamp": "2022-04-01T01:28:00.000Z",
            //             "open": "45146.39",
            //             "close": "45219.43",
            //             "min": "45146.39",
            //             "max": "45219.43"
            //         },
            //     ]
            //
        ch <- this.ParseOHLCVs(response, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *hitbtc) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // Spot and Swap
    //
    //     {
    //         "timestamp":"2015-08-20T19:01:00.000Z",
    //         "open":"0.006",
    //         "close":"0.006",
    //         "min":"0.006",
    //         "max":"0.006",
    //         "volume":"0.003",
    //         "volume_quote":"0.000018"
    //     }
    //
    // Mark, Index and Premium Index
    //
    //     {
    //         "timestamp": "2022-04-01T01:28:00.000Z",
    //         "open": "45146.39",
    //         "close": "45219.43",
    //         "min": "45146.39",
    //         "max": "45219.43"
    //     },
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.Parse8601(this.SafeString(ohlcv, "timestamp")), this.SafeNumber(ohlcv, "open"), this.SafeNumber(ohlcv, "max"), this.SafeNumber(ohlcv, "min"), this.SafeNumber(ohlcv, "close"), this.SafeNumber(ohlcv, "volume")}
}
/**
 * @method
 * @name hitbtc#fetchClosedOrders
 * @description fetches information on multiple closed orders made by the user
 * @see https://api.hitbtc.com/#spot-orders-history
 * @see https://api.hitbtc.com/#futures-orders-history
 * @see https://api.hitbtc.com/#margin-orders-history
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] 'cross' or 'isolated' only 'isolated' is supported
 * @param {bool} [params.margin] true for fetching margin orders
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *hitbtc) FetchClosedOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes19438 := (<-this.LoadMarkets())
            PanicOnError(retRes19438)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "from", this.Iso8601(since))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            var marketType interface{} = nil
            var marginMode interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchClosedOrders", market, params);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            marginModeparamsVariable := this.HandleMarginModeAndParams("fetchClosedOrders", params);
            marginMode = GetValue(marginModeparamsVariable,0);
            params = GetValue(marginModeparamsVariable,1)
            params = this.Omit(params, []interface{}{"marginMode", "margin"})
            var response interface{} = nil
            if IsTrue(!IsEqual(marginMode, nil)) {
                
        response = (<-this.PrivateGetMarginHistoryOrder(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                if IsTrue(IsEqual(marketType, "spot")) {
                    
        response = (<-this.PrivateGetSpotHistoryOrder(this.Extend(request, params)))
                    PanicOnError(response)
                } else if IsTrue(IsEqual(marketType, "swap")) {
                    
        response = (<-this.PrivateGetFuturesHistoryOrder(this.Extend(request, params)))
                    PanicOnError(response)
                } else if IsTrue(IsEqual(marketType, "margin")) {
                    
        response = (<-this.PrivateGetMarginHistoryOrder(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    panic(NotSupported(Add(this.Id, " fetchClosedOrders() not support this market type")))
                }
            }
            var parsed interface{} = this.ParseOrders(response, market, since, limit)
        
            ch <- this.FilterByArray(parsed, "status", []interface{}{"closed", "canceled"}, false)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hitbtc#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://api.hitbtc.com/#spot-orders-history
 * @see https://api.hitbtc.com/#futures-orders-history
 * @see https://api.hitbtc.com/#margin-orders-history
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] 'cross' or 'isolated' only 'isolated' is supported
 * @param {bool} [params.margin] true for fetching a margin order
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *hitbtc) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes19948 := (<-this.LoadMarkets())
            PanicOnError(retRes19948)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var request interface{} = map[string]interface{} {
                "client_order_id": id,
            }
            var marketType interface{} = nil
            var marginMode interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchOrder", market, params);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            marginModeparamsVariable := this.HandleMarginModeAndParams("fetchOrder", params);
            marginMode = GetValue(marginModeparamsVariable,0);
            params = GetValue(marginModeparamsVariable,1)
            params = this.Omit(params, []interface{}{"marginMode", "margin"})
            var response interface{} = nil
            if IsTrue(!IsEqual(marginMode, nil)) {
                
        response = (<-this.PrivateGetMarginHistoryOrder(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                if IsTrue(IsEqual(marketType, "spot")) {
                    
        response = (<-this.PrivateGetSpotHistoryOrder(this.Extend(request, params)))
                    PanicOnError(response)
                } else if IsTrue(IsEqual(marketType, "swap")) {
                    
        response = (<-this.PrivateGetFuturesHistoryOrder(this.Extend(request, params)))
                    PanicOnError(response)
                } else if IsTrue(IsEqual(marketType, "margin")) {
                    
        response = (<-this.PrivateGetMarginHistoryOrder(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    panic(NotSupported(Add(this.Id, " fetchOrder() not support this market type")))
                }
            }
            //
            //     [
            //       {
            //         "id": "685965182082",
            //         "client_order_id": "B3CBm9uGg9oYQlw96bBSEt38-6gbgBO0",
            //         "symbol": "BTCUSDT",
            //         "side": "buy",
            //         "status": "new",
            //         "type": "limit",
            //         "time_in_force": "GTC",
            //         "quantity": "0.00010",
            //         "quantity_cumulative": "0",
            //         "price": "50000.00",
            //         "price_average": "0",
            //         "created_at": "2021-10-26T11:40:09.287Z",
            //         "updated_at": "2021-10-26T11:40:09.287Z"
            //       }
            //     ]
            //
            var order interface{} = this.SafeDict(response, 0)
        
            ch <- this.ParseOrder(order, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hitbtc#fetchOrderTrades
 * @description fetch all the trades made from a single order
 * @see https://api.hitbtc.com/#spot-trades-history
 * @see https://api.hitbtc.com/#futures-trades-history
 * @see https://api.hitbtc.com/#margin-trades-history
 * @param {string} id order id
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] 'cross' or 'isolated' only 'isolated' is supported
 * @param {bool} [params.margin] true for fetching margin trades
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *hitbtc) FetchOrderTrades(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes20618 := (<-this.LoadMarkets())
            PanicOnError(retRes20618)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var request interface{} = map[string]interface{} {
                "order_id": id,
            }
            var marketType interface{} = nil
            var marginMode interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchOrderTrades", market, params);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            marginModeparamsVariable := this.HandleMarginModeAndParams("fetchOrderTrades", params);
            marginMode = GetValue(marginModeparamsVariable,0);
            params = GetValue(marginModeparamsVariable,1)
            params = this.Omit(params, []interface{}{"marginMode", "margin"})
            var response interface{} = nil
            if IsTrue(!IsEqual(marginMode, nil)) {
                
        response = (<-this.PrivateGetMarginHistoryTrade(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                if IsTrue(IsEqual(marketType, "spot")) {
                    
        response = (<-this.PrivateGetSpotHistoryTrade(this.Extend(request, params)))
                    PanicOnError(response)
                } else if IsTrue(IsEqual(marketType, "swap")) {
                    
        response = (<-this.PrivateGetFuturesHistoryTrade(this.Extend(request, params)))
                    PanicOnError(response)
                } else if IsTrue(IsEqual(marketType, "margin")) {
                    
        response = (<-this.PrivateGetMarginHistoryTrade(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    panic(NotSupported(Add(this.Id, " fetchOrderTrades() not support this market type")))
                }
            }
        
                //
            // Spot
            //
            //     [
            //       {
            //         "id": 1393448977,
            //         "order_id": 653496804534,
            //         "client_order_id": "065f6f0ff9d54547848454182263d7b4",
            //         "symbol": "DICEETH",
            //         "side": "buy",
            //         "quantity": "1.4",
            //         "price": "0.00261455",
            //         "fee": "0.000003294333",
            //         "timestamp": "2021-09-19T05:35:56.601Z",
            //         "taker": true
            //       }
            //     ]
            //
            // Swap and Margin
            //
            //     [
            //         {
            //             "id": 4718551,
            //             "order_id": 58730748700,
            //             "client_order_id": "dcbcd8549e3445ee922665946002ef67",
            //             "symbol": "BTCUSDT_PERP",
            //             "side": "buy",
            //             "quantity": "0.0001",
            //             "price": "41095.96",
            //             "fee": "0.002054798000",
            //             "timestamp": "2022-03-17T05:23:02.217Z",
            //             "taker": true,
            //             "position_id": 2350122,
            //             "pnl": "0",
            //             "liquidation": false
            //         }
            //     ]
            //
        ch <- this.ParseTrades(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hitbtc#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://api.hitbtc.com/#get-all-active-spot-orders
 * @see https://api.hitbtc.com/#get-active-futures-orders
 * @see https://api.hitbtc.com/#get-active-margin-orders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] 'cross' or 'isolated' only 'isolated' is supported
 * @param {bool} [params.margin] true for fetching open margin orders
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *hitbtc) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes21458 := (<-this.LoadMarkets())
            PanicOnError(retRes21458)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            var marketType interface{} = nil
            var marginMode interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchOpenOrders", market, params);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            marginModeparamsVariable := this.HandleMarginModeAndParams("fetchOpenOrders", params);
            marginMode = GetValue(marginModeparamsVariable,0);
            params = GetValue(marginModeparamsVariable,1)
            params = this.Omit(params, []interface{}{"marginMode", "margin"})
            var response interface{} = nil
            if IsTrue(!IsEqual(marginMode, nil)) {
                
        response = (<-this.PrivateGetMarginOrder(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                if IsTrue(IsEqual(marketType, "spot")) {
                    
        response = (<-this.PrivateGetSpotOrder(this.Extend(request, params)))
                    PanicOnError(response)
                } else if IsTrue(IsEqual(marketType, "swap")) {
                    
        response = (<-this.PrivateGetFuturesOrder(this.Extend(request, params)))
                    PanicOnError(response)
                } else if IsTrue(IsEqual(marketType, "margin")) {
                    
        response = (<-this.PrivateGetMarginOrder(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    panic(NotSupported(Add(this.Id, " fetchOpenOrders() not support this market type")))
                }
            }
        
                //
            //     [
            //       {
            //         "id": "488953123149",
            //         "client_order_id": "103ad305301e4c3590045b13de15b36e",
            //         "symbol": "BTCUSDT",
            //         "side": "buy",
            //         "status": "new",
            //         "type": "limit",
            //         "time_in_force": "GTC",
            //         "quantity": "0.00001",
            //         "quantity_cumulative": "0",
            //         "price": "0.01",
            //         "post_only": false,
            //         "created_at": "2021-04-13T13:06:16.567Z",
            //         "updated_at": "2021-04-13T13:06:16.567Z"
            //       }
            //     ]
            //
        ch <- this.ParseOrders(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hitbtc#fetchOpenOrder
 * @description fetch an open order by it's id
 * @see https://api.hitbtc.com/#get-active-spot-order
 * @see https://api.hitbtc.com/#get-active-futures-order
 * @see https://api.hitbtc.com/#get-active-margin-order
 * @param {string} id order id
 * @param {string} symbol unified market symbol, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] 'cross' or 'isolated' only 'isolated' is supported
 * @param {bool} [params.margin] true for fetching an open margin order
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *hitbtc) FetchOpenOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes22088 := (<-this.LoadMarkets())
            PanicOnError(retRes22088)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var request interface{} = map[string]interface{} {
                "client_order_id": id,
            }
            var marketType interface{} = nil
            var marginMode interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchOpenOrder", market, params);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            marginModeparamsVariable := this.HandleMarginModeAndParams("fetchOpenOrder", params);
            marginMode = GetValue(marginModeparamsVariable,0);
            params = GetValue(marginModeparamsVariable,1)
            params = this.Omit(params, []interface{}{"marginMode", "margin"})
            var response interface{} = nil
            if IsTrue(!IsEqual(marginMode, nil)) {
                
        response = (<-this.PrivateGetMarginOrderClientOrderId(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                if IsTrue(IsEqual(marketType, "spot")) {
                    
        response = (<-this.PrivateGetSpotOrderClientOrderId(this.Extend(request, params)))
                    PanicOnError(response)
                } else if IsTrue(IsEqual(marketType, "swap")) {
                    
        response = (<-this.PrivateGetFuturesOrderClientOrderId(this.Extend(request, params)))
                    PanicOnError(response)
                } else if IsTrue(IsEqual(marketType, "margin")) {
                    
        response = (<-this.PrivateGetMarginOrderClientOrderId(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    panic(NotSupported(Add(this.Id, " fetchOpenOrder() not support this market type")))
                }
            }
        
            ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hitbtc#cancelAllOrders
 * @description cancel all open orders
 * @see https://api.hitbtc.com/#cancel-all-spot-orders
 * @see https://api.hitbtc.com/#cancel-futures-orders
 * @see https://api.hitbtc.com/#cancel-all-margin-orders
 * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] 'cross' or 'isolated' only 'isolated' is supported
 * @param {bool} [params.margin] true for canceling margin orders
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *hitbtc) CancelAllOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes22528 := (<-this.LoadMarkets())
            PanicOnError(retRes22528)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            var marketType interface{} = nil
            var marginMode interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("cancelAllOrders", market, params);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            marginModeparamsVariable := this.HandleMarginModeAndParams("cancelAllOrders", params);
            marginMode = GetValue(marginModeparamsVariable,0);
            params = GetValue(marginModeparamsVariable,1)
            params = this.Omit(params, []interface{}{"marginMode", "margin"})
            var response interface{} = nil
            if IsTrue(!IsEqual(marginMode, nil)) {
                
        response = (<-this.PrivateDeleteMarginOrder(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                if IsTrue(IsEqual(marketType, "spot")) {
                    
        response = (<-this.PrivateDeleteSpotOrder(this.Extend(request, params)))
                    PanicOnError(response)
                } else if IsTrue(IsEqual(marketType, "swap")) {
                    
        response = (<-this.PrivateDeleteFuturesOrder(this.Extend(request, params)))
                    PanicOnError(response)
                } else if IsTrue(IsEqual(marketType, "margin")) {
                    
        response = (<-this.PrivateDeleteMarginOrder(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    panic(NotSupported(Add(this.Id, " cancelAllOrders() not support this market type")))
                }
            }
        
            ch <- this.ParseOrders(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hitbtc#cancelOrder
 * @description cancels an open order
 * @see https://api.hitbtc.com/#cancel-spot-order
 * @see https://api.hitbtc.com/#cancel-futures-order
 * @see https://api.hitbtc.com/#cancel-margin-order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] 'cross' or 'isolated' only 'isolated' is supported
 * @param {bool} [params.margin] true for canceling a margin order
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *hitbtc) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes22968 := (<-this.LoadMarkets())
            PanicOnError(retRes22968)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {
                "client_order_id": id,
            }
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var marketType interface{} = nil
            var marginMode interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("cancelOrder", market, params);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            marginModeparamsVariable := this.HandleMarginModeAndParams("cancelOrder", params);
            marginMode = GetValue(marginModeparamsVariable,0);
            params = GetValue(marginModeparamsVariable,1)
            params = this.Omit(params, []interface{}{"marginMode", "margin"})
            var response interface{} = nil
            if IsTrue(!IsEqual(marginMode, nil)) {
                
        response = (<-this.PrivateDeleteMarginOrderClientOrderId(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                if IsTrue(IsEqual(marketType, "spot")) {
                    
        response = (<-this.PrivateDeleteSpotOrderClientOrderId(this.Extend(request, params)))
                    PanicOnError(response)
                } else if IsTrue(IsEqual(marketType, "swap")) {
                    
        response = (<-this.PrivateDeleteFuturesOrderClientOrderId(this.Extend(request, params)))
                    PanicOnError(response)
                } else if IsTrue(IsEqual(marketType, "margin")) {
                    
        response = (<-this.PrivateDeleteMarginOrderClientOrderId(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    panic(NotSupported(Add(this.Id, " cancelOrder() not support this market type")))
                }
            }
        
            ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
func  (this *hitbtc) EditOrder(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    amount := GetArg(optionalArgs, 0, nil)
            _ = amount
            price := GetArg(optionalArgs, 1, nil)
            _ = price
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes23278 := (<-this.LoadMarkets())
            PanicOnError(retRes23278)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {
                "client_order_id": id,
                "quantity": this.AmountToPrecision(symbol, amount),
            }
            if IsTrue(IsTrue((IsEqual(typeVar, "limit"))) || IsTrue((IsEqual(typeVar, "stopLimit")))) {
                if IsTrue(IsEqual(price, nil)) {
                    panic(ExchangeError(Add(this.Id, " editOrder() limit order requires price")))
                }
                AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
            }
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var marketType interface{} = nil
            var marginMode interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("editOrder", market, params);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            marginModeparamsVariable := this.HandleMarginModeAndParams("editOrder", params);
            marginMode = GetValue(marginModeparamsVariable,0);
            params = GetValue(marginModeparamsVariable,1)
            params = this.Omit(params, []interface{}{"marginMode", "margin"})
            var response interface{} = nil
            if IsTrue(!IsEqual(marginMode, nil)) {
                
        response = (<-this.PrivatePatchMarginOrderClientOrderId(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                if IsTrue(IsEqual(marketType, "spot")) {
                    
        response = (<-this.PrivatePatchSpotOrderClientOrderId(this.Extend(request, params)))
                    PanicOnError(response)
                } else if IsTrue(IsEqual(marketType, "swap")) {
                    
        response = (<-this.PrivatePatchFuturesOrderClientOrderId(this.Extend(request, params)))
                    PanicOnError(response)
                } else if IsTrue(IsEqual(marketType, "margin")) {
                    
        response = (<-this.PrivatePatchMarginOrderClientOrderId(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    panic(NotSupported(Add(this.Id, " editOrder() not support this market type")))
                }
            }
        
            ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hitbtc#createOrder
 * @description create a trade order
 * @see https://api.hitbtc.com/#create-new-spot-order
 * @see https://api.hitbtc.com/#create-margin-order
 * @see https://api.hitbtc.com/#create-futures-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] 'cross' or 'isolated' only 'isolated' is supported for spot-margin, swap supports both, default is 'cross'
 * @param {bool} [params.margin] true for creating a margin order
 * @param {float} [params.triggerPrice] The price at which a trigger order is triggered at
 * @param {bool} [params.postOnly] if true, the order will only be posted to the order book and not executed immediately
 * @param {string} [params.timeInForce] "GTC", "IOC", "FOK", "Day", "GTD"
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *hitbtc) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes23858 := (<-this.LoadMarkets())
            PanicOnError(retRes23858)
            var market interface{} = this.Market(symbol)
            var request interface{} = nil
            var marketType interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("createOrder", market, params);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            var marginMode interface{} = nil
            marginModeparamsVariable := this.HandleMarginModeAndParams("createOrder", params);
            marginMode = GetValue(marginModeparamsVariable,0);
            params = GetValue(marginModeparamsVariable,1)
            requestparamsVariable := this.CreateOrderRequest(market, marketType, typeVar, side, amount, price, marginMode, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
            var response interface{} = nil
            if IsTrue(IsEqual(marketType, "swap")) {
                
        response = (<-this.PrivatePostFuturesOrder(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(IsTrue((IsEqual(marketType, "margin"))) || IsTrue((!IsEqual(marginMode, nil)))) {
                
        response = (<-this.PrivatePostMarginOrder(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PrivatePostSpotOrder(this.Extend(request, params)))
                PanicOnError(response)
            }
        
            ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
func  (this *hitbtc) CreateOrderRequest(market interface{}, marketType interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    price := GetArg(optionalArgs, 0, nil)
    _ = price
    marginMode := GetArg(optionalArgs, 1, nil)
    _ = marginMode
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    var isLimit interface{} =     (IsEqual(typeVar, "limit"))
    var reduceOnly interface{} = this.SafeValue(params, "reduceOnly")
    var timeInForce interface{} = this.SafeString(params, "timeInForce")
    var triggerPrice interface{} = this.SafeNumberN(params, []interface{}{"triggerPrice", "stopPrice", "stop_price"})
    var isPostOnly interface{} = this.IsPostOnly(IsEqual(typeVar, "market"), nil, params)
    var request interface{} = map[string]interface{} {
        "type": typeVar,
        "side": side,
        "quantity": this.AmountToPrecision(GetValue(market, "symbol"), amount),
        "symbol": GetValue(market, "id"),
    }
    if IsTrue(!IsEqual(reduceOnly, nil)) {
        if IsTrue(IsTrue((!IsEqual(GetValue(market, "type"), "swap"))) && IsTrue((!IsEqual(GetValue(market, "type"), "margin")))) {
            panic(InvalidOrder(Add(Add(Add(this.Id, " createOrder() does not support reduce_only for "), GetValue(market, "type")), " orders, reduce_only orders are supported for swap and margin markets only")))
        }
    }
    if IsTrue(IsEqual(reduceOnly, true)) {
        AddElementToObject(request, "reduce_only", reduceOnly)
    }
    if IsTrue(isPostOnly) {
        AddElementToObject(request, "post_only", true)
    }
    if IsTrue(!IsEqual(timeInForce, nil)) {
        AddElementToObject(request, "time_in_force", timeInForce)
    }
    if IsTrue(IsTrue(IsTrue(isLimit) || IsTrue((IsEqual(typeVar, "stopLimit")))) || IsTrue((IsEqual(typeVar, "takeProfitLimit")))) {
        if IsTrue(IsEqual(price, nil)) {
            panic(ExchangeError(Add(this.Id, " createOrder() requires a price argument for limit orders")))
        }
        AddElementToObject(request, "price", this.PriceToPrecision(GetValue(market, "symbol"), price))
    }
    if IsTrue((IsEqual(timeInForce, "GTD"))) {
        var expireTime interface{} = this.SafeString(params, "expire_time")
        if IsTrue(IsEqual(expireTime, nil)) {
            panic(ExchangeError(Add(this.Id, " createOrder() requires an expire_time parameter for a GTD order")))
        }
    }
    if IsTrue(!IsEqual(triggerPrice, nil)) {
        AddElementToObject(request, "stop_price", this.PriceToPrecision(GetValue(market, "symbol"), triggerPrice))
        if IsTrue(isLimit) {
            AddElementToObject(request, "type", "stopLimit")
        } else if IsTrue(IsEqual(typeVar, "market")) {
            AddElementToObject(request, "type", "stopMarket")
        }
    } else if IsTrue(IsTrue(IsTrue(IsTrue((IsEqual(typeVar, "stopLimit"))) || IsTrue((IsEqual(typeVar, "stopMarket")))) || IsTrue((IsEqual(typeVar, "takeProfitLimit")))) || IsTrue((IsEqual(typeVar, "takeProfitMarket")))) {
        panic(ExchangeError(Add(this.Id, " createOrder() requires a triggerPrice parameter for stop-loss and take-profit orders")))
    }
    params = this.Omit(params, []interface{}{"triggerPrice", "timeInForce", "stopPrice", "stop_price", "reduceOnly", "postOnly"})
    if IsTrue(IsEqual(marketType, "swap")) {
        // set default margin mode to cross
        if IsTrue(IsEqual(marginMode, nil)) {
            marginMode = "cross"
        }
        AddElementToObject(request, "margin_mode", marginMode)
    }
    return []interface{}{request, params}
}
func  (this *hitbtc) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "new": "open",
        "suspended": "open",
        "partiallyFilled": "open",
        "filled": "closed",
        "canceled": "canceled",
        "expired": "failed",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *hitbtc) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // limit
    //     {
    //       "id": 488953123149,
    //       "client_order_id": "103ad305301e4c3590045b13de15b36e",
    //       "symbol": "BTCUSDT",
    //       "side": "buy",
    //       "status": "new",
    //       "type": "limit",
    //       "time_in_force": "GTC",
    //       "quantity": "0.00001",
    //       "quantity_cumulative": "0",
    //       "price": "0.01",
    //       "price_average": "0.01",
    //       "post_only": false,
    //       "created_at": "2021-04-13T13:06:16.567Z",
    //       "updated_at": "2021-04-13T13:06:16.567Z"
    //     }
    //
    // market
    //     {
    //       "id": "685877626834",
    //       "client_order_id": "Yshl7G-EjaREyXQYaGbsmdtVbW-nzQwu",
    //       "symbol": "BTCUSDT",
    //       "side": "buy",
    //       "status": "filled",
    //       "type": "market",
    //       "time_in_force": "GTC",
    //       "quantity": "0.00010",
    //       "quantity_cumulative": "0.00010",
    //       "post_only": false,
    //       "created_at": "2021-10-26T08:55:55.1Z",
    //       "updated_at": "2021-10-26T08:55:55.1Z",
    //       "trades": [
    //         {
    //           "id": "1437229630",
    //           "position_id": "0",
    //           "quantity": "0.00010",
    //           "price": "62884.78",
    //           "fee": "0.005659630200",
    //           "timestamp": "2021-10-26T08:55:55.1Z",
    //           "taker": true
    //         }
    //       ]
    //     }
    //
    // swap and margin
    //
    //     {
    //         "id": 58418961892,
    //         "client_order_id": "r42gdPjNMZN-H_xs8RKl2wljg_dfgdg4",
    //         "symbol": "BTCUSDT_PERP",
    //         "side": "buy",
    //         "status": "new",
    //         "type": "limit",
    //         "time_in_force": "GTC",
    //         "quantity": "0.0005",
    //         "quantity_cumulative": "0",
    //         "price": "30000.00",
    //         "post_only": false,
    //         "reduce_only": false,
    //         "created_at": "2022-03-16T08:16:53.039Z",
    //         "updated_at": "2022-03-16T08:16:53.039Z"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeString(order, "client_order_id")
    // we use clientOrderId as the order id with this exchange intentionally
    // because most of their endpoints will require clientOrderId
    // explained here: https://github.com/ccxt/ccxt/issues/5674
    var side interface{} = this.SafeString(order, "side")
    var typeVar interface{} = this.SafeString(order, "type")
    var amount interface{} = this.SafeString(order, "quantity")
    var price interface{} = this.SafeString(order, "price")
    var average interface{} = this.SafeString(order, "price_average")
    var created interface{} = this.SafeString(order, "created_at")
    var timestamp interface{} = this.Parse8601(created)
    var updated interface{} = this.SafeString(order, "updated_at")
    var lastTradeTimestamp interface{} = nil
    if IsTrue(!IsEqual(updated, created)) {
        lastTradeTimestamp = this.Parse8601(updated)
    }
    var filled interface{} = this.SafeString(order, "quantity_cumulative")
    var status interface{} = this.ParseOrderStatus(this.SafeString(order, "status"))
    var marketId interface{} = this.SafeString(order, "symbol")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = GetValue(market, "symbol")
    var postOnly interface{} = this.SafeValue(order, "post_only")
    var timeInForce interface{} = this.SafeString(order, "time_in_force")
    var rawTrades interface{} = this.SafeValue(order, "trades")
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": id,
        "clientOrderId": id,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": lastTradeTimestamp,
        "lastUpdateTimestamp": lastTradeTimestamp,
        "symbol": symbol,
        "price": price,
        "amount": amount,
        "type": typeVar,
        "side": side,
        "timeInForce": timeInForce,
        "postOnly": postOnly,
        "reduceOnly": this.SafeValue(order, "reduce_only"),
        "filled": filled,
        "remaining": nil,
        "cost": nil,
        "status": status,
        "average": average,
        "trades": rawTrades,
        "fee": nil,
        "triggerPrice": this.SafeString(order, "stop_price"),
        "takeProfitPrice": nil,
        "stopLossPrice": nil,
    }, market)
}
/**
 * @method
 * @name hitbtc#fetchMarginModes
 * @description fetches margin mode of the user
 * @see https://api.hitbtc.com/#get-margin-position-parameters
 * @see https://api.hitbtc.com/#get-futures-position-parameters
 * @param {string[]} symbols unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [margin mode structures]{@link https://docs.ccxt.com/#/?id=margin-mode-structure}
 */
func  (this *hitbtc) FetchMarginModes(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes26168 := (<-this.LoadMarkets())
            PanicOnError(retRes26168)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbols, nil)) {
                symbols = this.MarketSymbols(symbols)
                market = this.Market(GetValue(symbols, 0))
            }
            var marketType interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchMarginMode", market, params);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            var response interface{} = nil
            if IsTrue(IsEqual(marketType, "margin")) {
                
        response = (<-this.PrivateGetMarginConfig(params))
                PanicOnError(response)
            } else if IsTrue(IsEqual(marketType, "swap")) {
                
        response = (<-this.PrivateGetFuturesConfig(params))
                PanicOnError(response)
            } else {
                panic(BadSymbol(Add(this.Id, " fetchMarginModes () supports swap contracts and margin only")))
            }
            var config interface{} = this.SafeList(response, "config", []interface{}{})
        
            ch <- this.ParseMarginModes(config, symbols, "symbol")
            return nil
        
            }()
            return ch
        }
func  (this *hitbtc) ParseMarginMode(marginMode interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(marginMode, "symbol")
    return map[string]interface{} {
        "info": marginMode,
        "symbol": this.SafeSymbol(marketId, market),
        "marginMode": this.SafeStringLower(marginMode, "margin_mode"),
    }
}
/**
 * @method
 * @name hitbtc#transfer
 * @description transfer currency internally between wallets on the same account
 * @see https://api.hitbtc.com/#transfer-between-wallet-and-exchange
 * @param {string} code unified currency code
 * @param {float} amount amount to transfer
 * @param {string} fromAccount account to transfer from
 * @param {string} toAccount account to transfer to
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func  (this *hitbtc) Transfer(code interface{}, amount interface{}, fromAccount interface{}, toAccount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    // account can be "spot", "wallet", or "derivatives"
            params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes26938 := (<-this.LoadMarkets())
            PanicOnError(retRes26938)
            var currency interface{} = this.Currency(code)
            var requestAmount interface{} = this.CurrencyToPrecision(code, amount)
            var accountsByType interface{} = this.SafeValue(this.Options, "accountsByType", map[string]interface{} {})
            fromAccount = ToLower(fromAccount)
            toAccount = ToLower(toAccount)
            var fromId interface{} = this.SafeString(accountsByType, fromAccount, fromAccount)
            var toId interface{} = this.SafeString(accountsByType, toAccount, toAccount)
            if IsTrue(IsEqual(fromId, toId)) {
                panic(BadRequest(Add(this.Id, " transfer() fromAccount and toAccount arguments cannot be the same account")))
            }
            var request interface{} = map[string]interface{} {
                "currency": GetValue(currency, "id"),
                "amount": requestAmount,
                "source": fromId,
                "destination": toId,
            }
        
            response:= (<-this.PrivatePostWalletTransfer(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         "2db6ebab-fb26-4537-9ef8-1a689472d236"
            //     ]
            //
        ch <- this.ParseTransfer(response, currency)
            return nil
        
            }()
            return ch
        }
func  (this *hitbtc) ParseTransfer(transfer interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // transfer
    //
    //     [
    //         "2db6ebab-fb26-4537-9ef8-1a689472d236"
    //     ]
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    return map[string]interface{} {
        "id": this.SafeString(transfer, 0),
        "timestamp": nil,
        "datetime": nil,
        "currency": this.SafeCurrencyCode(nil, currency),
        "amount": nil,
        "fromAccount": nil,
        "toAccount": nil,
        "status": nil,
        "info": transfer,
    }
}
func  (this *hitbtc) ConvertCurrencyNetwork(code interface{}, amount interface{}, fromNetwork interface{}, toNetwork interface{}, params interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                
            retRes27418 := (<-this.LoadMarkets())
            PanicOnError(retRes27418)
            if IsTrue(!IsEqual(code, "USDT")) {
                panic(ExchangeError(Add(this.Id, " convertCurrencyNetwork() only supports USDT currently")))
            }
            var networks interface{} = this.SafeValue(this.Options, "networks", map[string]interface{} {})
            fromNetwork = ToUpper(fromNetwork)
            toNetwork = ToUpper(toNetwork)
            fromNetwork = this.SafeString(networks, fromNetwork) // handle ETH>ERC20 alias
            toNetwork = this.SafeString(networks, toNetwork) // handle ETH>ERC20 alias
            if IsTrue(IsEqual(fromNetwork, toNetwork)) {
                panic(BadRequest(Add(this.Id, " convertCurrencyNetwork() fromNetwork cannot be the same as toNetwork")))
            }
            if IsTrue(IsTrue((IsEqual(fromNetwork, nil))) || IsTrue((IsEqual(toNetwork, nil)))) {
                var keys interface{} = ObjectKeys(networks)
                panic(ArgumentsRequired(Add(Add(this.Id, " convertCurrencyNetwork() requires a fromNetwork parameter and a toNetwork parameter, supported networks are "), Join(keys, ", "))))
            }
            var request interface{} = map[string]interface{} {
                "from_currency": fromNetwork,
                "to_currency": toNetwork,
                "amount": this.CurrencyToPrecision(code, amount),
            }
        
            response:= (<-this.PrivatePostWalletConvert(this.Extend(request, params)))
            PanicOnError(response)
        
                // {"result":["587a1868-e62d-4d8e-b27c-dbdb2ee96149","e168df74-c041-41f2-b76c-e43e4fed5bc7"]}
        ch <- map[string]interface{} {
                "info": response,
            }
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hitbtc#withdraw
 * @description make a withdrawal
 * @see https://api.hitbtc.com/#withdraw-crypto
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *hitbtc) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params);
            tag = GetValue(tagparamsVariable,0);
            params = GetValue(tagparamsVariable,1)
        
            retRes27838 := (<-this.LoadMarkets())
            PanicOnError(retRes27838)
            this.CheckAddress(address)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "currency": GetValue(currency, "id"),
                "amount": amount,
                "address": address,
            }
            if IsTrue(!IsEqual(tag, nil)) {
                AddElementToObject(request, "payment_id", tag)
            }
            var networks interface{} = this.SafeValue(this.Options, "networks", map[string]interface{} {})
            var network interface{} = this.SafeStringUpper(params, "network")
            if IsTrue(IsTrue((!IsEqual(network, nil))) && IsTrue((IsEqual(code, "USDT")))) {
                var parsedNetwork interface{} = this.SafeString(networks, network)
                if IsTrue(!IsEqual(parsedNetwork, nil)) {
                    AddElementToObject(request, "network_code", parsedNetwork)
                }
                params = this.Omit(params, "network")
            }
            var withdrawOptions interface{} = this.SafeValue(this.Options, "withdraw", map[string]interface{} {})
            var includeFee interface{} = this.SafeBool(withdrawOptions, "includeFee", false)
            if IsTrue(includeFee) {
                AddElementToObject(request, "include_fee", true)
            }
        
            response:= (<-this.PrivatePostWalletCryptoWithdraw(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "id":"084cfcd5-06b9-4826-882e-fdb75ec3625d"
            //     }
            //
        ch <- this.ParseTransaction(response, currency)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hitbtc#fetchFundingRates
 * @description fetches funding rates for multiple markets
 * @see https://api.hitbtc.com/#futures-info
 * @param {string[]} symbols unified symbols of the markets to fetch the funding rates for, all market funding rates are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
 */
func  (this *hitbtc) FetchFundingRates(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes28278 := (<-this.LoadMarkets())
            PanicOnError(retRes28278)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbols, nil)) {
                symbols = this.MarketSymbols(symbols)
                market = this.Market(GetValue(symbols, 0))
                var queryMarketIds interface{} = this.MarketIds(symbols)
                AddElementToObject(request, "symbols", Join(queryMarketIds, ","))
            }
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchFundingRates", market, params);
            typeVar = GetValue(typeVarparamsVariable,0);
            params = GetValue(typeVarparamsVariable,1)
            if IsTrue(!IsEqual(typeVar, "swap")) {
                panic(NotSupported(Add(Add(Add(this.Id, " fetchFundingRates() does not support "), typeVar), " markets")))
            }
        
            response:= (<-this.PublicGetPublicFuturesInfo(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "BTCUSDT_PERP": {
            //             "contract_type": "perpetual",
            //             "mark_price": "30897.68",
            //             "index_price": "30895.29",
            //             "funding_rate": "0.0001",
            //             "open_interest": "93.7128",
            //             "next_funding_time": "2021-07-21T16:00:00.000Z",
            //             "indicative_funding_rate": "0.0001",
            //             "premium_index": "0.000047541807127312",
            //             "avg_premium_index": "0.000087063368020112",
            //             "interest_rate": "0.0001",
            //             "timestamp": "2021-07-21T09:48:37.235Z"
            //         }
            //     }
            //
            var marketIds interface{} = ObjectKeys(response)
            var fundingRates interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(marketIds)); i++ {
                var marketId interface{} = this.SafeString(marketIds, i)
                var rawFundingRate interface{} = this.SafeValue(response, marketId)
                var marketInner interface{} = this.Market(marketId)
                var symbol interface{} = GetValue(marketInner, "symbol")
                var fundingRate interface{} = this.ParseFundingRate(rawFundingRate, marketInner)
                AddElementToObject(fundingRates, symbol, fundingRate)
            }
        
            ch <- this.FilterByArray(fundingRates, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hitbtc#fetchFundingRateHistory
 * @see https://api.hitbtc.com/#funding-history
 * @description fetches historical funding rate prices
 * @param {string} symbol unified symbol of the market to fetch the funding rate history for
 * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
 * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure} to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest funding rate
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
 */
func  (this *hitbtc) FetchFundingRateHistory(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes28868 := (<-this.LoadMarkets())
            PanicOnError(retRes28868)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchFundingRateHistory", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes289019 :=  (<-this.FetchPaginatedCallDeterministic("fetchFundingRateHistory", symbol, since, limit, "8h", params, 1000))
                    PanicOnError(retRes289019)
                    ch <- retRes289019
                    return nil
            }
            var market interface{} = nil
            var request interface{} = map[string]interface{} {}
            requestparamsVariable := this.HandleUntilOption("until", request, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                symbol = GetValue(market, "symbol")
                AddElementToObject(request, "symbols", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "from", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.PublicGetPublicFuturesHistoryFunding(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "BTCUSDT_PERP": [
            //            {
            //                "timestamp": "2021-07-29T16:00:00.271Z",
            //                "funding_rate": "0.0001",
            //                "avg_premium_index": "0.000061858585213222",
            //                "next_funding_time": "2021-07-30T00:00:00.000Z",
            //                "interest_rate": "0.0001"
            //            },
            //            ...
            //        ],
            //        ...
            //    }
            //
            var contracts interface{} = ObjectKeys(response)
            var rates interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(contracts)); i++ {
                var marketId interface{} = GetValue(contracts, i)
                var marketInner interface{} = this.SafeMarket(marketId)
                var fundingRateData interface{} = GetValue(response, marketId)
                for j := 0; IsLessThan(j, GetArrayLength(fundingRateData)); j++ {
                    var entry interface{} = GetValue(fundingRateData, j)
                    var symbolInner interface{} = this.SafeSymbol(GetValue(marketInner, "symbol"))
                    var fundingRate interface{} = this.SafeNumber(entry, "funding_rate")
                    var datetime interface{} = this.SafeString(entry, "timestamp")
                    AppendToArray(&rates,map[string]interface{} {
                        "info": entry,
                        "symbol": symbolInner,
                        "fundingRate": fundingRate,
                        "timestamp": this.Parse8601(datetime),
                        "datetime": datetime,
                    })
                }
            }
            var sorted interface{} = this.SortBy(rates, "timestamp")
        
            ch <- this.FilterBySymbolSinceLimit(sorted, symbol, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hitbtc#fetchPositions
 * @description fetch all open positions
 * @see https://api.hitbtc.com/#get-futures-margin-accounts
 * @see https://api.hitbtc.com/#get-all-margin-accounts
 * @param {string[]|undefined} symbols not used by hitbtc fetchPositions ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] 'cross' or 'isolated' only 'isolated' is supported, defaults to spot-margin endpoint if this is set
 * @param {bool} [params.margin] true for fetching spot-margin positions
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *hitbtc) FetchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes29678 := (<-this.LoadMarkets())
            PanicOnError(retRes29678)
            var request interface{} = map[string]interface{} {}
            var marketType interface{} = nil
            var marginMode interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchPositions", nil, params);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            if IsTrue(IsEqual(marketType, "spot")) {
                marketType = "swap"
            }
            marginModeparamsVariable := this.HandleMarginModeAndParams("fetchPositions", params);
            marginMode = GetValue(marginModeparamsVariable,0);
            params = GetValue(marginModeparamsVariable,1)
            params = this.Omit(params, []interface{}{"marginMode", "margin"})
            var response interface{} = nil
            if IsTrue(!IsEqual(marginMode, nil)) {
                
        response = (<-this.PrivateGetMarginAccount(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                if IsTrue(IsEqual(marketType, "swap")) {
                    
        response = (<-this.PrivateGetFuturesAccount(this.Extend(request, params)))
                    PanicOnError(response)
                } else if IsTrue(IsEqual(marketType, "margin")) {
                    
        response = (<-this.PrivateGetMarginAccount(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    panic(NotSupported(Add(this.Id, " fetchPositions() not support this market type")))
                }
            }
            //
            //     [
            //         {
            //             "symbol": "ETHUSDT_PERP",
            //             "type": "isolated",
            //             "leverage": "10.00",
            //             "created_at": "2022-03-19T07:54:35.24Z",
            //             "updated_at": "2022-03-19T07:54:58.922Z",
            //             currencies": [
            //                 {
            //                     "code": "USDT",
            //                     "margin_balance": "7.478100643043",
            //                     "reserved_orders": "0",
            //                     "reserved_positions": "0.303530761300"
            //                 }
            //             ],
            //             "positions": [
            //                 {
            //                     "id": 2470568,
            //                     "symbol": "ETHUSDT_PERP",
            //                     "quantity": "0.001",
            //                     "price_entry": "2927.509",
            //                     "price_margin_call": "0",
            //                     "price_liquidation": "0",
            //                     "pnl": "0",
            //                     "created_at": "2022-03-19T07:54:35.24Z",
            //                     "updated_at": "2022-03-19T07:54:58.922Z"
            //                 }
            //             ]
            //         },
            //     ]
            //
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
                AppendToArray(&result,this.ParsePosition(GetValue(response, i)))
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hitbtc#fetchPosition
 * @description fetch data on a single open contract trade position
 * @see https://api.hitbtc.com/#get-futures-margin-account
 * @see https://api.hitbtc.com/#get-isolated-margin-account
 * @param {string} symbol unified market symbol of the market the position is held in, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] 'cross' or 'isolated' only 'isolated' is supported, defaults to spot-margin endpoint if this is set
 * @param {bool} [params.margin] true for fetching a spot-margin position
 * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *hitbtc) FetchPosition(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes30418 := (<-this.LoadMarkets())
            PanicOnError(retRes30418)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var marketType interface{} = nil
            var marginMode interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchPosition", nil, params);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            marginModeparamsVariable := this.HandleMarginModeAndParams("fetchPosition", params);
            marginMode = GetValue(marginModeparamsVariable,0);
            params = GetValue(marginModeparamsVariable,1)
            params = this.Omit(params, []interface{}{"marginMode", "margin"})
            var response interface{} = nil
            if IsTrue(!IsEqual(marginMode, nil)) {
                
        response = (<-this.PrivateGetMarginAccountIsolatedSymbol(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                if IsTrue(IsEqual(marketType, "swap")) {
                    
        response = (<-this.PrivateGetFuturesAccountIsolatedSymbol(this.Extend(request, params)))
                    PanicOnError(response)
                } else if IsTrue(IsEqual(marketType, "margin")) {
                    
        response = (<-this.PrivateGetMarginAccountIsolatedSymbol(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    panic(NotSupported(Add(this.Id, " fetchPosition() not support this market type")))
                }
            }
        
                //
            //     [
            //         {
            //             "symbol": "ETHUSDT_PERP",
            //             "type": "isolated",
            //             "leverage": "10.00",
            //             "created_at": "2022-03-19T07:54:35.24Z",
            //             "updated_at": "2022-03-19T07:54:58.922Z",
            //             currencies": [
            //                 {
            //                     "code": "USDT",
            //                     "margin_balance": "7.478100643043",
            //                     "reserved_orders": "0",
            //                     "reserved_positions": "0.303530761300"
            //                 }
            //             ],
            //             "positions": [
            //                 {
            //                     "id": 2470568,
            //                     "symbol": "ETHUSDT_PERP",
            //                     "quantity": "0.001",
            //                     "price_entry": "2927.509",
            //                     "price_margin_call": "0",
            //                     "price_liquidation": "0",
            //                     "pnl": "0",
            //                     "created_at": "2022-03-19T07:54:35.24Z",
            //                     "updated_at": "2022-03-19T07:54:58.922Z"
            //                 }
            //             ]
            //         },
            //     ]
            //
        ch <- this.ParsePosition(response, market)
            return nil
        
            }()
            return ch
        }
func  (this *hitbtc) ParsePosition(position interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     [
    //         {
    //             "symbol": "ETHUSDT_PERP",
    //             "type": "isolated",
    //             "leverage": "10.00",
    //             "created_at": "2022-03-19T07:54:35.24Z",
    //             "updated_at": "2022-03-19T07:54:58.922Z",
    //             currencies": [
    //                 {
    //                     "code": "USDT",
    //                     "margin_balance": "7.478100643043",
    //                     "reserved_orders": "0",
    //                     "reserved_positions": "0.303530761300"
    //                 }
    //             ],
    //             "positions": [
    //                 {
    //                     "id": 2470568,
    //                     "symbol": "ETHUSDT_PERP",
    //                     "quantity": "0.001",
    //                     "price_entry": "2927.509",
    //                     "price_margin_call": "0",
    //                     "price_liquidation": "0",
    //                     "pnl": "0",
    //                     "created_at": "2022-03-19T07:54:35.24Z",
    //                     "updated_at": "2022-03-19T07:54:58.922Z"
    //                 }
    //             ]
    //         },
    //     ]
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marginMode interface{} = this.SafeString(position, "type")
    var leverage interface{} = this.SafeNumber(position, "leverage")
    var datetime interface{} = this.SafeString(position, "updated_at")
    var positions interface{} = this.SafeValue(position, "positions", []interface{}{})
    var liquidationPrice interface{} = nil
    var entryPrice interface{} = nil
    var contracts interface{} = nil
    for i := 0; IsLessThan(i, GetArrayLength(positions)); i++ {
        var entry interface{} = GetValue(positions, i)
        liquidationPrice = this.SafeNumber(entry, "price_liquidation")
        entryPrice = this.SafeNumber(entry, "price_entry")
        contracts = this.SafeNumber(entry, "quantity")
    }
    var currencies interface{} = this.SafeValue(position, "currencies", []interface{}{})
    var collateral interface{} = nil
    for i := 0; IsLessThan(i, GetArrayLength(currencies)); i++ {
        var entry interface{} = GetValue(currencies, i)
        collateral = this.SafeNumber(entry, "margin_balance")
    }
    var marketId interface{} = this.SafeString(position, "symbol")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = GetValue(market, "symbol")
    return this.SafePosition(map[string]interface{} {
        "info": position,
        "id": nil,
        "symbol": symbol,
        "notional": nil,
        "marginMode": marginMode,
        "marginType": marginMode,
        "liquidationPrice": liquidationPrice,
        "entryPrice": entryPrice,
        "unrealizedPnl": nil,
        "percentage": nil,
        "contracts": contracts,
        "contractSize": nil,
        "markPrice": nil,
        "lastPrice": nil,
        "side": nil,
        "hedged": nil,
        "timestamp": this.Parse8601(datetime),
        "datetime": datetime,
        "lastUpdateTimestamp": nil,
        "maintenanceMargin": nil,
        "maintenanceMarginPercentage": nil,
        "collateral": collateral,
        "initialMargin": nil,
        "initialMarginPercentage": nil,
        "leverage": leverage,
        "marginRatio": nil,
        "stopLossPrice": nil,
        "takeProfitPrice": nil,
    })
}
func  (this *hitbtc) ParseOpenInterest(interest interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "contract_type": "perpetual",
    //         "mark_price": "42307.43",
    //         "index_price": "42303.27",
    //         "funding_rate": "0.0001",
    //         "open_interest": "30.9826",
    //         "next_funding_time": "2022-03-22T16:00:00.000Z",
    //         "indicative_funding_rate": "0.0001",
    //         "premium_index": "0",
    //         "avg_premium_index": "0.000029587712038098",
    //         "interest_rate": "0.0001",
    //         "timestamp": "2022-03-22T08:08:26.687Z"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var datetime interface{} = this.SafeString(interest, "timestamp")
    var value interface{} = this.SafeNumber(interest, "open_interest")
    return this.SafeOpenInterest(map[string]interface{} {
        "symbol": this.SafeSymbol(nil, market),
        "openInterestAmount": nil,
        "openInterestValue": value,
        "timestamp": this.Parse8601(datetime),
        "datetime": datetime,
        "info": interest,
    }, market)
}
/**
 * @method
 * @name hitbtc#fetchOpenInterests
 * @description Retrieves the open interest for a list of symbols
 * @see https://api.hitbtc.com/#futures-info
 * @param {string[]} [symbols] a list of unified CCXT market symbols
 * @param {object} [params] exchange specific parameters
 * @returns {object[]} a list of [open interest structures]{@link https://docs.ccxt.com/#/?id=open-interest-structure}
 */
func  (this *hitbtc) FetchOpenInterests(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes32238 := (<-this.LoadMarkets())
            PanicOnError(retRes32238)
            var request interface{} = map[string]interface{} {}
            symbols = this.MarketSymbols(symbols)
            var marketIds interface{} = nil
            if IsTrue(!IsEqual(symbols, nil)) {
                marketIds = this.MarketIds(symbols)
                AddElementToObject(request, "symbols", Join(marketIds, ","))
            }
        
            response:= (<-this.PublicGetPublicFuturesInfo(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "BTCUSDT_PERP": {
            //             "contract_type": "perpetual",
            //             "mark_price": "97291.83",
            //             "index_price": "97298.61",
            //             "funding_rate": "-0.000183473092423284",
            //             "open_interest": "94.1503",
            //             "next_funding_time": "2024-12-20T08:00:00.000Z",
            //             "indicative_funding_rate": "-0.00027495203277752",
            //             "premium_index": "-0.000789474900583786",
            //             "avg_premium_index": "-0.000683473092423284",
            //             "interest_rate": "0.0001",
            //             "timestamp": "2024-12-20T04:57:33.693Z"
            //         }
            //     }
            //
            var results interface{} = []interface{}{}
            var markets interface{} = ObjectKeys(response)
            for i := 0; IsLessThan(i, GetArrayLength(markets)); i++ {
                var marketId interface{} = GetValue(markets, i)
                var marketInner interface{} = this.SafeMarket(marketId)
                AppendToArray(&results,this.ParseOpenInterest(GetValue(response, marketId), marketInner))
            }
        
            ch <- this.FilterByArray(results, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hitbtc#fetchOpenInterest
 * @description Retrieves the open interest of a derivative trading pair
 * @see https://api.hitbtc.com/#futures-info
 * @param {string} symbol Unified CCXT market symbol
 * @param {object} [params] exchange specific parameters
 * @returns {object} an open interest structure{@link https://docs.ccxt.com/#/?id=interest-history-structure}
 */
func  (this *hitbtc) FetchOpenInterest(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes32698 := (<-this.LoadMarkets())
            PanicOnError(retRes32698)
            var market interface{} = this.Market(symbol)
            if !IsTrue(GetValue(market, "swap")) {
                panic(BadSymbol(Add(this.Id, " fetchOpenInterest() supports swap contracts only")))
            }
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetPublicFuturesInfoSymbol(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "contract_type": "perpetual",
            //         "mark_price": "42307.43",
            //         "index_price": "42303.27",
            //         "funding_rate": "0.0001",
            //         "open_interest": "30.9826",
            //         "next_funding_time": "2022-03-22T16:00:00.000Z",
            //         "indicative_funding_rate": "0.0001",
            //         "premium_index": "0",
            //         "avg_premium_index": "0.000029587712038098",
            //         "interest_rate": "0.0001",
            //         "timestamp": "2022-03-22T08:08:26.687Z"
            //     }
            //
        ch <- this.ParseOpenInterest(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hitbtc#fetchFundingRate
 * @description fetch the current funding rate
 * @see https://api.hitbtc.com/#futures-info
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
 */
func  (this *hitbtc) FetchFundingRate(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes33068 := (<-this.LoadMarkets())
            PanicOnError(retRes33068)
            var market interface{} = this.Market(symbol)
            if !IsTrue(GetValue(market, "swap")) {
                panic(BadSymbol(Add(this.Id, " fetchFundingRate() supports swap contracts only")))
            }
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetPublicFuturesInfoSymbol(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "contract_type": "perpetual",
            //         "mark_price": "42307.43",
            //         "index_price": "42303.27",
            //         "funding_rate": "0.0001",
            //         "open_interest": "30.9826",
            //         "next_funding_time": "2022-03-22T16:00:00.000Z",
            //         "indicative_funding_rate": "0.0001",
            //         "premium_index": "0",
            //         "avg_premium_index": "0.000029587712038098",
            //         "interest_rate": "0.0001",
            //         "timestamp": "2022-03-22T08:08:26.687Z"
            //     }
            //
        ch <- this.ParseFundingRate(response, market)
            return nil
        
            }()
            return ch
        }
func  (this *hitbtc) ParseFundingRate(contract interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "contract_type": "perpetual",
    //         "mark_price": "42307.43",
    //         "index_price": "42303.27",
    //         "funding_rate": "0.0001",
    //         "open_interest": "30.9826",
    //         "next_funding_time": "2022-03-22T16:00:00.000Z",
    //         "indicative_funding_rate": "0.0001",
    //         "premium_index": "0",
    //         "avg_premium_index": "0.000029587712038098",
    //         "interest_rate": "0.0001",
    //         "timestamp": "2022-03-22T08:08:26.687Z"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var fundingDateTime interface{} = this.SafeString(contract, "next_funding_time")
    var datetime interface{} = this.SafeString(contract, "timestamp")
    return map[string]interface{} {
        "info": contract,
        "symbol": this.SafeSymbol(nil, market),
        "markPrice": this.SafeNumber(contract, "mark_price"),
        "indexPrice": this.SafeNumber(contract, "index_price"),
        "interestRate": this.SafeNumber(contract, "interest_rate"),
        "estimatedSettlePrice": nil,
        "timestamp": this.Parse8601(datetime),
        "datetime": datetime,
        "fundingRate": this.SafeNumber(contract, "funding_rate"),
        "fundingTimestamp": this.Parse8601(fundingDateTime),
        "fundingDatetime": fundingDateTime,
        "nextFundingRate": this.SafeNumber(contract, "indicative_funding_rate"),
        "nextFundingTimestamp": nil,
        "nextFundingDatetime": nil,
        "previousFundingRate": nil,
        "previousFundingTimestamp": nil,
        "previousFundingDatetime": nil,
        "interval": nil,
    }
}
func  (this *hitbtc) ModifyMarginHelper(symbol interface{}, amount interface{}, typeVar interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes33748 := (<-this.LoadMarkets())
            PanicOnError(retRes33748)
            var market interface{} = this.Market(symbol)
            var leverage interface{} = this.SafeString(params, "leverage")
            if IsTrue(GetValue(market, "swap")) {
                if IsTrue(IsEqual(leverage, nil)) {
                    panic(ArgumentsRequired(Add(this.Id, " modifyMarginHelper() requires a leverage parameter for swap markets")))
                }
            }
            var stringAmount interface{} = this.NumberToString(amount)
            if IsTrue(!IsEqual(stringAmount, "0")) {
                amount = this.AmountToPrecision(symbol, stringAmount)
            } else {
                amount = "0"
            }
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "margin_balance": amount,
            }
            if IsTrue(!IsEqual(leverage, nil)) {
                AddElementToObject(request, "leverage", leverage)
            }
            var marketType interface{} = nil
            var marginMode interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("modifyMarginHelper", market, params);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            marginModeparamsVariable := this.HandleMarginModeAndParams("modifyMarginHelper", params);
            marginMode = GetValue(marginModeparamsVariable,0);
            params = GetValue(marginModeparamsVariable,1)
            var response interface{} = nil
            if IsTrue(IsEqual(marketType, "swap")) {
                
        response = (<-this.PrivatePutFuturesAccountIsolatedSymbol(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(IsTrue(IsTrue((IsEqual(marketType, "margin"))) || IsTrue((IsEqual(marketType, "spot")))) || IsTrue((IsEqual(marginMode, "isolated")))) {
                
        response = (<-this.PrivatePutMarginAccountIsolatedSymbol(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                panic(NotSupported(Add(this.Id, " modifyMarginHelper() not support this market type")))
            }
        
                //
            //     {
            //         "symbol": "BTCUSDT_PERP",
            //         "type": "isolated",
            //         "leverage": "8.00",
            //         "created_at": "2022-03-30T23:34:27.161Z",
            //         "updated_at": "2022-03-30T23:34:27.161Z",
            //         "currencies": [
            //             {
            //                 "code": "USDT",
            //                 "margin_balance": "7.000000000000",
            //                 "reserved_orders": "0",
            //                 "reserved_positions": "0"
            //             }
            //         ],
            //         "positions": null
            //     }
            //
        ch <- this.Extend(this.ParseMarginModification(response, market), map[string]interface{} {
                "amount": this.ParseNumber(amount),
                "type": typeVar,
            })
            return nil
        
            }()
            return ch
        }
func  (this *hitbtc) ParseMarginModification(data interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // addMargin/reduceMargin
    //
    //     {
    //         "symbol": "BTCUSDT_PERP",
    //         "type": "isolated",
    //         "leverage": "8.00",
    //         "created_at": "2022-03-30T23:34:27.161Z",
    //         "updated_at": "2022-03-30T23:34:27.161Z",
    //         "currencies": [
    //             {
    //                 "code": "USDT",
    //                 "margin_balance": "7.000000000000",
    //                 "reserved_orders": "0",
    //                 "reserved_positions": "0"
    //             }
    //         ],
    //         "positions": null
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var currencies interface{} = this.SafeValue(data, "currencies", []interface{}{})
    var currencyInfo interface{} = this.SafeValue(currencies, 0)
    var datetime interface{} = this.SafeString(data, "updated_at")
    return map[string]interface{} {
        "info": data,
        "symbol": GetValue(market, "symbol"),
        "type": nil,
        "marginMode": "isolated",
        "amount": nil,
        "total": nil,
        "code": this.SafeString(currencyInfo, "code"),
        "status": nil,
        "timestamp": this.Parse8601(datetime),
        "datetime": datetime,
    }
}
/**
 * @method
 * @name hitbtc#reduceMargin
 * @description remove margin from a position
 * @see https://api.hitbtc.com/#create-update-margin-account-2
 * @see https://api.hitbtc.com/#create-update-margin-account
 * @param {string} symbol unified market symbol
 * @param {float} amount the amount of margin to remove
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] 'cross' or 'isolated' only 'isolated' is supported, defaults to the spot-margin endpoint if this is set
 * @param {bool} [params.margin] true for reducing spot-margin
 * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=reduce-margin-structure}
 */
func  (this *hitbtc) ReduceMargin(symbol interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            if IsTrue(!IsEqual(this.NumberToString(amount), "0")) {
                panic(BadRequest(Add(this.Id, " reduceMargin() on hitbtc requires the amount to be 0 and that will remove the entire margin amount")))
            }
        
                retRes348815 :=  (<-this.ModifyMarginHelper(symbol, amount, "reduce", params))
                PanicOnError(retRes348815)
                ch <- retRes348815
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hitbtc#addMargin
 * @description add margin
 * @see https://api.hitbtc.com/#create-update-margin-account-2
 * @see https://api.hitbtc.com/#create-update-margin-account
 * @param {string} symbol unified market symbol
 * @param {float} amount amount of margin to add
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] 'cross' or 'isolated' only 'isolated' is supported, defaults to the spot-margin endpoint if this is set
 * @param {bool} [params.margin] true for adding spot-margin
 * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=add-margin-structure}
 */
func  (this *hitbtc) AddMargin(symbol interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes350515 :=  (<-this.ModifyMarginHelper(symbol, amount, "add", params))
                PanicOnError(retRes350515)
                ch <- retRes350515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hitbtc#fetchLeverage
 * @description fetch the set leverage for a market
 * @see https://api.hitbtc.com/#get-futures-margin-account
 * @see https://api.hitbtc.com/#get-isolated-margin-account
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] 'cross' or 'isolated' only 'isolated' is supported, defaults to the spot-margin endpoint if this is set
 * @param {bool} [params.margin] true for fetching spot-margin leverage
 * @returns {object} a [leverage structure]{@link https://docs.ccxt.com/#/?id=leverage-structure}
 */
func  (this *hitbtc) FetchLeverage(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes35218 := (<-this.LoadMarkets())
            PanicOnError(retRes35218)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var marginMode interface{} = nil
            marginModeparamsVariable := this.HandleMarginModeAndParams("fetchLeverage", params);
            marginMode = GetValue(marginModeparamsVariable,0);
            params = GetValue(marginModeparamsVariable,1)
            params = this.Omit(params, []interface{}{"marginMode", "margin"})
            var response interface{} = nil
            if IsTrue(!IsEqual(marginMode, nil)) {
                
        response = (<-this.PrivateGetMarginAccountIsolatedSymbol(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                if IsTrue(IsEqual(GetValue(market, "type"), "spot")) {
                    
        response = (<-this.PrivateGetMarginAccountIsolatedSymbol(this.Extend(request, params)))
                    PanicOnError(response)
                } else if IsTrue(IsEqual(GetValue(market, "type"), "swap")) {
                    
        response = (<-this.PrivateGetFuturesAccountIsolatedSymbol(this.Extend(request, params)))
                    PanicOnError(response)
                } else if IsTrue(IsEqual(GetValue(market, "type"), "margin")) {
                    
        response = (<-this.PrivateGetMarginAccountIsolatedSymbol(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    panic(NotSupported(Add(this.Id, " fetchLeverage() not support this market type")))
                }
            }
        
                //
            //     {
            //         "symbol": "BTCUSDT",
            //         "type": "isolated",
            //         "leverage": "12.00",
            //         "created_at": "2022-03-29T22:31:29.067Z",
            //         "updated_at": "2022-03-30T00:00:00.125Z",
            //         "currencies": [
            //             {
            //                 "code": "USDT",
            //                 "margin_balance": "20.824360374174",
            //                 "reserved_orders": "0",
            //                 "reserved_positions": "0.973330435000"
            //             }
            //         ],
            //         "positions": [
            //             {
            //                 "id": 631301,
            //                 "symbol": "BTCUSDT",
            //                 "quantity": "0.00022",
            //                 "price_entry": "47425.57",
            //                 "price_margin_call": "",
            //                 "price_liquidation": "0",
            //                 "pnl": "0",
            //                 "created_at": "2022-03-29T22:31:29.067Z",
            //                 "updated_at": "2022-03-30T00:00:00.125Z"
            //             }
            //         ]
            //     }
            //
        ch <- this.ParseLeverage(response, market)
            return nil
        
            }()
            return ch
        }
func  (this *hitbtc) ParseLeverage(leverage interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(leverage, "symbol")
    var leverageValue interface{} = this.SafeInteger(leverage, "leverage")
    return map[string]interface{} {
        "info": leverage,
        "symbol": this.SafeSymbol(marketId, market),
        "marginMode": this.SafeStringLower(leverage, "type"),
        "longLeverage": leverageValue,
        "shortLeverage": leverageValue,
    }
}
/**
 * @method
 * @name hitbtc#setLeverage
 * @description set the level of leverage for a market
 * @see https://api.hitbtc.com/#create-update-margin-account-2
 * @param {float} leverage the rate of leverage
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} response from the exchange
 */
func  (this *hitbtc) SetLeverage(leverage interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " setLeverage() requires a symbol argument")))
            }
        
            retRes36028 := (<-this.LoadMarkets())
            PanicOnError(retRes36028)
            if IsTrue(IsEqual(GetValue(params, "margin_balance"), nil)) {
                panic(ArgumentsRequired(Add(this.Id, " setLeverage() requires a margin_balance parameter that will transfer margin to the specified trading pair")))
            }
            var market interface{} = this.Market(symbol)
            var amount interface{} = this.SafeNumber(params, "margin_balance")
            var maxLeverage interface{} = this.SafeInteger(GetValue(GetValue(market, "limits"), "leverage"), "max", 50)
            if IsTrue(!IsEqual(GetValue(market, "type"), "swap")) {
                panic(BadSymbol(Add(this.Id, " setLeverage() supports swap contracts only")))
            }
            if IsTrue(IsTrue((IsLessThan(leverage, 1))) || IsTrue((IsGreaterThan(leverage, maxLeverage)))) {
                panic(BadRequest(Add(Add(Add(Add(this.Id, " setLeverage() leverage should be between 1 and "), ToString(maxLeverage)), " for "), symbol)))
            }
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "leverage": ToString(leverage),
                "margin_balance": this.AmountToPrecision(symbol, amount),
            }
        
                retRes362115 :=  (<-this.PrivatePutFuturesAccountIsolatedSymbol(this.Extend(request, params)))
                PanicOnError(retRes362115)
                ch <- retRes362115
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name hitbtc#fetchDepositWithdrawFees
 * @description fetch deposit and withdraw fees
 * @see https://api.hitbtc.com/#currencies
 * @param {string[]|undefined} codes list of unified currency codes
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [fees structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func  (this *hitbtc) FetchDepositWithdrawFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    codes := GetArg(optionalArgs, 0, nil)
            _ = codes
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes36348 := (<-this.LoadMarkets())
            PanicOnError(retRes36348)
        
            response:= (<-this.PublicGetPublicCurrency(params))
            PanicOnError(response)
        
                //
            //     {
            //       "WEALTH": {
            //         "full_name": "ConnectWealth",
            //         "payin_enabled": false,
            //         "payout_enabled": false,
            //         "transfer_enabled": true,
            //         "precision_transfer": "0.001",
            //         "networks": [
            //           {
            //             "network": "ETH",
            //             "protocol": "ERC20",
            //             "default": true,
            //             "payin_enabled": false,
            //             "payout_enabled": false,
            //             "precision_payout": "0.001",
            //             "payout_fee": "0.016800000000",
            //             "payout_is_payment_id": false,
            //             "payin_payment_id": false,
            //             "payin_confirmations": "2"
            //           }
            //         ]
            //       }
            //     }
            //
        ch <- this.ParseDepositWithdrawFees(response, codes)
            return nil
        
            }()
            return ch
        }
func  (this *hitbtc) ParseDepositWithdrawFee(fee interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //         "full_name": "ConnectWealth",
    //         "payin_enabled": false,
    //         "payout_enabled": false,
    //         "transfer_enabled": true,
    //         "precision_transfer": "0.001",
    //         "networks": [
    //           {
    //             "network": "ETH",
    //             "protocol": "ERC20",
    //             "default": true,
    //             "payin_enabled": false,
    //             "payout_enabled": false,
    //             "precision_payout": "0.001",
    //             "payout_fee": "0.016800000000",
    //             "payout_is_payment_id": false,
    //             "payin_payment_id": false,
    //             "payin_confirmations": "2"
    //           }
    //         ]
    //    }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var networks interface{} = this.SafeValue(fee, "networks", []interface{}{})
    var result interface{} = this.DepositWithdrawFee(fee)
    for j := 0; IsLessThan(j, GetArrayLength(networks)); j++ {
        var networkEntry interface{} = GetValue(networks, j)
        var networkId interface{} = this.SafeString(networkEntry, "network")
        var networkCode interface{} = this.NetworkIdToCode(networkId)
        networkCode = Ternary(IsTrue((!IsEqual(networkCode, nil))), ToUpper(networkCode), nil)
        var withdrawFee interface{} = this.SafeNumber(networkEntry, "payout_fee")
        var isDefault interface{} = this.SafeValue(networkEntry, "default")
        var withdrawResult interface{} = map[string]interface{} {
            "fee": withdrawFee,
            "percentage": Ternary(IsTrue((!IsEqual(withdrawFee, nil))), false, nil),
        }
        if IsTrue(IsEqual(isDefault, true)) {
            AddElementToObject(result, "withdraw", withdrawResult)
        }
        AddElementToObject(GetValue(result, "networks"), networkCode, map[string]interface{} {
    "withdraw": withdrawResult,
    "deposit": map[string]interface{} {
        "fee": nil,
        "percentage": nil,
    },
})
    }
    return result
}
/**
 * @method
 * @name hitbtc#closePosition
 * @description closes open positions for a market
 * @see https://api.hitbtc.com/#close-all-futures-margin-positions
 * @param {string} symbol unified ccxt market symbol
 * @param {string} side 'buy' or 'sell'
 * @param {object} [params] extra parameters specific to the okx api endpoint
 * @param {string} [params.symbol] *required* unified market symbol
 * @param {string} [params.marginMode] 'cross' or 'isolated', default is 'cross'
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *hitbtc) ClosePosition(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    side := GetArg(optionalArgs, 0, nil)
            _ = side
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes37288 := (<-this.LoadMarkets())
            PanicOnError(retRes37288)
            var marginMode interface{} = nil
            marginModeparamsVariable := this.HandleMarginModeAndParams("closePosition", params, "cross");
            marginMode = GetValue(marginModeparamsVariable,0);
            params = GetValue(marginModeparamsVariable,1)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "margin_mode": marginMode,
            }
        
            response:= (<-this.PrivateDeleteFuturesPositionMarginModeSymbol(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            // {
            //     "id":"202471640",
            //     "symbol":"TRXUSDT_PERP",
            //     "margin_mode":"Cross",
            //     "leverage":"1.00",
            //     "quantity":"0",
            //     "price_entry":"0",
            //     "price_margin_call":"0",
            //     "price_liquidation":"0",
            //     "pnl":"0.001234100000",
            //     "created_at":"2023-10-29T14:46:13.235Z",
            //     "updated_at":"2023-12-19T09:34:40.014Z"
            // }
            //
        ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
func  (this *hitbtc) HandleMarginModeAndParams(methodName interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @description marginMode specified by params["marginMode"], this.options["marginMode"], this.options["defaultMarginMode"], params["margin"] = true or this.options["defaultType"] = 'margin'
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @returns {Array} the marginMode in lowercase
    */
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    defaultValue := GetArg(optionalArgs, 1, nil)
    _ = defaultValue
    var defaultType interface{} = this.SafeString(this.Options, "defaultType")
    var isMargin interface{} = this.SafeBool(params, "margin", false)
    var marginMode interface{} = nil
    marginModeparamsVariable := this.Exchange.HandleMarginModeAndParams(methodName, params, defaultValue);
    marginMode = GetValue(marginModeparamsVariable,0);
    params = GetValue(marginModeparamsVariable,1)
    if IsTrue(IsEqual(marginMode, nil)) {
        if IsTrue(IsTrue((IsEqual(defaultType, "margin"))) || IsTrue((IsEqual(isMargin, true)))) {
            marginMode = "isolated"
        }
    }
    return []interface{}{marginMode, params}
}
func  (this *hitbtc) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    //
    //     {
    //       "error": {
    //         "code": 20001,
    //         "message": "Insufficient funds",
    //         "description": "Check that the funds are sufficient, given commissions"
    //       }
    //     }
    //
    //     {
    //       "error": {
    //         "code": "600",
    //         "message": "Action not allowed"
    //       }
    //     }
    //
    var error interface{} = this.SafeValue(response, "error")
    var errorCode interface{} = this.SafeString(error, "code")
    if IsTrue(!IsEqual(errorCode, nil)) {
        var feedback interface{} = Add(Add(this.Id, " "), body)
        var message interface{} = this.SafeString2(error, "message", "description")
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), errorCode, feedback)
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), message, feedback)
        panic(ExchangeError(feedback))
    }
    return nil
}
func  (this *hitbtc) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var query interface{} = this.Omit(params, this.ExtractParams(path))
    var implodedPath interface{} = this.ImplodeParams(path, params)
    var url interface{} = Add(Add(GetValue(GetValue(this.Urls, "api"), api), "/"), implodedPath)
    var getRequest interface{} = nil
    var keys interface{} = ObjectKeys(query)
    var queryLength interface{} =     GetArrayLength(keys)
    headers = map[string]interface{} {
        "Content-Type": "application/json",
    }
    if IsTrue(IsEqual(method, "GET")) {
        if IsTrue(queryLength) {
            getRequest = Add("?", this.Urlencode(query))
            url = Add(url, getRequest)
        }
    } else {
        body = this.Json(params)
    }
    if IsTrue(IsEqual(api, "private")) {
        this.CheckRequiredCredentials()
        var timestamp interface{} = ToString(this.Nonce())
        var payload interface{} = []interface{}{method, Add("/api/3/", implodedPath)}
        if IsTrue(IsEqual(method, "GET")) {
            if IsTrue(!IsEqual(getRequest, nil)) {
                AppendToArray(&payload,getRequest)
            }
        } else {
            AppendToArray(&payload,body)
        }
        AppendToArray(&payload,timestamp)
        var payloadString interface{} = Join(payload, "")
        var signature interface{} = this.Hmac(this.Encode(payloadString), this.Encode(this.Secret), sha256, "hex")
        var secondPayload interface{} = Add(Add(Add(Add(this.ApiKey, ":"), signature), ":"), timestamp)
        var encoded interface{} = this.StringToBase64(secondPayload)
        AddElementToObject(headers, "Authorization", Add("HS256 ", encoded))
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}


func (this *hitbtc) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
