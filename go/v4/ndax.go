package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type ndax struct {
    Exchange

}

func NewNdaxCore() ndax {
   p := ndax{}
   setDefaults(&p)
   return p
}

func  (this *ndax) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "ndax",
        "name": "NDAX",
        "countries": []interface{}{"CA"},
        "rateLimit": 1000,
        "pro": true,
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": false,
            "swap": false,
            "future": false,
            "option": false,
            "addMargin": false,
            "cancelAllOrders": true,
            "cancelOrder": true,
            "closeAllPositions": false,
            "closePosition": false,
            "createDepositAddress": true,
            "createOrder": true,
            "createReduceOnlyOrder": false,
            "createStopLimitOrder": true,
            "createStopMarketOrder": true,
            "createStopOrder": true,
            "editOrder": true,
            "fetchAccounts": true,
            "fetchBalance": true,
            "fetchBorrowInterest": false,
            "fetchBorrowRate": false,
            "fetchBorrowRateHistories": false,
            "fetchBorrowRateHistory": false,
            "fetchBorrowRates": false,
            "fetchBorrowRatesPerSymbol": false,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchCurrencies": true,
            "fetchDepositAddress": true,
            "fetchDepositAddresses": false,
            "fetchDepositAddressesByNetwork": false,
            "fetchDeposits": true,
            "fetchFundingHistory": false,
            "fetchFundingInterval": false,
            "fetchFundingIntervals": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchGreeks": false,
            "fetchIndexOHLCV": false,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchIsolatedPositions": false,
            "fetchLedger": true,
            "fetchLeverage": false,
            "fetchLeverages": false,
            "fetchLeverageTiers": false,
            "fetchLiquidations": false,
            "fetchMarginAdjustmentHistory": false,
            "fetchMarginMode": false,
            "fetchMarginModes": false,
            "fetchMarketLeverageTiers": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMarkPrices": false,
            "fetchMyLiquidations": false,
            "fetchMySettlementHistory": false,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenInterest": false,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrders": true,
            "fetchOption": false,
            "fetchOptionChain": false,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrders": true,
            "fetchOrderTrades": true,
            "fetchPosition": false,
            "fetchPositionHistory": false,
            "fetchPositionMode": false,
            "fetchPositions": false,
            "fetchPositionsForSymbol": false,
            "fetchPositionsHistory": false,
            "fetchPositionsRisk": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchSettlementHistory": false,
            "fetchTicker": true,
            "fetchTickers": false,
            "fetchTime": false,
            "fetchTrades": true,
            "fetchTradingFee": false,
            "fetchTradingFees": false,
            "fetchUnderlyingAssets": false,
            "fetchVolatilityHistory": false,
            "fetchWithdrawals": true,
            "reduceMargin": false,
            "repayCrossMargin": false,
            "repayIsolatedMargin": false,
            "sandbox": true,
            "setLeverage": false,
            "setMargin": false,
            "setMarginMode": false,
            "setPositionMode": false,
            "signIn": true,
            "transfer": false,
            "withdraw": true,
        },
        "timeframes": map[string]interface{} {
            "1m": "60",
            "5m": "300",
            "15m": "900",
            "30m": "1800",
            "1h": "3600",
            "2h": "7200",
            "4h": "14400",
            "6h": "21600",
            "12h": "43200",
            "1d": "86400",
            "1w": "604800",
            "1M": "2419200",
            "4M": "9676800",
        },
        "urls": map[string]interface{} {
            "logo": "https://user-images.githubusercontent.com/1294454/108623144-67a3ef00-744e-11eb-8140-75c6b851e945.jpg",
            "test": map[string]interface{} {
                "public": "https://ndaxmarginstaging.cdnhop.net:8443/AP",
                "private": "https://ndaxmarginstaging.cdnhop.net:8443/AP",
            },
            "api": map[string]interface{} {
                "public": "https://api.ndax.io:8443/AP",
                "private": "https://api.ndax.io:8443/AP",
            },
            "www": "https://ndax.io",
            "doc": []interface{}{"https://apidoc.ndax.io/"},
            "fees": "https://ndax.io/fees",
            "referral": "https://one.ndax.io/bfQiSL",
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": map[string]interface{} {
                    "Activate2FA": 1,
                    "Authenticate2FA": 1,
                    "AuthenticateUser": 1,
                    "GetL2Snapshot": 1,
                    "GetLevel1": 1,
                    "GetValidate2FARequiredEndpoints": 1,
                    "LogOut": 1,
                    "GetTickerHistory": 1,
                    "GetProduct": 1,
                    "GetProducts": 1,
                    "GetInstrument": 1,
                    "GetInstruments": 1,
                    "Ping": 1,
                    "trades": 1,
                    "GetLastTrades": 1,
                    "SubscribeLevel1": 1,
                    "SubscribeLevel2": 1,
                    "SubscribeTicker": 1,
                    "SubscribeTrades": 1,
                    "SubscribeBlockTrades": 1,
                    "UnsubscribeBlockTrades": 1,
                    "UnsubscribeLevel1": 1,
                    "UnsubscribeLevel2": 1,
                    "UnsubscribeTicker": 1,
                    "UnsubscribeTrades": 1,
                    "Authenticate": 1,
                },
            },
            "private": map[string]interface{} {
                "get": map[string]interface{} {
                    "GetUserAccountInfos": 1,
                    "GetUserAccounts": 1,
                    "GetUserAffiliateCount": 1,
                    "GetUserAffiliateTag": 1,
                    "GetUserConfig": 1,
                    "GetAllUnredactedUserConfigsForUser": 1,
                    "GetUnredactedUserConfigByKey": 1,
                    "GetUserDevices": 1,
                    "GetUserReportTickets": 1,
                    "GetUserReportWriterResultRecords": 1,
                    "GetAccountInfo": 1,
                    "GetAccountPositions": 1,
                    "GetAllAccountConfigs": 1,
                    "GetTreasuryProductsForAccount": 1,
                    "GetAccountTrades": 1,
                    "GetAccountTransactions": 1,
                    "GetOpenTradeReports": 1,
                    "GetAllOpenTradeReports": 1,
                    "GetTradesHistory": 1,
                    "GetOpenOrders": 1,
                    "GetOpenQuotes": 1,
                    "GetOrderFee": 1,
                    "GetOrderHistory": 1,
                    "GetOrdersHistory": 1,
                    "GetOrderStatus": 1,
                    "GetOmsFeeTiers": 1,
                    "GetAccountDepositTransactions": 1,
                    "GetAccountWithdrawTransactions": 1,
                    "GetAllDepositRequestInfoTemplates": 1,
                    "GetDepositInfo": 1,
                    "GetDepositRequestInfoTemplate": 1,
                    "GetDeposits": 1,
                    "GetDepositTicket": 1,
                    "GetDepositTickets": 1,
                    "GetOMSWithdrawFees": 1,
                    "GetWithdrawFee": 1,
                    "GetWithdraws": 1,
                    "GetWithdrawTemplate": 1,
                    "GetWithdrawTemplateTypes": 1,
                    "GetWithdrawTicket": 1,
                    "GetWithdrawTickets": 1,
                },
                "post": map[string]interface{} {
                    "AddUserAffiliateTag": 1,
                    "CancelUserReport": 1,
                    "RegisterNewDevice": 1,
                    "SubscribeAccountEvents": 1,
                    "UpdateUserAffiliateTag": 1,
                    "GenerateTradeActivityReport": 1,
                    "GenerateTransactionActivityReport": 1,
                    "GenerateTreasuryActivityReport": 1,
                    "ScheduleTradeActivityReport": 1,
                    "ScheduleTransactionActivityReport": 1,
                    "ScheduleTreasuryActivityReport": 1,
                    "CancelAllOrders": 1,
                    "CancelOrder": 1,
                    "CancelQuote": 1,
                    "CancelReplaceOrder": 1,
                    "CreateQuote": 1,
                    "ModifyOrder": 1,
                    "SendOrder": 1,
                    "SubmitBlockTrade": 1,
                    "UpdateQuote": 1,
                    "CancelWithdraw": 1,
                    "CreateDepositTicket": 1,
                    "CreateWithdrawTicket": 1,
                    "SubmitDepositTicketComment": 1,
                    "SubmitWithdrawTicketComment": 1,
                    "GetOrderHistoryByOrderId": 1,
                },
            },
        },
        "features": map[string]interface{} {
            "spot": map[string]interface{} {
                "sandbox": true,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": true,
                    "triggerDirection": false,
                    "triggerPriceType": map[string]interface{} {
                        "last": true,
                        "mark": false,
                        "index": false,
                    },
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": true,
                        "FOK": true,
                        "PO": true,
                        "GTD": false,
                    },
                    "hedged": false,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyByCost": false,
                    "marketBuyRequiresPrice": false,
                    "selfTradePrevention": false,
                    "iceberg": true,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": 100000,
                    "untilDays": 100000,
                    "symbolRequired": false,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": nil,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": nil,
                    "daysBack": nil,
                    "untilDays": nil,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchClosedOrders": nil,
                "fetchOHLCV": map[string]interface{} {
                    "limit": nil,
                },
            },
            "swap": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "tierBased": false,
                "percentage": true,
                "maker": this.ParseNumber("0.002"),
                "taker": this.ParseNumber("0.0025"),
            },
        },
        "requiredCredentials": map[string]interface{} {
            "apiKey": true,
            "secret": true,
            "uid": true,
            "login": true,
            "password": true,
        },
        "precisionMode": TICK_SIZE,
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "Not_Enough_Funds": InsufficientFunds,
                "Server Error": ExchangeError,
                "Resource Not Found": OrderNotFound,
            },
            "broad": map[string]interface{} {
                "Invalid InstrumentId": BadSymbol,
                "This endpoint requires 2FACode along with the payload": AuthenticationError,
            },
        },
        "options": map[string]interface{} {
            "omsId": 1,
            "orderTypes": map[string]interface{} {
                "Market": 1,
                "Limit": 2,
                "StopMarket": 3,
                "StopLimit": 4,
                "TrailingStopMarket": 5,
                "TrailingStopLimit": 6,
                "BlockTrade": 7,
                "1": 1,
                "2": 2,
                "3": 3,
                "4": 4,
                "5": 5,
                "6": 6,
                "7": 7,
            },
        },
    })
}
/**
 * @method
 * @name ndax#signIn
 * @description sign in, must be called prior to using other authenticated methods
 * @see https://apidoc.ndax.io/#authenticate2fa
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns response from exchange
 */
func  (this *ndax) SignIn(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
            if IsTrue(IsTrue(IsEqual(this.Login, nil)) || IsTrue(IsEqual(this.Password, nil))) {
                panic(AuthenticationError(Add(this.Id, " signIn() requires exchange.login, exchange.password")))
            }
            var request interface{} = map[string]interface{} {
                "grant_type": "client_credentials",
            }
        
            response:= (<-this.PublicGetAuthenticate(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "Authenticated":true,
            //         "Requires2FA":true,
            //         "AuthType":"Google",
            //         "AddtlInfo":"",
            //         "Pending2FaToken": "6f5c4e66-f3ee-493e-9227-31cc0583b55f"
            //     }
            //
            var sessionToken interface{} = this.SafeString(response, "SessionToken")
            if IsTrue(!IsEqual(sessionToken, nil)) {
                AddElementToObject(this.Options, "sessionToken", sessionToken)
        
                ch <- response
                return nil
            }
            var pending2faToken interface{} = this.SafeString(response, "Pending2FaToken")
            if IsTrue(!IsEqual(pending2faToken, nil)) {
                if IsTrue(IsEqual(this.Twofa, nil)) {
                    panic(AuthenticationError(Add(this.Id, " signIn() requires exchange.twofa credentials")))
                }
                AddElementToObject(this.Options, "pending2faToken", pending2faToken)
                request = map[string]interface{} {
                    "Code": Totp(this.Twofa),
                }
        
                responseInner:= (<-this.PublicGetAuthenticate2FA(this.Extend(request, params)))
                PanicOnError(responseInner)
                //
                //     {
                //         "Authenticated": true,
                //         "UserId":57764,
                //         "SessionToken":"4a2a5857-c4e5-4fac-b09e-2c4c30b591a0"
                //     }
                //
                sessionToken = this.SafeString(responseInner, "SessionToken")
                AddElementToObject(this.Options, "sessionToken", sessionToken)
        
                ch <- responseInner
                return nil
            }
        
            ch <- response
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ndax#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see https://apidoc.ndax.io/#getproduct
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func  (this *ndax) FetchCurrencies(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var omsId interface{} = this.SafeInteger(this.Options, "omsId", 1)
            var request interface{} = map[string]interface{} {
                "omsId": omsId,
            }
        
            response:= (<-this.PublicGetGetProducts(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     [
            //         {
            //             "OMSId":1,
            //             "ProductId":1,
            //             "Product":"BTC",
            //             "ProductFullName":"Bitcoin",
            //             "ProductType":"CryptoCurrency",
            //             "DecimalPlaces":8,
            //             "TickSize":0.0000000100000000000000000000,
            //             "NoFees":false,
            //             "IsDisabled":false,
            //             "MarginEnabled":false
            //         },
            //     ]
            //
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
                var currency interface{} = GetValue(response, i)
                var id interface{} = this.SafeString(currency, "ProductId")
                var name interface{} = this.SafeString(currency, "ProductFullName")
                var ProductType interface{} = this.SafeString(currency, "ProductType")
                var typeVar interface{} = Ternary(IsTrue((IsEqual(ProductType, "NationalCurrency"))), "fiat", "crypto")
                if IsTrue(IsEqual(ProductType, "Unknown")) {
                    // such currency is just a blanket entry
                    typeVar = "other"
                }
                var code interface{} = this.SafeCurrencyCode(this.SafeString(currency, "Product"))
                var isDisabled interface{} = this.SafeValue(currency, "IsDisabled")
                var active interface{} =         !IsTrue(isDisabled)
                AddElementToObject(result, code, map[string]interface{} {
            "id": id,
            "name": name,
            "code": code,
            "type": typeVar,
            "precision": this.SafeNumber(currency, "TickSize"),
            "info": currency,
            "active": active,
            "deposit": nil,
            "withdraw": nil,
            "fee": nil,
            "limits": map[string]interface{} {
                "amount": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
                "withdraw": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
            },
            "networks": map[string]interface{} {},
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ndax#fetchMarkets
 * @description retrieves data on all markets for ndax
 * @see https://apidoc.ndax.io/#getinstruments
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *ndax) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var omsId interface{} = this.SafeInteger(this.Options, "omsId", 1)
            var request interface{} = map[string]interface{} {
                "omsId": omsId,
            }
        
            response:= (<-this.PublicGetGetInstruments(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "OMSId":1,
            //             "InstrumentId":3,
            //             "Symbol":"LTCBTC",
            //             "Product1":3,
            //             "Product1Symbol":"LTC",
            //             "Product2":1,
            //             "Product2Symbol":"BTC",
            //             "InstrumentType":"Standard",
            //             "VenueInstrumentId":3,
            //             "VenueId":1,
            //             "SortIndex":0,
            //             "SessionStatus":"Running",
            //             "PreviousSessionStatus":"Stopped",
            //             "SessionStatusDateTime":"2020-11-25T19:42:15.245Z",
            //             "SelfTradePrevention":true,
            //             "QuantityIncrement":0.0000000100000000000000000000,
            //             "PriceIncrement":0.0000000100000000000000000000,
            //             "MinimumQuantity":0.0100000000000000000000000000,
            //             "MinimumPrice":0.0000010000000000000000000000,
            //             "VenueSymbol":"LTCBTC",
            //             "IsDisable":false,
            //             "MasterDataId":0,
            //             "PriceCollarThreshold":0.0000000000000000000000000000,
            //             "PriceCollarPercent":0.0000000000000000000000000000,
            //             "PriceCollarEnabled":false,
            //             "PriceFloorLimit":0.0000000000000000000000000000,
            //             "PriceFloorLimitEnabled":false,
            //             "PriceCeilingLimit":0.0000000000000000000000000000,
            //             "PriceCeilingLimitEnabled":false,
            //             "CreateWithMarketRunning":true,
            //             "AllowOnlyMarketMakerCounterParty":false,
            //             "PriceCollarIndexDifference":0.0000000000000000000000000000,
            //             "PriceCollarConvertToOtcEnabled":false,
            //             "PriceCollarConvertToOtcClientUserId":0,
            //             "PriceCollarConvertToOtcAccountId":0,
            //             "PriceCollarConvertToOtcThreshold":0.0000000000000000000000000000,
            //             "OtcConvertSizeThreshold":0.0000000000000000000000000000,
            //             "OtcConvertSizeEnabled":false,
            //             "OtcTradesPublic":true,
            //             "PriceTier":0
            //         },
            //     ]
            //
        ch <- this.ParseMarkets(response)
            return nil
        
            }()
            return ch
        }
func  (this *ndax) ParseMarket(market interface{}) interface{}  {
    var id interface{} = this.SafeString(market, "InstrumentId")
    // const lowercaseId = this.safeStringLower (market, 'symbol');
    var baseId interface{} = this.SafeString(market, "Product1")
    var quoteId interface{} = this.SafeString(market, "Product2")
    var base interface{} = this.SafeCurrencyCode(this.SafeString(market, "Product1Symbol"))
    var quote interface{} = this.SafeCurrencyCode(this.SafeString(market, "Product2Symbol"))
    var sessionStatus interface{} = this.SafeString(market, "SessionStatus")
    var isDisable interface{} = this.SafeValue(market, "IsDisable")
    var sessionRunning interface{} =     (IsEqual(sessionStatus, "Running"))
    return map[string]interface{} {
        "id": id,
        "symbol": Add(Add(base, "/"), quote),
        "base": base,
        "quote": quote,
        "settle": nil,
        "baseId": baseId,
        "quoteId": quoteId,
        "settleId": nil,
        "type": "spot",
        "spot": true,
        "margin": false,
        "swap": false,
        "future": false,
        "option": false,
        "active": (IsTrue(sessionRunning) && !IsTrue(isDisable)),
        "contract": false,
        "linear": nil,
        "inverse": nil,
        "contractSize": nil,
        "expiry": nil,
        "expiryDatetime": nil,
        "strike": nil,
        "optionType": nil,
        "precision": map[string]interface{} {
            "amount": this.SafeNumber(market, "QuantityIncrement"),
            "price": this.SafeNumber(market, "PriceIncrement"),
        },
        "limits": map[string]interface{} {
            "leverage": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "amount": map[string]interface{} {
                "min": this.SafeNumber(market, "MinimumQuantity"),
                "max": nil,
            },
            "price": map[string]interface{} {
                "min": this.SafeNumber(market, "MinimumPrice"),
                "max": nil,
            },
            "cost": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
        },
        "created": nil,
        "info": market,
    }
}
func  (this *ndax) ParseOrderBook(orderbook interface{}, symbol interface{}, optionalArgs ...interface{}) interface{}  {
    timestamp := GetArg(optionalArgs, 0, nil)
    _ = timestamp
    bidsKey := GetArg(optionalArgs, 1, "bids")
    _ = bidsKey
    asksKey := GetArg(optionalArgs, 2, "asks")
    _ = asksKey
    priceKey := GetArg(optionalArgs, 3, 6)
    _ = priceKey
    amountKey := GetArg(optionalArgs, 4, 8)
    _ = amountKey
    countOrIdKey := GetArg(optionalArgs, 5, 2)
    _ = countOrIdKey
    var nonce interface{} = nil
    var result interface{} = map[string]interface{} {
        "symbol": symbol,
        "bids": []interface{}{},
        "asks": []interface{}{},
        "timestamp": nil,
        "datetime": nil,
        "nonce": nil,
    }
    for i := 0; IsLessThan(i, GetArrayLength(orderbook)); i++ {
        var level interface{} = GetValue(orderbook, i)
        if IsTrue(IsEqual(timestamp, nil)) {
            timestamp = this.SafeInteger(level, 2)
        } else {
            var newTimestamp interface{} = this.SafeInteger(level, 2)
            timestamp = mathMax(timestamp, newTimestamp)
        }
        if IsTrue(IsEqual(nonce, nil)) {
            nonce = this.SafeInteger(level, 0)
        } else {
            var newNonce interface{} = this.SafeInteger(level, 0)
            nonce = mathMax(nonce, newNonce)
        }
        var bidask interface{} = this.ParseBidAsk(level, priceKey, amountKey)
        var levelSide interface{} = this.SafeInteger(level, 9)
        var side interface{} = Ternary(IsTrue(levelSide), asksKey, bidsKey)
        var resultSide interface{} = GetValue(result, side)
        AppendToArray(&resultSide,bidask)
    }
    AddElementToObject(result, "bids", this.SortBy(GetValue(result, "bids"), 0, true))
    AddElementToObject(result, "asks", this.SortBy(GetValue(result, "asks"), 0))
    AddElementToObject(result, "timestamp", timestamp)
    AddElementToObject(result, "datetime", this.Iso8601(timestamp))
    AddElementToObject(result, "nonce", nonce)
    return result
}
/**
 * @method
 * @name ndax#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://apidoc.ndax.io/#getl2snapshot
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *ndax) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var omsId interface{} = this.SafeInteger(this.Options, "omsId", 1)
        
            retRes6878 := (<-this.LoadMarkets())
            PanicOnError(retRes6878)
            var market interface{} = this.Market(symbol)
            limit = Ternary(IsTrue((IsEqual(limit, nil))), 100, limit) // default 100
            var request interface{} = map[string]interface{} {
                "omsId": omsId,
                "InstrumentId": GetValue(market, "id"),
                "Depth": limit,
            }
        
            response:= (<-this.PublicGetGetL2Snapshot(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         [
            //             0,   // 0 MDUpdateId
            //             1,   // 1 Number of Unique Accounts
            //             123, // 2 ActionDateTime in Posix format X 1000
            //             0,   // 3 ActionType 0 (New), 1 (Update), 2(Delete)
            //             0.0, // 4 LastTradePrice
            //             0,   // 5 Number of Orders
            //             0.0, // 6 Price
            //             0,   // 7 ProductPairCode
            //             0.0, // 8 Quantity
            //             0,   // 9 Side
            //         ],
            //         [97244115,1,1607456142963,0,19069.32,1,19069.31,8,0.140095,0],
            //         [97244115,0,1607456142963,0,19069.32,1,19068.64,8,0.0055,0],
            //         [97244115,0,1607456142963,0,19069.32,1,19068.26,8,0.021291,0],
            //         [97244115,1,1607456142964,0,19069.32,1,19069.32,8,0.099636,1],
            //         [97244115,0,1607456142964,0,19069.32,1,19069.98,8,0.1,1],
            //         [97244115,0,1607456142964,0,19069.32,1,19069.99,8,0.141604,1],
            //     ]
            //
        ch <- this.ParseOrderBook(response, symbol)
            return nil
        
            }()
            return ch
        }
func  (this *ndax) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTicker
    //
    //     {
    //         "OMSId":1,
    //         "InstrumentId":8,
    //         "BestBid":19069.31,
    //         "BestOffer":19069.32,
    //         "LastTradedPx":19069.32,
    //         "LastTradedQty":0.0001,
    //         "LastTradeTime":1607040406424,
    //         "SessionOpen":19069.32,
    //         "SessionHigh":19069.32,
    //         "SessionLow":19069.32,
    //         "SessionClose":19069.32,
    //         "Volume":0.0001,
    //         "CurrentDayVolume":0.0001,
    //         "CurrentDayNotional":1.906932,
    //         "CurrentDayNumTrades":1,
    //         "CurrentDayPxChange":0.00,
    //         "Rolling24HrVolume":0.000000000000000000000000000,
    //         "Rolling24HrNotional":0.00000000000000000000000,
    //         "Rolling24NumTrades":0,
    //         "Rolling24HrPxChange":0,
    //         "TimeStamp":"1607040406425",
    //         "BidQty":0,
    //         "AskQty":0,
    //         "BidOrderCt":0,
    //         "AskOrderCt":0,
    //         "Rolling24HrPxChangePercent":0,
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger(ticker, "TimeStamp")
    var marketId interface{} = this.SafeString(ticker, "InstrumentId")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var last interface{} = this.SafeString(ticker, "LastTradedPx")
    var percentage interface{} = this.SafeString(ticker, "Rolling24HrPxChangePercent")
    var change interface{} = this.SafeString(ticker, "Rolling24HrPxChange")
    var open interface{} = this.SafeString(ticker, "SessionOpen")
    var baseVolume interface{} = this.SafeString(ticker, "Rolling24HrVolume")
    var quoteVolume interface{} = this.SafeString(ticker, "Rolling24HrNotional")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeString(ticker, "SessionHigh"),
        "low": this.SafeString(ticker, "SessionLow"),
        "bid": this.SafeString(ticker, "BestBid"),
        "bidVolume": nil,
        "ask": this.SafeString(ticker, "BestOffer"),
        "askVolume": nil,
        "vwap": nil,
        "open": open,
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": change,
        "percentage": percentage,
        "average": nil,
        "baseVolume": baseVolume,
        "quoteVolume": quoteVolume,
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name ndax#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://apidoc.ndax.io/#getlevel1
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *ndax) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var omsId interface{} = this.SafeInteger(this.Options, "omsId", 1)
        
            retRes7998 := (<-this.LoadMarkets())
            PanicOnError(retRes7998)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "omsId": omsId,
                "InstrumentId": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetGetLevel1(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "OMSId":1,
            //         "InstrumentId":8,
            //         "BestBid":19069.31,
            //         "BestOffer":19069.32,
            //         "LastTradedPx":19069.32,
            //         "LastTradedQty":0.0001,
            //         "LastTradeTime":1607040406424,
            //         "SessionOpen":19069.32,
            //         "SessionHigh":19069.32,
            //         "SessionLow":19069.32,
            //         "SessionClose":19069.32,
            //         "Volume":0.0001,
            //         "CurrentDayVolume":0.0001,
            //         "CurrentDayNotional":1.906932,
            //         "CurrentDayNumTrades":1,
            //         "CurrentDayPxChange":0.00,
            //         "Rolling24HrVolume":0.000000000000000000000000000,
            //         "Rolling24HrNotional":0.00000000000000000000000,
            //         "Rolling24NumTrades":0,
            //         "Rolling24HrPxChange":0,
            //         "TimeStamp":"1607040406425",
            //         "BidQty":0,
            //         "AskQty":0,
            //         "BidOrderCt":0,
            //         "AskOrderCt":0,
            //         "Rolling24HrPxChangePercent":0,
            //     }
            //
        ch <- this.ParseTicker(response, market)
            return nil
        
            }()
            return ch
        }
func  (this *ndax) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     [
    //         1501603632000, // 0 DateTime
    //         2700.33,       // 1 High
    //         2687.01,       // 2 Low
    //         2687.01,       // 3 Open
    //         2687.01,       // 4 Close
    //         24.86100992,   // 5 Volume
    //         0,             // 6 Inside Bid Price
    //         2870.95,       // 7 Inside Ask Price
    //         1              // 8 InstrumentId
    //     ]
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.SafeInteger(ohlcv, 0), this.SafeNumber(ohlcv, 3), this.SafeNumber(ohlcv, 1), this.SafeNumber(ohlcv, 2), this.SafeNumber(ohlcv, 4), this.SafeNumber(ohlcv, 5)}
}
/**
 * @method
 * @name ndax#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://apidoc.ndax.io/#gettickerhistory
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *ndax) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var omsId interface{} = this.SafeInteger(this.Options, "omsId", 1)
        
            retRes8778 := (<-this.LoadMarkets())
            PanicOnError(retRes8778)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "omsId": omsId,
                "InstrumentId": GetValue(market, "id"),
                "Interval": this.SafeString(this.Timeframes, timeframe, timeframe),
            }
            var duration interface{} = this.ParseTimeframe(timeframe)
            var now interface{} = this.Milliseconds()
            if IsTrue(IsEqual(since, nil)) {
                if IsTrue(!IsEqual(limit, nil)) {
                    AddElementToObject(request, "FromDate", this.Ymdhms(Subtract(now, Multiply(Multiply(duration, limit), 1000))))
                    AddElementToObject(request, "ToDate", this.Ymdhms(now))
                }
            } else {
                AddElementToObject(request, "FromDate", this.Ymdhms(since))
                if IsTrue(IsEqual(limit, nil)) {
                    AddElementToObject(request, "ToDate", this.Ymdhms(now))
                } else {
                    AddElementToObject(request, "ToDate", this.Ymdhms(this.Sum(since, Multiply(Multiply(duration, limit), 1000))))
                }
            }
        
            response:= (<-this.PublicGetGetTickerHistory(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         [1607299260000,19069.32,19069.32,19069.32,19069.32,0,19069.31,19069.32,8,1607299200000],
            //         [1607299320000,19069.32,19069.32,19069.32,19069.32,0,19069.31,19069.32,8,1607299260000],
            //         [1607299380000,19069.32,19069.32,19069.32,19069.32,0,19069.31,19069.32,8,1607299320000],
            //     ]
            //
        ch <- this.ParseOHLCVs(response, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *ndax) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTrades (public)
    //
    //     [
    //         6913253,       //  0 TradeId
    //         8,             //  1 ProductPairCode
    //         0.03340802,    //  2 Quantity
    //         19116.08,      //  3 Price
    //         2543425077,    //  4 Order1
    //         2543425482,    //  5 Order2
    //         1606935922416, //  6 Tradetime
    //         0,             //  7 Direction
    //         1,             //  8 TakerSide
    //         0,             //  9 BlockTrade
    //         0,             // 10 Either Order1ClientId or Order2ClientId
    //     ]
    //
    // fetchMyTrades (private)
    //
    //     {
    //         "OMSId":1,
    //         "ExecutionId":16916567,
    //         "TradeId":14476351,
    //         "OrderId":2543565231,
    //         "AccountId":449,
    //         "AccountName":"igor@ccxt.trade",
    //         "SubAccountId":0,
    //         "ClientOrderId":0,
    //         "InstrumentId":8,
    //         "Side":"Sell",
    //         "OrderType":"Market",
    //         "Quantity":0.1230000000000000000000000000,
    //         "RemainingQuantity":0.0000000000000000000000000000,
    //         "Price":19069.310000000000000000000000,
    //         "Value":2345.5251300000000000000000000,
    //         "CounterParty":"7",
    //         "OrderTradeRevision":1,
    //         "Direction":"NoChange",
    //         "IsBlockTrade":false,
    //         "Fee":1.1727625650000000000000000000,
    //         "FeeProductId":8,
    //         "OrderOriginator":446,
    //         "UserName":"igor@ccxt.trade",
    //         "TradeTimeMS":1607565031569,
    //         "MakerTaker":"Taker",
    //         "AdapterTradeId":0,
    //         "InsideBid":19069.310000000000000000000000,
    //         "InsideBidSize":0.2400950000000000000000000000,
    //         "InsideAsk":19069.320000000000000000000000,
    //         "InsideAskSize":0.0997360000000000000000000000,
    //         "IsQuote":false,
    //         "CounterPartyClientUserId":1,
    //         "NotionalProductId":2,
    //         "NotionalRate":1.0000000000000000000000000000,
    //         "NotionalValue":2345.5251300000000000000000000,
    //         "NotionalHoldAmount":0,
    //         "TradeTime":637431618315686826
    //     }
    //
    // fetchOrderTrades
    //
    //     {
    //         "Side":"Sell",
    //         "OrderId":2543565235,
    //         "Price":18600.000000000000000000000000,
    //         "Quantity":0.0000000000000000000000000000,
    //         "DisplayQuantity":0.0000000000000000000000000000,
    //         "Instrument":8,
    //         "Account":449,
    //         "AccountName":"igor@ccxt.trade",
    //         "OrderType":"Limit",
    //         "ClientOrderId":0,
    //         "OrderState":"FullyExecuted",
    //         "ReceiveTime":1607585844956,
    //         "ReceiveTimeTicks":637431826449564182,
    //         "LastUpdatedTime":1607585844959,
    //         "LastUpdatedTimeTicks":637431826449593893,
    //         "OrigQuantity":0.1230000000000000000000000000,
    //         "QuantityExecuted":0.1230000000000000000000000000,
    //         "GrossValueExecuted":2345.3947500000000000000000000,
    //         "ExecutableValue":0.0000000000000000000000000000,
    //         "AvgPrice":19068.250000000000000000000000,
    //         "CounterPartyId":0,
    //         "ChangeReason":"Trade",
    //         "OrigOrderId":2543565235,
    //         "OrigClOrdId":0,
    //         "EnteredBy":446,
    //         "UserName":"igor@ccxt.trade",
    //         "IsQuote":false,
    //         "InsideAsk":19069.320000000000000000000000,
    //         "InsideAskSize":0.0997360000000000000000000000,
    //         "InsideBid":19068.250000000000000000000000,
    //         "InsideBidSize":1.3300010000000000000000000000,
    //         "LastTradePrice":19068.250000000000000000000000,
    //         "RejectReason":"",
    //         "IsLockedIn":false,
    //         "CancelReason":"",
    //         "OrderFlag":"0",
    //         "UseMargin":false,
    //         "StopPrice":0.0000000000000000000000000000,
    //         "PegPriceType":"Unknown",
    //         "PegOffset":0.0000000000000000000000000000,
    //         "PegLimitOffset":0.0000000000000000000000000000,
    //         "IpAddress":"x.x.x.x",
    //         "ClientOrderIdUuid":null,
    //         "OMSId":1
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var priceString interface{} = nil
    var amountString interface{} = nil
    var costString interface{} = nil
    var timestamp interface{} = nil
    var id interface{} = nil
    var marketId interface{} = nil
    var side interface{} = nil
    var orderId interface{} = nil
    var takerOrMaker interface{} = nil
    var fee interface{} = nil
    var typeVar interface{} = nil
    if IsTrue(IsArray(trade)) {
        priceString = this.SafeString(trade, 3)
        amountString = this.SafeString(trade, 2)
        timestamp = this.SafeInteger(trade, 6)
        id = this.SafeString(trade, 0)
        marketId = this.SafeString(trade, 1)
        var takerSide interface{} = this.SafeValue(trade, 8)
        side = Ternary(IsTrue(takerSide), "sell", "buy")
        orderId = this.SafeString(trade, 4)
    } else {
        timestamp = this.SafeInteger2(trade, "TradeTimeMS", "ReceiveTime")
        id = this.SafeString(trade, "TradeId")
        orderId = this.SafeString2(trade, "OrderId", "OrigOrderId")
        marketId = this.SafeString2(trade, "InstrumentId", "Instrument")
        priceString = this.SafeString(trade, "Price")
        amountString = this.SafeString(trade, "Quantity")
        costString = this.SafeString2(trade, "Value", "GrossValueExecuted")
        takerOrMaker = this.SafeStringLower(trade, "MakerTaker")
        side = this.SafeStringLower(trade, "Side")
        typeVar = this.SafeStringLower(trade, "OrderType")
        var feeCostString interface{} = this.SafeString(trade, "Fee")
        if IsTrue(!IsEqual(feeCostString, nil)) {
            var feeCurrencyId interface{} = this.SafeString(trade, "FeeProductId")
            var feeCurrencyCode interface{} = this.SafeCurrencyCode(feeCurrencyId)
            fee = map[string]interface{} {
                "cost": feeCostString,
                "currency": feeCurrencyCode,
            }
        }
    }
    var symbol interface{} = this.SafeSymbol(marketId, market)
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "id": id,
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "order": orderId,
        "type": typeVar,
        "side": side,
        "takerOrMaker": takerOrMaker,
        "price": priceString,
        "amount": amountString,
        "cost": costString,
        "fee": fee,
    }, market)
}
/**
 * @method
 * @name ndax#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *ndax) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
            var omsId interface{} = this.SafeInteger(this.Options, "omsId", 1)
        
            retRes10908 := (<-this.LoadMarkets())
            PanicOnError(retRes10908)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "omsId": omsId,
                "InstrumentId": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "Count", limit)
            }
        
            response:= (<-this.PublicGetGetLastTrades(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         [6913253,8,0.03340802,19116.08,2543425077,2543425482,1606935922416,0,1,0,0],
            //         [6913254,8,0.01391671,19117.42,2543427510,2543427811,1606935927998,1,1,0,0],
            //         [6913255,8,0.000006,19107.81,2543430495,2543430793,1606935933881,2,0,0,0],
            //     ]
            //
        ch <- this.ParseTrades(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ndax#fetchAccounts
 * @description fetch all the accounts associated with a profile
 * @see https://apidoc.ndax.io/#getuseraccounts
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/#/?id=account-structure} indexed by the account type
 */
func  (this *ndax) FetchAccounts(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            if !IsTrue(this.Login) {
                panic(AuthenticationError(Add(this.Id, " fetchAccounts() requires exchange.login email credential")))
            }
            var omsId interface{} = this.SafeInteger(this.Options, "omsId", 1)
            this.CheckRequiredCredentials()
            var request interface{} = map[string]interface{} {
                "omsId": omsId,
                "UserId": this.Uid,
                "UserName": this.Login,
            }
        
            response:= (<-this.PrivateGetGetUserAccounts(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     [ 449 ] // comma-separated list of account ids
            //
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
                var accountId interface{} = this.SafeString(response, i)
                AppendToArray(&result,map[string]interface{} {
                    "id": accountId,
                    "type": nil,
                    "currency": nil,
                    "info": accountId,
                })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *ndax) ParseBalance(response interface{}) interface{}  {
    var result interface{} = map[string]interface{} {
        "info": response,
        "timestamp": nil,
        "datetime": nil,
    }
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        var balance interface{} = GetValue(response, i)
        var currencyId interface{} = this.SafeString(balance, "ProductId")
        if IsTrue(InOp(this.Currencies_by_id, currencyId)) {
            var code interface{} = this.SafeCurrencyCode(currencyId)
            var account interface{} = this.Account()
            AddElementToObject(account, "total", this.SafeString(balance, "Amount"))
            AddElementToObject(account, "used", this.SafeString(balance, "Hold"))
            AddElementToObject(result, code, account)
        }
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name ndax#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://apidoc.ndax.io/#getaccountpositions
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *ndax) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var omsId interface{} = this.SafeInteger(this.Options, "omsId", 1)
        
            retRes11768 := (<-this.LoadMarkets())
            PanicOnError(retRes11768)
        
            retRes11778 := (<-this.LoadAccounts())
            PanicOnError(retRes11778)
            var defaultAccountId interface{} = this.SafeInteger2(this.Options, "accountId", "AccountId")
            var accountId interface{} = this.SafeInteger2(params, "accountId", "AccountId", defaultAccountId)
            if IsTrue(IsEqual(accountId, nil)) {
                accountId = ParseInt(GetValue(GetValue(this.Accounts, 0), "id"))
            }
            params = this.Omit(params, []interface{}{"accountId", "AccountId"})
            var request interface{} = map[string]interface{} {
                "omsId": omsId,
                "AccountId": accountId,
            }
        
            response:= (<-this.PrivateGetGetAccountPositions(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "OMSId":1,
            //             "AccountId":449,
            //             "ProductSymbol":"BTC",
            //             "ProductId":1,
            //             "Amount":10.000000000000000000000000000,
            //             "Hold":0,
            //             "PendingDeposits":0.0000000000000000000000000000,
            //             "PendingWithdraws":0.0000000000000000000000000000,
            //             "TotalDayDeposits":10.000000000000000000000000000,
            //             "TotalMonthDeposits":10.000000000000000000000000000,
            //             "TotalYearDeposits":10.000000000000000000000000000,
            //             "TotalDayDepositNotional":10.000000000000000000000000000,
            //             "TotalMonthDepositNotional":10.000000000000000000000000000,
            //             "TotalYearDepositNotional":10.000000000000000000000000000,
            //             "TotalDayWithdraws":0,
            //             "TotalMonthWithdraws":0,
            //             "TotalYearWithdraws":0,
            //             "TotalDayWithdrawNotional":0,
            //             "TotalMonthWithdrawNotional":0,
            //             "TotalYearWithdrawNotional":0,
            //             "NotionalProductId":8,
            //             "NotionalProductSymbol":"USDT",
            //             "NotionalValue":10.000000000000000000000000000,
            //             "NotionalHoldAmount":0,
            //             "NotionalRate":1
            //         },
            //     ]
            //
        ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
func  (this *ndax) ParseLedgerEntryType(typeVar interface{}) interface{}  {
    var types interface{} = map[string]interface{} {
        "Trade": "trade",
        "Deposit": "transaction",
        "Withdraw": "transaction",
        "Transfer": "transfer",
        "OrderHold": "trade",
        "WithdrawHold": "transaction",
        "DepositHold": "transaction",
        "MarginHold": "trade",
        "ManualHold": "trade",
        "ManualEntry": "trade",
        "MarginAcquisition": "trade",
        "MarginRelinquish": "trade",
        "MarginQuoteHold": "trade",
    }
    return this.SafeString(types, typeVar, typeVar)
}
func  (this *ndax) ParseLedgerEntry(item interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "TransactionId": 2663709493,
    //         "ReferenceId": 68,
    //         "OMSId": 1,
    //         "AccountId": 449,
    //         "CR": 10.000000000000000000000000000,
    //         "DR": 0.0000000000000000000000000000,
    //         "Counterparty": 3,
    //         "TransactionType": "Other",
    //         "ReferenceType": "Deposit",
    //         "ProductId": 1,
    //         "Balance": 10.000000000000000000000000000,
    //         "TimeStamp": 1607532331591
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var currencyId interface{} = this.SafeString(item, "ProductId")
    currency = this.SafeCurrency(currencyId, currency)
    var credit interface{} = this.SafeString(item, "CR")
    var debit interface{} = this.SafeString(item, "DR")
    var amount interface{} = nil
    var direction interface{} = nil
    if IsTrue(Precise.StringLt(credit, "0")) {
        amount = credit
        direction = "in"
    } else if IsTrue(Precise.StringLt(debit, "0")) {
        amount = debit
        direction = "out"
    }
    var before interface{} = nil
    var after interface{} = this.SafeString(item, "Balance")
    if IsTrue(IsEqual(direction, "out")) {
        before = Precise.StringAdd(after, amount)
    } else if IsTrue(IsEqual(direction, "in")) {
        before = Precise.StringMax("0", Precise.StringSub(after, amount))
    }
    var timestamp interface{} = this.SafeInteger(item, "TimeStamp")
    return this.SafeLedgerEntry(map[string]interface{} {
        "info": item,
        "id": this.SafeString(item, "TransactionId"),
        "direction": direction,
        "account": this.SafeString(item, "AccountId"),
        "referenceId": this.SafeString(item, "ReferenceId"),
        "referenceAccount": this.SafeString(item, "Counterparty"),
        "type": this.ParseLedgerEntryType(this.SafeString(item, "ReferenceType")),
        "currency": this.SafeCurrencyCode(currencyId, currency),
        "amount": this.ParseNumber(amount),
        "before": this.ParseNumber(before),
        "after": this.ParseNumber(after),
        "status": "ok",
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "fee": nil,
    }, currency)
}
/**
 * @method
 * @name ndax#fetchLedger
 * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
 * @see https://apidoc.ndax.io/#getaccounttransactions
 * @param {string} [code] unified currency code, default is undefined
 * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
 * @param {int} [limit] max number of ledger entries to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger}
 */
func  (this *ndax) FetchLedger(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var omsId interface{} = this.SafeInteger(this.Options, "omsId", 1)
        
            retRes13128 := (<-this.LoadMarkets())
            PanicOnError(retRes13128)
        
            retRes13138 := (<-this.LoadAccounts())
            PanicOnError(retRes13138)
            var defaultAccountId interface{} = this.SafeInteger2(this.Options, "accountId", "AccountId", ParseInt(GetValue(GetValue(this.Accounts, 0), "id")))
            var accountId interface{} = this.SafeInteger2(params, "accountId", "AccountId", defaultAccountId)
            params = this.Omit(params, []interface{}{"accountId", "AccountId"})
            var request interface{} = map[string]interface{} {
                "omsId": omsId,
                "AccountId": accountId,
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "Depth", limit)
            }
        
            response:= (<-this.PrivateGetGetAccountTransactions(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     [
            //         {
            //             "TransactionId":2663709493,
            //             "ReferenceId":68,
            //             "OMSId":1,
            //             "AccountId":449,
            //             "CR":10.000000000000000000000000000,
            //             "DR":0.0000000000000000000000000000,
            //             "Counterparty":3,
            //             "TransactionType":"Other",
            //             "ReferenceType":"Deposit",
            //             "ProductId":1,
            //             "Balance":10.000000000000000000000000000,
            //             "TimeStamp":1607532331591
            //         },
            //     ]
            //
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
            }
        
            ch <- this.ParseLedger(response, currency, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *ndax) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "Accepted": "open",
        "Rejected": "rejected",
        "Working": "open",
        "Canceled": "canceled",
        "Expired": "expired",
        "FullyExecuted": "closed",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *ndax) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // createOrder
    //
    //     {
    //         "status":"Accepted",
    //         "errormsg":"",
    //         "OrderId": 2543565231
    //     }
    //
    // editOrder
    //
    //     {
    //         "ReplacementOrderId": 1234,
    //         "ReplacementClOrdId": 1561,
    //         "OrigOrderId": 5678,
    //         "OrigClOrdId": 91011,
    //     }
    //
    // fetchOpenOrders, fetchClosedOrders
    //
    //     {
    //         "Side":"Buy",
    //         "OrderId":2543565233,
    //         "Price":19010,
    //         "Quantity":0.345,
    //         "DisplayQuantity":0.345,
    //         "Instrument":8,
    //         "Account":449,
    //         "AccountName":"igor@ccxt.trade",
    //         "OrderType":"Limit",
    //         "ClientOrderId":0,
    //         "OrderState":"Working",
    //         "ReceiveTime":1607579326003,
    //         "ReceiveTimeTicks":637431761260028981,
    //         "LastUpdatedTime":1607579326005,
    //         "LastUpdatedTimeTicks":637431761260054714,
    //         "OrigQuantity":0.345,
    //         "QuantityExecuted":0,
    //         "GrossValueExecuted":0,
    //         "ExecutableValue":0,
    //         "AvgPrice":0,
    //         "CounterPartyId":0,
    //         "ChangeReason":"NewInputAccepted",
    //         "OrigOrderId":2543565233,
    //         "OrigClOrdId":0,
    //         "EnteredBy":446,
    //         "UserName":"igor@ccxt.trade",
    //         "IsQuote":false,
    //         "InsideAsk":19069.32,
    //         "InsideAskSize":0.099736,
    //         "InsideBid":19068.25,
    //         "InsideBidSize":1.330001,
    //         "LastTradePrice":19068.25,
    //         "RejectReason":"",
    //         "IsLockedIn":false,
    //         "CancelReason":"",
    //         "OrderFlag":"AddedToBook",
    //         "UseMargin":false,
    //         "StopPrice":0,
    //         "PegPriceType":"Unknown",
    //         "PegOffset":0,
    //         "PegLimitOffset":0,
    //         "IpAddress":null,
    //         "ClientOrderIdUuid":null,
    //         "OMSId":1
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger(order, "ReceiveTime")
    var marketId interface{} = this.SafeString(order, "Instrument")
    return this.SafeOrder(map[string]interface{} {
        "id": this.SafeString2(order, "ReplacementOrderId", "OrderId"),
        "clientOrderId": this.SafeString2(order, "ReplacementClOrdId", "ClientOrderId"),
        "info": order,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": this.SafeInteger(order, "LastUpdatedTime"),
        "status": this.ParseOrderStatus(this.SafeString(order, "OrderState")),
        "symbol": this.SafeSymbol(marketId, market),
        "type": this.SafeStringLower(order, "OrderType"),
        "timeInForce": nil,
        "postOnly": nil,
        "side": this.SafeStringLower(order, "Side"),
        "price": this.SafeString(order, "Price"),
        "triggerPrice": this.ParseNumber(this.OmitZero(this.SafeString(order, "StopPrice"))),
        "cost": this.SafeString(order, "GrossValueExecuted"),
        "amount": this.SafeString(order, "OrigQuantity"),
        "filled": this.SafeString(order, "QuantityExecuted"),
        "average": this.SafeString(order, "AvgPrice"),
        "remaining": nil,
        "fee": nil,
        "trades": nil,
    }, market)
}
/**
 * @method
 * @name ndax#createOrder
 * @description create a trade order
 * @see https://apidoc.ndax.io/#sendorder
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {float} [params.triggerPrice] the price at which a trigger order would be triggered
 * @param {string} [params.clientOrderId] a unique id for the order
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *ndax) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var omsId interface{} = this.SafeInteger(this.Options, "omsId", 1)
        
            retRes14748 := (<-this.LoadMarkets())
            PanicOnError(retRes14748)
        
            retRes14758 := (<-this.LoadAccounts())
            PanicOnError(retRes14758)
            var defaultAccountId interface{} = this.SafeInteger2(this.Options, "accountId", "AccountId", ParseInt(GetValue(GetValue(this.Accounts, 0), "id")))
            var accountId interface{} = this.SafeInteger2(params, "accountId", "AccountId", defaultAccountId)
            var clientOrderId interface{} = this.SafeInteger2(params, "ClientOrderId", "clientOrderId")
            var orderType interface{} = this.SafeInteger(GetValue(this.Options, "orderTypes"), this.Capitalize(typeVar))
            var triggerPrice interface{} = this.SafeString(params, "triggerPrice")
            if IsTrue(!IsEqual(triggerPrice, nil)) {
                if IsTrue(IsEqual(typeVar, "market")) {
                    orderType = 3
                } else if IsTrue(IsEqual(typeVar, "limit")) {
                    orderType = 4
                }
            }
            params = this.Omit(params, []interface{}{"accountId", "AccountId", "clientOrderId", "ClientOrderId", "triggerPrice"})
            var market interface{} = this.Market(symbol)
            var orderSide interface{} = Ternary(IsTrue((IsEqual(side, "buy"))), 0, 1)
            var request interface{} = map[string]interface{} {
                "InstrumentId": ParseInt(GetValue(market, "id")),
                "omsId": omsId,
                "AccountId": accountId,
                "TimeInForce": 1,
                "Side": orderSide,
                "Quantity": ParseFloat(this.AmountToPrecision(symbol, amount)),
                "OrderType": orderType,
            }
            // If OrderType=1 (Market), Side=0 (Buy), and LimitPrice is supplied, the Market order will execute up to the value specified
            if IsTrue(!IsEqual(price, nil)) {
                AddElementToObject(request, "LimitPrice", ParseFloat(this.PriceToPrecision(symbol, price)))
            }
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                AddElementToObject(request, "ClientOrderId", clientOrderId)
            }
            if IsTrue(!IsEqual(triggerPrice, nil)) {
                AddElementToObject(request, "StopPrice", triggerPrice)
            }
        
            response:= (<-this.PrivatePostSendOrder(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "status":"Accepted",
            //         "errormsg":"",
            //         "OrderId": 2543565231
            //     }
            //
        ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
func  (this *ndax) EditOrder(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    amount := GetArg(optionalArgs, 0, nil)
            _ = amount
            price := GetArg(optionalArgs, 1, nil)
            _ = price
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
            var omsId interface{} = this.SafeInteger(this.Options, "omsId", 1)
        
            retRes15328 := (<-this.LoadMarkets())
            PanicOnError(retRes15328)
        
            retRes15338 := (<-this.LoadAccounts())
            PanicOnError(retRes15338)
            var defaultAccountId interface{} = this.SafeInteger2(this.Options, "accountId", "AccountId", ParseInt(GetValue(GetValue(this.Accounts, 0), "id")))
            var accountId interface{} = this.SafeInteger2(params, "accountId", "AccountId", defaultAccountId)
            var clientOrderId interface{} = this.SafeInteger2(params, "ClientOrderId", "clientOrderId")
            params = this.Omit(params, []interface{}{"accountId", "AccountId", "clientOrderId", "ClientOrderId"})
            var market interface{} = this.Market(symbol)
            var orderSide interface{} = Ternary(IsTrue((IsEqual(side, "buy"))), 0, 1)
            var request interface{} = map[string]interface{} {
                "OrderIdToReplace": ParseInt(id),
                "InstrumentId": ParseInt(GetValue(market, "id")),
                "omsId": omsId,
                "AccountId": accountId,
                "TimeInForce": 1,
                "Side": orderSide,
                "Quantity": ParseFloat(this.AmountToPrecision(symbol, amount)),
                "OrderType": this.SafeInteger(GetValue(this.Options, "orderTypes"), this.Capitalize(typeVar)),
            }
            // If OrderType=1 (Market), Side=0 (Buy), and LimitPrice is supplied, the Market order will execute up to the value specified
            if IsTrue(!IsEqual(price, nil)) {
                AddElementToObject(request, "LimitPrice", ParseFloat(this.PriceToPrecision(symbol, price)))
            }
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                AddElementToObject(request, "ClientOrderId", clientOrderId)
            }
        
            response:= (<-this.PrivatePostCancelReplaceOrder(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "replacementOrderId": 1234,
            //         "replacementClOrdId": 1561,
            //         "origOrderId": 5678,
            //         "origClOrdId": 91011,
            //     }
            //
        ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ndax#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://apidoc.ndax.io/#gettradeshistory
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *ndax) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var omsId interface{} = this.SafeInteger(this.Options, "omsId", 1)
        
            retRes15918 := (<-this.LoadMarkets())
            PanicOnError(retRes15918)
        
            retRes15928 := (<-this.LoadAccounts())
            PanicOnError(retRes15928)
            var defaultAccountId interface{} = this.SafeInteger2(this.Options, "accountId", "AccountId", ParseInt(GetValue(GetValue(this.Accounts, 0), "id")))
            var accountId interface{} = this.SafeInteger2(params, "accountId", "AccountId", defaultAccountId)
            params = this.Omit(params, []interface{}{"accountId", "AccountId"})
            var request interface{} = map[string]interface{} {
                "omsId": omsId,
                "AccountId": accountId,
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "InstrumentId", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "StartTimeStamp", this.ParseToInt(Divide(since, 1000)))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "Depth", limit)
            }
        
            response:= (<-this.PrivateGetGetTradesHistory(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "OMSId":1,
            //             "ExecutionId":16916567,
            //             "TradeId":14476351,
            //             "OrderId":2543565231,
            //             "AccountId":449,
            //             "AccountName":"igor@ccxt.trade",
            //             "SubAccountId":0,
            //             "ClientOrderId":0,
            //             "InstrumentId":8,
            //             "Side":"Sell",
            //             "OrderType":"Market",
            //             "Quantity":0.1230000000000000000000000000,
            //             "RemainingQuantity":0.0000000000000000000000000000,
            //             "Price":19069.310000000000000000000000,
            //             "Value":2345.5251300000000000000000000,
            //             "CounterParty":"7",
            //             "OrderTradeRevision":1,
            //             "Direction":"NoChange",
            //             "IsBlockTrade":false,
            //             "Fee":1.1727625650000000000000000000,
            //             "FeeProductId":8,
            //             "OrderOriginator":446,
            //             "UserName":"igor@ccxt.trade",
            //             "TradeTimeMS":1607565031569,
            //             "MakerTaker":"Taker",
            //             "AdapterTradeId":0,
            //             "InsideBid":19069.310000000000000000000000,
            //             "InsideBidSize":0.2400950000000000000000000000,
            //             "InsideAsk":19069.320000000000000000000000,
            //             "InsideAskSize":0.0997360000000000000000000000,
            //             "IsQuote":false,
            //             "CounterPartyClientUserId":1,
            //             "NotionalProductId":2,
            //             "NotionalRate":1.0000000000000000000000000000,
            //             "NotionalValue":2345.5251300000000000000000000,
            //             "NotionalHoldAmount":0,
            //             "TradeTime":637431618315686826
            //         }
            //     ]
            //
        ch <- this.ParseTrades(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ndax#cancelAllOrders
 * @description cancel all open orders
 * @see https://apidoc.ndax.io/#cancelallorders
 * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *ndax) CancelAllOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var omsId interface{} = this.SafeInteger(this.Options, "omsId", 1)
        
            retRes16788 := (<-this.LoadMarkets())
            PanicOnError(retRes16788)
        
            retRes16798 := (<-this.LoadAccounts())
            PanicOnError(retRes16798)
            var defaultAccountId interface{} = this.SafeInteger2(this.Options, "accountId", "AccountId", ParseInt(GetValue(GetValue(this.Accounts, 0), "id")))
            var accountId interface{} = this.SafeInteger2(params, "accountId", "AccountId", defaultAccountId)
            params = this.Omit(params, []interface{}{"accountId", "AccountId"})
            var request interface{} = map[string]interface{} {
                "omsId": omsId,
                "AccountId": accountId,
            }
            if IsTrue(!IsEqual(symbol, nil)) {
                var market interface{} = this.Market(symbol)
                AddElementToObject(request, "IntrumentId", GetValue(market, "id"))
            }
        
            response:= (<-this.PrivatePostCancelAllOrders(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "result":true,
            //         "errormsg":null,
            //         "errorcode":0,
            //         "detail":null
            //     }
            //
        ch <- []interface{}{this.SafeOrder(map[string]interface{} {
            "info": response,
        })}
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ndax#cancelOrder
 * @description cancels an open order
 * @see https://apidoc.ndax.io/#cancelorder
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.clientOrderId] a unique id for the order
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *ndax) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var omsId interface{} = this.SafeInteger(this.Options, "omsId", 1)
        
            retRes17208 := (<-this.LoadMarkets())
            PanicOnError(retRes17208)
        
            retRes17218 := (<-this.LoadAccounts())
            PanicOnError(retRes17218)
            // const defaultAccountId = this.safeInteger2 (this.options, 'accountId', 'AccountId', parseInt (this.accounts[0]['id']));
            // const accountId = this.safeInteger2 (params, 'accountId', 'AccountId', defaultAccountId);
            // params = this.omit (params, [ 'accountId', 'AccountId' ]);
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var request interface{} = map[string]interface{} {
                "omsId": omsId,
            }
            var clientOrderId interface{} = this.SafeInteger2(params, "clientOrderId", "ClOrderId")
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                AddElementToObject(request, "ClOrderId", clientOrderId)
            } else {
                AddElementToObject(request, "OrderId", ParseInt(id))
            }
            params = this.Omit(params, []interface{}{"clientOrderId", "ClOrderId"})
        
            response:= (<-this.PrivatePostCancelOrder(this.Extend(request, params)))
            PanicOnError(response)
            var order interface{} = this.ParseOrder(response, market)
        
            ch <- this.Extend(order, map[string]interface{} {
                "id": id,
                "clientOrderId": clientOrderId,
            })
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ndax#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://apidoc.ndax.io/#getopenorders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *ndax) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var omsId interface{} = this.SafeInteger(this.Options, "omsId", 1)
        
            retRes17618 := (<-this.LoadMarkets())
            PanicOnError(retRes17618)
        
            retRes17628 := (<-this.LoadAccounts())
            PanicOnError(retRes17628)
            var defaultAccountId interface{} = this.SafeInteger2(this.Options, "accountId", "AccountId", ParseInt(GetValue(GetValue(this.Accounts, 0), "id")))
            var accountId interface{} = this.SafeInteger2(params, "accountId", "AccountId", defaultAccountId)
            params = this.Omit(params, []interface{}{"accountId", "AccountId"})
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var request interface{} = map[string]interface{} {
                "omsId": omsId,
                "AccountId": accountId,
            }
        
            response:= (<-this.PrivateGetGetOpenOrders(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "Side":"Buy",
            //             "OrderId":2543565233,
            //             "Price":19010,
            //             "Quantity":0.345,
            //             "DisplayQuantity":0.345,
            //             "Instrument":8,
            //             "Account":449,
            //             "AccountName":"igor@ccxt.trade",
            //             "OrderType":"Limit",
            //             "ClientOrderId":0,
            //             "OrderState":"Working",
            //             "ReceiveTime":1607579326003,
            //             "ReceiveTimeTicks":637431761260028981,
            //             "LastUpdatedTime":1607579326005,
            //             "LastUpdatedTimeTicks":637431761260054714,
            //             "OrigQuantity":0.345,
            //             "QuantityExecuted":0,
            //             "GrossValueExecuted":0,
            //             "ExecutableValue":0,
            //             "AvgPrice":0,
            //             "CounterPartyId":0,
            //             "ChangeReason":"NewInputAccepted",
            //             "OrigOrderId":2543565233,
            //             "OrigClOrdId":0,
            //             "EnteredBy":446,
            //             "UserName":"igor@ccxt.trade",
            //             "IsQuote":false,
            //             "InsideAsk":19069.32,
            //             "InsideAskSize":0.099736,
            //             "InsideBid":19068.25,
            //             "InsideBidSize":1.330001,
            //             "LastTradePrice":19068.25,
            //             "RejectReason":"",
            //             "IsLockedIn":false,
            //             "CancelReason":"",
            //             "OrderFlag":"AddedToBook",
            //             "UseMargin":false,
            //             "StopPrice":0,
            //             "PegPriceType":"Unknown",
            //             "PegOffset":0,
            //             "PegLimitOffset":0,
            //             "IpAddress":null,
            //             "ClientOrderIdUuid":null,
            //             "OMSId":1
            //         }
            //     ]
            //
        ch <- this.ParseOrders(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ndax#fetchOrders
 * @description fetches information on multiple orders made by the user
 * @see https://apidoc.ndax.io/#getorderhistory
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *ndax) FetchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var omsId interface{} = this.SafeInteger(this.Options, "omsId", 1)
        
            retRes18418 := (<-this.LoadMarkets())
            PanicOnError(retRes18418)
        
            retRes18428 := (<-this.LoadAccounts())
            PanicOnError(retRes18428)
            var defaultAccountId interface{} = this.SafeInteger2(this.Options, "accountId", "AccountId", ParseInt(GetValue(GetValue(this.Accounts, 0), "id")))
            var accountId interface{} = this.SafeInteger2(params, "accountId", "AccountId", defaultAccountId)
            params = this.Omit(params, []interface{}{"accountId", "AccountId"})
            var request interface{} = map[string]interface{} {
                "omsId": omsId,
                "AccountId": accountId,
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "InstrumentId", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "StartTimeStamp", this.ParseToInt(Divide(since, 1000)))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "Depth", limit)
            }
        
            response:= (<-this.PrivateGetGetOrdersHistory(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "Side":"Buy",
            //             "OrderId":2543565233,
            //             "Price":19010.000000000000000000000000,
            //             "Quantity":0.0000000000000000000000000000,
            //             "DisplayQuantity":0.3450000000000000000000000000,
            //             "Instrument":8,
            //             "Account":449,
            //             "AccountName":"igor@ccxt.trade",
            //             "OrderType":"Limit",
            //             "ClientOrderId":0,
            //             "OrderState":"Canceled",
            //             "ReceiveTime":1607579326003,
            //             "ReceiveTimeTicks":637431761260028981,
            //             "LastUpdatedTime":1607580965346,
            //             "LastUpdatedTimeTicks":637431777653463754,
            //             "OrigQuantity":0.3450000000000000000000000000,
            //             "QuantityExecuted":0.0000000000000000000000000000,
            //             "GrossValueExecuted":0.0000000000000000000000000000,
            //             "ExecutableValue":0.0000000000000000000000000000,
            //             "AvgPrice":0.0000000000000000000000000000,
            //             "CounterPartyId":0,
            //             "ChangeReason":"UserModified",
            //             "OrigOrderId":2543565233,
            //             "OrigClOrdId":0,
            //             "EnteredBy":446,
            //             "UserName":"igor@ccxt.trade",
            //             "IsQuote":false,
            //             "InsideAsk":19069.320000000000000000000000,
            //             "InsideAskSize":0.0997360000000000000000000000,
            //             "InsideBid":19068.250000000000000000000000,
            //             "InsideBidSize":1.3300010000000000000000000000,
            //             "LastTradePrice":19068.250000000000000000000000,
            //             "RejectReason":"",
            //             "IsLockedIn":false,
            //             "CancelReason":"UserModified",
            //             "OrderFlag":"AddedToBook, RemovedFromBook",
            //             "UseMargin":false,
            //             "StopPrice":0.0000000000000000000000000000,
            //             "PegPriceType":"Unknown",
            //             "PegOffset":0.0000000000000000000000000000,
            //             "PegLimitOffset":0.0000000000000000000000000000,
            //             "IpAddress":"x.x.x.x",
            //             "ClientOrderIdUuid":null,
            //             "OMSId":1
            //         },
            //     ]
            //
        ch <- this.ParseOrders(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ndax#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://apidoc.ndax.io/#getorderstatus
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *ndax) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var omsId interface{} = this.SafeInteger(this.Options, "omsId", 1)
        
            retRes19368 := (<-this.LoadMarkets())
            PanicOnError(retRes19368)
        
            retRes19378 := (<-this.LoadAccounts())
            PanicOnError(retRes19378)
            var defaultAccountId interface{} = this.SafeInteger2(this.Options, "accountId", "AccountId", ParseInt(GetValue(GetValue(this.Accounts, 0), "id")))
            var accountId interface{} = this.SafeInteger2(params, "accountId", "AccountId", defaultAccountId)
            params = this.Omit(params, []interface{}{"accountId", "AccountId"})
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var request interface{} = map[string]interface{} {
                "omsId": omsId,
                "AccountId": accountId,
                "OrderId": ParseInt(id),
            }
        
            response:= (<-this.PrivateGetGetOrderStatus(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "Side":"Sell",
            //         "OrderId":2543565232,
            //         "Price":0.0000000000000000000000000000,
            //         "Quantity":0.0000000000000000000000000000,
            //         "DisplayQuantity":0.0000000000000000000000000000,
            //         "Instrument":8,
            //         "Account":449,
            //         "AccountName":"igor@ccxt.trade",
            //         "OrderType":"Market",
            //         "ClientOrderId":0,
            //         "OrderState":"FullyExecuted",
            //         "ReceiveTime":1607569475591,
            //         "ReceiveTimeTicks":637431662755912377,
            //         "LastUpdatedTime":1607569475596,
            //         "LastUpdatedTimeTicks":637431662755960902,
            //         "OrigQuantity":1.0000000000000000000000000000,
            //         "QuantityExecuted":1.0000000000000000000000000000,
            //         "GrossValueExecuted":19068.270478610000000000000000,
            //         "ExecutableValue":0.0000000000000000000000000000,
            //         "AvgPrice":19068.270478610000000000000000,
            //         "CounterPartyId":0,
            //         "ChangeReason":"Trade",
            //         "OrigOrderId":2543565232,
            //         "OrigClOrdId":0,
            //         "EnteredBy":446,
            //         "UserName":"igor@ccxt.trade",
            //         "IsQuote":false,
            //         "InsideAsk":19069.320000000000000000000000,
            //         "InsideAskSize":0.0997360000000000000000000000,
            //         "InsideBid":19069.310000000000000000000000,
            //         "InsideBidSize":0.2400950000000000000000000000,
            //         "LastTradePrice":19069.310000000000000000000000,
            //         "RejectReason":"",
            //         "IsLockedIn":false,
            //         "CancelReason":"",
            //         "OrderFlag":"0",
            //         "UseMargin":false,
            //         "StopPrice":0.0000000000000000000000000000,
            //         "PegPriceType":"Unknown",
            //         "PegOffset":0.0000000000000000000000000000,
            //         "PegLimitOffset":0.0000000000000000000000000000,
            //         "IpAddress":"x.x.x.x",
            //         "ClientOrderIdUuid":null,
            //         "OMSId":1
            //     }
            //
        ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ndax#fetchOrderTrades
 * @description fetch all the trades made from a single order
 * @see https://apidoc.ndax.io/#getorderhistorybyorderid
 * @param {string} id order id
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *ndax) FetchOrderTrades(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var omsId interface{} = this.SafeInteger(this.Options, "omsId", 1)
        
            retRes20168 := (<-this.LoadMarkets())
            PanicOnError(retRes20168)
        
            retRes20178 := (<-this.LoadAccounts())
            PanicOnError(retRes20178)
            // const defaultAccountId = this.safeInteger2 (this.options, 'accountId', 'AccountId', parseInt (this.accounts[0]['id']));
            // const accountId = this.safeInteger2 (params, 'accountId', 'AccountId', defaultAccountId);
            // params = this.omit (params, [ 'accountId', 'AccountId' ]);
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var request interface{} = map[string]interface{} {
                "OMSId": this.ParseToInt(omsId),
                "OrderId": ParseInt(id),
            }
        
            response:= (<-this.PrivatePostGetOrderHistoryByOrderId(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     [
            //         {
            //             "Side":"Sell",
            //             "OrderId":2543565235,
            //             "Price":18600.000000000000000000000000,
            //             "Quantity":0.0000000000000000000000000000,
            //             "DisplayQuantity":0.0000000000000000000000000000,
            //             "Instrument":8,
            //             "Account":449,
            //             "AccountName":"igor@ccxt.trade",
            //             "OrderType":"Limit",
            //             "ClientOrderId":0,
            //             "OrderState":"FullyExecuted",
            //             "ReceiveTime":1607585844956,
            //             "ReceiveTimeTicks":637431826449564182,
            //             "LastUpdatedTime":1607585844959,
            //             "LastUpdatedTimeTicks":637431826449593893,
            //             "OrigQuantity":0.1230000000000000000000000000,
            //             "QuantityExecuted":0.1230000000000000000000000000,
            //             "GrossValueExecuted":2345.3947500000000000000000000,
            //             "ExecutableValue":0.0000000000000000000000000000,
            //             "AvgPrice":19068.250000000000000000000000,
            //             "CounterPartyId":0,
            //             "ChangeReason":"Trade",
            //             "OrigOrderId":2543565235,
            //             "OrigClOrdId":0,
            //             "EnteredBy":446,
            //             "UserName":"igor@ccxt.trade",
            //             "IsQuote":false,
            //             "InsideAsk":19069.320000000000000000000000,
            //             "InsideAskSize":0.0997360000000000000000000000,
            //             "InsideBid":19068.250000000000000000000000,
            //             "InsideBidSize":1.3300010000000000000000000000,
            //             "LastTradePrice":19068.250000000000000000000000,
            //             "RejectReason":"",
            //             "IsLockedIn":false,
            //             "CancelReason":"",
            //             "OrderFlag":"0",
            //             "UseMargin":false,
            //             "StopPrice":0.0000000000000000000000000000,
            //             "PegPriceType":"Unknown",
            //             "PegOffset":0.0000000000000000000000000000,
            //             "PegLimitOffset":0.0000000000000000000000000000,
            //             "IpAddress":"x.x.x.x",
            //             "ClientOrderIdUuid":null,
            //             "OMSId":1
            //         },
            //     ]
            //
            var grouped interface{} = this.GroupBy(response, "ChangeReason")
            var trades interface{} = this.SafeList(grouped, "Trade", []interface{}{})
        
            ch <- this.ParseTrades(trades, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ndax#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *ndax) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var omsId interface{} = this.SafeInteger(this.Options, "omsId", 1)
        
            retRes20968 := (<-this.LoadMarkets())
            PanicOnError(retRes20968)
        
            retRes20978 := (<-this.LoadAccounts())
            PanicOnError(retRes20978)
            var defaultAccountId interface{} = this.SafeInteger2(this.Options, "accountId", "AccountId", ParseInt(GetValue(GetValue(this.Accounts, 0), "id")))
            var accountId interface{} = this.SafeInteger2(params, "accountId", "AccountId", defaultAccountId)
            params = this.Omit(params, []interface{}{"accountId", "AccountId"})
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "omsId": omsId,
                "AccountId": accountId,
                "ProductId": GetValue(currency, "id"),
                "GenerateNewKey": false,
            }
        
            response:= (<-this.PrivateGetGetDepositInfo(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "result":true,
            //         "errormsg":null,
            //         "statuscode":0,
            //         "AssetManagerId":1,
            //         "AccountId":57922,
            //         "AssetId":16,
            //         "ProviderId":23,
            //         "DepositInfo":"[\"0x8A27564b5c30b91C93B1591821642420F323a210\"]"
            //     }
            //
        ch <- this.ParseDepositAddress(response, currency)
            return nil
        
            }()
            return ch
        }
func  (this *ndax) ParseDepositAddress(depositAddress interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchDepositAddress, createDepositAddress
    //
    //     {
    //         "result":true,
    //         "errormsg":null,
    //         "statuscode":0,
    //         "AssetManagerId":1,
    //         "AccountId":449,
    //         "AssetId":1,
    //         "ProviderId":1,
    //         "DepositInfo":"[\"r3e95RwVsLH7yCbnMfyh7SA8FdwUJCB4S2?memo=241452010\"]"
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var depositInfoString interface{} = this.SafeString(depositAddress, "DepositInfo")
    var depositInfo interface{} = JsonParse(depositInfoString)
    var depositInfoLength interface{} =     GetArrayLength(depositInfo)
    var lastString interface{} = this.SafeString(depositInfo, Subtract(depositInfoLength, 1))
    var parts interface{} = Split(lastString, "?memo=")
    var address interface{} = this.SafeString(parts, 0)
    var tag interface{} = this.SafeString(parts, 1)
    var code interface{} = nil
    if IsTrue(!IsEqual(currency, nil)) {
        code = GetValue(currency, "code")
    }
    this.CheckAddress(address)
    return map[string]interface{} {
        "info": depositAddress,
        "currency": code,
        "network": nil,
        "address": address,
        "tag": tag,
    }
}
/**
 * @method
 * @name ndax#createDepositAddress
 * @description create a currency deposit address
 * @param {string} code unified currency code of the currency for the deposit address
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *ndax) CreateDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "GenerateNewKey": true,
            }
        
                retRes217215 :=  (<-this.FetchDepositAddress(code, this.Extend(request, params)))
                PanicOnError(retRes217215)
                ch <- retRes217215
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ndax#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://apidoc.ndax.io/#getdeposits
 * @param {string} code unified currency code
 * @param {int} [since] not used by ndax fetchDeposits
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *ndax) FetchDeposits(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var omsId interface{} = this.SafeInteger(this.Options, "omsId", 1)
        
            retRes21888 := (<-this.LoadMarkets())
            PanicOnError(retRes21888)
        
            retRes21898 := (<-this.LoadAccounts())
            PanicOnError(retRes21898)
            var defaultAccountId interface{} = this.SafeInteger2(this.Options, "accountId", "AccountId", ParseInt(GetValue(GetValue(this.Accounts, 0), "id")))
            var accountId interface{} = this.SafeInteger2(params, "accountId", "AccountId", defaultAccountId)
            params = this.Omit(params, []interface{}{"accountId", "AccountId"})
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
            }
            var request interface{} = map[string]interface{} {
                "omsId": omsId,
                "AccountId": accountId,
            }
        
            response:= (<-this.PrivateGetGetDeposits(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    "[
            //        {
            //            "OMSId": 1,
            //            "DepositId": 44,
            //            "AccountId": 449,
            //            "SubAccountId": 0,
            //            "ProductId": 4,
            //            "Amount": 200.00000000000000000000000000,
            //            "LastUpdateTimeStamp": 637431291261187806,
            //            "ProductType": "CryptoCurrency",
            //            "TicketStatus": "FullyProcessed",
            //            "DepositInfo": "{
            //                "AccountProviderId":42,
            //                "AccountProviderName":"USDT_BSC",
            //                "TXId":"0x3879b02632c69482646409e991149290bc9a58e4603be63c7c2c90a843f45d2b",
            //                "FromAddress":"0x8894E0a0c962CB723c1976a4421c95949bE2D4E3",
            //                "ToAddress":"0x5428EcEB1F7Ee058f64158589e27D087149230CB"
            //            },",
            //            "DepositCode": "ab0e23d5-a9ce-4d94-865f-9ab464fb1de3",
            //            "TicketNumber": 71,
            //            "NotionalProductId": 13,
            //            "NotionalValue": 200.00000000000000000000000000,
            //            "FeeAmount": 0.0000000000000000000000000000,
            //        },
            //        ...
            //    ]"
            //
            if IsTrue(IsString(response)) {
        
                ch <- this.ParseTransactions(JsonParse(response), currency, since, limit)
                return nil
            }
        
            ch <- this.ParseTransactions(response, currency, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ndax#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @see https://apidoc.ndax.io/#getwithdraws
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawals structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *ndax) FetchWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var omsId interface{} = this.SafeInteger(this.Options, "omsId", 1)
        
            retRes22498 := (<-this.LoadMarkets())
            PanicOnError(retRes22498)
        
            retRes22508 := (<-this.LoadAccounts())
            PanicOnError(retRes22508)
            var defaultAccountId interface{} = this.SafeInteger2(this.Options, "accountId", "AccountId", ParseInt(GetValue(GetValue(this.Accounts, 0), "id")))
            var accountId interface{} = this.SafeInteger2(params, "accountId", "AccountId", defaultAccountId)
            params = this.Omit(params, []interface{}{"accountId", "AccountId"})
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
            }
            var request interface{} = map[string]interface{} {
                "omsId": omsId,
                "AccountId": accountId,
            }
        
            response:= (<-this.PrivateGetGetWithdraws(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "Amount": 0.0,
            //             "FeeAmount": 0.0,
            //             "NotionalValue": 0.0,
            //             "WithdrawId": 0,
            //             "AssetManagerId": 0,
            //             "AccountId": 0,
            //             "AssetId": 0,
            //             "TemplateForm": "{\"TemplateType\": \"TetherRPCWithdraw\",\"Comment\": \"TestWithdraw\",\"ExternalAddress\": \"ms6C3pKAAr8gRCcnVebs8VRkVrjcvqNYv3\"}",
            //             "TemplateFormType": "TetherRPCWithdraw",
            //             "omsId": 0,
            //             "TicketStatus": 0,
            //             "TicketNumber": 0,
            //             "WithdrawTransactionDetails": "",
            //             "WithdrawType": "",
            //             "WithdrawCode": "490b4fa3-53fc-44f4-bd29-7e16be86fba3",
            //             "AssetType": 0,
            //             "Reaccepted": true,
            //             "NotionalProductId": 0
            //         },
            //     ]
            //
        ch <- this.ParseTransactions(response, currency, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *ndax) ParseTransactionStatusByType(status interface{}, optionalArgs ...interface{}) interface{}  {
    typeVar := GetArg(optionalArgs, 0, nil)
    _ = typeVar
    var statusesByType interface{} = map[string]interface{} {
        "deposit": map[string]interface{} {
            "New": "pending",
            "AdminProcessing": "pending",
            "Accepted": "pending",
            "Rejected": "rejected",
            "SystemProcessing": "pending",
            "FullyProcessed": "ok",
            "Failed": "failed",
            "Pending": "pending",
            "Confirmed": "pending",
            "AmlProcessing": "pending",
            "AmlAccepted": "pending",
            "AmlRejected": "rejected",
            "AmlFailed": "failed",
            "LimitsAccepted": "pending",
            "LimitsRejected": "rejected",
        },
        "withdrawal": map[string]interface{} {
            "New": "pending",
            "AdminProcessing": "pending",
            "Accepted": "pending",
            "Rejected": "rejected",
            "SystemProcessing": "pending",
            "FullyProcessed": "ok",
            "Failed": "failed",
            "Pending": "pending",
            "Pending2Fa": "pending",
            "AutoAccepted": "pending",
            "Delayed": "pending",
            "UserCanceled": "canceled",
            "AdminCanceled": "canceled",
            "AmlProcessing": "pending",
            "AmlAccepted": "pending",
            "AmlRejected": "rejected",
            "AmlFailed": "failed",
            "LimitsAccepted": "pending",
            "LimitsRejected": "rejected",
            "Submitted": "pending",
            "Confirmed": "pending",
            "ManuallyConfirmed": "pending",
            "Confirmed2Fa": "pending",
        },
    }
    var statuses interface{} = this.SafeValue(statusesByType, typeVar, map[string]interface{} {})
    return this.SafeString(statuses, status, status)
}
func  (this *ndax) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchDeposits
    //
    //    {
    //        "OMSId": 1,
    //        "DepositId": 44,
    //        "AccountId": 449,
    //        "SubAccountId": 0,
    //        "ProductId": 4,
    //        "Amount": 200.00000000000000000000000000,
    //        "LastUpdateTimeStamp": 637431291261187806,
    //        "ProductType": "CryptoCurrency",
    //        "TicketStatus": "FullyProcessed",
    //        "DepositInfo": "{
    //            "AccountProviderId":42,
    //            "AccountProviderName":"USDT_BSC",
    //            "TXId":"0x3879b02632c69482646409e991149290bc9a58e4603be63c7c2c90a843f45d2b",
    //            "FromAddress":"0x8894E0a0c962CB723c1976a4421c95949bE2D4E3",
    //            "ToAddress":"0x5428EcEB1F7Ee058f64158589e27D087149230CB"
    //        }",
    //        "DepositCode": "ab0e23d5-a9ce-4d94-865f-9ab464fb1de3",
    //        "TicketNumber": 71,
    //        "NotionalProductId": 13,
    //        "NotionalValue": 200.00000000000000000000000000,
    //        "FeeAmount": 0.0000000000000000000000000000,
    //     }
    //
    // fetchWithdrawals
    //
    //     {
    //         "Amount": 0.0,
    //         "FeeAmount": 0.0,
    //         "NotionalValue": 0.0,
    //         "WithdrawId": 0,
    //         "AssetManagerId": 0,
    //         "AccountId": 0,
    //         "AssetId": 0,
    //         "TemplateForm": "{\"TemplateType\": \"TetherRPCWithdraw\",\"Comment\": \"TestWithdraw\",\"ExternalAddress\": \"ms6C3pKAAr8gRCcnVebs8VRkVrjcvqNYv3\"}",
    //         "TemplateFormType": "TetherRPCWithdraw",
    //         "omsId": 0,
    //         "TicketStatus": 0,
    //         "TicketNumber": 0,
    //         "WithdrawTransactionDetails": "",
    //         "WithdrawType": "",
    //         "WithdrawCode": "490b4fa3-53fc-44f4-bd29-7e16be86fba3",
    //         "AssetType": 0,
    //         "Reaccepted": true,
    //         "NotionalProductId": 0
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var id interface{} = nil
    var currencyId interface{} = this.SafeString(transaction, "ProductId")
    var code interface{} = this.SafeCurrencyCode(currencyId, currency)
    var typeVar interface{} = nil
    if IsTrue(InOp(transaction, "DepositId")) {
        id = this.SafeString(transaction, "DepositId")
        typeVar = "deposit"
    } else if IsTrue(InOp(transaction, "WithdrawId")) {
        id = this.SafeString(transaction, "WithdrawId")
        typeVar = "withdrawal"
    }
    var templateForm interface{} = this.ParseJson(this.SafeValue2(transaction, "TemplateForm", "DepositInfo"))
    var updated interface{} = this.SafeInteger(transaction, "LastUpdateTimeStamp")
    if IsTrue(!IsEqual(templateForm, nil)) {
        updated = this.SafeInteger(templateForm, "LastUpdated", updated)
    }
    var address interface{} = this.SafeString2(templateForm, "ExternalAddress", "ToAddress")
    var timestamp interface{} = this.SafeInteger(templateForm, "TimeSubmitted")
    var feeCost interface{} = this.SafeNumber(transaction, "FeeAmount")
    var transactionStatus interface{} = this.SafeString(transaction, "TicketStatus")
    var fee interface{} = nil
    if IsTrue(!IsEqual(feeCost, nil)) {
        fee = map[string]interface{} {
            "currency": code,
            "cost": feeCost,
        }
    }
    return map[string]interface{} {
        "info": transaction,
        "id": id,
        "txid": this.SafeString2(templateForm, "TxId", "TXId"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "address": address,
        "addressTo": address,
        "addressFrom": this.SafeString(templateForm, "FromAddress"),
        "tag": nil,
        "tagTo": nil,
        "tagFrom": nil,
        "type": typeVar,
        "amount": this.SafeNumber(transaction, "Amount"),
        "currency": code,
        "status": this.ParseTransactionStatusByType(transactionStatus, typeVar),
        "updated": updated,
        "fee": fee,
        "internal": nil,
        "comment": nil,
        "network": nil,
    }
}
/**
 * @method
 * @name ndax#withdraw
 * @description make a withdrawal
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *ndax) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params);
            tag = GetValue(tagparamsVariable,0);
            params = GetValue(tagparamsVariable,1)
            // this method required login, password and twofa key
            var sessionToken interface{} = this.SafeString(this.Options, "sessionToken")
            if IsTrue(IsEqual(sessionToken, nil)) {
                panic(AuthenticationError(Add(this.Id, " call signIn() method to obtain a session token")))
            }
            if IsTrue(IsEqual(this.Twofa, nil)) {
                panic(AuthenticationError(Add(this.Id, " withdraw() requires exchange.twofa credentials")))
            }
            this.CheckAddress(address)
            var omsId interface{} = this.SafeInteger(this.Options, "omsId", 1)
        
            retRes24618 := (<-this.LoadMarkets())
            PanicOnError(retRes24618)
        
            retRes24628 := (<-this.LoadAccounts())
            PanicOnError(retRes24628)
            var defaultAccountId interface{} = this.SafeInteger2(this.Options, "accountId", "AccountId", ParseInt(GetValue(GetValue(this.Accounts, 0), "id")))
            var accountId interface{} = this.SafeInteger2(params, "accountId", "AccountId", defaultAccountId)
            params = this.Omit(params, []interface{}{"accountId", "AccountId"})
            var currency interface{} = this.Currency(code)
            var withdrawTemplateTypesRequest interface{} = map[string]interface{} {
                "omsId": omsId,
                "AccountId": accountId,
                "ProductId": GetValue(currency, "id"),
            }
        
            withdrawTemplateTypesResponse:= (<-this.PrivateGetGetWithdrawTemplateTypes(withdrawTemplateTypesRequest))
            PanicOnError(withdrawTemplateTypesResponse)
            //
            //     {
            //         "result": true,
            //         "errormsg": null,
            //         "statuscode": "0",
            //         "TemplateTypes": [
            //             { AccountProviderId: "14", TemplateName: "ToExternalBitcoinAddress", AccountProviderName: "BitgoRPC-BTC" },
            //             { AccountProviderId: "20", TemplateName: "ToExternalBitcoinAddress", AccountProviderName: "TrezorBTC" },
            //             { AccountProviderId: "31", TemplateName: "BTC", AccountProviderName: "BTC Fireblocks 1" }
            //         ]
            //     }
            //
            var templateTypes interface{} = this.SafeValue(withdrawTemplateTypesResponse, "TemplateTypes", []interface{}{})
            var firstTemplateType interface{} = this.SafeValue(templateTypes, 0)
            if IsTrue(IsEqual(firstTemplateType, nil)) {
                panic(ExchangeError(Add(Add(this.Id, " withdraw() could not find a withdraw template type for "), GetValue(currency, "code"))))
            }
            var templateName interface{} = this.SafeString(firstTemplateType, "TemplateName")
            var withdrawTemplateRequest interface{} = map[string]interface{} {
                "omsId": omsId,
                "AccountId": accountId,
                "ProductId": GetValue(currency, "id"),
                "TemplateType": templateName,
                "AccountProviderId": GetValue(firstTemplateType, "AccountProviderId"),
            }
        
            withdrawTemplateResponse:= (<-this.PrivateGetGetWithdrawTemplate(withdrawTemplateRequest))
            PanicOnError(withdrawTemplateResponse)
            //
            //     {
            //         "result": true,
            //         "errormsg": null,
            //         "statuscode": "0",
            //         "Template": "{\"TemplateType\":\"ToExternalBitcoinAddress\",\"Comment\":\"\",\"ExternalAddress\":\"\"}"
            //     }
            //
            var template interface{} = this.SafeString(withdrawTemplateResponse, "Template")
            if IsTrue(IsEqual(template, nil)) {
                panic(ExchangeError(Add(Add(this.Id, " withdraw() could not find a withdraw template for "), GetValue(currency, "code"))))
            }
            var withdrawTemplate interface{} = JsonParse(template)
            AddElementToObject(withdrawTemplate, "ExternalAddress", address)
            if IsTrue(!IsEqual(tag, nil)) {
                if IsTrue(InOp(withdrawTemplate, "Memo")) {
                    AddElementToObject(withdrawTemplate, "Memo", tag)
                }
            }
            var withdrawPayload interface{} = map[string]interface{} {
                "omsId": omsId,
                "AccountId": accountId,
                "ProductId": GetValue(currency, "id"),
                "TemplateForm": this.Json(withdrawTemplate),
                "TemplateType": templateName,
            }
            var withdrawRequest interface{} = map[string]interface{} {
                "TfaType": "Google",
                "TFaCode": Totp(this.Twofa),
                "Payload": this.Json(withdrawPayload),
            }
        
            response:= (<-this.PrivatePostCreateWithdrawTicket(this.DeepExtend(withdrawRequest, params)))
            PanicOnError(response)
        
            ch <- this.ParseTransaction(response, currency)
            return nil
        
            }()
            return ch
        }
func  (this *ndax) Nonce() interface{}  {
    return this.Milliseconds()
}
func  (this *ndax) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var url interface{} = Add(Add(GetValue(GetValue(this.Urls, "api"), api), "/"), this.ImplodeParams(path, params))
    var query interface{} = this.Omit(params, this.ExtractParams(path))
    if IsTrue(IsEqual(api, "public")) {
        if IsTrue(IsEqual(path, "Authenticate")) {
            var auth interface{} = Add(Add(this.Login, ":"), this.Password)
            var auth64 interface{} = this.StringToBase64(auth)
            headers = map[string]interface{} {
                "Authorization": Add("Basic ", auth64),
            }
        } else if IsTrue(IsEqual(path, "Authenticate2FA")) {
            var pending2faToken interface{} = this.SafeString(this.Options, "pending2faToken")
            if IsTrue(!IsEqual(pending2faToken, nil)) {
                headers = map[string]interface{} {
                    "Pending2FaToken": pending2faToken,
                }
                query = this.Omit(query, "pending2faToken")
            }
        }
        if IsTrue(GetArrayLength(ObjectKeys(query))) {
            url = Add(url, Add("?", this.Urlencode(query)))
        }
    } else if IsTrue(IsEqual(api, "private")) {
        this.CheckRequiredCredentials()
        var sessionToken interface{} = this.SafeString(this.Options, "sessionToken")
        if IsTrue(IsEqual(sessionToken, nil)) {
            var nonce interface{} = ToString(this.Nonce())
            var auth interface{} = Add(Add(nonce, this.Uid), this.ApiKey)
            var signature interface{} = this.Hmac(this.Encode(auth), this.Encode(this.Secret), sha256)
            headers = map[string]interface{} {
                "Nonce": nonce,
                "APIKey": this.ApiKey,
                "Signature": signature,
                "UserId": this.Uid,
            }
        } else {
            headers = map[string]interface{} {
                "APToken": sessionToken,
            }
        }
        if IsTrue(IsEqual(method, "POST")) {
            AddElementToObject(headers, "Content-Type", "application/json")
            body = this.Json(query)
        } else {
            if IsTrue(GetArrayLength(ObjectKeys(query))) {
                url = Add(url, Add("?", this.Urlencode(query)))
            }
        }
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *ndax) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsEqual(code, 404)) {
        panic(AuthenticationError(Add(Add(this.Id, " "), body)))
    }
    if IsTrue(IsEqual(response, nil)) {
        return nil
    }
    //
    //     {"status":"Rejected","errormsg":"Not_Enough_Funds","errorcode":101}
    //     {"result":false,"errormsg":"Server Error","errorcode":102,"detail":null}
    //
    var message interface{} = this.SafeString(response, "errormsg")
    if IsTrue(IsTrue((!IsEqual(message, nil))) && IsTrue((!IsEqual(message, "")))) {
        var feedback interface{} = Add(Add(this.Id, " "), body)
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), message, feedback)
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), body, feedback)
        panic(ExchangeError(feedback))
    }
    return nil
}


func (this *ndax) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
