package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type coincheck struct {
    Exchange

}

func NewCoincheckCore() coincheck {
   p := coincheck{}
   setDefaults(&p)
   return p
}

func  (this *coincheck) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "coincheck",
        "name": "coincheck",
        "countries": []interface{}{"JP", "ID"},
        "rateLimit": 1500,
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": false,
            "swap": false,
            "future": false,
            "option": false,
            "addMargin": false,
            "cancelOrder": true,
            "closeAllPositions": false,
            "closePosition": false,
            "createOrder": true,
            "createReduceOnlyOrder": false,
            "fetchBalance": true,
            "fetchBorrowRateHistories": false,
            "fetchBorrowRateHistory": false,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchDeposits": true,
            "fetchFundingHistory": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchIndexOHLCV": false,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchLeverage": false,
            "fetchMarginMode": false,
            "fetchMarkOHLCV": false,
            "fetchMyTrades": true,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrders": true,
            "fetchOrderBook": true,
            "fetchPosition": false,
            "fetchPositionHistory": false,
            "fetchPositionMode": false,
            "fetchPositions": false,
            "fetchPositionsForSymbol": false,
            "fetchPositionsHistory": false,
            "fetchPositionsRisk": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchTicker": true,
            "fetchTrades": true,
            "fetchTradingFee": false,
            "fetchTradingFees": true,
            "fetchWithdrawals": true,
            "reduceMargin": false,
            "setLeverage": false,
            "setMarginMode": false,
            "setPositionMode": false,
            "ws": true,
        },
        "urls": map[string]interface{} {
            "logo": "https://user-images.githubusercontent.com/51840849/87182088-1d6d6380-c2ec-11ea-9c64-8ab9f9b289f5.jpg",
            "api": map[string]interface{} {
                "rest": "https://coincheck.com/api",
            },
            "www": "https://coincheck.com",
            "doc": "https://coincheck.com/documents/exchange/api",
            "fees": []interface{}{"https://coincheck.com/exchange/fee", "https://coincheck.com/info/fee"},
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": []interface{}{"exchange/orders/rate", "order_books", "rate/{pair}", "ticker", "trades"},
            },
            "private": map[string]interface{} {
                "get": []interface{}{"accounts", "accounts/balance", "accounts/leverage_balance", "bank_accounts", "deposit_money", "exchange/orders/opens", "exchange/orders/transactions", "exchange/orders/transactions_pagination", "exchange/leverage/positions", "lending/borrows/matches", "send_money", "withdraws"},
                "post": []interface{}{"bank_accounts", "deposit_money/{id}/fast", "exchange/orders", "exchange/transfers/to_leverage", "exchange/transfers/from_leverage", "lending/borrows", "lending/borrows/{id}/repay", "send_money", "withdraws"},
                "delete": []interface{}{"bank_accounts/{id}", "exchange/orders/{id}", "withdraws/{id}"},
            },
        },
        "markets": map[string]interface{} {
            "BTC/JPY": this.SafeMarketStructure(map[string]interface{} {
                "id": "btc_jpy",
                "symbol": "BTC/JPY",
                "base": "BTC",
                "quote": "JPY",
                "baseId": "btc",
                "quoteId": "jpy",
                "type": "spot",
                "spot": true,
            }),
            "ETC/JPY": this.SafeMarketStructure(map[string]interface{} {
                "id": "etc_jpy",
                "symbol": "ETC/JPY",
                "base": "ETC",
                "quote": "JPY",
                "baseId": "etc",
                "quoteId": "jpy",
                "type": "spot",
                "spot": true,
            }),
            "FCT/JPY": this.SafeMarketStructure(map[string]interface{} {
                "id": "fct_jpy",
                "symbol": "FCT/JPY",
                "base": "FCT",
                "quote": "JPY",
                "baseId": "fct",
                "quoteId": "jpy",
                "type": "spot",
                "spot": true,
            }),
            "MONA/JPY": this.SafeMarketStructure(map[string]interface{} {
                "id": "mona_jpy",
                "symbol": "MONA/JPY",
                "base": "MONA",
                "quote": "JPY",
                "baseId": "mona",
                "quoteId": "jpy",
                "type": "spot",
                "spot": true,
            }),
            "ETC/BTC": this.SafeMarketStructure(map[string]interface{} {
                "id": "etc_btc",
                "symbol": "ETC/BTC",
                "base": "ETC",
                "quote": "BTC",
                "baseId": "etc",
                "quoteId": "btc",
                "type": "spot",
                "spot": true,
            }),
        },
        "features": map[string]interface{} {
            "spot": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": false,
                    "triggerPriceType": nil,
                    "triggerDirection": false,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": false,
                        "FOK": false,
                        "PO": true,
                        "GTD": false,
                    },
                    "hedged": false,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyByCost": false,
                    "marketBuyRequiresPrice": false,
                    "selfTradePrevention": false,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": nil,
                    "daysBack": nil,
                    "untilDays": nil,
                    "symbolRequired": true,
                },
                "fetchOrder": nil,
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": nil,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOrders": nil,
                "fetchClosedOrders": nil,
                "fetchOHLCV": nil,
            },
            "swap": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "tierBased": false,
                "percentage": true,
                "maker": this.ParseNumber("0"),
                "taker": this.ParseNumber("0"),
            },
        },
        "precisionMode": TICK_SIZE,
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "disabled API Key": AuthenticationError,
                "invalid authentication": AuthenticationError,
            },
            "broad": map[string]interface{} {},
        },
    })
}
func  (this *coincheck) ParseBalance(response interface{}) interface{}  {
    var result interface{} = map[string]interface{} {
        "info": response,
    }
    var codes interface{} = ObjectKeys(this.Currencies)
    for i := 0; IsLessThan(i, GetArrayLength(codes)); i++ {
        var code interface{} = GetValue(codes, i)
        var currency interface{} = this.Currency(code)
        var currencyId interface{} = GetValue(currency, "id")
        if IsTrue(InOp(response, currencyId)) {
            var account interface{} = this.Account()
            var reserved interface{} = Add(currencyId, "_reserved")
            AddElementToObject(account, "free", this.SafeString(response, currencyId))
            AddElementToObject(account, "used", this.SafeString(response, reserved))
            AddElementToObject(result, code, account)
        }
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name coincheck#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://coincheck.com/documents/exchange/api#order-transactions-pagination
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *coincheck) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes436372 := (<-this.LoadMarkets())
            PanicOnError(retRes436372)
        
            response:= (<-this.PrivateGetAccountsBalance(params))
            PanicOnError(response)
        
            ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coincheck#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://coincheck.com/documents/exchange/api#order-opens
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coincheck) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes344083 := (<-this.LoadMarkets())
            PanicOnError(retRes344083)
            // Only BTC/JPY is meaningful
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
        
            response:= (<-this.PrivateGetExchangeOrdersOpens(params))
            PanicOnError(response)
            var rawOrders interface{} = this.SafeValue(response, "orders", []interface{}{})
            var parsedOrders interface{} = this.ParseOrders(rawOrders, market, since, limit)
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(parsedOrders)); i++ {
                AppendToArray(&result,this.Extend(GetValue(parsedOrders, i), map[string]interface{} {
                    "status": "open",
                }))
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *coincheck) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchOpenOrders
    //
    //     {                        id:  202835,
    //                      "order_type": "buy",
    //                            "rate":  26890,
    //                            "pair": "btc_jpy",
    //                  "pending_amount": "0.5527",
    //       "pending_market_buy_amount":  null,
    //                  "stop_loss_rate":  null,
    //                      "created_at": "2015-01-10T05:55:38.000Z" }
    //
    // todo: add formats for fetchOrder, fetchClosedOrders here
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeString(order, "id")
    var side interface{} = this.SafeString(order, "order_type")
    var timestamp interface{} = this.Parse8601(this.SafeString(order, "created_at"))
    var amount interface{} = this.SafeString(order, "pending_amount")
    var remaining interface{} = this.SafeString(order, "pending_amount")
    var price interface{} = this.SafeString(order, "rate")
    var status interface{} = nil
    var marketId interface{} = this.SafeString(order, "pair")
    var symbol interface{} = this.SafeSymbol(marketId, market, "_")
    return this.SafeOrder(map[string]interface{} {
        "id": id,
        "clientOrderId": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "amount": amount,
        "remaining": remaining,
        "filled": nil,
        "side": side,
        "type": nil,
        "timeInForce": nil,
        "postOnly": nil,
        "status": status,
        "symbol": symbol,
        "price": price,
        "triggerPrice": nil,
        "cost": nil,
        "fee": nil,
        "info": order,
        "average": nil,
        "trades": nil,
    }, market)
}
/**
 * @method
 * @name coincheck#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://coincheck.com/documents/exchange/api#order-book
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *coincheck) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes965351 := (<-this.LoadMarkets())
            PanicOnError(retRes965351)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "pair": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetOrderBooks(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseOrderBook(response, GetValue(market, "symbol"))
            return nil
        
            }()
            return ch
        }
func  (this *coincheck) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // {
    //     "last":4192632.0,
    //     "bid":4192496.0,
    //     "ask":4193749.0,
    //     "high":4332000.0,
    //     "low":4101047.0,
    //     "volume":2313.43191762,
    //     "timestamp":1643374115
    // }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var symbol interface{} = this.SafeSymbol(nil, market)
    var timestamp interface{} = this.SafeTimestamp(ticker, "timestamp")
    var last interface{} = this.SafeString(ticker, "last")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeString(ticker, "high"),
        "low": this.SafeString(ticker, "low"),
        "bid": this.SafeString(ticker, "bid"),
        "bidVolume": nil,
        "ask": this.SafeString(ticker, "ask"),
        "askVolume": nil,
        "vwap": nil,
        "open": nil,
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": nil,
        "percentage": nil,
        "average": nil,
        "baseVolume": this.SafeString(ticker, "volume"),
        "quoteVolume": nil,
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name coincheck#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://coincheck.com/documents/exchange/api#ticker
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *coincheck) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            if IsTrue(!IsEqual(symbol, "BTC/JPY")) {
                panic(BadSymbol(Add(this.Id, " fetchTicker() supports BTC/JPY only")))
            }
        
            retRes324686 := (<-this.LoadMarkets())
            PanicOnError(retRes324686)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "pair": GetValue(market, "id"),
            }
        
            ticker:= (<-this.PublicGetTicker(this.Extend(request, params)))
            PanicOnError(ticker)
        
                //
            // {
            //     "last":4192632.0,
            //     "bid":4192496.0,
            //     "ask":4193749.0,
            //     "high":4332000.0,
            //     "low":4101047.0,
            //     "volume":2313.43191762,
            //     "timestamp":1643374115
            // }
            //
        ch <- this.ParseTicker(ticker, market)
            return nil
        
            }()
            return ch
        }
func  (this *coincheck) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTrades (public)
    //
    //      {
    //          "id": "206849494",
    //          "amount": "0.01",
    //          "rate": "5598346.0",
    //          "pair": "btc_jpy",
    //          "order_type": "sell",
    //          "created_at": "2021-12-08T14:10:33.000Z"
    //      }
    //
    // fetchMyTrades (private) - example from docs
    //
    //      {
    //          "id": 38,
    //          "order_id": 49,
    //          "created_at": "2015-11-18T07:02:21.000Z",
    //          "funds": {
    //              "btc": "0.1",
    //              "jpy": "-4096.135"
    //                  },
    //           "pair": "btc_jpy",
    //           "rate": "40900.0",
    //           "fee_currency": "JPY",
    //           "fee": "6.135",
    //           "liquidity": "T",
    //           "side": "buy"
    //      }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.Parse8601(this.SafeString(trade, "created_at"))
    var id interface{} = this.SafeString(trade, "id")
    var priceString interface{} = this.SafeString(trade, "rate")
    var marketId interface{} = this.SafeString(trade, "pair")
    market = this.SafeMarket(marketId, market, "_")
    var baseId interface{} = GetValue(market, "baseId")
    var quoteId interface{} = GetValue(market, "quoteId")
    var symbol interface{} = GetValue(market, "symbol")
    var takerOrMaker interface{} = nil
    var amountString interface{} = nil
    var costString interface{} = nil
    var side interface{} = nil
    var fee interface{} = nil
    var orderId interface{} = nil
    if IsTrue(InOp(trade, "liquidity")) {
        if IsTrue(IsEqual(this.SafeString(trade, "liquidity"), "T")) {
            takerOrMaker = "taker"
        } else if IsTrue(IsEqual(this.SafeString(trade, "liquidity"), "M")) {
            takerOrMaker = "maker"
        }
        var funds interface{} = this.SafeValue(trade, "funds", map[string]interface{} {})
        amountString = this.SafeString(funds, baseId)
        costString = this.SafeString(funds, quoteId)
        fee = map[string]interface{} {
            "currency": this.SafeString(trade, "fee_currency"),
            "cost": this.SafeString(trade, "fee"),
        }
        side = this.SafeString(trade, "side")
        orderId = this.SafeString(trade, "order_id")
    } else {
        amountString = this.SafeString(trade, "amount")
        side = this.SafeString(trade, "order_type")
    }
    return this.SafeTrade(map[string]interface{} {
        "id": id,
        "info": trade,
        "datetime": this.Iso8601(timestamp),
        "timestamp": timestamp,
        "symbol": symbol,
        "type": nil,
        "side": side,
        "order": orderId,
        "takerOrMaker": takerOrMaker,
        "price": priceString,
        "amount": amountString,
        "cost": costString,
        "fee": fee,
    }, market)
}
/**
 * @method
 * @name coincheck#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://coincheck.com/documents/exchange/api#order-transactions-pagination
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *coincheck) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes575168 := (<-this.LoadMarkets())
            PanicOnError(retRes575168)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.PrivateGetExchangeOrdersTransactionsPagination(this.Extend(request, params)))
            PanicOnError(response)
            //
            //      {
            //          "success": true,
            //          "data": [
            //                      {
            //                          "id": 38,
            //                          "order_id": 49,
            //                          "created_at": "2015-11-18T07:02:21.000Z",
            //                          "funds": {
            //                              "btc": "0.1",
            //                              "jpy": "-4096.135"
            //                                  },
            //                          "pair": "btc_jpy",
            //                          "rate": "40900.0",
            //                          "fee_currency": "JPY",
            //                          "fee": "6.135",
            //                          "liquidity": "T",
            //                          "side": "buy"
            //                       },
            //                  ]
            //      }
            //
            var transactions interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTrades(transactions, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coincheck#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://coincheck.com/documents/exchange/api#public-trades
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *coincheck) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes948912 := (<-this.LoadMarkets())
            PanicOnError(retRes948912)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "pair": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.PublicGetTrades(this.Extend(request, params)))
            PanicOnError(response)
            //
            //      {
            //          "id": "206849494",
            //          "amount": "0.01",
            //          "rate": "5598346.0",
            //          "pair": "btc_jpy",
            //          "order_type": "sell",
            //          "created_at": "2021-12-08T14:10:33.000Z"
            //      }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTrades(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coincheck#fetchTradingFees
 * @description fetch the trading fees for multiple markets
 * @see https://coincheck.com/documents/exchange/api#account-info
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
 */
func  (this *coincheck) FetchTradingFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes472786 := (<-this.LoadMarkets())
            PanicOnError(retRes472786)
        
            response:= (<-this.PrivateGetAccounts(params))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "id": "7487995",
            //         "email": "some@email.com",
            //         "identity_status": "identity_pending",
            //         "bitcoin_address": null,
            //         "lending_leverage": "4",
            //         "taker_fee": "0.0",
            //         "maker_fee": "0.0",
            //         "exchange_fees": {
            //           "btc_jpy": { taker_fee: '0.0', maker_fee: "0.0" },
            //           "etc_jpy": { taker_fee: '0.0', maker_fee: "0.0" },
            //           "fct_jpy": { taker_fee: '0.0', maker_fee: "0.0" },
            //           "mona_jpy": { taker_fee: '0.0', maker_fee: "0.0" },
            //           "plt_jpy": { taker_fee: '0.0', maker_fee: "0.0" }
            //         }
            //     }
            //
            var fees interface{} = this.SafeValue(response, "exchange_fees", map[string]interface{} {})
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(this.Symbols)); i++ {
                var symbol interface{} = GetValue(this.Symbols, i)
                var market interface{} = this.Market(symbol)
                var fee interface{} = this.SafeValue(fees, GetValue(market, "id"), map[string]interface{} {})
                AddElementToObject(result, symbol, map[string]interface{} {
            "info": fee,
            "symbol": symbol,
            "maker": this.SafeNumber(fee, "maker_fee"),
            "taker": this.SafeNumber(fee, "taker_fee"),
            "percentage": true,
            "tierBased": false,
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coincheck#createOrder
 * @description create a trade order
 * @see https://coincheck.com/documents/exchange/api#order-new
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coincheck) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes244823 := (<-this.LoadMarkets())
            PanicOnError(retRes244823)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "pair": GetValue(market, "id"),
            }
            if IsTrue(IsEqual(typeVar, "market")) {
                var order_type interface{} = Add(Add(typeVar, "_"), side)
                AddElementToObject(request, "order_type", order_type)
                var prefix interface{} = Ternary(IsTrue((IsEqual(side, "buy"))), (Add(order_type, "_")), "")
                AddElementToObject(request, Add(prefix, "amount"), amount)
            } else {
                AddElementToObject(request, "order_type", side)
                AddElementToObject(request, "rate", price)
                AddElementToObject(request, "amount", amount)
            }
        
            response:= (<-this.PrivatePostExchangeOrders(this.Extend(request, params)))
            PanicOnError(response)
            var id interface{} = this.SafeString(response, "id")
        
            ch <- this.SafeOrder(map[string]interface{} {
                "id": id,
                "info": response,
            }, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coincheck#cancelOrder
 * @description cancels an open order
 * @see https://coincheck.com/documents/exchange/api#order-cancel
 * @param {string} id order id
 * @param {string} symbol not used by coincheck cancelOrder ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coincheck) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "id": id,
            }
        
            response:= (<-this.PrivateDeleteExchangeOrdersId(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //    {
            //        "success": true,
            //        "id": 12345
            //    }
            //
        ch <- this.ParseOrder(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coincheck#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://coincheck.com/documents/exchange/api#account-deposits
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *coincheck) FetchDeposits(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes484827 := (<-this.LoadMarkets())
            PanicOnError(retRes484827)
            var currency interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "currency", GetValue(currency, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.PrivateGetDepositMoney(this.Extend(request, params)))
            PanicOnError(response)
            // {
            //   "success": true,
            //   "deposits": [
            //     {
            //       "id": 2,
            //       "amount": "0.05",
            //       "currency": "BTC",
            //       "address": "13PhzoK8me3u5nHzzFD85qT9RqEWR9M4Ty",
            //       "status": "confirmed",
            //       "confirmed_at": "2015-06-13T08:29:18.000Z",
            //       "created_at": "2015-06-13T08:22:18.000Z"
            //     },
            //     {
            //       "id": 1,
            //       "amount": "0.01",
            //       "currency": "BTC",
            //       "address": "13PhzoK8me3u5nHzzFD85qT9RqEWR9M4Ty",
            //       "status": "received",
            //       "confirmed_at": "2015-06-13T08:21:18.000Z",
            //       "created_at": "2015-06-13T08:21:18.000Z"
            //     }
            //   ]
            // }
            var data interface{} = this.SafeList(response, "deposits", []interface{}{})
        
            ch <- this.ParseTransactions(data, currency, since, limit, map[string]interface{} {
                "type": "deposit",
            })
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coincheck#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @see https://coincheck.com/documents/exchange/api#withdraws
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawals structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *coincheck) FetchWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes589194 := (<-this.LoadMarkets())
            PanicOnError(retRes589194)
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
            }
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.PrivateGetWithdraws(this.Extend(request, params)))
            PanicOnError(response)
            //  {
            //   "success": true,
            //   "pagination": {
            //     "limit": 25,
            //     "order": "desc",
            //     "starting_after": null,
            //     "ending_before": null
            //   },
            //   "data": [
            //     {
            //       "id": 398,
            //       "status": "finished",
            //       "amount": "242742.0",
            //       "currency": "JPY",
            //       "created_at": "2014-12-04T15:00:00.000Z",
            //       "bank_account_id": 243,
            //       "fee": "400.0",
            //       "is_fast": true
            //     }
            //   ]
            // }
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTransactions(data, currency, since, limit, map[string]interface{} {
                "type": "withdrawal",
            })
            return nil
        
            }()
            return ch
        }
func  (this *coincheck) ParseTransactionStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "pending": "pending",
        "processing": "pending",
        "finished": "ok",
        "canceled": "canceled",
        "confirmed": "pending",
        "received": "ok",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *coincheck) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchDeposits
    //
    // {
    //       "id": 2,
    //       "amount": "0.05",
    //       "currency": "BTC",
    //       "address": "13PhzoK8me3u5nHzzFD85qT9RqEWR9M4Ty",
    //       "status": "confirmed",
    //       "confirmed_at": "2015-06-13T08:29:18.000Z",
    //       "created_at": "2015-06-13T08:22:18.000Z"
    //  }
    //
    // fetchWithdrawals
    //
    //  {
    //       "id": 398,
    //       "status": "finished",
    //       "amount": "242742.0",
    //       "currency": "JPY",
    //       "created_at": "2014-12-04T15:00:00.000Z",
    //       "bank_account_id": 243,
    //       "fee": "400.0",
    //       "is_fast": true
    //  }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var id interface{} = this.SafeString(transaction, "id")
    var timestamp interface{} = this.Parse8601(this.SafeString(transaction, "created_at"))
    var address interface{} = this.SafeString(transaction, "address")
    var amount interface{} = this.SafeNumber(transaction, "amount")
    var currencyId interface{} = this.SafeString(transaction, "currency")
    var code interface{} = this.SafeCurrencyCode(currencyId, currency)
    var status interface{} = this.ParseTransactionStatus(this.SafeString(transaction, "status"))
    var updated interface{} = this.Parse8601(this.SafeString(transaction, "confirmed_at"))
    var fee interface{} = nil
    var feeCost interface{} = this.SafeNumber(transaction, "fee")
    if IsTrue(!IsEqual(feeCost, nil)) {
        fee = map[string]interface{} {
            "cost": feeCost,
            "currency": code,
        }
    }
    return map[string]interface{} {
        "info": transaction,
        "id": id,
        "txid": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "network": nil,
        "address": address,
        "addressTo": address,
        "addressFrom": nil,
        "tag": nil,
        "tagTo": nil,
        "tagFrom": nil,
        "type": nil,
        "amount": amount,
        "currency": code,
        "status": status,
        "updated": updated,
        "comment": nil,
        "internal": nil,
        "fee": fee,
    }
}
func  (this *coincheck) Nonce() interface{}  {
    return this.Milliseconds()
}
func  (this *coincheck) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var url interface{} = Add(Add(GetValue(GetValue(this.Urls, "api"), "rest"), "/"), this.ImplodeParams(path, params))
    var query interface{} = this.Omit(params, this.ExtractParams(path))
    if IsTrue(IsEqual(api, "public")) {
        if IsTrue(GetArrayLength(ObjectKeys(query))) {
            url = Add(url, Add("?", this.Urlencode(query)))
        }
    } else {
        this.CheckRequiredCredentials()
        var nonce interface{} = ToString(this.Nonce())
        var queryString interface{} = ""
        if IsTrue(IsEqual(method, "GET")) {
            if IsTrue(GetArrayLength(ObjectKeys(query))) {
                url = Add(url, Add("?", this.Urlencode(this.Keysort(query))))
            }
        } else {
            if IsTrue(GetArrayLength(ObjectKeys(query))) {
                body = this.Urlencode(this.Keysort(query))
                queryString = body
            }
        }
        var auth interface{} = Add(Add(nonce, url), queryString)
        headers = map[string]interface{} {
            "Content-Type": "application/x-www-form-urlencoded",
            "ACCESS-KEY": this.ApiKey,
            "ACCESS-NONCE": nonce,
            "ACCESS-SIGNATURE": this.Hmac(this.Encode(auth), this.Encode(this.Secret), sha256),
        }
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *coincheck) HandleErrors(httpCode interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsEqual(response, nil)) {
        return nil
    }
    //
    //     {"success":false,"error":"disabled API Key"}'
    //     {"success":false,"error":"invalid authentication"}
    //
    var success interface{} = this.SafeBool(response, "success", true)
    if !IsTrue(success) {
        var error interface{} = this.SafeString(response, "error")
        var feedback interface{} = Add(Add(this.Id, " "), this.Json(response))
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), error, feedback)
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), body, feedback)
        panic(ExchangeError(Add(Add(this.Id, " "), this.Json(response))))
    }
    return nil
}


func (this *coincheck) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
