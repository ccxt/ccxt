package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type bitmart struct {
    Exchange

}

func NewBitmartCore() bitmart {
   p := bitmart{}
   setDefaults(&p)
   return p
}

func  (this *bitmart) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "bitmart",
        "name": "BitMart",
        "countries": []interface{}{"US", "CN", "HK", "KR"},
        "rateLimit": 33.34,
        "version": "v2",
        "certified": true,
        "pro": true,
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": true,
            "swap": true,
            "future": false,
            "option": false,
            "borrowCrossMargin": false,
            "borrowIsolatedMargin": true,
            "cancelAllOrders": true,
            "cancelOrder": true,
            "cancelOrders": true,
            "createMarketBuyOrderWithCost": true,
            "createMarketOrderWithCost": false,
            "createMarketSellOrderWithCost": false,
            "createOrder": true,
            "createOrders": true,
            "createPostOnlyOrder": true,
            "createStopLimitOrder": false,
            "createStopMarketOrder": false,
            "createStopOrder": false,
            "createTrailingPercentOrder": true,
            "fetchBalance": true,
            "fetchBorrowInterest": true,
            "fetchBorrowRateHistories": false,
            "fetchBorrowRateHistory": false,
            "fetchCanceledOrders": true,
            "fetchClosedOrders": true,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchCurrencies": true,
            "fetchDeposit": true,
            "fetchDepositAddress": true,
            "fetchDepositAddresses": false,
            "fetchDepositAddressesByNetwork": false,
            "fetchDeposits": true,
            "fetchDepositWithdrawFee": true,
            "fetchDepositWithdrawFees": false,
            "fetchFundingHistory": true,
            "fetchFundingRate": true,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchIsolatedBorrowRate": true,
            "fetchIsolatedBorrowRates": true,
            "fetchLedger": true,
            "fetchLiquidations": false,
            "fetchMarginMode": false,
            "fetchMarkets": true,
            "fetchMyLiquidations": true,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenInterest": true,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrders": false,
            "fetchOrderTrades": true,
            "fetchPosition": true,
            "fetchPositionMode": false,
            "fetchPositions": true,
            "fetchStatus": true,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTime": true,
            "fetchTrades": true,
            "fetchTradingFee": true,
            "fetchTradingFees": false,
            "fetchTransactionFee": true,
            "fetchTransactionFees": false,
            "fetchTransfer": false,
            "fetchTransfers": true,
            "fetchWithdrawAddressesByNetwork": false,
            "fetchWithdrawal": true,
            "fetchWithdrawals": true,
            "reduceMargin": false,
            "repayCrossMargin": false,
            "repayIsolatedMargin": true,
            "setLeverage": true,
            "setMarginMode": false,
            "transfer": true,
            "withdraw": true,
        },
        "hostname": "bitmart.com",
        "urls": map[string]interface{} {
            "logo": "https://github.com/user-attachments/assets/0623e9c4-f50e-48c9-82bd-65c3908c3a14",
            "api": map[string]interface{} {
                "spot": "https://api-cloud.{hostname}",
                "swap": "https://api-cloud-v2.{hostname}",
            },
            "www": "https://www.bitmart.com/",
            "doc": "https://developer-pro.bitmart.com/",
            "referral": map[string]interface{} {
                "url": "http://www.bitmart.com/?r=rQCFLh",
                "discount": 0.3,
            },
            "fees": "https://www.bitmart.com/fee/en",
        },
        "requiredCredentials": map[string]interface{} {
            "apiKey": true,
            "secret": true,
            "uid": true,
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": map[string]interface{} {
                    "system/time": 3,
                    "system/service": 3,
                    "spot/v1/currencies": 7.5,
                    "spot/v1/symbols": 7.5,
                    "spot/v1/symbols/details": 5,
                    "spot/quotation/v3/tickers": 6,
                    "spot/quotation/v3/ticker": 4,
                    "spot/quotation/v3/lite-klines": 5,
                    "spot/quotation/v3/klines": 7,
                    "spot/quotation/v3/books": 4,
                    "spot/quotation/v3/trades": 4,
                    "spot/v1/ticker": 5,
                    "spot/v2/ticker": 30,
                    "spot/v1/ticker_detail": 5,
                    "spot/v1/steps": 30,
                    "spot/v1/symbols/kline": 6,
                    "spot/v1/symbols/book": 5,
                    "spot/v1/symbols/trades": 5,
                    "contract/v1/tickers": 15,
                    "contract/public/details": 5,
                    "contract/public/depth": 5,
                    "contract/public/open-interest": 30,
                    "contract/public/funding-rate": 30,
                    "contract/public/funding-rate-history": 30,
                    "contract/public/kline": 6,
                    "account/v1/currencies": 30,
                },
            },
            "private": map[string]interface{} {
                "get": map[string]interface{} {
                    "account/sub-account/v1/transfer-list": 7.5,
                    "account/sub-account/v1/transfer-history": 7.5,
                    "account/sub-account/main/v1/wallet": 5,
                    "account/sub-account/main/v1/subaccount-list": 7.5,
                    "account/contract/sub-account/main/v1/wallet": 5,
                    "account/contract/sub-account/main/v1/transfer-list": 7.5,
                    "account/contract/sub-account/v1/transfer-history": 7.5,
                    "account/v1/wallet": 5,
                    "account/v1/currencies": 30,
                    "spot/v1/wallet": 5,
                    "account/v1/deposit/address": 30,
                    "account/v1/withdraw/charge": 32,
                    "account/v2/deposit-withdraw/history": 7.5,
                    "account/v1/deposit-withdraw/detail": 7.5,
                    "spot/v1/order_detail": 1,
                    "spot/v2/orders": 5,
                    "spot/v1/trades": 5,
                    "spot/v2/trades": 4,
                    "spot/v3/orders": 5,
                    "spot/v2/order_detail": 1,
                    "spot/v1/margin/isolated/borrow_record": 1,
                    "spot/v1/margin/isolated/repay_record": 1,
                    "spot/v1/margin/isolated/pairs": 30,
                    "spot/v1/margin/isolated/account": 5,
                    "spot/v1/trade_fee": 30,
                    "spot/v1/user_fee": 30,
                    "spot/v1/broker/rebate": 1,
                    "contract/private/assets-detail": 5,
                    "contract/private/order": 1.2,
                    "contract/private/order-history": 10,
                    "contract/private/position": 10,
                    "contract/private/get-open-orders": 1.2,
                    "contract/private/current-plan-order": 1.2,
                    "contract/private/trades": 10,
                    "contract/private/position-risk": 10,
                    "contract/private/affilate/rebate-list": 10,
                    "contract/private/affilate/trade-list": 10,
                    "contract/private/transaction-history": 10,
                },
                "post": map[string]interface{} {
                    "account/sub-account/main/v1/sub-to-main": 30,
                    "account/sub-account/sub/v1/sub-to-main": 30,
                    "account/sub-account/main/v1/main-to-sub": 30,
                    "account/sub-account/sub/v1/sub-to-sub": 30,
                    "account/sub-account/main/v1/sub-to-sub": 30,
                    "account/contract/sub-account/main/v1/sub-to-main": 7.5,
                    "account/contract/sub-account/main/v1/main-to-sub": 7.5,
                    "account/contract/sub-account/sub/v1/sub-to-main": 7.5,
                    "account/v1/withdraw/apply": 7.5,
                    "spot/v1/submit_order": 1,
                    "spot/v1/batch_orders": 1,
                    "spot/v2/cancel_order": 1,
                    "spot/v1/cancel_orders": 15,
                    "spot/v4/query/order": 1,
                    "spot/v4/query/client-order": 1,
                    "spot/v4/query/open-orders": 5,
                    "spot/v4/query/history-orders": 5,
                    "spot/v4/query/trades": 5,
                    "spot/v4/query/order-trades": 5,
                    "spot/v4/cancel_orders": 3,
                    "spot/v4/cancel_all": 90,
                    "spot/v4/batch_orders": 3,
                    "spot/v3/cancel_order": 1,
                    "spot/v2/batch_orders": 1,
                    "spot/v2/submit_order": 1,
                    "spot/v1/margin/submit_order": 1,
                    "spot/v1/margin/isolated/borrow": 30,
                    "spot/v1/margin/isolated/repay": 30,
                    "spot/v1/margin/isolated/transfer": 30,
                    "account/v1/transfer-contract-list": 60,
                    "account/v1/transfer-contract": 60,
                    "contract/private/submit-order": 2.5,
                    "contract/private/cancel-order": 1.5,
                    "contract/private/cancel-orders": 30,
                    "contract/private/submit-plan-order": 2.5,
                    "contract/private/cancel-plan-order": 1.5,
                    "contract/private/submit-leverage": 2.5,
                    "contract/private/submit-tp-sl-order": 2.5,
                    "contract/private/modify-plan-order": 2.5,
                    "contract/private/modify-preset-plan-order": 2.5,
                    "contract/private/modify-tp-sl-order": 2.5,
                },
            },
        },
        "timeframes": map[string]interface{} {
            "1m": 1,
            "3m": 3,
            "5m": 5,
            "15m": 15,
            "30m": 30,
            "45m": 45,
            "1h": 60,
            "2h": 120,
            "3h": 180,
            "4h": 240,
            "1d": 1440,
            "1w": 10080,
            "1M": 43200,
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "tierBased": true,
                "percentage": true,
                "taker": this.ParseNumber("0.0040"),
                "maker": this.ParseNumber("0.0035"),
                "tiers": map[string]interface{} {
                    "taker": []interface{}{[]interface{}{this.ParseNumber("0"), this.ParseNumber("0.0020")}, []interface{}{this.ParseNumber("10"), this.ParseNumber("0.18")}, []interface{}{this.ParseNumber("50"), this.ParseNumber("0.0016")}, []interface{}{this.ParseNumber("250"), this.ParseNumber("0.0014")}, []interface{}{this.ParseNumber("1000"), this.ParseNumber("0.0012")}, []interface{}{this.ParseNumber("5000"), this.ParseNumber("0.0010")}, []interface{}{this.ParseNumber("25000"), this.ParseNumber("0.0008")}, []interface{}{this.ParseNumber("50000"), this.ParseNumber("0.0006")}},
                    "maker": []interface{}{[]interface{}{this.ParseNumber("0"), this.ParseNumber("0.001")}, []interface{}{this.ParseNumber("10"), this.ParseNumber("0.0009")}, []interface{}{this.ParseNumber("50"), this.ParseNumber("0.0008")}, []interface{}{this.ParseNumber("250"), this.ParseNumber("0.0007")}, []interface{}{this.ParseNumber("1000"), this.ParseNumber("0.0006")}, []interface{}{this.ParseNumber("5000"), this.ParseNumber("0.0005")}, []interface{}{this.ParseNumber("25000"), this.ParseNumber("0.0004")}, []interface{}{this.ParseNumber("50000"), this.ParseNumber("0.0003")}},
                },
            },
        },
        "precisionMode": TICK_SIZE,
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "30000": ExchangeError,
                "30001": AuthenticationError,
                "30002": AuthenticationError,
                "30003": AccountSuspended,
                "30004": AuthenticationError,
                "30005": AuthenticationError,
                "30006": AuthenticationError,
                "30007": AuthenticationError,
                "30008": AuthenticationError,
                "30010": PermissionDenied,
                "30011": AuthenticationError,
                "30012": AuthenticationError,
                "30013": RateLimitExceeded,
                "30014": ExchangeNotAvailable,
                "30016": OnMaintenance,
                "30017": RateLimitExceeded,
                "30018": BadRequest,
                "30019": PermissionDenied,
                "60000": BadRequest,
                "60001": BadRequest,
                "60002": BadRequest,
                "60003": ExchangeError,
                "60004": ExchangeError,
                "60005": ExchangeError,
                "60006": ExchangeError,
                "60007": InvalidAddress,
                "60008": InsufficientFunds,
                "60009": ExchangeError,
                "60010": ExchangeError,
                "60011": InvalidAddress,
                "60012": ExchangeError,
                "60020": PermissionDenied,
                "60021": PermissionDenied,
                "60022": PermissionDenied,
                "60026": PermissionDenied,
                "60027": PermissionDenied,
                "60028": AccountSuspended,
                "60029": AccountSuspended,
                "60030": BadRequest,
                "60031": BadRequest,
                "60050": ExchangeError,
                "60051": ExchangeError,
                "61001": InsufficientFunds,
                "61003": BadRequest,
                "61004": BadRequest,
                "61005": BadRequest,
                "61006": NotSupported,
                "61007": ExchangeError,
                "61008": ExchangeError,
                "70000": ExchangeError,
                "70001": BadRequest,
                "70002": BadSymbol,
                "70003": NetworkError,
                "71001": BadRequest,
                "71002": BadRequest,
                "71003": BadRequest,
                "71004": BadRequest,
                "71005": BadRequest,
                "50000": BadRequest,
                "50001": BadSymbol,
                "50002": BadRequest,
                "50003": BadRequest,
                "50004": BadRequest,
                "50005": OrderNotFound,
                "50006": InvalidOrder,
                "50007": InvalidOrder,
                "50008": InvalidOrder,
                "50009": InvalidOrder,
                "50010": InvalidOrder,
                "50011": InvalidOrder,
                "50012": InvalidOrder,
                "50013": InvalidOrder,
                "50014": BadRequest,
                "50015": BadRequest,
                "50016": BadRequest,
                "50017": BadRequest,
                "50018": BadRequest,
                "50019": ExchangeError,
                "50020": InsufficientFunds,
                "50021": BadRequest,
                "50022": ExchangeNotAvailable,
                "50023": BadSymbol,
                "50024": BadRequest,
                "50025": BadRequest,
                "50026": BadRequest,
                "50027": BadRequest,
                "50028": BadRequest,
                "50029": InvalidOrder,
                "50030": OrderNotFound,
                "50031": OrderNotFound,
                "50032": OrderNotFound,
                "50033": InvalidOrder,
                "50034": InvalidOrder,
                "50035": InvalidOrder,
                "50036": ExchangeError,
                "50037": BadRequest,
                "50038": BadRequest,
                "50039": BadRequest,
                "50040": BadSymbol,
                "50041": ExchangeError,
                "50042": BadRequest,
                "51000": BadSymbol,
                "51001": ExchangeError,
                "51002": ExchangeError,
                "51003": ExchangeError,
                "51004": InsufficientFunds,
                "51005": InvalidOrder,
                "51006": InvalidOrder,
                "51007": BadRequest,
                "51008": ExchangeError,
                "51009": InvalidOrder,
                "51010": InvalidOrder,
                "51011": InvalidOrder,
                "51012": InvalidOrder,
                "51013": InvalidOrder,
                "51014": InvalidOrder,
                "51015": InvalidOrder,
                "52000": BadRequest,
                "52001": BadRequest,
                "52002": BadRequest,
                "52003": BadRequest,
                "52004": BadRequest,
                "53000": AccountSuspended,
                "53001": AccountSuspended,
                "53002": PermissionDenied,
                "53003": PermissionDenied,
                "53005": PermissionDenied,
                "53006": PermissionDenied,
                "53007": PermissionDenied,
                "53008": PermissionDenied,
                "53009": PermissionDenied,
                "53010": PermissionDenied,
                "57001": BadRequest,
                "58001": BadRequest,
                "59001": ExchangeError,
                "59002": ExchangeError,
                "59003": ExchangeError,
                "59004": ExchangeError,
                "59005": PermissionDenied,
                "59006": ExchangeError,
                "59007": ExchangeError,
                "59008": ExchangeError,
                "59009": ExchangeError,
                "59010": InsufficientFunds,
                "59011": ExchangeError,
                "40001": ExchangeError,
                "40002": ExchangeError,
                "40003": ExchangeError,
                "40004": ExchangeError,
                "40005": ExchangeError,
                "40006": PermissionDenied,
                "40007": BadRequest,
                "40008": InvalidNonce,
                "40009": BadRequest,
                "40010": BadRequest,
                "40011": BadRequest,
                "40012": ExchangeError,
                "40013": ExchangeError,
                "40014": BadSymbol,
                "40015": BadSymbol,
                "40016": InvalidOrder,
                "40017": InvalidOrder,
                "40018": InvalidOrder,
                "40019": ExchangeError,
                "40020": InvalidOrder,
                "40021": ExchangeError,
                "40022": ExchangeError,
                "40023": ExchangeError,
                "40024": ExchangeError,
                "40025": ExchangeError,
                "40026": ExchangeError,
                "40027": InsufficientFunds,
                "40028": PermissionDenied,
                "40029": InvalidOrder,
                "40030": InvalidOrder,
                "40031": InvalidOrder,
                "40032": InvalidOrder,
                "40033": InvalidOrder,
                "40034": BadSymbol,
                "40035": OrderNotFound,
                "40036": InvalidOrder,
                "40037": OrderNotFound,
                "40038": BadRequest,
                "40039": BadRequest,
                "40040": InvalidOrder,
                "40041": InvalidOrder,
                "40042": InvalidOrder,
                "40043": InvalidOrder,
                "40044": InvalidOrder,
                "40045": InvalidOrder,
                "40046": PermissionDenied,
                "40047": PermissionDenied,
                "40048": InvalidOrder,
                "40049": InvalidOrder,
                "40050": InvalidOrder,
            },
            "broad": map[string]interface{} {
                "You contract account available balance not enough": InsufficientFunds,
                "you contract account available balance not enough": InsufficientFunds,
            },
        },
        "commonCurrencies": map[string]interface{} {
            "$GM": "GOLDMINER",
            "$HERO": "Step Hero",
            "$PAC": "PAC",
            "BP": "BEYOND",
            "GDT": "Gorilla Diamond",
            "GLD": "Goldario",
            "MVP": "MVP Coin",
            "TRU": "Truebit",
        },
        "options": map[string]interface{} {
            "defaultNetworks": map[string]interface{} {
                "USDT": "TRC20",
                "BTC": "BTC",
                "ETH": "ERC20",
            },
            "timeDifference": 0,
            "adjustForTimeDifference": false,
            "networks": map[string]interface{} {
                "ERC20": "ERC20",
                "SOL": "SOL",
                "BTC": "BTC",
                "TRC20": "TRC20",
                "OMNI": "OMNI",
                "XLM": "XLM",
                "EOS": "EOS",
                "NEO": "NEO",
                "BTM": "BTM",
                "BCH": "BCH",
                "LTC": "LTC",
                "BSV": "BSV",
                "XRP": "XRP",
                "PLEX": "PLEX",
                "XCH": "XCH",
                "NEAR": "NEAR",
                "FIO": "FIO",
                "SCRT": "SCRT",
                "IOTX": "IOTX",
                "ALGO": "ALGO",
                "ATOM": "ATOM",
                "DOT": "DOT",
                "ADA": "ADA",
                "DOGE": "DOGE",
                "XYM": "XYM",
                "GLMR": "GLMR",
                "MOVR": "MOVR",
                "ZIL": "ZIL",
                "INJ": "INJ",
                "KSM": "KSM",
                "ZEC": "ZEC",
                "NAS": "NAS",
                "POLYGON": "MATIC",
                "HRC20": "HECO",
                "XDC": "XDC",
                "ONE": "ONE",
                "LAT": "LAT",
                "CSPR": "Casper",
                "ICP": "Computer",
                "XTZ": "XTZ",
                "MINA": "MINA",
                "BEP20": "BSC_BNB",
                "THETA": "THETA",
                "AKT": "AKT",
                "AR": "AR",
                "CELO": "CELO",
                "FIL": "FIL",
                "NULS": "NULS",
                "ETC": "ETC",
                "DASH": "DASH",
                "DGB": "DGB",
                "BEP2": "BEP2",
                "GRIN": "GRIN",
                "WAVES": "WAVES",
                "ABBC": "ABBC",
                "ACA": "ACA",
                "QTUM": "QTUM",
                "PAC": "PAC",
                "TLOS": "TLOS",
                "KARDIA": "KardiaChain",
                "FUSE": "FUSE",
                "TRC10": "TRC10",
                "FIRO": "FIRO",
                "FTM": "Fantom",
                "EVER": "EVER",
                "KAVA": "KAVA",
                "HYDRA": "HYDRA",
                "PLCU": "PLCU",
                "BRISE": "BRISE",
                "OPTIMISM": "OPTIMISM",
                "REEF": "REEF",
                "SYS": "SYS",
                "VITE": "VITE",
                "STX": "STX",
                "SXP": "SXP",
                "BITCI": "BITCI",
                "XRD": "XRD",
                "ASTR": "ASTAR",
                "ZEN": "HORIZEN",
                "LTO": "LTO",
                "ETHW": "ETHW",
                "ETHF": "ETHF",
                "IOST": "IOST",
                "APT": "APT",
                "ONT": "ONT",
                "EVMOS": "EVMOS",
                "XMR": "XMR",
                "OASYS": "OAS",
                "OSMO": "OSMO",
                "OMAX": "OMAX Chain",
                "DESO": "DESO",
                "BFIC": "BFIC",
                "OHO": "OHO",
                "CS": "CS",
                "CHEQ": "CHEQ",
                "NODL": "NODL",
                "NEM": "XEM",
                "FRA": "FRA",
                "ERGO": "ERG",
            },
            "networksById": map[string]interface{} {
                "ETH": "ERC20",
                "Ethereum": "ERC20",
                "USDT": "OMNI",
                "Bitcoin": "BTC",
            },
            "defaultType": "spot",
            "fetchBalance": map[string]interface{} {
                "type": "spot",
            },
            "accountsByType": map[string]interface{} {
                "spot": "spot",
                "swap": "swap",
            },
            "createMarketBuyOrderRequiresPrice": true,
            "brokerId": "CCXTxBitmart000",
        },
        "features": map[string]interface{} {
            "default": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": true,
                    "triggerPrice": false,
                    "triggerPriceType": nil,
                    "triggerDirection": false,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": true,
                        "FOK": false,
                        "PO": true,
                        "GTD": false,
                    },
                    "hedged": false,
                    "trailing": false,
                    "marketBuyRequiresPrice": false,
                    "marketBuyByCost": true,
                    "leverage": true,
                    "selfTradePrevention": false,
                    "iceberg": false,
                },
                "createOrders": map[string]interface{} {
                    "max": 10,
                },
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": true,
                    "limit": 200,
                    "daysBack": nil,
                    "untilDays": 99999,
                    "symbolRequired": false,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": true,
                    "limit": 200,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOrders": nil,
                "fetchClosedOrders": map[string]interface{} {
                    "marginMode": true,
                    "limit": 200,
                    "daysBack": nil,
                    "daysBackCanceled": nil,
                    "untilDays": nil,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOHLCV": map[string]interface{} {
                    "limit": 1000,
                },
            },
            "forDerivatives": map[string]interface{} {
                "extends": "default",
                "createOrder": map[string]interface{} {
                    "marginMode": true,
                    "triggerPrice": true,
                    "triggerPriceType": map[string]interface{} {
                        "last": true,
                        "mark": true,
                        "index": false,
                    },
                    "triggerDirection": true,
                    "stopLossPrice": true,
                    "takeProfitPrice": true,
                    "attachedStopLossTakeProfit": map[string]interface{} {
                        "triggerPriceType": map[string]interface{} {
                            "last": true,
                            "mark": true,
                            "index": false,
                        },
                        "price": false,
                    },
                    "timeInForce": map[string]interface{} {
                        "IOC": true,
                        "FOK": true,
                        "PO": true,
                        "GTD": false,
                    },
                    "hedged": false,
                    "trailing": true,
                    "marketBuyRequiresPrice": true,
                    "marketBuyByCost": true,
                },
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": true,
                    "limit": nil,
                    "daysBack": nil,
                    "untilDays": 99999,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": true,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "trigger": true,
                    "trailing": false,
                },
                "fetchClosedOrders": map[string]interface{} {
                    "marginMode": true,
                    "limit": 200,
                    "daysBack": nil,
                    "daysBackCanceled": nil,
                    "untilDays": nil,
                    "trigger": false,
                    "trailing": false,
                },
                "fetchOHLCV": map[string]interface{} {
                    "limit": 500,
                },
            },
            "spot": map[string]interface{} {
                "extends": "default",
            },
            "swap": map[string]interface{} {
                "linear": map[string]interface{} {
                    "extends": "forDerivatives",
                },
                "inverse": map[string]interface{} {
                    "extends": "forDerivatives",
                },
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
    })
}
/**
 * @method
 * @name bitmart#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func  (this *bitmart) FetchTime(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetSystemTime(params))
            PanicOnError(response)
            //
            //     {
            //         "message":"OK",
            //         "code":1000,
            //         "trace":"c4e5e5b7-fe9f-4191-89f7-53f6c5bf9030",
            //         "data":{
            //             "server_time":1599843709578
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.SafeInteger(data, "server_time")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitmart#fetchStatus
 * @description the latest known information on the availability of the exchange API
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [status structure]{@link https://docs.ccxt.com/#/?id=exchange-status-structure}
 */
func  (this *bitmart) FetchStatus(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var options interface{} = this.SafeDict(this.Options, "fetchStatus", map[string]interface{} {})
            var defaultType interface{} = this.SafeString(this.Options, "defaultType")
            var typeVar interface{} = this.SafeString(options, "type", defaultType)
            typeVar = this.SafeString(params, "type", typeVar)
            params = this.Omit(params, "type")
        
            response:= (<-this.PublicGetSystemService(params))
            PanicOnError(response)
            //
            //     {
            //         "message": "OK",
            //         "code": 1000,
            //         "trace": "1d3f28b0-763e-4f78-90c4-5e3ad19dc595",
            //         "data": {
            //           "service": [
            //             {
            //               "title": "Spot API Stop",
            //               "service_type": "spot",
            //               "status": 2,
            //               "start_time": 1648639069125,
            //               "end_time": 1648639069125
            //             },
            //             {
            //               "title": "Contract API Stop",
            //               "service_type": "contract",
            //               "status": 2,
            //               "start_time": 1648639069125,
            //               "end_time": 1648639069125
            //             }
            //           ]
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var services interface{} = this.SafeList(data, "service", []interface{}{})
            var servicesByType interface{} = this.IndexBy(services, "service_type")
            if IsTrue(IsEqual(typeVar, "swap")) {
                typeVar = "contract"
            }
            var service interface{} = this.SafeString(servicesByType, typeVar)
            var status interface{} = nil
            var eta interface{} = nil
            if IsTrue(!IsEqual(service, nil)) {
                var statusCode interface{} = this.SafeInteger(service, "status")
                if IsTrue(IsEqual(statusCode, 2)) {
                    status = "ok"
                } else {
                    status = "maintenance"
                    eta = this.SafeInteger(service, "end_time")
                }
            }
        
            ch <- map[string]interface{} {
                "status": status,
                "updated": nil,
                "eta": eta,
                "url": nil,
                "info": response,
            }
            return nil
        
            }()
            return ch
        }
func  (this *bitmart) FetchSpotMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetSpotV1SymbolsDetails(params))
            PanicOnError(response)
            //
            //     {
            //         "message":"OK",
            //         "code":1000,
            //         "trace":"a67c9146-086d-4d3f-9897-5636a9bb26e1",
            //         "data":{
            //             "symbols":[
            //               {
            //                  "symbol": "BTC_USDT",
            //                  "symbol_id": 53,
            //                  "base_currency": "BTC",
            //                  "quote_currency": "USDT",
            //                  "base_min_size": "0.000010000000000000000000000000",
            //                  "base_max_size": "100000000.000000000000000000000000000000",
            //                  "price_min_precision": -1,
            //                  "price_max_precision": 2,
            //                  "quote_increment": "0.00001", // Api docs says "The minimum order quantity is also the minimum order quantity increment", however I think they mistakenly use the term 'order quantity'
            //                  "expiration": "NA",
            //                  "min_buy_amount": "5.000000000000000000000000000000",
            //                  "min_sell_amount": "5.000000000000000000000000000000",
            //                  "trade_status": "trading"
            //               },
            //             ]
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var symbols interface{} = this.SafeList(data, "symbols", []interface{}{})
            var result interface{} = []interface{}{}
            var fees interface{} = GetValue(this.Fees, "trading")
            for i := 0; IsLessThan(i, GetArrayLength(symbols)); i++ {
                var market interface{} = GetValue(symbols, i)
                var id interface{} = this.SafeString(market, "symbol")
                var numericId interface{} = this.SafeInteger(market, "symbol_id")
                var baseId interface{} = this.SafeString(market, "base_currency")
                var quoteId interface{} = this.SafeString(market, "quote_currency")
                var base interface{} = this.SafeCurrencyCode(baseId)
                var quote interface{} = this.SafeCurrencyCode(quoteId)
                var symbol interface{} = Add(Add(base, "/"), quote)
                var minBuyCost interface{} = this.SafeString(market, "min_buy_amount")
                var minSellCost interface{} = this.SafeString(market, "min_sell_amount")
                var minCost interface{} = Precise.StringMax(minBuyCost, minSellCost)
                var baseMinSize interface{} = this.SafeNumber(market, "base_min_size")
                AppendToArray(&result,this.SafeMarketStructure(map[string]interface{} {
                    "id": id,
                    "numericId": numericId,
                    "symbol": symbol,
                    "base": base,
                    "quote": quote,
                    "settle": nil,
                    "baseId": baseId,
                    "quoteId": quoteId,
                    "settleId": nil,
                    "type": "spot",
                    "spot": true,
                    "margin": false,
                    "swap": false,
                    "future": false,
                    "option": false,
                    "active": true,
                    "contract": false,
                    "linear": nil,
                    "inverse": nil,
                    "contractSize": nil,
                    "expiry": nil,
                    "expiryDatetime": nil,
                    "strike": nil,
                    "optionType": nil,
                    "maker": GetValue(fees, "maker"),
                    "taker": GetValue(fees, "taker"),
                    "precision": map[string]interface{} {
                        "amount": baseMinSize,
                        "price": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "price_max_precision"))),
                    },
                    "limits": map[string]interface{} {
                        "leverage": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "amount": map[string]interface{} {
                            "min": baseMinSize,
                            "max": this.SafeNumber(market, "base_max_size"),
                        },
                        "price": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "cost": map[string]interface{} {
                            "min": this.ParseNumber(minCost),
                            "max": nil,
                        },
                    },
                    "created": nil,
                    "info": market,
                }))
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *bitmart) FetchContractMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetContractPublicDetails(params))
            PanicOnError(response)
            //
            //     {
            //         "code": 1000,
            //         "message": "Ok",
            //         "data": {
            //             "symbols": [
            //                 {
            //                     "symbol": "BTCUSDT",
            //                     "product_type": 1,
            //                     "open_timestamp": 1645977600000,
            //                     "expire_timestamp": 0,
            //                     "settle_timestamp": 0,
            //                     "base_currency": "BTC",
            //                     "quote_currency": "USDT",
            //                     "last_price": "63547.4",
            //                     "volume_24h": "110938430",
            //                     "turnover_24h": "7004836342.6944",
            //                     "index_price": "63587.85404255",
            //                     "index_name": "BTCUSDT",
            //                     "contract_size": "0.001",
            //                     "min_leverage": "1",
            //                     "max_leverage": "100",
            //                     "price_precision": "0.1",
            //                     "vol_precision": "1",
            //                     "max_volume": "1000000",
            //                     "min_volume": "1",
            //                     "funding_rate": "0.0000801",
            //                     "expected_funding_rate": "-0.0000035",
            //                     "open_interest": "278214",
            //                     "open_interest_value": "17555316.9355496",
            //                     "high_24h": "64109.4",
            //                     "low_24h": "61857.6",
            //                     "change_24h": "0.0239264900886327",
            //                     "funding_time": 1726819200000
            //                 },
            //             ]
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var symbols interface{} = this.SafeList(data, "symbols", []interface{}{})
            var result interface{} = []interface{}{}
            var fees interface{} = GetValue(this.Fees, "trading")
            for i := 0; IsLessThan(i, GetArrayLength(symbols)); i++ {
                var market interface{} = GetValue(symbols, i)
                var id interface{} = this.SafeString(market, "symbol")
                var baseId interface{} = this.SafeString(market, "base_currency")
                var quoteId interface{} = this.SafeString(market, "quote_currency")
                var base interface{} = this.SafeCurrencyCode(baseId)
                var quote interface{} = this.SafeCurrencyCode(quoteId)
                var settleId interface{} = "USDT" // this is bitmart's ID for usdt
                var settle interface{} = this.SafeCurrencyCode(settleId)
                var symbol interface{} = Add(Add(Add(Add(base, "/"), quote), ":"), settle)
                var productType interface{} = this.SafeInteger(market, "product_type")
                var isSwap interface{} =         (IsEqual(productType, 1))
                var isFutures interface{} =         (IsEqual(productType, 2))
                var expiry interface{} = this.SafeInteger(market, "expire_timestamp")
                if IsTrue(!IsTrue(isFutures) && IsTrue((IsEqual(expiry, 0)))) {
                    expiry = nil
                }
                AppendToArray(&result,this.SafeMarketStructure(map[string]interface{} {
                    "id": id,
                    "numericId": nil,
                    "symbol": symbol,
                    "base": base,
                    "quote": quote,
                    "settle": settle,
                    "baseId": baseId,
                    "quoteId": quoteId,
                    "settleId": settleId,
                    "type": Ternary(IsTrue(isSwap), "swap", "future"),
                    "spot": false,
                    "margin": false,
                    "swap": isSwap,
                    "future": isFutures,
                    "option": false,
                    "active": true,
                    "contract": true,
                    "linear": true,
                    "inverse": false,
                    "contractSize": this.SafeNumber(market, "contract_size"),
                    "expiry": expiry,
                    "expiryDatetime": this.Iso8601(expiry),
                    "strike": nil,
                    "optionType": nil,
                    "maker": GetValue(fees, "maker"),
                    "taker": GetValue(fees, "taker"),
                    "precision": map[string]interface{} {
                        "amount": this.SafeNumber(market, "vol_precision"),
                        "price": this.SafeNumber(market, "price_precision"),
                    },
                    "limits": map[string]interface{} {
                        "leverage": map[string]interface{} {
                            "min": this.SafeNumber(market, "min_leverage"),
                            "max": this.SafeNumber(market, "max_leverage"),
                        },
                        "amount": map[string]interface{} {
                            "min": this.SafeNumber(market, "min_volume"),
                            "max": this.SafeNumber(market, "max_volume"),
                        },
                        "price": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "cost": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                    },
                    "created": this.SafeInteger(market, "open_timestamp"),
                    "info": market,
                }))
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitmart#fetchMarkets
 * @see https://developer-pro.bitmart.com/en/futuresv2/#get-contract-details
 * @description retrieves data on all markets for bitmart
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *bitmart) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            if IsTrue(GetValue(this.Options, "adjustForTimeDifference")) {
        
                retRes117012 := (<-this.LoadTimeDifference())
                PanicOnError(retRes117012)
            }
        
            spot:= (<-this.FetchSpotMarkets(params))
            PanicOnError(spot)
        
            contract:= (<-this.FetchContractMarkets(params))
            PanicOnError(contract)
        
            ch <- this.ArrayConcat(spot, contract)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitmart#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func  (this *bitmart) FetchCurrencies(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetAccountV1Currencies(params))
            PanicOnError(response)
            //
            //     {
            //         "message": "OK",
            //         "code":1000,
            //         "trace": "9eaec51cd80d46d48a1c6b447206c4d6.71.17392193317851454",
            //         "data": {
            //             "currencies": [
            //                 {
            //                     "currency": "BTC",
            //                     "name": "Bitcoin",
            //                     "contract_address": null,
            //                     "network": "BTC",
            //                     "withdraw_enabled": true,
            //                     "deposit_enabled": true,
            //                     "withdraw_minsize": "0.0003",
            //                     "withdraw_minfee": "9.74"
            //                 }
            //             ]
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var currencies interface{} = this.SafeList(data, "currencies", []interface{}{})
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(currencies)); i++ {
                var currency interface{} = GetValue(currencies, i)
                var fullId interface{} = this.SafeString(currency, "currency")
                var currencyId interface{} = fullId
                var networkId interface{} = this.SafeString(currency, "network")
                if IsTrue(IsLessThan(GetIndexOf(fullId, "NFT"), 0)) {
                    var parts interface{} = Split(fullId, "-")
                    currencyId = this.SafeString(parts, 0)
                    var second interface{} = this.SafeString(parts, 1)
                    if IsTrue(!IsEqual(second, nil)) {
                        networkId = ToUpper(second)
                    }
                }
                var currencyCode interface{} = this.SafeCurrencyCode(currencyId)
                var entry interface{} = this.SafeDict(result, currencyCode)
                if IsTrue(IsEqual(entry, nil)) {
                    entry = map[string]interface{} {
                        "info": currency,
                        "id": currencyId,
                        "code": currencyCode,
                        "precision": nil,
                        "name": this.SafeString(currency, "name"),
                        "deposit": nil,
                        "withdraw": nil,
                        "active": nil,
                        "networks": map[string]interface{} {},
                    }
                }
                var networkCode interface{} = this.NetworkIdToCode(networkId)
                var withdraw interface{} = this.SafeBool(currency, "withdraw_enabled")
                var deposit interface{} = this.SafeBool(currency, "deposit_enabled")
                AddElementToObject(GetValue(entry, "networks"), networkCode, map[string]interface{} {
            "info": currency,
            "id": networkId,
            "code": networkCode,
            "withdraw": withdraw,
            "deposit": deposit,
            "active": IsTrue(withdraw) && IsTrue(deposit),
            "fee": this.SafeNumber(currency, "withdraw_minfee"),
            "limits": map[string]interface{} {
                "withdraw": map[string]interface{} {
                    "min": this.SafeNumber(currency, "withdraw_minsize"),
                    "max": nil,
                },
                "deposit": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
            },
        })
                AddElementToObject(result, currencyCode, entry)
            }
            var keys interface{} = ObjectKeys(result)
            for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
                var key interface{} = GetValue(keys, i)
                var currency interface{} = GetValue(result, key)
                AddElementToObject(result, key, this.SafeCurrencyStructure(currency))
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *bitmart) GetCurrencyIdFromCodeAndNetwork(currencyCode interface{}, networkCode interface{}) interface{}  {
    if IsTrue(IsEqual(networkCode, nil)) {
        networkCode = this.DefaultNetworkCode(currencyCode) // use default network code if not provided
    }
    var currency interface{} = this.Currency(currencyCode)
    var id interface{} = GetValue(currency, "id")
    var idFromNetwork interface{} = nil
    var networks interface{} = this.SafeDict(currency, "networks", map[string]interface{} {})
    var networkInfo interface{} = map[string]interface{} {}
    if IsTrue(IsEqual(networkCode, nil)) {
        // network code is not provided and there is no default network code
        var network interface{} = this.SafeDict(networks, currencyCode) // trying to find network that has the same code as currency
        if IsTrue(IsEqual(network, nil)) {
            // use the first network in the networks list if there is no network code with the same code as currency
            var keys interface{} = ObjectKeys(networks)
            var length interface{} =             GetArrayLength(keys)
            if IsTrue(IsGreaterThan(length, 0)) {
                network = this.SafeValue(networks, GetValue(keys, 0))
            }
        }
        networkInfo = this.SafeDict(network, "info", map[string]interface{} {})
        idFromNetwork = this.SafeString(networkInfo, "currency") // use currency name from network
    } else {
        var providedOrDefaultNetwork interface{} = this.SafeDict(networks, networkCode)
        if IsTrue(!IsEqual(providedOrDefaultNetwork, nil)) {
            networkInfo = this.SafeDict(providedOrDefaultNetwork, "info", map[string]interface{} {})
            idFromNetwork = this.SafeString(networkInfo, "currency") // use currency name from network
        } else {
            id = Add(id, Add("-", this.NetworkCodeToId(networkCode, currencyCode))) // use concatenated currency id and network code if network is not found
        }
    }
    return Ternary(IsTrue((!IsEqual(idFromNetwork, nil))), idFromNetwork, id)
}
/**
 * @method
 * @name bitmart#fetchTransactionFee
 * @deprecated
 * @description please use fetchDepositWithdrawFee instead
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.network] the network code of the currency
 * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func  (this *bitmart) FetchTransactionFee(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes13168 := (<-this.LoadMarkets())
            PanicOnError(retRes13168)
            var currency interface{} = this.Currency(code)
            var network interface{} = nil
            networkparamsVariable := this.HandleNetworkCodeAndParams(params);
            network = GetValue(networkparamsVariable,0);
            params = GetValue(networkparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "currency": this.GetCurrencyIdFromCodeAndNetwork(GetValue(currency, "code"), network),
            }
        
            response:= (<-this.PrivateGetAccountV1WithdrawCharge(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "message": "OK",
            //         "code": "1000",
            //         "trace": "3ecc0adf-91bd-4de7-aca1-886c1122f54f",
            //         "data": {
            //             "today_available_withdraw_BTC": "100.0000",
            //             "min_withdraw": "0.005",
            //             "withdraw_precision": "8",
            //             "withdraw_fee": "0.000500000000000000000000000000"
            //         }
            //     }
            //
            var data interface{} = GetValue(response, "data")
            var withdrawFees interface{} = map[string]interface{} {}
            AddElementToObject(withdrawFees, code, this.SafeNumber(data, "withdraw_fee"))
        
            ch <- map[string]interface{} {
                "info": response,
                "withdraw": withdrawFees,
                "deposit": map[string]interface{} {},
            }
            return nil
        
            }()
            return ch
        }
func  (this *bitmart) ParseDepositWithdrawFee(fee interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "today_available_withdraw_BTC": "100.0000",
    //        "min_withdraw": "0.005",
    //        "withdraw_precision": "8",
    //        "withdraw_fee": "0.000500000000000000000000000000"
    //    }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    return map[string]interface{} {
        "info": fee,
        "withdraw": map[string]interface{} {
            "fee": this.SafeNumber(fee, "withdraw_fee"),
            "percentage": nil,
        },
        "deposit": map[string]interface{} {
            "fee": nil,
            "percentage": nil,
        },
        "networks": map[string]interface{} {},
    }
}
/**
 * @method
 * @name bitmart#fetchDepositWithdrawFee
 * @description fetch the fee for deposits and withdrawals
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.network] the network code of the currency
 * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func  (this *bitmart) FetchDepositWithdrawFee(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes13808 := (<-this.LoadMarkets())
            PanicOnError(retRes13808)
            var network interface{} = nil
            networkparamsVariable := this.HandleNetworkCodeAndParams(params);
            network = GetValue(networkparamsVariable,0);
            params = GetValue(networkparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "currency": this.GetCurrencyIdFromCodeAndNetwork(code, network),
            }
        
            response:= (<-this.PrivateGetAccountV1WithdrawCharge(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "message": "OK",
            //         "code": "1000",
            //         "trace": "3ecc0adf-91bd-4de7-aca1-886c1122f54f",
            //         "data": {
            //             "today_available_withdraw_BTC": "100.0000",
            //             "min_withdraw": "0.005",
            //             "withdraw_precision": "8",
            //             "withdraw_fee": "0.000500000000000000000000000000"
            //         }
            //     }
            //
            var data interface{} = GetValue(response, "data")
        
            ch <- this.ParseDepositWithdrawFee(data)
            return nil
        
            }()
            return ch
        }
func  (this *bitmart) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // spot (REST) fetchTickers
    //
    //     {
    //         'result': [
    //             "AFIN_USDT",     // symbol
    //             "0.001047",      // last
    //             "11110",         // v_24h
    //             "11.632170",     // qv_24h
    //             "0.001048",      // open_24h
    //             "0.001048",      // high_24h
    //             "0.001047",      // low_24h
    //             "-0.00095",      // price_change_24h
    //             "0.001029",      // bid_px
    //             "5555",          // bid_sz
    //             "0.001041",      // ask_px
    //             "5297",          // ask_sz
    //             "1717122550482"  // timestamp
    //         ]
    //     }
    //
    // spot (REST) fetchTicker
    //
    //     {
    //         "symbol": "BTC_USDT",
    //         "last": "68500.00",
    //         "v_24h": "10491.65490",
    //         "qv_24h": "717178990.42",
    //         "open_24h": "68149.75",
    //         "high_24h": "69499.99",
    //         "low_24h": "67132.40",
    //         "fluctuation": "0.00514",
    //         "bid_px": "68500",
    //         "bid_sz": "0.00162",
    //         "ask_px": "68500.01",
    //         "ask_sz": "0.01722",
    //         "ts": "1717131391671"
    //     }
    //
    // spot (WS)
    //
    //      {
    //          "symbol":"BTC_USDT",
    //          "last_price":"146.24",
    //          "open_24h":"147.17",
    //          "high_24h":"147.48",
    //          "low_24h":"143.88",
    //          "base_volume_24h":"117387.58", // NOT base, but quote currency!!!
    //          "s_t": 1610936002
    //      }
    //
    // swap
    //
    //     {
    //         "symbol": "BTCUSDT",
    //         "product_type": 1,
    //         "open_timestamp": 1645977600000,
    //         "expire_timestamp": 0,
    //         "settle_timestamp": 0,
    //         "base_currency": "BTC",
    //         "quote_currency": "USDT",
    //         "last_price": "63547.4",
    //         "volume_24h": "110938430",
    //         "turnover_24h": "7004836342.6944",
    //         "index_price": "63587.85404255",
    //         "index_name": "BTCUSDT",
    //         "contract_size": "0.001",
    //         "min_leverage": "1",
    //         "max_leverage": "100",
    //         "price_precision": "0.1",
    //         "vol_precision": "1",
    //         "max_volume": "1000000",
    //         "min_volume": "1",
    //         "funding_rate": "0.0000801",
    //         "expected_funding_rate": "-0.0000035",
    //         "open_interest": "278214",
    //         "open_interest_value": "17555316.9355496",
    //         "high_24h": "64109.4",
    //         "low_24h": "61857.6",
    //         "change_24h": "0.0239264900886327",
    //         "funding_time": 1726819200000
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var result interface{} = this.SafeList(ticker, "result", []interface{}{})
    var average interface{} = this.SafeString2(ticker, "avg_price", "index_price")
    var marketId interface{} = this.SafeString2(ticker, "symbol", "contract_symbol")
    var timestamp interface{} = this.SafeInteger2(ticker, "timestamp", "ts")
    var last interface{} = this.SafeString2(ticker, "last_price", "last")
    var percentage interface{} = this.SafeString2(ticker, "price_change_percent_24h", "change_24h")
    var change interface{} = this.SafeString(ticker, "fluctuation")
    var high interface{} = this.SafeString2(ticker, "high_24h", "high_price")
    var low interface{} = this.SafeString2(ticker, "low_24h", "low_price")
    var bid interface{} = this.SafeString2(ticker, "best_bid", "bid_px")
    var bidVolume interface{} = this.SafeString2(ticker, "best_bid_size", "bid_sz")
    var ask interface{} = this.SafeString2(ticker, "best_ask", "ask_px")
    var askVolume interface{} = this.SafeString2(ticker, "best_ask_size", "ask_sz")
    var open interface{} = this.SafeString(ticker, "open_24h")
    var baseVolume interface{} = this.SafeStringN(ticker, []interface{}{"base_volume_24h", "v_24h", "volume_24h"})
    var quoteVolume interface{} = this.SafeStringLowerN(ticker, []interface{}{"quote_volume_24h", "qv_24h", "turnover_24h"})
    var listMarketId interface{} = this.SafeString(result, 0)
    if IsTrue(!IsEqual(listMarketId, nil)) {
        marketId = listMarketId
        timestamp = this.SafeInteger(result, 12)
        high = this.SafeString(result, 5)
        low = this.SafeString(result, 6)
        bid = this.SafeString(result, 8)
        bidVolume = this.SafeString(result, 9)
        ask = this.SafeString(result, 10)
        askVolume = this.SafeString(result, 11)
        open = this.SafeString(result, 4)
        last = this.SafeString(result, 1)
        change = this.SafeString(result, 7)
        baseVolume = this.SafeString(result, 2)
        quoteVolume = this.SafeStringLower(result, 3)
    }
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = GetValue(market, "symbol")
    if IsTrue(IsEqual(timestamp, nil)) {
        // ticker from WS has a different field (in seconds)
        timestamp = this.SafeIntegerProduct(ticker, "s_t", 1000)
    }
    if IsTrue(IsEqual(percentage, nil)) {
        percentage = Precise.StringMul(change, "100")
    }
    if IsTrue(IsEqual(quoteVolume, nil)) {
        if IsTrue(IsEqual(baseVolume, nil)) {
            // this is swap
            quoteVolume = this.SafeString(ticker, "volume_24h", quoteVolume)
        } else {
            // this is a ticker from websockets
            // contrary to name and documentation, base_volume_24h is actually the quote volume
            quoteVolume = baseVolume
            baseVolume = nil
        }
    }
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": high,
        "low": low,
        "bid": bid,
        "bidVolume": bidVolume,
        "ask": ask,
        "askVolume": askVolume,
        "vwap": nil,
        "open": open,
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": nil,
        "percentage": percentage,
        "average": average,
        "baseVolume": baseVolume,
        "quoteVolume": quoteVolume,
        "indexPrice": this.SafeString(ticker, "index_price"),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name bitmart#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://developer-pro.bitmart.com/en/spot/#get-ticker-of-a-trading-pair-v3
 * @see https://developer-pro.bitmart.com/en/futuresv2/#get-contract-details
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *bitmart) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes15768 := (<-this.LoadMarkets())
            PanicOnError(retRes15768)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {}
            var response interface{} = nil
            if IsTrue(GetValue(market, "swap")) {
                AddElementToObject(request, "symbol", GetValue(market, "id"))
                
        response = (<-this.PublicGetContractPublicDetails(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(GetValue(market, "spot")) {
                AddElementToObject(request, "symbol", GetValue(market, "id"))
                
        response = (<-this.PublicGetSpotQuotationV3Ticker(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                panic(NotSupported(Add(Add(Add(this.Id, " fetchTicker() does not support "), GetValue(market, "type")), " markets, only spot and swap markets are accepted")))
            }
            // fails in naming for contract tickers 'contract_symbol'
            var tickers interface{} = []interface{}{}
            var ticker interface{} = map[string]interface{} {}
            if IsTrue(GetValue(market, "spot")) {
                ticker = this.SafeDict(response, "data", map[string]interface{} {})
            } else {
                var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
                tickers = this.SafeList(data, "symbols", []interface{}{})
                ticker = this.SafeDict(tickers, 0, map[string]interface{} {})
            }
        
            ch <- this.ParseTicker(ticker, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitmart#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://developer-pro.bitmart.com/en/spot/#get-ticker-of-all-pairs-v3
 * @see https://developer-pro.bitmart.com/en/futuresv2/#get-contract-details
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *bitmart) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes16748 := (<-this.LoadMarkets())
            PanicOnError(retRes16748)
            symbols = this.MarketSymbols(symbols)
            var typeVar interface{} = nil
            var market interface{} = nil
            if IsTrue(!IsEqual(symbols, nil)) {
                var symbol interface{} = this.SafeString(symbols, 0)
                market = this.Market(symbol)
            }
            typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchTickers", market, params);
            typeVar = GetValue(typeVarparamsVariable,0);
            params = GetValue(typeVarparamsVariable,1)
            var response interface{} = nil
            if IsTrue(IsEqual(typeVar, "spot")) {
                
        response = (<-this.PublicGetSpotQuotationV3Tickers(params))
                PanicOnError(response)
            } else if IsTrue(IsEqual(typeVar, "swap")) {
                
        response = (<-this.PublicGetContractPublicDetails(params))
                PanicOnError(response)
            } else {
                panic(NotSupported(Add(Add(Add(this.Id, " fetchTickers() does not support "), typeVar), " markets, only spot and swap markets are accepted")))
            }
            var tickers interface{} = []interface{}{}
            if IsTrue(IsEqual(typeVar, "spot")) {
                tickers = this.SafeList(response, "data", []interface{}{})
            } else {
                var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
                tickers = this.SafeList(data, "symbols", []interface{}{})
            }
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(tickers)); i++ {
                var ticker interface{} = map[string]interface{} {}
                if IsTrue(IsEqual(typeVar, "spot")) {
                    ticker = this.ParseTicker(map[string]interface{} {
                        "result": GetValue(tickers, i),
                    })
                } else {
                    ticker = this.ParseTicker(GetValue(tickers, i))
                }
                var symbol interface{} = GetValue(ticker, "symbol")
                AddElementToObject(result, symbol, ticker)
            }
        
            ch <- this.FilterByArrayTickers(result, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitmart#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://developer-pro.bitmart.com/en/spot/#get-depth-v3
 * @see https://developer-pro.bitmart.com/en/futures/#get-market-depth
 * @see https://developer-pro.bitmart.com/en/futuresv2/#get-market-depth
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *bitmart) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes17888 := (<-this.LoadMarkets())
            PanicOnError(retRes17888)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var response interface{} = nil
            if IsTrue(GetValue(market, "spot")) {
                if IsTrue(!IsEqual(limit, nil)) {
                    AddElementToObject(request, "limit", limit) // default 35, max 50
                }
                
        response = (<-this.PublicGetSpotQuotationV3Books(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(GetValue(market, "swap")) {
                
        response = (<-this.PublicGetContractPublicDepth(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                panic(NotSupported(Add(Add(Add(this.Id, " fetchOrderBook() does not support "), GetValue(market, "type")), " markets, only spot and swap markets are accepted")))
            }
            //
            // spot
            //
            //     {
            //         "code": 1000,
            //         "message": "success",
            //         "data": {
            //             "ts": "1695264191808",
            //             "symbol": "BTC_USDT",
            //             "asks": [
            //                 ["26942.57","0.06492"],
            //                 ["26942.73","0.05447"],
            //                 ["26943.00","0.07154"]
            //             ],
            //             "bids": [
            //                 ["26942.45","0.00074"],
            //                 ["26941.53","0.00371"],
            //                 ["26940.94","0.08992"]
            //             ]
            //         },
            //         "trace": "430a7f69581d4258a8e4b424dfb10782.73.16952341919017619"
            //     }
            //
            // swap
            //
            //     {
            //         "code": 1000,
            //         "message": "Ok",
            //         "data": {
            //             "asks": [
            //                 ["26938.3","3499","3499"],
            //                 ["26938.5","14702","18201"],
            //                 ["26938.6","20457","38658"]
            //             ],
            //             "bids": [
            //                 ["26938.2","20","20"],
            //                 ["26937.9","1913","1933"],
            //                 ["26937.8","2588","4521"]
            //             ],
            //             "timestamp": 1695264383999,
            //             "symbol": "BTCUSDT"
            //         },
            //         "trace": "4cad855074664097ac6ba5258c47305d.72.16952643834721135"
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var timestamp interface{} = this.SafeInteger2(data, "ts", "timestamp")
        
            ch <- this.ParseOrderBook(data, GetValue(market, "symbol"), timestamp)
            return nil
        
            }()
            return ch
        }
func  (this *bitmart) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // public fetchTrades spot ( amount = count * price )
    //
    //     [
    //         "BTC_USDT",      // symbol
    //         "1717212457302", // timestamp
    //         "67643.11",      // price
    //         "0.00106",       // size
    //         "sell"           // side
    //     ]
    //
    // spot: fetchMyTrades
    //
    //    {
    //        "tradeId":"182342999769370687",
    //        "orderId":"183270218784142990",
    //        "clientOrderId":"183270218784142990",
    //        "symbol":"ADA_USDT",
    //        "side":"buy",
    //        "orderMode":"spot",
    //        "type":"market",
    //        "price":"0.245948",
    //        "size":"20.71",
    //        "notional":"5.09358308",
    //        "fee":"0.00509358",
    //        "feeCoinName":"USDT",
    //        "tradeRole":"taker",
    //        "createTime":1695658457836,
    //    }
    //
    // swap: fetchMyTrades
    //
    //    {
    //        "order_id": "230930336848609",
    //        "trade_id": "6212604014",
    //        "symbol": "BTCUSDT",
    //        "side": 3,
    //        "price": "26910.4",
    //        "vol": "1",
    //        "exec_type": "Taker",
    //        "profit": false,
    //        "create_time": 1695961596692,
    //        "realised_profit": "-0.0003",
    //        "paid_fees": "0.01614624"
    //    }
    //
    // ws swap
    //
    //    {
    //        'fee': '-0.000044502',
    //        'feeCcy': 'USDT',
    //        'fillPrice': '74.17',
    //        'fillQty': '1',
    //        'lastTradeID': 6802340762
    //    }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeIntegerN(trade, []interface{}{"createTime", "create_time", 1})
    var isPublic interface{} = this.SafeString(trade, 0)
    var isPublicTrade interface{} =     (!IsEqual(isPublic, nil))
    var amount interface{} = nil
    var cost interface{} = nil
    var typeVar interface{} = nil
    var side interface{} = nil
    if IsTrue(isPublicTrade) {
        amount = this.SafeString2(trade, "count", 3)
        cost = this.SafeString(trade, "amount")
        side = this.SafeString2(trade, "type", 4)
    } else {
        amount = this.SafeStringN(trade, []interface{}{"size", "vol", "fillQty"})
        cost = this.SafeString(trade, "notional")
        typeVar = this.SafeString(trade, "type")
        side = this.ParseOrderSide(this.SafeString(trade, "side"))
    }
    var marketId interface{} = this.SafeString2(trade, "symbol", 0)
    market = this.SafeMarket(marketId, market)
    var feeCostString interface{} = this.SafeString2(trade, "fee", "paid_fees")
    var fee interface{} = nil
    if IsTrue(!IsEqual(feeCostString, nil)) {
        var feeCurrencyId interface{} = this.SafeString(trade, "feeCoinName")
        var feeCurrencyCode interface{} = this.SafeCurrencyCode(feeCurrencyId)
        if IsTrue(IsEqual(feeCurrencyCode, nil)) {
            feeCurrencyCode = Ternary(IsTrue((IsEqual(side, "buy"))), GetValue(market, "base"), GetValue(market, "quote"))
        }
        fee = map[string]interface{} {
            "cost": feeCostString,
            "currency": feeCurrencyCode,
        }
    }
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "id": this.SafeStringN(trade, []interface{}{"tradeId", "trade_id", "lastTradeID"}),
        "order": this.SafeString2(trade, "orderId", "order_id"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": GetValue(market, "symbol"),
        "type": typeVar,
        "side": side,
        "price": this.SafeStringN(trade, []interface{}{"price", "fillPrice", 2}),
        "amount": amount,
        "cost": cost,
        "takerOrMaker": this.SafeStringLower2(trade, "tradeRole", "exec_type"),
        "fee": fee,
    }, market)
}
/**
 * @method
 * @name bitmart#fetchTrades
 * @description get a list of the most recent trades for a particular symbol
 * @see https://developer-pro.bitmart.com/en/spot/#get-recent-trades-v3
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum number of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *bitmart) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes19728 := (<-this.LoadMarkets())
            PanicOnError(retRes19728)
            var market interface{} = this.Market(symbol)
            if !IsTrue(GetValue(market, "spot")) {
                panic(NotSupported(Add(Add(Add(this.Id, " fetchTrades() does not support "), GetValue(market, "type")), " orders, only spot orders are accepted")))
            }
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.PublicGetSpotQuotationV3Trades(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": 1000,
            //         "trace": "58031f9a5bd.111.17117",
            //         "message": "success",
            //         "data": [
            //             [
            //                 "BTC_USDT",
            //                 "1717212457302",
            //                 "67643.11",
            //                 "0.00106",
            //                 "sell"
            //             ],
            //         ]
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTrades(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *bitmart) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // spot
    //    [
    //        "1699512060", // timestamp
    //        "36746.49", // open
    //        "36758.71", // high
    //        "36736.13", // low
    //        "36755.99", // close
    //        "2.83965", // base volume
    //        "104353.57" // quote volume
    //    ]
    //
    // swap
    //    {
    //        "low_price": "20090.3",
    //        "high_price": "20095.5",
    //        "open_price": "20092.6",
    //        "close_price": "20091.4",
    //        "volume": "8748",
    //        "timestamp": 1665002281
    //    }
    //
    // ws
    //    [
    //        1631056350, // timestamp
    //        "46532.83", // open
    //        "46555.71", // high
    //        "46511.41", // low
    //        "46555.71", // close
    //        "0.25", // volume
    //    ]
    //
    // ws swap
    //    {
    //        "symbol":"BTCUSDT",
    //        "o":"146.24",
    //        "h":"146.24",
    //        "l":"146.24",
    //        "c":"146.24",
    //        "v":"146"
    //    }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    if IsTrue(IsArray(ohlcv)) {
        return []interface{}{this.SafeTimestamp(ohlcv, 0), this.SafeNumber(ohlcv, 1), this.SafeNumber(ohlcv, 2), this.SafeNumber(ohlcv, 3), this.SafeNumber(ohlcv, 4), this.SafeNumber(ohlcv, 5)}
    } else {
        return []interface{}{this.SafeTimestamp2(ohlcv, "timestamp", "ts"), this.SafeNumber2(ohlcv, "open_price", "o"), this.SafeNumber2(ohlcv, "high_price", "h"), this.SafeNumber2(ohlcv, "low_price", "l"), this.SafeNumber2(ohlcv, "close_price", "c"), this.SafeNumber2(ohlcv, "volume", "v")}
    }
}
/**
 * @method
 * @name bitmart#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://developer-pro.bitmart.com/en/spot/#get-history-k-line-v3
 * @see https://developer-pro.bitmart.com/en/futuresv2/#get-k-line
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp of the latest candle in ms
 * @param {boolean} [params.paginate] *spot only* default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *bitmart) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes20848 := (<-this.LoadMarkets())
            PanicOnError(retRes20848)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchOHLCV", "paginate", false);
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes208819 :=  (<-this.FetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, params, 200))
                    PanicOnError(retRes208819)
                    ch <- retRes208819
                    return nil
            }
            var market interface{} = this.Market(symbol)
            var duration interface{} = this.ParseTimeframe(timeframe)
            var parsedTimeframe interface{} = this.SafeInteger(this.Timeframes, timeframe)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(parsedTimeframe, nil)) {
                AddElementToObject(request, "step", parsedTimeframe)
            } else {
                AddElementToObject(request, "step", timeframe)
            }
            if IsTrue(GetValue(market, "spot")) {
                requestparamsVariable := this.HandleUntilOption("before", request, params, 0.001);
                request = GetValue(requestparamsVariable,0);
                params = GetValue(requestparamsVariable,1)
                if IsTrue(!IsEqual(limit, nil)) {
                    AddElementToObject(request, "limit", limit)
                }
                if IsTrue(!IsEqual(since, nil)) {
                    AddElementToObject(request, "after", Subtract(this.ParseToInt((Divide(since, 1000))), 1))
                }
            } else {
                var maxLimit interface{} = 500
                if IsTrue(IsEqual(limit, nil)) {
                    limit = maxLimit
                }
                limit = mathMin(maxLimit, limit)
                var now interface{} = this.ParseToInt(Divide(this.Milliseconds(), 1000))
                if IsTrue(IsEqual(since, nil)) {
                    var start interface{} = Subtract(now, Multiply(limit, duration))
                    AddElementToObject(request, "start_time", start)
                    AddElementToObject(request, "end_time", now)
                } else {
                    var start interface{} = Subtract(this.ParseToInt((Divide(since, 1000))), 1)
                    var end interface{} = this.Sum(start, Multiply(limit, duration))
                    AddElementToObject(request, "start_time", start)
                    AddElementToObject(request, "end_time", mathMin(end, now))
                }
                requestparamsVariable := this.HandleUntilOption("end_time", request, params, 0.001);
                request = GetValue(requestparamsVariable,0);
                params = GetValue(requestparamsVariable,1)
            }
            var response interface{} = nil
            if IsTrue(GetValue(market, "swap")) {
                
        response = (<-this.PublicGetContractPublicKline(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PublicGetSpotQuotationV3Klines(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            // spot
            //
            //     {
            //         "code": 1000,
            //         "message": "success",
            //         "data": [
            //             ["1699512060","36746.49","36758.71","36736.13","36755.99","2.83965","104353.57"],
            //             ["1699512120","36756.00","36758.70","36737.14","36737.63","1.96070","72047.10"],
            //             ["1699512180","36737.63","36740.45","36737.62","36740.44","0.63194","23217.62"]
            //         ],
            //         "trace": "6591fc7b508845359d5fa442e3b3a4fb.72.16995122398750695"
            //     }
            //
            // swap
            //
            //     {
            //         "code": 1000,
            //         "message": "Ok",
            //         "data": [
            //             {
            //                 "low_price": "20090.3",
            //                 "high_price": "20095.5",
            //                 "open_price": "20092.6",
            //                 "close_price": "20091.4",
            //                 "volume": "8748",
            //                 "timestamp": 1665002281
            //             },
            //             ...
            //         ],
            //         "trace": "96c989db-e0f5-46f5-bba6-60cfcbde699b"
            //     }
            //
            var ohlcv interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseOHLCVs(ohlcv, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitmart#fetchMyTrades
 * @see https://developer-pro.bitmart.com/en/spot/#account-trade-list-v4-signed
 * @see https://developer-pro.bitmart.com/en/futures/#get-order-trade-keyed
 * @description fetch all trades made by the user
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch trades for
 * @param {boolean} [params.marginMode] *spot* whether to fetch trades for margin orders or spot orders, defaults to spot orders (only isolated margin orders are supported)
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *bitmart) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes21868 := (<-this.LoadMarkets())
            PanicOnError(retRes21868)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            var typeVar interface{} = nil
            var response interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchMyTrades", market, params);
            typeVar = GetValue(typeVarparamsVariable,0);
            params = GetValue(typeVarparamsVariable,1)
            var until interface{} = this.SafeIntegerN(params, []interface{}{"until", "endTime", "end_time"})
            params = this.Omit(params, []interface{}{"until"})
            if IsTrue(IsEqual(typeVar, "spot")) {
                var marginMode interface{} = nil
                marginModeparamsVariable := this.HandleMarginModeAndParams("fetchMyTrades", params);
                marginMode = GetValue(marginModeparamsVariable,0);
                params = GetValue(marginModeparamsVariable,1)
                if IsTrue(IsEqual(marginMode, "isolated")) {
                    AddElementToObject(request, "orderMode", "iso_margin")
                }
                var options interface{} = this.SafeDict(this.Options, "fetchMyTrades", map[string]interface{} {})
                var maxLimit interface{} = 200
                var defaultLimit interface{} = this.SafeInteger(options, "limit", maxLimit)
                if IsTrue(IsEqual(limit, nil)) {
                    limit = defaultLimit
                }
                AddElementToObject(request, "limit", mathMin(limit, maxLimit))
                if IsTrue(!IsEqual(since, nil)) {
                    AddElementToObject(request, "startTime", since)
                }
                if IsTrue(!IsEqual(until, nil)) {
                    AddElementToObject(request, "endTime", until)
                }
                
        response = (<-this.PrivatePostSpotV4QueryTrades(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(typeVar, "swap")) {
                if IsTrue(IsEqual(symbol, nil)) {
                    panic(ArgumentsRequired(Add(this.Id, " fetchMyTrades() requires a symbol argument")))
                }
                if IsTrue(!IsEqual(since, nil)) {
                    AddElementToObject(request, "start_time", since)
                }
                if IsTrue(!IsEqual(until, nil)) {
                    AddElementToObject(request, "end_time", until)
                }
                
        response = (<-this.PrivateGetContractPrivateTrades(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                panic(NotSupported(Add(Add(Add(this.Id, " fetchMyTrades() does not support "), typeVar), " orders, only spot and swap orders are accepted")))
            }
            //
            // spot
            //
            //    {
            //        "code":1000,
            //        "message":"success",
            //        "data":[
            //           {
            //              "tradeId":"182342999769370687",
            //              "orderId":"183270218784142990",
            //              "clientOrderId":"183270218784142990",
            //              "symbol":"ADA_USDT",
            //              "side":"buy",
            //              "orderMode":"spot",
            //              "type":"market",
            //              "price":"0.245948",
            //              "size":"20.71",
            //              "notional":"5.09358308",
            //              "fee":"0.00509358",
            //              "feeCoinName":"USDT",
            //              "tradeRole":"taker",
            //              "createTime":1695658457836,
            //              "updateTime":1695658457836
            //           }
            //        ],
            //        "trace":"fbaee9e0e2f5442fba5b3262fc86b0ac.65.16956593456523085"
            //    }
            //
            // swap
            //
            //     {
            //         "code": 1000,
            //         "message": "Ok",
            //         "data": [
            //             {
            //                 "order_id": "230930336848609",
            //                 "trade_id": "6212604014",
            //                 "symbol": "BTCUSDT",
            //                 "side": 3,
            //                 "price": "26910.4",
            //                 "vol": "1",
            //                 "exec_type": "Taker",
            //                 "profit": false,
            //                 "create_time": 1695961596692,
            //                 "realised_profit": "-0.0003",
            //                 "paid_fees": "0.01614624"
            //             },
            //         ],
            //         "trace": "4cad855074634097ac6ba5257c47305d.62.16959616054873723"
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTrades(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitmart#fetchOrderTrades
 * @see https://developer-pro.bitmart.com/en/spot/#order-trade-list-v4-signed
 * @description fetch all the trades made from a single order
 * @param {string} id order id
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *bitmart) FetchOrderTrades(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes23008 := (<-this.LoadMarkets())
            PanicOnError(retRes23008)
            var request interface{} = map[string]interface{} {
                "orderId": id,
            }
        
            response:= (<-this.PrivatePostSpotV4QueryOrderTrades(this.Extend(request, params)))
            PanicOnError(response)
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTrades(data, nil, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *bitmart) CustomParseBalance(response interface{}, marketType interface{}) interface{}  {
    var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
    var wallet interface{} = nil
    if IsTrue(IsEqual(marketType, "swap")) {
        wallet = this.SafeList(response, "data", []interface{}{})
    } else if IsTrue(IsEqual(marketType, "margin")) {
        wallet = this.SafeList(data, "symbols", []interface{}{})
    } else {
        wallet = this.SafeList(data, "wallet", []interface{}{})
    }
    var result interface{} = map[string]interface{} {
        "info": response,
    }
    if IsTrue(IsEqual(marketType, "margin")) {
        for i := 0; IsLessThan(i, GetArrayLength(wallet)); i++ {
            var entry interface{} = GetValue(wallet, i)
            var marketId interface{} = this.SafeString(entry, "symbol")
            var symbol interface{} = this.SafeSymbol(marketId, nil, "_")
            var base interface{} = this.SafeDict(entry, "base", map[string]interface{} {})
            var quote interface{} = this.SafeDict(entry, "quote", map[string]interface{} {})
            var baseCode interface{} = this.SafeCurrencyCode(this.SafeString(base, "currency"))
            var quoteCode interface{} = this.SafeCurrencyCode(this.SafeString(quote, "currency"))
            var subResult interface{} = map[string]interface{} {}
            AddElementToObject(subResult, baseCode, this.ParseBalanceHelper(base))
            AddElementToObject(subResult, quoteCode, this.ParseBalanceHelper(quote))
            AddElementToObject(result, symbol, this.SafeBalance(subResult))
        }
        return result
    } else {
        for i := 0; IsLessThan(i, GetArrayLength(wallet)); i++ {
            var balance interface{} = GetValue(wallet, i)
            var currencyId interface{} = this.SafeString2(balance, "id", "currency")
            currencyId = this.SafeString(balance, "coin_code", currencyId)
            var code interface{} = this.SafeCurrencyCode(currencyId)
            var account interface{} = this.Account()
            AddElementToObject(account, "free", this.SafeString2(balance, "available", "available_balance"))
            AddElementToObject(account, "used", this.SafeString2(balance, "frozen", "frozen_balance"))
            AddElementToObject(result, code, account)
        }
        return this.SafeBalance(result)
    }
}
func  (this *bitmart) ParseBalanceHelper(entry interface{}) interface{}  {
    var account interface{} = this.Account()
    AddElementToObject(account, "used", this.SafeString(entry, "frozen"))
    AddElementToObject(account, "free", this.SafeString(entry, "available"))
    AddElementToObject(account, "total", this.SafeString(entry, "total_asset"))
    var debt interface{} = this.SafeString(entry, "borrow_unpaid")
    var interest interface{} = this.SafeString(entry, "interest_unpaid")
    AddElementToObject(account, "debt", Precise.StringAdd(debt, interest))
    return account
}
/**
 * @method
 * @name bitmart#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://developer-pro.bitmart.com/en/spot/#get-spot-wallet-balance
 * @see https://developer-pro.bitmart.com/en/futures/#get-contract-assets-detail
 * @see https://developer-pro.bitmart.com/en/futuresv2/#get-contract-assets-keyed
 * @see https://developer-pro.bitmart.com/en/spot/#get-account-balance
 * @see https://developer-pro.bitmart.com/en/spot/#get-margin-account-details-isolated
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *bitmart) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes23748 := (<-this.LoadMarkets())
            PanicOnError(retRes23748)
            var marketType interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchBalance", nil, params);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            var marginMode interface{} = this.SafeString(params, "marginMode")
            var isMargin interface{} = this.SafeBool(params, "margin", false)
            params = this.Omit(params, []interface{}{"margin", "marginMode"})
            if IsTrue(IsTrue(!IsEqual(marginMode, nil)) || IsTrue(isMargin)) {
                marketType = "margin"
            }
            var response interface{} = nil
            if IsTrue(IsEqual(marketType, "spot")) {
                
        response = (<-this.PrivateGetSpotV1Wallet(params))
                PanicOnError(response)
            } else if IsTrue(IsEqual(marketType, "swap")) {
                
        response = (<-this.PrivateGetContractPrivateAssetsDetail(params))
                PanicOnError(response)
            } else if IsTrue(IsEqual(marketType, "account")) {
                
        response = (<-this.PrivateGetAccountV1Wallet(params))
                PanicOnError(response)
            } else if IsTrue(IsEqual(marketType, "margin")) {
                
        response = (<-this.PrivateGetSpotV1MarginIsolatedAccount(params))
                PanicOnError(response)
            } else {
                panic(NotSupported(Add(Add(Add(this.Id, " fetchBalance() does not support "), marketType), " markets, only spot, swap and account and margin markets are accepted")))
            }
        
                //
            // spot
            //
            //     {
            //         "message":"OK",
            //         "code":1000,
            //         "trace":"39069916-72f9-44c7-acde-2ad5afd21cad",
            //         "data":{
            //             "wallet":[
            //                 {"id":"BTC","name":"Bitcoin","available":"0.00000062","frozen":"0.00000000"},
            //                 {"id":"ETH","name":"Ethereum","available":"0.00002277","frozen":"0.00000000"},
            //                 {"id":"BMX","name":"BitMart Token","available":"0.00000000","frozen":"0.00000000"}
            //             ]
            //         }
            //     }
            //
            // account
            //
            //     {
            //         "message":"OK",
            //         "code":1000,
            //         "trace":"5c3b7fc7-93b2-49ef-bb59-7fdc56915b59",
            //         "data":{
            //             "wallet":[
            //                 {"currency":"BTC","name":"Bitcoin","available":"0.00000062","frozen":"0.00000000"},
            //                 {"currency":"ETH","name":"Ethereum","available":"0.00002277","frozen":"0.00000000"}
            //             ]
            //         }
            //     }
            //
            // swap
            //
            //     {
            //         "code": 1000,
            //         "message": "Ok",
            //         "data": [
            //             {
            //                 "currency": "USDT",
            //                 "available_balance": "0",
            //                 "frozen_balance": "0",
            //                 "unrealized": "0",
            //                 "equity": "0",
            //                 "position_deposit": "0"
            //             },
            //             ...
            //         ],
            //         "trace": "f9da3a39-cf45-42e7-914d-294f565dfc33"
            //     }
            //
            // margin
            //
            //     {
            //         "message": "OK",
            //         "code": 1000,
            //         "trace": "61dd6ab265c04064b72d8bc9b205f741.71.16701055600915302",
            //         "data": {
            //             "symbols": [
            //                 {
            //                     "symbol": "BTC_USDT",
            //                     "risk_rate": "999.00",
            //                     "risk_level": "1",
            //                     "buy_enabled": false,
            //                     "sell_enabled": false,
            //                     "liquidate_price": null,
            //                     "liquidate_rate": "1.15",
            //                     "base": {
            //                         "currency": "BTC",
            //                         "borrow_enabled": true,
            //                         "borrowed": "0.00000000",
            //                         "available": "0.00000000",
            //                         "frozen": "0.00000000",
            //                         "net_asset": "0.00000000",
            //                         "net_assetBTC": "0.00000000",
            //                         "total_asset": "0.00000000",
            //                         "borrow_unpaid": "0.00000000",
            //                         "interest_unpaid": "0.00000000"
            //                     },
            //                     "quote": {
            //                         "currency": "USDT",
            //                         "borrow_enabled": true,
            //                         "borrowed": "0.00000000",
            //                         "available": "20.00000000",
            //                         "frozen": "0.00000000",
            //                         "net_asset": "20.00000000",
            //                         "net_assetBTC": "0.00118008",
            //                         "total_asset": "20.00000000",
            //                         "borrow_unpaid": "0.00000000",
            //                         "interest_unpaid": "0.00000000"
            //                     }
            //                 }
            //             ]
            //         }
            //     }
            //
        ch <- this.CustomParseBalance(response, marketType)
            return nil
        
            }()
            return ch
        }
func  (this *bitmart) ParseTradingFee(fee interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "symbol": "ETH_USDT",
    //         "taker_fee_rate": "0.0025",
    //         "maker_fee_rate": "0.0025"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(fee, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId)
    return map[string]interface{} {
        "info": fee,
        "symbol": symbol,
        "maker": this.SafeNumber(fee, "maker_fee_rate"),
        "taker": this.SafeNumber(fee, "taker_fee_rate"),
        "percentage": nil,
        "tierBased": nil,
    }
}
/**
 * @method
 * @name bitmart#fetchTradingFee
 * @description fetch the trading fees for a market
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func  (this *bitmart) FetchTradingFee(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes25218 := (<-this.LoadMarkets())
            PanicOnError(retRes25218)
            var market interface{} = this.Market(symbol)
            if !IsTrue(GetValue(market, "spot")) {
                panic(NotSupported(Add(Add(Add(this.Id, " fetchTradingFee() does not support "), GetValue(market, "type")), " orders, only spot orders are accepted")))
            }
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.PrivateGetSpotV1TradeFee(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "message": "OK",
            //         "code": "1000",
            //         "trace": "5a6f1e40-37fe-4849-a494-03279fadcc62",
            //         "data": {
            //             "symbol": "ETH_USDT",
            //             "taker_fee_rate": "0.0025",
            //             "maker_fee_rate": "0.0025"
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseTradingFee(data)
            return nil
        
            }()
            return ch
        }
func  (this *bitmart) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // createOrder, editOrder
    //
    //     {
    //         "order_id": 2707217580
    //     }
    //
    // swap
    //   "data": {
    //       "order_id": 231116359426639,
    //       "price": "market price"
    //    },
    //
    // cancelOrder
    //
    //     "2707217580" // order id
    //
    // spot fetchOrder, fetchOrdersByStatus, fetchOpenOrders, fetchClosedOrders
    //
    //     {
    //         "order_id":1736871726781,
    //         "symbol":"BTC_USDT",
    //         "create_time":1591096004000,
    //         "side":"sell",
    //         "type":"market", // limit, market, limit_maker, ioc
    //         "price":"0.00",
    //         "price_avg":"0.00",
    //         "size":"0.02000",
    //         "notional":"0.00000000",
    //         "filled_notional":"0.00000000",
    //         "filled_size":"0.00000",
    //         "status":"8"
    //     }
    //
    // spot v4
    //    {
    //        "orderId" : "118100034543076010",
    //        "clientOrderId" : "118100034543076010",
    //        "symbol" : "BTC_USDT",
    //        "side" : "buy",
    //        "orderMode" : "spot",
    //        "type" : "limit",
    //        "state" : "filled",
    //        "price" : "48800.00",
    //        "priceAvg" : "39999.00",
    //        "size" : "0.10000",
    //        "filledSize" : "0.10000",
    //        "notional" : "4880.00000000",
    //        "filledNotional" : "3999.90000000",
    //        "createTime" : 1681701557927,
    //        "updateTime" : 1681701559408
    //    }
    //
    // swap: fetchOrder, fetchOpenOrders, fetchClosedOrders
    //
    //     {
    //         "order_id": "230935812485489",
    //         "client_order_id": "",
    //         "price": "24000",
    //         "size": "1",
    //         "symbol": "BTCUSDT",
    //         "state": 2,
    //         "side": 1,
    //         "type": "limit",
    //         "leverage": "10",
    //         "open_type": "isolated",
    //         "deal_avg_price": "0",
    //         "deal_size": "0",
    //         "create_time": 1695702258629,
    //         "update_time": 1695702258642,
    //         "activation_price_type": 0,
    //         "activation_price": "",
    //         "callback_rate": ""
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = nil
    if IsTrue(IsString(order)) {
        id = order
        order = map[string]interface{} {}
    }
    id = this.SafeString2(order, "order_id", "orderId", id)
    var timestamp interface{} = this.SafeInteger2(order, "create_time", "createTime")
    var marketId interface{} = this.SafeString(order, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    market = this.SafeMarket(symbol, market)
    var orderType interface{} = this.SafeString(market, "type", "spot")
    var typeVar interface{} = this.SafeString(order, "type")
    var timeInForce interface{} = nil
    var postOnly interface{} = nil
    if IsTrue(IsEqual(typeVar, "limit_maker")) {
        typeVar = "limit"
        postOnly = true
        timeInForce = "PO"
    }
    if IsTrue(IsEqual(typeVar, "ioc")) {
        typeVar = "limit"
        timeInForce = "IOC"
    }
    var priceString interface{} = this.SafeString(order, "price")
    if IsTrue(IsEqual(priceString, "market price")) {
        priceString = nil
    }
    var trailingActivationPrice interface{} = this.SafeNumber(order, "activation_price")
    return this.SafeOrder(map[string]interface{} {
        "id": id,
        "clientOrderId": this.SafeString2(order, "client_order_id", "clientOrderId"),
        "info": order,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": this.SafeInteger(order, "update_time"),
        "symbol": symbol,
        "type": typeVar,
        "timeInForce": timeInForce,
        "postOnly": postOnly,
        "side": this.ParseOrderSide(this.SafeString(order, "side")),
        "price": this.OmitZero(priceString),
        "triggerPrice": trailingActivationPrice,
        "amount": this.OmitZero(this.SafeString(order, "size")),
        "cost": this.SafeString2(order, "filled_notional", "filledNotional"),
        "average": this.SafeStringN(order, []interface{}{"price_avg", "priceAvg", "deal_avg_price"}),
        "filled": this.SafeStringN(order, []interface{}{"filled_size", "filledSize", "deal_size"}),
        "remaining": nil,
        "status": this.ParseOrderStatusByType(orderType, this.SafeString2(order, "status", "state")),
        "fee": nil,
        "trades": nil,
    }, market)
}
func  (this *bitmart) ParseOrderSide(side interface{}) interface{}  {
    var sides interface{} = map[string]interface{} {
        "1": "buy",
        "2": "buy",
        "3": "sell",
        "4": "sell",
    }
    return this.SafeString(sides, side, side)
}
func  (this *bitmart) ParseOrderStatusByType(typeVar interface{}, status interface{}) interface{}  {
    var statusesByType interface{} = map[string]interface{} {
        "spot": map[string]interface{} {
            "1": "rejected",
            "2": "open",
            "3": "rejected",
            "4": "open",
            "5": "open",
            "6": "closed",
            "7": "canceled",
            "8": "canceled",
            "new": "open",
            "partially_filled": "open",
            "filled": "closed",
            "partially_canceled": "canceled",
        },
        "swap": map[string]interface{} {
            "1": "open",
            "2": "open",
            "4": "closed",
        },
    }
    var statuses interface{} = this.SafeDict(statusesByType, typeVar, map[string]interface{} {})
    return this.SafeString(statuses, status, status)
}
/**
 * @method
 * @name bitmart#createMarketBuyOrderWithCost
 * @description create a market buy order by providing the symbol and cost
 * @see https://developer-pro.bitmart.com/en/spot/#new-order-v2-signed
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {float} cost how much you want to trade in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bitmart) CreateMarketBuyOrderWithCost(symbol interface{}, cost interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes27228 := (<-this.LoadMarkets())
            PanicOnError(retRes27228)
            var market interface{} = this.Market(symbol)
            if !IsTrue(GetValue(market, "spot")) {
                panic(NotSupported(Add(this.Id, " createMarketBuyOrderWithCost() supports spot orders only")))
            }
            AddElementToObject(params, "createMarketBuyOrderRequiresPrice", false)
        
                retRes272815 :=  (<-this.CreateOrder(symbol, "market", "buy", cost, nil, params))
                PanicOnError(retRes272815)
                ch <- retRes272815
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitmart#createOrder
 * @description create a trade order
 * @see https://developer-pro.bitmart.com/en/spot/#new-order-v2-signed
 * @see https://developer-pro.bitmart.com/en/spot/#place-margin-order
 * @see https://developer-pro.bitmart.com/en/futures/#submit-order-signed
 * @see https://developer-pro.bitmart.com/en/futures/#submit-plan-order-signed
 * @see https://developer-pro.bitmart.com/en/futuresv2/#submit-plan-order-signed
 * @see https://developer-pro.bitmart.com/en/futuresv2/#submit-tp-or-sl-order-signed
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market', 'limit' or 'trailing' for swap markets only
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] 'cross' or 'isolated'
 * @param {string} [params.leverage] *swap only* leverage level
 * @param {string} [params.clientOrderId] client order id of the order
 * @param {boolean} [params.reduceOnly] *swap only* reduce only
 * @param {boolean} [params.postOnly] make sure the order is posted to the order book and not matched immediately
 * @param {string} [params.triggerPrice] *swap only* the price to trigger a stop order
 * @param {int} [params.price_type] *swap only* 1: last price, 2: fair price, default is 1
 * @param {int} [params.price_way] *swap only* 1: price way long, 2: price way short
 * @param {int} [params.activation_price_type] *swap trailing order only* 1: last price, 2: fair price, default is 1
 * @param {string} [params.trailingPercent] *swap only* the percent to trail away from the current market price, min 0.1 max 5
 * @param {string} [params.trailingTriggerPrice] *swap only* the price to trigger a trailing order, default uses the price argument
 * @param {string} [params.stopLossPrice] *swap only* the price to trigger a stop-loss order
 * @param {string} [params.takeProfitPrice] *swap only* the price to trigger a take-profit order
 * @param {int} [params.plan_category] *swap tp/sl only* 1: tp/sl, 2: position tp/sl, default is 1
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bitmart) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes27648 := (<-this.LoadMarkets())
            PanicOnError(retRes27648)
            var market interface{} = this.Market(symbol)
            var result interface{} = this.HandleMarginModeAndParams("createOrder", params)
            var marginMode interface{} = this.SafeString(result, 0)
            var triggerPrice interface{} = this.SafeStringN(params, []interface{}{"triggerPrice", "stopPrice", "trigger_price"})
            var stopLossPrice interface{} = this.SafeString(params, "stopLossPrice")
            var takeProfitPrice interface{} = this.SafeString(params, "takeProfitPrice")
            var isStopLoss interface{} = !IsEqual(stopLossPrice, nil)
            var isTakeProfit interface{} = !IsEqual(takeProfitPrice, nil)
            var isTriggerOrder interface{} = !IsEqual(triggerPrice, nil)
            var response interface{} = nil
            if IsTrue(GetValue(market, "spot")) {
                var spotRequest interface{} = this.CreateSpotOrderRequest(symbol, typeVar, side, amount, price, params)
                if IsTrue(IsEqual(marginMode, "isolated")) {
                    
        response = (<-this.PrivatePostSpotV1MarginSubmitOrder(spotRequest))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.PrivatePostSpotV2SubmitOrder(spotRequest))
                    PanicOnError(response)
                }
            } else {
                var swapRequest interface{} = this.CreateSwapOrderRequest(symbol, typeVar, side, amount, price, params)
                if IsTrue(isTriggerOrder) {
                    
        response = (<-this.PrivatePostContractPrivateSubmitPlanOrder(swapRequest))
                    PanicOnError(response)
                } else if IsTrue(IsTrue(isStopLoss) || IsTrue(isTakeProfit)) {
                    
        response = (<-this.PrivatePostContractPrivateSubmitTpSlOrder(swapRequest))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.PrivatePostContractPrivateSubmitOrder(swapRequest))
                    PanicOnError(response)
                }
            }
            //
            // spot and margin
            //
            //     {
            //         "code": 1000,
            //         "trace":"886fb6ae-456b-4654-b4e0-d681ac05cea1",
            //         "message": "OK",
            //         "data": {
            //             "order_id": 2707217580
            //         }
            //     }
            //
            // swap
            // {"code":1000,"message":"Ok","data":{"order_id":231116359426639,"price":"market price"},"trace":"7f9c94e10f9d4513bc08a7bfc2a5559a.62.16996369620521911"}
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var order interface{} = this.ParseOrder(data, market)
            AddElementToObject(order, "type", typeVar)
            AddElementToObject(order, "side", side)
            AddElementToObject(order, "amount", amount)
            AddElementToObject(order, "price", price)
        
            ch <- order
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitmart#createOrders
 * @description create a list of trade orders
 * @see https://developer-pro.bitmart.com/en/spot/#new-batch-order-v4-signed
 * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
 * @param {object} [params]  extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bitmart) CreateOrders(orders interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes28268 := (<-this.LoadMarkets())
            PanicOnError(retRes28268)
            var ordersRequests interface{} = []interface{}{}
            var symbol interface{} = nil
            var market interface{} = nil
            for i := 0; IsLessThan(i, GetArrayLength(orders)); i++ {
                var rawOrder interface{} = GetValue(orders, i)
                var marketId interface{} = this.SafeString(rawOrder, "symbol")
                market = this.Market(marketId)
                if !IsTrue(GetValue(market, "spot")) {
                    panic(NotSupported(Add(this.Id, " createOrders() supports spot orders only")))
                }
                if IsTrue(IsEqual(symbol, nil)) {
                    symbol = marketId
                } else {
                    if IsTrue(!IsEqual(symbol, marketId)) {
                        panic(BadRequest(Add(this.Id, " createOrders() requires all orders to have the same symbol")))
                    }
                }
                var typeVar interface{} = this.SafeString(rawOrder, "type")
                var side interface{} = this.SafeString(rawOrder, "side")
                var amount interface{} = this.SafeValue(rawOrder, "amount")
                var price interface{} = this.SafeValue(rawOrder, "price")
                var orderParams interface{} = this.SafeDict(rawOrder, "params", map[string]interface{} {})
                var orderRequest interface{} = this.CreateSpotOrderRequest(marketId, typeVar, side, amount, price, orderParams)
                orderRequest = this.Omit(orderRequest, []interface{}{"symbol"}) // not needed because it goes in the outter object
                AppendToArray(&ordersRequests,orderRequest)
            }
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "orderParams": ordersRequests,
            }
        
            response:= (<-this.PrivatePostSpotV4BatchOrders(request))
            PanicOnError(response)
            //
            // {
            //     "message": "OK",
            //     "code": 1000,
            //     "trace": "5fc697fb817a4b5396284786a9b2609a.263.17022620476480263",
            //     "data": {
            //       "code": 0,
            //       "msg": "success",
            //       "data": {
            //         "orderIds": [
            //           "212751308355553320"
            //         ]
            //       }
            //     }
            // }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var innderData interface{} = this.SafeDict(data, "data", map[string]interface{} {})
            var orderIds interface{} = this.SafeList(innderData, "orderIds", []interface{}{})
            var parsedOrders interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(orderIds)); i++ {
                var orderId interface{} = GetValue(orderIds, i)
                var order interface{} = this.SafeOrder(map[string]interface{} {
                    "id": orderId,
                }, market)
                AppendToArray(&parsedOrders,order)
            }
        
            ch <- parsedOrders
            return nil
        
            }()
            return ch
        }
func  (this *bitmart) CreateSwapOrderRequest(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @name bitmart#createSwapOrderRequest
    * @ignore
    * @description create a trade order
    * @see https://developer-pro.bitmart.com/en/futuresv2/#submit-order-signed
    * @see https://developer-pro.bitmart.com/en/futuresv2/#submit-plan-order-signed
    * @see https://developer-pro.bitmart.com/en/futuresv2/#submit-tp-or-sl-order-signed
    * @param {string} symbol unified symbol of the market to create an order in
    * @param {string} type 'market', 'limit', 'trailing', 'stop_loss', or 'take_profit'
    * @param {string} side 'buy' or 'sell'
    * @param {float} amount how much of currency you want to trade in units of base currency
    * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @param {int} [params.leverage] leverage level
    * @param {boolean} [params.reduceOnly] *swap only* reduce only
    * @param {string} [params.marginMode] 'cross' or 'isolated', default is 'cross'
    * @param {string} [params.clientOrderId] client order id of the order
    * @param {string} [params.triggerPrice] *swap only* the price to trigger a stop order
    * @param {int} [params.price_type] *swap only* 1: last price, 2: fair price, default is 1
    * @param {int} [params.price_way] *swap only* 1: price way long, 2: price way short
    * @param {int} [params.activation_price_type] *swap trailing order only* 1: last price, 2: fair price, default is 1
    * @param {string} [params.trailingPercent] *swap only* the percent to trail away from the current market price, min 0.1 max 5
    * @param {string} [params.trailingTriggerPrice] *swap only* the price to trigger a trailing order, default uses the price argument
    * @param {string} [params.stopLossPrice] *swap only* the price to trigger a stop-loss order
    * @param {string} [params.takeProfitPrice] *swap only* the price to trigger a take-profit order
    * @param {int} [params.plan_category] *swap tp/sl only* 1: tp/sl, 2: position tp/sl, default is 1
    * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
    */
    price := GetArg(optionalArgs, 0, nil)
    _ = price
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    var market interface{} = this.Market(symbol)
    var stopLossPrice interface{} = this.SafeString(params, "stopLossPrice")
    var takeProfitPrice interface{} = this.SafeString(params, "takeProfitPrice")
    var isStopLoss interface{} = !IsEqual(stopLossPrice, nil)
    var isTakeProfit interface{} = !IsEqual(takeProfitPrice, nil)
    if IsTrue(isStopLoss) {
        typeVar = "stop_loss"
    } else if IsTrue(isTakeProfit) {
        typeVar = "take_profit"
    }
    var request interface{} = map[string]interface{} {
        "symbol": GetValue(market, "id"),
        "type": typeVar,
        "size": ParseInt(this.AmountToPrecision(symbol, amount)),
    }
    var timeInForce interface{} = this.SafeString(params, "timeInForce")
    var mode interface{} = this.SafeInteger(params, "mode") // only for swap
    var isMarketOrder interface{} = IsEqual(typeVar, "market")
    var postOnly interface{} = nil
    var reduceOnly interface{} = this.SafeBool(params, "reduceOnly")
    var isExchangeSpecificPo interface{} =     (IsEqual(mode, 4))
    postOnlyparamsVariable := this.HandlePostOnly(isMarketOrder, isExchangeSpecificPo, params);
    postOnly = GetValue(postOnlyparamsVariable,0);
    params = GetValue(postOnlyparamsVariable,1)
    var ioc interface{} =     (IsTrue((IsEqual(timeInForce, "IOC"))) || IsTrue((IsEqual(mode, 3))))
    var isLimitOrder interface{} = IsTrue(IsTrue((IsEqual(typeVar, "limit"))) || IsTrue(postOnly)) || IsTrue(ioc)
    if IsTrue(IsEqual(timeInForce, "GTC")) {
        AddElementToObject(request, "mode", 1)
    } else if IsTrue(IsEqual(timeInForce, "FOK")) {
        AddElementToObject(request, "mode", 2)
    } else if IsTrue(IsEqual(timeInForce, "IOC")) {
        AddElementToObject(request, "mode", 3)
    }
    if IsTrue(postOnly) {
        AddElementToObject(request, "mode", 4)
    }
    var triggerPrice interface{} = this.SafeStringN(params, []interface{}{"triggerPrice", "stopPrice", "trigger_price"})
    var isTriggerOrder interface{} = !IsEqual(triggerPrice, nil)
    var trailingTriggerPrice interface{} = this.SafeString2(params, "trailingTriggerPrice", "activation_price", this.NumberToString(price))
    var trailingPercent interface{} = this.SafeString2(params, "trailingPercent", "callback_rate")
    var isTrailingPercentOrder interface{} = !IsEqual(trailingPercent, nil)
    if IsTrue(isLimitOrder) {
        AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
    } else if IsTrue(IsTrue(IsEqual(typeVar, "trailing")) || IsTrue(isTrailingPercentOrder)) {
        AddElementToObject(request, "callback_rate", trailingPercent)
        AddElementToObject(request, "activation_price", this.PriceToPrecision(symbol, trailingTriggerPrice))
        AddElementToObject(request, "activation_price_type", this.SafeInteger(params, "activation_price_type", 1))
    }
    if IsTrue(isTriggerOrder) {
        if IsTrue(IsTrue(isLimitOrder) || IsTrue(!IsEqual(price, nil))) {
            AddElementToObject(request, "executive_price", this.PriceToPrecision(symbol, price))
        }
        AddElementToObject(request, "trigger_price", this.PriceToPrecision(symbol, triggerPrice))
        AddElementToObject(request, "price_type", this.SafeInteger(params, "price_type", 1))
        if IsTrue(IsEqual(side, "buy")) {
            if IsTrue(reduceOnly) {
                AddElementToObject(request, "price_way", 2)
            } else {
                AddElementToObject(request, "price_way", 1)
            }
        } else if IsTrue(IsEqual(side, "sell")) {
            if IsTrue(reduceOnly) {
                AddElementToObject(request, "price_way", 1)
            } else {
                AddElementToObject(request, "price_way", 2)
            }
        }
    }
    var marginMode interface{} = nil
    marginModeparamsVariable := this.HandleMarginModeAndParams("createOrder", params, "cross");
    marginMode = GetValue(marginModeparamsVariable,0);
    params = GetValue(marginModeparamsVariable,1)
    if IsTrue(IsTrue(isStopLoss) || IsTrue(isTakeProfit)) {
        reduceOnly = true
        AddElementToObject(request, "price_type", this.SafeInteger(params, "price_type", 1))
        AddElementToObject(request, "executive_price", this.PriceToPrecision(symbol, price))
        if IsTrue(isStopLoss) {
            AddElementToObject(request, "trigger_price", this.PriceToPrecision(symbol, stopLossPrice))
        } else {
            AddElementToObject(request, "trigger_price", this.PriceToPrecision(symbol, takeProfitPrice))
        }
    } else {
        AddElementToObject(request, "open_type", marginMode)
    }
    if IsTrue(IsEqual(side, "buy")) {
        if IsTrue(reduceOnly) {
            AddElementToObject(request, "side", 2) // buy close short
        } else {
            AddElementToObject(request, "side", 1) // buy open long
        }
    } else if IsTrue(IsEqual(side, "sell")) {
        if IsTrue(reduceOnly) {
            AddElementToObject(request, "side", 3) // sell close long
        } else {
            AddElementToObject(request, "side", 4) // sell open short
        }
    }
    var clientOrderId interface{} = this.SafeString(params, "clientOrderId")
    if IsTrue(!IsEqual(clientOrderId, nil)) {
        params = this.Omit(params, "clientOrderId")
        AddElementToObject(request, "client_order_id", clientOrderId)
    }
    var leverage interface{} = this.SafeInteger(params, "leverage")
    params = this.Omit(params, []interface{}{"timeInForce", "postOnly", "reduceOnly", "leverage", "trailingTriggerPrice", "trailingPercent", "triggerPrice", "stopPrice", "stopLossPrice", "takeProfitPrice"})
    if IsTrue(!IsEqual(leverage, nil)) {
        AddElementToObject(request, "leverage", this.NumberToString(leverage))
    } else if IsTrue(isTriggerOrder) {
        AddElementToObject(request, "leverage", "1") // for plan orders leverage is required, if not available default to 1
    }
    return this.Extend(request, params)
}
func  (this *bitmart) CreateSpotOrderRequest(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @name bitmart#createSpotOrderRequest
    * @ignore
    * @description create a spot order request
    * @see https://developer-pro.bitmart.com/en/spot/#place-spot-order
    * @see https://developer-pro.bitmart.com/en/spot/#place-margin-order
    * @param {string} symbol unified symbol of the market to create an order in
    * @param {string} type 'market' or 'limit'
    * @param {string} side 'buy' or 'sell'
    * @param {float} amount how much of currency you want to trade in units of base currency
    * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @param {string} [params.marginMode] 'cross' or 'isolated'
    * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
    */
    price := GetArg(optionalArgs, 0, nil)
    _ = price
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    var market interface{} = this.Market(symbol)
    var request interface{} = map[string]interface{} {
        "symbol": GetValue(market, "id"),
        "side": side,
        "type": typeVar,
    }
    var timeInForce interface{} = this.SafeString(params, "timeInForce")
    if IsTrue(IsEqual(timeInForce, "FOK")) {
        panic(InvalidOrder(Add(this.Id, " createOrder() only accepts timeInForce parameter values of IOC or PO")))
    }
    var mode interface{} = this.SafeInteger(params, "mode") // only for swap
    var isMarketOrder interface{} = IsEqual(typeVar, "market")
    var postOnly interface{} = nil
    var isExchangeSpecificPo interface{} = IsTrue((IsEqual(typeVar, "limit_maker"))) || IsTrue((IsEqual(mode, 4)))
    postOnlyparamsVariable := this.HandlePostOnly(isMarketOrder, isExchangeSpecificPo, params);
    postOnly = GetValue(postOnlyparamsVariable,0);
    params = GetValue(postOnlyparamsVariable,1)
    params = this.Omit(params, []interface{}{"timeInForce", "postOnly"})
    var ioc interface{} =     (IsTrue((IsEqual(timeInForce, "IOC"))) || IsTrue((IsEqual(typeVar, "ioc"))))
    var isLimitOrder interface{} = IsTrue(IsTrue((IsEqual(typeVar, "limit"))) || IsTrue(postOnly)) || IsTrue(ioc)
    // method = 'privatePostSpotV2SubmitOrder';
    if IsTrue(isLimitOrder) {
        AddElementToObject(request, "size", this.AmountToPrecision(symbol, amount))
        AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
    } else if IsTrue(isMarketOrder) {
        // for market buy it requires the amount of quote currency to spend
        if IsTrue(IsEqual(side, "buy")) {
            var notional interface{} = this.SafeString2(params, "cost", "notional")
            params = this.Omit(params, "cost")
            var createMarketBuyOrderRequiresPrice interface{} = true
            createMarketBuyOrderRequiresPriceparamsVariable := this.HandleOptionAndParams(params, "createOrder", "createMarketBuyOrderRequiresPrice", true);
            createMarketBuyOrderRequiresPrice = GetValue(createMarketBuyOrderRequiresPriceparamsVariable,0);
            params = GetValue(createMarketBuyOrderRequiresPriceparamsVariable,1)
            if IsTrue(createMarketBuyOrderRequiresPrice) {
                if IsTrue(IsTrue((IsEqual(price, nil))) && IsTrue((IsEqual(notional, nil)))) {
                    panic(InvalidOrder(Add(this.Id, " createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend in the amount argument or in the \"notional\" extra parameter (the exchange-specific behaviour)")))
                } else {
                    var amountString interface{} = this.NumberToString(amount)
                    var priceString interface{} = this.NumberToString(price)
                    notional = Precise.StringMul(amountString, priceString)
                }
            } else {
                notional = Ternary(IsTrue((IsEqual(notional, nil))), this.NumberToString(amount), notional)
            }
            AddElementToObject(request, "notional", this.DecimalToPrecision(notional, TRUNCATE, GetValue(GetValue(market, "precision"), "price"), this.PrecisionMode))
        } else if IsTrue(IsEqual(side, "sell")) {
            AddElementToObject(request, "size", this.AmountToPrecision(symbol, amount))
        }
    }
    if IsTrue(postOnly) {
        AddElementToObject(request, "type", "limit_maker")
    }
    if IsTrue(ioc) {
        AddElementToObject(request, "type", "ioc")
    }
    var clientOrderId interface{} = this.SafeString(params, "clientOrderId")
    if IsTrue(!IsEqual(clientOrderId, nil)) {
        params = this.Omit(params, "clientOrderId")
        AddElementToObject(request, "client_order_id", clientOrderId)
    }
    return this.Extend(request, params)
}
/**
 * @method
 * @name bitmart#cancelOrder
 * @description cancels an open order
 * @see https://developer-pro.bitmart.com/en/futures/#cancel-order-signed
 * @see https://developer-pro.bitmart.com/en/spot/#cancel-order-v3-signed
 * @see https://developer-pro.bitmart.com/en/futures/#cancel-plan-order-signed
 * @see https://developer-pro.bitmart.com/en/futures/#cancel-plan-order-signed
 * @see https://developer-pro.bitmart.com/en/futures/#cancel-order-signed
 * @see https://developer-pro.bitmart.com/en/futures/#cancel-plan-order-signed
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.clientOrderId] *spot only* the client order id of the order to cancel
 * @param {boolean} [params.trigger] *swap only* whether the order is a trigger order
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bitmart) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " cancelOrder() requires a symbol argument")))
            }
        
            retRes31218 := (<-this.LoadMarkets())
            PanicOnError(retRes31218)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var clientOrderId interface{} = this.SafeString2(params, "clientOrderId", "client_order_id")
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                AddElementToObject(request, "client_order_id", clientOrderId)
            } else {
                AddElementToObject(request, "order_id", ToString(id))
            }
            params = this.Omit(params, []interface{}{"clientOrderId"})
            var response interface{} = nil
            if IsTrue(GetValue(market, "spot")) {
                
        response = (<-this.PrivatePostSpotV3CancelOrder(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                var trigger interface{} = this.SafeBool2(params, "stop", "trigger")
                params = this.Omit(params, []interface{}{"stop", "trigger"})
                if !IsTrue(trigger) {
                    
        response = (<-this.PrivatePostContractPrivateCancelOrder(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.PrivatePostContractPrivateCancelPlanOrder(this.Extend(request, params)))
                    PanicOnError(response)
                }
            }
            // swap
            // {"code":1000,"message":"Ok","trace":"7f9c94e10f9d4513bc08a7bfc2a5559a.55.16959817848001851"}
            //
            // spot
            //
            //     {
            //         "code": 1000,
            //         "trace":"886fb6ae-456b-4654-b4e0-d681ac05cea1",
            //         "message": "OK",
            //         "data": {
            //             "result": true
            //         }
            //     }
            //
            // spot alternative
            //
            //     {
            //         "code": 1000,
            //         "trace":"886fb6ae-456b-4654-b4e0-d681ac05cea1",
            //         "message": "OK",
            //         "data": true
            //     }
            //
            if IsTrue(GetValue(market, "swap")) {
        
                ch <- response
                return nil
            }
            var data interface{} = this.SafeValue(response, "data")
            if IsTrue(IsEqual(data, true)) {
        
                ch <- this.SafeOrder(map[string]interface{} {
                    "id": id,
                }, market)
                return nil
            }
            var succeeded interface{} = this.SafeValue(data, "succeed")
            if IsTrue(!IsEqual(succeeded, nil)) {
                id = this.SafeString(succeeded, 0)
                if IsTrue(IsEqual(id, nil)) {
                    panic(InvalidOrder(Add(Add(Add(Add(this.Id, " cancelOrder() failed to cancel "), symbol), " order id "), id)))
                }
            } else {
                var result interface{} = this.SafeValue(data, "result")
                if !IsTrue(result) {
                    panic(InvalidOrder(Add(Add(Add(Add(Add(this.Id, " cancelOrder() "), symbol), " order id "), id), " is filled or canceled")))
                }
            }
            var order interface{} = this.SafeOrder(map[string]interface{} {
                "id": id,
                "symbol": GetValue(market, "symbol"),
                "info": map[string]interface{} {},
            }, market)
        
            ch <- order
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitmart#cancelOrders
 * @description cancel multiple orders
 * @see https://developer-pro.bitmart.com/en/spot/#cancel-batch-order-v4-signed
 * @param {string[]} ids order ids
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string[]} [params.clientOrderIds] client order ids
 * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bitmart) CancelOrders(ids interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " cancelOrders() requires a symbol argument")))
            }
        
            retRes32068 := (<-this.LoadMarkets())
            PanicOnError(retRes32068)
            var market interface{} = this.Market(symbol)
            if !IsTrue(GetValue(market, "spot")) {
                panic(NotSupported(Add(Add(Add(this.Id, " cancelOrders() does not support "), GetValue(market, "type")), " orders, only spot orders are accepted")))
            }
            var clientOrderIds interface{} = this.SafeList(params, "clientOrderIds")
            params = this.Omit(params, []interface{}{"clientOrderIds"})
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(clientOrderIds, nil)) {
                AddElementToObject(request, "clientOrderIds", clientOrderIds)
            } else {
                AddElementToObject(request, "orderIds", ids)
            }
        
            response:= (<-this.PrivatePostSpotV4CancelOrders(this.Extend(request, params)))
            PanicOnError(response)
            //
            //  {
            //      "message": "OK",
            //      "code": 1000,
            //      "trace": "c4edbce860164203954f7c3c81d60fc6.309.17022669632770001",
            //      "data": {
            //        "successIds": [
            //          "213055379155243012"
            //        ],
            //        "failIds": [],
            //        "totalCount": 1,
            //        "successCount": 1,
            //        "failedCount": 0
            //      }
            //  }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var allOrders interface{} = []interface{}{}
            var successIds interface{} = this.SafeList(data, "successIds", []interface{}{})
            for i := 0; IsLessThan(i, GetArrayLength(successIds)); i++ {
                var id interface{} = GetValue(successIds, i)
                AppendToArray(&allOrders,this.SafeOrder(map[string]interface{} {
                    "id": id,
                    "status": "canceled",
                }, market))
            }
            var failIds interface{} = this.SafeList(data, "failIds", []interface{}{})
            for i := 0; IsLessThan(i, GetArrayLength(failIds)); i++ {
                var id interface{} = GetValue(failIds, i)
                AppendToArray(&allOrders,this.SafeOrder(map[string]interface{} {
                    "id": id,
                    "status": "failed",
                }, market))
            }
        
            ch <- allOrders
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitmart#cancelAllOrders
 * @description cancel all open orders in a market
 * @see https://developer-pro.bitmart.com/en/spot/#cancel-all-orders
 * @see https://developer-pro.bitmart.com/en/spot/#new-batch-order-v4-signed
 * @see https://developer-pro.bitmart.com/en/futures/#cancel-all-orders-signed
 * @see https://developer-pro.bitmart.com/en/futuresv2/#cancel-all-orders-signed
 * @param {string} symbol unified market symbol of the market to cancel orders in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.side] *spot only* 'buy' or 'sell'
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bitmart) CancelAllOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes32678 := (<-this.LoadMarkets())
            PanicOnError(retRes32678)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            var response interface{} = nil
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("cancelAllOrders", market, params);
            typeVar = GetValue(typeVarparamsVariable,0);
            params = GetValue(typeVarparamsVariable,1)
            if IsTrue(IsEqual(typeVar, "spot")) {
                
        response = (<-this.PrivatePostSpotV4CancelAll(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(typeVar, "swap")) {
                if IsTrue(IsEqual(symbol, nil)) {
                    panic(ArgumentsRequired(Add(this.Id, " cancelAllOrders() requires a symbol argument")))
                }
                
        response = (<-this.PrivatePostContractPrivateCancelOrders(this.Extend(request, params)))
                PanicOnError(response)
            }
        
                //
            // spot
            //
            //     {
            //         "code": 1000,
            //         "trace":"886fb6ae-456b-4654-b4e0-d681ac05cea1",
            //         "message": "OK",
            //         "data": {}
            //     }
            //
            // swap
            //
            //     {
            //         "code": 1000,
            //         "message": "Ok",
            //         "trace": "7f9c94e10f9d4513bc08a7bfc2a5559a.70.16954131323145323"
            //     }
            //
        ch <- response
            return nil
        
            }()
            return ch
        }
func  (this *bitmart) FetchOrdersByStatus(status interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchOrdersByStatus() requires a symbol argument")))
            }
        
            retRes33108 := (<-this.LoadMarkets())
            PanicOnError(retRes33108)
            var market interface{} = this.Market(symbol)
            if !IsTrue(GetValue(market, "spot")) {
                panic(NotSupported(Add(Add(Add(this.Id, " fetchOrdersByStatus() does not support "), GetValue(market, "type")), " orders, only spot orders are accepted")))
            }
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "offset": 1,
                "N": 100,
            }
            if IsTrue(IsEqual(status, "open")) {
                AddElementToObject(request, "status", 9)
            } else if IsTrue(IsEqual(status, "closed")) {
                AddElementToObject(request, "status", 6)
            } else if IsTrue(IsEqual(status, "canceled")) {
                AddElementToObject(request, "status", 8)
            } else {
                AddElementToObject(request, "status", status)
            }
        
            response:= (<-this.PrivateGetSpotV3Orders(this.Extend(request, params)))
            PanicOnError(response)
            //
            // spot
            //
            //     {
            //         "message":"OK",
            //         "code":1000,
            //         "trace":"70e7d427-7436-4fb8-8cdd-97e1f5eadbe9",
            //         "data":{
            //             "current_page":1,
            //             "orders":[
            //                 {
            //                     "order_id":2147601241,
            //                     "symbol":"BTC_USDT",
            //                     "create_time":1591099963000,
            //                     "side":"sell",
            //                     "type":"limit",
            //                     "price":"9000.00",
            //                     "price_avg":"0.00",
            //                     "size":"1.00000",
            //                     "notional":"9000.00000000",
            //                     "filled_notional":"0.00000000",
            //                     "filled_size":"0.00000",
            //                     "status":"4"
            //                 }
            //             ]
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var orders interface{} = this.SafeList(data, "orders", []interface{}{})
        
            ch <- this.ParseOrders(orders, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitmart#fetchOpenOrders
 * @see https://developer-pro.bitmart.com/en/spot/#current-open-orders-v4-signed
 * @see https://developer-pro.bitmart.com/en/futures/#get-all-open-orders-keyed
 * @see https://developer-pro.bitmart.com/en/futures/#get-all-current-plan-orders-keyed
 * @description fetch all unfilled currently open orders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of open order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.marginMode] *spot* whether to fetch trades for margin orders or spot orders, defaults to spot orders (only isolated margin orders are supported)
 * @param {int} [params.until] *spot* the latest time in ms to fetch orders for
 * @param {string} [params.type] *swap* order type, 'limit' or 'market'
 * @param {string} [params.order_state] *swap* the order state, 'all' or 'partially_filled', default is 'all'
 * @param {string} [params.orderType] *swap only* 'limit', 'market', or 'trailing'
 * @param {boolean} [params.trailing] *swap only* set to true if you want to fetch trailing orders
 * @param {boolean} [params.trigger] *swap only* set to true if you want to fetch trigger orders
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bitmart) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes33848 := (<-this.LoadMarkets())
            PanicOnError(retRes33848)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            var typeVar interface{} = nil
            var response interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchOpenOrders", market, params);
            typeVar = GetValue(typeVarparamsVariable,0);
            params = GetValue(typeVarparamsVariable,1)
            if IsTrue(IsEqual(typeVar, "spot")) {
                if IsTrue(!IsEqual(limit, nil)) {
                    AddElementToObject(request, "limit", mathMin(limit, 200))
                }
                var marginMode interface{} = nil
                marginModeparamsVariable := this.HandleMarginModeAndParams("fetchOpenOrders", params);
                marginMode = GetValue(marginModeparamsVariable,0);
                params = GetValue(marginModeparamsVariable,1)
                if IsTrue(IsEqual(marginMode, "isolated")) {
                    AddElementToObject(request, "orderMode", "iso_margin")
                }
                if IsTrue(!IsEqual(since, nil)) {
                    AddElementToObject(request, "startTime", since)
                }
                var until interface{} = this.SafeInteger2(params, "until", "endTime")
                if IsTrue(!IsEqual(until, nil)) {
                    params = this.Omit(params, []interface{}{"endTime"})
                    AddElementToObject(request, "endTime", until)
                }
                
        response = (<-this.PrivatePostSpotV4QueryOpenOrders(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(typeVar, "swap")) {
                if IsTrue(!IsEqual(limit, nil)) {
                    AddElementToObject(request, "limit", mathMin(limit, 100))
                }
                var isTrigger interface{} = this.SafeBool2(params, "stop", "trigger")
                params = this.Omit(params, []interface{}{"stop", "trigger"})
                if IsTrue(isTrigger) {
                    
        response = (<-this.PrivateGetContractPrivateCurrentPlanOrder(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    var trailing interface{} = this.SafeBool(params, "trailing", false)
                    var orderType interface{} = this.SafeString(params, "orderType")
                    params = this.Omit(params, []interface{}{"orderType", "trailing"})
                    if IsTrue(trailing) {
                        orderType = "trailing"
                    }
                    if IsTrue(!IsEqual(orderType, nil)) {
                        AddElementToObject(request, "type", orderType)
                    }
                    
        response = (<-this.PrivateGetContractPrivateGetOpenOrders(this.Extend(request, params)))
                    PanicOnError(response)
                }
            } else {
                panic(NotSupported(Add(Add(Add(this.Id, " fetchOpenOrders() does not support "), typeVar), " orders, only spot and swap orders are accepted")))
            }
            //
            // spot
            //
            //     {
            //         "code": 1000,
            //         "message": "success",
            //         "data": [
            //             {
            //                 "orderId": "183299373022163211",
            //                 "clientOrderId": "183299373022163211",
            //                 "symbol": "BTC_USDT",
            //                 "side": "buy",
            //                 "orderMode": "spot",
            //                 "type": "limit",
            //                 "state": "new",
            //                 "price": "25000.00",
            //                 "priceAvg": "0.00",
            //                 "size": "0.00020",
            //                 "filledSize": "0.00000",
            //                 "notional": "5.00000000",
            //                 "filledNotional": "0.00000000",
            //                 "createTime": 1695703703338,
            //                 "updateTime": 1695703703359
            //             }
            //         ],
            //         "trace": "15f11d48e3234c81a2e786cr2e7a38e6.71.16957022303515933"
            //     }
            //
            // swap
            //
            //     {
            //         "code": 1000,
            //         "message": "Ok",
            //         "data": [
            //             {
            //                 "order_id": "230935812485489",
            //                 "client_order_id": "",
            //                 "price": "24000",
            //                 "size": "1",
            //                 "symbol": "BTCUSDT",
            //                 "state": 2,
            //                 "side": 1,
            //                 "type": "limit",
            //                 "leverage": "10",
            //                 "open_type": "isolated",
            //                 "deal_avg_price": "0",
            //                 "deal_size": "0",
            //                 "create_time": 1695702258629,
            //                 "update_time": 1695702258642
            //             }
            //         ],
            //         "trace": "7f9d94g10f9d4513bc08a7rfc3a5559a.71.16957022303515933"
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseOrders(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitmart#fetchClosedOrders
 * @see https://developer-pro.bitmart.com/en/spot/#account-orders-v4-signed
 * @see https://developer-pro.bitmart.com/en/futures/#get-order-history-keyed
 * @see https://developer-pro.bitmart.com/en/futuresv2/#get-order-history-keyed
 * @description fetches information on multiple closed orders made by the user
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest entry
 * @param {string} [params.marginMode] *spot only* 'cross' or 'isolated', for margin trading
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bitmart) FetchClosedOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes35098 := (<-this.LoadMarkets())
            PanicOnError(retRes35098)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchClosedOrders", market, params);
            typeVar = GetValue(typeVarparamsVariable,0);
            params = GetValue(typeVarparamsVariable,1)
            if IsTrue(!IsEqual(typeVar, "spot")) {
                if IsTrue(IsEqual(symbol, nil)) {
                    panic(ArgumentsRequired(Add(this.Id, " fetchClosedOrders() requires a symbol argument")))
                }
            }
            if IsTrue(!IsEqual(since, nil)) {
                var startTimeKey interface{} = Ternary(IsTrue((IsEqual(typeVar, "spot"))), "startTime", "start_time")
                AddElementToObject(request, startTimeKey, since)
            }
            var endTimeKey interface{} = Ternary(IsTrue((IsEqual(typeVar, "spot"))), "endTime", "end_time")
            var until interface{} = this.SafeInteger2(params, "until", endTimeKey)
            if IsTrue(!IsEqual(until, nil)) {
                params = this.Omit(params, []interface{}{"until"})
                AddElementToObject(request, endTimeKey, until)
            }
            var response interface{} = nil
            if IsTrue(IsEqual(typeVar, "spot")) {
                var marginMode interface{} = nil
                marginModeparamsVariable := this.HandleMarginModeAndParams("fetchClosedOrders", params);
                marginMode = GetValue(marginModeparamsVariable,0);
                params = GetValue(marginModeparamsVariable,1)
                if IsTrue(IsEqual(marginMode, "isolated")) {
                    AddElementToObject(request, "orderMode", "iso_margin")
                }
                
        response = (<-this.PrivatePostSpotV4QueryHistoryOrders(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PrivateGetContractPrivateOrderHistory(this.Extend(request, params)))
                PanicOnError(response)
            }
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseOrders(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitmart#fetchCanceledOrders
 * @description fetches information on multiple canceled orders made by the user
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] timestamp in ms of the earliest order, default is undefined
 * @param {int} [limit] max number of orders to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bitmart) FetchCanceledOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
                retRes355915 :=  (<-this.FetchOrdersByStatus("canceled", symbol, since, limit, params))
                PanicOnError(retRes355915)
                ch <- retRes355915
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitmart#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://developer-pro.bitmart.com/en/spot/#query-order-by-id-v4-signed
 * @see https://developer-pro.bitmart.com/en/spot/#query-order-by-clientorderid-v4-signed
 * @see https://developer-pro.bitmart.com/en/futures/#get-order-detail-keyed
 * @see https://developer-pro.bitmart.com/en/futuresv2/#get-order-detail-keyed
 * @param {string} id the id of the order
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.clientOrderId] *spot* fetch the order by client order id instead of order id
 * @param {string} [params.orderType] *swap only* 'limit', 'market', 'liquidate', 'bankruptcy', 'adl' or 'trailing'
 * @param {boolean} [params.trailing] *swap only* set to true if you want to fetch a trailing order
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bitmart) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes35798 := (<-this.LoadMarkets())
            PanicOnError(retRes35798)
            var request interface{} = map[string]interface{} {}
            var typeVar interface{} = nil
            var market interface{} = nil
            var response interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchOrder", market, params);
            typeVar = GetValue(typeVarparamsVariable,0);
            params = GetValue(typeVarparamsVariable,1)
            if IsTrue(IsEqual(typeVar, "spot")) {
                var clientOrderId interface{} = this.SafeString(params, "clientOrderId")
                if !IsTrue(clientOrderId) {
                    AddElementToObject(request, "orderId", id)
                }
                if IsTrue(!IsEqual(clientOrderId, nil)) {
                    
        response = (<-this.PrivatePostSpotV4QueryClientOrder(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.PrivatePostSpotV4QueryOrder(this.Extend(request, params)))
                    PanicOnError(response)
                }
            } else if IsTrue(IsEqual(typeVar, "swap")) {
                if IsTrue(IsEqual(symbol, nil)) {
                    panic(ArgumentsRequired(Add(this.Id, " fetchOrder() requires a symbol argument")))
                }
                var trailing interface{} = this.SafeBool(params, "trailing", false)
                var orderType interface{} = this.SafeString(params, "orderType")
                params = this.Omit(params, []interface{}{"orderType", "trailing"})
                if IsTrue(trailing) {
                    orderType = "trailing"
                }
                if IsTrue(!IsEqual(orderType, nil)) {
                    AddElementToObject(request, "type", orderType)
                }
                AddElementToObject(request, "symbol", GetValue(market, "id"))
                AddElementToObject(request, "order_id", id)
                
        response = (<-this.PrivateGetContractPrivateOrder(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            // spot
            //
            //     {
            //         "code": 1000,
            //         "message": "success",
            //         "data": {
            //             "orderId": "183347420821295423",
            //             "clientOrderId": "183347420821295423",
            //             "symbol": "BTC_USDT",
            //             "side": "buy",
            //             "orderMode": "spot",
            //             "type": "limit",
            //             "state": "new",
            //             "price": "24000.00",
            //             "priceAvg": "0.00",
            //             "size": "0.00022",
            //             "filledSize": "0.00000",
            //             "notional": "5.28000000",
            //             "filledNotional": "0.00000000",
            //             "createTime": 1695783014734,
            //             "updateTime": 1695783014762
            //         },
            //         "trace": "ce3e6422c8b44d5fag855348a68693ed.63.14957831547451715"
            //     }
            //
            // swap
            //
            //     {
            //         "code": 1000,
            //         "message": "Ok",
            //         "data": {
            //             "order_id": "230927283405028",
            //             "client_order_id": "",
            //             "price": "23000",
            //             "size": "1",
            //             "symbol": "BTCUSDT",
            //             "state": 2,
            //             "side": 1,
            //             "type": "limit",
            //             "leverage": "10",
            //             "open_type": "isolated",
            //             "deal_avg_price": "0",
            //             "deal_size": "0",
            //             "create_time": 1695783433600,
            //             "update_time": 1695783433613
            //         },
            //         "trace": "4cad855075664097af6ba5257c47605d.63.14957831547451715"
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseOrder(data, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitmart#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account
 * @see https://developer-pro.bitmart.com/en/spot/#deposit-address-keyed
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *bitmart) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes36798 := (<-this.LoadMarkets())
            PanicOnError(retRes36798)
            var currency interface{} = this.Currency(code)
            var network interface{} = nil
            networkparamsVariable := this.HandleNetworkCodeAndParams(params);
            network = GetValue(networkparamsVariable,0);
            params = GetValue(networkparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "currency": this.GetCurrencyIdFromCodeAndNetwork(code, network),
            }
        
            response:= (<-this.PrivateGetAccountV1DepositAddress(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "message": "OK",
            //        "code": 1000,
            //        "trace": "0e6edd79-f77f-4251-abe5-83ba75d06c1a",
            //        "data": {
            //            currency: 'ETH',
            //            chain: 'Ethereum',
            //            address: '0x99B5EEc2C520f86F0F62F05820d28D05D36EccCf',
            //            address_memo: ''
            //        }
            //    }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseDepositAddress(data, currency)
            return nil
        
            }()
            return ch
        }
func  (this *bitmart) ParseDepositAddress(depositAddress interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        currency: 'ETH',
    //        chain: 'Ethereum',
    //        address: '0x99B5EEc2C520f86F0F62F05820d28D05D36EccCf',
    //        address_memo: ''
    //    }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var currencyId interface{} = this.SafeString(depositAddress, "currency")
    var network interface{} = this.SafeString(depositAddress, "chain")
    if IsTrue(IsLessThan(GetIndexOf(currencyId, "NFT"), 0)) {
        var parts interface{} = Split(currencyId, "-")
        currencyId = this.SafeString(parts, 0)
        var secondPart interface{} = this.SafeString(parts, 1)
        if IsTrue(!IsEqual(secondPart, nil)) {
            network = secondPart
        }
    }
    var address interface{} = this.SafeString(depositAddress, "address")
    currency = this.SafeCurrency(currencyId, currency)
    this.CheckAddress(address)
    return map[string]interface{} {
        "info": depositAddress,
        "currency": this.SafeString(currency, "code"),
        "network": this.NetworkIdToCode(network),
        "address": address,
        "tag": this.SafeString(depositAddress, "address_memo"),
    }
}
/**
 * @method
 * @name bitmart#withdraw
 * @description make a withdrawal
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.network] the network name for this withdrawal
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *bitmart) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params);
            tag = GetValue(tagparamsVariable,0);
            params = GetValue(tagparamsVariable,1)
            this.CheckAddress(address)
        
            retRes37508 := (<-this.LoadMarkets())
            PanicOnError(retRes37508)
            var currency interface{} = this.Currency(code)
            var network interface{} = nil
            networkparamsVariable := this.HandleNetworkCodeAndParams(params);
            network = GetValue(networkparamsVariable,0);
            params = GetValue(networkparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "currency": this.GetCurrencyIdFromCodeAndNetwork(code, network),
                "amount": amount,
                "destination": "To Digital Address",
                "address": address,
            }
            if IsTrue(!IsEqual(tag, nil)) {
                AddElementToObject(request, "address_memo", tag)
            }
        
            response:= (<-this.PrivatePostAccountV1WithdrawApply(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": 1000,
            //         "trace":"886fb6ae-456b-4654-b4e0-d681ac05cea1",
            //         "message": "OK",
            //         "data": {
            //             "withdraw_id": "121212"
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var transaction interface{} = this.ParseTransaction(data, currency)
        
            ch <- this.Extend(transaction, map[string]interface{} {
                "code": code,
                "address": address,
                "tag": tag,
            })
            return nil
        
            }()
            return ch
        }
func  (this *bitmart) FetchTransactionsByType(typeVar interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes37848 := (<-this.LoadMarkets())
            PanicOnError(retRes37848)
            if IsTrue(IsEqual(limit, nil)) {
                limit = 50 // max 50
            }
            var request interface{} = map[string]interface{} {
                "operation_type": typeVar,
                "offset": 1,
                "N": limit,
            }
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "currency", GetValue(currency, "id"))
            }
        
            response:= (<-this.PrivateGetAccountV2DepositWithdrawHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "message":"OK",
            //         "code":1000,
            //         "trace":"142bf92a-fc50-4689-92b6-590886f90b97",
            //         "data":{
            //             "records":[
            //                 {
            //                     "withdraw_id":"1679952",
            //                     "deposit_id":"",
            //                     "operation_type":"withdraw",
            //                     "currency":"BMX",
            //                     "apply_time":1588867374000,
            //                     "arrival_amount":"59.000000000000",
            //                     "fee":"1.000000000000",
            //                     "status":0,
            //                     "address":"0xe57b69a8776b37860407965B73cdFFBDFe668Bb5",
            //                     "address_memo":"",
            //                     "tx_id":""
            //                 },
            //             ]
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var records interface{} = this.SafeList(data, "records", []interface{}{})
        
            ch <- this.ParseTransactions(records, currency, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitmart#fetchDeposit
 * @description fetch information on a deposit
 * @param {string} id deposit id
 * @param {string} code not used by bitmart fetchDeposit ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *bitmart) FetchDeposit(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes38388 := (<-this.LoadMarkets())
            PanicOnError(retRes38388)
            var request interface{} = map[string]interface{} {
                "id": id,
            }
        
            response:= (<-this.PrivateGetAccountV1DepositWithdrawDetail(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "message":"OK",
            //         "code":1000,
            //         "trace":"f7f74924-14da-42a6-b7f2-d3799dd9a612",
            //         "data":{
            //             "record":{
            //                 "withdraw_id":"",
            //                 "deposit_id":"1679952",
            //                 "operation_type":"deposit",
            //                 "currency":"BMX",
            //                 "apply_time":1588867374000,
            //                 "arrival_amount":"59.000000000000",
            //                 "fee":"1.000000000000",
            //                 "status":0,
            //                 "address":"0xe57b69a8776b37860407965B73cdFFBDFe668Bb5",
            //                 "address_memo":"",
            //                 "tx_id":""
            //             }
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var record interface{} = this.SafeDict(data, "record", map[string]interface{} {})
        
            ch <- this.ParseTransaction(record)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitmart#fetchDeposits
 * @description fetch all deposits made to an account
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *bitmart) FetchDeposits(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
                retRes388115 :=  (<-this.FetchTransactionsByType("deposit", code, since, limit, params))
                PanicOnError(retRes388115)
                ch <- retRes388115
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitmart#fetchWithdrawal
 * @description fetch data on a currency withdrawal via the withdrawal id
 * @param {string} id withdrawal id
 * @param {string} code not used by bitmart.fetchWithdrawal
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *bitmart) FetchWithdrawal(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes38948 := (<-this.LoadMarkets())
            PanicOnError(retRes38948)
            var request interface{} = map[string]interface{} {
                "id": id,
            }
        
            response:= (<-this.PrivateGetAccountV1DepositWithdrawDetail(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "message":"OK",
            //         "code":1000,
            //         "trace":"f7f74924-14da-42a6-b7f2-d3799dd9a612",
            //         "data":{
            //             "record":{
            //                 "withdraw_id":"1679952",
            //                 "deposit_id":"",
            //                 "operation_type":"withdraw",
            //                 "currency":"BMX",
            //                 "apply_time":1588867374000,
            //                 "arrival_amount":"59.000000000000",
            //                 "fee":"1.000000000000",
            //                 "status":0,
            //                 "address":"0xe57b69a8776b37860407965B73cdFFBDFe668Bb5",
            //                 "address_memo":"",
            //                 "tx_id":""
            //             }
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var record interface{} = this.SafeDict(data, "record", map[string]interface{} {})
        
            ch <- this.ParseTransaction(record)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitmart#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawals structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *bitmart) FetchWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
                retRes393715 :=  (<-this.FetchTransactionsByType("withdraw", code, since, limit, params))
                PanicOnError(retRes393715)
                ch <- retRes393715
                return nil
        
            }()
            return ch
        }
func  (this *bitmart) ParseTransactionStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "0": "pending",
        "1": "pending",
        "2": "pending",
        "3": "ok",
        "4": "canceled",
        "5": "failed",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *bitmart) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // withdraw
    //
    //     {
    //         "withdraw_id": "121212"
    //     }
    //
    // fetchDeposits, fetchWithdrawals, fetchWithdrawal
    //
    //     {
    //         "withdraw_id":"1679952",
    //         "deposit_id":"",
    //         "operation_type":"withdraw",
    //         "currency":"BMX",
    //         "apply_time":1588867374000,
    //         "arrival_amount":"59.000000000000",
    //         "fee":"1.000000000000",
    //         "status":0,
    //         "address":"0xe57b69a8776b37860407965B73cdFFBDFe668Bb5",
    //         "address_memo":"",
    //         "tx_id":""
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var id interface{} = nil
    var withdrawId interface{} = this.SafeString(transaction, "withdraw_id")
    var depositId interface{} = this.SafeString(transaction, "deposit_id")
    var typeVar interface{} = nil
    if IsTrue(IsTrue((!IsEqual(withdrawId, nil))) && IsTrue((!IsEqual(withdrawId, "")))) {
        typeVar = "withdraw"
        id = withdrawId
    } else if IsTrue(IsTrue((!IsEqual(depositId, nil))) && IsTrue((!IsEqual(depositId, "")))) {
        typeVar = "deposit"
        id = depositId
    }
    var amount interface{} = this.SafeNumber(transaction, "arrival_amount")
    var timestamp interface{} = this.SafeInteger(transaction, "apply_time")
    var currencyId interface{} = this.SafeString(transaction, "currency")
    var networkId interface{} = nil
    if IsTrue(IsLessThan(GetIndexOf(currencyId, "NFT"), 0)) {
        var parts interface{} = Split(currencyId, "-")
        currencyId = this.SafeString(parts, 0)
        networkId = this.SafeString(parts, 1)
    }
    var code interface{} = this.SafeCurrencyCode(currencyId, currency)
    var status interface{} = this.ParseTransactionStatus(this.SafeString(transaction, "status"))
    var feeCost interface{} = this.SafeNumber(transaction, "fee")
    var fee interface{} = nil
    if IsTrue(!IsEqual(feeCost, nil)) {
        fee = map[string]interface{} {
            "cost": feeCost,
            "currency": code,
        }
    }
    var txid interface{} = this.SafeString(transaction, "tx_id")
    var address interface{} = this.SafeString(transaction, "address")
    var tag interface{} = this.SafeString(transaction, "address_memo")
    return map[string]interface{} {
        "info": transaction,
        "id": id,
        "currency": code,
        "amount": amount,
        "network": this.NetworkIdToCode(networkId),
        "address": address,
        "addressFrom": nil,
        "addressTo": nil,
        "tag": tag,
        "tagFrom": nil,
        "tagTo": nil,
        "status": status,
        "type": typeVar,
        "updated": nil,
        "txid": txid,
        "internal": nil,
        "comment": nil,
        "timestamp": Ternary(IsTrue((!IsEqual(timestamp, 0))), timestamp, nil),
        "datetime": Ternary(IsTrue((!IsEqual(timestamp, 0))), this.Iso8601(timestamp), nil),
        "fee": fee,
    }
}
/**
 * @method
 * @name bitmart#repayIsolatedMargin
 * @description repay borrowed margin and interest
 * @see https://developer-pro.bitmart.com/en/spot/#margin-repay-isolated
 * @param {string} symbol unified market symbol
 * @param {string} code unified currency code of the currency to repay
 * @param {string} amount the amount to repay
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
 */
func  (this *bitmart) RepayIsolatedMargin(symbol interface{}, code interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes40458 := (<-this.LoadMarkets())
            PanicOnError(retRes40458)
            var market interface{} = this.Market(symbol)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "currency": GetValue(currency, "id"),
                "amount": this.CurrencyToPrecision(code, amount),
            }
        
            response:= (<-this.PrivatePostSpotV1MarginIsolatedRepay(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "message": "OK",
            //         "code": 1000,
            //         "trace": "b0a60b4c-e986-4b54-a190-8f7c05ddf685",
            //         "data": {
            //             "repay_id": "2afcc16d99bd4707818c5a355dc89bed"
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var transaction interface{} = this.ParseMarginLoan(data, currency)
        
            ch <- this.Extend(transaction, map[string]interface{} {
                "amount": amount,
                "symbol": symbol,
            })
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitmart#borrowIsolatedMargin
 * @description create a loan to borrow margin
 * @see https://developer-pro.bitmart.com/en/spot/#margin-borrow-isolated
 * @param {string} symbol unified market symbol
 * @param {string} code unified currency code of the currency to borrow
 * @param {string} amount the amount to borrow
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
 */
func  (this *bitmart) BorrowIsolatedMargin(symbol interface{}, code interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes40848 := (<-this.LoadMarkets())
            PanicOnError(retRes40848)
            var market interface{} = this.Market(symbol)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "currency": GetValue(currency, "id"),
                "amount": this.CurrencyToPrecision(code, amount),
            }
        
            response:= (<-this.PrivatePostSpotV1MarginIsolatedBorrow(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "message": "OK",
            //         "code": 1000,
            //         "trace": "e6fda683-181e-4e78-ac9c-b27c4c8ba035",
            //         "data": {
            //             "borrow_id": "629a7177a4ed4cf09869c6a4343b788c"
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var transaction interface{} = this.ParseMarginLoan(data, currency)
        
            ch <- this.Extend(transaction, map[string]interface{} {
                "amount": amount,
                "symbol": symbol,
            })
            return nil
        
            }()
            return ch
        }
func  (this *bitmart) ParseMarginLoan(info interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // borrowMargin
    //
    //     {
    //         "borrow_id": "629a7177a4ed4cf09869c6a4343b788c",
    //     }
    //
    // repayMargin
    //
    //     {
    //         "repay_id": "2afcc16d99bd4707818c5a355dc89bed",
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    return map[string]interface{} {
        "id": this.SafeString2(info, "borrow_id", "repay_id"),
        "currency": this.SafeCurrencyCode(nil, currency),
        "amount": nil,
        "symbol": nil,
        "timestamp": nil,
        "datetime": nil,
        "info": info,
    }
}
/**
 * @method
 * @name bitmart#fetchIsolatedBorrowRate
 * @description fetch the rate of interest to borrow a currency for margin trading
 * @see https://developer-pro.bitmart.com/en/spot/#get-trading-pair-borrowing-rate-and-amount-keyed
 * @param {string} symbol unified symbol of the market to fetch the borrow rate for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [isolated borrow rate structure]{@link https://github.com/ccxt/ccxt/wiki/Manual#isolated-borrow-rate-structure}
 */
func  (this *bitmart) FetchIsolatedBorrowRate(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes41468 := (<-this.LoadMarkets())
            PanicOnError(retRes41468)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.PrivateGetSpotV1MarginIsolatedPairs(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "message": "OK",
            //         "code": 1000,
            //         "trace": "0985a130-a5ae-4fc1-863f-4704e214f585",
            //         "data": {
            //             "symbols": [
            //                 {
            //                     "symbol": "BTC_USDT",
            //                     "max_leverage": "5",
            //                     "symbol_enabled": true,
            //                     "base": {
            //                         "currency": "BTC",
            //                         "daily_interest": "0.00055000",
            //                         "hourly_interest": "0.00002291",
            //                         "max_borrow_amount": "2.00000000",
            //                         "min_borrow_amount": "0.00000001",
            //                         "borrowable_amount": "0.00670810"
            //                     },
            //                     "quote": {
            //                         "currency": "USDT",
            //                         "daily_interest": "0.00055000",
            //                         "hourly_interest": "0.00002291",
            //                         "max_borrow_amount": "50000.00000000",
            //                         "min_borrow_amount": "0.00000001",
            //                         "borrowable_amount": "135.12575038"
            //                     }
            //                 }
            //             ]
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var symbols interface{} = this.SafeList(data, "symbols", []interface{}{})
            var borrowRate interface{} = this.SafeDict(symbols, 0, []interface{}{})
        
            ch <- this.ParseIsolatedBorrowRate(borrowRate, market)
            return nil
        
            }()
            return ch
        }
func  (this *bitmart) ParseIsolatedBorrowRate(info interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "symbol": "BTC_USDT",
    //         "max_leverage": "5",
    //         "symbol_enabled": true,
    //         "base": {
    //             "currency": "BTC",
    //             "daily_interest": "0.00055000",
    //             "hourly_interest": "0.00002291",
    //             "max_borrow_amount": "2.00000000",
    //             "min_borrow_amount": "0.00000001",
    //             "borrowable_amount": "0.00670810"
    //         },
    //         "quote": {
    //             "currency": "USDT",
    //             "daily_interest": "0.00055000",
    //             "hourly_interest": "0.00002291",
    //             "max_borrow_amount": "50000.00000000",
    //             "min_borrow_amount": "0.00000001",
    //             "borrowable_amount": "135.12575038"
    //         }
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(info, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var baseData interface{} = this.SafeDict(info, "base", map[string]interface{} {})
    var quoteData interface{} = this.SafeDict(info, "quote", map[string]interface{} {})
    var baseId interface{} = this.SafeString(baseData, "currency")
    var quoteId interface{} = this.SafeString(quoteData, "currency")
    return map[string]interface{} {
        "symbol": symbol,
        "base": this.SafeCurrencyCode(baseId),
        "baseRate": this.SafeNumber(baseData, "hourly_interest"),
        "quote": this.SafeCurrencyCode(quoteId),
        "quoteRate": this.SafeNumber(quoteData, "hourly_interest"),
        "period": 3600000,
        "timestamp": nil,
        "datetime": nil,
        "info": info,
    }
}
/**
 * @method
 * @name bitmart#fetchIsolatedBorrowRates
 * @description fetch the borrow interest rates of all currencies, currently only works for isolated margin
 * @see https://developer-pro.bitmart.com/en/spot/#get-trading-pair-borrowing-rate-and-amount-keyed
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [isolated borrow rate structures]{@link https://docs.ccxt.com/#/?id=isolated-borrow-rate-structure}
 */
func  (this *bitmart) FetchIsolatedBorrowRates(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes42428 := (<-this.LoadMarkets())
            PanicOnError(retRes42428)
        
            response:= (<-this.PrivateGetSpotV1MarginIsolatedPairs(params))
            PanicOnError(response)
            //
            //     {
            //         "message": "OK",
            //         "code": 1000,
            //         "trace": "0985a130-a5ae-4fc1-863f-4704e214f585",
            //         "data": {
            //             "symbols": [
            //                 {
            //                     "symbol": "BTC_USDT",
            //                     "max_leverage": "5",
            //                     "symbol_enabled": true,
            //                     "base": {
            //                         "currency": "BTC",
            //                         "daily_interest": "0.00055000",
            //                         "hourly_interest": "0.00002291",
            //                         "max_borrow_amount": "2.00000000",
            //                         "min_borrow_amount": "0.00000001",
            //                         "borrowable_amount": "0.00670810"
            //                     },
            //                     "quote": {
            //                         "currency": "USDT",
            //                         "daily_interest": "0.00055000",
            //                         "hourly_interest": "0.00002291",
            //                         "max_borrow_amount": "50000.00000000",
            //                         "min_borrow_amount": "0.00000001",
            //                         "borrowable_amount": "135.12575038"
            //                     }
            //                 }
            //             ]
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var symbols interface{} = this.SafeList(data, "symbols", []interface{}{})
        
            ch <- this.ParseIsolatedBorrowRates(symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitmart#transfer
 * @description transfer currency internally between wallets on the same account, currently only supports transfer between spot and margin
 * @see https://developer-pro.bitmart.com/en/spot/#margin-asset-transfer-signed
 * @see https://developer-pro.bitmart.com/en/futures/#transfer-signed
 * @see https://developer-pro.bitmart.com/en/futuresv2/#transfer-signed
 * @param {string} code unified currency code
 * @param {float} amount amount to transfer
 * @param {string} fromAccount account to transfer from
 * @param {string} toAccount account to transfer to
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func  (this *bitmart) Transfer(code interface{}, amount interface{}, fromAccount interface{}, toAccount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes42968 := (<-this.LoadMarkets())
            PanicOnError(retRes42968)
            var currency interface{} = this.Currency(code)
            var amountToPrecision interface{} = this.CurrencyToPrecision(code, amount)
            var request interface{} = map[string]interface{} {
                "amount": amountToPrecision,
                "currency": GetValue(currency, "id"),
            }
            var fromId interface{} = this.ConvertTypeToAccount(fromAccount)
            var toId interface{} = this.ConvertTypeToAccount(toAccount)
            if IsTrue(IsEqual(fromAccount, "spot")) {
                if IsTrue(IsEqual(toAccount, "margin")) {
                    AddElementToObject(request, "side", "in")
                    AddElementToObject(request, "symbol", toId)
                } else if IsTrue(IsEqual(toAccount, "swap")) {
                    AddElementToObject(request, "type", "spot_to_contract")
                }
            } else if IsTrue(IsEqual(toAccount, "spot")) {
                if IsTrue(IsEqual(fromAccount, "margin")) {
                    AddElementToObject(request, "side", "out")
                    AddElementToObject(request, "symbol", fromId)
                } else if IsTrue(IsEqual(fromAccount, "swap")) {
                    AddElementToObject(request, "type", "contract_to_spot")
                }
            } else {
                panic(ArgumentsRequired(Add(this.Id, " transfer() requires either fromAccount or toAccount to be spot")))
            }
            var response interface{} = nil
            if IsTrue(IsTrue((IsEqual(fromAccount, "margin"))) || IsTrue((IsEqual(toAccount, "margin")))) {
                
        response = (<-this.PrivatePostSpotV1MarginIsolatedTransfer(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(IsTrue((IsEqual(fromAccount, "swap"))) || IsTrue((IsEqual(toAccount, "swap")))) {
                
        response = (<-this.PrivatePostAccountV1TransferContract(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            // margin
            //
            //     {
            //         "message": "OK",
            //         "code": 1000,
            //         "trace": "b26cecec-ef5a-47d9-9531-2bd3911d3d55",
            //         "data": {
            //             "transfer_id": "ca90d97a621e47d49774f19af6b029f5"
            //         }
            //     }
            //
            // swap
            //
            //     {
            //         "message": "OK",
            //         "code": 1000,
            //         "trace": "4cad858074667097ac6ba5257c57305d.68.16953302431189455",
            //         "data": {
            //             "currency": "USDT",
            //             "amount": "5"
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.Extend(this.ParseTransfer(data, currency), map[string]interface{} {
                "status": this.ParseTransferStatus(this.SafeString2(response, "code", "message")),
            })
            return nil
        
            }()
            return ch
        }
func  (this *bitmart) ParseTransferStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "1000": "ok",
        "OK": "ok",
        "FINISHED": "ok",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *bitmart) ParseTransferToAccount(typeVar interface{}) interface{}  {
    var types interface{} = map[string]interface{} {
        "contract_to_spot": "spot",
        "spot_to_contract": "swap",
    }
    return this.SafeString(types, typeVar, typeVar)
}
func  (this *bitmart) ParseTransferFromAccount(typeVar interface{}) interface{}  {
    var types interface{} = map[string]interface{} {
        "contract_to_spot": "swap",
        "spot_to_contract": "spot",
    }
    return this.SafeString(types, typeVar, typeVar)
}
func  (this *bitmart) ParseTransfer(transfer interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // margin
    //
    //     {
    //         "transfer_id": "ca90d97a621e47d49774f19af6b029f5"
    //     }
    //
    // swap
    //
    //     {
    //         "currency": "USDT",
    //         "amount": "5"
    //     }
    //
    // fetchTransfers
    //
    //     {
    //         "transfer_id": "902463535961567232",
    //         "currency": "USDT",
    //         "amount": "5",
    //         "type": "contract_to_spot",
    //         "state": "FINISHED",
    //         "timestamp": 1695330539565
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var currencyId interface{} = this.SafeString(transfer, "currency")
    var timestamp interface{} = this.SafeInteger(transfer, "timestamp")
    return map[string]interface{} {
        "id": this.SafeString(transfer, "transfer_id"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "currency": this.SafeCurrencyCode(currencyId, currency),
        "amount": this.SafeNumber(transfer, "amount"),
        "fromAccount": this.ParseTransferFromAccount(this.SafeString(transfer, "type")),
        "toAccount": this.ParseTransferToAccount(this.SafeString(transfer, "type")),
        "status": this.ParseTransferStatus(this.SafeString(transfer, "state")),
    }
}
/**
 * @method
 * @name bitmart#fetchTransfers
 * @description fetch a history of internal transfers made on an account, only transfers between spot and swap are supported
 * @see https://developer-pro.bitmart.com/en/futures/#get-transfer-list-signed
 * @param {string} code unified currency code of the currency transferred
 * @param {int} [since] the earliest time in ms to fetch transfers for
 * @param {int} [limit] the maximum number of transfer structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.page] the required number of pages, default is 1, max is 1000
 * @param {int} [params.until] the latest time in ms to fetch transfers for
 * @returns {object[]} a list of [transfer structures]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func  (this *bitmart) FetchTransfers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes44378 := (<-this.LoadMarkets())
            PanicOnError(retRes44378)
            if IsTrue(IsEqual(limit, nil)) {
                limit = 10
            }
            var request interface{} = map[string]interface{} {
                "page": this.SafeInteger(params, "page", 1),
                "limit": limit,
            }
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "currency", GetValue(currency, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "time_start", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            var until interface{} = this.SafeInteger(params, "until") // unified in milliseconds
            var endTime interface{} = this.SafeInteger(params, "time_end", until) // exchange-specific in milliseconds
            params = this.Omit(params, []interface{}{"until"})
            if IsTrue(!IsEqual(endTime, nil)) {
                AddElementToObject(request, "time_end", endTime)
            }
        
            response:= (<-this.PrivatePostAccountV1TransferContractList(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "message": "OK",
            //         "code": 1000,
            //         "trace": "7f9d93e10f9g4513bc08a7btc2a5559a.69.16953325693032193",
            //         "data": {
            //             "records": [
            //                 {
            //                     "transfer_id": "902463535961567232",
            //                     "currency": "USDT",
            //                     "amount": "5",
            //                     "type": "contract_to_spot",
            //                     "state": "FINISHED",
            //                     "timestamp": 1695330539565
            //                 },
            //             ]
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var records interface{} = this.SafeList(data, "records", []interface{}{})
        
            ch <- this.ParseTransfers(records, currency, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitmart#fetchBorrowInterest
 * @description fetch the interest owed by the user for borrowing currency for margin trading
 * @see https://developer-pro.bitmart.com/en/spot/#get-borrow-record-isolated
 * @param {string} code unified currency code
 * @param {string} symbol unified market symbol when fetch interest in isolated markets
 * @param {int} [since] the earliest time in ms to fetch borrrow interest for
 * @param {int} [limit] the maximum number of structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [borrow interest structures]{@link https://docs.ccxt.com/#/?id=borrow-interest-structure}
 */
func  (this *bitmart) FetchBorrowInterest(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            symbol := GetArg(optionalArgs, 1, nil)
            _ = symbol
            since := GetArg(optionalArgs, 2, nil)
            _ = since
            limit := GetArg(optionalArgs, 3, nil)
            _ = limit
            params := GetArg(optionalArgs, 4, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchBorrowInterest() requires a symbol argument")))
            }
        
            retRes45038 := (<-this.LoadMarkets())
            PanicOnError(retRes45038)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "N", limit)
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_time", since)
            }
        
            response:= (<-this.PrivateGetSpotV1MarginIsolatedBorrowRecord(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "message": "OK",
            //         "code": 1000,
            //         "trace": "8ea27a2a-4aba-49fa-961d-43a0137b0ef3",
            //         "data": {
            //             "records": [
            //                 {
            //                     "borrow_id": "1659045283903rNvJnuRTJNL5J53n",
            //                     "symbol": "BTC_USDT",
            //                     "currency": "USDT",
            //                     "borrow_amount": "100.00000000",
            //                     "daily_interest": "0.00055000",
            //                     "hourly_interest": "0.00002291",
            //                     "interest_amount": "0.00229166",
            //                     "create_time": 1659045284000
            //                 },
            //             ]
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var rows interface{} = this.SafeList(data, "records", []interface{}{})
            var interest interface{} = this.ParseBorrowInterests(rows, market)
        
            ch <- this.FilterByCurrencySinceLimit(interest, code, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *bitmart) ParseBorrowInterest(info interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "borrow_id": "1657664327844Lk5eJJugXmdHHZoe",
    //         "symbol": "BTC_USDT",
    //         "currency": "USDT",
    //         "borrow_amount": "20.00000000",
    //         "daily_interest": "0.00055000",
    //         "hourly_interest": "0.00002291",
    //         "interest_amount": "0.00045833",
    //         "create_time": 1657664329000
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(info, "symbol")
    market = this.SafeMarket(marketId, market)
    var timestamp interface{} = this.SafeInteger(info, "create_time")
    return map[string]interface{} {
        "info": info,
        "symbol": this.SafeString(market, "symbol"),
        "currency": this.SafeCurrencyCode(this.SafeString(info, "currency")),
        "interest": this.SafeNumber(info, "interest_amount"),
        "interestRate": this.SafeNumber(info, "hourly_interest"),
        "amountBorrowed": this.SafeNumber(info, "borrow_amount"),
        "marginMode": "isolated",
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
    }
}
/**
 * @method
 * @name bitmart#fetchOpenInterest
 * @description Retrieves the open interest of a currency
 * @see https://developer-pro.bitmart.com/en/futuresv2/#get-futures-openinterest
 * @param {string} symbol Unified CCXT market symbol
 * @param {object} [params] exchange specific parameters
 * @returns {object} an open interest structure{@link https://docs.ccxt.com/#/?id=open-interest-structure}
 */
func  (this *bitmart) FetchOpenInterest(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes45818 := (<-this.LoadMarkets())
            PanicOnError(retRes45818)
            var market interface{} = this.Market(symbol)
            if !IsTrue(GetValue(market, "contract")) {
                panic(BadRequest(Add(this.Id, " fetchOpenInterest() supports contract markets only")))
            }
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetContractPublicOpenInterest(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": 1000,
            //         "message": "Ok",
            //         "data": {
            //             "timestamp": 1694657502415,
            //             "symbol": "BTCUSDT",
            //             "open_interest": "265231.721368593081729069",
            //             "open_interest_value": "7006353.83988919"
            //         },
            //         "trace": "7f9c94e10f9d4513bc08a7bfc2a5559a.72.16946575108274991"
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseOpenInterest(data, market)
            return nil
        
            }()
            return ch
        }
func  (this *bitmart) ParseOpenInterest(interest interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "timestamp": 1694657502415,
    //         "symbol": "BTCUSDT",
    //         "open_interest": "265231.721368593081729069",
    //         "open_interest_value": "7006353.83988919"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger(interest, "timestamp")
    var id interface{} = this.SafeString(interest, "symbol")
    return this.SafeOpenInterest(map[string]interface{} {
        "symbol": this.SafeSymbol(id, market),
        "openInterestAmount": this.SafeNumber(interest, "open_interest"),
        "openInterestValue": this.SafeNumber(interest, "open_interest_value"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "info": interest,
    }, market)
}
/**
 * @method
 * @name bitmart#setLeverage
 * @description set the level of leverage for a market
 * @see https://developer-pro.bitmart.com/en/futures/#submit-leverage-signed
 * @see https://developer-pro.bitmart.com/en/futuresv2/#submit-leverage-signed
 * @param {float} leverage the rate of leverage
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] 'isolated' or 'cross'
 * @returns {object} response from the exchange
 */
func  (this *bitmart) SetLeverage(leverage interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " setLeverage() requires a symbol argument")))
            }
            var marginMode interface{} = nil
            marginModeparamsVariable := this.HandleMarginModeAndParams("setLeverage", params);
            marginMode = GetValue(marginModeparamsVariable,0);
            params = GetValue(marginModeparamsVariable,1)
            this.CheckRequiredArgument("setLeverage", marginMode, "marginMode", []interface{}{"isolated", "cross"})
        
            retRes46478 := (<-this.LoadMarkets())
            PanicOnError(retRes46478)
            var market interface{} = this.Market(symbol)
            if !IsTrue(GetValue(market, "swap")) {
                panic(BadSymbol(Add(this.Id, " setLeverage() supports swap contracts only")))
            }
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "leverage": ToString(leverage),
                "open_type": marginMode,
            }
        
                retRes465715 :=  (<-this.PrivatePostContractPrivateSubmitLeverage(this.Extend(request, params)))
                PanicOnError(retRes465715)
                ch <- retRes465715
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitmart#fetchFundingRate
 * @description fetch the current funding rate
 * @see https://developer-pro.bitmart.com/en/futuresv2/#get-current-funding-rate
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
 */
func  (this *bitmart) FetchFundingRate(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes46708 := (<-this.LoadMarkets())
            PanicOnError(retRes46708)
            var market interface{} = this.Market(symbol)
            if !IsTrue(GetValue(market, "swap")) {
                panic(BadSymbol(Add(this.Id, " fetchFundingRate() supports swap contracts only")))
            }
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetContractPublicFundingRate(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": 1000,
            //         "message": "Ok",
            //         "data": {
            //             "timestamp": 1695184410697,
            //             "symbol": "BTCUSDT",
            //             "rate_value": "-0.00002614",
            //             "expected_rate": "-0.00002"
            //         },
            //         "trace": "4cad855074654097ac7ba5257c47305d.54.16951844206655589"
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseFundingRate(data, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitmart#fetchFundingRateHistory
 * @description fetches historical funding rate prices
 * @see https://developer-pro.bitmart.com/en/futuresv2/#get-funding-rate-history
 * @param {string} symbol unified symbol of the market to fetch the funding rate history for
 * @param {int} [since] not sent to exchange api, exchange api always returns the most recent data, only used to filter exchange response
 * @param {int} [limit] the maximum amount of funding rate structures to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
 */
func  (this *bitmart) FetchFundingRateHistory(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchFundingRateHistory() requires a symbol argument")))
            }
        
            retRes47118 := (<-this.LoadMarkets())
            PanicOnError(retRes47118)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.PublicGetContractPublicFundingRateHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": 1000,
            //         "message": "Ok",
            //         "data": {
            //             "list": [
            //                 {
            //                     "symbol": "BTCUSDT",
            //                     "funding_rate": "0.000091412174",
            //                     "funding_time": "1734336000000"
            //                 },
            //             ]
            //         },
            //         "trace": "fg73d949fgfdf6a40c8fc7f5ae6738.54.345345345345"
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var result interface{} = this.SafeList(data, "list", []interface{}{})
            var rates interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(result)); i++ {
                var entry interface{} = GetValue(result, i)
                var marketId interface{} = this.SafeString(entry, "symbol")
                var symbolInner interface{} = this.SafeSymbol(marketId, market, "-", "swap")
                var timestamp interface{} = this.SafeInteger(entry, "funding_time")
                AppendToArray(&rates,map[string]interface{} {
                    "info": entry,
                    "symbol": symbolInner,
                    "fundingRate": this.SafeNumber(entry, "funding_rate"),
                    "timestamp": timestamp,
                    "datetime": this.Iso8601(timestamp),
                })
            }
            var sorted interface{} = this.SortBy(rates, "timestamp")
        
            ch <- this.FilterBySymbolSinceLimit(sorted, GetValue(market, "symbol"), since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *bitmart) ParseFundingRate(contract interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "timestamp": 1695184410697,
    //         "symbol": "BTCUSDT",
    //         "rate_value": "-0.00002614",
    //         "expected_rate": "-0.00002"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(contract, "symbol")
    var timestamp interface{} = this.SafeInteger(contract, "timestamp")
    return map[string]interface{} {
        "info": contract,
        "symbol": this.SafeSymbol(marketId, market),
        "markPrice": nil,
        "indexPrice": nil,
        "interestRate": nil,
        "estimatedSettlePrice": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "fundingRate": this.SafeNumber(contract, "expected_rate"),
        "fundingTimestamp": nil,
        "fundingDatetime": nil,
        "nextFundingRate": nil,
        "nextFundingTimestamp": nil,
        "nextFundingDatetime": nil,
        "previousFundingRate": this.SafeNumber(contract, "rate_value"),
        "previousFundingTimestamp": nil,
        "previousFundingDatetime": nil,
        "interval": nil,
    }
}
/**
 * @method
 * @name bitmart#fetchPosition
 * @description fetch data on a single open contract trade position
 * @see https://developer-pro.bitmart.com/en/futures/#get-current-position-keyed
 * @see https://developer-pro.bitmart.com/en/futuresv2/#get-current-position-risk-details-keyed
 * @param {string} symbol unified market symbol of the market the position is held in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *bitmart) FetchPosition(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes48008 := (<-this.LoadMarkets())
            PanicOnError(retRes48008)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.PrivateGetContractPrivatePosition(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": 1000,
            //         "message": "Ok",
            //         "data": [
            //             {
            //                 "symbol": "BTCUSDT",
            //                 "leverage": "10",
            //                 "timestamp": 1696392515269,
            //                 "current_fee": "0.0014250028",
            //                 "open_timestamp": 1696392256998,
            //                 "current_value": "27.4039",
            //                 "mark_price": "27.4039",
            //                 "position_value": "27.4079",
            //                 "position_cross": "3.75723474",
            //                 "maintenance_margin": "0.1370395",
            //                 "close_vol": "0",
            //                 "close_avg_price": "0",
            //                 "open_avg_price": "27407.9",
            //                 "entry_price": "27407.9",
            //                 "current_amount": "1",
            //                 "unrealized_value": "-0.004",
            //                 "realized_value": "-0.01644474",
            //                 "position_type": 1
            //             }
            //         ],
            //         "trace":"4cad855074664097ac5ba5257c47305d.67.16963925142065945"
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
            var first interface{} = this.SafeDict(data, 0, map[string]interface{} {})
        
            ch <- this.ParsePosition(first, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitmart#fetchPositions
 * @description fetch all open contract positions
 * @see https://developer-pro.bitmart.com/en/futures/#get-current-position-keyed
 * @see https://developer-pro.bitmart.com/en/futuresv2/#get-current-position-risk-details-keyed
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structures]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *bitmart) FetchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes48518 := (<-this.LoadMarkets())
            PanicOnError(retRes48518)
            var market interface{} = nil
            var symbolsLength interface{} = nil
            if IsTrue(!IsEqual(symbols, nil)) {
                symbolsLength = GetArrayLength(symbols)
                var first interface{} = this.SafeString(symbols, 0)
                market = this.Market(first)
            }
            var request interface{} = map[string]interface{} {}
            if IsTrue(IsEqual(symbolsLength, 1)) {
                // only supports symbols as undefined or sending one symbol
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
        
            response:= (<-this.PrivateGetContractPrivatePosition(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": 1000,
            //         "message": "Ok",
            //         "data": [
            //             {
            //                 "symbol": "BTCUSDT",
            //                 "leverage": "10",
            //                 "timestamp": 1696392515269,
            //                 "current_fee": "0.0014250028",
            //                 "open_timestamp": 1696392256998,
            //                 "current_value": "27.4039",
            //                 "mark_price": "27.4039",
            //                 "position_value": "27.4079",
            //                 "position_cross": "3.75723474",
            //                 "maintenance_margin": "0.1370395",
            //                 "close_vol": "0",
            //                 "close_avg_price": "0",
            //                 "open_avg_price": "27407.9",
            //                 "entry_price": "27407.9",
            //                 "current_amount": "1",
            //                 "unrealized_value": "-0.004",
            //                 "realized_value": "-0.01644474",
            //                 "position_type": 1
            //             },
            //         ],
            //         "trace":"4cad855074664097ac5ba5257c47305d.67.16963925142065945"
            //     }
            //
            var positions interface{} = this.SafeList(response, "data", []interface{}{})
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(positions)); i++ {
                AppendToArray(&result,this.ParsePosition(GetValue(positions, i)))
            }
            symbols = this.MarketSymbols(symbols)
        
            ch <- this.FilterByArrayPositions(result, "symbol", symbols, false)
            return nil
        
            }()
            return ch
        }
func  (this *bitmart) ParsePosition(position interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "symbol": "BTCUSDT",
    //         "leverage": "10",
    //         "timestamp": 1696392515269,
    //         "current_fee": "0.0014250028",
    //         "open_timestamp": 1696392256998,
    //         "current_value": "27.4039",
    //         "mark_price": "27.4039",
    //         "position_value": "27.4079",
    //         "position_cross": "3.75723474",
    //         "maintenance_margin": "0.1370395",
    //         "close_vol": "0",
    //         "close_avg_price": "0",
    //         "open_avg_price": "27407.9",
    //         "entry_price": "27407.9",
    //         "current_amount": "1",
    //         "unrealized_value": "-0.004",
    //         "realized_value": "-0.01644474",
    //         "position_type": 1
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(position, "symbol")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = GetValue(market, "symbol")
    var timestamp interface{} = this.SafeInteger(position, "timestamp")
    var side interface{} = this.SafeInteger(position, "position_type")
    var maintenanceMargin interface{} = this.SafeString(position, "maintenance_margin")
    var notional interface{} = this.SafeString(position, "current_value")
    var collateral interface{} = this.SafeString(position, "position_cross")
    var maintenanceMarginPercentage interface{} = Precise.StringDiv(maintenanceMargin, notional)
    var marginRatio interface{} = Precise.StringDiv(maintenanceMargin, collateral)
    return this.SafePosition(map[string]interface{} {
        "info": position,
        "id": nil,
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastUpdateTimestamp": nil,
        "hedged": nil,
        "side": Ternary(IsTrue((IsEqual(side, 1))), "long", "short"),
        "contracts": this.SafeNumber(position, "current_amount"),
        "contractSize": this.SafeNumber(market, "contractSize"),
        "entryPrice": this.SafeNumber(position, "entry_price"),
        "markPrice": this.SafeNumber(position, "mark_price"),
        "lastPrice": nil,
        "notional": this.ParseNumber(notional),
        "leverage": this.SafeNumber(position, "leverage"),
        "collateral": this.ParseNumber(collateral),
        "initialMargin": nil,
        "initialMarginPercentage": nil,
        "maintenanceMargin": this.ParseNumber(maintenanceMargin),
        "maintenanceMarginPercentage": this.ParseNumber(maintenanceMarginPercentage),
        "unrealizedPnl": this.SafeNumber(position, "unrealized_value"),
        "realizedPnl": this.SafeNumber(position, "realized_value"),
        "liquidationPrice": nil,
        "marginMode": nil,
        "percentage": nil,
        "marginRatio": this.ParseNumber(marginRatio),
        "stopLossPrice": nil,
        "takeProfitPrice": nil,
    })
}
/**
 * @method
 * @name bitmart#fetchMyLiquidations
 * @description retrieves the users liquidated positions
 * @see https://developer-pro.bitmart.com/en/futures/#get-order-history-keyed
 * @param {string} symbol unified CCXT market symbol
 * @param {int} [since] the earliest time in ms to fetch liquidations for
 * @param {int} [limit] the maximum number of liquidation structures to retrieve
 * @param {object} [params] exchange specific parameters for the bitmart api endpoint
 * @param {int} [params.until] timestamp in ms of the latest liquidation
 * @returns {object} an array of [liquidation structures]{@link https://docs.ccxt.com/#/?id=liquidation-structure}
 */
func  (this *bitmart) FetchMyLiquidations(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchMyLiquidations() requires a symbol argument")))
            }
        
            retRes49848 := (<-this.LoadMarkets())
            PanicOnError(retRes49848)
            var market interface{} = this.Market(symbol)
            if !IsTrue(GetValue(market, "swap")) {
                panic(NotSupported(Add(this.Id, " fetchMyLiquidations() supports swap markets only")))
            }
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_time", since)
            }
            requestparamsVariable := this.HandleUntilOption("end_time", request, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
        
            response:= (<-this.PrivateGetContractPrivateOrderHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": 1000,
            //         "message": "Ok",
            //         "data": [
            //             {
            //                 "order_id": "231007865458273",
            //                 "client_order_id": "",
            //                 "price": "27407.9",
            //                 "size": "1",
            //                 "symbol": "BTCUSDT",
            //                 "state": 4,
            //                 "side": 3,
            //                 "type": "liquidate",
            //                 "leverage": "10",
            //                 "open_type": "isolated",
            //                 "deal_avg_price": "27422.6",
            //                 "deal_size": "1",
            //                 "create_time": 1696405864011,
            //                 "update_time": 1696405864045
            //             },
            //         ],
            //         "trace": "4cad855074664097ac6ba4257c47305d.71.16965658195443021"
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
                var entry interface{} = GetValue(data, i)
                var checkLiquidation interface{} = this.SafeString(entry, "type")
                if IsTrue(IsEqual(checkLiquidation, "liquidate")) {
                    AppendToArray(&result,entry)
                }
            }
        
            ch <- this.ParseLiquidations(result, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *bitmart) ParseLiquidation(liquidation interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "order_id": "231007865458273",
    //         "client_order_id": "",
    //         "price": "27407.9",
    //         "size": "1",
    //         "symbol": "BTCUSDT",
    //         "state": 4,
    //         "side": 3,
    //         "type": "market",
    //         "leverage": "10",
    //         "open_type": "isolated",
    //         "deal_avg_price": "27422.6",
    //         "deal_size": "1",
    //         "create_time": 1696405864011,
    //         "update_time": 1696405864045
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(liquidation, "symbol")
    var timestamp interface{} = this.SafeInteger(liquidation, "update_time")
    var contractsString interface{} = this.SafeString(liquidation, "deal_size")
    var contractSizeString interface{} = this.SafeString(market, "contractSize")
    var priceString interface{} = this.SafeString(liquidation, "deal_avg_price")
    var baseValueString interface{} = Precise.StringMul(contractsString, contractSizeString)
    var quoteValueString interface{} = Precise.StringMul(baseValueString, priceString)
    return this.SafeLiquidation(map[string]interface{} {
        "info": liquidation,
        "symbol": this.SafeSymbol(marketId, market),
        "contracts": this.ParseNumber(contractsString),
        "contractSize": this.ParseNumber(contractSizeString),
        "price": this.ParseNumber(priceString),
        "baseValue": this.ParseNumber(baseValueString),
        "quoteValue": this.ParseNumber(quoteValueString),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
    })
}
/**
 * @method
 * @name bitmart#editOrder
 * @description edits an open order
 * @see https://developer-pro.bitmart.com/en/futuresv2/#modify-plan-order-signed
 * @see https://developer-pro.bitmart.com/en/futuresv2/#modify-tp-sl-order-signed
 * @see https://developer-pro.bitmart.com/en/futuresv2/#modify-preset-plan-order-signed
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market to edit an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} [amount] how much you want to trade in units of the base currency
 * @param {float} [price] the price to fulfill the order, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.triggerPrice] *swap only* the price to trigger a stop order
 * @param {string} [params.stopLossPrice] *swap only* the price to trigger a stop-loss order
 * @param {string} [params.takeProfitPrice] *swap only* the price to trigger a take-profit order
 * @param {string} [params.stopLoss.triggerPrice] *swap only* the price to trigger a preset stop-loss order
 * @param {string} [params.takeProfit.triggerPrice] *swap only* the price to trigger a preset take-profit order
 * @param {string} [params.clientOrderId] client order id of the order
 * @param {int} [params.price_type] *swap only* 1: last price, 2: fair price, default is 1
 * @param {int} [params.plan_category] *swap tp/sl only* 1: tp/sl, 2: position tp/sl, default is 1
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bitmart) EditOrder(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    amount := GetArg(optionalArgs, 0, nil)
            _ = amount
            price := GetArg(optionalArgs, 1, nil)
            _ = price
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes50988 := (<-this.LoadMarkets())
            PanicOnError(retRes50988)
            var market interface{} = this.Market(symbol)
            if !IsTrue(GetValue(market, "swap")) {
                panic(NotSupported(Add(Add(Add(this.Id, " editOrder() does not support "), GetValue(market, "type")), " markets, only swap markets are supported")))
            }
            var stopLossPrice interface{} = this.SafeString(params, "stopLossPrice")
            var takeProfitPrice interface{} = this.SafeString(params, "takeProfitPrice")
            var triggerPrice interface{} = this.SafeStringN(params, []interface{}{"triggerPrice", "stopPrice", "trigger_price"})
            var stopLoss interface{} = this.SafeDict(params, "stopLoss", map[string]interface{} {})
            var takeProfit interface{} = this.SafeDict(params, "takeProfit", map[string]interface{} {})
            var presetStopLoss interface{} = this.SafeString(stopLoss, "triggerPrice")
            var presetTakeProfit interface{} = this.SafeString(takeProfit, "triggerPrice")
            var isTriggerOrder interface{} = !IsEqual(triggerPrice, nil)
            var isStopLoss interface{} = !IsEqual(stopLossPrice, nil)
            var isTakeProfit interface{} = !IsEqual(takeProfitPrice, nil)
            var isPresetStopLoss interface{} = !IsEqual(presetStopLoss, nil)
            var isPresetTakeProfit interface{} = !IsEqual(presetTakeProfit, nil)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var clientOrderId interface{} = this.SafeString(params, "clientOrderId")
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                params = this.Omit(params, "clientOrderId")
                AddElementToObject(request, "client_order_id", clientOrderId)
            }
            if IsTrue(!IsEqual(id, nil)) {
                AddElementToObject(request, "order_id", id)
            }
            params = this.Omit(params, []interface{}{"triggerPrice", "stopPrice", "stopLossPrice", "takeProfitPrice", "stopLoss", "takeProfit"})
            var response interface{} = nil
            if IsTrue(IsTrue(IsTrue(isTriggerOrder) || IsTrue(isStopLoss)) || IsTrue(isTakeProfit)) {
                AddElementToObject(request, "price_type", this.SafeInteger(params, "price_type", 1))
                if IsTrue(!IsEqual(price, nil)) {
                    AddElementToObject(request, "executive_price", this.PriceToPrecision(symbol, price))
                }
            }
            if IsTrue(isTriggerOrder) {
                AddElementToObject(request, "type", typeVar)
                AddElementToObject(request, "trigger_price", this.PriceToPrecision(symbol, triggerPrice))
                
        response = (<-this.PrivatePostContractPrivateModifyPlanOrder(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(IsTrue(isStopLoss) || IsTrue(isTakeProfit)) {
                AddElementToObject(request, "category", typeVar)
                if IsTrue(isStopLoss) {
                    AddElementToObject(request, "trigger_price", this.PriceToPrecision(symbol, stopLossPrice))
                } else {
                    AddElementToObject(request, "trigger_price", this.PriceToPrecision(symbol, takeProfitPrice))
                }
                
        response = (<-this.PrivatePostContractPrivateModifyTpSlOrder(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(IsTrue(isPresetStopLoss) || IsTrue(isPresetTakeProfit)) {
                if IsTrue(isPresetStopLoss) {
                    AddElementToObject(request, "preset_stop_loss_price_type", this.SafeInteger(params, "price_type", 1))
                    AddElementToObject(request, "preset_stop_loss_price", this.PriceToPrecision(symbol, presetStopLoss))
                } else {
                    AddElementToObject(request, "preset_take_profit_price_type", this.SafeInteger(params, "price_type", 1))
                    AddElementToObject(request, "preset_take_profit_price", this.PriceToPrecision(symbol, presetTakeProfit))
                }
                
        response = (<-this.PrivatePostContractPrivateModifyPresetPlanOrder(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                panic(NotSupported(Add(this.Id, " editOrder() only supports trigger, stop loss and take profit orders")))
            }
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseOrder(data, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitmart#fetchLedger
 * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
 * @see https://developer-pro.bitmart.com/en/futuresv2/#get-transaction-history-keyed
 * @param {string} [code] unified currency code
 * @param {int} [since] timestamp in ms of the earliest ledger entry
 * @param {int} [limit] max number of ledger entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest ledger entry
 * @returns {object[]} a list of [ledger structures]{@link https://docs.ccxt.com/#/?id=ledger}
 */
func  (this *bitmart) FetchLedger(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes52058 := (<-this.LoadMarkets())
            PanicOnError(retRes52058)
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
            }
            var request interface{} = map[string]interface{} {}
            requestparamsVariable := this.HandleUntilOption("end_time", request, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
            var transactionsRequest interface{} = this.FetchTransactionsRequest(0, nil, since, limit, params)
        
            response:= (<-this.PrivateGetContractPrivateTransactionHistory(transactionsRequest))
            PanicOnError(response)
            //
            //     {
            //         "code": 1000,
            //         "message": "Ok",
            //         "data": [
            //             {
            //                 "time": "1734422402121",
            //                 "type": "Funding Fee",
            //                 "amount": "-0.00008253",
            //                 "asset": "USDT",
            //                 "symbol": "LTCUSDT",
            //                 "tran_id": "1734422402121",
            //                 "flow_type": 3
            //             },
            //         ],
            //         "trace": "4cd11f83c71egfhfgh842790f07241e.23.173442343427772866"
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseLedger(data, currency, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *bitmart) ParseLedgerEntry(item interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "time": "1734422402121",
    //         "type": "Funding Fee",
    //         "amount": "-0.00008253",
    //         "asset": "USDT",
    //         "symbol": "LTCUSDT",
    //         "tran_id": "1734422402121",
    //         "flow_type": 3
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var amount interface{} = this.SafeString(item, "amount")
    var direction interface{} = nil
    if IsTrue(Precise.StringLe(amount, "0")) {
        direction = "out"
        amount = Precise.StringMul("-1", amount)
    } else {
        direction = "in"
    }
    var currencyId interface{} = this.SafeString(item, "asset")
    currency = this.SafeCurrency(currencyId, currency)
    var timestamp interface{} = this.SafeInteger(item, "time")
    var typeVar interface{} = this.SafeString(item, "type")
    return this.SafeLedgerEntry(map[string]interface{} {
        "info": item,
        "id": this.SafeString(item, "tran_id"),
        "direction": direction,
        "account": nil,
        "referenceAccount": nil,
        "referenceId": this.SafeString(item, "tradeId"),
        "type": this.ParseLedgerEntryType(typeVar),
        "currency": GetValue(currency, "code"),
        "amount": this.ParseNumber(amount),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "before": nil,
        "after": nil,
        "status": nil,
        "fee": nil,
    }, currency)
}
func  (this *bitmart) ParseLedgerEntryType(typeVar interface{}) interface{}  {
    var ledgerType interface{} = map[string]interface{} {
        "Commission Fee": "fee",
        "Funding Fee": "fee",
        "Realized PNL": "trade",
        "Transfer": "transfer",
        "Liquidation Clearance": "settlement",
    }
    return this.SafeString(ledgerType, typeVar, typeVar)
}
func  (this *bitmart) FetchTransactionsRequest(optionalArgs ...interface{}) interface{}  {
    flowType := GetArg(optionalArgs, 0, nil)
    _ = flowType
    symbol := GetArg(optionalArgs, 1, nil)
    _ = symbol
    since := GetArg(optionalArgs, 2, nil)
    _ = since
    limit := GetArg(optionalArgs, 3, nil)
    _ = limit
    params := GetArg(optionalArgs, 4, map[string]interface{} {})
    _ = params
    var request interface{} = map[string]interface{} {}
    if IsTrue(!IsEqual(flowType, nil)) {
        AddElementToObject(request, "flow_type", flowType)
    }
    var market interface{} = nil
    if IsTrue(!IsEqual(symbol, nil)) {
        market = this.Market(symbol)
        AddElementToObject(request, "symbol", GetValue(market, "id"))
    }
    if IsTrue(!IsEqual(since, nil)) {
        AddElementToObject(request, "start_time", since)
    }
    if IsTrue(!IsEqual(limit, nil)) {
        AddElementToObject(request, "page_size", limit)
    }
    requestparamsVariable := this.HandleUntilOption("end_time", request, params);
    request = GetValue(requestparamsVariable,0);
    params = GetValue(requestparamsVariable,1)
    return this.Extend(request, params)
}
/**
 * @method
 * @name bitmart#fetchFundingHistory
 * @description fetch the history of funding payments paid and received on this account
 * @see https://developer-pro.bitmart.com/en/futuresv2/#get-transaction-history-keyed
 * @param {string} [symbol] unified market symbol
 * @param {int} [since] the starting timestamp in milliseconds
 * @param {int} [limit] the number of entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch funding history for
 * @returns {object[]} a list of [funding history structures]{@link https://docs.ccxt.com/#/?id=funding-history-structure}
 */
func  (this *bitmart) FetchFundingHistory(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes53238 := (<-this.LoadMarkets())
            PanicOnError(retRes53238)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var request interface{} = map[string]interface{} {}
            requestparamsVariable := this.HandleUntilOption("end_time", request, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
            var transactionsRequest interface{} = this.FetchTransactionsRequest(3, symbol, since, limit, params)
        
            response:= (<-this.PrivateGetContractPrivateTransactionHistory(transactionsRequest))
            PanicOnError(response)
            //
            //     {
            //         "code": 1000,
            //         "message": "Ok",
            //         "data": [
            //             {
            //                 "time": "1734422402121",
            //                 "type": "Funding Fee",
            //                 "amount": "-0.00008253",
            //                 "asset": "USDT",
            //                 "symbol": "LTCUSDT",
            //                 "tran_id": "1734422402121",
            //                 "flow_type": 3
            //             },
            //         ],
            //         "trace": "4cd11f83c71egfhfgh842790f07241e.23.173442343427772866"
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseFundingHistories(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *bitmart) ParseFundingHistory(contract interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "time": "1734422402121",
    //         "type": "Funding Fee",
    //         "amount": "-0.00008253",
    //         "asset": "USDT",
    //         "symbol": "LTCUSDT",
    //         "tran_id": "1734422402121",
    //         "flow_type": 3
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(contract, "symbol")
    var currencyId interface{} = this.SafeString(contract, "asset")
    var timestamp interface{} = this.SafeInteger(contract, "time")
    return map[string]interface{} {
        "info": contract,
        "symbol": this.SafeSymbol(marketId, market, nil, "swap"),
        "code": this.SafeCurrencyCode(currencyId),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "id": this.SafeString(contract, "tran_id"),
        "amount": this.SafeNumber(contract, "amount"),
    }
}
func  (this *bitmart) ParseFundingHistories(contracts interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    since := GetArg(optionalArgs, 1, nil)
    _ = since
    limit := GetArg(optionalArgs, 2, nil)
    _ = limit
    var result interface{} = []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(contracts)); i++ {
        var contract interface{} = GetValue(contracts, i)
        AppendToArray(&result,this.ParseFundingHistory(contract, market))
    }
    var sorted interface{} = this.SortBy(result, "timestamp")
    return this.FilterBySinceLimit(sorted, since, limit)
}
func  (this *bitmart) Nonce() interface{}  {
    return Subtract(this.Milliseconds(), GetValue(this.Options, "timeDifference"))
}
func  (this *bitmart) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var parts interface{} = Split(path, "/")
    // to do: refactor api endpoints with spot/swap sections
    var category interface{} = this.SafeString(parts, 0, "spot")
    var market interface{} = Ternary(IsTrue((IsTrue(IsEqual(category, "spot")) || IsTrue(IsEqual(category, "account")))), "spot", "swap")
    var baseUrl interface{} = this.ImplodeHostname(GetValue(GetValue(this.Urls, "api"), market))
    var url interface{} = Add(Add(baseUrl, "/"), this.ImplodeParams(path, params))
    var query interface{} = this.Omit(params, this.ExtractParams(path))
    var queryString interface{} = ""
    var getOrDelete interface{} = IsTrue((IsEqual(method, "GET"))) || IsTrue((IsEqual(method, "DELETE")))
    if IsTrue(getOrDelete) {
        if IsTrue(GetArrayLength(ObjectKeys(query))) {
            queryString = this.Urlencode(query)
            url = Add(url, Add("?", queryString))
        }
    }
    if IsTrue(IsEqual(api, "private")) {
        this.CheckRequiredCredentials()
        var timestamp interface{} = ToString(this.Nonce())
        var brokerId interface{} = this.SafeString(this.Options, "brokerId", "CCXTxBitmart000")
        headers = map[string]interface{} {
            "X-BM-KEY": this.ApiKey,
            "X-BM-TIMESTAMP": timestamp,
            "X-BM-BROKER-ID": brokerId,
            "Content-Type": "application/json",
        }
        if !IsTrue(getOrDelete) {
            body = this.Json(query)
            queryString = body
        }
        var auth interface{} = Add(Add(Add(Add(timestamp, "#"), this.Uid), "#"), queryString)
        var signature interface{} = this.Hmac(this.Encode(auth), this.Encode(this.Secret), sha256)
        AddElementToObject(headers, "X-BM-SIGN", signature)
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *bitmart) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsEqual(response, nil)) {
        return nil
    }
    //
    // spot
    //
    //     {"message":"Bad Request [to is empty]","code":50000,"trace":"f9d46e1b-4edb-4d07-a06e-4895fb2fc8fc","data":{}}
    //     {"message":"Bad Request [from is empty]","code":50000,"trace":"579986f7-c93a-4559-926b-06ba9fa79d76","data":{}}
    //     {"message":"Kline size over 500","code":50004,"trace":"d625caa8-e8ca-4bd2-b77c-958776965819","data":{}}
    //     {"message":"Balance not enough","code":50020,"trace":"7c709d6a-3292-462c-98c5-32362540aeef","data":{}}
    //     {"code":40012,"message":"You contract account available balance not enough.","trace":"..."}
    //
    // contract
    //
    //     {"errno":"OK","message":"INVALID_PARAMETER","code":49998,"trace":"eb5ebb54-23cd-4de2-9064-e090b6c3b2e3","data":null}
    //
    var message interface{} = this.SafeStringLower(response, "message")
    var isErrorMessage interface{} = IsTrue(IsTrue((!IsEqual(message, nil))) && IsTrue((!IsEqual(message, "ok")))) && IsTrue((!IsEqual(message, "success")))
    var errorCode interface{} = this.SafeString(response, "code")
    var isErrorCode interface{} = IsTrue((!IsEqual(errorCode, nil))) && IsTrue((!IsEqual(errorCode, "1000")))
    if IsTrue(IsTrue(isErrorCode) || IsTrue(isErrorMessage)) {
        var feedback interface{} = Add(Add(this.Id, " "), body)
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), message, feedback)
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), message, feedback)
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), errorCode, feedback)
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), errorCode, feedback)
        panic(ExchangeError(feedback))
    }
    return nil
}


func (this *bitmart) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
