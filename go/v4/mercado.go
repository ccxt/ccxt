package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type mercado struct {
    Exchange

}

func NewMercadoCore() mercado {
   p := mercado{}
   setDefaults(&p)
   return p
}

func  (this *mercado) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "mercado",
        "name": "Mercado Bitcoin",
        "countries": []interface{}{"BR"},
        "rateLimit": 1000,
        "version": "v3",
        "has": map[string]interface{} {
            "CORS": true,
            "spot": true,
            "margin": false,
            "swap": false,
            "future": false,
            "option": false,
            "addMargin": false,
            "cancelOrder": true,
            "closeAllPositions": false,
            "closePosition": false,
            "createMarketOrder": true,
            "createOrder": true,
            "createReduceOnlyOrder": false,
            "createStopLimitOrder": false,
            "createStopMarketOrder": false,
            "createStopOrder": false,
            "fetchBalance": true,
            "fetchBorrowRateHistory": false,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchDepositAddress": false,
            "fetchDepositAddresses": false,
            "fetchDepositAddressesByNetwork": false,
            "fetchFundingHistory": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchIndexOHLCV": false,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchLeverage": false,
            "fetchLeverageTiers": false,
            "fetchMarginMode": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMyTrades": "emulated",
            "fetchOHLCV": true,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrders": true,
            "fetchPosition": false,
            "fetchPositionHistory": false,
            "fetchPositionMode": false,
            "fetchPositions": false,
            "fetchPositionsForSymbol": false,
            "fetchPositionsHistory": false,
            "fetchPositionsRisk": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchTicker": true,
            "fetchTickers": false,
            "fetchTrades": true,
            "fetchTradingFee": false,
            "fetchTradingFees": false,
            "reduceMargin": false,
            "setLeverage": false,
            "setMarginMode": false,
            "setPositionMode": false,
            "withdraw": true,
        },
        "timeframes": map[string]interface{} {
            "15m": "15m",
            "1h": "1h",
            "3h": "3h",
            "1d": "1d",
            "1w": "1w",
            "1M": "1M",
        },
        "urls": map[string]interface{} {
            "logo": "https://user-images.githubusercontent.com/1294454/27837060-e7c58714-60ea-11e7-9192-f05e86adb83f.jpg",
            "api": map[string]interface{} {
                "public": "https://www.mercadobitcoin.net/api",
                "private": "https://www.mercadobitcoin.net/tapi",
                "v4Public": "https://www.mercadobitcoin.com.br/v4",
                "v4PublicNet": "https://api.mercadobitcoin.net/api/v4",
            },
            "www": "https://www.mercadobitcoin.com.br",
            "doc": []interface{}{"https://www.mercadobitcoin.com.br/api-doc", "https://www.mercadobitcoin.com.br/trade-api"},
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": []interface{}{"coins", "{coin}/orderbook/", "{coin}/ticker/", "{coin}/trades/", "{coin}/trades/{from}/", "{coin}/trades/{from}/{to}", "{coin}/day-summary/{year}/{month}/{day}/"},
            },
            "private": map[string]interface{} {
                "post": []interface{}{"cancel_order", "get_account_info", "get_order", "get_withdrawal", "list_system_messages", "list_orders", "list_orderbook", "place_buy_order", "place_sell_order", "place_market_buy_order", "place_market_sell_order", "withdraw_coin"},
            },
            "v4Public": map[string]interface{} {
                "get": []interface{}{"{coin}/candle/"},
            },
            "v4PublicNet": map[string]interface{} {
                "get": []interface{}{"candles"},
            },
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "maker": 0.003,
                "taker": 0.007,
            },
        },
        "options": map[string]interface{} {
            "limits": map[string]interface{} {
                "BTC": 0.001,
                "BCH": 0.001,
                "ETH": 0.01,
                "LTC": 0.01,
                "XRP": 0.1,
            },
        },
        "features": map[string]interface{} {
            "spot": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": false,
                    "triggerPriceType": nil,
                    "triggerDirection": false,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": false,
                        "FOK": false,
                        "PO": true,
                        "GTD": false,
                    },
                    "hedged": false,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyByCost": true,
                    "marketBuyRequiresPrice": true,
                    "selfTradePrevention": false,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": nil,
                    "daysBack": 100000,
                    "untilDays": 100000,
                    "symbolRequired": true,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": nil,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 500,
                    "daysBack": 100000,
                    "untilDays": 100000,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchClosedOrders": nil,
                "fetchOHLCV": map[string]interface{} {
                    "limit": 1000,
                },
            },
            "swap": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "precisionMode": TICK_SIZE,
    })
}
/**
 * @method
 * @name mercado#fetchMarkets
 * @description retrieves data on all markets for mercado
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *mercado) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetCoins(params))
            PanicOnError(response)
            //
            //     [
            //         "BCH",
            //         "BTC",
            //         "ETH",
            //         "LTC",
            //         "XRP",
            //         "MBPRK01",
            //         "MBPRK02",
            //         "MBPRK03",
            //         "MBPRK04",
            //         "MBCONS01",
            //         "USDC",
            //         "WBX",
            //         "CHZ",
            //         "MBCONS02",
            //         "PAXG",
            //         "MBVASCO01",
            //         "LINK"
            //     ]
            //
            var result interface{} = []interface{}{}
            var amountLimits interface{} = this.SafeValue(this.Options, "limits", map[string]interface{} {})
            for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
                var coin interface{} = GetValue(response, i)
                var baseId interface{} = coin
                var quoteId interface{} = "BRL"
                var base interface{} = this.SafeCurrencyCode(baseId)
                var quote interface{} = this.SafeCurrencyCode(quoteId)
                var id interface{} = Add(quote, base)
                AppendToArray(&result,map[string]interface{} {
                    "id": id,
                    "symbol": Add(Add(base, "/"), quote),
                    "base": base,
                    "quote": quote,
                    "settle": nil,
                    "baseId": baseId,
                    "quoteId": quoteId,
                    "settleId": nil,
                    "type": "spot",
                    "spot": true,
                    "margin": false,
                    "swap": false,
                    "future": false,
                    "option": false,
                    "active": nil,
                    "contract": false,
                    "linear": nil,
                    "inverse": nil,
                    "contractSize": nil,
                    "expiry": nil,
                    "expiryDatetime": nil,
                    "strike": nil,
                    "optionType": nil,
                    "precision": map[string]interface{} {
                        "amount": this.ParseNumber("1e-8"),
                        "price": this.ParseNumber("1e-5"),
                    },
                    "limits": map[string]interface{} {
                        "leverage": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "amount": map[string]interface{} {
                            "min": this.SafeNumber(amountLimits, baseId),
                            "max": nil,
                        },
                        "price": map[string]interface{} {
                            "min": this.ParseNumber("1e-5"),
                            "max": nil,
                        },
                        "cost": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                    },
                    "created": nil,
                    "info": coin,
                })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mercado#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *mercado) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes375981 := (<-this.LoadMarkets())
            PanicOnError(retRes375981)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "coin": GetValue(market, "base"),
            }
        
            response:= (<-this.PublicGetCoinOrderbook(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseOrderBook(response, GetValue(market, "symbol"))
            return nil
        
            }()
            return ch
        }
func  (this *mercado) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "high":"103.96000000",
    //         "low":"95.00000000",
    //         "vol":"2227.67806598",
    //         "last":"97.91591000",
    //         "buy":"95.52760000",
    //         "sell":"97.91475000",
    //         "open":"99.79955000",
    //         "date":1643382606
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var symbol interface{} = this.SafeSymbol(nil, market)
    var timestamp interface{} = this.SafeTimestamp(ticker, "date")
    var last interface{} = this.SafeString(ticker, "last")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeString(ticker, "high"),
        "low": this.SafeString(ticker, "low"),
        "bid": this.SafeString(ticker, "buy"),
        "bidVolume": nil,
        "ask": this.SafeString(ticker, "sell"),
        "askVolume": nil,
        "vwap": nil,
        "open": nil,
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": nil,
        "percentage": nil,
        "average": nil,
        "baseVolume": this.SafeString(ticker, "vol"),
        "quoteVolume": nil,
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name mercado#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *mercado) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes37966 := (<-this.LoadMarkets())
            PanicOnError(retRes37966)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "coin": GetValue(market, "base"),
            }
        
            response:= (<-this.PublicGetCoinTicker(this.Extend(request, params)))
            PanicOnError(response)
            var ticker interface{} = this.SafeValue(response, "ticker", map[string]interface{} {})
        
                //
            //     {
            //         "ticker": {
            //             "high":"1549.82293000",
            //             "low":"1503.00011000",
            //             "vol":"81.82827101",
            //             "last":"1533.15000000",
            //             "buy":"1533.21018000",
            //             "sell":"1540.09000000",
            //             "open":"1524.71089000",
            //             "date":1643691671
            //         }
            //     }
            //
        ch <- this.ParseTicker(ticker, market)
            return nil
        
            }()
            return ch
        }
func  (this *mercado) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeTimestamp2(trade, "date", "executed_timestamp")
    market = this.SafeMarket(nil, market)
    var id interface{} = this.SafeString2(trade, "tid", "operation_id")
    var typeVar interface{} = nil
    var side interface{} = this.SafeString(trade, "type")
    var price interface{} = this.SafeString(trade, "price")
    var amount interface{} = this.SafeString2(trade, "amount", "quantity")
    var feeCost interface{} = this.SafeString(trade, "fee_rate")
    var fee interface{} = nil
    if IsTrue(!IsEqual(feeCost, nil)) {
        fee = map[string]interface{} {
            "cost": feeCost,
            "currency": nil,
        }
    }
    return this.SafeTrade(map[string]interface{} {
        "id": id,
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": GetValue(market, "symbol"),
        "order": nil,
        "type": typeVar,
        "side": side,
        "takerOrMaker": nil,
        "price": price,
        "amount": amount,
        "cost": nil,
        "fee": fee,
    }, market)
}
/**
 * @method
 * @name mercado#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *mercado) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes720131 := (<-this.LoadMarkets())
            PanicOnError(retRes720131)
            var market interface{} = this.Market(symbol)
            var method interface{} = "publicGetCoinTrades"
            var request interface{} = map[string]interface{} {
                "coin": GetValue(market, "base"),
            }
            if IsTrue(!IsEqual(since, nil)) {
                method = Add(method, "From")
                AddElementToObject(request, "from", this.ParseToInt(Divide(since, 1000)))
            }
            var to interface{} = this.SafeInteger(params, "to")
            if IsTrue(!IsEqual(to, nil)) {
                method = Add(method, "To")
            }
        
            response:= (<-this.callDynamically(method, this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseTrades(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *mercado) ParseBalance(response interface{}) interface{}  {
    var data interface{} = this.SafeValue(response, "response_data", map[string]interface{} {})
    var balances interface{} = this.SafeValue(data, "balance", map[string]interface{} {})
    var result interface{} = map[string]interface{} {
        "info": response,
    }
    var currencyIds interface{} = ObjectKeys(balances)
    for i := 0; IsLessThan(i, GetArrayLength(currencyIds)); i++ {
        var currencyId interface{} = GetValue(currencyIds, i)
        var code interface{} = this.SafeCurrencyCode(currencyId)
        if IsTrue(InOp(balances, currencyId)) {
            var balance interface{} = this.SafeValue(balances, currencyId, map[string]interface{} {})
            var account interface{} = this.Account()
            AddElementToObject(account, "free", this.SafeString(balance, "available"))
            AddElementToObject(account, "total", this.SafeString(balance, "total"))
            AddElementToObject(result, code, account)
        }
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name mercado#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *mercado) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes788413 := (<-this.LoadMarkets())
            PanicOnError(retRes788413)
        
            response:= (<-this.PrivatePostGetAccountInfo(params))
            PanicOnError(response)
        
            ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mercado#createOrder
 * @description create a trade order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *mercado) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes809151 := (<-this.LoadMarkets())
            PanicOnError(retRes809151)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "coin_pair": GetValue(market, "id"),
            }
            var method interface{} = Add(this.Capitalize(side), "Order")
            if IsTrue(IsEqual(typeVar, "limit")) {
                method = Add("privatePostPlace", method)
                AddElementToObject(request, "limit_price", this.PriceToPrecision(GetValue(market, "symbol"), price))
                AddElementToObject(request, "quantity", this.AmountToPrecision(GetValue(market, "symbol"), amount))
            } else {
                method = Add("privatePostPlaceMarket", method)
                if IsTrue(IsEqual(side, "buy")) {
                    if IsTrue(IsEqual(price, nil)) {
                        panic(InvalidOrder(Add(this.Id, " createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount")))
                    }
                    var amountString interface{} = this.NumberToString(amount)
                    var priceString interface{} = this.NumberToString(price)
                    var cost interface{} = this.ParseToNumeric(Precise.StringMul(amountString, priceString))
                    AddElementToObject(request, "cost", this.PriceToPrecision(GetValue(market, "symbol"), cost))
                } else {
                    AddElementToObject(request, "quantity", this.AmountToPrecision(GetValue(market, "symbol"), amount))
                }
            }
        
            response:= (<-this.callDynamically(method, this.Extend(request, params)))
            PanicOnError(response)
        
                // TODO: replace this with a call to parseOrder for unification
        ch <- this.SafeOrder(map[string]interface{} {
                "info": response,
                "id": ToString(GetValue(GetValue(GetValue(response, "response_data"), "order"), "order_id")),
            }, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mercado#cancelOrder
 * @description cancels an open order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *mercado) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " cancelOrder() requires a symbol argument")))
            }
        
            retRes541603 := (<-this.LoadMarkets())
            PanicOnError(retRes541603)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "coin_pair": GetValue(market, "id"),
                "order_id": id,
            }
        
            response:= (<-this.PrivatePostCancelOrder(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "response_data": {
            //             "order": {
            //                 "order_id": 2176769,
            //                 "coin_pair": "BRLBCH",
            //                 "order_type": 2,
            //                 "status": 3,
            //                 "has_fills": false,
            //                 "quantity": "0.10000000",
            //                 "limit_price": "1996.15999",
            //                 "executed_quantity": "0.00000000",
            //                 "executed_price_avg": "0.00000",
            //                 "fee": "0.00000000",
            //                 "created_timestamp": "1536956488",
            //                 "updated_timestamp": "1536956499",
            //                 "operations": []
            //             }
            //         },
            //         "status_code": 100,
            //         "server_unix_timestamp": "1536956499"
            //     }
            //
            var responseData interface{} = this.SafeValue(response, "response_data", map[string]interface{} {})
            var order interface{} = this.SafeDict(responseData, "order", map[string]interface{} {})
        
            ch <- this.ParseOrder(order, market)
            return nil
        
            }()
            return ch
        }
func  (this *mercado) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "2": "open",
        "3": "canceled",
        "4": "closed",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *mercado) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "order_id": 4,
    //         "coin_pair": "BRLBTC",
    //         "order_type": 1,
    //         "status": 2,
    //         "has_fills": true,
    //         "quantity": "2.00000000",
    //         "limit_price": "900.00000",
    //         "executed_quantity": "1.00000000",
    //         "executed_price_avg": "900.00000",
    //         "fee": "0.00300000",
    //         "created_timestamp": "1453838494",
    //         "updated_timestamp": "1453838494",
    //         "operations": [
    //             {
    //                 "operation_id": 1,
    //                 "quantity": "1.00000000",
    //                 "price": "900.00000",
    //                 "fee_rate": "0.30",
    //                 "executed_timestamp": "1453838494",
    //             },
    //         ],
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeString(order, "order_id")
    var order_type interface{} = this.SafeString(order, "order_type")
    var side interface{} = nil
    if IsTrue(InOp(order, "order_type")) {
        side = Ternary(IsTrue((IsEqual(order_type, "1"))), "buy", "sell")
    }
    var status interface{} = this.ParseOrderStatus(this.SafeString(order, "status"))
    var marketId interface{} = this.SafeString(order, "coin_pair")
    market = this.SafeMarket(marketId, market)
    var timestamp interface{} = this.SafeTimestamp(order, "created_timestamp")
    var fee interface{} = map[string]interface{} {
        "cost": this.SafeString(order, "fee"),
        "currency": GetValue(market, "quote"),
    }
    var price interface{} = this.SafeString(order, "limit_price")
    // price = this.safeNumber (order, 'executed_price_avg', price);
    var average interface{} = this.SafeString(order, "executed_price_avg")
    var amount interface{} = this.SafeString(order, "quantity")
    var filled interface{} = this.SafeString(order, "executed_quantity")
    var lastTradeTimestamp interface{} = this.SafeTimestamp(order, "updated_timestamp")
    var rawTrades interface{} = this.SafeValue(order, "operations", []interface{}{})
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": id,
        "clientOrderId": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": lastTradeTimestamp,
        "symbol": GetValue(market, "symbol"),
        "type": "limit",
        "timeInForce": nil,
        "postOnly": nil,
        "side": side,
        "price": price,
        "triggerPrice": nil,
        "cost": nil,
        "average": average,
        "amount": amount,
        "filled": filled,
        "remaining": nil,
        "status": status,
        "fee": fee,
        "trades": rawTrades,
    }, market)
}
/**
 * @method
 * @name mercado#fetchOrder
 * @description fetches information on an order made by the user
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *mercado) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchOrder() requires a symbol argument")))
            }
        
            retRes859851 := (<-this.LoadMarkets())
            PanicOnError(retRes859851)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "coin_pair": GetValue(market, "id"),
                "order_id": ParseInt(id),
            }
        
            response:= (<-this.PrivatePostGetOrder(this.Extend(request, params)))
            PanicOnError(response)
            var responseData interface{} = this.SafeValue(response, "response_data", map[string]interface{} {})
            var order interface{} = this.SafeDict(responseData, "order")
        
            ch <- this.ParseOrder(order, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mercado#withdraw
 * @description make a withdrawal
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *mercado) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params);
            tag = GetValue(tagparamsVariable,0);
            params = GetValue(tagparamsVariable,1)
            this.CheckAddress(address)
        
            retRes606904 := (<-this.LoadMarkets())
            PanicOnError(retRes606904)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "coin": GetValue(currency, "id"),
                "quantity": toFixed(amount, 10),
                "address": address,
            }
            if IsTrue(IsEqual(code, "BRL")) {
                var account_ref interface{} =         (InOp(params, "account_ref"))
                if !IsTrue(account_ref) {
                    panic(ArgumentsRequired(Add(Add(this.Id, " withdraw() requires account_ref parameter to withdraw "), code)))
                }
            } else if IsTrue(!IsEqual(code, "LTC")) {
                var tx_fee interface{} =         (InOp(params, "tx_fee"))
                if !IsTrue(tx_fee) {
                    panic(ArgumentsRequired(Add(Add(this.Id, " withdraw() requires tx_fee parameter to withdraw "), code)))
                }
                if IsTrue(IsEqual(code, "XRP")) {
                    if IsTrue(IsEqual(tag, nil)) {
                        if !IsTrue((InOp(params, "destination_tag"))) {
                            panic(ArgumentsRequired(Add(Add(this.Id, " withdraw() requires a tag argument or destination_tag parameter to withdraw "), code)))
                        }
                    } else {
                        AddElementToObject(request, "destination_tag", tag)
                    }
                }
            }
        
            response:= (<-this.PrivatePostWithdrawCoin(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "response_data": {
            //             "withdrawal": {
            //                 "id": 1,
            //                 "coin": "BRL",
            //                 "quantity": "300.56",
            //                 "net_quantity": "291.68",
            //                 "fee": "8.88",
            //                 "account": "bco: 341, ag: 1111, cta: 23456-X",
            //                 "status": 1,
            //                 "created_timestamp": "1453912088",
            //                 "updated_timestamp": "1453912088"
            //             }
            //         },
            //         "status_code": 100,
            //         "server_unix_timestamp": "1453912088"
            //     }
            //
            var responseData interface{} = this.SafeValue(response, "response_data", map[string]interface{} {})
            var withdrawal interface{} = this.SafeDict(responseData, "withdrawal")
        
            ch <- this.ParseTransaction(withdrawal, currency)
            return nil
        
            }()
            return ch
        }
func  (this *mercado) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "id": 1,
    //         "coin": "BRL",
    //         "quantity": "300.56",
    //         "net_quantity": "291.68",
    //         "fee": "8.88",
    //         "account": "bco: 341, ag: 1111, cta: 23456-X",
    //         "status": 1,
    //         "created_timestamp": "1453912088",
    //         "updated_timestamp": "1453912088"
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    currency = this.SafeCurrency(nil, currency)
    return map[string]interface{} {
        "id": this.SafeString(transaction, "id"),
        "txid": nil,
        "timestamp": nil,
        "datetime": nil,
        "network": nil,
        "addressFrom": nil,
        "address": nil,
        "addressTo": nil,
        "amount": nil,
        "type": nil,
        "currency": GetValue(currency, "code"),
        "status": nil,
        "updated": nil,
        "tagFrom": nil,
        "tag": nil,
        "tagTo": nil,
        "comment": nil,
        "internal": nil,
        "fee": nil,
        "info": transaction,
    }
}
func  (this *mercado) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.SafeInteger(ohlcv, 0), this.SafeNumber(ohlcv, 1), this.SafeNumber(ohlcv, 2), this.SafeNumber(ohlcv, 3), this.SafeNumber(ohlcv, 4), this.SafeNumber(ohlcv, 5)}
}
/**
 * @method
 * @name mercado#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *mercado) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "15m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes293411 := (<-this.LoadMarkets())
            PanicOnError(retRes293411)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "resolution": this.SafeString(this.Timeframes, timeframe, timeframe),
                "symbol": Add(Add(GetValue(market, "base"), "-"), GetValue(market, "quote")),
            }
            if IsTrue(IsEqual(limit, nil)) {
                limit = 100 // set some default limit, as it's required if user doesn't provide it
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "from", this.ParseToInt(Divide(since, 1000)))
                AddElementToObject(request, "to", this.Sum(GetValue(request, "from"), Multiply(limit, this.ParseTimeframe(timeframe))))
            } else {
                AddElementToObject(request, "to", this.Seconds())
                AddElementToObject(request, "from", Subtract(GetValue(request, "to"), (Multiply(limit, this.ParseTimeframe(timeframe)))))
            }
        
            response:= (<-this.V4PublicNetGetCandles(this.Extend(request, params)))
            PanicOnError(response)
            var candles interface{} = this.ConvertTradingViewToOHLCV(response, "t", "o", "h", "l", "c", "v")
        
            ch <- this.ParseOHLCVs(candles, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mercado#fetchOrders
 * @description fetches information on multiple orders made by the user
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *mercado) FetchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchOrders() requires a symbol argument")))
            }
        
            retRes746988 := (<-this.LoadMarkets())
            PanicOnError(retRes746988)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "coin_pair": GetValue(market, "id"),
            }
        
            response:= (<-this.PrivatePostListOrders(this.Extend(request, params)))
            PanicOnError(response)
            var responseData interface{} = this.SafeValue(response, "response_data", map[string]interface{} {})
            var orders interface{} = this.SafeList(responseData, "orders", []interface{}{})
        
            ch <- this.ParseOrders(orders, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mercado#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of open order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *mercado) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchOpenOrders() requires a symbol argument")))
            }
        
            retRes271036 := (<-this.LoadMarkets())
            PanicOnError(retRes271036)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "coin_pair": GetValue(market, "id"),
                "status_list": "[2]",
            }
        
            response:= (<-this.PrivatePostListOrders(this.Extend(request, params)))
            PanicOnError(response)
            var responseData interface{} = this.SafeValue(response, "response_data", map[string]interface{} {})
            var orders interface{} = this.SafeList(responseData, "orders", []interface{}{})
        
            ch <- this.ParseOrders(orders, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name mercado#fetchMyTrades
 * @description fetch all trades made by the user
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *mercado) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchMyTrades() requires a symbol argument")))
            }
        
            retRes328189 := (<-this.LoadMarkets())
            PanicOnError(retRes328189)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "coin_pair": GetValue(market, "id"),
                "has_fills": true,
            }
        
            response:= (<-this.PrivatePostListOrders(this.Extend(request, params)))
            PanicOnError(response)
            var responseData interface{} = this.SafeValue(response, "response_data", map[string]interface{} {})
            var ordersRaw interface{} = this.SafeValue(responseData, "orders", []interface{}{})
            var orders interface{} = this.ParseOrders(ordersRaw, market, since, limit)
            var trades interface{} = this.OrdersToTrades(orders)
        
            ch <- this.FilterBySymbolSinceLimit(trades, GetValue(market, "symbol"), since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *mercado) OrdersToTrades(orders interface{}) interface{}  {
    var result interface{} = []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(orders)); i++ {
        var trades interface{} = this.SafeValue(GetValue(orders, i), "trades", []interface{}{})
        for y := 0; IsLessThan(y, GetArrayLength(trades)); y++ {
            AppendToArray(&result,GetValue(trades, y))
        }
    }
    return result
}
func  (this *mercado) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var url interface{} = Add(GetValue(GetValue(this.Urls, "api"), api), "/")
    var query interface{} = this.Omit(params, this.ExtractParams(path))
    if IsTrue(IsTrue(IsTrue((IsEqual(api, "public"))) || IsTrue((IsEqual(api, "v4Public")))) || IsTrue((IsEqual(api, "v4PublicNet")))) {
        url = Add(url, this.ImplodeParams(path, params))
        if IsTrue(GetArrayLength(ObjectKeys(query))) {
            url = Add(url, Add("?", this.Urlencode(query)))
        }
    } else {
        this.CheckRequiredCredentials()
        url = Add(url, Add(this.Version, "/"))
        var nonce interface{} = this.Nonce()
        body = this.Urlencode(this.Extend(map[string]interface{} {
            "tapi_method": path,
            "tapi_nonce": nonce,
        }, params))
        var auth interface{} = Add(Add(Add(Add("/tapi/", this.Version), "/"), "?"), body)
        headers = map[string]interface{} {
            "Content-Type": "application/x-www-form-urlencoded",
            "TAPI-ID": this.ApiKey,
            "TAPI-MAC": this.Hmac(this.Encode(auth), this.Encode(this.Secret), sha512),
        }
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *mercado) HandleErrors(httpCode interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsEqual(response, nil)) {
        return nil
    }
    //
    // todo add a unified standard handleErrors with this.exceptions in describe()
    //
    //     {"status":503,"message":"Maintenancing, try again later","result":null}
    //
    var errorMessage interface{} = this.SafeValue(response, "error_message")
    if IsTrue(!IsEqual(errorMessage, nil)) {
        panic(ExchangeError(Add(Add(this.Id, " "), this.Json(response))))
    }
    return nil
}


func (this *mercado) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
