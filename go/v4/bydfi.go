package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type BydfiCore struct {
	Exchange
}

func NewBydfiCore() *BydfiCore {
	p := &BydfiCore{}
	setDefaults(p)
	return p
}

func (this *BydfiCore) Describe() interface{} {
	return this.DeepExtend(this.Exchange.Describe(), map[string]interface{}{
		"id":        "bydfi",
		"name":      "BYDFi",
		"countries": []interface{}{"SG"},
		"rateLimit": 50,
		"version":   "v1",
		"certified": false,
		"pro":       true,
		"has": map[string]interface{}{
			"CORS":                                 nil,
			"spot":                                 false,
			"margin":                               false,
			"swap":                                 true,
			"future":                               false,
			"option":                               false,
			"addMargin":                            false,
			"borrowCrossMargin":                    false,
			"borrowIsolatedMargin":                 false,
			"borrowMargin":                         false,
			"cancelAllOrders":                      true,
			"cancelOrder":                          false,
			"cancelOrders":                         false,
			"cancelOrdersWithClientOrderId":        false,
			"cancelOrderWithClientOrderId":         false,
			"closeAllPositions":                    false,
			"closePosition":                        false,
			"createDepositAddress":                 false,
			"createLimitBuyOrder":                  false,
			"createLimitOrder":                     true,
			"createLimitSellOrder":                 false,
			"createMarketBuyOrder":                 false,
			"createMarketBuyOrderWithCost":         false,
			"createMarketOrder":                    true,
			"createMarketOrderWithCost":            false,
			"createMarketSellOrder":                false,
			"createMarketSellOrderWithCost":        false,
			"createOrder":                          true,
			"createOrders":                         true,
			"createOrderWithTakeProfitAndStopLoss": false,
			"createPostOnlyOrder":                  true,
			"createReduceOnlyOrder":                true,
			"createStopLimitOrder":                 true,
			"createStopLossOrder":                  true,
			"createStopMarketOrder":                false,
			"createStopOrder":                      false,
			"createTakeProfitOrder":                true,
			"createTrailingAmountOrder":            false,
			"createTrailingPercentOrder":           true,
			"createTriggerOrder":                   false,
			"deposit":                              false,
			"editOrder":                            true,
			"editOrders":                           true,
			"editOrderWithClientOrderId":           true,
			"fetchAccounts":                        false,
			"fetchBalance":                         true,
			"fetchBidsAsks":                        false,
			"fetchBorrowInterest":                  false,
			"fetchBorrowRate":                      false,
			"fetchBorrowRateHistories":             false,
			"fetchBorrowRateHistory":               false,
			"fetchBorrowRates":                     false,
			"fetchBorrowRatesPerSymbol":            false,
			"fetchCanceledAndClosedOrders":         true,
			"fetchCanceledOrders":                  false,
			"fetchClosedOrder":                     false,
			"fetchClosedOrders":                    false,
			"fetchConvertCurrencies":               false,
			"fetchConvertQuote":                    false,
			"fetchConvertTrade":                    false,
			"fetchConvertTradeHistory":             false,
			"fetchCrossBorrowRate":                 false,
			"fetchCrossBorrowRates":                false,
			"fetchCurrencies":                      false,
			"fetchDeposit":                         false,
			"fetchDepositAddress":                  false,
			"fetchDepositAddresses":                false,
			"fetchDepositAddressesByNetwork":       false,
			"fetchDeposits":                        true,
			"fetchDepositsWithdrawals":             false,
			"fetchDepositWithdrawFee":              false,
			"fetchDepositWithdrawFees":             false,
			"fetchFundingHistory":                  false,
			"fetchFundingInterval":                 false,
			"fetchFundingIntervals":                false,
			"fetchFundingRate":                     true,
			"fetchFundingRateHistory":              true,
			"fetchFundingRates":                    false,
			"fetchGreeks":                          false,
			"fetchIndexOHLCV":                      false,
			"fetchIsolatedBorrowRate":              false,
			"fetchIsolatedBorrowRates":             false,
			"fetchIsolatedPositions":               false,
			"fetchL2OrderBook":                     true,
			"fetchL3OrderBook":                     false,
			"fetchLastPrices":                      false,
			"fetchLedger":                          false,
			"fetchLedgerEntry":                     false,
			"fetchLeverage":                        true,
			"fetchLeverages":                       false,
			"fetchLeverageTiers":                   false,
			"fetchLiquidations":                    false,
			"fetchLongShortRatio":                  false,
			"fetchLongShortRatioHistory":           false,
			"fetchMarginAdjustmentHistory":         false,
			"fetchMarginMode":                      true,
			"fetchMarginModes":                     false,
			"fetchMarketLeverageTiers":             false,
			"fetchMarkets":                         true,
			"fetchMarkOHLCV":                       false,
			"fetchMarkPrices":                      false,
			"fetchMyLiquidations":                  false,
			"fetchMySettlementHistory":             false,
			"fetchMyTrades":                        true,
			"fetchOHLCV":                           true,
			"fetchOpenInterest":                    false,
			"fetchOpenInterestHistory":             false,
			"fetchOpenInterests":                   false,
			"fetchOpenOrder":                       false,
			"fetchOpenOrders":                      true,
			"fetchOption":                          false,
			"fetchOptionChain":                     false,
			"fetchOrder":                           false,
			"fetchOrderBook":                       true,
			"fetchOrderBooks":                      false,
			"fetchOrders":                          false,
			"fetchOrdersByStatus":                  false,
			"fetchOrderTrades":                     false,
			"fetchOrderWithClientOrderId":          false,
			"fetchPosition":                        false,
			"fetchPositionHistory":                 true,
			"fetchPositionMode":                    true,
			"fetchPositions":                       true,
			"fetchPositionsForSymbol":              true,
			"fetchPositionsHistory":                true,
			"fetchPositionsRisk":                   false,
			"fetchPremiumIndexOHLCV":               false,
			"fetchSettlementHistory":               false,
			"fetchStatus":                          false,
			"fetchTicker":                          true,
			"fetchTickers":                         true,
			"fetchTime":                            false,
			"fetchTrades":                          true,
			"fetchTradingFee":                      false,
			"fetchTradingFees":                     false,
			"fetchTradingLimits":                   false,
			"fetchTransactionFee":                  false,
			"fetchTransactionFees":                 false,
			"fetchTransactions":                    false,
			"fetchTransfer":                        false,
			"fetchTransfers":                       true,
			"fetchUnderlyingAssets":                false,
			"fetchVolatilityHistory":               false,
			"fetchWithdrawAddresses":               false,
			"fetchWithdrawal":                      false,
			"fetchWithdrawals":                     true,
			"fetchWithdrawalWhitelist":             false,
			"reduceMargin":                         false,
			"repayCrossMargin":                     false,
			"repayIsolatedMargin":                  false,
			"setLeverage":                          true,
			"setMargin":                            false,
			"setMarginMode":                        true,
			"setPositionMode":                      true,
			"signIn":                               false,
			"transfer":                             true,
			"watchMyLiquidationsForSymbols":        false,
			"withdraw":                             false,
			"ws":                                   true,
		},
		"urls": map[string]interface{}{
			"logo": "https://github.com/user-attachments/assets/bfffb73d-29bd-465d-b75b-98e210491769",
			"api": map[string]interface{}{
				"public":  "https://api.bydfi.com/api",
				"private": "https://api.bydfi.com/api",
			},
			"www":      "https://bydfi.com/",
			"doc":      "https://developers.bydfi.com/en/",
			"referral": "https://partner.bydfi.com/j/DilWutCI",
		},
		"fees": map[string]interface{}{},
		"api": map[string]interface{}{
			"public": map[string]interface{}{
				"get": map[string]interface{}{
					"v1/public/api_limits":                1,
					"v1/swap/market/exchange_info":        1,
					"v1/swap/market/depth":                1,
					"v1/swap/market/trades":               1,
					"v1/swap/market/klines":               1,
					"v1/swap/market/ticker/24hr":          1,
					"v1/swap/market/ticker/price":         1,
					"v1/swap/market/mark_price":           1,
					"v1/swap/market/funding_rate":         1,
					"v1/swap/market/funding_rate_history": 1,
					"v1/swap/market/risk_limit":           1,
				},
			},
			"private": map[string]interface{}{
				"get": map[string]interface{}{
					"v1/account/assets":                    1,
					"v1/account/transfer_records":          1,
					"v1/spot/deposit_records":              1,
					"v1/spot/withdraw_records":             1,
					"v1/swap/trade/open_order":             1,
					"v1/swap/trade/plan_order":             1,
					"v1/swap/trade/leverage":               1,
					"v1/swap/trade/history_order":          1,
					"v1/swap/trade/history_trade":          1,
					"v1/swap/trade/position_history":       1,
					"v1/swap/trade/positions":              1,
					"v1/swap/account/balance":              1,
					"v1/swap/user_data/assets_margin":      1,
					"v1/swap/user_data/position_side/dual": 1,
					"v1/agent/teams":                       1,
					"v1/agent/agent_links":                 1,
					"v1/agent/regular_overview":            1,
					"v1/agent/agent_sub_overview":          1,
					"v1/agent/partener_user_deposit":       1,
					"v1/agent/partener_users_data":         1,
					"v1/agent/affiliate_uids":              1,
					"v1/agent/affiliate_commission":        1,
					"v1/agent/internal_withdrawal_status":  1,
				},
				"post": map[string]interface{}{
					"v1/account/transfer":                  1,
					"v1/swap/trade/place_order":            1,
					"v1/swap/trade/batch_place_order":      1,
					"v1/swap/trade/edit_order":             1,
					"v1/swap/trade/batch_edit_order":       1,
					"v1/swap/trade/cancel_all_order":       1,
					"v1/swap/trade/leverage":               1,
					"v1/swap/trade/batch_leverage_margin":  1,
					"v1/swap/user_data/margin_type":        1,
					"v1/swap/user_data/position_side/dual": 1,
					"v1/agent/internal_withdrawal":         1,
				},
			},
		},
		"features": map[string]interface{}{
			"spot": nil,
			"swap": map[string]interface{}{
				"linear": map[string]interface{}{
					"sandbox": false,
					"createOrder": map[string]interface{}{
						"marginMode":   false,
						"triggerPrice": false,
						"triggerPriceType": map[string]interface{}{
							"mark":  true,
							"last":  true,
							"index": false,
						},
						"stopLossPrice":              true,
						"takeProfitPrice":            true,
						"attachedStopLossTakeProfit": nil,
						"timeInForce": map[string]interface{}{
							"IOC": true,
							"FOK": true,
							"PO":  true,
							"GTD": false,
						},
						"hedged":                 true,
						"selfTradePrevention":    false,
						"trailing":               true,
						"iceberg":                false,
						"leverage":               false,
						"marketBuyRequiresPrice": false,
						"marketBuyByCost":        false,
					},
					"createOrders": map[string]interface{}{
						"max": 5,
					},
					"fetchMyTrades": map[string]interface{}{
						"marginMode":     false,
						"daysBack":       182,
						"limit":          500,
						"untilDays":      7,
						"symbolRequired": false,
					},
					"fetchOrder": nil,
					"fetchOpenOrder": map[string]interface{}{
						"marginMode":     false,
						"trigger":        true,
						"trailing":       false,
						"symbolRequired": true,
					},
					"fetchOpenOrders": map[string]interface{}{
						"marginMode":     false,
						"limit":          500,
						"trigger":        true,
						"trailing":       false,
						"symbolRequired": true,
					},
					"fetchOrders": nil,
					"fetchCanceledAndClosedOrders": map[string]interface{}{
						"marginMode":     false,
						"limit":          500,
						"daysBack":       182,
						"untilDays":      7,
						"trigger":        false,
						"trailing":       false,
						"symbolRequired": false,
					},
					"fetchClosedOrders": nil,
					"fetchOHLCV": map[string]interface{}{
						"limit": 500,
					},
				},
				"inverse": nil,
			},
			"future": map[string]interface{}{
				"linear":  nil,
				"inverse": nil,
			},
		},
		"timeframes": map[string]interface{}{
			"1m":  "1m",
			"3m":  "3m",
			"5m":  "5m",
			"15m": "15m",
			"30m": "30m",
			"1h":  "1h",
			"2h":  "2h",
			"4h":  "4h",
			"6h":  "6h",
			"12h": "12h",
			"1d":  "1d",
		},
		"precisionMode": TICK_SIZE,
		"exceptions": map[string]interface{}{
			"exact": map[string]interface{}{
				"101001":                           AuthenticationError,
				"101103":                           AuthenticationError,
				"102001":                           BadRequest,
				"102002":                           PermissionDenied,
				"401":                              AuthenticationError,
				"500":                              ExchangeError,
				"501":                              ExchangeError,
				"506":                              ExchangeError,
				"510":                              RateLimitExceeded,
				"511":                              AuthenticationError,
				"513":                              BadRequest,
				"514":                              BadRequest,
				"600":                              BadRequest,
				"Position does not exist":          BadRequest,
				"Requires transaction permissions": PermissionDenied,
				"Service error":                    ExchangeError,
				"transfer failed":                  InsufficientFunds,
			},
			"broad": map[string]interface{}{
				"is missing": ArgumentsRequired,
			},
		},
		"commonCurrencies": map[string]interface{}{},
		"options": map[string]interface{}{
			"networks": map[string]interface{}{
				"ERC20": "ETH",
			},
			"timeInForce": map[string]interface{}{
				"GTC": "GTC",
				"FOK": "FOK",
				"IOC": "IOC",
				"PO":  "POST_ONLY",
			},
			"accountsByType": map[string]interface{}{
				"spot":    "SPOT",
				"swap":    "SWAP",
				"funding": "FUND",
			},
			"accountsById": map[string]interface{}{
				"SPOT": "spot",
				"SWAP": "swap",
				"FUND": "funding",
			},
		},
	})
}

/**
 * @method
 * @name bydfi#fetchMarkets
 * @description retrieves data on all markets for bydfi
 * @see https://developers.bydfi.com/en/swap/market#fetching-trading-rules-and-pairs
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func (this *BydfiCore) FetchMarkets(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		response := (<-this.PublicGetV1SwapMarketExchangeInfo(params))
		PanicOnError(response)
		//
		//     {
		//         "code": "200",
		//         "message": "success",
		//         "data": [
		//             {
		//                 "symbol": "CLANKER-USDT",
		//                 "baseAsset": "CLANKER",
		//                 "marginAsset": "USDT",
		//                 "quoteAsset": "USDT",
		//                 "contractFactor": "0.01",
		//                 "limitMaxQty": "50000",
		//                 "limitMinQty": "1",
		//                 "marketMaxQty": "10000",
		//                 "marketMinQty": "1",
		//                 "pricePrecision": "8",
		//                 "basePrecision": "8",
		//                 "feeRateTaker": "0.0006",
		//                 "feeRateMaker": "0.0002",
		//                 "liqFeeRate": "0.0006",
		//                 "openBuyLimitRateMax": "0.05",
		//                 "openSellLimitRateMax": "100",
		//                 "openBuyLimitRateMin": "0.98",
		//                 "openSellLimitRateMin": "0.05",
		//                 "priceOrderPrecision": "2",
		//                 "baseShowPrecision": "2",
		//                 "maxLeverageLevel": "20",
		//                 "volumePrecision": "2",
		//                 "maxLimitOrderNum": "200",
		//                 "maxPlanOrderNum": "10",
		//                 "reverse": false,
		//                 "onboardTime": "1763373600000",
		//                 "status": "NORMAL"
		//             },
		//             ...
		//         ],
		//         "success": true
		//     }
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseMarkets(data)
		return nil

	}()
	return ch
}
func (this *BydfiCore) ParseMarket(market interface{}) interface{} {
	//
	//     {
	//         "symbol": "CLANKER-USDT",
	//         "baseAsset": "CLANKER",
	//         "marginAsset": "USDT",
	//         "quoteAsset": "USDT",
	//         "contractFactor": "0.01",
	//         "limitMaxQty": "50000",
	//         "limitMinQty": "1",
	//         "marketMaxQty": "10000",
	//         "marketMinQty": "1",
	//         "pricePrecision": "8",
	//         "basePrecision": "8",
	//         "feeRateTaker": "0.0006",
	//         "feeRateMaker": "0.0002",
	//         "liqFeeRate": "0.0006",
	//         "openBuyLimitRateMax": "0.05",
	//         "openSellLimitRateMax": "100",
	//         "openBuyLimitRateMin": "0.98",
	//         "openSellLimitRateMin": "0.05",
	//         "priceOrderPrecision": "2",
	//         "baseShowPrecision": "2",
	//         "maxLeverageLevel": "20",
	//         "volumePrecision": "2",
	//         "maxLimitOrderNum": "200",
	//         "maxPlanOrderNum": "10",
	//         "reverse": false,
	//         "onboardTime": "1763373600000",
	//         "status": "NORMAL"
	//     }
	//
	var id interface{} = this.SafeString(market, "symbol")
	var baseId interface{} = this.SafeString(market, "baseAsset")
	var quoteId interface{} = this.SafeString(market, "quoteAsset")
	var settleId interface{} = this.SafeString(market, "marginAsset")
	var base interface{} = this.SafeCurrencyCode(baseId)
	var quote interface{} = this.SafeCurrencyCode(quoteId)
	var settle interface{} = this.SafeCurrencyCode(settleId)
	var symbol interface{} = Add(Add(Add(Add(base, "/"), quote), ":"), settle)
	var inverse interface{} = this.SafeBool(market, "reverse")
	var limitMaxQty interface{} = this.SafeString(market, "limitMaxQty")
	var marketMaxQty interface{} = this.SafeString(market, "marketMaxQty")
	var maxAmountString interface{} = Precise.StringMax(limitMaxQty, marketMaxQty)
	var marketMinQty interface{} = this.SafeString(market, "marketMinQty")
	var limitMinQty interface{} = this.SafeString(market, "limitMinQty")
	var minAmountString interface{} = Precise.StringMin(marketMinQty, limitMinQty)
	var contractSize interface{} = this.SafeString(market, "contractFactor")
	var pricePrecision interface{} = this.ParsePrecision(this.SafeString(market, "priceOrderPrecision"))
	var rawAmountPrecision interface{} = this.ParsePrecision(this.SafeString(market, "volumePrecision"))
	var amountPrecision interface{} = Precise.StringDiv(rawAmountPrecision, contractSize)
	var basePrecision interface{} = this.ParsePrecision(this.SafeString(market, "basePrecision"))
	var taker interface{} = this.SafeNumber(market, "feeRateTaker")
	var maker interface{} = this.SafeNumber(market, "feeRateMaker")
	var maxLeverage interface{} = this.SafeNumber(market, "maxLeverageLevel")
	var status interface{} = this.SafeString(market, "status")
	return this.SafeMarketStructure(map[string]interface{}{
		"id":             id,
		"symbol":         symbol,
		"base":           base,
		"quote":          quote,
		"settle":         settle,
		"baseId":         baseId,
		"quoteId":        quoteId,
		"settleId":       settleId,
		"type":           "swap",
		"spot":           false,
		"margin":         nil,
		"swap":           true,
		"future":         false,
		"option":         false,
		"active":         IsEqual(status, "NORMAL"),
		"contract":       true,
		"linear":         !IsTrue(inverse),
		"inverse":        inverse,
		"taker":          taker,
		"maker":          maker,
		"contractSize":   this.ParseNumber(contractSize),
		"expiry":         nil,
		"expiryDatetime": nil,
		"strike":         nil,
		"optionType":     nil,
		"precision": map[string]interface{}{
			"amount": this.ParseNumber(amountPrecision),
			"price":  this.ParseNumber(pricePrecision),
			"base":   this.ParseNumber(basePrecision),
		},
		"limits": map[string]interface{}{
			"leverage": map[string]interface{}{
				"min": nil,
				"max": maxLeverage,
			},
			"amount": map[string]interface{}{
				"min": this.ParseNumber(minAmountString),
				"max": this.ParseNumber(maxAmountString),
			},
			"price": map[string]interface{}{
				"min": nil,
				"max": nil,
			},
			"cost": map[string]interface{}{
				"min": nil,
				"max": nil,
			},
		},
		"created": this.Parse8601(this.SafeString(market, "createdAt")),
		"info":    market,
	})
}

/**
 * @method
 * @name bydfi#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://developers.bydfi.com/en/swap/market#depth-information
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return, could be 5, 10, 20, 50, 100, 500 or 1000 (default 500)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.loc] crypto location, default: us
 * @returns {object} A dictionary of [order book structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#order-book-structure} indexed by market symbols
 */
func (this *BydfiCore) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		limit := GetArg(optionalArgs, 0, nil)
		_ = limit
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes5708 := (<-this.LoadMarkets())
		PanicOnError(retRes5708)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", this.GetClosestLimit(limit))
		}

		response := (<-this.PublicGetV1SwapMarketDepth(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": 200,
		//         "message": "success",
		//         "data": {
		//             "lastUpdateId": "221780076",
		//             "symbol": "ETH-USDT",
		//             "asks": [
		//                 {
		//                     "price": "2958.21",
		//                     "amount": "39478"
		//                 },
		//                 ...
		//             ],
		//             "bids": [
		//                 {
		//                     "price": "2958.19",
		//                     "amount": "174498"
		//                 },
		//                 ...
		//             ],
		//             "e": "221780076"
		//         },
		//         "success": true
		//     }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		var timestamp interface{} = this.Milliseconds()
		var orderBook interface{} = this.ParseOrderBook(data, GetValue(market, "symbol"), timestamp, "bids", "asks", "price", "amount")
		AddElementToObject(orderBook, "nonce", this.SafeInteger(data, "lastUpdateId"))

		ch <- orderBook
		return nil

	}()
	return ch
}
func (this *BydfiCore) GetClosestLimit(limit interface{}) interface{} {
	var limits interface{} = []interface{}{5, 10, 20, 50, 100, 500, 1000}
	var result interface{} = 1000
	for i := 0; IsLessThan(i, GetArrayLength(limits)); i++ {
		if IsTrue(IsLessThanOrEqual(limit, GetValue(limits, i))) {
			result = GetValue(limits, i)
			break
		}
	}
	return result
}

/**
 * @method
 * @name bydfi#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://developers.bydfi.com/en/swap/market#recent-trades
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch (default 500, max 1000)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.fromId] retrieve from which trade ID to start. Default to retrieve the most recent trade records
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func (this *BydfiCore) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		since := GetArg(optionalArgs, 0, nil)
		_ = since
		limit := GetArg(optionalArgs, 1, nil)
		_ = limit
		params := GetArg(optionalArgs, 2, map[string]interface{}{})
		_ = params

		retRes6378 := (<-this.LoadMarkets())
		PanicOnError(retRes6378)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}

		response := (<-this.PublicGetV1SwapMarketTrades(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": 200,
		//         "message": "success",
		//         "data": [
		//             {
		//                 "id": "7407825178362667008",
		//                 "symbol": "ETH-USDT",
		//                 "price": "2970.49",
		//                 "quantity": "63",
		//                 "side": "SELL",
		//                 "time": 1766163153218
		//             }
		//         ],
		//         "success": true
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseTrades(data, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bydfi#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://developers.bydfi.com/en/swap/trade#historical-trades-query
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch trades for
 * @param {string} [params.contractType] FUTURE or DELIVERY, default is FUTURE
 * @param {string} [params.wallet] The unique code of a sub-wallet
 * @param {string} [params.orderType] order type ('LIMIT', 'MARKET', 'LIQ', 'LIMIT_CLOSE', 'MARKET_CLOSE', 'STOP', 'TAKE_PROFIT', 'STOP_MARKET', 'TAKE_PROFIT_MARKET' or 'TRAILING_STOP_MARKET')
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
 */
func (this *BydfiCore) FetchMyTrades(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes6838 := (<-this.LoadMarkets())
		PanicOnError(retRes6838)
		var paginate interface{} = this.SafeBool(params, "paginate", false)
		if IsTrue(paginate) {
			var maxLimit interface{} = 500
			params = this.Omit(params, "paginate")
			params = this.Extend(params, map[string]interface{}{
				"paginationDirection": "backward",
			})

			paginatedResponse := (<-this.FetchPaginatedCallDynamic("fetchMyTrades", symbol, since, limit, params, maxLimit, true))
			PanicOnError(paginatedResponse)

			ch <- this.SortBy(paginatedResponse, "timestamp")
			return nil
		}
		var contractType interface{} = "FUTURE"
		contractTypeparamsVariable := this.HandleOptionAndParams(params, "fetchMyTrades", "contractType", contractType)
		contractType = GetValue(contractTypeparamsVariable, 0)
		params = GetValue(contractTypeparamsVariable, 1)
		var request interface{} = map[string]interface{}{
			"contractType": contractType,
		}
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			AddElementToObject(request, "symbol", GetValue(market, "id"))
		}
		params = this.HandleSinceAndUntil("fetchMyTrades", since, params)
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}

		response := (<-this.PrivateGetV1SwapTradeHistoryTrade(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": 200,
		//         "message": "success",
		//         "data": [
		//             {
		//                 "orderId": "7408919189505597440",
		//                 "wallet": "W001",
		//                 "symbol": "ETH-USDC",
		//                 "time": "1766423985842",
		//                 "dealPrice": "3032.45",
		//                 "dealVolume": "1",
		//                 "fee": "0",
		//                 "side": "BUY",
		//                 "type": "2",
		//                 "liqPrice": null,
		//                 "basePrecision": "8",
		//                 "baseShowPrecision": "2",
		//                 "tradePnl": "0",
		//                 "marginType": "CROSS",
		//                 "leverageLevel": 1
		//             }
		//         ],
		//         "success": true
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseTrades(data, market, since, limit)
		return nil

	}()
	return ch
}
func (this *BydfiCore) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{} {
	//
	// fetchTrades
	//     {
	//         "id": "7407825178362667008",
	//         "symbol": "ETH-USDT",
	//         "price": "2970.49",
	//         "quantity": "63",
	//         "side": "SELL",
	//         "time": 1766163153218
	//     }
	//
	// fetchMyTrades
	//     {
	//         "orderId": "7408919189505597440",
	//         "wallet": "W001",
	//         "symbol": "ETH-USDC",
	//         "time": "1766423985842",
	//         "dealPrice": "3032.45",
	//         "dealVolume": "1",
	//         "fee": "0",
	//         "side": "BUY",
	//         "type": "2",
	//         "liqPrice": null,
	//         "basePrecision": "8",
	//         "baseShowPrecision": "2",
	//         "tradePnl": "0",
	//         "marginType": "CROSS",
	//         "leverageLevel": 1
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(trade, "symbol")
	market = this.SafeMarket(marketId, market)
	var timestamp interface{} = this.SafeInteger(trade, "time")
	var fee interface{} = nil
	var rawType interface{} = this.SafeString(trade, "type")
	var feeCost interface{} = this.SafeString(trade, "fee")
	if IsTrue(!IsEqual(feeCost, nil)) {
		fee = map[string]interface{}{
			"cost":     feeCost,
			"currency": GetValue(market, "settle"),
		}
	}
	var orderId interface{} = this.SafeString(trade, "orderId")
	var side interface{} = nil // fetchMyTrades always returns side BUY
	if IsTrue(IsEqual(orderId, nil)) {
		// from fetchTrades
		side = this.SafeStringLower(trade, "side")
	}
	return this.SafeTrade(map[string]interface{}{
		"info":         trade,
		"timestamp":    timestamp,
		"datetime":     this.Iso8601(timestamp),
		"symbol":       GetValue(market, "symbol"),
		"id":           this.SafeString(trade, "id"),
		"order":        orderId,
		"type":         this.ParseTradeType(rawType),
		"side":         side,
		"takerOrMaker": nil,
		"price":        this.SafeString2(trade, "price", "dealPrice"),
		"amount":       this.SafeString2(trade, "quantity", "dealVolume"),
		"cost":         nil,
		"fee":          fee,
	}, market)
}
func (this *BydfiCore) ParseTradeType(typeVar interface{}) interface{} {
	var types interface{} = map[string]interface{}{
		"1": "limit",
		"2": "market",
		"3": "liquidation",
	}
	return this.SafeString(types, typeVar, typeVar)
}

/**
 * @method
 * @name bydfi#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://developers.bydfi.com/en/swap/market#candlestick-data
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch (max 500)
 * @param {object} [params] extra parameters specific to the bitteam api endpoint
 * @param {int} [params.until] timestamp in ms of the latest candle to fetch
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func (this *BydfiCore) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		timeframe := GetArg(optionalArgs, 0, "1m")
		_ = timeframe
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes8268 := (<-this.LoadMarkets())
		PanicOnError(retRes8268)
		var maxLimit interface{} = 500 // docs says max 1500, but in practice only 500 works
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchOHLCV", "paginate")
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {

			ch <- this.FetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, params, maxLimit)
			return nil
		}
		var market interface{} = this.Market(symbol)
		var interval interface{} = this.SafeString(this.Timeframes, timeframe, timeframe)
		var request interface{} = map[string]interface{}{
			"symbol":   GetValue(market, "id"),
			"interval": interval,
		}
		var startTime interface{} = since
		var numberOfCandles interface{} = Ternary(IsTrue(limit), limit, maxLimit)
		var until interface{} = nil
		untilparamsVariable := this.HandleOptionAndParams(params, "fetchOHLCV", "until")
		until = GetValue(untilparamsVariable, 0)
		params = GetValue(untilparamsVariable, 1)
		var now interface{} = this.Milliseconds()
		var duration interface{} = Multiply(this.ParseTimeframe(timeframe), 1000)
		var timeDelta interface{} = Multiply(duration, numberOfCandles)
		if IsTrue(IsTrue(IsEqual(startTime, nil)) && IsTrue(IsEqual(until, nil))) {
			startTime = Subtract(now, timeDelta)
			until = now
		} else if IsTrue(IsEqual(until, nil)) {
			until = Add(startTime, timeDelta)
			if IsTrue(IsGreaterThan(until, now)) {
				until = now
			}
		} else if IsTrue(IsEqual(startTime, nil)) {
			startTime = Subtract(until, timeDelta)
		}
		AddElementToObject(request, "startTime", startTime)
		AddElementToObject(request, "endTime", until)
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}

		response := (<-this.PublicGetV1SwapMarketKlines(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": 200,
		//         "message": "success",
		//         "data": [
		//             {
		//                 "s": "ETH-USDT",
		//                 "t": "1766166000000",
		//                 "c": "2964.990000000000000000",
		//                 "o": "2967.830000000000000000",
		//                 "h": "2967.830000000000000000",
		//                 "l": "2964.130000000000000000",
		//                 "v": "20358.000000000000000000"
		//             }
		//         ],
		//         "success": true
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var result interface{} = this.ParseOHLCVs(data, market, timeframe, since, limit)

		ch <- result
		return nil

	}()
	return ch
}
func (this *BydfiCore) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "s": "ETH-USDT",
	//         "t": "1766166000000",
	//         "c": "2964.990000000000000000",
	//         "o": "2967.830000000000000000",
	//         "h": "2967.830000000000000000",
	//         "l": "2964.130000000000000000",
	//         "v": "20358.000000000000000000"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	return []interface{}{this.SafeInteger(ohlcv, "t"), this.SafeNumber(ohlcv, "o"), this.SafeNumber(ohlcv, "h"), this.SafeNumber(ohlcv, "l"), this.SafeNumber(ohlcv, "c"), this.SafeNumber(ohlcv, "v")}
}

/**
 * @method
 * @name bydfi#fetchTickers
 * @see https://developers.bydfi.com/en/swap/market#24hr-price-change-statistics
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func (this *BydfiCore) FetchTickers(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes9188 := (<-this.LoadMarkets())
		PanicOnError(retRes9188)

		response := (<-this.PublicGetV1SwapMarketTicker24hr(params))
		PanicOnError(response)
		//
		//     {
		//         "code": 200,
		//         "message": "success",
		//         "data": [
		//             {
		//                 "symbol": "BTC-USDT",
		//                 "open": "86452.9",
		//                 "high": "89371.2",
		//                 "low": "84418.5",
		//                 "last": "87050.3",
		//                 "vol": "12938783",
		//                 "time": 1766169423872
		//             }
		//         ],
		//         "success": true
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseTickers(data, symbols)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bydfi#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://developers.bydfi.com/en/swap/market#24hr-price-change-statistics
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func (this *BydfiCore) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes9528 := (<-this.LoadMarkets())
		PanicOnError(retRes9528)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}

		response := (<-this.PublicGetV1SwapMarketTicker24hr(this.Extend(request, params)))
		PanicOnError(response)
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var ticker interface{} = this.SafeDict(data, 0, map[string]interface{}{})

		ch <- this.ParseTicker(ticker, market)
		return nil

	}()
	return ch
}
func (this *BydfiCore) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{} {
	//
	// fetchTicker/fetchTickers
	//     {
	//         "symbol": "BTC-USDT",
	//         "open": "86452.9",
	//         "high": "89371.2",
	//         "low": "84418.5",
	//         "last": "87050.3",
	//         "vol": "12938783",
	//         "time": 1766169423872
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString2(ticker, "symbol", "s")
	market = this.SafeMarket(marketId, market)
	var timestamp interface{} = this.SafeInteger2(ticker, "time", "E")
	var last interface{} = this.SafeString2(ticker, "last", "c")
	return this.SafeTicker(map[string]interface{}{
		"symbol":        this.SafeSymbol(marketId, market),
		"timestamp":     timestamp,
		"datetime":      this.Iso8601(timestamp),
		"high":          this.SafeString2(ticker, "high", "h"),
		"low":           this.SafeString2(ticker, "low", "l"),
		"bid":           nil,
		"bidVolume":     nil,
		"ask":           nil,
		"askVolume":     nil,
		"vwap":          nil,
		"open":          this.SafeString2(ticker, "open", "o"),
		"close":         last,
		"last":          last,
		"previousClose": nil,
		"change":        nil,
		"percentage":    nil,
		"average":       nil,
		"baseVolume":    this.SafeString2(ticker, "vol", "v"),
		"quoteVolume":   nil,
		"markPrice":     nil,
		"indexPrice":    nil,
		"info":          ticker,
	}, market)
}

/**
 * @method
 * @name bydfi#fetchFundingRate
 * @description fetch the current funding rate
 * @see https://developers.bydfi.com/en/swap/market#recent-funding-rate
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/?id=funding-rate-structure}
 */
func (this *BydfiCore) FetchFundingRate(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes10168 := (<-this.LoadMarkets())
		PanicOnError(retRes10168)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}

		response := (<-this.PublicGetV1SwapMarketFundingRate(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": 200,
		//         "message": "success",
		//         "data": {
		//             "symbol": "BTC-USDT",
		//             "lastFundingRate": "0.0001",
		//             "nextFundingTime": "1766188800000",
		//             "time": "1766170665007"
		//         },
		//         "success": true
		//     }
		//
		var data interface{} = this.SafeDict(response, "data")

		ch <- this.ParseFundingRate(data, market)
		return nil

	}()
	return ch
}
func (this *BydfiCore) ParseFundingRate(contract interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "symbol": "BTC-USDT",
	//         "lastFundingRate": "0.0001",
	//         "nextFundingTime": "1766188800000",
	//         "time": "1766170665007"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(contract, "symbol")
	var symbol interface{} = this.SafeSymbol(marketId, market)
	var timestamp interface{} = this.SafeInteger(contract, "time")
	var nextFundingTimestamp interface{} = this.SafeInteger(contract, "nextFundingTime")
	return map[string]interface{}{
		"info":                     contract,
		"symbol":                   symbol,
		"markPrice":                nil,
		"indexPrice":               nil,
		"interestRate":             nil,
		"estimatedSettlePrice":     nil,
		"timestamp":                timestamp,
		"datetime":                 this.Iso8601(timestamp),
		"fundingRate":              this.SafeNumber(contract, "lastFundingRate"),
		"fundingTimestamp":         nil,
		"fundingDatetime":          nil,
		"nextFundingRate":          nil,
		"nextFundingTimestamp":     nextFundingTimestamp,
		"nextFundingDatetime":      this.Iso8601(nextFundingTimestamp),
		"previousFundingRate":      nil,
		"previousFundingTimestamp": nil,
		"previousFundingDatetime":  nil,
		"interval":                 nil,
	}
}

/**
 * @method
 * @name bydfi#fetchFundingRateHistory
 * @description fetches historical funding rate prices
 * @see https://developers.bydfi.com/en/swap/market#historical-funding-rates
 * @param {string} symbol unified symbol of the market to fetch the funding rate history for
 * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
 * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/?id=funding-rate-history-structure} to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest funding rate to fetch
 * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/?id=funding-rate-history-structure}
 */
func (this *BydfiCore) FetchFundingRateHistory(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchFundingRateHistory() requires a symbol argument")))
		}

		retRes10908 := (<-this.LoadMarkets())
		PanicOnError(retRes10908)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}
		var until interface{} = nil
		untilparamsVariable := this.HandleOptionAndParams(params, "fetchFundingRateHistory", "until")
		until = GetValue(untilparamsVariable, 0)
		params = GetValue(untilparamsVariable, 1)
		if IsTrue(!IsEqual(until, nil)) {
			AddElementToObject(request, "endTime", until)
		}

		response := (<-this.PublicGetV1SwapMarketFundingRateHistory(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": 200,
		//         "message": "success",
		//         "data": [
		//             {
		//                 "symbol": "ETH-USDT",
		//                 "fundingRate": "0.00000025",
		//                 "fundingTime": "1765584000000",
		//                 "markPrice": "3083.2"
		//             }
		//         ],
		//         "success": true
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseFundingRateHistories(data, market, since, limit)
		return nil

	}()
	return ch
}
func (this *BydfiCore) ParseFundingRateHistory(contract interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "symbol": "ETH-USDT",
	//         "fundingRate": "0.00000025",
	//         "fundingTime": "1765584000000",
	//         "markPrice": "3083.2"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(contract, "symbol")
	var timestamp interface{} = this.SafeInteger(contract, "fundingTime")
	return map[string]interface{}{
		"info":        contract,
		"symbol":      this.SafeSymbol(marketId, market),
		"fundingRate": this.SafeNumber(contract, "fundingRate"),
		"timestamp":   timestamp,
		"datetime":    this.Iso8601(timestamp),
	}
}

/**
 * @method
 * @name bydfi#createOrder
 * @description create a trade order
 * @see https://developers.bydfi.com/en/swap/trade#placing-an-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.wallet] The unique code of a sub-wallet. W001 is the default wallet and the main wallet code of the contract
 * @param {bool} [params.hedged] true for hedged mode, false for one way mode, default is false
 * @param {string} [params.clientOrderId] Custom order ID, must be unique for open orders
 * @param {string} [params.timeInForce] 'GTC' (Good Till Cancelled), 'FOK' (Fill Or Kill), 'IOC' (Immediate Or Cancel), 'PO' (Post Only)
 * @param {bool} [params.postOnly] true or false, whether the order is post-only
 * @param {bool} [params.reduceOnly] true or false, true or false whether the order is reduce-only
 * @param {float} [params.stopLossPrice] The price a stop loss order is triggered at
 * @param {float} [params.takeProfitPrice] The price a take profit order is triggered at
 * @param {float} [params.trailingTriggerPrice] the price to activate a trailing order, default uses the price argument or market price if price is not provided
 * @param {float} [params.trailingPercent] the percent to trail away from the current market price
 * @param {string} [params.triggerPriceType] 'MARK_PRICE' or 'CONTRACT_PRICE', default is 'CONTRACT_PRICE', the price type used to trigger stop orders
 * @param {bool} [params.closePosition] true or false, whether to close all positions after triggering, only supported in STOP_MARKET and TAKE_PROFIT_MARKET; not used with quantity;
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *BydfiCore) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		price := GetArg(optionalArgs, 0, nil)
		_ = price
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes11728 := (<-this.LoadMarkets())
		PanicOnError(retRes11728)
		var market interface{} = this.Market(symbol)
		var orderRequest interface{} = this.CreateOrderRequest(symbol, typeVar, side, amount, price, params)
		var wallet interface{} = "W001"
		walletparamsVariable := this.HandleOptionAndParams(params, "createOrder", "wallet", wallet)
		wallet = GetValue(walletparamsVariable, 0)
		params = GetValue(walletparamsVariable, 1)
		orderRequest = this.Extend(orderRequest, map[string]interface{}{
			"wallet": wallet,
		})

		response := (<-this.PrivatePostV1SwapTradePlaceOrder(orderRequest))
		PanicOnError(response)
		//
		//     {
		//         "code": 200,
		//         "message": "success",
		//         "data": {
		//             "wallet": "W001",
		//             "symbol": "ETH-USDT",
		//             "orderId": "7408875768086683648",
		//             "clientOrderId": "7408875768086683648",
		//             "price": "1000",
		//             "origQty": "10",
		//             "avgPrice": null,
		//             "executedQty": "0",
		//             "orderType": "LIMIT",
		//             "side": "BUY",
		//             "status": "NEW",
		//             "stopPrice": null,
		//             "activatePrice": null,
		//             "timeInForce": null,
		//             "workingType": "CONTRACT_PRICE",
		//             "positionSide": "BOTH",
		//             "priceProtect": false,
		//             "reduceOnly": false,
		//             "closePosition": false,
		//             "createTime": "1766413633367",
		//             "updateTime": "1766413633367"
		//         },
		//         "success": true
		//     }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})

		ch <- this.ParseOrder(data, market)
		return nil

	}()
	return ch
}
func (this *BydfiCore) CreateOrderRequest(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{} {
	price := GetArg(optionalArgs, 0, nil)
	_ = price
	params := GetArg(optionalArgs, 1, map[string]interface{}{})
	_ = params
	var market interface{} = this.Market(symbol)
	var request interface{} = map[string]interface{}{
		"symbol": GetValue(market, "id"),
		"side":   ToUpper(side),
	}
	var stopLossPrice interface{} = this.SafeString(params, "stopLossPrice")
	var isStopLossOrder interface{} = (!IsEqual(stopLossPrice, nil))
	var takeProfitPrice interface{} = this.SafeString(params, "takeProfitPrice")
	var isTakeProfitOrder interface{} = (!IsEqual(takeProfitPrice, nil))
	var trailingPercent interface{} = this.SafeString(params, "trailingPercent")
	var isTailingStopOrder interface{} = (!IsEqual(trailingPercent, nil))
	var stopPrice interface{} = nil
	if IsTrue(IsTrue(isStopLossOrder) || IsTrue(isTakeProfitOrder)) {
		stopPrice = Ternary(IsTrue(isStopLossOrder), stopLossPrice, takeProfitPrice)
		params = this.Omit(params, []interface{}{"stopLossPrice", "takeProfitPrice"})
		AddElementToObject(request, "stopPrice", this.PriceToPrecision(symbol, stopPrice))
	} else if IsTrue(isTailingStopOrder) {
		params = this.Omit(params, []interface{}{"trailingPercent"})
		AddElementToObject(request, "callbackRate", trailingPercent)
		var trailingTriggerPrice interface{} = this.NumberToString(price)
		trailingTriggerPriceparamsVariable := this.HandleParamString(params, "trailingTriggerPrice", trailingTriggerPrice)
		trailingTriggerPrice = GetValue(trailingTriggerPriceparamsVariable, 0)
		params = GetValue(trailingTriggerPriceparamsVariable, 1)
		if IsTrue(!IsEqual(trailingTriggerPrice, nil)) {
			AddElementToObject(request, "activationPrice", this.PriceToPrecision(symbol, trailingTriggerPrice))
			params = this.Omit(params, []interface{}{"trailingTriggerPrice"})
		}
	}
	typeVar = ToUpper(typeVar)
	var isMarketOrder interface{} = (IsTrue(IsTrue(IsTrue((IsEqual(typeVar, "MARKET"))) || IsTrue((IsEqual(typeVar, "STOP_MARKET")))) || IsTrue((IsEqual(typeVar, "TAKE_PROFIT_MARKET")))) || IsTrue((IsEqual(typeVar, "TRAILING_STOP_MARKET"))))
	if IsTrue(isMarketOrder) {
		if IsTrue(IsEqual(typeVar, "MARKET")) {
			if IsTrue(isStopLossOrder) {
				typeVar = "STOP_MARKET"
			} else if IsTrue(isTakeProfitOrder) {
				typeVar = "TAKE_PROFIT_MARKET"
			} else if IsTrue(isTailingStopOrder) {
				typeVar = "TRAILING_STOP_MARKET"
			}
		}
	} else {
		if IsTrue(IsEqual(price, nil)) {
			panic(ArgumentsRequired(Add(Add(Add(this.Id, " createOrder() requires a price argument for a "), typeVar), " order")))
		}
		AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
		if IsTrue(isStopLossOrder) {
			typeVar = "STOP"
		} else if IsTrue(isTakeProfitOrder) {
			typeVar = "TAKE_PROFIT"
		}
	}
	AddElementToObject(request, "type", typeVar)
	var hedged interface{} = false
	hedgedparamsVariable := this.HandleOptionAndParams(params, "createOrder", "hedged", hedged)
	hedged = GetValue(hedgedparamsVariable, 0)
	params = GetValue(hedgedparamsVariable, 1)
	var reduceOnly interface{} = this.SafeBool(params, "reduceOnly", false)
	if IsTrue(hedged) {
		params = this.Omit(params, "reduceOnly")
		if IsTrue(IsEqual(side, "buy")) {
			AddElementToObject(request, "positionSide", Ternary(IsTrue(reduceOnly), "SHORT", "LONG"))
		} else if IsTrue(IsEqual(side, "sell")) {
			AddElementToObject(request, "positionSide", Ternary(IsTrue(reduceOnly), "LONG", "SHORT"))
		}
	}
	var closePosition interface{} = this.SafeBool(params, "closePosition", false)
	if !IsTrue(closePosition) {
		params = this.Omit(params, "closePosition")
		AddElementToObject(request, "quantity", this.AmountToPrecision(symbol, amount))
	} else if IsTrue(IsTrue((!IsEqual(typeVar, "STOP_MARKET"))) && IsTrue((!IsEqual(typeVar, "TAKE_PROFIT_MARKET")))) {
		panic(NotSupported(Add(this.Id, " createOrder() closePosition is only supported for stopLoss and takeProfit market orders")))
	}
	var timeInForce interface{} = this.HandleTimeInForce(params)
	var postOnly interface{} = false
	postOnlyparamsVariable := this.HandlePostOnly(isMarketOrder, IsEqual(timeInForce, "POST_ONLY"), params)
	postOnly = GetValue(postOnlyparamsVariable, 0)
	params = GetValue(postOnlyparamsVariable, 1)
	if IsTrue(postOnly) {
		timeInForce = "POST_ONLY"
	}
	if IsTrue(!IsEqual(timeInForce, nil)) {
		AddElementToObject(request, "timeInForce", timeInForce)
		params = this.Omit(params, "timeInForce")
	}
	if IsTrue(IsTrue(IsTrue(isStopLossOrder) || IsTrue(isTakeProfitOrder)) || IsTrue(isTailingStopOrder)) {
		var workingType interface{} = "CONTRACT_PRICE"
		workingTypeparamsVariable := this.HandleOptionAndParams(params, "createOrder", "triggerPriceType", workingType)
		workingType = GetValue(workingTypeparamsVariable, 0)
		params = GetValue(workingTypeparamsVariable, 1)
		AddElementToObject(request, "workingType", this.EncodeWorkingType(workingType))
	}
	return this.Extend(request, params)
}
func (this *BydfiCore) EncodeWorkingType(workingType interface{}) interface{} {
	var types interface{} = map[string]interface{}{
		"markPrice":     "MARK_PRICE",
		"mark":          "MARK_PRICE",
		"contractPrice": "CONTRACT_PRICE",
		"contract":      "CONTRACT_PRICE",
		"last":          "CONTRACT_PRICE",
	}
	return this.SafeString(types, workingType, workingType)
}

/**
 * @method
 * @name bydfi#createOrders
 * @description create a list of trade orders
 * @see https://developers.bydfi.com/en/swap/trade#batch-order-placement
 * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.wallet] The unique code of a sub-wallet. W001 is the default wallet and the main wallet code of the contract
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *BydfiCore) CreateOrders(orders interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes13348 := (<-this.LoadMarkets())
		PanicOnError(retRes13348)
		var length interface{} = GetArrayLength(orders)
		if IsTrue(IsGreaterThan(length, 5)) {
			panic(BadRequest(Add(this.Id, " createOrders() accepts a maximum of 5 orders")))
		}
		var ordersRequests interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(orders)); i++ {
			var rawOrder interface{} = GetValue(orders, i)
			var symbol interface{} = this.SafeString(rawOrder, "symbol")
			var typeVar interface{} = this.SafeString(rawOrder, "type")
			var side interface{} = this.SafeString(rawOrder, "side")
			var amount interface{} = this.SafeNumber(rawOrder, "amount")
			var price interface{} = this.SafeNumber(rawOrder, "price")
			var orderParams interface{} = this.SafeDict(rawOrder, "params", map[string]interface{}{})
			var orderRequest interface{} = this.CreateOrderRequest(symbol, typeVar, side, amount, price, orderParams)
			AppendToArray(&ordersRequests, orderRequest)
		}
		var wallet interface{} = "W001"
		walletparamsVariable := this.HandleOptionAndParams(params, "createOrder", "wallet", wallet)
		wallet = GetValue(walletparamsVariable, 0)
		params = GetValue(walletparamsVariable, 1)
		var request interface{} = map[string]interface{}{
			"wallet": wallet,
			"orders": ordersRequests,
		}

		response := (<-this.PrivatePostV1SwapTradeBatchPlaceOrder(this.Extend(request, params)))
		PanicOnError(response)
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseOrders(data)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bydfi#editOrder
 * @description edit a trade order
 * @see https://developers.bydfi.com/en/swap/trade#order-modification
 * @param {string} id order id (mandatory if params.clientOrderId is not provided)
 * @param {string} [symbol] unified symbol of the market to create an order in
 * @param {string} [type] not used by bydfi editOrder
 * @param {string} [side] 'buy' or 'sell'
 * @param {float} [amount] how much of the currency you want to trade in units of the base currency
 * @param {float} [price] the price for the order, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.clientOrderId] a unique identifier for the order (could be alternative to id)
 * @param {string} [params.wallet] The unique code of a sub-wallet. W001 is the default wallet and the main wallet code of the contract
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *BydfiCore) EditOrder(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		amount := GetArg(optionalArgs, 0, nil)
		_ = amount
		price := GetArg(optionalArgs, 1, nil)
		_ = price
		params := GetArg(optionalArgs, 2, map[string]interface{}{})
		_ = params

		retRes13798 := (<-this.LoadMarkets())
		PanicOnError(retRes13798)
		var request interface{} = this.CreateEditOrderRequest(id, symbol, "limit", side, amount, price, params)
		var wallet interface{} = "W001"
		walletparamsVariable := this.HandleOptionAndParams(params, "editOrder", "wallet", wallet)
		wallet = GetValue(walletparamsVariable, 0)
		params = GetValue(walletparamsVariable, 1)
		AddElementToObject(request, "wallet", wallet)

		response := (<-this.PrivatePostV1SwapTradeEditOrder(request))
		PanicOnError(response)
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})

		ch <- this.ParseOrder(data)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bydfi#editOrders
 * @description edit a list of trade orders
 * @see https://developers.bydfi.com/en/swap/trade#batch-order-modification
 * @param {Array} orders list of orders to edit, each object should contain the parameters required by editOrder, namely id, symbol, amount, price and params
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.wallet] The unique code of a sub-wallet. W001 is the default wallet and the main wallet code of the contract
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *BydfiCore) EditOrders(orders interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes14008 := (<-this.LoadMarkets())
		PanicOnError(retRes14008)
		var length interface{} = GetArrayLength(orders)
		if IsTrue(IsGreaterThan(length, 5)) {
			panic(BadRequest(Add(this.Id, " editOrders() accepts a maximum of 5 orders")))
		}
		var ordersRequests interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(orders)); i++ {
			var rawOrder interface{} = GetValue(orders, i)
			var id interface{} = this.SafeString(rawOrder, "id")
			var symbol interface{} = this.SafeString(rawOrder, "symbol")
			var side interface{} = this.SafeString(rawOrder, "side")
			var amount interface{} = this.SafeNumber(rawOrder, "amount")
			var price interface{} = this.SafeNumber(rawOrder, "price")
			var orderParams interface{} = this.SafeDict(rawOrder, "params", map[string]interface{}{})
			var orderRequest interface{} = this.CreateEditOrderRequest(id, symbol, "limit", side, amount, price, orderParams)
			AppendToArray(&ordersRequests, orderRequest)
		}
		var wallet interface{} = "W001"
		walletparamsVariable := this.HandleOptionAndParams(params, "editOrder", "wallet", wallet)
		wallet = GetValue(walletparamsVariable, 0)
		params = GetValue(walletparamsVariable, 1)
		var request interface{} = map[string]interface{}{
			"wallet":     wallet,
			"editOrders": ordersRequests,
		}

		response := (<-this.PrivatePostV1SwapTradeBatchEditOrder(this.Extend(request, params)))
		PanicOnError(response)
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseOrders(data)
		return nil

	}()
	return ch
}
func (this *BydfiCore) CreateEditOrderRequest(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) interface{} {
	amount := GetArg(optionalArgs, 0, nil)
	_ = amount
	price := GetArg(optionalArgs, 1, nil)
	_ = price
	params := GetArg(optionalArgs, 2, map[string]interface{}{})
	_ = params
	var clientOrderId interface{} = this.SafeString(params, "clientOrderId")
	var request interface{} = map[string]interface{}{}
	if IsTrue(IsTrue((IsEqual(id, nil))) && IsTrue((IsEqual(clientOrderId, nil)))) {
		panic(ArgumentsRequired(Add(this.Id, " editOrder() requires an id argument or a clientOrderId parameter")))
	} else if IsTrue(!IsEqual(id, nil)) {
		AddElementToObject(request, "orderId", id)
	}
	var market interface{} = this.Market(symbol)
	AddElementToObject(request, "symbol", GetValue(market, "id"))
	if IsTrue(!IsEqual(side, nil)) {
		AddElementToObject(request, "side", ToUpper(side))
	}
	if IsTrue(!IsEqual(amount, nil)) {
		AddElementToObject(request, "quantity", this.AmountToPrecision(symbol, amount))
	}
	if IsTrue(!IsEqual(price, nil)) {
		AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
	}
	return this.Extend(request, params)
}

/**
 * @method
 * @name bydfi#cancelAllOrders
 * @description cancel all open orders in a market
 * @see https://developers.bydfi.com/en/swap/trade#complete-order-cancellation
 * @param {string} symbol unified market symbol of the market to cancel orders in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.wallet] The unique code of a sub-wallet. W001 is the default wallet and the main wallet code of the contract
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *BydfiCore) CancelAllOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " cancelAllOrders() requires a symbol argument")))
		}

		retRes14648 := (<-this.LoadMarkets())
		PanicOnError(retRes14648)
		var market interface{} = this.Market(symbol)
		var wallet interface{} = "W001"
		walletparamsVariable := this.HandleOptionAndParams(params, "cancelAllOrders", "wallet", wallet)
		wallet = GetValue(walletparamsVariable, 0)
		params = GetValue(walletparamsVariable, 1)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
			"wallet": wallet,
		}

		response := (<-this.PrivatePostV1SwapTradeCancelAllOrder(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": 200,
		//         "message": "success",
		//         "data": [
		//             {
		//                 "wallet": "W001",
		//                 "symbol": "ETH-USDT",
		//                 "orderId": "7408875768086683648",
		//                 "clientOrderId": "7408875768086683648",
		//                 "price": "1000",
		//                 "origQty": "10",
		//                 "avgPrice": "0",
		//                 "executedQty": "0",
		//                 "orderType": "LIMIT",
		//                 "side": "BUY",
		//                 "status": "CANCELED",
		//                 "stopPrice": null,
		//                 "activatePrice": null,
		//                 "timeInForce": null,
		//                 "workingType": "CONTRACT_PRICE",
		//                 "positionSide": "BOTH",
		//                 "priceProtect": false,
		//                 "reduceOnly": false,
		//                 "closePosition": false,
		//                 "createTime": "1766413633367",
		//                 "updateTime": "1766413633370"
		//             }
		//         ],
		//         "success": true
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseOrders(data, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bydfi#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://developers.bydfi.com/en/swap/trade#pending-order-query
 * @see https://developers.bydfi.com/en/swap/trade#planned-order-query
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {bool} [params.trigger] true or false, whether to fetch conditional orders only
 * @param {string} [params.wallet] The unique code of a sub-wallet. W001 is the default wallet and the main wallet code of the contract
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *BydfiCore) FetchOpenOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchOpenOrders() requires a symbol argument")))
		}

		retRes15278 := (<-this.LoadMarkets())
		PanicOnError(retRes15278)
		var market interface{} = this.Market(symbol)
		var wallet interface{} = "W001"
		walletparamsVariable := this.HandleOptionAndParams(params, "fetchOpenOrders", "wallet", wallet)
		wallet = GetValue(walletparamsVariable, 0)
		params = GetValue(walletparamsVariable, 1)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
			"wallet": wallet,
		}
		var response interface{} = nil
		var trigger interface{} = false
		triggerparamsVariable := this.HandleOptionAndParams(params, "fetchOpenOrders", "trigger", trigger)
		trigger = GetValue(triggerparamsVariable, 0)
		params = GetValue(triggerparamsVariable, 1)
		if !IsTrue(trigger) {
			//
			//     {
			//         "code": 200,
			//         "message": "success",
			//         "data": [
			//             {
			//                 "wallet": "W001",
			//                 "symbol": "ETH-USDC",
			//                 "orderId": "7408896083240091648",
			//                 "clientOrderId": "7408896083240091648",
			//                 "price": "999",
			//                 "origQty": "1",
			//                 "avgPrice": "0",
			//                 "executedQty": "0",
			//                 "orderType": "LIMIT",
			//                 "side": "BUY",
			//                 "status": "NEW",
			//                 "stopPrice": null,
			//                 "activatePrice": null,
			//                 "timeInForce": null,
			//                 "workingType": "CONTRACT_PRICE",
			//                 "positionSide": "BOTH",
			//                 "priceProtect": false,
			//                 "reduceOnly": false,
			//                 "closePosition": false,
			//                 "createTime": "1766418476877",
			//                 "updateTime": "1766418476880"
			//             }
			//         ],
			//         "success": true
			//     }
			//

			response = (<-this.PrivateGetV1SwapTradeOpenOrder(this.Extend(request, params)))
			PanicOnError(response)
		} else {

			response = (<-this.PrivateGetV1SwapTradePlanOrder(this.Extend(request, params)))
			PanicOnError(response)
		}
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseOrders(data, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bydfi#fetchOpenOrder
 * @description fetch an open order by the id
 * @see https://developers.bydfi.com/en/swap/trade#pending-order-query
 * @see https://developers.bydfi.com/en/swap/trade#planned-order-query
 * @param {string} id order id (mandatory if params.clientOrderId is not provided)
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {bool} [params.trigger] true or false, whether to fetch conditional orders only
 * @param {string} [params.clientOrderId] a unique identifier for the order (could be alternative to id)
 * @param {string} [params.wallet] The unique code of a sub-wallet. W001 is the default wallet and the main wallet code of the contract
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *BydfiCore) FetchOpenOrder(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchOpenOrder() requires a symbol argument")))
		}

		retRes15978 := (<-this.LoadMarkets())
		PanicOnError(retRes15978)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		var clientOrderId interface{} = this.SafeString(params, "clientOrderId")
		if IsTrue(IsTrue((IsEqual(id, nil))) && IsTrue((IsEqual(clientOrderId, nil)))) {
			panic(ArgumentsRequired(Add(this.Id, " fetchOpenOrder() requires an id argument or a clientOrderId parameter")))
		} else if IsTrue(!IsEqual(id, nil)) {
			AddElementToObject(request, "orderId", id)
		}
		var wallet interface{} = "W001"
		walletparamsVariable := this.HandleOptionAndParams(params, "fetchOpenOrder", "wallet", wallet)
		wallet = GetValue(walletparamsVariable, 0)
		params = GetValue(walletparamsVariable, 1)
		AddElementToObject(request, "wallet", wallet)
		var response interface{} = nil
		var trigger interface{} = false
		triggerparamsVariable := this.HandleOptionAndParams(params, "fetchOpenOrder", "trigger", trigger)
		trigger = GetValue(triggerparamsVariable, 0)
		params = GetValue(triggerparamsVariable, 1)
		if !IsTrue(trigger) {

			response = (<-this.PrivateGetV1SwapTradeOpenOrder(this.Extend(request, params)))
			PanicOnError(response)
		} else {

			response = (<-this.PrivateGetV1SwapTradePlanOrder(this.Extend(request, params)))
			PanicOnError(response)
		}
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var order interface{} = this.SafeDict(data, 0, map[string]interface{}{})

		ch <- this.ParseOrder(order, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bydfi#fetchCanceledAndClosedOrders
 * @description fetches information on multiple canceled and closed orders made by the user
 * @see https://developers.bydfi.com/en/swap/trade#historical-orders-query
 * @param {string} symbol unified market symbol of the closed orders
 * @param {int} [since] timestamp in ms of the earliest order
 * @param {int} [limit] the max number of closed orders to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest order
 * @param {string} [params.contractType] FUTURE or DELIVERY, default is FUTURE
 * @param {string} [params.wallet] The unique code of a sub-wallet
 * @param {string} [params.orderType] order type ('LIMIT', 'MARKET', 'LIQ', 'LIMIT_CLOSE', 'MARKET_CLOSE', 'STOP', 'TAKE_PROFIT', 'STOP_MARKET', 'TAKE_PROFIT_MARKET' or 'TRAILING_STOP_MARKET')
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *BydfiCore) FetchCanceledAndClosedOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes16408 := (<-this.LoadMarkets())
		PanicOnError(retRes16408)
		var paginate interface{} = this.SafeBool(params, "paginate", false)
		if IsTrue(paginate) {
			var maxLimit interface{} = 500
			params = this.Omit(params, "paginate")
			params = this.Extend(params, map[string]interface{}{
				"paginationDirection": "backward",
			})

			paginatedResponse := (<-this.FetchPaginatedCallDynamic("fetchCanceledAndClosedOrders", symbol, since, limit, params, maxLimit, true))
			PanicOnError(paginatedResponse)

			ch <- this.SortBy(paginatedResponse, "timestamp")
			return nil
		}
		var contractType interface{} = "FUTURE"
		contractTypeparamsVariable := this.HandleOptionAndParams(params, "fetchCanceledAndClosedOrders", "contractType", contractType)
		contractType = GetValue(contractTypeparamsVariable, 0)
		params = GetValue(contractTypeparamsVariable, 1)
		var request interface{} = map[string]interface{}{
			"contractType": contractType,
		}
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			AddElementToObject(request, "symbol", GetValue(market, "id"))
		}
		params = this.HandleSinceAndUntil("fetchCanceledAndClosedOrders", since, params)
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}

		response := (<-this.PrivateGetV1SwapTradeHistoryOrder(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": 200,
		//         "message": "success",
		//         "data": [
		//             {
		//                 "orderId": "7408919189505597440",
		//                 "orderType": "MARKET",
		//                 "symbol": "ETH-USDC",
		//                 "origQty": "1",
		//                 "side": "BUY",
		//                 "positionSide": "BOTH",
		//                 "positionAvgPrice": null,
		//                 "positionVolume": null,
		//                 "positionType": null,
		//                 "reduceOnly": false,
		//                 "closePosition": false,
		//                 "action": null,
		//                 "price": "3032.45",
		//                 "avgPrice": "3032.45",
		//                 "brkPrice": null,
		//                 "dealVolume": null,
		//                 "status": "2",
		//                 "wallet": "W001",
		//                 "alias": null,
		//                 "contractId": null,
		//                 "mtime": "1766423985842",
		//                 "ctime": "1766423985840",
		//                 "fixedPrice": null,
		//                 "direction": null,
		//                 "triggerPrice": null,
		//                 "priceType": null,
		//                 "basePrecision": "8",
		//                 "baseShowPrecision": "2",
		//                 "strategyType": null,
		//                 "leverageLevel": 1,
		//                 "marginType": "CROSS",
		//                 "remark": null,
		//                 "callbackRate": null,
		//                 "activationPrice": null
		//             }
		//         ],
		//         "success": true
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseOrders(data, market, since, limit)
		return nil

	}()
	return ch
}
func (this *BydfiCore) HandleSinceAndUntil(methodName interface{}, optionalArgs ...interface{}) interface{} {
	since := GetArg(optionalArgs, 0, nil)
	_ = since
	params := GetArg(optionalArgs, 1, map[string]interface{}{})
	_ = params
	var until interface{} = nil
	untilparamsVariable := this.HandleOptionAndParams2(params, methodName, "until", "endTime")
	until = GetValue(untilparamsVariable, 0)
	params = GetValue(untilparamsVariable, 1)
	var now interface{} = this.Milliseconds()
	var sevenDays interface{} = Multiply(Multiply(Multiply(Multiply(7, 24), 60), 60), 1000) // the maximum range is 7 days
	var startTime interface{} = since
	if IsTrue(IsEqual(startTime, nil)) {
		if IsTrue(IsEqual(until, nil)) {
			// both since and until are undefined
			startTime = Subtract(now, sevenDays)
			until = now
		} else {
			// since is undefined but until is defined
			startTime = Subtract(until, sevenDays)
		}
	} else if IsTrue(IsEqual(until, nil)) {
		// until is undefined but since is defined
		var delta interface{} = Subtract(now, startTime)
		if IsTrue(IsGreaterThan(delta, sevenDays)) {
			until = Add(startTime, sevenDays)
		} else {
			until = now
		}
	}
	var request interface{} = map[string]interface{}{
		"startTime": startTime,
		"endTime":   until,
	}
	return this.Extend(request, params)
}
func (this *BydfiCore) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{} {
	//
	// createOrder, fetchOpenOrders, fetchOpenOrder
	//     {
	//         "wallet": "W001",
	//         "symbol": "ETH-USDT",
	//         "orderId": "7408875768086683648",
	//         "clientOrderId": "7408875768086683648",
	//         "price": "1000",
	//         "origQty": "10",
	//         "avgPrice": "0",
	//         "executedQty": "0",
	//         "orderType": "LIMIT",
	//         "side": "BUY",
	//         "status": "CANCELED",
	//         "stopPrice": null,
	//         "activatePrice": null,
	//         "timeInForce": null,
	//         "workingType": "CONTRACT_PRICE",
	//         "positionSide": "BOTH",
	//         "priceProtect": false,
	//         "reduceOnly": false,
	//         "closePosition": false,
	//         "createTime": "1766413633367",
	//         "updateTime": "1766413633370"
	//     }
	//
	// fetchCanceledAndClosedOrders
	//     {
	//         "orderId": "7408919189505597440",
	//         "orderType": "MARKET",
	//         "symbol": "ETH-USDC",
	//         "origQty": "1",
	//         "side": "BUY",
	//         "positionSide": "BOTH",
	//         "positionAvgPrice": null,
	//         "positionVolume": null,
	//         "positionType": null,
	//         "reduceOnly": false,
	//         "closePosition": false,
	//         "action": null,
	//         "price": "3032.45",
	//         "avgPrice": "3032.45",
	//         "brkPrice": null,
	//         "dealVolume": null,
	//         "status": "2",
	//         "wallet": "W001",
	//         "alias": null,
	//         "contractId": null,
	//         "mtime": "1766423985842",
	//         "ctime": "1766423985840",
	//         "fixedPrice": null,
	//         "direction": null,
	//         "triggerPrice": null,
	//         "priceType": null,
	//         "basePrecision": "8",
	//         "baseShowPrecision": "2",
	//         "strategyType": null,
	//         "leverageLevel": 1,
	//         "marginType": "CROSS",
	//         "remark": null,
	//         "callbackRate": null,
	//         "activationPrice": null
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(order, "symbol")
	market = this.SafeMarket(marketId, market)
	var timestamp interface{} = this.SafeInteger2(order, "createTime", "ctime")
	var rawType interface{} = this.SafeString(order, "orderType")
	var stopPrice interface{} = this.SafeStringN(order, []interface{}{"stopPrice", "activatePrice", "triggerPrice"})
	var isStopLossOrder interface{} = IsTrue(IsTrue((IsEqual(rawType, "STOP"))) || IsTrue((IsEqual(rawType, "STOP_MARKET")))) || IsTrue((IsEqual(rawType, "TRAILING_STOP_MARKET")))
	var isTakeProfitOrder interface{} = IsTrue((IsEqual(rawType, "TAKE_PROFIT"))) || IsTrue((IsEqual(rawType, "TAKE_PROFIT_MARKET")))
	var rawTimeInForce interface{} = this.SafeString(order, "timeInForce")
	var timeInForce interface{} = this.ParseOrderTimeInForce(rawTimeInForce)
	var postOnly interface{} = nil
	if IsTrue(IsEqual(timeInForce, "PO")) {
		postOnly = true
	}
	var rawStatus interface{} = this.SafeString(order, "status")
	var fee interface{} = map[string]interface{}{}
	var quoteFee interface{} = this.SafeNumber(order, "quoteFee")
	if IsTrue(!IsEqual(quoteFee, nil)) {
		AddElementToObject(fee, "cost", quoteFee)
		AddElementToObject(fee, "currency", GetValue(market, "quote"))
	}
	return this.SafeOrder(map[string]interface{}{
		"info":                order,
		"id":                  this.SafeString(order, "orderId"),
		"clientOrderId":       this.SafeString(order, "clientOrderId"),
		"timestamp":           timestamp,
		"datetime":            this.Iso8601(timestamp),
		"lastTradeTimestamp":  nil,
		"lastUpdateTimestamp": this.SafeInteger2(order, "updateTime", "mtime"),
		"status":              this.ParseOrderStatus(rawStatus),
		"symbol":              GetValue(market, "symbol"),
		"type":                this.ParseOrderType(rawType),
		"timeInForce":         timeInForce,
		"postOnly":            postOnly,
		"reduceOnly":          this.SafeBool(order, "reduceOnly"),
		"side":                this.SafeStringLower(order, "side"),
		"price":               this.SafeString(order, "price"),
		"triggerPrice":        stopPrice,
		"stopLossPrice":       Ternary(IsTrue(isStopLossOrder), stopPrice, nil),
		"takeProfitPrice":     Ternary(IsTrue(isTakeProfitOrder), stopPrice, nil),
		"amount":              this.SafeString(order, "origQty"),
		"filled":              this.SafeString(order, "executedQty"),
		"remaining":           nil,
		"cost":                nil,
		"trades":              nil,
		"fee":                 fee,
		"average":             this.OmitZero(this.SafeString(order, "avgPrice")),
	}, market)
}
func (this *BydfiCore) ParseOrderType(typeVar interface{}) interface{} {
	var types interface{} = map[string]interface{}{
		"LIMIT":                "limit",
		"MARKET":               "market",
		"STOP":                 "limit",
		"STOP_MARKET":          "market",
		"TAKE_PROFIT":          "limit",
		"TAKE_PROFIT_MARKET":   "market",
		"TRAILING_STOP_MARKET": "market",
	}
	return this.SafeString(types, typeVar, typeVar)
}
func (this *BydfiCore) ParseOrderTimeInForce(timeInForce interface{}) interface{} {
	var timeInForces interface{} = map[string]interface{}{
		"GTC":           "GTC",
		"FOK":           "FOK",
		"IOC":           "IOC",
		"POST_ONLY":     "PO",
		"TRAILING_STOP": "IOC",
	}
	return this.SafeString(timeInForces, timeInForce, timeInForce)
}
func (this *BydfiCore) ParseOrderStatus(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"NEW":                   "open",
		"PARTIALLY_FILLED":      "open",
		"FILLED":                "closed",
		"EXPIRED":               "canceled",
		"PART_FILLED_CANCELLED": "canceled",
		"CANCELED":              "canceled",
		"2":                     "closed",
		"4":                     "canceled",
	}
	return this.SafeString(statuses, status, status)
}

/**
 * @method
 * @name bydfi#setLeverage
 * @description set the level of leverage for a market
 * @see https://developers.bydfi.com/en/swap/trade#set-leverage-for-single-trading-pair
 * @param {float} leverage the rate of leverage
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.wallet] The unique code of a sub-wallet. W001 is the default wallet and the main wallet code of the contract
 * @returns {object} response from the exchange
 */
func (this *BydfiCore) SetLeverage(leverage interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " setLeverage() requires a symbol argument")))
		}

		retRes19118 := (<-this.LoadMarkets())
		PanicOnError(retRes19118)
		var market interface{} = this.Market(symbol)
		var wallet interface{} = "W001"
		walletparamsVariable := this.HandleOptionAndParams(params, "setLeverage", "wallet", wallet)
		wallet = GetValue(walletparamsVariable, 0)
		params = GetValue(walletparamsVariable, 1)
		var request interface{} = map[string]interface{}{
			"symbol":   GetValue(market, "id"),
			"leverage": leverage,
			"wallet":   wallet,
		}

		response := (<-this.PrivatePostV1SwapTradeLeverage(this.Extend(request, params)))
		PanicOnError(response)
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})

		ch <- data
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bydfi#fetchLeverage
 * @description fetch the set leverage for a market
 * @see https://developers.bydfi.com/en/swap/trade#get-leverage-for-single-trading-pair
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.wallet] The unique code of a sub-wallet. W001 is the default wallet and the main wallet code of the contract
 * @returns {object} a [leverage structure]{@link https://docs.ccxt.com/?id=leverage-structure}
 */
func (this *BydfiCore) FetchLeverage(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchLeverage() requires a symbol argument")))
		}

		retRes19398 := (<-this.LoadMarkets())
		PanicOnError(retRes19398)
		var market interface{} = this.Market(symbol)
		var wallet interface{} = "W001"
		walletparamsVariable := this.HandleOptionAndParams(params, "fetchLeverage", "wallet", wallet)
		wallet = GetValue(walletparamsVariable, 0)
		params = GetValue(walletparamsVariable, 1)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
			"wallet": wallet,
		}

		response := (<-this.PrivateGetV1SwapTradeLeverage(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": 200,
		//         "message": "success",
		//         "data": {
		//             "symbol": "ETH-USDC",
		//             "leverage": 1,
		//             "maxNotionalValue": "100000000"
		//         },
		//         "success": true
		//     }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})

		ch <- this.ParseLeverage(data, market)
		return nil

	}()
	return ch
}
func (this *BydfiCore) ParseLeverage(leverage interface{}, optionalArgs ...interface{}) interface{} {
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(leverage, "symbol")
	return map[string]interface{}{
		"info":          leverage,
		"symbol":        this.SafeSymbol(marketId, market),
		"marginMode":    nil,
		"longLeverage":  this.SafeInteger(leverage, "leverage"),
		"shortLeverage": this.SafeInteger(leverage, "leverage"),
	}
}

/**
 * @method
 * @name bydfi#fetchPositions
 * @description fetch all open positions
 * @see https://developers.bydfi.com/en/swap/trade#positions-query
 * @param {string[]} [symbols] list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.contractType] FUTURE or DELIVERY, default is FUTURE
 * @param {string} [params.settleCoin] the settlement currency (USDT or USDC or USD)
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/?id=position-structure}
 */
func (this *BydfiCore) FetchPositions(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes19878 := (<-this.LoadMarkets())
		PanicOnError(retRes19878)
		var contractType interface{} = "FUTURE"
		contractTypeparamsVariable := this.HandleOptionAndParams(params, "fetchPositions", "contractType", contractType)
		contractType = GetValue(contractTypeparamsVariable, 0)
		params = GetValue(contractTypeparamsVariable, 1)
		var request interface{} = map[string]interface{}{
			"contractType": contractType,
		}

		response := (<-this.PrivateGetV1SwapTradePositions(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": 200,
		//         "message": "success",
		//         "data": [
		//             {
		//                 "symbol": "ETH-USDC",
		//                 "side": "BUY",
		//                 "volume": "0.001",
		//                 "avgPrice": "3032.45",
		//                 "liqPrice": "0",
		//                 "markPrice": "3032.37",
		//                 "unPnl": "-0.00008",
		//                 "positionMargin": "0",
		//                 "settleCoin": "USDC",
		//                 "im": "3.03245",
		//                 "mm": "0.007581125"
		//             }
		//         ],
		//         "success": true
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParsePositions(data, symbols)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bydfi#fetchPositionsForSymbol
 * @description fetch open positions for a single market
 * @see https://developers.bydfi.com/en/swap/trade#positions-query
 * @description fetch all open positions for specific symbol
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.contractType] FUTURE or DELIVERY, default is FUTURE
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/?id=position-structure}
 */
func (this *BydfiCore) FetchPositionsForSymbol(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes20328 := (<-this.LoadMarkets())
		PanicOnError(retRes20328)
		var market interface{} = this.Market(symbol)
		var contractType interface{} = "FUTURE"
		contractTypeparamsVariable := this.HandleOptionAndParams(params, "fetchPositions", "contractType", contractType)
		contractType = GetValue(contractTypeparamsVariable, 0)
		params = GetValue(contractTypeparamsVariable, 1)
		var request interface{} = map[string]interface{}{
			"contractType": contractType,
			"symbol":       GetValue(market, "id"),
		}

		response := (<-this.PrivateGetV1SwapTradePositions(this.Extend(request, params)))
		PanicOnError(response)
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParsePositions(data, []interface{}{GetValue(market, "symbol")})
		return nil

	}()
	return ch
}
func (this *BydfiCore) ParsePosition(position interface{}, optionalArgs ...interface{}) interface{} {
	//
	// fetchPositions, fetchPositionsForSymbol
	//     {
	//         "symbol": "ETH-USDC",
	//         "side": "BUY",
	//         "volume": "0.001",
	//         "avgPrice": "3032.45",
	//         "liqPrice": "0",
	//         "markPrice": "3032.37",
	//         "unPnl": "-0.00008",
	//         "positionMargin": "0",
	//         "settleCoin": "USDC",
	//         "im": "3.03245",
	//         "mm": "0.007581125"
	//     }
	//
	// fetchPositionsHistory
	//     {
	//         "id": "16788366",
	//         "wallet": "W001",
	//         "currency": "USDC",
	//         "symbol": "ETH-USDC",
	//         "side": "BUY",
	//         "positionSide": "BOTH",
	//         "leverage": 1,
	//         "avgOpenPositionPrice": "3032.45",
	//         "openPositionVolume": "1",
	//         "openCount": 1,
	//         "highPrice": "3032.45",
	//         "lowPrice": "2953.67",
	//         "avgClosePositionPrice": "2953.67",
	//         "closePositionVolume": "1",
	//         "closePositionCost": "2.95367",
	//         "closeCount": 1,
	//         "positionProfits": "-0.07878",
	//         "lossBonus": "0",
	//         "capitalFeeTotal": "-0.00026361",
	//         "capitalFeeOutCash": "-0.00026361",
	//         "capitalFeeInCash": "0",
	//         "capitalFeeBonus": "0",
	//         "openFeeTotal": "-0.00181947",
	//         "openFeeBonus": "0",
	//         "closeFeeTotal": "-0.00177221",
	//         "closeFeeBonus": "0",
	//         "liqLoss": "0",
	//         "liqClosed": false,
	//         "sequence": "53685341336",
	//         "updateTime": "1766494929423",
	//         "createTime": "1766423985842"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(position, "symbol")
	market = this.SafeMarket(marketId, market)
	var buyOrSell interface{} = this.SafeString(position, "side")
	var rawPositionSide interface{} = this.SafeStringLower(position, "positionSide")
	var positionSide interface{} = this.ParsePositionSide(buyOrSell)
	var hedged interface{} = nil
	var isFetchPositionsHistory interface{} = false
	if IsTrue(!IsEqual(rawPositionSide, nil)) {
		isFetchPositionsHistory = true
		if IsTrue(!IsEqual(rawPositionSide, "both")) {
			positionSide = rawPositionSide
			hedged = true
		} else {
			hedged = false
		}
	}
	var contractSize interface{} = this.SafeString(market, "contractSize")
	var contracts interface{} = this.SafeString2(position, "volume", "openPositionVolume")
	if !IsTrue(isFetchPositionsHistory) {
		// in fetchPositions, the 'volume' is in base currency units, need to convert to contracts
		contracts = Precise.StringDiv(contracts, contractSize)
	}
	var timestamp interface{} = this.SafeInteger(position, "createTime")
	return this.SafePosition(map[string]interface{}{
		"info":                        position,
		"id":                          this.SafeString(position, "id"),
		"symbol":                      GetValue(market, "symbol"),
		"entryPrice":                  this.ParseNumber(this.SafeString2(position, "avgOpenPositionPrice", "avgPrice")),
		"markPrice":                   this.ParseNumber(this.SafeString(position, "markPrice")),
		"lastPrice":                   this.ParseNumber(this.SafeString(position, "avgClosePositionPrice")),
		"notional":                    this.ParseNumber(this.SafeString(position, "closePositionCost")),
		"collateral":                  nil,
		"unrealizedPnl":               this.ParseNumber(this.SafeString(position, "unPnl")),
		"realizedPnl":                 this.ParseNumber(this.SafeString(position, "positionProfits")),
		"side":                        positionSide,
		"contracts":                   this.ParseNumber(contracts),
		"contractSize":                this.ParseNumber(contractSize),
		"timestamp":                   timestamp,
		"datetime":                    this.Iso8601(timestamp),
		"lastUpdateTimestamp":         this.SafeInteger(position, "updateTime"),
		"hedged":                      hedged,
		"maintenanceMargin":           this.ParseNumber(this.SafeString(position, "mm")),
		"maintenanceMarginPercentage": nil,
		"initialMargin":               this.ParseNumber(this.SafeString(position, "im")),
		"initialMarginPercentage":     nil,
		"leverage":                    this.ParseNumber(this.SafeString(position, "leverage")),
		"liquidationPrice":            this.ParseNumber(this.SafeString(position, "liqPrice")),
		"marginRatio":                 nil,
		"marginMode":                  nil,
		"percentage":                  nil,
	})
}
func (this *BydfiCore) ParsePositionSide(side interface{}) interface{} {
	var sides interface{} = map[string]interface{}{
		"BUY":  "long",
		"SELL": "short",
	}
	return this.SafeString(sides, side, side)
}

/**
 * @method
 * @name bydfi#fetchPositionHistory
 * @description fetches historical positions
 * @see https://developers.bydfi.com/en/swap/trade#query-historical-position-profit-and-loss-records
 * @param {string} symbol a unified market symbol
 * @param {int} [since] timestamp in ms of the earliest position to fetch , params["until"] - since <= 7 days
 * @param {int} [limit] the maximum amount of records to fetch (default 500, max 500)
 * @param {object} params extra parameters specific to the exchange api endpoint
 * @param {int} [params.until] timestamp in ms of the latest position to fetch , params["until"] - since <= 7 days
 * @param {string} [params.contractType] FUTURE or DELIVERY, default is FUTURE
 * @param {string} [params.wallet] The unique code of a sub-wallet. W001 is the default wallet and the main wallet code of the contract
 * @returns {object[]} a list of [position structures]{@link https://docs.ccxt.com/?id=position-structure}
 */
func (this *BydfiCore) FetchPositionHistory(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		since := GetArg(optionalArgs, 0, nil)
		_ = since
		limit := GetArg(optionalArgs, 1, nil)
		_ = limit
		params := GetArg(optionalArgs, 2, map[string]interface{}{})
		_ = params

		retRes21738 := (<-this.LoadMarkets())
		PanicOnError(retRes21738)
		var market interface{} = this.Market(symbol)
		var contractType interface{} = "FUTURE"
		contractTypeparamsVariable := this.HandleOptionAndParams(params, "fetchPositionsHistory", "contractType", contractType)
		contractType = GetValue(contractTypeparamsVariable, 0)
		params = GetValue(contractTypeparamsVariable, 1)
		var request interface{} = map[string]interface{}{
			"symbol":       GetValue(market, "id"),
			"contractType": contractType,
		}
		params = this.HandleSinceAndUntil("fetchPositionsHistory", since, params)
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}

		response := (<-this.PrivateGetV1SwapTradePositionHistory(this.Extend(request, params)))
		PanicOnError(response)
		//
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var positions interface{} = this.ParsePositions(data)

		ch <- this.FilterBySinceLimit(positions, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bydfi#fetchPositionsHistory
 * @description fetches historical positions
 * @see https://developers.bydfi.com/en/swap/trade#query-historical-position-profit-and-loss-records
 * @param {string[]} symbols a list of unified market symbols
 * @param {int} [since] timestamp in ms of the earliest position to fetch , params["until"] - since <= 7 days
 * @param {int} [limit] the maximum amount of records to fetch (default 500, max 500)
 * @param {object} params extra parameters specific to the exchange api endpoint
 * @param {int} [params.until] timestamp in ms of the latest position to fetch , params["until"] - since <= 7 days
 * @param {string} [params.contractType] FUTURE or DELIVERY, default is FUTURE
 * @param {string} [params.wallet] The unique code of a sub-wallet. W001 is the default wallet and the main wallet code of the contract
 * @returns {object[]} a list of [position structures]{@link https://docs.ccxt.com/?id=position-structure}
 */
func (this *BydfiCore) FetchPositionsHistory(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes22088 := (<-this.LoadMarkets())
		PanicOnError(retRes22088)
		var contractType interface{} = "FUTURE"
		contractTypeparamsVariable := this.HandleOptionAndParams(params, "fetchPositionsHistory", "contractType", contractType)
		contractType = GetValue(contractTypeparamsVariable, 0)
		params = GetValue(contractTypeparamsVariable, 1)
		var request interface{} = map[string]interface{}{
			"contractType": contractType,
		}
		params = this.HandleSinceAndUntil("fetchPositionsHistory", since, params)
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}

		response := (<-this.PrivateGetV1SwapTradePositionHistory(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": 200,
		//         "message": "success",
		//         "data": [
		//             {
		//                 "id": "16788366",
		//                 "wallet": "W001",
		//                 "currency": "USDC",
		//                 "symbol": "ETH-USDC",
		//                 "side": "BUY",
		//                 "positionSide": "BOTH",
		//                 "leverage": 1,
		//                 "avgOpenPositionPrice": "3032.45",
		//                 "openPositionVolume": "1",
		//                 "openCount": 1,
		//                 "highPrice": "3032.45",
		//                 "lowPrice": "2953.67",
		//                 "avgClosePositionPrice": "2953.67",
		//                 "closePositionVolume": "1",
		//                 "closePositionCost": "2.95367",
		//                 "closeCount": 1,
		//                 "positionProfits": "-0.07878",
		//                 "lossBonus": "0",
		//                 "capitalFeeTotal": "-0.00026361",
		//                 "capitalFeeOutCash": "-0.00026361",
		//                 "capitalFeeInCash": "0",
		//                 "capitalFeeBonus": "0",
		//                 "openFeeTotal": "-0.00181947",
		//                 "openFeeBonus": "0",
		//                 "closeFeeTotal": "-0.00177221",
		//                 "closeFeeBonus": "0",
		//                 "liqLoss": "0",
		//                 "liqClosed": false,
		//                 "sequence": "53685341336",
		//                 "updateTime": "1766494929423",
		//                 "createTime": "1766423985842"
		//             }
		//         ],
		//         "success": true
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var positions interface{} = this.ParsePositions(data, symbols)

		ch <- this.FilterBySinceLimit(positions, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bydfi#fetchMarginMode
 * @description fetches the margin mode of a trading pair
 * @see https://developers.bydfi.com/en/swap/user#margin-mode-query
 * @param {string} symbol unified symbol of the market to fetch the margin mode for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.contractType] FUTURE or DELIVERY, default is FUTURE
 * @param {string} [params.wallet] The unique code of a sub-wallet. W001 is the default wallet and the main wallet code of the contract
 * @returns {object} a [margin mode structure]{@link https://docs.ccxt.com/?id=margin-mode-structure}
 */
func (this *BydfiCore) FetchMarginMode(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes22788 := (<-this.LoadMarkets())
		PanicOnError(retRes22788)
		var market interface{} = this.Market(symbol)
		var contractType interface{} = "FUTURE"
		contractTypeparamsVariable := this.HandleOptionAndParams(params, "fetchMarginMode", "contractType", contractType)
		contractType = GetValue(contractTypeparamsVariable, 0)
		params = GetValue(contractTypeparamsVariable, 1)
		var wallet interface{} = "W001"
		walletparamsVariable := this.HandleOptionAndParams(params, "fetchMarginMode", "wallet", wallet)
		wallet = GetValue(walletparamsVariable, 0)
		params = GetValue(walletparamsVariable, 1)
		var request interface{} = map[string]interface{}{
			"contractType": contractType,
			"symbol":       GetValue(market, "id"),
			"wallet":       wallet,
		}

		response := (<-this.PrivateGetV1SwapUserDataAssetsMargin(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": 200,
		//         "message": "success",
		//         "data": {
		//             "wallet": "W001",
		//             "symbol": "ETH-USDC",
		//             "marginType": "CROSS"
		//         },
		//         "success": true
		//     }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})

		ch <- this.ParseMarginMode(data, market)
		return nil

	}()
	return ch
}
func (this *BydfiCore) ParseMarginMode(marginMode interface{}, optionalArgs ...interface{}) interface{} {
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(marginMode, "symbol")
	return map[string]interface{}{
		"info":       marginMode,
		"symbol":     this.SafeSymbol(marketId, market),
		"marginMode": this.SafeStringLower(marginMode, "marginType"),
	}
}

/**
 * @method
 * @name bydfi#setMarginMode
 * @description set margin mode to 'cross' or 'isolated'
 * @see https://developers.bydfi.com/en/swap/user#change-margin-type-cross-margin
 * @param {string} marginMode 'cross' or 'isolated'
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.contractType] FUTURE or DELIVERY, default is FUTURE
 * @param {string} [params.wallet] The unique code of a sub-wallet. W001 is the default wallet and the main wallet code of the contract
 * @returns {object} response from the exchange
 */
func (this *BydfiCore) SetMarginMode(marginMode interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " setMarginMode() requires a symbol argument")))
		}
		marginMode = ToLower(marginMode)
		if IsTrue(IsTrue(!IsEqual(marginMode, "isolated")) && IsTrue(!IsEqual(marginMode, "cross"))) {
			panic(BadRequest(Add(this.Id, " setMarginMode() marginMode argument should be isolated or cross")))
		}

		retRes23358 := (<-this.LoadMarkets())
		PanicOnError(retRes23358)
		var market interface{} = this.Market(symbol)
		var contractType interface{} = "FUTURE"
		contractTypeparamsVariable := this.HandleOptionAndParams(params, "fetchMarginMode", "contractType", contractType)
		contractType = GetValue(contractTypeparamsVariable, 0)
		params = GetValue(contractTypeparamsVariable, 1)
		var wallet interface{} = "W001"
		walletparamsVariable := this.HandleOptionAndParams(params, "fetchMarginMode", "wallet", wallet)
		wallet = GetValue(walletparamsVariable, 0)
		params = GetValue(walletparamsVariable, 1)
		var request interface{} = map[string]interface{}{
			"contractType": contractType,
			"symbol":       GetValue(market, "id"),
			"marginType":   ToUpper(marginMode),
			"wallet":       wallet,
		}

		retRes234715 := (<-this.PrivatePostV1SwapUserDataMarginType(this.Extend(request, params)))
		PanicOnError(retRes234715)
		ch <- retRes234715
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bydfi#setPositionMode
 * @description set hedged to true or false for a market, hedged for bydfi is set identically for all markets with same settle currency
 * @see https://developers.bydfi.com/en/swap/user#change-position-mode-dual
 * @param {bool} hedged set to true to use dualSidePosition
 * @param {string} [symbol] not used by bydfi setPositionMode ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.contractType] FUTURE or DELIVERY, default is FUTURE
 * @param {string} [params.wallet] The unique code of a sub-wallet. W001 is the default wallet and the main wallet code of the contract
 * @param {string} [params.settleCoin] The settlement currency - USDT or USDC or USD (default is USDT)
 * @returns {object} response from the exchange
 */
func (this *BydfiCore) SetPositionMode(hedged interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		if IsTrue(!IsEqual(symbol, nil)) {
			panic(NotSupported(Add(this.Id, " setPositionMode() does not support a symbol argument. The position mode is set identically for all markets with same settle currency")))
		}

		retRes23678 := (<-this.LoadMarkets())
		PanicOnError(retRes23678)
		var positionType interface{} = Ternary(IsTrue(hedged), "HEDGE", "ONEWAY")
		var wallet interface{} = "W001"
		walletparamsVariable := this.HandleOptionAndParams(params, "setPositionMode", "wallet", wallet)
		wallet = GetValue(walletparamsVariable, 0)
		params = GetValue(walletparamsVariable, 1)
		var contractType interface{} = "FUTURE"
		contractTypeparamsVariable := this.HandleOptionAndParams(params, "setPositionMode", "contractType", contractType)
		contractType = GetValue(contractTypeparamsVariable, 0)
		params = GetValue(contractTypeparamsVariable, 1)
		var settleCoin interface{} = "USDT"
		settleCoinparamsVariable := this.HandleOptionAndParams(params, "setPositionMode", "settleCoin", settleCoin)
		settleCoin = GetValue(settleCoinparamsVariable, 0)
		params = GetValue(settleCoinparamsVariable, 1)
		var request interface{} = map[string]interface{}{
			"contractType": contractType,
			"wallet":       wallet,
			"positionType": positionType,
			"settleCoin":   settleCoin,
		}

		retRes238815 := (<-this.PrivatePostV1SwapUserDataPositionSideDual(this.Extend(request, params)))
		PanicOnError(retRes238815)
		//
		//     {
		//         "code": 200,
		//         "message": "success",
		//         "success": true
		//     }
		//
		ch <- retRes238815
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bydfi#fetchPositionMode
 * @description fetchs the position mode, hedged or one way, hedged for bydfi is set identically for all markets with same settle currency
 * @see https://developers.bydfi.com/en/swap/user#get-position-mode
 * @param {string} [symbol] unified symbol of the market to fetch the order book for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.contractType] FUTURE or DELIVERY, default is FUTURE
 * @param {string} [params.wallet] The unique code of a sub-wallet. W001 is the default wallet and the main wallet code of the contract
 * @param {string} [params.settleCoin] The settlement currency - USDT or USDC or USD (default is USDT or settle currency of the market if market is provided)
 * @returns {object} an object detailing whether the market is in hedged or one-way mode
 */
func (this *BydfiCore) FetchPositionMode(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes24048 := (<-this.LoadMarkets())
		PanicOnError(retRes24048)
		var wallet interface{} = "W001"
		walletparamsVariable := this.HandleOptionAndParams(params, "fetchPositionMode", "wallet", wallet)
		wallet = GetValue(walletparamsVariable, 0)
		params = GetValue(walletparamsVariable, 1)
		var contractType interface{} = "FUTURE"
		contractTypeparamsVariable := this.HandleOptionAndParams(params, "fetchPositionMode", "contractType", contractType)
		contractType = GetValue(contractTypeparamsVariable, 0)
		params = GetValue(contractTypeparamsVariable, 1)
		var settleCoin interface{} = "USDT"
		if IsTrue(IsEqual(symbol, nil)) {
			settleCoinparamsVariable := this.HandleOptionAndParams(params, "fetchPositionMode", "settleCoin", settleCoin)
			settleCoin = GetValue(settleCoinparamsVariable, 0)
			params = GetValue(settleCoinparamsVariable, 1)
		} else {
			var market interface{} = this.Market(symbol)
			settleCoin = GetValue(market, "settleId")
		}
		var request interface{} = map[string]interface{}{
			"contractType": contractType,
			"settleCoin":   settleCoin,
			"wallet":       wallet,
		}

		response := (<-this.PrivateGetV1SwapUserDataPositionSideDual(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": 200,
		//         "message": "success",
		//         "data": {
		//             "wallet": "W001",
		//             "contractType": "FUTURE",
		//             "settleCoin": "USDT",
		//             "positionType": "HEDGE",
		//             "unitModel": 2,
		//             "pricingModel": "FLAG",
		//             "priceProtection": "CLOSE",
		//             "totalWallet": 2
		//         },
		//         "success": true
		//     }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		var hedged interface{} = IsEqual(this.SafeString(data, "positionType"), "HEDGE")

		ch <- map[string]interface{}{
			"info":   response,
			"hedged": hedged,
		}
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bydfi#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://developers.bydfi.com/en/account#asset-inquiry
 * @see https://developers.bydfi.com/en/swap/user#asset-query
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.accountType] the type of account to fetch the balance for, either 'spot' or 'swap'  or 'funding' (default is 'spot')
 * @param {string} [params.wallet] *swap only* The unique code of a sub-wallet. W001 is the default wallet and the main wallet code of the contract
 * @param {string} [params.asset] currency id for the balance to fetch
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/?id=balance-structure}
 */
func (this *BydfiCore) FetchBalance(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes24608 := (<-this.LoadMarkets())
		PanicOnError(retRes24608)
		var accountType interface{} = "spot"
		accountTypeparamsVariable := this.HandleOptionAndParams2(params, "fetchBalance", "accountType", "type", accountType)
		accountType = GetValue(accountTypeparamsVariable, 0)
		params = GetValue(accountTypeparamsVariable, 1)
		var request interface{} = map[string]interface{}{}
		var response interface{} = nil
		if IsTrue(!IsEqual(accountType, "swap")) {
			var options interface{} = this.SafeDict(this.Options, "accountsByType", map[string]interface{}{})
			var parsedAccountType interface{} = this.SafeString(options, accountType, accountType)
			AddElementToObject(request, "walletType", parsedAccountType)
			//
			//     {
			//         "code": 200,
			//         "message": "success",
			//         "data": [
			//             {
			//                 "walletType": "spot",
			//                 "asset": "USDC",
			//                 "total": "100",
			//                 "available": "100",
			//                 "frozen": "0"
			//             }
			//         ],
			//         "success": true
			//     }
			//

			response = (<-this.PrivateGetV1AccountAssets(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			var wallet interface{} = "W001"
			walletparamsVariable := this.HandleOptionAndParams(params, "fetchBalance", "wallet", wallet)
			wallet = GetValue(walletparamsVariable, 0)
			params = GetValue(walletparamsVariable, 1)
			AddElementToObject(request, "wallet", wallet)
			//
			//     {
			//         "code": 200,
			//         "message": "success",
			//         "data": [
			//             {
			//                 "wallet": "W001",
			//                 "asset": "USDT",
			//                 "balance": "0",
			//                 "frozen": "0",
			//                 "positionMargin": "0",
			//                 "availableBalance": "0",
			//                 "canWithdrawAmount": "0",
			//                 "bonusAmount": "0"
			//             },
			//             {
			//                 "wallet": "W001",
			//                 "asset": "USDC",
			//                 "balance": "99.99505828",
			//                 "frozen": "4.0024",
			//                 "positionMargin": "2.95342",
			//                 "availableBalance": "92.96020828",
			//                 "canWithdrawAmount": "92.96020828",
			//                 "bonusAmount": "0"
			//             }
			//         ],
			//         "success": true
			//     }

			response = (<-this.PrivateGetV1SwapAccountBalance(this.Extend(request, params)))
			PanicOnError(response)
		}
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseBalance(data)
		return nil

	}()
	return ch
}
func (this *BydfiCore) ParseBalance(response interface{}) interface{} {
	var timestamp interface{} = this.Milliseconds()
	var result interface{} = map[string]interface{}{
		"info":      response,
		"timestamp": timestamp,
		"datetime":  this.Iso8601(timestamp),
	}
	for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
		var balance interface{} = GetValue(response, i)
		var symbol interface{} = this.SafeString(balance, "asset")
		var code interface{} = this.SafeCurrencyCode(symbol)
		var account interface{} = this.Account()
		AddElementToObject(account, "total", this.SafeString2(balance, "total", "balance"))
		AddElementToObject(account, "free", this.SafeString2(balance, "available", "availableBalance"))
		AddElementToObject(result, code, account)
	}
	return this.SafeBalance(result)
}

/**
 * @method
 * @name budfi#transfer
 * @description transfer currency internally between wallets on the same account
 * @see https://developers.bydfi.com/en/account#asset-transfer-between-accounts
 * @param {string} code unified currency code
 * @param {float} amount amount to transfer
 * @param {string} fromAccount 'spot', 'funding', or 'swap'
 * @param {string} toAccount 'spot', 'funding', or 'swap'
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/?id=transfer-structure}
 */
func (this *BydfiCore) Transfer(code interface{}, amount interface{}, fromAccount interface{}, toAccount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes25568 := (<-this.LoadMarkets())
		PanicOnError(retRes25568)
		var currency interface{} = this.Currency(code)
		var accountsByType interface{} = this.SafeDict(this.Options, "accountsByType", map[string]interface{}{})
		var fromId interface{} = this.SafeString(accountsByType, fromAccount, fromAccount)
		var toId interface{} = this.SafeString(accountsByType, toAccount, toAccount)
		var request interface{} = map[string]interface{}{
			"asset":    GetValue(currency, "id"),
			"amount":   this.CurrencyToPrecision(code, amount),
			"fromType": fromId,
			"toType":   toId,
		}

		response := (<-this.PrivatePostV1AccountTransfer(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": 200,
		//         "message": "success",
		//         "success": true
		//     }
		//
		var transfer interface{} = this.ParseTransfer(response, currency)
		var transferOptions interface{} = this.SafeDict(this.Options, "transfer", map[string]interface{}{})
		var fillResponseFromRequest interface{} = this.SafeBool(transferOptions, "fillResponseFromRequest", true)
		if IsTrue(fillResponseFromRequest) {
			var timestamp interface{} = this.Milliseconds()
			AddElementToObject(transfer, "timestamp", timestamp)
			AddElementToObject(transfer, "datetime", this.Iso8601(timestamp))
			AddElementToObject(transfer, "currency", code)
			AddElementToObject(transfer, "fromAccount", fromAccount)
			AddElementToObject(transfer, "toAccount", toAccount)
			AddElementToObject(transfer, "amount", amount)
		}

		ch <- transfer
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bydfi#fetchTransfers
 * @description fetch a history of internal transfers made on an account
 * @see https://developers.bydfi.com/en/account#query-wallet-transfer-records
 * @param {string} code unified currency code of the currency transferred
 * @param {int} [since] the earliest time in ms to fetch transfers for
 * @param {int} [limit] the maximum number of transfers structures to retrieve (default 10)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch entries for
 * @returns {object[]} a list of [transfer structures]{@link https://docs.ccxt.com/?id=transfer-structure}
 */
func (this *BydfiCore) FetchTransfers(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(code, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchTransfers() requires a code argument")))
		}

		retRes26068 := (<-this.LoadMarkets())
		PanicOnError(retRes26068)
		var currency interface{} = this.Currency(code)
		var paginate interface{} = this.SafeBool(params, "paginate", false)
		if IsTrue(paginate) {
			var maxLimit interface{} = 50
			params = this.Omit(params, "paginate")
			params = this.Extend(params, map[string]interface{}{
				"paginationDirection": "backward",
			})

			paginatedResponse := (<-this.FetchPaginatedCallDynamic("fetchTransfers", GetValue(currency, "code"), since, limit, params, maxLimit, true))
			PanicOnError(paginatedResponse)

			ch <- this.SortBy(paginatedResponse, "timestamp")
			return nil
		}
		var request interface{} = map[string]interface{}{
			"asset": GetValue(currency, "id"),
		}
		var until interface{} = nil
		untilparamsVariable := this.HandleOptionAndParams2(params, "fetchTransfers", "until", "endTime")
		until = GetValue(untilparamsVariable, 0)
		params = GetValue(untilparamsVariable, 1)
		if IsTrue(IsEqual(until, nil)) {
			until = this.Milliseconds() // exchange requires endTime
		}
		if IsTrue(IsEqual(since, nil)) {
			since = 1 // exchange requires startTime but allows any value
		}
		AddElementToObject(request, "startTime", since)
		AddElementToObject(request, "endTime", until)
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "rows", limit)
		}

		response := (<-this.PrivateGetV1AccountTransferRecords(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": 200,
		//         "message": "success",
		//         "data": [
		//             {
		//                 "orderId": "1209991065294581760",
		//                 "txId": "6km5fRK83Gwdp43HA479DW1Colh2pKyS",
		//                 "sourceWallet": "SPOT",
		//                 "targetWallet": "SWAP",
		//                 "asset": "USDC",
		//                 "amount": "100",
		//                 "status": "SUCCESS",
		//                 "timestamp": 1766413950000
		//             }
		//         ],
		//         "success": true
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseTransfers(data, currency, since, limit)
		return nil

	}()
	return ch
}
func (this *BydfiCore) ParseTransfer(transfer interface{}, optionalArgs ...interface{}) interface{} {
	//
	// transfer
	//     {
	//         "code": 200,
	//         "message": "success",
	//         "success": true
	//     }
	//
	// fetchTransfers
	//     {
	//         "orderId": "1209991065294581760",
	//         "txId": "6km5fRK83Gwdp43HA479DW1Colh2pKyS",
	//         "sourceWallet": "SPOT",
	//         "targetWallet": "SWAP",
	//         "asset": "USDC",
	//         "amount": "100",
	//         "status": "SUCCESS",
	//         "timestamp": 1766413950000
	//     }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var status interface{} = this.SafeStringUpper2(transfer, "message", "status")
	var accountsById interface{} = this.SafeDict(this.Options, "accountsById", map[string]interface{}{})
	var fromId interface{} = this.SafeStringUpper(transfer, "sourceWallet")
	var toId interface{} = this.SafeStringUpper(transfer, "targetWallet")
	var fromAccount interface{} = this.SafeString(accountsById, fromId, fromId)
	var toAccount interface{} = this.SafeString(accountsById, toId, toId)
	var timestamp interface{} = this.SafeInteger(transfer, "timestamp")
	var currencyId interface{} = this.SafeString(transfer, "asset")
	return map[string]interface{}{
		"info":        transfer,
		"id":          this.SafeString(transfer, "txId"),
		"timestamp":   timestamp,
		"datetime":    this.Iso8601(timestamp),
		"currency":    this.SafeCurrencyCode(currencyId, currency),
		"amount":      this.SafeNumber(transfer, "amount"),
		"fromAccount": fromAccount,
		"toAccount":   toAccount,
		"status":      this.ParaseTransferStatus(status),
	}
}
func (this *BydfiCore) ParaseTransferStatus(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"SUCCESS": "ok",
		"WAIT":    "pending",
		"FAILED":  "failed",
	}
	return this.SafeString(statuses, status, status)
}

/**
 * @method
 * @name bydfi#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://developers.bydfi.com/en/spot/account#query-deposit-records
 * @param {string} code unified currency code (mandatory)
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/?id=transaction-structure}
 */
func (this *BydfiCore) FetchDeposits(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes271915 := (<-this.FetchTransactionsHelper("deposit", code, since, limit, params))
		PanicOnError(retRes271915)
		ch <- retRes271915
		return nil

	}()
	return ch
}

/**
 * @method
 * @name bydfi#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @see https://developers.bydfi.com/en/spot/account#query-withdrawal-records
 * @param {string} code unified currency code (mandatory)
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawal structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/?id=transaction-structure}
 */
func (this *BydfiCore) FetchWithdrawals(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes273415 := (<-this.FetchTransactionsHelper("withdrawal", code, since, limit, params))
		PanicOnError(retRes273415)
		ch <- retRes273415
		return nil

	}()
	return ch
}
func (this *BydfiCore) FetchTransactionsHelper(typeVar interface{}, code interface{}, since interface{}, limit interface{}, params interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		var methodName interface{} = Ternary(IsTrue((IsEqual(typeVar, "deposit"))), "fetchDeposits", "fetchWithdrawals")
		if IsTrue(IsEqual(code, nil)) {
			panic(ArgumentsRequired(Add(Add(Add(this.Id, " "), methodName), "() requires a code argument")))
		}

		retRes27428 := (<-this.LoadMarkets())
		PanicOnError(retRes27428)
		var currency interface{} = this.Currency(code)
		var paginate interface{} = this.SafeBool(params, "paginate", false)
		if IsTrue(paginate) {
			var maxLimit interface{} = 50
			params = this.Omit(params, "paginate")
			params = this.Extend(params, map[string]interface{}{
				"paginationDirection": "backward",
			})

			paginatedResponse := (<-this.FetchPaginatedCallDynamic(methodName, GetValue(currency, "code"), since, limit, params, maxLimit, true))
			PanicOnError(paginatedResponse)

			ch <- this.SortBy(paginatedResponse, "timestamp")
			return nil
		}
		var request interface{} = map[string]interface{}{
			"asset": GetValue(currency, "id"),
		}
		var until interface{} = nil
		untilparamsVariable := this.HandleOptionAndParams2(params, "fetchTransfers", "until", "endTime")
		until = GetValue(untilparamsVariable, 0)
		params = GetValue(untilparamsVariable, 1)
		var now interface{} = this.Milliseconds()
		var sevenDays interface{} = Multiply(Multiply(Multiply(Multiply(7, 24), 60), 60), 1000) // the maximum range is 7 days
		var startTime interface{} = since
		if IsTrue(IsEqual(startTime, nil)) {
			if IsTrue(IsEqual(until, nil)) {
				// both since and until are undefined
				startTime = Subtract(now, sevenDays)
				until = now
			} else {
				// since is undefined but until is defined
				startTime = Subtract(until, sevenDays)
			}
		} else if IsTrue(IsEqual(until, nil)) {
			// until is undefined but since is defined
			var delta interface{} = Subtract(now, startTime)
			if IsTrue(IsGreaterThan(delta, sevenDays)) {
				until = Add(startTime, sevenDays)
			} else {
				until = now
			}
		}
		AddElementToObject(request, "startTime", startTime)
		AddElementToObject(request, "endTime", until)
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}
		var response interface{} = nil
		if IsTrue(IsEqual(typeVar, "deposit")) {
			//
			//     {
			//         "code": 200,
			//         "message": "success",
			//         "data": [
			//             {
			//                 "orderId": "1208864446987255809",
			//                 "asset": "USDC",
			//                 "amount": "200",
			//                 "status": "SUCCESS",
			//                 "txId": "0xd059a82a55ffc737722bd23c1ef3db2884ce8525b72ff0b3c038b430ce0c8ca5",
			//                 "network": "ETH",
			//                 "address": "0x8346b46f6aa9843c09f79f1c170a37aca83c8fcd",
			//                 "addressTag": null,
			//                 "finishTime": 1766145475000,
			//                 "createTime": 1766145344000
			//             }
			//         ],
			//         "success": true
			//     }
			//

			response = (<-this.PrivateGetV1SpotDepositRecords(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			//
			// todo check after withdrawal
			//

			response = (<-this.PrivateGetV1SpotWithdrawRecords(this.Extend(request, params)))
			PanicOnError(response)
		}
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var transactionParams interface{} = map[string]interface{}{
			"type": typeVar,
		}
		params = this.Extend(params, transactionParams)

		ch <- this.ParseTransactions(data, currency, since, limit, params)
		return nil

	}()
	return ch
}
func (this *BydfiCore) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{} {
	//
	// fetchDeposits
	//     {
	//         "orderId": "1208864446987255809",
	//         "asset": "USDC",
	//         "amount": "200",
	//         "status": "SUCCESS",
	//         "txId": "0xd059a82a55ffc737722bd23c1ef3db2884ce8525b72ff0b3c038b430ce0c8ca5",
	//         "network": "ETH",
	//         "address": "0x8346b46f6aa9843c09f79f1c170a37aca83c8fcd",
	//         "addressTag": null,
	//         "finishTime": 1766145475000,
	//         "createTime": 1766145344000
	//     }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var currencyId interface{} = this.SafeString(transaction, "asset")
	var code interface{} = this.SafeCurrencyCode(currencyId, currency)
	var rawStatus interface{} = this.SafeStringLower(transaction, "status")
	var timestamp interface{} = this.SafeInteger(transaction, "createTime")
	var fee interface{} = nil
	var feeCost interface{} = this.SafeNumber(transaction, "fee")
	if IsTrue(!IsEqual(feeCost, nil)) {
		fee = map[string]interface{}{
			"cost":     feeCost,
			"currency": nil,
		}
	}
	return map[string]interface{}{
		"info":        transaction,
		"id":          this.SafeString(transaction, "orderId"),
		"txid":        this.SafeString(transaction, "txId"),
		"type":        nil,
		"currency":    code,
		"network":     this.NetworkIdToCode(this.SafeString(transaction, "network")),
		"amount":      this.SafeNumber(transaction, "amount"),
		"status":      this.ParseTransactionStatus(rawStatus),
		"timestamp":   timestamp,
		"datetime":    this.Iso8601(timestamp),
		"address":     this.SafeString(transaction, "address"),
		"addressFrom": nil,
		"addressTo":   nil,
		"tag":         this.SafeString(transaction, "addressTag"),
		"tagFrom":     nil,
		"tagTo":       nil,
		"updated":     this.SafeInteger(transaction, "finishTime"),
		"comment":     nil,
		"fee":         fee,
		"internal":    false,
	}
}
func (this *BydfiCore) ParseTransactionStatus(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"success": "ok",
		"wait":    "pending",
		"failed":  "failed",
	}
	return this.SafeString(statuses, status, status)
}
func (this *BydfiCore) Sign(path interface{}, optionalArgs ...interface{}) interface{} {
	api := GetArg(optionalArgs, 0, "public")
	_ = api
	method := GetArg(optionalArgs, 1, "GET")
	_ = method
	params := GetArg(optionalArgs, 2, map[string]interface{}{})
	_ = params
	headers := GetArg(optionalArgs, 3, nil)
	_ = headers
	body := GetArg(optionalArgs, 4, nil)
	_ = body
	var url interface{} = GetValue(GetValue(this.Urls, "api"), api)
	var endpoint interface{} = Add("/", path)
	var query interface{} = ""
	var sortedParams interface{} = this.Keysort(params)
	if IsTrue(IsEqual(method, "GET")) {
		query = this.Urlencode(sortedParams)
		if IsTrue(!IsEqual(GetLength(query), 0)) {
			endpoint = Add(endpoint, Add("?", query))
		}
	}
	if IsTrue(IsEqual(api, "private")) {
		this.CheckRequiredCredentials()
		var timestamp interface{} = ToString(this.Milliseconds())
		if IsTrue(IsEqual(method, "GET")) {
			var payload interface{} = Add(Add(this.ApiKey, timestamp), query)
			var signature interface{} = this.Hmac(this.Encode(payload), this.Encode(this.Secret), sha256, "hex")
			headers = map[string]interface{}{
				"X-API-KEY":       this.ApiKey,
				"X-API-TIMESTAMP": timestamp,
				"X-API-SIGNATURE": signature,
			}
		} else {
			body = this.Json(sortedParams)
			var payload interface{} = Add(Add(this.ApiKey, timestamp), body)
			var signature interface{} = this.Hmac(this.Encode(payload), this.Encode(this.Secret), sha256, "hex")
			headers = map[string]interface{}{
				"Content-Type":    "application/json",
				"X-API-KEY":       this.ApiKey,
				"X-API-TIMESTAMP": timestamp,
				"X-API-SIGNATURE": signature,
			}
		}
	}
	url = Add(url, endpoint)
	return map[string]interface{}{
		"url":     url,
		"method":  method,
		"body":    body,
		"headers": headers,
	}
}
func (this *BydfiCore) HandleErrors(httpCode interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{} {
	if IsTrue(IsEqual(response, nil)) {
		return nil // fallback to default error handler
	}
	//
	//     {
	//         "code": 101107,
	//         "message": "Requires transaction permissions"
	//     }
	//
	var code interface{} = this.SafeString(response, "code")
	var message interface{} = this.SafeString(response, "message")
	if IsTrue(!IsEqual(code, "200")) {
		var feedback interface{} = Add(Add(this.Id, " "), body)
		this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), message, feedback)
		this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), message, feedback)
		this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), code, feedback)
		panic(ExchangeError(feedback))
	}
	return nil
}

func (this *BydfiCore) Init(userConfig map[string]interface{}) {
	this.Exchange = Exchange{}
	this.Exchange.DerivedExchange = this
	this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
}
