package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type bit2c struct {
    Exchange

}

func NewBit2cCore() bit2c {
   p := bit2c{}
   setDefaults(&p)
   return p
}

func  (this *bit2c) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "bit2c",
        "name": "Bit2C",
        "countries": []interface{}{"IL"},
        "rateLimit": 3000,
        "pro": false,
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": false,
            "swap": false,
            "future": false,
            "option": false,
            "addMargin": false,
            "cancelAllOrders": false,
            "cancelOrder": true,
            "closeAllPositions": false,
            "closePosition": false,
            "createOrder": true,
            "createReduceOnlyOrder": false,
            "fetchBalance": true,
            "fetchBorrowRateHistories": false,
            "fetchBorrowRateHistory": false,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchDepositAddress": true,
            "fetchDepositAddresses": false,
            "fetchDepositAddressesByNetwork": false,
            "fetchFundingHistory": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchIndexOHLCV": false,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchLeverage": false,
            "fetchLeverageTiers": false,
            "fetchMarginMode": false,
            "fetchMarkOHLCV": false,
            "fetchMyTrades": true,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchPosition": false,
            "fetchPositionMode": false,
            "fetchPositions": false,
            "fetchPositionsRisk": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchTicker": true,
            "fetchTrades": true,
            "fetchTradingFee": false,
            "fetchTradingFees": true,
            "fetchTransfer": false,
            "fetchTransfers": false,
            "reduceMargin": false,
            "setLeverage": false,
            "setMarginMode": false,
            "setPositionMode": false,
            "transfer": false,
            "ws": false,
        },
        "urls": map[string]interface{} {
            "logo": "https://github.com/user-attachments/assets/db0bce50-6842-4c09-a1d5-0c87d22118aa",
            "api": map[string]interface{} {
                "rest": "https://bit2c.co.il",
            },
            "www": "https://www.bit2c.co.il",
            "referral": "https://bit2c.co.il/Aff/63bfed10-e359-420c-ab5a-ad368dab0baf",
            "doc": []interface{}{"https://www.bit2c.co.il/home/api", "https://github.com/OferE/bit2c"},
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": []interface{}{"Exchanges/{pair}/Ticker", "Exchanges/{pair}/orderbook", "Exchanges/{pair}/trades", "Exchanges/{pair}/lasttrades"},
            },
            "private": map[string]interface{} {
                "post": []interface{}{"Merchant/CreateCheckout", "Funds/AddCoinFundsRequest", "Order/AddFund", "Order/AddOrder", "Order/GetById", "Order/AddOrderMarketPriceBuy", "Order/AddOrderMarketPriceSell", "Order/CancelOrder", "Order/AddCoinFundsRequest", "Order/AddStopOrder", "Payment/GetMyId", "Payment/Send", "Payment/Pay"},
                "get": []interface{}{"Account/Balance", "Account/Balance/v2", "Order/MyOrders", "Order/GetById", "Order/AccountHistory", "Order/OrderHistory"},
            },
        },
        "markets": map[string]interface{} {
            "BTC/NIS": this.SafeMarketStructure(map[string]interface{} {
                "id": "BtcNis",
                "symbol": "BTC/NIS",
                "base": "BTC",
                "quote": "NIS",
                "baseId": "Btc",
                "quoteId": "Nis",
                "type": "spot",
                "spot": true,
            }),
            "ETH/NIS": this.SafeMarketStructure(map[string]interface{} {
                "id": "EthNis",
                "symbol": "ETH/NIS",
                "base": "ETH",
                "quote": "NIS",
                "baseId": "Eth",
                "quoteId": "Nis",
                "type": "spot",
                "spot": true,
            }),
            "LTC/NIS": this.SafeMarketStructure(map[string]interface{} {
                "id": "LtcNis",
                "symbol": "LTC/NIS",
                "base": "LTC",
                "quote": "NIS",
                "baseId": "Ltc",
                "quoteId": "Nis",
                "type": "spot",
                "spot": true,
            }),
            "USDC/NIS": this.SafeMarketStructure(map[string]interface{} {
                "id": "UsdcNis",
                "symbol": "USDC/NIS",
                "base": "USDC",
                "quote": "NIS",
                "baseId": "Usdc",
                "quoteId": "Nis",
                "type": "spot",
                "spot": true,
            }),
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "tierBased": true,
                "percentage": true,
                "maker": this.ParseNumber("0.025"),
                "taker": this.ParseNumber("0.03"),
                "tiers": map[string]interface{} {
                    "taker": []interface{}{[]interface{}{this.ParseNumber("0"), this.ParseNumber("0.03")}, []interface{}{this.ParseNumber("20000"), this.ParseNumber("0.0275")}, []interface{}{this.ParseNumber("50000"), this.ParseNumber("0.025")}, []interface{}{this.ParseNumber("75000"), this.ParseNumber("0.0225")}, []interface{}{this.ParseNumber("100000"), this.ParseNumber("0.02")}, []interface{}{this.ParseNumber("250000"), this.ParseNumber("0.015")}, []interface{}{this.ParseNumber("500000"), this.ParseNumber("0.0125")}, []interface{}{this.ParseNumber("750000"), this.ParseNumber("0.01")}, []interface{}{this.ParseNumber("1000000"), this.ParseNumber("0.008")}, []interface{}{this.ParseNumber("2000000"), this.ParseNumber("0.006")}, []interface{}{this.ParseNumber("3000000"), this.ParseNumber("0.004")}, []interface{}{this.ParseNumber("4000000"), this.ParseNumber("0.002")}},
                    "maker": []interface{}{[]interface{}{this.ParseNumber("0"), this.ParseNumber("0.025")}, []interface{}{this.ParseNumber("20000"), this.ParseNumber("0.0225")}, []interface{}{this.ParseNumber("50000"), this.ParseNumber("0.02")}, []interface{}{this.ParseNumber("75000"), this.ParseNumber("0.0175")}, []interface{}{this.ParseNumber("100000"), this.ParseNumber("0.015")}, []interface{}{this.ParseNumber("250000"), this.ParseNumber("0.01")}, []interface{}{this.ParseNumber("500000"), this.ParseNumber("0.0075")}, []interface{}{this.ParseNumber("750000"), this.ParseNumber("0.005")}, []interface{}{this.ParseNumber("1000000"), this.ParseNumber("0.004")}, []interface{}{this.ParseNumber("2000000"), this.ParseNumber("0.003")}, []interface{}{this.ParseNumber("3000000"), this.ParseNumber("0.002")}, []interface{}{this.ParseNumber("4000000"), this.ParseNumber("0.001")}},
                },
            },
        },
        "options": map[string]interface{} {
            "fetchTradesMethod": "public_get_exchanges_pair_trades",
        },
        "features": map[string]interface{} {
            "spot": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": false,
                    "triggerPriceType": nil,
                    "triggerDirection": false,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": false,
                        "FOK": false,
                        "PO": false,
                        "GTD": false,
                    },
                    "hedged": false,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyRequiresPrice": false,
                    "marketBuyByCost": false,
                    "selfTradePrevention": false,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": 30,
                    "untilDays": 30,
                    "symbolRequired": false,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": nil,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchOrders": nil,
                "fetchClosedOrders": nil,
                "fetchOHLCV": nil,
            },
            "swap": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "precisionMode": TICK_SIZE,
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "Please provide valid APIkey": AuthenticationError,
                "No order found.": OrderNotFound,
            },
            "broad": map[string]interface{} {
                "Please provide valid nonce": InvalidNonce,
                "please approve new terms of use on site": PermissionDenied,
            },
        },
    })
}
func  (this *bit2c) ParseBalance(response interface{}) interface{}  {
    var result interface{} = map[string]interface{} {
        "info": response,
        "timestamp": nil,
        "datetime": nil,
    }
    var codes interface{} = ObjectKeys(this.Currencies)
    for i := 0; IsLessThan(i, GetArrayLength(codes)); i++ {
        var code interface{} = GetValue(codes, i)
        var account interface{} = this.Account()
        var currency interface{} = this.Currency(code)
        var uppercase interface{} = ToUpper(GetValue(currency, "id"))
        if IsTrue(InOp(response, uppercase)) {
            AddElementToObject(account, "free", this.SafeString(response, Add("AVAILABLE_", uppercase)))
            AddElementToObject(account, "total", this.SafeString(response, uppercase))
        }
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name bit2c#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://bit2c.co.il/home/api#balance
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *bit2c) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes2798 := (<-this.LoadMarkets())
            PanicOnError(retRes2798)
        
            response:= (<-this.PrivateGetAccountBalanceV2(params))
            PanicOnError(response)
        
                //
            //     {
            //         "AVAILABLE_NIS": 0.0,
            //         "NIS": 0.0,
            //         "LOCKED_NIS": 0.0,
            //         "AVAILABLE_BTC": 0.0,
            //         "BTC": 0.0,
            //         "LOCKED_BTC": 0.0,
            //         "AVAILABLE_ETH": 0.0,
            //         "ETH": 0.0,
            //         "LOCKED_ETH": 0.0,
            //         "AVAILABLE_BCHSV": 0.0,
            //         "BCHSV": 0.0,
            //         "LOCKED_BCHSV": 0.0,
            //         "AVAILABLE_BCHABC": 0.0,
            //         "BCHABC": 0.0,
            //         "LOCKED_BCHABC": 0.0,
            //         "AVAILABLE_LTC": 0.0,
            //         "LTC": 0.0,
            //         "LOCKED_LTC": 0.0,
            //         "AVAILABLE_ETC": 0.0,
            //         "ETC": 0.0,
            //         "LOCKED_ETC": 0.0,
            //         "AVAILABLE_BTG": 0.0,
            //         "BTG": 0.0,
            //         "LOCKED_BTG": 0.0,
            //         "AVAILABLE_GRIN": 0.0,
            //         "GRIN": 0.0,
            //         "LOCKED_GRIN": 0.0,
            //         "Fees": {
            //             "BtcNis": { "FeeMaker": 1.0, "FeeTaker": 1.0 },
            //             "EthNis": { "FeeMaker": 1.0, "FeeTaker": 1.0 },
            //             "BchabcNis": { "FeeMaker": 1.0, "FeeTaker": 1.0 },
            //             "LtcNis": { "FeeMaker": 1.0, "FeeTaker": 1.0 },
            //             "EtcNis": { "FeeMaker": 1.0, "FeeTaker": 1.0 },
            //             "BtgNis": { "FeeMaker": 1.0, "FeeTaker": 1.0 },
            //             "LtcBtc": { "FeeMaker": 1.0, "FeeTaker": 1.0 },
            //             "BchsvNis": { "FeeMaker": 1.0, "FeeTaker": 1.0 },
            //             "GrinNis": { "FeeMaker": 1.0, "FeeTaker": 1.0 }
            //         }
            //     }
            //
        ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bit2c#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://bit2c.co.il/home/api#orderb
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *bit2c) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes3378 := (<-this.LoadMarkets())
            PanicOnError(retRes3378)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "pair": GetValue(market, "id"),
            }
        
            orderbook:= (<-this.PublicGetExchangesPairOrderbook(this.Extend(request, params)))
            PanicOnError(orderbook)
        
            ch <- this.ParseOrderBook(orderbook, symbol)
            return nil
        
            }()
            return ch
        }
func  (this *bit2c) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var symbol interface{} = this.SafeSymbol(nil, market)
    var averagePrice interface{} = this.SafeString(ticker, "av")
    var baseVolume interface{} = this.SafeString(ticker, "a")
    var last interface{} = this.SafeString(ticker, "ll")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": nil,
        "datetime": nil,
        "high": nil,
        "low": nil,
        "bid": this.SafeString(ticker, "h"),
        "bidVolume": nil,
        "ask": this.SafeString(ticker, "l"),
        "askVolume": nil,
        "vwap": nil,
        "open": nil,
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": nil,
        "percentage": nil,
        "average": averagePrice,
        "baseVolume": baseVolume,
        "quoteVolume": nil,
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name bit2c#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://bit2c.co.il/home/api#ticker
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *bit2c) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes3858 := (<-this.LoadMarkets())
            PanicOnError(retRes3858)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "pair": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetExchangesPairTicker(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseTicker(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bit2c#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://bit2c.co.il/home/api#transactions
 * @see https://bit2c.co.il/home/api#trades
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *bit2c) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes4078 := (<-this.LoadMarkets())
            PanicOnError(retRes4078)
            var market interface{} = this.Market(symbol)
            var method interface{} = GetValue(this.Options, "fetchTradesMethod") // public_get_exchanges_pair_trades or public_get_exchanges_pair_lasttrades
            var request interface{} = map[string]interface{} {
                "pair": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "date", this.ParseToInt(since))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit) // max 100000
            }
            var response interface{} = nil
            if IsTrue(IsEqual(method, "public_get_exchanges_pair_trades")) {
                
        response = (<-this.PublicGetExchangesPairTrades(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PublicGetExchangesPairLasttrades(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            //     [
            //         {"date":1651785980,"price":127975.68,"amount":0.3750321,"isBid":true,"tid":1261018},
            //         {"date":1651785980,"price":127987.70,"amount":0.0389527820303982335802581029,"isBid":true,"tid":1261020},
            //         {"date":1651786701,"price":128084.03,"amount":0.0015614749161156156626239821,"isBid":true,"tid":1261022},
            //     ]
            //
            if IsTrue(IsString(response)) {
                panic(ExchangeError(response))
            }
        
            ch <- this.ParseTrades(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bit2c#fetchTradingFees
 * @description fetch the trading fees for multiple markets
 * @see https://bit2c.co.il/home/api#balance
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
 */
func  (this *bit2c) FetchTradingFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes4478 := (<-this.LoadMarkets())
            PanicOnError(retRes4478)
        
            response:= (<-this.PrivateGetAccountBalance(params))
            PanicOnError(response)
            //
            //     {
            //         "AVAILABLE_NIS": 0.0,
            //         "NIS": 0.0,
            //         "LOCKED_NIS": 0.0,
            //         "AVAILABLE_BTC": 0.0,
            //         "BTC": 0.0,
            //         "LOCKED_BTC": 0.0,
            //         ...
            //         "Fees": {
            //             "BtcNis": { "FeeMaker": 1.0, "FeeTaker": 1.0 },
            //             "EthNis": { "FeeMaker": 1.0, "FeeTaker": 1.0 },
            //             ...
            //         }
            //     }
            //
            var fees interface{} = this.SafeValue(response, "Fees", map[string]interface{} {})
            var keys interface{} = ObjectKeys(fees)
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
                var marketId interface{} = GetValue(keys, i)
                var symbol interface{} = this.SafeSymbol(marketId)
                var fee interface{} = this.SafeValue(fees, marketId)
                var makerString interface{} = this.SafeString(fee, "FeeMaker")
                var takerString interface{} = this.SafeString(fee, "FeeTaker")
                var maker interface{} = this.ParseNumber(Precise.StringDiv(makerString, "100"))
                var taker interface{} = this.ParseNumber(Precise.StringDiv(takerString, "100"))
                AddElementToObject(result, symbol, map[string]interface{} {
            "info": fee,
            "symbol": symbol,
            "taker": taker,
            "maker": maker,
            "percentage": true,
            "tierBased": true,
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bit2c#createOrder
 * @description create a trade order
 * @see https://bit2c.co.il/home/api#addo
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bit2c) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes5028 := (<-this.LoadMarkets())
            PanicOnError(retRes5028)
            var method interface{} = "privatePostOrderAddOrder"
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "Amount": amount,
                "Pair": GetValue(market, "id"),
            }
            if IsTrue(IsEqual(typeVar, "market")) {
                method = Add(method, Add("MarketPrice", this.Capitalize(side)))
            } else {
                AddElementToObject(request, "Price", price)
                var amountString interface{} = this.NumberToString(amount)
                var priceString interface{} = this.NumberToString(price)
                AddElementToObject(request, "Total", this.ParseToNumeric(Precise.StringMul(amountString, priceString)))
                AddElementToObject(request, "IsBid", (IsEqual(side, "buy")))
            }
        
            response:= (<-this.callDynamically(method, this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bit2c#cancelOrder
 * @description cancels an open order
 * @see https://bit2c.co.il/home/api#cancelo
 * @param {string} id order id
 * @param {string} symbol Not used by bit2c cancelOrder ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bit2c) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "id": id,
            }
        
            response:= (<-this.PrivatePostOrderCancelOrder(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseOrder(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bit2c#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://bit2c.co.il/home/api#geto
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of open order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bit2c) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchOpenOrders() requires a symbol argument")))
            }
        
            retRes5558 := (<-this.LoadMarkets())
            PanicOnError(retRes5558)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "pair": GetValue(market, "id"),
            }
        
            response:= (<-this.PrivateGetOrderMyOrders(this.Extend(request, params)))
            PanicOnError(response)
            var orders interface{} = this.SafeValue(response, GetValue(market, "id"), map[string]interface{} {})
            var asks interface{} = this.SafeValue(orders, "ask", []interface{}{})
            var bids interface{} = this.SafeList(orders, "bid", []interface{}{})
        
            ch <- this.ParseOrders(this.ArrayConcat(asks, bids), market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bit2c#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://bit2c.co.il/home/api#getoid
 * @param {string} id the order id
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bit2c) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes5788 := (<-this.LoadMarkets())
            PanicOnError(retRes5788)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "id": id,
            }
        
            response:= (<-this.PrivateGetOrderGetById(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //         {
            //             "pair": "BtcNis",
            //             "status": "Completed",
            //             "created": 1666689837,
            //             "type": 0,
            //             "order_type": 0,
            //             "amount": 0.00000000,
            //             "price": 50000.00000000,
            //             "stop": 0,
            //             "id": 10951473,
            //             "initialAmount": 2.00000000
            //         }
            //
        ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
func  (this *bit2c) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //      createOrder
    //      {
    //          "OrderResponse": {"pair": "BtcNis", "HasError": False, "Error": "", "Message": ""},
    //          "NewOrder": {
    //              "created": 1505531577,
    //              "type": 0,
    //              "order_type": 0,
    //              "status_type": 0,
    //              "amount": 0.01,
    //              "price": 10000,
    //              "stop": 0,
    //              "id": 9244416,
    //              "initialAmount": None,
    //          },
    //      }
    //      fetchOrder, fetchOpenOrders
    //      {
    //          "pair": "BtcNis",
    //          "status": "Completed",
    //          "created": 1535555837,
    //          "type": 0,
    //          "order_type": 0,
    //          "amount": 0.00000000,
    //          "price": 120000.00000000,
    //          "stop": 0,
    //          "id": 10555173,
    //          "initialAmount": 2.00000000
    //      }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var orderUnified interface{} = nil
    var isNewOrder interface{} = false
    if IsTrue(InOp(order, "NewOrder")) {
        orderUnified = GetValue(order, "NewOrder")
        isNewOrder = true
    } else {
        orderUnified = order
    }
    var id interface{} = this.SafeString(orderUnified, "id")
    var symbol interface{} = this.SafeSymbol(nil, market)
    var timestamp interface{} = this.SafeIntegerProduct(orderUnified, "created", 1000)
    // status field vary between responses
    // bit2c status type:
    // 0 = New
    // 1 = Open
    // 5 = Completed
    var status interface{} = nil
    if IsTrue(isNewOrder) {
        var tempStatus interface{} = this.SafeInteger(orderUnified, "status_type")
        if IsTrue(IsTrue(IsEqual(tempStatus, 0)) || IsTrue(IsEqual(tempStatus, 1))) {
            status = "open"
        } else if IsTrue(IsEqual(tempStatus, 5)) {
            status = "closed"
        }
    } else {
        var tempStatus interface{} = this.SafeString(orderUnified, "status")
        if IsTrue(IsTrue(IsEqual(tempStatus, "New")) || IsTrue(IsEqual(tempStatus, "Open"))) {
            status = "open"
        } else if IsTrue(IsEqual(tempStatus, "Completed")) {
            status = "closed"
        }
    }
    // bit2c order type:
    // 0 = LMT,  1 = MKT
    var typeVar interface{} = this.SafeString(orderUnified, "order_type")
    if IsTrue(IsEqual(typeVar, "0")) {
        typeVar = "limit"
    } else if IsTrue(IsEqual(typeVar, "1")) {
        typeVar = "market"
    }
    // bit2c side:
    // 0 = buy, 1 = sell
    var side interface{} = this.SafeString(orderUnified, "type")
    if IsTrue(IsEqual(side, "0")) {
        side = "buy"
    } else if IsTrue(IsEqual(side, "1")) {
        side = "sell"
    }
    var price interface{} = this.SafeString(orderUnified, "price")
    var amount interface{} = nil
    var remaining interface{} = nil
    if IsTrue(isNewOrder) {
        amount = this.SafeString(orderUnified, "amount") // NOTE:'initialAmount' is currently not set on new order
        remaining = this.SafeString(orderUnified, "amount")
    } else {
        amount = this.SafeString(orderUnified, "initialAmount")
        remaining = this.SafeString(orderUnified, "amount")
    }
    return this.SafeOrder(map[string]interface{} {
        "id": id,
        "clientOrderId": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "status": status,
        "symbol": symbol,
        "type": typeVar,
        "timeInForce": nil,
        "postOnly": nil,
        "side": side,
        "price": price,
        "triggerPrice": nil,
        "amount": amount,
        "filled": nil,
        "remaining": remaining,
        "cost": nil,
        "trades": nil,
        "fee": nil,
        "info": order,
        "average": nil,
    }, market)
}
/**
 * @method
 * @name bit2c#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://bit2c.co.il/home/api#orderh
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *bit2c) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes7278 := (<-this.LoadMarkets())
            PanicOnError(retRes7278)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "take", limit)
            }
            AddElementToObject(request, "take", limit)
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "toTime", this.Yyyymmdd(this.Milliseconds(), "."))
                AddElementToObject(request, "fromTime", this.Yyyymmdd(since, "."))
            }
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "pair", GetValue(market, "id"))
            }
        
            response:= (<-this.PrivateGetOrderOrderHistory(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "ticks":1574767951,
            //             "created":"26/11/19 13:32",
            //             "action":1,
            //             "price":"1000",
            //             "pair":"EthNis",
            //             "reference":"EthNis|10867390|10867377",
            //             "fee":"0.5",
            //             "feeAmount":"0.08",
            //             "feeCoin":"₪",
            //             "firstAmount":"-0.015",
            //             "firstAmountBalance":"9",
            //             "secondAmount":"14.93",
            //             "secondAmountBalance":"130,233.28",
            //             "firstCoin":"ETH",
            //             "secondCoin":"₪"
            //         },
            //         {
            //             "ticks":1574767951,
            //             "created":"26/11/19 13:32",
            //             "action":0,
            //             "price":"1000",
            //             "pair":"EthNis",
            //             "reference":"EthNis|10867390|10867377",
            //             "fee":"0.5",
            //             "feeAmount":"0.08",
            //             "feeCoin":"₪",
            //             "firstAmount":"0.015",
            //             "firstAmountBalance":"9.015",
            //             "secondAmount":"-15.08",
            //             "secondAmountBalance":"130,218.35",
            //             "firstCoin":"ETH",
            //             "secondCoin":"₪"
            //         }
            //     ]
            //
        ch <- this.ParseTrades(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *bit2c) RemoveCommaFromValue(str interface{}) interface{}  {
    var newString interface{} = ""
    var strParts interface{} = Split(str, ",")
    for i := 0; IsLessThan(i, GetArrayLength(strParts)); i++ {
        newString = Add(newString, GetValue(strParts, i))
    }
    return newString
}
func  (this *bit2c) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // public fetchTrades
    //
    //     {
    //         "date":1651785980,
    //         "price":127975.68,
    //         "amount":0.3750321,
    //         "isBid":true,
    //         "tid":1261018
    //     }
    //
    // private fetchMyTrades
    //
    //     {
    //         "ticks":1574767951,
    //         "created":"26/11/19 13:32",
    //         "action":1,
    //         "price":"1,000",
    //         "pair":"EthNis",
    //         "reference":"EthNis|10867390|10867377",
    //         "fee":"0.5",
    //         "feeAmount":"0.08",
    //         "feeCoin":"₪",
    //         "firstAmount":"-0.015",
    //         "firstAmountBalance":"9",
    //         "secondAmount":"14.93",
    //         "secondAmountBalance":"130,233.28",
    //         "firstCoin":"ETH",
    //         "secondCoin":"₪"
    //         "isMaker": True,
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = nil
    var id interface{} = nil
    var price interface{} = nil
    var amount interface{} = nil
    var orderId interface{} = nil
    var fee interface{} = nil
    var side interface{} = nil
    var makerOrTaker interface{} = nil
    var reference interface{} = this.SafeString(trade, "reference")
    if IsTrue(!IsEqual(reference, nil)) {
        id = reference
        timestamp = this.SafeTimestamp(trade, "ticks")
        price = this.SafeString(trade, "price")
        price = this.RemoveCommaFromValue(price)
        amount = this.SafeString(trade, "firstAmount")
        var reference_parts interface{} = Split(reference, "|") // reference contains 'pair|orderId_by_taker|orderId_by_maker'
        var marketId interface{} = this.SafeString(trade, "pair")
        market = this.SafeMarket(marketId, market)
        market = this.SafeMarket(GetValue(reference_parts, 0), market)
        var isMaker interface{} = this.SafeValue(trade, "isMaker")
        makerOrTaker = Ternary(IsTrue(isMaker), "maker", "taker")
        orderId = Ternary(IsTrue(isMaker), GetValue(reference_parts, 2), GetValue(reference_parts, 1))
        side = this.SafeInteger(trade, "action")
        if IsTrue(IsEqual(side, 0)) {
            side = "buy"
        } else if IsTrue(IsEqual(side, 1)) {
            side = "sell"
        }
        var feeCost interface{} = this.SafeString(trade, "feeAmount")
        if IsTrue(!IsEqual(feeCost, nil)) {
            fee = map[string]interface{} {
                "cost": feeCost,
                "currency": "NIS",
            }
        }
    } else {
        timestamp = this.SafeTimestamp(trade, "date")
        id = this.SafeString(trade, "tid")
        price = this.SafeString(trade, "price")
        amount = this.SafeString(trade, "amount")
        side = this.SafeValue(trade, "isBid")
        if IsTrue(!IsEqual(side, nil)) {
            if IsTrue(side) {
                side = "buy"
            } else {
                side = "sell"
            }
        }
    }
    market = this.SafeMarket(nil, market)
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "id": id,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": GetValue(market, "symbol"),
        "order": orderId,
        "type": nil,
        "side": side,
        "takerOrMaker": makerOrTaker,
        "price": price,
        "amount": amount,
        "cost": nil,
        "fee": fee,
    }, market)
}
func  (this *bit2c) IsFiat(code interface{}) interface{}  {
    return IsEqual(code, "NIS")
}
/**
 * @method
 * @name bit2c#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account
 * @see https://bit2c.co.il/home/api#addc
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *bit2c) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes9078 := (<-this.LoadMarkets())
            PanicOnError(retRes9078)
            var currency interface{} = this.Currency(code)
            if IsTrue(this.IsFiat(code)) {
                panic(NotSupported(Add(this.Id, " fetchDepositAddress() does not support fiat currencies")))
            }
            var request interface{} = map[string]interface{} {
                "Coin": GetValue(currency, "id"),
            }
        
            response:= (<-this.PrivatePostFundsAddCoinFundsRequest(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "address": "0xf14b94518d74aff2b1a6d3429471bcfcd3881d42",
            //         "hasTx": False
            //     }
            //
        ch <- this.ParseDepositAddress(response, currency)
            return nil
        
            }()
            return ch
        }
func  (this *bit2c) ParseDepositAddress(depositAddress interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "address": "0xf14b94518d74aff2b1a6d3429471bcfcd3881d42",
    //         "hasTx": False
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var address interface{} = this.SafeString(depositAddress, "address")
    this.CheckAddress(address)
    var code interface{} = this.SafeCurrencyCode(nil, currency)
    return map[string]interface{} {
        "info": depositAddress,
        "currency": code,
        "network": nil,
        "address": address,
        "tag": nil,
    }
}
func  (this *bit2c) Nonce() interface{}  {
    return this.Milliseconds()
}
func  (this *bit2c) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var url interface{} = Add(Add(GetValue(GetValue(this.Urls, "api"), "rest"), "/"), this.ImplodeParams(path, params))
    if IsTrue(IsEqual(api, "public")) {
        url = Add(url, ".json")
    } else {
        this.CheckRequiredCredentials()
        var nonce interface{} = this.Nonce()
        var query interface{} = this.Extend(map[string]interface{} {
            "nonce": nonce,
        }, params)
        var auth interface{} = this.Urlencode(query)
        if IsTrue(IsEqual(method, "GET")) {
            if IsTrue(GetArrayLength(ObjectKeys(query))) {
                url = Add(url, Add("?", auth))
            }
        } else {
            body = auth
        }
        var signature interface{} = this.Hmac(this.Encode(auth), this.Encode(this.Secret), sha512, "base64")
        headers = map[string]interface{} {
            "Content-Type": "application/x-www-form-urlencoded",
            "key": this.ApiKey,
            "sign": signature,
        }
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *bit2c) HandleErrors(httpCode interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsEqual(response, nil)) {
        return nil  // fallback to default error handler
    }
    //
    //     { "error" : "please approve new terms of use on site." }
    //     { "error": "Please provide valid nonce in Request Nonce (1598218490) is not bigger than last nonce (1598218490)."}
    //     { "Error" : "No order found." }
    //
    var error interface{} = this.SafeString(response, "error")
    if IsTrue(IsEqual(error, nil)) {
        error = this.SafeString(response, "Error")
    }
    if IsTrue(!IsEqual(error, nil)) {
        var feedback interface{} = Add(Add(this.Id, " "), body)
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), error, feedback)
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), error, feedback)
        panic(ExchangeError(feedback))
    }
    return nil
}


func (this *bit2c) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
