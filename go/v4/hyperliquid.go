package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type HyperliquidCore struct {
	Exchange
}

func NewHyperliquidCore() *HyperliquidCore {
	p := &HyperliquidCore{}
	setDefaults(p)
	return p
}

func (this *HyperliquidCore) Describe() interface{} {
	return this.DeepExtend(this.Exchange.Describe(), map[string]interface{}{
		"id":        "hyperliquid",
		"name":      "Hyperliquid",
		"countries": []interface{}{},
		"version":   "v1",
		"rateLimit": 50,
		"certified": true,
		"pro":       true,
		"dex":       true,
		"has": map[string]interface{}{
			"CORS":                                 nil,
			"spot":                                 true,
			"margin":                               false,
			"swap":                                 true,
			"future":                               true,
			"option":                               false,
			"addMargin":                            true,
			"borrowCrossMargin":                    false,
			"borrowIsolatedMargin":                 false,
			"cancelAllOrders":                      false,
			"cancelAllOrdersAfter":                 true,
			"cancelOrder":                          true,
			"cancelOrders":                         true,
			"cancelOrdersForSymbols":               true,
			"closeAllPositions":                    false,
			"closePosition":                        false,
			"createMarketBuyOrderWithCost":         false,
			"createMarketOrderWithCost":            false,
			"createMarketSellOrderWithCost":        false,
			"createOrder":                          true,
			"createOrders":                         true,
			"createOrderWithTakeProfitAndStopLoss": true,
			"createReduceOnlyOrder":                true,
			"createStopOrder":                      true,
			"createTriggerOrder":                   true,
			"editOrder":                            true,
			"editOrders":                           true,
			"fetchAccounts":                        false,
			"fetchBalance":                         true,
			"fetchBorrowInterest":                  false,
			"fetchBorrowRateHistories":             false,
			"fetchBorrowRateHistory":               false,
			"fetchCanceledAndClosedOrders":         true,
			"fetchCanceledOrders":                  true,
			"fetchClosedOrders":                    true,
			"fetchCrossBorrowRate":                 false,
			"fetchCrossBorrowRates":                false,
			"fetchCurrencies":                      true,
			"fetchDepositAddress":                  false,
			"fetchDepositAddresses":                false,
			"fetchDeposits":                        true,
			"fetchDepositWithdrawFee":              "emulated",
			"fetchDepositWithdrawFees":             false,
			"fetchFundingHistory":                  true,
			"fetchFundingRate":                     false,
			"fetchFundingRateHistory":              true,
			"fetchFundingRates":                    true,
			"fetchIndexOHLCV":                      false,
			"fetchIsolatedBorrowRate":              false,
			"fetchIsolatedBorrowRates":             false,
			"fetchLedger":                          true,
			"fetchLeverage":                        false,
			"fetchLeverageTiers":                   false,
			"fetchLiquidations":                    false,
			"fetchMarginMode":                      nil,
			"fetchMarketLeverageTiers":             false,
			"fetchMarkets":                         true,
			"fetchMarkOHLCV":                       false,
			"fetchMyLiquidations":                  false,
			"fetchMyTrades":                        true,
			"fetchOHLCV":                           true,
			"fetchOpenInterest":                    true,
			"fetchOpenInterestHistory":             false,
			"fetchOpenInterests":                   true,
			"fetchOpenOrders":                      true,
			"fetchOrder":                           true,
			"fetchOrderBook":                       true,
			"fetchOrders":                          true,
			"fetchOrderTrades":                     false,
			"fetchPosition":                        true,
			"fetchPositionMode":                    false,
			"fetchPositions":                       true,
			"fetchPositionsRisk":                   false,
			"fetchPremiumIndexOHLCV":               false,
			"fetchStatus":                          true,
			"fetchTicker":                          "emulated",
			"fetchTickers":                         true,
			"fetchTime":                            true,
			"fetchTrades":                          true,
			"fetchTradingFee":                      true,
			"fetchTradingFees":                     false,
			"fetchTransfer":                        false,
			"fetchTransfers":                       false,
			"fetchWithdrawal":                      false,
			"fetchWithdrawals":                     true,
			"reduceMargin":                         true,
			"repayCrossMargin":                     false,
			"repayIsolatedMargin":                  false,
			"sandbox":                              true,
			"setLeverage":                          true,
			"setMarginMode":                        true,
			"setPositionMode":                      false,
			"transfer":                             true,
			"withdraw":                             true,
		},
		"timeframes": map[string]interface{}{
			"1m":  "1m",
			"3m":  "3m",
			"5m":  "5m",
			"15m": "15m",
			"30m": "30m",
			"1h":  "1h",
			"2h":  "2h",
			"4h":  "4h",
			"8h":  "8h",
			"12h": "12h",
			"1d":  "1d",
			"3d":  "3d",
			"1w":  "1w",
			"1M":  "1M",
		},
		"hostname": "hyperliquid.xyz",
		"urls": map[string]interface{}{
			"logo": "https://github.com/ccxt/ccxt/assets/43336371/b371bc6c-4a8c-489f-87f4-20a913dd8d4b",
			"api": map[string]interface{}{
				"public":  "https://api.{hostname}",
				"private": "https://api.{hostname}",
			},
			"test": map[string]interface{}{
				"public":  "https://api.hyperliquid-testnet.xyz",
				"private": "https://api.hyperliquid-testnet.xyz",
			},
			"www":      "https://hyperliquid.xyz",
			"doc":      "https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api",
			"fees":     "https://hyperliquid.gitbook.io/hyperliquid-docs/trading/fees",
			"referral": "https://app.hyperliquid.xyz/",
		},
		"api": map[string]interface{}{
			"public": map[string]interface{}{
				"post": map[string]interface{}{
					"info": map[string]interface{}{
						"cost": 20,
						"byType": map[string]interface{}{
							"l2Book":                 2,
							"allMids":                2,
							"clearinghouseState":     2,
							"orderStatus":            2,
							"spotClearinghouseState": 2,
							"exchangeStatus":         2,
							"candleSnapshot":         4,
						},
					},
				},
			},
			"private": map[string]interface{}{
				"post": map[string]interface{}{
					"exchange": 1,
				},
			},
		},
		"fees": map[string]interface{}{
			"swap": map[string]interface{}{
				"taker": this.ParseNumber("0.00045"),
				"maker": this.ParseNumber("0.00015"),
			},
			"spot": map[string]interface{}{
				"taker": this.ParseNumber("0.0007"),
				"maker": this.ParseNumber("0.0004"),
			},
		},
		"requiredCredentials": map[string]interface{}{
			"apiKey":        false,
			"secret":        false,
			"walletAddress": true,
			"privateKey":    true,
		},
		"exceptions": map[string]interface{}{
			"exact": map[string]interface{}{},
			"broad": map[string]interface{}{
				"Price must be divisible by tick size.":                             InvalidOrder,
				"Order must have minimum value of $10":                              InvalidOrder,
				"Insufficient margin to place order.":                               InsufficientFunds,
				"Reduce only order would increase position.":                        InvalidOrder,
				"Post only order would have immediately matched,":                   InvalidOrder,
				"Order could not immediately match against any resting orders.":     InvalidOrder,
				"Invalid TP/SL price.":                                              InvalidOrder,
				"No liquidity available for market order.":                          InvalidOrder,
				"Order was never placed, already canceled, or filled.":              OrderNotFound,
				"User or API Wallet ":                                               InvalidOrder,
				"Order has invalid size":                                            InvalidOrder,
				"Order price cannot be more than 80% away from the reference price": InvalidOrder,
				"Order has zero size.":                                              InvalidOrder,
				"Insufficient spot balance asset":                                   InsufficientFunds,
				"Insufficient balance for withdrawal":                               InsufficientFunds,
				"Insufficient balance for token transfer":                           InsufficientFunds,
			},
		},
		"precisionMode":    TICK_SIZE,
		"commonCurrencies": map[string]interface{}{},
		"options": map[string]interface{}{
			"defaultType":       "swap",
			"sandboxMode":       false,
			"defaultSlippage":   0.05,
			"marketHelperProps": []interface{}{"hip3TokensByName", "cachedCurrenciesById"},
			"zeroAddress":       "0x0000000000000000000000000000000000000000",
			"spotCurrencyMapping": map[string]interface{}{
				"UDZ":    "2Z",
				"UBONK":  "BONK",
				"UBTC":   "BTC",
				"UETH":   "ETH",
				"UFART":  "FARTCOIN",
				"HPENGU": "PENGU",
				"UPUMP":  "PUMP",
				"USOL":   "SOL",
				"UUUSPX": "SPX",
				"USDT0":  "USDT",
				"XAUT0":  "XAUT",
				"UXPL":   "XPL",
			},
			"fetchMarkets": map[string]interface{}{
				"types": []interface{}{"spot", "swap", "hip3"},
				"hip3": map[string]interface{}{
					"limit": 10,
					"dexes": []interface{}{},
				},
			},
		},
		"features": map[string]interface{}{
			"default": map[string]interface{}{
				"sandbox": true,
				"createOrder": map[string]interface{}{
					"marginMode":       false,
					"triggerPrice":     false,
					"triggerPriceType": nil,
					"triggerDirection": false,
					"stopLossPrice":    false,
					"takeProfitPrice":  false,
					"attachedStopLossTakeProfit": map[string]interface{}{
						"triggerPriceType": map[string]interface{}{
							"last":  false,
							"mark":  false,
							"index": false,
						},
						"triggerPrice": true,
						"type":         true,
						"price":        true,
					},
					"timeInForce": map[string]interface{}{
						"IOC": true,
						"FOK": false,
						"PO":  true,
						"GTD": false,
					},
					"hedged":                 false,
					"trailing":               false,
					"leverage":               false,
					"marketBuyByCost":        false,
					"marketBuyRequiresPrice": false,
					"selfTradePrevention":    false,
					"iceberg":                false,
				},
				"createOrders": map[string]interface{}{
					"max": 1000,
				},
				"fetchMyTrades": map[string]interface{}{
					"marginMode":     false,
					"limit":          2000,
					"daysBack":       nil,
					"untilDays":      nil,
					"symbolRequired": true,
				},
				"fetchOrder": map[string]interface{}{
					"marginMode":     false,
					"trigger":        false,
					"trailing":       false,
					"symbolRequired": true,
				},
				"fetchOpenOrders": map[string]interface{}{
					"marginMode":     false,
					"limit":          2000,
					"trigger":        false,
					"trailing":       false,
					"symbolRequired": true,
				},
				"fetchOrders": map[string]interface{}{
					"marginMode":     false,
					"limit":          2000,
					"daysBack":       nil,
					"untilDays":      nil,
					"trigger":        false,
					"trailing":       false,
					"symbolRequired": true,
				},
				"fetchClosedOrders": map[string]interface{}{
					"marginMode":       false,
					"limit":            2000,
					"daysBack":         nil,
					"daysBackCanceled": nil,
					"untilDays":        nil,
					"trigger":          false,
					"trailing":         false,
					"symbolRequired":   true,
				},
				"fetchOHLCV": map[string]interface{}{
					"limit": 5000,
				},
			},
			"spot": map[string]interface{}{
				"extends": "default",
			},
			"forPerps": map[string]interface{}{
				"extends": "default",
				"createOrder": map[string]interface{}{
					"stopLossPrice":              true,
					"takeProfitPrice":            true,
					"attachedStopLossTakeProfit": nil,
				},
			},
			"swap": map[string]interface{}{
				"linear": map[string]interface{}{
					"extends": "forPerps",
				},
				"inverse": map[string]interface{}{
					"extends": "forPerps",
				},
			},
			"future": map[string]interface{}{
				"linear": map[string]interface{}{
					"extends": "forPerps",
				},
				"inverse": map[string]interface{}{
					"extends": "forPerps",
				},
			},
		},
	})
}
func (this *HyperliquidCore) SetSandboxMode(enabled interface{}) {
	this.Exchange.SetSandboxMode(enabled)
	AddElementToObject(this.Options, "sandboxMode", enabled)
}
func (this *HyperliquidCore) Market(symbol interface{}) interface{} {
	if IsTrue(IsEqual(this.Markets, nil)) {
		panic(ExchangeError(Add(this.Id, " markets not loaded")))
	}
	if IsTrue(IsTrue((!IsEqual(symbol, nil))) && !IsTrue((InOp(this.Markets, symbol)))) {
		var symbolParts interface{} = Split(symbol, "/")
		var baseName interface{} = this.SafeString(symbolParts, 0)
		var spotCurrencyMapping interface{} = this.SafeDict(this.Options, "spotCurrencyMapping", map[string]interface{}{})
		if IsTrue(InOp(spotCurrencyMapping, baseName)) {
			var unifiedBaseName interface{} = this.SafeString(spotCurrencyMapping, baseName)
			var quote interface{} = this.SafeString(symbolParts, 1)
			var newSymbol interface{} = Add(Add(this.SafeCurrencyCode(unifiedBaseName), "/"), quote)
			if IsTrue(InOp(this.Markets, newSymbol)) {
				return GetValue(this.Markets, newSymbol)
			}
		}
	}
	return this.Exchange.Market(symbol)
}

/**
 * @method
 * @name hyperliquid#fetchStatus
 * @description the latest known information on the availability of the exchange API
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [status structure]{@link https://docs.ccxt.com/?id=exchange-status-structure}
 */
func (this *HyperliquidCore) FetchStatus(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		var request interface{} = map[string]interface{}{
			"type": "exchangeStatus",
		}

		response := (<-this.PublicPostInfo(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "status": "ok"
		//     }
		//
		var status interface{} = this.SafeString(response, "specialStatuses")

		ch <- map[string]interface{}{
			"status":  Ternary(IsTrue((IsEqual(status, nil))), "ok", "maintenance"),
			"updated": this.SafeInteger(response, "time"),
			"eta":     nil,
			"url":     nil,
			"info":    response,
		}
		return nil

	}()
	return ch
}

/**
 * @method
 * @name hyperliquid#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func (this *HyperliquidCore) FetchTime(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		var request interface{} = map[string]interface{}{
			"type": "exchangeStatus",
		}

		response := (<-this.PublicPostInfo(this.Extend(request, params)))
		PanicOnError(response)

		//
		// { specialStatuses: null, time: '1764617438643' }
		//
		ch <- this.SafeInteger(response, "time")
		return nil

	}()
	return ch
}

/**
 * @method
 * @name hyperliquid#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/perpetuals#retrieve-perpetuals-metadata
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func (this *HyperliquidCore) FetchCurrencies(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		if IsTrue(this.CheckRequiredCredentials(false)) {

			retRes44012 := (<-this.InitializeClient())
			PanicOnError(retRes44012)
		}
		var request interface{} = map[string]interface{}{
			"type": "spotMeta",
		}

		response := (<-this.PublicPostInfo(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     [
		//         {
		//             "universe": [
		//                 {
		//                     "maxLeverage": 50,
		//                     "name": "SOL",
		//                     "onlyIsolated": false,
		//                     "szDecimals": 2
		//                 }
		//             ]
		//         }
		//     ]
		//
		// const spotMeta = await this.publicPostInfo ({ 'type': 'spotMeta' });
		var tokens interface{} = this.SafeList(response, "tokens", []interface{}{})
		// const meta = this.safeList (response, 'universe', []);
		AddElementToObject(this.Options, "cachedCurrenciesById", map[string]interface{}{}) // used to map hip3 markets
		var result interface{} = map[string]interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(tokens)); i++ {
			var data interface{} = this.SafeDict(tokens, i, map[string]interface{}{})
			// const id = i;
			var id interface{} = this.SafeString(data, "index")
			var name interface{} = this.SafeString(data, "name")
			var code interface{} = this.SafeCurrencyCode(name)
			AddElementToObject(GetValue(this.Options, "cachedCurrenciesById"), id, name)
			AddElementToObject(result, code, this.SafeCurrencyStructure(map[string]interface{}{
				"id":        id,
				"name":      name,
				"code":      code,
				"precision": this.ParsePrecision(this.SafeString(data, "weiDecimals")),
				"info":      data,
				"active":    nil,
				"deposit":   nil,
				"withdraw":  nil,
				"networks":  nil,
				"fee":       nil,
				"type":      "crypto",
				"limits": map[string]interface{}{
					"amount": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
					"withdraw": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
				},
			}))
			// add in wrapped map
			var fullName interface{} = this.SafeString(data, "fullName")
			if IsTrue(IsTrue(!IsEqual(fullName, nil)) && IsTrue(!IsEqual(name, nil))) {
				var isWrapped interface{} = IsTrue(StartsWith(fullName, "Unit ")) && IsTrue(StartsWith(name, "U"))
				if IsTrue(isWrapped) {
					var parts interface{} = Split(name, "U")
					var nameWithoutU interface{} = ""
					for j := 0; IsLessThan(j, GetArrayLength(parts)); j++ {
						nameWithoutU = Add(nameWithoutU, GetValue(parts, j))
					}
					var baseCode interface{} = this.SafeCurrencyCode(nameWithoutU)
					AddElementToObject(GetValue(this.Options, "spotCurrencyMapping"), code, baseCode)
				}
			}
		}

		ch <- result
		return nil

	}()
	return ch
}

/**
 * @method
 * @name hyperliquid#fetchMarkets
 * @description retrieves data on all markets for hyperliquid
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/perpetuals#retrieve-perpetuals-asset-contexts-includes-mark-price-current-funding-open-interest-etc
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/spot#retrieve-spot-asset-contexts
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func (this *HyperliquidCore) FetchMarkets(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		var options interface{} = this.SafeDict(this.Options, "fetchMarkets", map[string]interface{}{})
		var types interface{} = this.SafeList(options, "types")
		var rawPromises interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(types)); i++ {
			var marketType interface{} = GetValue(types, i)
			if IsTrue(IsEqual(marketType, "swap")) {
				AppendToArray(&rawPromises, this.FetchSwapMarkets(params))
			} else if IsTrue(IsEqual(marketType, "spot")) {
				AppendToArray(&rawPromises, this.FetchSpotMarkets(params))
			} else if IsTrue(IsEqual(marketType, "hip3")) {
				AppendToArray(&rawPromises, this.FetchHip3Markets(params))
			}
		}

		promises := (<-promiseAll(rawPromises))
		PanicOnError(promises)
		var result interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(promises)); i++ {
			result = this.ArrayConcat(result, GetValue(promises, i))
		}

		ch <- result
		return nil

	}()
	return ch
}

/**
 * @method
 * @name hyperliquid#fetchHip3Markets
 * @description retrieves data on all hip3 markets for hyperliquid
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/perpetuals#retrieve-all-perpetual-dexs
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/perpetuals#retrieve-perpetuals-asset-contexts-includes-mark-price-current-funding-open-interest-etc
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func (this *HyperliquidCore) FetchHip3Markets(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		fetchDexes := (<-this.PublicPostInfo(map[string]interface{}{
			"type": "perpDexs",
		}))
		PanicOnError(fetchDexes)
		//
		//     [
		//         null,
		//         {
		//             "name": "xyz",
		//             "fullName": "XYZ",
		//             "deployer": "0x88806a71d74ad0a510b350545c9ae490912f0888",
		//             "oracleUpdater": "0x1234567890545d1df9ee64b35fdd16966e08acec",
		//             "feeRecipient": "0x79c0650064b10f73649b7b64c5ebf0b319606140",
		//             "assetToStreamingOiCap": [
		//                 [
		//                     "xyz:XYZ100",
		//                     "100000000.0"
		//                 ]
		//             ]
		//         }
		//     ]
		//
		var perpDexesOffset interface{} = map[string]interface{}{}
		for i := 1; IsLessThan(i, GetArrayLength(fetchDexes)); i++ {
			// builder-deployed perp dexs start at 110000
			var dex interface{} = GetValue(fetchDexes, i)
			var offset interface{} = Add(110000, Multiply((Subtract(i, 1)), 10000))
			AddElementToObject(perpDexesOffset, GetValue(dex, "name"), offset)
		}
		var fetchDexesList interface{} = []interface{}{}
		var options interface{} = this.SafeDict(this.Options, "fetchMarkets", map[string]interface{}{})
		var hip3 interface{} = this.SafeDict(options, "hip3", map[string]interface{}{})
		var dexesProvided interface{} = this.SafeList(hip3, "dexes", []interface{}{}) // let users provide their own list of dexes to load
		var maxLimit interface{} = this.SafeInteger(hip3, "limit", 10)
		var userProvidedDexesLength interface{} = GetArrayLength(dexesProvided)
		if IsTrue(IsGreaterThan(userProvidedDexesLength, 0)) {
			if IsTrue(IsGreaterThan(userProvidedDexesLength, 0)) {
				fetchDexesList = dexesProvided
			}
		} else {
			var fetchDexesLength interface{} = GetArrayLength(fetchDexes)
			for i := 1; IsLessThan(i, maxLimit); i++ {
				if IsTrue(IsGreaterThanOrEqual(i, fetchDexesLength)) {
					break
				}
				var dex interface{} = this.SafeDict(fetchDexes, i, map[string]interface{}{})
				if IsTrue(IsEqual(dex, nil)) {
					continue
				}
				var dexName interface{} = this.SafeString(dex, "name")
				AppendToArray(&fetchDexesList, dexName)
			}
		}
		var rawPromises interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(fetchDexesList)); i++ {
			var request interface{} = map[string]interface{}{
				"type": "metaAndAssetCtxs",
				"dex":  this.SafeString(fetchDexesList, i),
			}
			AppendToArray(&rawPromises, this.PublicPostInfo(this.Extend(request, params)))
		}

		promises := (<-promiseAll(rawPromises))
		PanicOnError(promises)
		AddElementToObject(this.Options, "hip3TokensByName", map[string]interface{}{})
		var markets interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(promises)); i++ {
			var dexName interface{} = GetValue(fetchDexesList, i)
			var offset interface{} = GetValue(perpDexesOffset, dexName)
			var response interface{} = GetValue(promises, i)
			var meta interface{} = this.SafeDict(response, 0, map[string]interface{}{})
			var collateralToken interface{} = this.SafeString(meta, "collateralToken")
			var universe interface{} = this.SafeList(meta, "universe", []interface{}{})
			var assetCtxs interface{} = this.SafeList(response, 1, []interface{}{})
			var result interface{} = []interface{}{}
			// helper because some endpoints return just the coin name like: flx:crcl
			// and we don't have the base/settle information and we can't assume it's USDC for hip3 markets
			for j := 0; IsLessThan(j, GetArrayLength(universe)); j++ {
				var data interface{} = this.Extend(this.SafeDict(universe, j, map[string]interface{}{}), this.SafeDict(assetCtxs, j, map[string]interface{}{}))
				AddElementToObject(data, "baseId", Add(j, offset))
				AddElementToObject(data, "collateralToken", collateralToken)
				AddElementToObject(data, "hip3", true)
				AddElementToObject(data, "dex", dexName)
				var cachedCurrencies interface{} = this.SafeDict(this.Options, "cachedCurrenciesById", map[string]interface{}{})
				// injecting collateral token name for further usage in parseMarket, already converted from like '0' to 'USDC', etc
				if IsTrue(InOp(cachedCurrencies, collateralToken)) {
					var name interface{} = this.SafeString(data, "name")
					var collateralTokenCode interface{} = this.SafeString(cachedCurrencies, collateralToken)
					AddElementToObject(data, "collateralTokenName", collateralTokenCode)
					// eg: 'flx:crcl' => {'quote': 'USDC', 'code': 'FLX-CRCL'}
					var safeCode interface{} = this.SafeCurrencyCode(name)
					AddElementToObject(GetValue(this.Options, "hip3TokensByName"), name, map[string]interface{}{
						"quote": collateralTokenCode,
						"code":  Replace(safeCode, ":", "-"),
					})
				}
				AppendToArray(&result, data)
			}
			markets = this.ArrayConcat(markets, this.ParseMarkets(result))
		}

		//
		//     [
		//         {
		//             "universe": [
		//                 {
		//                     "maxLeverage": 50,
		//                     "name": "SOL",
		//                     "onlyIsolated": false,
		//                     "szDecimals": 2
		//                 }
		//             ]
		//         },
		//         [
		//             {
		//                 "dayNtlVlm": "9450588.2273",
		//                 "funding": "0.0000198",
		//                 "impactPxs": [
		//                     "108.04",
		//                     "108.06"
		//                 ],
		//                 "markPx": "108.04",
		//                 "midPx": "108.05",
		//                 "openInterest": "10764.48",
		//                 "oraclePx": "107.99",
		//                 "premium": "0.00055561",
		//                 "prevDayPx": "111.81"
		//             }
		//         ]
		//     ]
		//
		//
		ch <- markets
		return nil

	}()
	return ch
}

/**
 * @method
 * @name hyperliquid#fetchSwapMarkets
 * @description retrieves data on all swap markets for hyperliquid
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/perpetuals#retrieve-perpetuals-asset-contexts-includes-mark-price-current-funding-open-interest-etc
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func (this *HyperliquidCore) FetchSwapMarkets(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		var request interface{} = map[string]interface{}{
			"type": "metaAndAssetCtxs",
		}

		response := (<-this.PublicPostInfo(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     [
		//         {
		//             "universe": [
		//                 {
		//                     "maxLeverage": 50,
		//                     "name": "SOL",
		//                     "onlyIsolated": false,
		//                     "szDecimals": 2
		//                 }
		//             ]
		//         },
		//         [
		//             {
		//                 "dayNtlVlm": "9450588.2273",
		//                 "funding": "0.0000198",
		//                 "impactPxs": [
		//                     "108.04",
		//                     "108.06"
		//                 ],
		//                 "markPx": "108.04",
		//                 "midPx": "108.05",
		//                 "openInterest": "10764.48",
		//                 "oraclePx": "107.99",
		//                 "premium": "0.00055561",
		//                 "prevDayPx": "111.81"
		//             }
		//         ]
		//     ]
		//
		//
		var meta interface{} = this.SafeDict(response, 0, map[string]interface{}{})
		var universe interface{} = this.SafeList(meta, "universe", []interface{}{})
		var assetCtxs interface{} = this.SafeList(response, 1, []interface{}{})
		var result interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(universe)); i++ {
			var data interface{} = this.Extend(this.SafeDict(universe, i, map[string]interface{}{}), this.SafeDict(assetCtxs, i, map[string]interface{}{}))
			AddElementToObject(data, "baseId", i)
			AppendToArray(&result, data)
		}

		ch <- this.ParseMarkets(result)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name hyperliquid#calculatePricePrecision
 * @description Helper function to calculate the Hyperliquid DECIMAL_PLACES price precision
 * @param {float} price the price to use in the calculation
 * @param {int} amountPrecision the amountPrecision to use in the calculation
 * @param {int} maxDecimals the maxDecimals to use in the calculation
 * @returns {int} The calculated price precision
 */
func (this *HyperliquidCore) CalculatePricePrecision(price interface{}, amountPrecision interface{}, maxDecimals interface{}) interface{} {
	var pricePrecision interface{} = 0
	var priceStr interface{} = this.NumberToString(price)
	if IsTrue(IsEqual(priceStr, nil)) {
		return 0
	}
	var priceSplitted interface{} = Split(priceStr, ".")
	if IsTrue(Precise.StringEq(priceStr, "0")) {
		// Significant digits is always 5 in this case
		var significantDigits interface{} = 5
		// Integer digits is always 0 in this case (0 doesn't count)
		var integerDigits interface{} = 0
		// Calculate the price precision
		pricePrecision = mathMin(Subtract(maxDecimals, amountPrecision), Subtract(significantDigits, integerDigits))
	} else if IsTrue(IsTrue(Precise.StringGt(priceStr, "0")) && IsTrue(Precise.StringLt(priceStr, "1"))) {
		// Significant digits, always 5 in this case
		var significantDigits interface{} = 5
		// Get the part after the decimal separator
		var decimalPart interface{} = this.SafeString(priceSplitted, 1, "")
		// Count the number of leading zeros in the decimal part
		var leadingZeros interface{} = 0
		for IsTrue((IsLessThanOrEqual(leadingZeros, GetLength(decimalPart)))) && IsTrue((IsEqual(GetValue(decimalPart, leadingZeros), "0"))) {
			leadingZeros = Add(leadingZeros, 1)
		}
		// Calculate price precision based on leading zeros and significant digits
		pricePrecision = Add(leadingZeros, significantDigits)
		// Calculate the price precision based on maxDecimals - szDecimals and the calculated price precision from the previous step
		pricePrecision = mathMin(Subtract(maxDecimals, amountPrecision), pricePrecision)
	} else {
		// Count the numbers before the decimal separator
		var integerPart interface{} = this.SafeString(priceSplitted, 0, "")
		// Get significant digits, take the max() of 5 and the integer digits count
		var significantDigits interface{} = mathMax(5, GetLength(integerPart))
		// Calculate price precision based on maxDecimals - szDecimals and significantDigits - integerPart.length
		pricePrecision = mathMin(Subtract(maxDecimals, amountPrecision), Subtract(significantDigits, GetLength(integerPart)))
	}
	return this.ParseToInt(pricePrecision)
}

/**
 * @method
 * @name hyperliquid#fetchSpotMarkets
 * @description retrieves data on all spot markets for hyperliquid
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/spot#retrieve-spot-asset-contexts
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func (this *HyperliquidCore) FetchSpotMarkets(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		var request interface{} = map[string]interface{}{
			"type": "spotMetaAndAssetCtxs",
		}

		response := (<-this.PublicPostInfo(this.Extend(request, params)))
		PanicOnError(response)
		//
		// [
		//     {
		//         "tokens": [
		//             {
		//                 "name": "USDC",
		//                 "szDecimals": 8,
		//                 "weiDecimals" 8,
		//                 "index": 0,
		//                 "tokenId": "0x6d1e7cde53ba9467b783cb7c530ce054",
		//                 "isCanonical": true,
		//                 "evmContract":null,
		//                 "fullName":null
		//             },
		//             {
		//                 "name": "PURR",
		//                 "szDecimals": 0,
		//                 "weiDecimals": 5,
		//                 "index": 1,
		//                 "tokenId": "0xc1fb593aeffbeb02f85e0308e9956a90",
		//                 "isCanonical": true,
		//                 "evmContract":null,
		//                 "fullName":null
		//             }
		//         ],
		//         "universe": [
		//             {
		//                 "name": "PURR/USDC",
		//                 "tokens": [1, 0],
		//                 "index": 0,
		//                 "isCanonical": true
		//             }
		//         ]
		//     },
		//     [
		//         {
		//             "dayNtlVlm":"8906.0",
		//             "markPx":"0.14",
		//             "midPx":"0.209265",
		//             "prevDayPx":"0.20432"
		//         }
		//     ]
		// ]
		//
		var first interface{} = this.SafeDict(response, 0, map[string]interface{}{})
		var second interface{} = this.SafeList(response, 1, []interface{}{})
		var meta interface{} = this.SafeList(first, "universe", []interface{}{})
		var tokens interface{} = this.SafeList(first, "tokens", []interface{}{})
		var markets interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(meta)); i++ {
			var market interface{} = this.SafeDict(meta, i, map[string]interface{}{})
			var index interface{} = this.SafeInteger(market, "index")
			var extraData interface{} = this.SafeDict(second, index, map[string]interface{}{})
			var marketName interface{} = this.SafeString(market, "name")
			// if (marketName.indexOf ('/') < 0) {
			//     // there are some weird spot markets in testnet, eg @2
			//     continue;
			// }
			// const marketParts = marketName.split ('/');
			// const baseName = this.safeString (marketParts, 0);
			// const quoteId = this.safeString (marketParts, 1);
			var fees interface{} = this.SafeDict(this.Fees, "spot", map[string]interface{}{})
			var taker interface{} = this.SafeNumber(fees, "taker")
			var maker interface{} = this.SafeNumber(fees, "maker")
			var tokensPos interface{} = this.SafeList(market, "tokens", []interface{}{})
			var baseTokenPos interface{} = this.SafeInteger(tokensPos, 0)
			var quoteTokenPos interface{} = this.SafeInteger(tokensPos, 1)
			var baseTokenInfo interface{} = this.SafeDict(tokens, baseTokenPos, map[string]interface{}{})
			var quoteTokenInfo interface{} = this.SafeDict(tokens, quoteTokenPos, map[string]interface{}{})
			var baseName interface{} = this.SafeString(baseTokenInfo, "name")
			var quoteId interface{} = this.SafeString(quoteTokenInfo, "name")
			// do spot currency mapping
			var spotCurrencyMapping interface{} = this.SafeDict(this.Options, "spotCurrencyMapping", map[string]interface{}{})
			var mappedBaseName interface{} = this.SafeString(spotCurrencyMapping, baseName, baseName)
			var mappedQuoteId interface{} = this.SafeString(spotCurrencyMapping, quoteId, quoteId)
			var mappedBase interface{} = this.SafeCurrencyCode(mappedBaseName)
			var mappedQuote interface{} = this.SafeCurrencyCode(mappedQuoteId)
			var mappedSymbol interface{} = Add(Add(mappedBase, "/"), mappedQuote)
			var innerBaseTokenInfo interface{} = this.SafeDict(baseTokenInfo, "spec", baseTokenInfo)
			// const innerQuoteTokenInfo = this.safeDict (quoteTokenInfo, 'spec', quoteTokenInfo);
			var amountPrecisionStr interface{} = this.SafeString(innerBaseTokenInfo, "szDecimals")
			var amountPrecision interface{} = ParseInt(amountPrecisionStr)
			var price interface{} = this.SafeNumber(extraData, "midPx")
			var pricePrecision interface{} = 0
			if IsTrue(!IsEqual(price, nil)) {
				pricePrecision = this.CalculatePricePrecision(price, amountPrecision, 8)
			}
			var pricePrecisionStr interface{} = this.NumberToString(pricePrecision)
			// const quotePrecision = this.parseNumber (this.parsePrecision (this.safeString (innerQuoteTokenInfo, 'szDecimals')));
			var baseId interface{} = this.NumberToString(Add(index, 10000))
			var entry interface{} = map[string]interface{}{
				"id":             marketName,
				"symbol":         mappedSymbol,
				"base":           mappedBase,
				"quote":          mappedQuote,
				"settle":         nil,
				"baseId":         baseId,
				"baseName":       baseName,
				"quoteId":        quoteId,
				"settleId":       nil,
				"type":           "spot",
				"spot":           true,
				"subType":        nil,
				"margin":         nil,
				"swap":           false,
				"future":         false,
				"option":         false,
				"active":         true,
				"contract":       false,
				"linear":         nil,
				"inverse":        nil,
				"taker":          taker,
				"maker":          maker,
				"contractSize":   nil,
				"expiry":         nil,
				"expiryDatetime": nil,
				"strike":         nil,
				"optionType":     nil,
				"precision": map[string]interface{}{
					"amount": this.ParseNumber(this.ParsePrecision(amountPrecisionStr)),
					"price":  this.ParseNumber(this.ParsePrecision(pricePrecisionStr)),
				},
				"limits": map[string]interface{}{
					"leverage": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
					"amount": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
					"price": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
					"cost": map[string]interface{}{
						"min": this.ParseNumber("10"),
						"max": nil,
					},
				},
				"created": nil,
				"info":    this.Extend(extraData, market),
			}
			AppendToArray(&markets, this.SafeMarketStructure(entry))
		}

		ch <- markets
		return nil

	}()
	return ch
}
func (this *HyperliquidCore) ParseMarket(market interface{}) interface{} {
	//
	//     {
	//         "maxLeverage": "50",
	//         "name": "ETH",
	//         "onlyIsolated": false,
	//         "szDecimals": "4",
	//         "dayNtlVlm": "1709813.11535",
	//         "funding": "0.00004807",
	//         "impactPxs": [
	//             "2369.3",
	//             "2369.6"
	//         ],
	//         "markPx": "2369.6",
	//         "midPx": "2369.45",
	//         "openInterest": "1815.4712",
	//         "oraclePx": "2367.3",
	//         "premium": "0.00090821",
	//         "prevDayPx": "2381.5"
	//         "collateralToken": "0" hip3 tokens only
	//     }
	//
	var collateralTokenCode interface{} = this.SafeString(market, "collateralTokenName")
	var quoteId interface{} = Ternary(IsTrue((IsEqual(collateralTokenCode, nil))), "USDC", collateralTokenCode)
	var settleId interface{} = Ternary(IsTrue((IsEqual(collateralTokenCode, nil))), "USDC", collateralTokenCode)
	var baseName interface{} = this.SafeString(market, "name")
	var base interface{} = this.SafeCurrencyCode(baseName)
	base = Replace(base, ":", "-") // handle hip3 tokens and converts from like flx:crcl to FLX-CRCL
	var quote interface{} = this.SafeCurrencyCode(quoteId)
	var baseId interface{} = this.SafeString(market, "baseId")
	var settle interface{} = this.SafeCurrencyCode(settleId)
	var symbol interface{} = Add(Add(base, "/"), quote)
	var contract interface{} = true
	var swap interface{} = true
	if IsTrue(contract) {
		if IsTrue(swap) {
			symbol = Add(Add(symbol, ":"), settle)
		}
	}
	var fees interface{} = this.SafeDict(this.Fees, "swap", map[string]interface{}{})
	var taker interface{} = this.SafeNumber(fees, "taker")
	var maker interface{} = this.SafeNumber(fees, "maker")
	var amountPrecisionStr interface{} = this.SafeString(market, "szDecimals")
	var amountPrecision interface{} = ParseInt(amountPrecisionStr)
	var price interface{} = this.SafeNumber(market, "markPx", 0)
	var pricePrecision interface{} = 0
	if IsTrue(!IsEqual(price, nil)) {
		pricePrecision = this.CalculatePricePrecision(price, amountPrecision, 6)
	}
	var pricePrecisionStr interface{} = this.NumberToString(pricePrecision)
	var isDelisted interface{} = this.SafeBool(market, "isDelisted")
	var active interface{} = true
	if IsTrue(!IsEqual(isDelisted, nil)) {
		active = !IsTrue(isDelisted)
	}
	return this.SafeMarketStructure(map[string]interface{}{
		"id":             baseId,
		"symbol":         symbol,
		"base":           base,
		"quote":          quote,
		"settle":         settle,
		"baseId":         baseId,
		"baseName":       baseName,
		"quoteId":        quoteId,
		"settleId":       settleId,
		"type":           "swap",
		"spot":           false,
		"margin":         nil,
		"swap":           swap,
		"future":         false,
		"option":         false,
		"active":         active,
		"contract":       contract,
		"linear":         true,
		"inverse":        false,
		"taker":          taker,
		"maker":          maker,
		"contractSize":   this.ParseNumber("1"),
		"expiry":         nil,
		"expiryDatetime": nil,
		"strike":         nil,
		"optionType":     nil,
		"precision": map[string]interface{}{
			"amount": this.ParseNumber(this.ParsePrecision(amountPrecisionStr)),
			"price":  this.ParseNumber(this.ParsePrecision(pricePrecisionStr)),
		},
		"limits": map[string]interface{}{
			"leverage": map[string]interface{}{
				"min": nil,
				"max": this.SafeInteger(market, "maxLeverage"),
			},
			"amount": map[string]interface{}{
				"min": nil,
				"max": nil,
			},
			"price": map[string]interface{}{
				"min": nil,
				"max": nil,
			},
			"cost": map[string]interface{}{
				"min": this.ParseNumber("10"),
				"max": nil,
			},
		},
		"created": nil,
		"info":    market,
	})
}
func (this *HyperliquidCore) UpdateSpotCurrencyCode(code interface{}) interface{} {
	if IsTrue(IsEqual(code, nil)) {
		return code
	}
	var spotCurrencyMapping interface{} = this.SafeDict(this.Options, "spotCurrencyMapping", map[string]interface{}{})
	return this.SafeString(spotCurrencyMapping, code, code)
}

/**
 * @method
 * @name hyperliquid#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/spot#retrieve-a-users-token-balances
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/perpetuals#retrieve-users-perpetuals-account-summary
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.user] user address, will default to this.walletAddress if not provided
 * @param {string} [params.type] wallet type, ['spot', 'swap'], defaults to swap
 * @param {string} [params.marginMode] 'cross' or 'isolated', for margin trading, uses this.options.defaultMarginMode if not passed, defaults to undefined/None/null
 * @param {string} [params.dex] for hip3 markets, the dex name, eg: 'xyz'
 * @param {string} [params.subAccountAddress] sub account user address
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/?id=balance-structure}
 */
func (this *HyperliquidCore) FetchBalance(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		var userAddress interface{} = nil
		userAddressparamsVariable := this.HandlePublicAddress("fetchBalance", params)
		userAddress = GetValue(userAddressparamsVariable, 0)
		params = GetValue(userAddressparamsVariable, 1)
		var typeVar interface{} = nil
		typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchBalance", nil, params)
		typeVar = GetValue(typeVarparamsVariable, 0)
		params = GetValue(typeVarparamsVariable, 1)
		var marginMode interface{} = nil
		marginModeparamsVariable := this.HandleMarginModeAndParams("fetchBalance", params)
		marginMode = GetValue(marginModeparamsVariable, 0)
		params = GetValue(marginModeparamsVariable, 1)
		var isSpot interface{} = (IsEqual(typeVar, "spot"))
		var request interface{} = map[string]interface{}{
			"type": Ternary(IsTrue((isSpot)), "spotClearinghouseState", "clearinghouseState"),
			"user": userAddress,
		}

		response := (<-this.PublicPostInfo(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "assetPositions": [],
		//         "crossMaintenanceMarginUsed": "0.0",
		//         "crossMarginSummary": {
		//             "accountValue": "100.0",
		//             "totalMarginUsed": "0.0",
		//             "totalNtlPos": "0.0",
		//             "totalRawUsd": "100.0"
		//         },
		//         "marginSummary": {
		//             "accountValue": "100.0",
		//             "totalMarginUsed": "0.0",
		//             "totalNtlPos": "0.0",
		//             "totalRawUsd": "100.0"
		//         },
		//         "time": "1704261007014",
		//         "withdrawable": "100.0"
		//     }
		// spot
		//
		//     {
		//         "balances":[
		//            {
		//               "coin":"USDC",
		//               "hold":"0.0",
		//               "total":"1481.844"
		//            },
		//            {
		//               "coin":"PURR",
		//               "hold":"0.0",
		//               "total":"999.65004"
		//            }
		//     }
		//
		var balances interface{} = this.SafeList(response, "balances")
		if IsTrue(!IsEqual(balances, nil)) {
			var spotBalances interface{} = map[string]interface{}{
				"info": response,
			}
			for i := 0; IsLessThan(i, GetArrayLength(balances)); i++ {
				var balance interface{} = GetValue(balances, i)
				var unifiedCode interface{} = this.SafeCurrencyCode(this.SafeString(balance, "coin"))
				var code interface{} = Ternary(IsTrue(isSpot), this.UpdateSpotCurrencyCode(unifiedCode), unifiedCode)
				var account interface{} = this.Account()
				var total interface{} = this.SafeString(balance, "total")
				var used interface{} = this.SafeString(balance, "hold")
				AddElementToObject(account, "total", total)
				AddElementToObject(account, "used", used)
				AddElementToObject(spotBalances, code, account)
			}

			ch <- this.SafeBalance(spotBalances)
			return nil
		}
		var data interface{} = this.SafeDict(response, "marginSummary", map[string]interface{}{})
		var usdcBalance interface{} = map[string]interface{}{
			"total": this.SafeNumber(data, "accountValue"),
		}
		if IsTrue(IsTrue((!IsEqual(marginMode, nil))) && IsTrue((IsEqual(marginMode, "isolated")))) {
			AddElementToObject(usdcBalance, "free", this.SafeNumber(response, "withdrawable"))
		} else {
			AddElementToObject(usdcBalance, "used", this.SafeNumber(data, "totalMarginUsed"))
		}
		var result interface{} = map[string]interface{}{
			"info": response,
			"USDC": usdcBalance,
		}
		var timestamp interface{} = this.SafeInteger(response, "time")
		AddElementToObject(result, "timestamp", timestamp)
		AddElementToObject(result, "datetime", this.Iso8601(timestamp))

		ch <- this.SafeBalance(result)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name hyperliquid#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#l2-book-snapshot
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func (this *HyperliquidCore) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		limit := GetArg(optionalArgs, 0, nil)
		_ = limit
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes11948 := (<-this.LoadMarkets())
		PanicOnError(retRes11948)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"type": "l2Book",
			"coin": Ternary(IsTrue(GetValue(market, "swap")), GetValue(market, "baseName"), GetValue(market, "id")),
		}

		response := (<-this.PublicPostInfo(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "coin": "ETH",
		//         "levels": [
		//             [
		//                 {
		//                     "n": "2",
		//                     "px": "2216.2",
		//                     "sz": "74.0637"
		//                 }
		//             ],
		//             [
		//                 {
		//                     "n": "2",
		//                     "px": "2216.5",
		//                     "sz": "70.5893"
		//                 }
		//             ]
		//         ],
		//         "time": "1704290104840"
		//     }
		//
		var data interface{} = this.SafeList(response, "levels", []interface{}{})
		var result interface{} = map[string]interface{}{
			"bids": this.SafeList(data, 0, []interface{}{}),
			"asks": this.SafeList(data, 1, []interface{}{}),
		}
		var timestamp interface{} = this.SafeInteger(response, "time")

		ch <- this.ParseOrderBook(result, GetValue(market, "symbol"), timestamp, "bids", "asks", "px", "sz")
		return nil

	}()
	return ch
}

/**
 * @method
 * @name hyperliquid#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/perpetuals#retrieve-perpetuals-asset-contexts-includes-mark-price-current-funding-open-interest-etc
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/spot#retrieve-spot-asset-contexts
 * @param {string[]} [symbols] unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.type] 'spot' or 'swap', by default fetches both
 * @param {boolean} [params.hip3] set to true to fetch hip3 markets only
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func (this *HyperliquidCore) FetchTickers(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes12458 := (<-this.LoadMarkets())
		PanicOnError(retRes12458)
		symbols = this.MarketSymbols(symbols)
		// at this stage, to get tickers data, we use fetchMarkets endpoints
		var response interface{} = []interface{}{}
		var typeVar interface{} = this.SafeString(params, "type")
		params = this.Omit(params, "type")
		var hip3 interface{} = false
		hip3paramsVariable := this.HandleOptionAndParams(params, "fetchTickers", "hip3", false)
		hip3 = GetValue(hip3paramsVariable, 0)
		params = GetValue(hip3paramsVariable, 1)
		if IsTrue(!IsEqual(symbols, nil)) {
			// infer from first symbol
			var firstSymbol interface{} = this.SafeString(symbols, 0)
			if IsTrue(!IsEqual(firstSymbol, nil)) {
				var market interface{} = this.Market(firstSymbol)
				if IsTrue(this.SafeBool(this.SafeDict(market, "info"), "hip3")) {
					hip3 = true
				}
			}
		}
		if IsTrue(hip3) {
			params = this.Omit(params, "hip3")

			response = (<-this.FetchHip3Markets(params))
			PanicOnError(response)
		} else if IsTrue(IsEqual(typeVar, "spot")) {

			response = (<-this.FetchSpotMarkets(params))
			PanicOnError(response)
		} else if IsTrue(IsEqual(typeVar, "swap")) {

			response = (<-this.FetchSwapMarkets(params))
			PanicOnError(response)
		} else {

			response = (<-this.FetchMarkets(params))
			PanicOnError(response)
		}
		// same response as under "fetchMarkets"
		var result interface{} = map[string]interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
			var market interface{} = GetValue(response, i)
			var info interface{} = GetValue(market, "info")
			var ticker interface{} = this.ParseTicker(info, market)
			var symbol interface{} = this.SafeString(ticker, "symbol")
			AddElementToObject(result, symbol, ticker)
		}

		ch <- this.FilterByArrayTickers(result, "symbol", symbols)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name hyperliquid#fetchFundingRates
 * @description retrieves data on all swap markets for hyperliquid
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/perpetuals#retrieve-perpetuals-asset-contexts-includes-mark-price-current-funding-open-interest-etc
 * @param {string[]} [symbols] list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func (this *HyperliquidCore) FetchFundingRates(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		var request interface{} = map[string]interface{}{
			"type": "metaAndAssetCtxs",
		}

		response := (<-this.PublicPostInfo(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     [
		//         {
		//             "universe": [
		//                 {
		//                     "maxLeverage": 50,
		//                     "name": "SOL",
		//                     "onlyIsolated": false,
		//                     "szDecimals": 2
		//                 }
		//             ]
		//         },
		//         [
		//             {
		//                 "dayNtlVlm": "9450588.2273",
		//                 "funding": "0.0000198",
		//                 "impactPxs": [
		//                     "108.04",
		//                     "108.06"
		//                 ],
		//                 "markPx": "108.04",
		//                 "midPx": "108.05",
		//                 "openInterest": "10764.48",
		//                 "oraclePx": "107.99",
		//                 "premium": "0.00055561",
		//                 "prevDayPx": "111.81"
		//             }
		//         ]
		//     ]
		//
		//
		var meta interface{} = this.SafeDict(response, 0, map[string]interface{}{})
		var universe interface{} = this.SafeList(meta, "universe", []interface{}{})
		var assetCtxs interface{} = this.SafeList(response, 1, []interface{}{})
		var result interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(universe)); i++ {
			var data interface{} = this.Extend(this.SafeDict(universe, i, map[string]interface{}{}), this.SafeDict(assetCtxs, i, map[string]interface{}{}))
			AppendToArray(&result, data)
		}

		ch <- this.ParseFundingRates(result, symbols)
		return nil

	}()
	return ch
}
func (this *HyperliquidCore) ParseFundingRate(info interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "maxLeverage": "50",
	//         "name": "ETH",
	//         "onlyIsolated": false,
	//         "szDecimals": "4",
	//         "dayNtlVlm": "1709813.11535",
	//         "funding": "0.00004807",
	//         "impactPxs": [
	//             "2369.3",
	//             "2369.6"
	//         ],
	//         "markPx": "2369.6",
	//         "midPx": "2369.45",
	//         "openInterest": "1815.4712",
	//         "oraclePx": "2367.3",
	//         "premium": "0.00090821",
	//         "prevDayPx": "2381.5"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var base interface{} = this.SafeString(info, "name")
	var marketId interface{} = this.CoinToMarketId(base)
	var symbol interface{} = this.SafeSymbol(marketId, market)
	var funding interface{} = this.SafeNumber(info, "funding")
	var markPx interface{} = this.SafeNumber(info, "markPx")
	var oraclePx interface{} = this.SafeNumber(info, "oraclePx")
	var fundingTimestamp interface{} = Multiply(Multiply(Multiply((Add(MathFloor(Divide(Divide(Divide(this.Milliseconds(), 60), 60), 1000)), 1)), 60), 60), 1000)
	return map[string]interface{}{
		"info":                     info,
		"symbol":                   symbol,
		"markPrice":                markPx,
		"indexPrice":               oraclePx,
		"interestRate":             nil,
		"estimatedSettlePrice":     nil,
		"timestamp":                nil,
		"datetime":                 nil,
		"fundingRate":              funding,
		"fundingTimestamp":         fundingTimestamp,
		"fundingDatetime":          this.Iso8601(fundingTimestamp),
		"nextFundingRate":          nil,
		"nextFundingTimestamp":     nil,
		"nextFundingDatetime":      nil,
		"previousFundingRate":      nil,
		"previousFundingTimestamp": nil,
		"previousFundingDatetime":  nil,
		"interval":                 "1h",
	}
}
func (this *HyperliquidCore) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "prevDayPx": "3400.5",
	//         "dayNtlVlm": "511297257.47936022",
	//         "markPx": "3464.7",
	//         "midPx": "3465.05",
	//         "oraclePx": "3460.1", // only in swap
	//         "openInterest": "64638.1108", // only in swap
	//         "premium": "0.00141614", // only in swap
	//         "funding": "0.00008727", // only in swap
	//         "impactPxs": [ "3465.0", "3465.1" ], // only in swap
	//         "coin": "PURR", // only in spot
	//         "circulatingSupply": "998949190.03400207", // only in spot
	//     },
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var name interface{} = this.SafeString(ticker, "name")
	var marketId interface{} = this.CoinToMarketId(name)
	market = this.SafeMarket(marketId, market)
	var bidAsk interface{} = this.SafeList(ticker, "impactPxs")
	return this.SafeTicker(map[string]interface{}{
		"symbol":        GetValue(market, "symbol"),
		"timestamp":     nil,
		"datetime":      nil,
		"previousClose": this.SafeNumber(ticker, "prevDayPx"),
		"close":         this.SafeNumber(ticker, "midPx"),
		"last":          this.SafeNumber(ticker, "price"),
		"bid":           this.SafeNumber(bidAsk, 0),
		"ask":           this.SafeNumber(bidAsk, 1),
		"quoteVolume":   this.SafeNumber(ticker, "dayNtlVlm"),
		"info":          ticker,
	}, market)
}

/**
 * @method
 * @name hyperliquid#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#candle-snapshot
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents, support '1m', '15m', '1h', '1d'
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest candle to fetch
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func (this *HyperliquidCore) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		timeframe := GetArg(optionalArgs, 0, "1m")
		_ = timeframe
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes14428 := (<-this.LoadMarkets())
		PanicOnError(retRes14428)
		var market interface{} = this.Market(symbol)
		var until interface{} = this.SafeInteger(params, "until", this.Milliseconds())
		var useTail interface{} = IsEqual(since, nil)
		var originalSince interface{} = since
		if IsTrue(IsEqual(since, nil)) {
			if IsTrue(!IsEqual(limit, nil)) {
				// optimization if limit is provided
				var timeframeInMilliseconds interface{} = Multiply(this.ParseTimeframe(timeframe), 1000)
				since = this.Sum(until, Multiply(Multiply(timeframeInMilliseconds, limit), OpNeg(1)))
				if IsTrue(IsLessThan(since, 0)) {
					since = 0
				}
				useTail = false
			} else {
				since = 0
			}
		}
		params = this.Omit(params, []interface{}{"until"})
		var request interface{} = map[string]interface{}{
			"type": "candleSnapshot",
			"req": map[string]interface{}{
				"coin":      Ternary(IsTrue(GetValue(market, "swap")), GetValue(market, "baseName"), GetValue(market, "id")),
				"interval":  this.SafeString(this.Timeframes, timeframe, timeframe),
				"startTime": since,
				"endTime":   until,
			},
		}

		response := (<-this.PublicPostInfo(this.Extend(request, params)))
		PanicOnError(response)

		//
		//     [
		//         {
		//             "T": 1704287699999,
		//             "c": "2226.4",
		//             "h": "2247.9",
		//             "i": "15m",
		//             "l": "2224.6",
		//             "n": 46,
		//             "o": "2247.9",
		//             "s": "ETH",
		//             "t": 1704286800000,
		//             "v": "591.6427"
		//         }
		//     ]
		//
		ch <- this.ParseOHLCVs(response, market, timeframe, originalSince, limit, useTail)
		return nil

	}()
	return ch
}
func (this *HyperliquidCore) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "T": 1704287699999,
	//         "c": "2226.4",
	//         "h": "2247.9",
	//         "i": "15m",
	//         "l": "2224.6",
	//         "n": 46,
	//         "o": "2247.9",
	//         "s": "ETH",
	//         "t": 1704286800000,
	//         "v": "591.6427"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	return []interface{}{this.SafeInteger(ohlcv, "t"), this.SafeNumber(ohlcv, "o"), this.SafeNumber(ohlcv, "h"), this.SafeNumber(ohlcv, "l"), this.SafeNumber(ohlcv, "c"), this.SafeNumber(ohlcv, "v")}
}

/**
 * @method
 * @name hyperliquid#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#retrieve-a-users-fills
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#retrieve-a-users-fills-by-time
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest trade
 * @param {string} [params.address] wallet address that made trades
 * @param {string} [params.user] wallet address that made trades
 * @param {string} [params.subAccountAddress] sub account user address
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
 */
func (this *HyperliquidCore) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		since := GetArg(optionalArgs, 0, nil)
		_ = since
		limit := GetArg(optionalArgs, 1, nil)
		_ = limit
		params := GetArg(optionalArgs, 2, map[string]interface{}{})
		_ = params
		var userAddress interface{} = nil
		userAddressparamsVariable := this.HandlePublicAddress("fetchTrades", params)
		userAddress = GetValue(userAddressparamsVariable, 0)
		params = GetValue(userAddressparamsVariable, 1)

		retRes15348 := (<-this.LoadMarkets())
		PanicOnError(retRes15348)
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
		}
		var request interface{} = map[string]interface{}{
			"user": userAddress,
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "type", "userFillsByTime")
			AddElementToObject(request, "startTime", since)
		} else {
			AddElementToObject(request, "type", "userFills")
		}
		var until interface{} = this.SafeInteger(params, "until")
		params = this.Omit(params, "until")
		if IsTrue(!IsEqual(until, nil)) {
			AddElementToObject(request, "endTime", until)
		}

		response := (<-this.PublicPostInfo(this.Extend(request, params)))
		PanicOnError(response)

		//
		//     [
		//         {
		//             "closedPnl": "0.19343",
		//             "coin": "ETH",
		//             "crossed": true,
		//             "dir": "Close Long",
		//             "fee": "0.050062",
		//             "hash": "0x09d77c96791e98b5775a04092584ab010d009445119c71e4005c0d634ea322bc",
		//             "liquidationMarkPx": null,
		//             "oid": 3929354691,
		//             "px": "2381.1",
		//             "side": "A",
		//             "startPosition": "0.0841",
		//             "sz": "0.0841",
		//             "tid": 128423918764978,
		//             "time": 1704262888911
		//         }
		//     ]
		//
		ch <- this.ParseTrades(response, market, since, limit)
		return nil

	}()
	return ch
}
func (this *HyperliquidCore) AmountToPrecision(symbol interface{}, amount interface{}) interface{} {
	var market interface{} = this.Market(symbol)
	return this.DecimalToPrecision(amount, ROUND, GetValue(GetValue(market, "precision"), "amount"), this.PrecisionMode, this.PaddingMode)
}
func (this *HyperliquidCore) PriceToPrecision(symbol interface{}, price interface{}) interface{} {
	var market interface{} = this.Market(symbol)
	var priceStr interface{} = this.NumberToString(price)
	var integerPart interface{} = GetValue(Split(priceStr, "."), 0)
	var significantDigits interface{} = mathMax(5, GetLength(integerPart))
	var result interface{} = this.DecimalToPrecision(price, ROUND, significantDigits, SIGNIFICANT_DIGITS, this.PaddingMode)
	var maxDecimals interface{} = Ternary(IsTrue(GetValue(market, "spot")), 8, 6)
	var subtractedValue interface{} = Subtract(maxDecimals, this.PrecisionFromString(this.SafeString(GetValue(market, "precision"), "amount")))
	return this.DecimalToPrecision(result, ROUND, subtractedValue, DECIMAL_PLACES, this.PaddingMode)
}
func (this *HyperliquidCore) HashMessage(message interface{}) interface{} {
	return Add("0x", this.Hash(message, keccak, "hex"))
}
func (this *HyperliquidCore) SignHash(hash interface{}, privateKey interface{}) interface{} {
	var signature interface{} = Ecdsa(Slice(hash, OpNeg(64), nil), Slice(privateKey, OpNeg(64), nil), secp256k1, nil)
	return map[string]interface{}{
		"r": Add("0x", GetValue(signature, "r")),
		"s": Add("0x", GetValue(signature, "s")),
		"v": this.Sum(27, GetValue(signature, "v")),
	}
}
func (this *HyperliquidCore) SignMessage(message interface{}, privateKey interface{}) interface{} {
	return this.SignHash(this.HashMessage(message), Slice(privateKey, OpNeg(64), nil))
}
func (this *HyperliquidCore) ConstructPhantomAgent(hash interface{}, optionalArgs ...interface{}) interface{} {
	isTestnet := GetArg(optionalArgs, 0, true)
	_ = isTestnet
	var source interface{} = Ternary(IsTrue((isTestnet)), "b", "a")
	return map[string]interface{}{
		"source":       source,
		"connectionId": hash,
	}
}
func (this *HyperliquidCore) ActionHash(action interface{}, vaultAddress interface{}, nonce interface{}, optionalArgs ...interface{}) interface{} {
	expiresAfter := GetArg(optionalArgs, 0, nil)
	_ = expiresAfter
	var dataBinary interface{} = this.Packb(action)
	var dataHex interface{} = this.BinaryToBase16(dataBinary)
	var data interface{} = dataHex
	data = Add(data, Add("00000", this.IntToBase16(nonce)))
	if IsTrue(IsEqual(vaultAddress, nil)) {
		data = Add(data, "00")
	} else {
		data = Add(data, "01")
		data = Add(data, vaultAddress)
	}
	if IsTrue(!IsEqual(expiresAfter, nil)) {
		data = Add(data, "00")
		data = Add(data, Add("00000", this.IntToBase16(expiresAfter)))
	}
	return this.Hash(this.Base16ToBinary(data), keccak, "binary")
}
func (this *HyperliquidCore) SignL1Action(action interface{}, nonce interface{}, optionalArgs ...interface{}) interface{} {
	vaultAdress := GetArg(optionalArgs, 0, nil)
	_ = vaultAdress
	expiresAfter := GetArg(optionalArgs, 1, nil)
	_ = expiresAfter
	var hash interface{} = this.ActionHash(action, vaultAdress, nonce, expiresAfter)
	var isTestnet interface{} = this.SafeBool(this.Options, "sandboxMode", false)
	var phantomAgent interface{} = this.ConstructPhantomAgent(hash, isTestnet)
	// const data: Dict = {
	//     'domain': {
	//         'chainId': 1337,
	//         'name': 'Exchange',
	//         'verifyingContract': '0x0000000000000000000000000000000000000000',
	//         'version': '1',
	//     },
	//     'types': {
	//         'Agent': [
	//             { 'name': 'source', 'type': 'string' },
	//             { 'name': 'connectionId', 'type': 'bytes32' },
	//         ],
	//         'EIP712Domain': [
	//             { 'name': 'name', 'type': 'string' },
	//             { 'name': 'version', 'type': 'string' },
	//             { 'name': 'chainId', 'type': 'uint256' },
	//             { 'name': 'verifyingContract', 'type': 'address' },
	//         ],
	//     },
	//     'primaryType': 'Agent',
	//     'message': phantomAgent,
	// };
	var zeroAddress interface{} = this.SafeString(this.Options, "zeroAddress")
	var chainId interface{} = 1337 // check this out
	var domain interface{} = map[string]interface{}{
		"chainId":           chainId,
		"name":              "Exchange",
		"verifyingContract": zeroAddress,
		"version":           "1",
	}
	var messageTypes interface{} = map[string]interface{}{
		"Agent": []interface{}{map[string]interface{}{
			"name": "source",
			"type": "string",
		}, map[string]interface{}{
			"name": "connectionId",
			"type": "bytes32",
		}},
	}
	var msg interface{} = this.EthEncodeStructuredData(domain, messageTypes, phantomAgent)
	var signature interface{} = this.SignMessage(msg, this.PrivateKey)
	return signature
}
func (this *HyperliquidCore) SignUserSignedAction(messageTypes interface{}, message interface{}) interface{} {
	var zeroAddress interface{} = this.SafeString(this.Options, "zeroAddress")
	var chainId interface{} = 421614 // check this out
	var domain interface{} = map[string]interface{}{
		"chainId":           chainId,
		"name":              "HyperliquidSignTransaction",
		"verifyingContract": zeroAddress,
		"version":           "1",
	}
	var msg interface{} = this.EthEncodeStructuredData(domain, messageTypes, message)
	var signature interface{} = this.SignMessage(msg, this.PrivateKey)
	return signature
}
func (this *HyperliquidCore) BuildUsdSendSig(message interface{}) interface{} {
	var messageTypes interface{} = map[string]interface{}{
		"HyperliquidTransaction:UsdSend": []interface{}{map[string]interface{}{
			"name": "hyperliquidChain",
			"type": "string",
		}, map[string]interface{}{
			"name": "destination",
			"type": "string",
		}, map[string]interface{}{
			"name": "amount",
			"type": "string",
		}, map[string]interface{}{
			"name": "time",
			"type": "uint64",
		}},
	}
	return this.SignUserSignedAction(messageTypes, message)
}
func (this *HyperliquidCore) BuildUsdClassSendSig(message interface{}) interface{} {
	var messageTypes interface{} = map[string]interface{}{
		"HyperliquidTransaction:UsdClassTransfer": []interface{}{map[string]interface{}{
			"name": "hyperliquidChain",
			"type": "string",
		}, map[string]interface{}{
			"name": "amount",
			"type": "string",
		}, map[string]interface{}{
			"name": "toPerp",
			"type": "bool",
		}, map[string]interface{}{
			"name": "nonce",
			"type": "uint64",
		}},
	}
	return this.SignUserSignedAction(messageTypes, message)
}
func (this *HyperliquidCore) BuildWithdrawSig(message interface{}) interface{} {
	var messageTypes interface{} = map[string]interface{}{
		"HyperliquidTransaction:Withdraw": []interface{}{map[string]interface{}{
			"name": "hyperliquidChain",
			"type": "string",
		}, map[string]interface{}{
			"name": "destination",
			"type": "string",
		}, map[string]interface{}{
			"name": "amount",
			"type": "string",
		}, map[string]interface{}{
			"name": "time",
			"type": "uint64",
		}},
	}
	return this.SignUserSignedAction(messageTypes, message)
}
func (this *HyperliquidCore) BuildUserDexAbstractionSig(message interface{}) interface{} {
	var messageTypes interface{} = map[string]interface{}{
		"HyperliquidTransaction:UserDexAbstraction": []interface{}{map[string]interface{}{
			"name": "hyperliquidChain",
			"type": "string",
		}, map[string]interface{}{
			"name": "user",
			"type": "address",
		}, map[string]interface{}{
			"name": "enabled",
			"type": "bool",
		}, map[string]interface{}{
			"name": "nonce",
			"type": "uint64",
		}},
	}
	return this.SignUserSignedAction(messageTypes, message)
}
func (this *HyperliquidCore) BuildApproveBuilderFeeSig(message interface{}) interface{} {
	var messageTypes interface{} = map[string]interface{}{
		"HyperliquidTransaction:ApproveBuilderFee": []interface{}{map[string]interface{}{
			"name": "hyperliquidChain",
			"type": "string",
		}, map[string]interface{}{
			"name": "maxFeeRate",
			"type": "string",
		}, map[string]interface{}{
			"name": "builder",
			"type": "address",
		}, map[string]interface{}{
			"name": "nonce",
			"type": "uint64",
		}},
	}
	return this.SignUserSignedAction(messageTypes, message)
}
func (this *HyperliquidCore) SetRef() <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		if IsTrue(this.SafeBool(this.Options, "refSet", false)) {

			ch <- true
			return nil
		}
		AddElementToObject(this.Options, "refSet", true)
		var action interface{} = map[string]interface{}{
			"type": "setReferrer",
			"code": this.SafeString(this.Options, "ref", "CCXT1"),
		}
		var nonce interface{} = this.Milliseconds()
		var signature interface{} = this.SignL1Action(action, nonce)
		var request interface{} = map[string]interface{}{
			"action":    action,
			"nonce":     nonce,
			"signature": signature,
		}
		var response interface{} = nil

		{
			func(this *HyperliquidCore) (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func(this *HyperliquidCore) interface{} {
							// catch block:
							response = nil // ignore this
							return nil
						}(this)
					}
				}()
				// try block:

				response = (<-this.PrivatePostExchange(request))
				PanicOnError(response)

				ch <- response
				return nil

			}(this)

		}

		ch <- response
		return nil

	}()
	return ch
}
func (this *HyperliquidCore) ApproveBuilderFee(builder interface{}, maxFeeRate interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		var nonce interface{} = this.Milliseconds()
		var isSandboxMode interface{} = this.SafeBool(this.Options, "sandboxMode", false)
		var payload interface{} = map[string]interface{}{
			"hyperliquidChain": Ternary(IsTrue(isSandboxMode), "Testnet", "Mainnet"),
			"maxFeeRate":       maxFeeRate,
			"builder":          builder,
			"nonce":            nonce,
		}
		var sig interface{} = this.BuildApproveBuilderFeeSig(payload)
		var action interface{} = map[string]interface{}{
			"hyperliquidChain": GetValue(payload, "hyperliquidChain"),
			"signatureChainId": "0x66eee",
			"maxFeeRate":       GetValue(payload, "maxFeeRate"),
			"builder":          GetValue(payload, "builder"),
			"nonce":            nonce,
			"type":             "approveBuilderFee",
		}
		var request interface{} = map[string]interface{}{
			"action":       action,
			"nonce":        nonce,
			"signature":    sig,
			"vaultAddress": nil,
		}

		retRes181315 := (<-this.PrivatePostExchange(request))
		PanicOnError(retRes181315)
		//
		// {
		//     "status": "ok",
		//     "response": {
		//         "type": "default"
		//     }
		// }
		//
		ch <- retRes181315
		return nil

	}()
	return ch
}
func (this *HyperliquidCore) InitializeClient() <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)

		{
			func(this *HyperliquidCore) (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func(this *HyperliquidCore) interface{} {
							// catch block:

							ch <- false
							return nil

						}(this)
					}
				}()
				// try block:

				retRes181812 := (<-promiseAll([]interface{}{this.HandleBuilderFeeApproval(), this.SetRef()}))
				PanicOnError(retRes181812)
				return nil
			}(this)

		}

		ch <- true
		return nil

	}()
	return ch
}
func (this *HyperliquidCore) HandleBuilderFeeApproval() <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		var buildFee interface{} = this.SafeBool(this.Options, "builderFee", true)
		if !IsTrue(buildFee) {

			ch <- false // skip if builder fee is not enabled
			return nil
		}
		var approvedBuilderFee interface{} = this.SafeBool(this.Options, "approvedBuilderFee", false)
		if IsTrue(approvedBuilderFee) {

			ch <- true // skip if builder fee is already approved
			return nil
		}

		{
			func(this *HyperliquidCore) (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func(this *HyperliquidCore) interface{} {
							// catch block:
							AddElementToObject(this.Options, "builderFee", false) // disable builder fee if an error occurs
							return nil
						}(this)
					}
				}()
				// try block:
				var builder interface{} = this.SafeString(this.Options, "builder", "0x6530512A6c89C7cfCEbC3BA7fcD9aDa5f30827a6")
				var maxFeeRate interface{} = this.SafeString(this.Options, "feeRate", "0.01%")

				retRes183712 := (<-this.ApproveBuilderFee(builder, maxFeeRate))
				PanicOnError(retRes183712)
				AddElementToObject(this.Options, "approvedBuilderFee", true)
				return nil
			}(this)

		}

		ch <- true
		return nil

	}()
	return ch
}
func (this *HyperliquidCore) EnableUserDexAbstraction(enabled interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		var userAddress interface{} = nil
		userAddressparamsVariable := this.HandlePublicAddress("enableUserDexAbstraction", params)
		userAddress = GetValue(userAddressparamsVariable, 0)
		params = GetValue(userAddressparamsVariable, 1)
		var nonce interface{} = this.Milliseconds()
		var isSandboxMode interface{} = this.SafeBool(this.Options, "sandboxMode", false)
		var payload interface{} = map[string]interface{}{
			"hyperliquidChain": Ternary(IsTrue(isSandboxMode), "Testnet", "Mainnet"),
			"user":             userAddress,
			"enabled":          enabled,
			"nonce":            nonce,
		}
		var sig interface{} = this.BuildUserDexAbstractionSig(payload)
		var action interface{} = map[string]interface{}{
			"hyperliquidChain": GetValue(payload, "hyperliquidChain"),
			"signatureChainId": "0x66eee",
			"enabled":          GetValue(payload, "enabled"),
			"user":             GetValue(payload, "user"),
			"nonce":            nonce,
			"type":             "userDexAbstraction",
		}
		var request interface{} = map[string]interface{}{
			"action":       action,
			"nonce":        nonce,
			"signature":    sig,
			"vaultAddress": nil,
		}

		retRes187915 := (<-this.PrivatePostExchange(request))
		PanicOnError(retRes187915)
		//
		// {
		//     "status": "ok",
		//     "response": {
		//         "type": "default"
		//     }
		// }
		//
		ch <- retRes187915
		return nil

	}()
	return ch
}

/**
 * @method
 * @name hyperliquid#createOrder
 * @description create a trade order
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#place-an-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.timeInForce] 'Gtc', 'Ioc', 'Alo'
 * @param {bool} [params.postOnly] true or false whether the order is post-only
 * @param {bool} [params.reduceOnly] true or false whether the order is reduce-only
 * @param {float} [params.triggerPrice] The price at which a trigger order is triggered at
 * @param {string} [params.clientOrderId] client order id, (optional 128 bit hex string e.g. 0x1234567890abcdef1234567890abcdef)
 * @param {string} [params.slippage] the slippage for market order
 * @param {string} [params.vaultAddress] the vault address for order
 * @param {string} [params.subAccountAddress] sub account user address
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *HyperliquidCore) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		price := GetArg(optionalArgs, 0, nil)
		_ = price
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes19048 := (<-this.LoadMarkets())
		PanicOnError(retRes19048)
		orderglobalParamsVariable := this.ParseCreateEditOrderArgs(nil, symbol, typeVar, side, amount, price, params)
		order := GetValue(orderglobalParamsVariable, 0)
		globalParams := GetValue(orderglobalParamsVariable, 1)

		orders := (<-this.CreateOrders([]interface{}{order}, globalParams))
		PanicOnError(orders)

		ch <- GetValue(orders, 0)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name hyperliquid#createOrders
 * @description create a list of trade orders
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#place-an-order
 * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *HyperliquidCore) CreateOrders(orders interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes19208 := (<-this.LoadMarkets())
		PanicOnError(retRes19208)

		retRes19218 := (<-this.InitializeClient())
		PanicOnError(retRes19218)
		var request interface{} = this.CreateOrdersRequest(orders, params)

		response := (<-this.PrivatePostExchange(request))
		PanicOnError(response)
		//
		//     {
		//         "status": "ok",
		//         "response": {
		//             "type": "order",
		//             "data": {
		//                 "statuses": [
		//                     {
		//                         "resting": {
		//                             "oid": 5063830287
		//                         }
		//                     }
		//                 ]
		//             }
		//         }
		//     }
		//
		var responseObj interface{} = this.SafeDict(response, "response", map[string]interface{}{})
		var data interface{} = this.SafeDict(responseObj, "data", map[string]interface{}{})
		var statuses interface{} = this.SafeList(data, "statuses", []interface{}{})
		var ordersToBeParsed interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(statuses)); i++ {
			var order interface{} = GetValue(statuses, i)
			if IsTrue(IsEqual(order, "waitingForTrigger")) {
				AppendToArray(&ordersToBeParsed, map[string]interface{}{
					"status": order,
				}) // tp/sl orders can return a string like "waitingForTrigger",
			} else {
				AppendToArray(&ordersToBeParsed, order)
			}
		}

		ch <- this.ParseOrders(ordersToBeParsed, nil)
		return nil

	}()
	return ch
}
func (this *HyperliquidCore) CreateOrderRequest(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{} {
	price := GetArg(optionalArgs, 0, nil)
	_ = price
	params := GetArg(optionalArgs, 1, map[string]interface{}{})
	_ = params
	var market interface{} = this.Market(symbol)
	typeVar = ToUpper(typeVar)
	side = ToUpper(side)
	var isMarket interface{} = (IsEqual(typeVar, "MARKET"))
	var isBuy interface{} = (IsEqual(side, "BUY"))
	var clientOrderId interface{} = this.SafeString2(params, "clientOrderId", "client_id")
	var slippage interface{} = this.SafeString(params, "slippage")
	var defaultTimeInForce interface{} = Ternary(IsTrue((isMarket)), "ioc", "gtc")
	var postOnly interface{} = this.SafeBool(params, "postOnly", false)
	if IsTrue(postOnly) {
		defaultTimeInForce = "alo"
	}
	var timeInForce interface{} = this.SafeStringLower(params, "timeInForce", defaultTimeInForce)
	timeInForce = this.Capitalize(timeInForce)
	var triggerPrice interface{} = this.SafeString2(params, "triggerPrice", "stopPrice")
	var stopLossPrice interface{} = this.SafeString(params, "stopLossPrice", triggerPrice)
	var takeProfitPrice interface{} = this.SafeString(params, "takeProfitPrice")
	var isTrigger interface{} = (IsTrue(stopLossPrice) || IsTrue(takeProfitPrice))
	var px interface{} = nil
	if IsTrue(isMarket) {
		if IsTrue(IsEqual(price, nil)) {
			panic(ArgumentsRequired(Add(this.Id, "  market orders require price to calculate the max slippage price. Default slippage can be set in options (default is 5%).")))
		}
		px = Ternary(IsTrue((isBuy)), Precise.StringMul(price, Precise.StringAdd("1", slippage)), Precise.StringMul(price, Precise.StringSub("1", slippage)))
		px = this.PriceToPrecision(symbol, px) // round after adding slippage
	} else {
		px = this.PriceToPrecision(symbol, price)
	}
	var sz interface{} = this.AmountToPrecision(symbol, amount)
	var reduceOnly interface{} = this.SafeBool(params, "reduceOnly", false)
	var orderType interface{} = map[string]interface{}{}
	if IsTrue(isTrigger) {
		var isTp interface{} = false
		if IsTrue(!IsEqual(takeProfitPrice, nil)) {
			triggerPrice = this.PriceToPrecision(symbol, takeProfitPrice)
			isTp = true
		} else {
			triggerPrice = this.PriceToPrecision(symbol, stopLossPrice)
		}
		AddElementToObject(orderType, "trigger", map[string]interface{}{
			"isMarket":  isMarket,
			"triggerPx": triggerPrice,
			"tpsl":      Ternary(IsTrue((isTp)), "tp", "sl"),
		})
	} else {
		AddElementToObject(orderType, "limit", map[string]interface{}{
			"tif": timeInForce,
		})
	}
	params = this.Omit(params, []interface{}{"clientOrderId", "slippage", "triggerPrice", "stopPrice", "stopLossPrice", "takeProfitPrice", "timeInForce", "client_id", "reduceOnly", "postOnly"})
	var orderObj interface{} = map[string]interface{}{
		"a": this.ParseToInt(GetValue(market, "baseId")),
		"b": isBuy,
		"p": px,
		"s": sz,
		"r": reduceOnly,
		"t": orderType,
	}
	if IsTrue(!IsEqual(clientOrderId, nil)) {
		AddElementToObject(orderObj, "c", clientOrderId)
	}
	return orderObj
}
func (this *HyperliquidCore) CreateOrdersRequest(orders interface{}, optionalArgs ...interface{}) interface{} {
	/**
	 * @method
	 * @name hyperliquid#createOrdersRequest
	 * @description create a list of trade orders
	 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#place-an-order
	 * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
	 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
	 */
	params := GetArg(optionalArgs, 0, map[string]interface{}{})
	_ = params
	this.CheckRequiredCredentials()
	var defaultSlippage interface{} = this.SafeString(this.Options, "defaultSlippage")
	defaultSlippage = this.SafeString(params, "slippage", defaultSlippage)
	var hasClientOrderId interface{} = false
	for i := 0; IsLessThan(i, GetArrayLength(orders)); i++ {
		var rawOrder interface{} = GetValue(orders, i)
		var orderParams interface{} = this.SafeDict(rawOrder, "params", map[string]interface{}{})
		var clientOrderId interface{} = this.SafeString2(orderParams, "clientOrderId", "client_id")
		if IsTrue(!IsEqual(clientOrderId, nil)) {
			hasClientOrderId = true
		}
	}
	if IsTrue(hasClientOrderId) {
		for i := 0; IsLessThan(i, GetArrayLength(orders)); i++ {
			var rawOrder interface{} = GetValue(orders, i)
			var orderParams interface{} = this.SafeDict(rawOrder, "params", map[string]interface{}{})
			var clientOrderId interface{} = this.SafeString2(orderParams, "clientOrderId", "client_id")
			if IsTrue(IsEqual(clientOrderId, nil)) {
				panic(ArgumentsRequired(Add(this.Id, " createOrders() all orders must have clientOrderId if at least one has a clientOrderId")))
			}
		}
	}
	params = this.Omit(params, []interface{}{"slippage", "clientOrderId", "client_id", "slippage", "triggerPrice", "stopPrice", "stopLossPrice", "takeProfitPrice", "timeInForce"})
	var nonce interface{} = this.Milliseconds()
	var orderReq interface{} = []interface{}{}
	var grouping interface{} = "na"
	for i := 0; IsLessThan(i, GetArrayLength(orders)); i++ {
		var rawOrder interface{} = GetValue(orders, i)
		var marketId interface{} = this.SafeString(rawOrder, "symbol")
		var market interface{} = this.Market(marketId)
		var symbol interface{} = GetValue(market, "symbol")
		var typeVar interface{} = this.SafeStringUpper(rawOrder, "type")
		var side interface{} = this.SafeStringUpper(rawOrder, "side")
		var amount interface{} = this.SafeString(rawOrder, "amount")
		var price interface{} = this.SafeString(rawOrder, "price")
		var orderParams interface{} = this.SafeDict(rawOrder, "params", map[string]interface{}{})
		var slippage interface{} = this.SafeString(orderParams, "slippage", defaultSlippage)
		AddElementToObject(orderParams, "slippage", slippage)
		var stopLoss interface{} = this.SafeValue(orderParams, "stopLoss")
		var takeProfit interface{} = this.SafeValue(orderParams, "takeProfit")
		var hasStopLoss interface{} = (!IsEqual(stopLoss, nil))
		var hasTakeProfit interface{} = (!IsEqual(takeProfit, nil))
		orderParams = this.Omit(orderParams, []interface{}{"stopLoss", "takeProfit"})
		var mainOrderObj interface{} = this.CreateOrderRequest(symbol, typeVar, side, amount, price, orderParams)
		AppendToArray(&orderReq, mainOrderObj)
		if IsTrue(IsTrue(hasStopLoss) || IsTrue(hasTakeProfit)) {
			// grouping opposed orders for sl/tp
			var stopLossOrderTriggerPrice interface{} = this.SafeStringN(stopLoss, []interface{}{"triggerPrice", "stopPrice"})
			var stopLossOrderType interface{} = this.SafeString(stopLoss, "type", "limit")
			var stopLossOrderLimitPrice interface{} = this.SafeStringN(stopLoss, []interface{}{"price", "stopLossPrice"}, stopLossOrderTriggerPrice)
			var takeProfitOrderTriggerPrice interface{} = this.SafeStringN(takeProfit, []interface{}{"triggerPrice", "stopPrice"})
			var takeProfitOrderType interface{} = this.SafeString(takeProfit, "type", "limit")
			var takeProfitOrderLimitPrice interface{} = this.SafeStringN(takeProfit, []interface{}{"price", "takeProfitPrice"}, takeProfitOrderTriggerPrice)
			grouping = "normalTpsl"
			orderParams = this.Omit(orderParams, []interface{}{"stopLoss", "takeProfit"})
			var triggerOrderSide interface{} = ""
			if IsTrue(IsEqual(side, "BUY")) {
				triggerOrderSide = "sell"
			} else {
				triggerOrderSide = "buy"
			}
			if IsTrue(hasTakeProfit) {
				var orderObj interface{} = this.CreateOrderRequest(symbol, takeProfitOrderType, triggerOrderSide, amount, takeProfitOrderLimitPrice, this.Extend(orderParams, map[string]interface{}{
					"takeProfitPrice": takeProfitOrderTriggerPrice,
					"reduceOnly":      true,
				}))
				AppendToArray(&orderReq, orderObj)
			}
			if IsTrue(hasStopLoss) {
				var orderObj interface{} = this.CreateOrderRequest(symbol, stopLossOrderType, triggerOrderSide, amount, stopLossOrderLimitPrice, this.Extend(orderParams, map[string]interface{}{
					"stopLossPrice": stopLossOrderTriggerPrice,
					"reduceOnly":    true,
				}))
				AppendToArray(&orderReq, orderObj)
			}
		}
	}
	var vaultAddress interface{} = nil
	vaultAddressparamsVariable := this.HandleOptionAndParams(params, "createOrder", "vaultAddress")
	vaultAddress = GetValue(vaultAddressparamsVariable, 0)
	params = GetValue(vaultAddressparamsVariable, 1)
	vaultAddress = this.FormatVaultAddress(vaultAddress)
	var orderAction interface{} = map[string]interface{}{
		"type":     "order",
		"orders":   orderReq,
		"grouping": grouping,
	}
	if IsTrue(this.SafeBool(this.Options, "approvedBuilderFee", false)) {
		var wallet interface{} = this.SafeStringLower(this.Options, "builder", "0x6530512A6c89C7cfCEbC3BA7fcD9aDa5f30827a6")
		AddElementToObject(orderAction, "builder", map[string]interface{}{
			"b": wallet,
			"f": this.SafeInteger(this.Options, "feeInt", 10),
		})
	}
	var signature interface{} = this.SignL1Action(orderAction, nonce, vaultAddress)
	var request interface{} = map[string]interface{}{
		"action":    orderAction,
		"nonce":     nonce,
		"signature": signature,
	}
	if IsTrue(!IsEqual(vaultAddress, nil)) {
		params = this.Omit(params, "vaultAddress")
		AddElementToObject(request, "vaultAddress", vaultAddress)
	}
	return request
}

/**
 * @method
 * @name hyperliquid#cancelOrder
 * @description cancels an open order
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#cancel-order-s
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#cancel-order-s-by-cloid
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.clientOrderId] client order id, (optional 128 bit hex string e.g. 0x1234567890abcdef1234567890abcdef)
 * @param {string} [params.vaultAddress] the vault address for order
 * @param {string} [params.subAccountAddress] sub account user address
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *HyperliquidCore) CancelOrder(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		orders := (<-this.CancelOrders([]interface{}{id}, symbol, params))
		PanicOnError(orders)

		ch <- this.SafeDict(orders, 0)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name hyperliquid#cancelOrders
 * @description cancel multiple orders
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#cancel-order-s
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#cancel-order-s-by-cloid
 * @param {string[]} ids order ids
 * @param {string} [symbol] unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string|string[]} [params.clientOrderId] client order ids, (optional 128 bit hex string e.g. 0x1234567890abcdef1234567890abcdef)
 * @param {string} [params.vaultAddress] the vault address
 * @param {string} [params.subAccountAddress] sub account user address
 * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *HyperliquidCore) CancelOrders(ids interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		this.CheckRequiredCredentials()
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " cancelOrders() requires a symbol argument")))
		}

		retRes21728 := (<-this.LoadMarkets())
		PanicOnError(retRes21728)

		retRes21738 := (<-this.InitializeClient())
		PanicOnError(retRes21738)
		var request interface{} = this.CancelOrdersRequest(ids, symbol, params)

		response := (<-this.PrivatePostExchange(request))
		PanicOnError(response)
		//
		//     {
		//         "status":"ok",
		//         "response":{
		//             "type":"cancel",
		//             "data":{
		//                 "statuses":[
		//                     "success"
		//                 ]
		//             }
		//         }
		//     }
		//
		var innerResponse interface{} = this.SafeDict(response, "response")
		var data interface{} = this.SafeDict(innerResponse, "data")
		var statuses interface{} = this.SafeList(data, "statuses")
		var orders interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(statuses)); i++ {
			var status interface{} = GetValue(statuses, i)
			AppendToArray(&orders, this.SafeOrder(map[string]interface{}{
				"info":   status,
				"status": status,
			}))
		}

		ch <- orders
		return nil

	}()
	return ch
}
func (this *HyperliquidCore) CancelOrdersRequest(ids interface{}, optionalArgs ...interface{}) interface{} {
	/**
	 * @method
	 * @name hyperliquid#cancelOrdersRequest
	 * @description build the request payload for cancelling multiple orders
	 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#cancel-order-s
	 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#cancel-order-s-by-cloid
	 * @param {string[]} ids order ids
	 * @param {string} symbol unified market symbol
	 * @param {object} [params]
	 * @returns {object} the raw request object to be sent to the exchange
	 */
	symbol := GetArg(optionalArgs, 0, nil)
	_ = symbol
	params := GetArg(optionalArgs, 1, map[string]interface{}{})
	_ = params
	var market interface{} = this.Market(symbol)
	var clientOrderId interface{} = this.SafeValue2(params, "clientOrderId", "client_id")
	params = this.Omit(params, []interface{}{"clientOrderId", "client_id"})
	var nonce interface{} = this.Milliseconds()
	var request interface{} = map[string]interface{}{
		"nonce": nonce,
	}
	var cancelReq interface{} = []interface{}{}
	var cancelAction interface{} = map[string]interface{}{
		"type":    "",
		"cancels": []interface{}{},
	}
	var baseId interface{} = this.ParseToNumeric(GetValue(market, "baseId"))
	if IsTrue(!IsEqual(clientOrderId, nil)) {
		if !IsTrue(IsArray(clientOrderId)) {
			clientOrderId = []interface{}{clientOrderId}
		}
		AddElementToObject(cancelAction, "type", "cancelByCloid")
		for i := 0; IsLessThan(i, GetArrayLength(clientOrderId)); i++ {
			AppendToArray(&cancelReq, map[string]interface{}{
				"asset": baseId,
				"cloid": GetValue(clientOrderId, i),
			})
		}
	} else {
		AddElementToObject(cancelAction, "type", "cancel")
		for i := 0; IsLessThan(i, GetArrayLength(ids)); i++ {
			AppendToArray(&cancelReq, map[string]interface{}{
				"a": baseId,
				"o": this.ParseToNumeric(GetValue(ids, i)),
			})
		}
	}
	AddElementToObject(cancelAction, "cancels", cancelReq)
	var vaultAddress interface{} = nil
	vaultAddressparamsVariable := this.HandleOptionAndParams2(params, "cancelOrders", "vaultAddress", "subAccountAddress")
	vaultAddress = GetValue(vaultAddressparamsVariable, 0)
	params = GetValue(vaultAddressparamsVariable, 1)
	vaultAddress = this.FormatVaultAddress(vaultAddress)
	var signature interface{} = this.SignL1Action(cancelAction, nonce, vaultAddress)
	AddElementToObject(request, "action", cancelAction)
	AddElementToObject(request, "signature", signature)
	if IsTrue(!IsEqual(vaultAddress, nil)) {
		params = this.Omit(params, "vaultAddress")
		AddElementToObject(request, "vaultAddress", vaultAddress)
	}
	return request
}

/**
 * @method
 * @name hyperliquid#cancelOrdersForSymbols
 * @description cancel multiple orders for multiple symbols
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#cancel-order-s
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#cancel-order-s-by-cloid
 * @param {CancellationRequest[]} orders each order should contain the parameters required by cancelOrder namely id and symbol, example [{"id": "a", "symbol": "BTC/USDT"}, {"id": "b", "symbol": "ETH/USDT"}]
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.vaultAddress] the vault address
 * @param {string} [params.subAccountAddress] sub account user address
 * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *HyperliquidCore) CancelOrdersForSymbols(orders interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		this.CheckRequiredCredentials()

		retRes22778 := (<-this.LoadMarkets())
		PanicOnError(retRes22778)

		retRes22788 := (<-this.InitializeClient())
		PanicOnError(retRes22788)
		var nonce interface{} = this.Milliseconds()
		var request interface{} = map[string]interface{}{
			"nonce": nonce,
		}
		var cancelReq interface{} = []interface{}{}
		var cancelAction interface{} = map[string]interface{}{
			"type":    "",
			"cancels": []interface{}{},
		}
		var cancelByCloid interface{} = false
		for i := 0; IsLessThan(i, GetArrayLength(orders)); i++ {
			var order interface{} = GetValue(orders, i)
			var clientOrderId interface{} = this.SafeString(order, "clientOrderId")
			if IsTrue(!IsEqual(clientOrderId, nil)) {
				cancelByCloid = true
			}
			var id interface{} = this.SafeString(order, "id")
			var symbol interface{} = this.SafeString(order, "symbol")
			if IsTrue(IsEqual(symbol, nil)) {
				panic(ArgumentsRequired(Add(this.Id, " cancelOrdersForSymbols() requires a symbol argument in each order")))
			}
			if IsTrue(IsTrue(!IsEqual(id, nil)) && IsTrue(cancelByCloid)) {
				panic(BadRequest(Add(this.Id, " cancelOrdersForSymbols() all orders must have either id or clientOrderId")))
			}
			var assetKey interface{} = Ternary(IsTrue(cancelByCloid), "asset", "a")
			var idKey interface{} = Ternary(IsTrue(cancelByCloid), "cloid", "o")
			var market interface{} = this.Market(symbol)
			var cancelObj interface{} = map[string]interface{}{}
			AddElementToObject(cancelObj, assetKey, this.ParseToNumeric(GetValue(market, "baseId")))
			AddElementToObject(cancelObj, idKey, Ternary(IsTrue(cancelByCloid), clientOrderId, this.ParseToNumeric(id)))
			AppendToArray(&cancelReq, cancelObj)
		}
		AddElementToObject(cancelAction, "type", Ternary(IsTrue(cancelByCloid), "cancelByCloid", "cancel"))
		AddElementToObject(cancelAction, "cancels", cancelReq)
		var vaultAddress interface{} = nil
		vaultAddressparamsVariable := this.HandleOptionAndParams2(params, "cancelOrdersForSymbols", "vaultAddress", "subAccountAddress")
		vaultAddress = GetValue(vaultAddressparamsVariable, 0)
		params = GetValue(vaultAddressparamsVariable, 1)
		vaultAddress = this.FormatVaultAddress(vaultAddress)
		var signature interface{} = this.SignL1Action(cancelAction, nonce, vaultAddress)
		AddElementToObject(request, "action", cancelAction)
		AddElementToObject(request, "signature", signature)
		if IsTrue(!IsEqual(vaultAddress, nil)) {
			params = this.Omit(params, "vaultAddress")
			AddElementToObject(request, "vaultAddress", vaultAddress)
		}

		response := (<-this.PrivatePostExchange(request))
		PanicOnError(response)

		//
		//     {
		//         "status":"ok",
		//         "response":{
		//             "type":"cancel",
		//             "data":{
		//                 "statuses":[
		//                     "success"
		//                 ]
		//             }
		//         }
		//     }
		//
		ch <- []interface{}{this.SafeOrder(map[string]interface{}{
			"info": response,
		})}
		return nil

	}()
	return ch
}

/**
 * @method
 * @name hyperliquid#cancelAllOrdersAfter
 * @description dead man's switch, cancel all orders after the given timeout
 * @param {number} timeout time in milliseconds, 0 represents cancel the timer
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.vaultAddress] the vault address
 * @param {string} [params.subAccountAddress] sub account user address
 * @returns {object} the api result
 */
func (this *HyperliquidCore) CancelAllOrdersAfter(timeout interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		this.CheckRequiredCredentials()

		retRes23538 := (<-this.LoadMarkets())
		PanicOnError(retRes23538)

		retRes23548 := (<-this.InitializeClient())
		PanicOnError(retRes23548)
		params = this.Omit(params, []interface{}{"clientOrderId", "client_id"})
		var nonce interface{} = this.Milliseconds()
		var request interface{} = map[string]interface{}{
			"nonce": nonce,
		}
		var cancelAction interface{} = map[string]interface{}{
			"type": "scheduleCancel",
			"time": Add(nonce, timeout),
		}
		var vaultAddress interface{} = nil
		vaultAddressparamsVariable := this.HandleOptionAndParams2(params, "cancelAllOrdersAfter", "vaultAddress", "subAccountAddress")
		vaultAddress = GetValue(vaultAddressparamsVariable, 0)
		params = GetValue(vaultAddressparamsVariable, 1)
		vaultAddress = this.FormatVaultAddress(vaultAddress)
		var signature interface{} = this.SignL1Action(cancelAction, nonce, vaultAddress)
		AddElementToObject(request, "action", cancelAction)
		AddElementToObject(request, "signature", signature)
		if IsTrue(!IsEqual(vaultAddress, nil)) {
			params = this.Omit(params, "vaultAddress")
			AddElementToObject(request, "vaultAddress", vaultAddress)
		}

		response := (<-this.PrivatePostExchange(request))
		PanicOnError(response)

		//
		//     {
		//         "status":"err",
		//         "response":"Cannot set scheduled cancel time until enough volume traded. Required: $1000000. Traded: $373.47205."
		//     }
		//
		ch <- response
		return nil

	}()
	return ch
}
func (this *HyperliquidCore) EditOrdersRequest(orders interface{}, optionalArgs ...interface{}) interface{} {
	params := GetArg(optionalArgs, 0, map[string]interface{}{})
	_ = params
	this.CheckRequiredCredentials()
	var hasClientOrderId interface{} = false
	for i := 0; IsLessThan(i, GetArrayLength(orders)); i++ {
		var rawOrder interface{} = GetValue(orders, i)
		var orderParams interface{} = this.SafeDict(rawOrder, "params", map[string]interface{}{})
		var clientOrderId interface{} = this.SafeString2(orderParams, "clientOrderId", "client_id")
		if IsTrue(!IsEqual(clientOrderId, nil)) {
			hasClientOrderId = true
		}
	}
	if IsTrue(hasClientOrderId) {
		for i := 0; IsLessThan(i, GetArrayLength(orders)); i++ {
			var rawOrder interface{} = GetValue(orders, i)
			var orderParams interface{} = this.SafeDict(rawOrder, "params", map[string]interface{}{})
			var clientOrderId interface{} = this.SafeString2(orderParams, "clientOrderId", "client_id")
			if IsTrue(IsEqual(clientOrderId, nil)) {
				panic(ArgumentsRequired(Add(this.Id, " editOrders() all orders must have clientOrderId if at least one has a clientOrderId")))
			}
		}
	}
	params = this.Omit(params, []interface{}{"slippage", "clientOrderId", "client_id", "slippage", "triggerPrice", "stopPrice", "stopLossPrice", "takeProfitPrice", "timeInForce"})
	var modifies interface{} = []interface{}{}
	for i := 0; IsLessThan(i, GetArrayLength(orders)); i++ {
		var rawOrder interface{} = GetValue(orders, i)
		var id interface{} = this.SafeString(rawOrder, "id")
		var marketId interface{} = this.SafeString(rawOrder, "symbol")
		var market interface{} = this.Market(marketId)
		var symbol interface{} = GetValue(market, "symbol")
		var typeVar interface{} = this.SafeStringUpper(rawOrder, "type")
		var isMarket interface{} = (IsEqual(typeVar, "MARKET"))
		var side interface{} = this.SafeStringUpper(rawOrder, "side")
		var isBuy interface{} = (IsEqual(side, "BUY"))
		var amount interface{} = this.SafeString(rawOrder, "amount")
		var price interface{} = this.SafeString(rawOrder, "price")
		var orderParams interface{} = this.SafeDict(rawOrder, "params", map[string]interface{}{})
		var defaultSlippage interface{} = this.SafeString(this.Options, "defaultSlippage")
		var slippage interface{} = this.SafeString(orderParams, "slippage", defaultSlippage)
		var defaultTimeInForce interface{} = Ternary(IsTrue((isMarket)), "ioc", "gtc")
		var postOnly interface{} = this.SafeBool(orderParams, "postOnly", false)
		if IsTrue(postOnly) {
			defaultTimeInForce = "alo"
		}
		var timeInForce interface{} = this.SafeStringLower(orderParams, "timeInForce", defaultTimeInForce)
		timeInForce = this.Capitalize(timeInForce)
		var clientOrderId interface{} = this.SafeString2(orderParams, "clientOrderId", "client_id")
		var triggerPrice interface{} = this.SafeString2(orderParams, "triggerPrice", "stopPrice")
		var stopLossPrice interface{} = this.SafeString(orderParams, "stopLossPrice", triggerPrice)
		var takeProfitPrice interface{} = this.SafeString(orderParams, "takeProfitPrice")
		var isTrigger interface{} = (IsTrue(stopLossPrice) || IsTrue(takeProfitPrice))
		var reduceOnly interface{} = this.SafeBool(orderParams, "reduceOnly", false)
		orderParams = this.Omit(orderParams, []interface{}{"slippage", "timeInForce", "triggerPrice", "stopLossPrice", "takeProfitPrice", "clientOrderId", "client_id", "postOnly", "reduceOnly"})
		var px interface{} = this.NumberToString(price)
		if IsTrue(isMarket) {
			px = Ternary(IsTrue((isBuy)), Precise.StringMul(px, Precise.StringAdd("1", slippage)), Precise.StringMul(px, Precise.StringSub("1", slippage)))
			px = this.PriceToPrecision(symbol, px)
		} else {
			px = this.PriceToPrecision(symbol, px)
		}
		var sz interface{} = this.AmountToPrecision(symbol, amount)
		var orderType interface{} = map[string]interface{}{}
		if IsTrue(isTrigger) {
			var isTp interface{} = false
			if IsTrue(!IsEqual(takeProfitPrice, nil)) {
				triggerPrice = this.PriceToPrecision(symbol, takeProfitPrice)
				isTp = true
			} else {
				triggerPrice = this.PriceToPrecision(symbol, stopLossPrice)
			}
			AddElementToObject(orderType, "trigger", map[string]interface{}{
				"isMarket":  isMarket,
				"triggerPx": triggerPrice,
				"tpsl":      Ternary(IsTrue((isTp)), "tp", "sl"),
			})
		} else {
			AddElementToObject(orderType, "limit", map[string]interface{}{
				"tif": timeInForce,
			})
		}
		if IsTrue(IsEqual(triggerPrice, nil)) {
			triggerPrice = "0"
		}
		var orderReq interface{} = map[string]interface{}{
			"a": this.ParseToInt(GetValue(market, "baseId")),
			"b": isBuy,
			"p": px,
			"s": sz,
			"r": reduceOnly,
			"t": orderType,
		}
		if IsTrue(!IsEqual(clientOrderId, nil)) {
			AddElementToObject(orderReq, "c", clientOrderId)
		}
		var modifyReq interface{} = map[string]interface{}{
			"oid":   this.ParseToInt(id),
			"order": orderReq,
		}
		AppendToArray(&modifies, modifyReq)
	}
	var nonce interface{} = this.Milliseconds()
	var modifyAction interface{} = map[string]interface{}{
		"type":     "batchModify",
		"modifies": modifies,
	}
	var vaultAddress interface{} = nil
	vaultAddressparamsVariable := this.HandleOptionAndParams(params, "editOrder", "vaultAddress")
	vaultAddress = GetValue(vaultAddressparamsVariable, 0)
	params = GetValue(vaultAddressparamsVariable, 1)
	vaultAddress = this.FormatVaultAddress(vaultAddress)
	var signature interface{} = this.SignL1Action(modifyAction, nonce, vaultAddress)
	var request interface{} = map[string]interface{}{
		"action":    modifyAction,
		"nonce":     nonce,
		"signature": signature,
	}
	if IsTrue(!IsEqual(vaultAddress, nil)) {
		AddElementToObject(request, "vaultAddress", vaultAddress)
	}
	return request
}

/**
 * @method
 * @name hyperliquid#editOrder
 * @description edit a trade order
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#modify-multiple-orders
 * @param {string} id cancel order id
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.timeInForce] 'Gtc', 'Ioc', 'Alo'
 * @param {bool} [params.postOnly] true or false whether the order is post-only
 * @param {bool} [params.reduceOnly] true or false whether the order is reduce-only
 * @param {float} [params.triggerPrice] The price at which a trigger order is triggered at
 * @param {string} [params.clientOrderId] client order id, (optional 128 bit hex string e.g. 0x1234567890abcdef1234567890abcdef)
 * @param {string} [params.vaultAddress] the vault address for order
 * @param {string} [params.subAccountAddress] sub account user address
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *HyperliquidCore) EditOrder(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		amount := GetArg(optionalArgs, 0, nil)
		_ = amount
		price := GetArg(optionalArgs, 1, nil)
		_ = price
		params := GetArg(optionalArgs, 2, map[string]interface{}{})
		_ = params

		retRes25288 := (<-this.LoadMarkets())
		PanicOnError(retRes25288)
		if IsTrue(IsEqual(id, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " editOrder() requires an id argument")))
		}
		orderglobalParamsVariable := this.ParseCreateEditOrderArgs(id, symbol, typeVar, side, amount, price, params)
		order := GetValue(orderglobalParamsVariable, 0)
		globalParams := GetValue(orderglobalParamsVariable, 1)

		orders := (<-this.EditOrders([]interface{}{order}, globalParams))
		PanicOnError(orders)

		ch <- GetValue(orders, 0)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name hyperliquid#editOrders
 * @description edit a list of trade orders
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#modify-multiple-orders
 * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *HyperliquidCore) EditOrders(orders interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes25478 := (<-this.LoadMarkets())
		PanicOnError(retRes25478)

		retRes25488 := (<-this.InitializeClient())
		PanicOnError(retRes25488)
		var request interface{} = this.EditOrdersRequest(orders, params)

		response := (<-this.PrivatePostExchange(request))
		PanicOnError(response)
		//
		//     {
		//         "status": "ok",
		//         "response": {
		//             "type": "order",
		//             "data": {
		//                 "statuses": [
		//                     {
		//                         "resting": {
		//                             "oid": 5063830287
		//                         }
		//                     }
		//                 ]
		//             }
		//         }
		//     }
		// when the order is filled immediately
		//     {
		//         "status":"ok",
		//         "response":{
		//            "type":"order",
		//            "data":{
		//               "statuses":[
		//                  {
		//                     "filled":{
		//                        "totalSz":"0.1",
		//                        "avgPx":"100.84",
		//                        "oid":6195281425
		//                     }
		//                  }
		//               ]
		//            }
		//         }
		//     }
		//
		var responseObject interface{} = this.SafeDict(response, "response", map[string]interface{}{})
		var dataObject interface{} = this.SafeDict(responseObject, "data", map[string]interface{}{})
		var statuses interface{} = this.SafeList(dataObject, "statuses", []interface{}{})

		ch <- this.ParseOrders(statuses)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name hyperliquid#createVault
 * @description creates a value
 * @param {string} name The name of the vault
 * @param {string} description The description of the vault
 * @param {number} initialUsd The initialUsd of the vault
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} the api result
 */
func (this *HyperliquidCore) CreateVault(name interface{}, description interface{}, initialUsd interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		this.CheckRequiredCredentials()

		retRes26048 := (<-this.LoadMarkets())
		PanicOnError(retRes26048)
		var nonce interface{} = this.Milliseconds()
		var request interface{} = map[string]interface{}{
			"nonce": nonce,
		}
		var usd interface{} = this.ParseToInt(Precise.StringMul(this.NumberToString(initialUsd), "1000000"))
		var action interface{} = map[string]interface{}{
			"type":        "createVault",
			"name":        name,
			"description": description,
			"initialUsd":  usd,
			"nonce":       nonce,
		}
		var signature interface{} = this.SignL1Action(action, nonce)
		AddElementToObject(request, "action", action)
		AddElementToObject(request, "signature", signature)

		response := (<-this.PrivatePostExchange(this.Extend(request, params)))
		PanicOnError(response)

		//
		// {
		//     "status": "ok",
		//     "response": {
		//         "type": "createVault",
		//         "data": "0x04fddcbc9ce80219301bd16f18491bedf2a8c2b8"
		//     }
		// }
		//
		ch <- response
		return nil

	}()
	return ch
}

/**
 * @method
 * @name hyperliquid#fetchFundingRateHistory
 * @description fetches historical funding rate prices
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/perpetuals#retrieve-historical-funding-rates
 * @param {string} symbol unified symbol of the market to fetch the funding rate history for
 * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
 * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/?id=funding-rate-history-structure} to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest funding rate
 * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/?id=funding-rate-history-structure}
 */
func (this *HyperliquidCore) FetchFundingRateHistory(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes26468 := (<-this.LoadMarkets())
		PanicOnError(retRes26468)
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchFundingRateHistory() requires a symbol argument")))
		}
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"type": "fundingHistory",
			"coin": GetValue(market, "baseName"),
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
		} else {
			var maxLimit interface{} = Ternary(IsTrue((IsEqual(limit, nil))), 500, limit)
			AddElementToObject(request, "startTime", Subtract(this.Milliseconds(), Multiply(Multiply(Multiply(maxLimit, 60), 60), 1000)))
		}
		var until interface{} = this.SafeInteger(params, "until")
		params = this.Omit(params, "until")
		if IsTrue(!IsEqual(until, nil)) {
			AddElementToObject(request, "endTime", until)
		}

		response := (<-this.PublicPostInfo(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     [
		//         {
		//             "coin": "ETH",
		//             "fundingRate": "0.0000125",
		//             "premium": "0.00057962",
		//             "time": 1704290400031
		//         }
		//     ]
		//
		var result interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
			var entry interface{} = GetValue(response, i)
			var timestamp interface{} = this.SafeInteger(entry, "time")
			AppendToArray(&result, map[string]interface{}{
				"info":        entry,
				"symbol":      this.SafeSymbol(nil, market),
				"fundingRate": this.SafeNumber(entry, "fundingRate"),
				"timestamp":   timestamp,
				"datetime":    this.Iso8601(timestamp),
			})
		}
		var sorted interface{} = this.SortBy(result, "timestamp")

		ch <- this.FilterBySymbolSinceLimit(sorted, symbol, since, limit)
		return nil

	}()
	return ch
}
func (this *HyperliquidCore) GetDexFromHip3Symbol(market interface{}) interface{} {
	var baseName interface{} = this.SafeString(market, "baseName", "")
	var part interface{} = Split(baseName, ":")
	var partsLength interface{} = GetArrayLength(part)
	if IsTrue(IsGreaterThan(partsLength, 1)) {
		return this.SafeString(part, 0)
	}
	return nil
}

/**
 * @method
 * @name hyperliquid#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#retrieve-a-users-open-orders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.user] user address, will default to this.walletAddress if not provided
 * @param {string} [params.method] 'openOrders' or 'frontendOpenOrders' default is 'frontendOpenOrders'
 * @param {string} [params.subAccountAddress] sub account user address
 * @param {string} [params.dex] perp dex name. default is null
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *HyperliquidCore) FetchOpenOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		var userAddress interface{} = nil
		userAddressparamsVariable := this.HandlePublicAddress("fetchOpenOrders", params)
		userAddress = GetValue(userAddressparamsVariable, 0)
		params = GetValue(userAddressparamsVariable, 1)
		var method interface{} = nil
		methodparamsVariable := this.HandleOptionAndParams(params, "fetchOpenOrders", "method", "frontendOpenOrders")
		method = GetValue(methodparamsVariable, 0)
		params = GetValue(methodparamsVariable, 1)

		retRes27238 := (<-this.LoadMarkets())
		PanicOnError(retRes27238)
		var request interface{} = map[string]interface{}{
			"type": method,
			"user": userAddress,
		}
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			// check if is hip3 symbol
			var dexName interface{} = this.GetDexFromHip3Symbol(market)
			if IsTrue(!IsEqual(dexName, nil)) {
				AddElementToObject(request, "dex", dexName)
			}
		}

		response := (<-this.PublicPostInfo(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     [
		//         {
		//             "coin": "ETH",
		//             "limitPx": "2000.0",
		//             "oid": 3991946565,
		//             "origSz": "0.1",
		//             "side": "B",
		//             "sz": "0.1",
		//             "timestamp": 1704346468838
		//         }
		//     ]
		//
		var orderWithStatus interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
			var order interface{} = GetValue(response, i)
			var extendOrder interface{} = map[string]interface{}{}
			if IsTrue(IsEqual(this.SafeString(order, "status"), nil)) {
				AddElementToObject(extendOrder, "ccxtStatus", "open")
			}
			AppendToArray(&orderWithStatus, this.Extend(order, extendOrder))
		}

		ch <- this.ParseOrders(orderWithStatus, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name hyperliquid#fetchClosedOrders
 * @description fetch all unfilled currently closed orders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.user] user address, will default to this.walletAddress if not provided
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *HyperliquidCore) FetchClosedOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes27758 := (<-this.LoadMarkets())
		PanicOnError(retRes27758)

		orders := (<-this.FetchOrders(symbol, nil, nil, params))
		PanicOnError(orders) // don't filter here because we don't want to catch open orders
		var closedOrders interface{} = this.FilterByArray(orders, "status", []interface{}{"closed"}, false)

		ch <- this.FilterBySymbolSinceLimit(closedOrders, symbol, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name hyperliquid#fetchCanceledOrders
 * @description fetch all canceled orders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.user] user address, will default to this.walletAddress if not provided
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *HyperliquidCore) FetchCanceledOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes27938 := (<-this.LoadMarkets())
		PanicOnError(retRes27938)

		orders := (<-this.FetchOrders(symbol, nil, nil, params))
		PanicOnError(orders) // don't filter here because we don't want to catch open orders
		var closedOrders interface{} = this.FilterByArray(orders, "status", []interface{}{"canceled"}, false)

		ch <- this.FilterBySymbolSinceLimit(closedOrders, symbol, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name hyperliquid#fetchCanceledAndClosedOrders
 * @description fetch all closed and canceled orders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.user] user address, will default to this.walletAddress if not provided
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *HyperliquidCore) FetchCanceledAndClosedOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes28118 := (<-this.LoadMarkets())
		PanicOnError(retRes28118)

		orders := (<-this.FetchOrders(symbol, nil, nil, params))
		PanicOnError(orders) // don't filter here because we don't want to catch open orders
		var closedOrders interface{} = this.FilterByArray(orders, "status", []interface{}{"canceled", "closed", "rejected"}, false)

		ch <- this.FilterBySymbolSinceLimit(closedOrders, symbol, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name hyperliquid#fetchOrders
 * @description fetch all orders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.user] user address, will default to this.walletAddress if not provided
 * @param {string} [params.subAccountAddress] sub account user address
 * @param {string} [params.dex] perp dex name. default is null
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *HyperliquidCore) FetchOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		var userAddress interface{} = nil
		userAddressparamsVariable := this.HandlePublicAddress("fetchOrders", params)
		userAddress = GetValue(userAddressparamsVariable, 0)
		params = GetValue(userAddressparamsVariable, 1)

		retRes28338 := (<-this.LoadMarkets())
		PanicOnError(retRes28338)
		var market interface{} = nil
		var request interface{} = map[string]interface{}{
			"type": "historicalOrders",
			"user": userAddress,
		}
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			// check if is hip3 symbol
			var dexName interface{} = this.GetDexFromHip3Symbol(market)
			if IsTrue(!IsEqual(dexName, nil)) {
				AddElementToObject(request, "dex", dexName)
			}
		}

		response := (<-this.PublicPostInfo(this.Extend(request, params)))
		PanicOnError(response)

		//
		//     [
		//         {
		//             "coin": "ETH",
		//             "limitPx": "2000.0",
		//             "oid": 3991946565,
		//             "origSz": "0.1",
		//             "side": "B",
		//             "sz": "0.1",
		//             "timestamp": 1704346468838
		//         }
		//     ]
		//
		ch <- this.ParseOrders(response, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name hyperliquid#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#query-order-status-by-oid-or-cloid
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.clientOrderId] client order id, (optional 128 bit hex string e.g. 0x1234567890abcdef1234567890abcdef)
 * @param {string} [params.user] user address, will default to this.walletAddress if not provided
 * @param {string} [params.subAccountAddress] sub account user address
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func (this *HyperliquidCore) FetchOrder(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		var userAddress interface{} = nil
		userAddressparamsVariable := this.HandlePublicAddress("fetchOrder", params)
		userAddress = GetValue(userAddressparamsVariable, 0)
		params = GetValue(userAddressparamsVariable, 1)

		retRes28808 := (<-this.LoadMarkets())
		PanicOnError(retRes28808)
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
		}
		var clientOrderId interface{} = this.SafeString(params, "clientOrderId")
		var request interface{} = map[string]interface{}{
			"type": "orderStatus",
			"user": userAddress,
		}
		if IsTrue(!IsEqual(clientOrderId, nil)) {
			params = this.Omit(params, "clientOrderId")
			AddElementToObject(request, "oid", clientOrderId)
		} else {
			var isClientOrderId interface{} = IsGreaterThanOrEqual(GetLength(id), 34)
			AddElementToObject(request, "oid", Ternary(IsTrue(isClientOrderId), id, this.ParseToNumeric(id)))
		}

		response := (<-this.PublicPostInfo(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "order": {
		//             "order": {
		//                 "children": [],
		//                 "cloid": null,
		//                 "coin": "ETH",
		//                 "isPositionTpsl": false,
		//                 "isTrigger": false,
		//                 "limitPx": "2000.0",
		//                 "oid": "3991946565",
		//                 "orderType": "Limit",
		//                 "origSz": "0.1",
		//                 "reduceOnly": false,
		//                 "side": "B",
		//                 "sz": "0.1",
		//                 "tif": "Gtc",
		//                 "timestamp": "1704346468838",
		//                 "triggerCondition": "N/A",
		//                 "triggerPx": "0.0"
		//             },
		//             "status": "open",
		//             "statusTimestamp": "1704346468838"
		//         },
		//         "status": "order"
		//     }
		//
		var data interface{} = this.SafeDict(response, "order")

		ch <- this.ParseOrder(data, market)
		return nil

	}()
	return ch
}
func (this *HyperliquidCore) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{} {
	//
	// createOrdersWs error
	//
	//  {error: 'Insufficient margin to place order. asset=159'}
	//
	//  fetchOpenOrders
	//
	//     {
	//         "coin": "ETH",
	//         "limitPx": "2000.0",
	//         "oid": 3991946565,
	//         "origSz": "0.1",
	//         "side": "B",
	//         "sz": "0.1",
	//         "timestamp": 1704346468838
	//     }
	// fetchClosedorders
	//    {
	//        "cloid": null,
	//        "closedPnl": "0.0",
	//        "coin": "SOL",
	//        "crossed": true,
	//        "dir": "Open Long",
	//        "fee": "0.003879",
	//        "hash": "0x4a2647998682b7f07bc5040ab531e1011400f9a51bfa0346a0b41ebe510e8875",
	//        "liquidationMarkPx": null,
	//        "oid": "6463280784",
	//        "px": "110.83",
	//        "side": "B",
	//        "startPosition": "1.64",
	//        "sz": "0.1",
	//        "tid": "232174667018988",
	//        "time": "1709142268394"
	//    }
	//
	//  fetchOrder
	//
	//     {
	//         "order": {
	//             "children": [],
	//             "cloid": null,
	//             "coin": "ETH",
	//             "isPositionTpsl": false,
	//             "isTrigger": false,
	//             "limitPx": "2000.0",
	//             "oid": "3991946565",
	//             "orderType": "Limit",
	//             "origSz": "0.1",
	//             "reduceOnly": false,
	//             "side": "B",
	//             "sz": "0.1",
	//             "tif": "Gtc",
	//             "timestamp": "1704346468838",
	//             "triggerCondition": "N/A",
	//             "triggerPx": "0.0"
	//         },
	//         "status": "open",
	//         "statusTimestamp": "1704346468838"
	//     }
	//
	// createOrder
	//
	//     {
	//         "resting": {
	//             "oid": 5063830287
	//         }
	//     }
	//
	//     {
	//        "filled":{
	//           "totalSz":"0.1",
	//           "avgPx":"100.84",
	//           "oid":6195281425
	//        }
	//     }
	// frontendOrder
	// {
	//     "children": [],
	//     "cloid": null,
	//     "coin": "BLUR",
	//     "isPositionTpsl": false,
	//     "isTrigger": true,
	//     "limitPx": "0.5",
	//     "oid": 8670487141,
	//     "orderType": "Stop Limit",
	//     "origSz": "20.0",
	//     "reduceOnly": false,
	//     "side": "B",
	//     "sz": "20.0",
	//     "tif": null,
	//     "timestamp": 1715523663687,
	//     "triggerCondition": "Price above 0.6",
	//     "triggerPx": "0.6"
	// }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var error interface{} = this.SafeString(order, "error")
	if IsTrue(!IsEqual(error, nil)) {
		return this.SafeOrder(map[string]interface{}{
			"info":   order,
			"status": "rejected",
		})
	}
	var entry interface{} = this.SafeDictN(order, []interface{}{"order", "resting", "filled"})
	if IsTrue(IsEqual(entry, nil)) {
		entry = order
	}
	var filled interface{} = this.SafeDict(order, "filled", map[string]interface{}{})
	var coin interface{} = this.SafeString(entry, "coin")
	var marketId interface{} = nil
	if IsTrue(!IsEqual(coin, nil)) {
		marketId = this.CoinToMarketId(coin)
	}
	if IsTrue(IsEqual(this.SafeString(entry, "id"), nil)) {
		market = this.SafeMarket(marketId, nil)
	} else {
		market = this.SafeMarket(marketId, market)
	}
	var symbol interface{} = GetValue(market, "symbol")
	var timestamp interface{} = this.SafeInteger(entry, "timestamp")
	var status interface{} = this.SafeString2(order, "status", "ccxtStatus")
	order = this.Omit(order, []interface{}{"ccxtStatus"})
	var side interface{} = this.SafeString(entry, "side")
	if IsTrue(!IsEqual(side, nil)) {
		side = Ternary(IsTrue((IsEqual(side, "A"))), "sell", "buy")
	}
	var totalAmount interface{} = this.SafeString2(entry, "origSz", "totalSz")
	var remaining interface{} = this.SafeString(entry, "sz")
	var tif interface{} = this.SafeStringUpper(entry, "tif")
	var postOnly interface{} = nil
	if IsTrue(!IsEqual(tif, nil)) {
		postOnly = (IsEqual(tif, "ALO"))
	}
	return this.SafeOrder(map[string]interface{}{
		"info":                order,
		"id":                  this.SafeString(entry, "oid"),
		"clientOrderId":       this.SafeString(entry, "cloid"),
		"timestamp":           timestamp,
		"datetime":            this.Iso8601(timestamp),
		"lastTradeTimestamp":  nil,
		"lastUpdateTimestamp": this.SafeInteger(order, "statusTimestamp"),
		"symbol":              symbol,
		"type":                this.ParseOrderType(this.SafeStringLower(entry, "orderType")),
		"timeInForce":         tif,
		"postOnly":            postOnly,
		"reduceOnly":          this.SafeBool(entry, "reduceOnly"),
		"side":                side,
		"price":               this.SafeString(entry, "limitPx"),
		"triggerPrice":        Ternary(IsTrue(this.SafeBool(entry, "isTrigger")), this.SafeNumber(entry, "triggerPx"), nil),
		"amount":              totalAmount,
		"cost":                nil,
		"average":             this.SafeString(entry, "avgPx"),
		"filled":              this.SafeString(filled, "totalSz", Precise.StringSub(totalAmount, remaining)),
		"remaining":           remaining,
		"status":              this.ParseOrderStatus(status),
		"fee":                 nil,
		"trades":              nil,
	}, market)
}
func (this *HyperliquidCore) ParseOrderStatus(status interface{}) interface{} {
	if IsTrue(IsEqual(status, nil)) {
		return nil
	}
	var statuses interface{} = map[string]interface{}{
		"triggered":      "open",
		"filled":         "closed",
		"open":           "open",
		"canceled":       "canceled",
		"rejected":       "rejected",
		"marginCanceled": "canceled",
	}
	if IsTrue(EndsWith(status, "Rejected")) {
		return "rejected"
	}
	if IsTrue(EndsWith(status, "Canceled")) {
		return "canceled"
	}
	return this.SafeString(statuses, status, status)
}
func (this *HyperliquidCore) ParseOrderType(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"stop limit":  "limit",
		"stop market": "market",
	}
	return this.SafeString(statuses, status, status)
}

/**
 * @method
 * @name hyperliquid#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#retrieve-a-users-fills
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint#retrieve-a-users-fills-by-time
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest trade
 * @param {string} [params.subAccountAddress] sub account user address
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=trade-structure}
 */
func (this *HyperliquidCore) FetchMyTrades(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		var userAddress interface{} = nil
		userAddressparamsVariable := this.HandlePublicAddress("fetchMyTrades", params)
		userAddress = GetValue(userAddressparamsVariable, 0)
		params = GetValue(userAddressparamsVariable, 1)

		retRes31368 := (<-this.LoadMarkets())
		PanicOnError(retRes31368)
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
		}
		var request interface{} = map[string]interface{}{
			"user": userAddress,
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "type", "userFillsByTime")
			AddElementToObject(request, "startTime", since)
		} else {
			AddElementToObject(request, "type", "userFills")
		}
		var until interface{} = this.SafeInteger(params, "until")
		params = this.Omit(params, "until")
		if IsTrue(!IsEqual(until, nil)) {
			AddElementToObject(request, "endTime", until)
		}

		response := (<-this.PublicPostInfo(this.Extend(request, params)))
		PanicOnError(response)

		//
		//     [
		//         {
		//             "closedPnl": "0.19343",
		//             "coin": "ETH",
		//             "crossed": true,
		//             "dir": "Close Long",
		//             "fee": "0.050062",
		//             "feeToken": "USDC",
		//             "hash": "0x09d77c96791e98b5775a04092584ab010d009445119c71e4005c0d634ea322bc",
		//             "liquidationMarkPx": null,
		//             "oid": 3929354691,
		//             "px": "2381.1",
		//             "side": "A",
		//             "startPosition": "0.0841",
		//             "sz": "0.0841",
		//             "tid": 128423918764978,
		//             "time": 1704262888911
		//         }
		//     ]
		//
		ch <- this.ParseTrades(response, market, since, limit)
		return nil

	}()
	return ch
}
func (this *HyperliquidCore) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "closedPnl": "0.19343",
	//         "coin": "ETH",
	//         "crossed": true,
	//         "dir": "Close Long",
	//         "fee": "0.050062",
	//         "hash": "0x09d77c96791e98b5775a04092584ab010d009445119c71e4005c0d634ea322bc",
	//         "liquidationMarkPx": null,
	//         "oid": 3929354691,
	//         "px": "2381.1",
	//         "side": "A",
	//         "startPosition": "0.0841",
	//         "sz": "0.0841",
	//         "tid": 128423918764978,
	//         "time": 1704262888911
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var timestamp interface{} = this.SafeInteger(trade, "time")
	var price interface{} = this.SafeString(trade, "px")
	var amount interface{} = this.SafeString(trade, "sz")
	var coin interface{} = this.SafeString(trade, "coin")
	var marketId interface{} = this.CoinToMarketId(coin)
	market = this.SafeMarket(marketId, nil)
	var symbol interface{} = GetValue(market, "symbol")
	var id interface{} = this.SafeString(trade, "tid")
	var side interface{} = this.SafeString(trade, "side")
	if IsTrue(!IsEqual(side, nil)) {
		side = Ternary(IsTrue((IsEqual(side, "A"))), "sell", "buy")
	}
	var fee interface{} = this.SafeString(trade, "fee")
	var takerOrMaker interface{} = nil
	var crossed interface{} = this.SafeBool(trade, "crossed")
	if IsTrue(!IsEqual(crossed, nil)) {
		takerOrMaker = Ternary(IsTrue(crossed), "taker", "maker")
	}
	return this.SafeTrade(map[string]interface{}{
		"info":         trade,
		"timestamp":    timestamp,
		"datetime":     this.Iso8601(timestamp),
		"symbol":       symbol,
		"id":           id,
		"order":        this.SafeString(trade, "oid"),
		"type":         nil,
		"side":         side,
		"takerOrMaker": takerOrMaker,
		"price":        price,
		"amount":       amount,
		"cost":         nil,
		"fee": map[string]interface{}{
			"cost":     fee,
			"currency": this.SafeString(trade, "feeToken"),
			"rate":     nil,
		},
	}, market)
}

/**
 * @method
 * @name hyperliquid#fetchPosition
 * @description fetch data on an open position
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/perpetuals#retrieve-users-perpetuals-account-summary
 * @param {string} symbol unified market symbol of the market the position is held in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.user] user address, will default to this.walletAddress if not provided
 * @returns {object} a [position structure]{@link https://docs.ccxt.com/?id=position-structure}
 */
func (this *HyperliquidCore) FetchPosition(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		positions := (<-this.FetchPositions([]interface{}{symbol}, params))
		PanicOnError(positions)

		ch <- this.SafeDict(positions, 0, map[string]interface{}{})
		return nil

	}()
	return ch
}
func (this *HyperliquidCore) GetDexFromSymbols(methodName interface{}, optionalArgs ...interface{}) interface{} {
	symbols := GetArg(optionalArgs, 0, nil)
	_ = symbols
	if IsTrue(IsEqual(symbols, nil)) {
		return nil
	}
	var symbolsLength interface{} = GetArrayLength(symbols)
	if IsTrue(IsEqual(symbolsLength, 0)) {
		return nil
	}
	var dexName interface{} = nil
	for i := 0; IsLessThan(i, symbolsLength); i++ {
		if IsTrue(IsEqual(dexName, nil)) {
			var market interface{} = this.Market(GetValue(symbols, i))
			dexName = this.GetDexFromHip3Symbol(market)
		} else {
			var market interface{} = this.Market(GetValue(symbols, i))
			var currentDexName interface{} = this.GetDexFromHip3Symbol(market)
			if IsTrue(!IsEqual(currentDexName, dexName)) {
				panic(NotSupported(Add(Add(Add(this.Id, " "), methodName), " only supports fetching positions for one DEX at a time for HIP3 markets")))
			}
		}
	}
	return dexName
}

/**
 * @method
 * @name hyperliquid#fetchPositions
 * @description fetch all open positions
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/info-endpoint/perpetuals#retrieve-users-perpetuals-account-summary
 * @param {string[]} [symbols] list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.user] user address, will default to this.walletAddress if not provided
 * @param {string} [params.subAccountAddress] sub account user address
 * @param {string} [params.dex] perp dex name, eg: XYZ
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/?id=position-structure}
 */
func (this *HyperliquidCore) FetchPositions(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes32908 := (<-this.LoadMarkets())
		PanicOnError(retRes32908)
		var userAddress interface{} = nil
		userAddressparamsVariable := this.HandlePublicAddress("fetchPositions", params)
		userAddress = GetValue(userAddressparamsVariable, 0)
		params = GetValue(userAddressparamsVariable, 1)
		symbols = this.MarketSymbols(symbols)
		var request interface{} = map[string]interface{}{
			"type": "clearinghouseState",
			"user": userAddress,
		}
		var dexName interface{} = this.GetDexFromSymbols("fetchPositions", symbols)
		if IsTrue(!IsEqual(dexName, nil)) {
			AddElementToObject(request, "dex", dexName)
		}

		response := (<-this.PublicPostInfo(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "assetPositions": [
		//             {
		//                 "position": {
		//                     "coin": "ETH",
		//                     "cumFunding": {
		//                         "allTime": "0.0",
		//                         "sinceChange": "0.0",
		//                         "sinceOpen": "0.0"
		//                     },
		//                     "entryPx": "2213.9",
		//                     "leverage": {
		//                         "rawUsd": "-475.23904",
		//                         "type": "isolated",
		//                         "value": "20"
		//                     },
		//                     "liquidationPx": "2125.00856238",
		//                     "marginUsed": "24.88097",
		//                     "maxLeverage": "50",
		//                     "positionValue": "500.12001",
		//                     "returnOnEquity": "0.0",
		//                     "szi": "0.2259",
		//                     "unrealizedPnl": "0.0"
		//                 },
		//                 "type": "oneWay"
		//             }
		//         ],
		//         "crossMaintenanceMarginUsed": "0.0",
		//         "crossMarginSummary": {
		//             "accountValue": "100.0",
		//             "totalMarginUsed": "0.0",
		//             "totalNtlPos": "0.0",
		//             "totalRawUsd": "100.0"
		//         },
		//         "marginSummary": {
		//             "accountValue": "100.0",
		//             "totalMarginUsed": "0.0",
		//             "totalNtlPos": "0.0",
		//             "totalRawUsd": "100.0"
		//         },
		//         "time": "1704261007014",
		//         "withdrawable": "100.0"
		//     }
		//
		var data interface{} = this.SafeList(response, "assetPositions", []interface{}{})
		var result interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
			AppendToArray(&result, this.ParsePosition(GetValue(data, i), nil))
		}

		ch <- this.FilterByArrayPositions(result, "symbol", symbols, false)
		return nil

	}()
	return ch
}
func (this *HyperliquidCore) ParsePosition(position interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "position": {
	//             "coin": "ETH",
	//             "cumFunding": {
	//                 "allTime": "0.0",
	//                 "sinceChange": "0.0",
	//                 "sinceOpen": "0.0"
	//             },
	//             "entryPx": "2213.9",
	//             "leverage": {
	//                 "rawUsd": "-475.23904",
	//                 "type": "isolated",
	//                 "value": "20"
	//             },
	//             "liquidationPx": "2125.00856238",
	//             "marginUsed": "24.88097",
	//             "maxLeverage": "50",
	//             "positionValue": "500.12001",
	//             "returnOnEquity": "0.0",
	//             "szi": "0.2259",
	//             "unrealizedPnl": "0.0"
	//         },
	//         "type": "oneWay"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var entry interface{} = this.SafeDict(position, "position", map[string]interface{}{})
	var coin interface{} = this.SafeString(entry, "coin")
	var marketId interface{} = this.CoinToMarketId(coin)
	market = this.SafeMarket(marketId, nil)
	var symbol interface{} = GetValue(market, "symbol")
	var leverage interface{} = this.SafeDict(entry, "leverage", map[string]interface{}{})
	var marginMode interface{} = this.SafeString(leverage, "type")
	var isIsolated interface{} = (IsEqual(marginMode, "isolated"))
	var rawSize interface{} = this.SafeString(entry, "szi")
	var size interface{} = rawSize
	var side interface{} = nil
	if IsTrue(!IsEqual(size, nil)) {
		side = Ternary(IsTrue(Precise.StringGt(rawSize, "0")), "long", "short")
		size = Precise.StringAbs(size)
	}
	var rawUnrealizedPnl interface{} = this.SafeString(entry, "unrealizedPnl")
	var absRawUnrealizedPnl interface{} = Precise.StringAbs(rawUnrealizedPnl)
	var marginUsed interface{} = this.SafeString(entry, "marginUsed")
	var initialMargin interface{} = nil
	if IsTrue(isIsolated) {
		initialMargin = Precise.StringSub(marginUsed, rawUnrealizedPnl)
	} else {
		initialMargin = marginUsed
	}
	var percentage interface{} = Precise.StringMul(Precise.StringDiv(absRawUnrealizedPnl, marginUsed), "100")
	return this.SafePosition(map[string]interface{}{
		"info":                        position,
		"id":                          nil,
		"symbol":                      symbol,
		"timestamp":                   nil,
		"datetime":                    nil,
		"isolated":                    isIsolated,
		"hedged":                      nil,
		"side":                        side,
		"contracts":                   this.ParseNumber(size),
		"contractSize":                nil,
		"entryPrice":                  this.SafeNumber(entry, "entryPx"),
		"markPrice":                   nil,
		"notional":                    this.SafeNumber(entry, "positionValue"),
		"leverage":                    this.SafeNumber(leverage, "value"),
		"collateral":                  this.ParseNumber(marginUsed),
		"initialMargin":               this.ParseNumber(initialMargin),
		"maintenanceMargin":           nil,
		"initialMarginPercentage":     nil,
		"maintenanceMarginPercentage": nil,
		"unrealizedPnl":               this.ParseNumber(rawUnrealizedPnl),
		"liquidationPrice":            this.SafeNumber(entry, "liquidationPx"),
		"marginMode":                  marginMode,
		"percentage":                  this.ParseNumber(percentage),
	})
}

/**
 * @method
 * @name hyperliquid#setMarginMode
 * @description set margin mode (symbol)
 * @param {string} marginMode margin mode must be either [isolated, cross]
 * @param {string} symbol unified market symbol of the market the position is held in, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.leverage] the rate of leverage, is required if setting trade mode (symbol)
 * @param {string} [params.vaultAddress] the vault address
 * @param {string} [params.subAccountAddress] sub account user address
 * @returns {object} response from the exchange
 */
func (this *HyperliquidCore) SetMarginMode(marginMode interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " setMarginMode() requires a symbol argument")))
		}

		retRes34518 := (<-this.LoadMarkets())
		PanicOnError(retRes34518)
		var market interface{} = this.Market(symbol)
		var leverage interface{} = this.SafeInteger(params, "leverage")
		if IsTrue(IsEqual(leverage, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " setMarginMode() requires a leverage parameter")))
		}
		var asset interface{} = this.ParseToInt(GetValue(market, "baseId"))
		var isCross interface{} = (IsEqual(marginMode, "cross"))
		var nonce interface{} = this.Milliseconds()
		params = this.Omit(params, []interface{}{"leverage"})
		var updateAction interface{} = map[string]interface{}{
			"type":     "updateLeverage",
			"asset":    asset,
			"isCross":  isCross,
			"leverage": leverage,
		}
		var vaultAddress interface{} = nil
		vaultAddressparamsVariable := this.HandleOptionAndParams2(params, "setMarginMode", "vaultAddress", "subAccountAddress")
		vaultAddress = GetValue(vaultAddressparamsVariable, 0)
		params = GetValue(vaultAddressparamsVariable, 1)
		if IsTrue(!IsEqual(vaultAddress, nil)) {
			if IsTrue(StartsWith(vaultAddress, "0x")) {
				vaultAddress = Replace(vaultAddress, "0x", "")
			}
		}
		var signature interface{} = this.SignL1Action(updateAction, nonce, vaultAddress)
		var request interface{} = map[string]interface{}{
			"action":    updateAction,
			"nonce":     nonce,
			"signature": signature,
		}
		if IsTrue(!IsEqual(vaultAddress, nil)) {
			AddElementToObject(request, "vaultAddress", vaultAddress)
		}

		response := (<-this.PrivatePostExchange(request))
		PanicOnError(response)

		//
		//     {
		//         'response': {
		//             'type': 'default'
		//         },
		//         'status': 'ok'
		//     }
		//
		ch <- response
		return nil

	}()
	return ch
}

/**
 * @method
 * @name hyperliquid#setLeverage
 * @description set the level of leverage for a market
 * @param {float} leverage the rate of leverage
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] margin mode must be either [isolated, cross], default is cross
 * @returns {object} response from the exchange
 */
func (this *HyperliquidCore) SetLeverage(leverage interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " setLeverage() requires a symbol argument")))
		}

		retRes35108 := (<-this.LoadMarkets())
		PanicOnError(retRes35108)
		var market interface{} = this.Market(symbol)
		var marginMode interface{} = this.SafeString(params, "marginMode", "cross")
		var isCross interface{} = (IsEqual(marginMode, "cross"))
		var asset interface{} = this.ParseToInt(GetValue(market, "baseId"))
		var nonce interface{} = this.Milliseconds()
		params = this.Omit(params, "marginMode")
		var updateAction interface{} = map[string]interface{}{
			"type":     "updateLeverage",
			"asset":    asset,
			"isCross":  isCross,
			"leverage": leverage,
		}
		var vaultAddress interface{} = nil
		vaultAddressparamsVariable := this.HandleOptionAndParams2(params, "setLeverage", "vaultAddress", "subAccountAddress")
		vaultAddress = GetValue(vaultAddressparamsVariable, 0)
		params = GetValue(vaultAddressparamsVariable, 1)
		vaultAddress = this.FormatVaultAddress(vaultAddress)
		var signature interface{} = this.SignL1Action(updateAction, nonce, vaultAddress)
		var request interface{} = map[string]interface{}{
			"action":    updateAction,
			"nonce":     nonce,
			"signature": signature,
		}
		if IsTrue(!IsEqual(vaultAddress, nil)) {
			params = this.Omit(params, "vaultAddress")
			AddElementToObject(request, "vaultAddress", vaultAddress)
		}

		response := (<-this.PrivatePostExchange(request))
		PanicOnError(response)

		//
		//     {
		//         'response': {
		//             'type': 'default'
		//         },
		//         'status': 'ok'
		//     }
		//
		ch <- response
		return nil

	}()
	return ch
}

/**
 * @method
 * @name hyperliquid#addMargin
 * @description add margin
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#update-isolated-margin
 * @param {string} symbol unified market symbol
 * @param {float} amount amount of margin to add
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.vaultAddress] the vault address
 * @param {string} [params.subAccountAddress] sub account user address
 * @returns {object} a [margin structure]{@link https://docs.ccxt.com/?id=margin-structure}
 */
func (this *HyperliquidCore) AddMargin(symbol interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes356215 := (<-this.ModifyMarginHelper(symbol, amount, "add", params))
		PanicOnError(retRes356215)
		ch <- retRes356215
		return nil

	}()
	return ch
}

/**
 * @method
 * @name hyperliquid#reduceMargin
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#update-isolated-margin
 * @description remove margin from a position
 * @param {string} symbol unified market symbol
 * @param {float} amount the amount of margin to remove
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.vaultAddress] the vault address
 * @param {string} [params.subAccountAddress] sub account user address
 * @returns {object} a [margin structure]{@link https://docs.ccxt.com/?id=margin-structure}
 */
func (this *HyperliquidCore) ReduceMargin(symbol interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes357815 := (<-this.ModifyMarginHelper(symbol, amount, "reduce", params))
		PanicOnError(retRes357815)
		ch <- retRes357815
		return nil

	}()
	return ch
}
func (this *HyperliquidCore) ModifyMarginHelper(symbol interface{}, amount interface{}, typeVar interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes35828 := (<-this.LoadMarkets())
		PanicOnError(retRes35828)
		var market interface{} = this.Market(symbol)
		var asset interface{} = this.ParseToInt(GetValue(market, "baseId"))
		var sz interface{} = this.ParseToInt(Precise.StringMul(this.AmountToPrecision(symbol, amount), "1000000"))
		if IsTrue(IsEqual(typeVar, "reduce")) {
			sz = OpNeg(sz)
		}
		var nonce interface{} = this.Milliseconds()
		var updateAction interface{} = map[string]interface{}{
			"type":  "updateIsolatedMargin",
			"asset": asset,
			"isBuy": true,
			"ntli":  sz,
		}
		var vaultAddress interface{} = nil
		vaultAddressparamsVariable := this.HandleOptionAndParams2(params, "modifyMargin", "vaultAddress", "subAccountAddress")
		vaultAddress = GetValue(vaultAddressparamsVariable, 0)
		params = GetValue(vaultAddressparamsVariable, 1)
		vaultAddress = this.FormatVaultAddress(vaultAddress)
		var signature interface{} = this.SignL1Action(updateAction, nonce, vaultAddress)
		var request interface{} = map[string]interface{}{
			"action":    updateAction,
			"nonce":     nonce,
			"signature": signature,
		}
		if IsTrue(!IsEqual(vaultAddress, nil)) {
			AddElementToObject(request, "vaultAddress", vaultAddress)
		}

		response := (<-this.PrivatePostExchange(request))
		PanicOnError(response)

		//
		//     {
		//         'response': {
		//             'type': 'default'
		//         },
		//         'status': 'ok'
		//     }
		//
		ch <- this.Extend(this.ParseMarginModification(response, market), map[string]interface{}{
			"code": this.SafeString(response, "status"),
		})
		return nil

	}()
	return ch
}
func (this *HyperliquidCore) ParseMarginModification(data interface{}, optionalArgs ...interface{}) interface{} {
	//
	//    {
	//        'type': 'default'
	//    }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	return map[string]interface{}{
		"info":       data,
		"symbol":     this.SafeSymbol(nil, market),
		"type":       nil,
		"marginMode": "isolated",
		"amount":     nil,
		"total":      nil,
		"code":       this.SafeString(market, "settle"),
		"status":     nil,
		"timestamp":  nil,
		"datetime":   nil,
	}
}

/**
 * @method
 * @name hyperliquid#transfer
 * @description transfer currency internally between wallets on the same account
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#l1-usdc-transfer
 * @param {string} code unified currency code
 * @param {float} amount amount to transfer
 * @param {string} fromAccount account to transfer from *spot, swap*
 * @param {string} toAccount account to transfer to *swap, spot or address*
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.vaultAddress] the vault address for order
 * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/?id=transfer-structure}
 */
func (this *HyperliquidCore) Transfer(code interface{}, amount interface{}, fromAccount interface{}, toAccount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		this.CheckRequiredCredentials()

		retRes36588 := (<-this.LoadMarkets())
		PanicOnError(retRes36588)
		var isSandboxMode interface{} = this.SafeBool(this.Options, "sandboxMode")
		var nonce interface{} = this.Milliseconds()
		if IsTrue(this.InArray(fromAccount, []interface{}{"spot", "swap", "perp"})) {
			// handle swap <> spot account transfer
			if !IsTrue(this.InArray(toAccount, []interface{}{"spot", "swap", "perp"})) {
				panic(NotSupported(Add(this.Id, " transfer() only support spot <> swap transfer")))
			}
			var strAmount interface{} = this.NumberToString(amount)
			var vaultAddress interface{} = this.SafeString2(params, "vaultAddress", "subAccountAddress")
			if IsTrue(!IsEqual(vaultAddress, nil)) {
				vaultAddress = this.FormatVaultAddress(vaultAddress)
				strAmount = Add(Add(strAmount, " subaccount:"), vaultAddress)
			}
			var toPerp interface{} = IsTrue((IsEqual(toAccount, "perp"))) || IsTrue((IsEqual(toAccount, "swap")))
			var transferPayload interface{} = map[string]interface{}{
				"hyperliquidChain": Ternary(IsTrue(isSandboxMode), "Testnet", "Mainnet"),
				"amount":           strAmount,
				"toPerp":           toPerp,
				"nonce":            nonce,
			}
			var transferSig interface{} = this.BuildUsdClassSendSig(transferPayload)
			var transferRequest interface{} = map[string]interface{}{
				"action": map[string]interface{}{
					"hyperliquidChain": GetValue(transferPayload, "hyperliquidChain"),
					"signatureChainId": "0x66eee",
					"type":             "usdClassTransfer",
					"amount":           strAmount,
					"toPerp":           toPerp,
					"nonce":            nonce,
				},
				"nonce":     nonce,
				"signature": transferSig,
			}

			transferResponse := (<-this.PrivatePostExchange(transferRequest))
			PanicOnError(transferResponse)

			ch <- transferResponse
			return nil
		}
		// transfer between main account and subaccount
		var isDeposit interface{} = false
		var subAccountAddress interface{} = nil
		if IsTrue(IsEqual(fromAccount, "main")) {
			subAccountAddress = toAccount
			isDeposit = true
		} else if IsTrue(IsEqual(toAccount, "main")) {
			subAccountAddress = fromAccount
		} else {
			panic(NotSupported(Add(this.Id, " transfer() only support main <> subaccount transfer")))
		}
		this.CheckAddress(subAccountAddress)
		if IsTrue(IsTrue(IsEqual(code, nil)) || IsTrue(IsEqual(ToUpper(code), "USDC"))) {
			// Transfer USDC with subAccountTransfer
			var usd interface{} = this.ParseToInt(Precise.StringMul(this.NumberToString(amount), "1000000"))
			var action interface{} = map[string]interface{}{
				"type":           "subAccountTransfer",
				"subAccountUser": subAccountAddress,
				"isDeposit":      isDeposit,
				"usd":            usd,
			}
			var sig interface{} = this.SignL1Action(action, nonce)
			var request interface{} = map[string]interface{}{
				"action":    action,
				"nonce":     nonce,
				"signature": sig,
			}

			response := (<-this.PrivatePostExchange(request))
			PanicOnError(response)

			//
			// {'response': {'type': 'default'}, 'status': 'ok'}
			//
			ch <- this.ParseTransfer(response)
			return nil
		} else {
			// Transfer non-USDC with subAccountSpotTransfer
			var symbol interface{} = this.Symbol(code)
			var action interface{} = map[string]interface{}{
				"type":           "subAccountSpotTransfer",
				"subAccountUser": subAccountAddress,
				"isDeposit":      isDeposit,
				"token":          symbol,
				"amount":         this.NumberToString(amount),
			}
			var sig interface{} = this.SignL1Action(action, nonce)
			var request interface{} = map[string]interface{}{
				"action":    action,
				"nonce":     nonce,
				"signature": sig,
			}

			response := (<-this.PrivatePostExchange(request))
			PanicOnError(response)

			ch <- this.ParseTransfer(response)
			return nil
		}

	}()
	return ch
}
func (this *HyperliquidCore) ParseTransfer(transfer interface{}, optionalArgs ...interface{}) interface{} {
	//
	// {'response': {'type': 'default'}, 'status': 'ok'}
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	return map[string]interface{}{
		"info":        transfer,
		"id":          nil,
		"timestamp":   nil,
		"datetime":    nil,
		"currency":    nil,
		"amount":      nil,
		"fromAccount": nil,
		"toAccount":   nil,
		"status":      "ok",
	}
}

/**
 * @method
 * @name hyperliquid#withdraw
 * @description make a withdrawal (only support USDC)
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#initiate-a-withdrawal-request
 * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#deposit-or-withdraw-from-a-vault
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.vaultAddress] vault address withdraw from
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/?id=transaction-structure}
 */
func (this *HyperliquidCore) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		tag := GetArg(optionalArgs, 0, nil)
		_ = tag
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		this.CheckRequiredCredentials()

		retRes37818 := (<-this.LoadMarkets())
		PanicOnError(retRes37818)
		this.CheckAddress(address)
		if IsTrue(!IsEqual(code, nil)) {
			code = ToUpper(code)
			if IsTrue(!IsEqual(code, "USDC")) {
				panic(NotSupported(Add(this.Id, " withdraw() only support USDC")))
			}
		}
		var vaultAddress interface{} = nil
		vaultAddressparamsVariable := this.HandleOptionAndParams(params, "withdraw", "vaultAddress")
		vaultAddress = GetValue(vaultAddressparamsVariable, 0)
		params = GetValue(vaultAddressparamsVariable, 1)
		vaultAddress = this.FormatVaultAddress(vaultAddress)
		params = this.Omit(params, "vaultAddress")
		var nonce interface{} = this.Milliseconds()
		var action interface{} = map[string]interface{}{}
		var sig interface{} = nil
		if IsTrue(!IsEqual(vaultAddress, nil)) {
			action = map[string]interface{}{
				"type":         "vaultTransfer",
				"vaultAddress": Add("0x", vaultAddress),
				"isDeposit":    false,
				"usd":          amount,
			}
			sig = this.SignL1Action(action, nonce)
		} else {
			var isSandboxMode interface{} = this.SafeBool(this.Options, "sandboxMode", false)
			var payload interface{} = map[string]interface{}{
				"hyperliquidChain": Ternary(IsTrue(isSandboxMode), "Testnet", "Mainnet"),
				"destination":      address,
				"amount":           ToString(amount),
				"time":             nonce,
			}
			sig = this.BuildWithdrawSig(payload)
			action = map[string]interface{}{
				"hyperliquidChain": GetValue(payload, "hyperliquidChain"),
				"signatureChainId": "0x66eee",
				"destination":      address,
				"amount":           ToString(amount),
				"time":             nonce,
				"type":             "withdraw3",
			}
		}
		var request interface{} = map[string]interface{}{
			"action":    action,
			"nonce":     nonce,
			"signature": sig,
		}

		response := (<-this.PrivatePostExchange(request))
		PanicOnError(response)

		ch <- this.ParseTransaction(response)
		return nil

	}()
	return ch
}
func (this *HyperliquidCore) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{} {
	//
	// { status: 'ok', response: { type: 'default' } }
	//
	// fetchDeposits / fetchWithdrawals
	// {
	//     "time":1724762307531,
	//     "hash":"0x620a234a7e0eb7930575040f59482a01050058b0802163b4767bfd9033e77781",
	//     "delta":{
	//         "type":"accountClassTransfer",
	//         "usdc":"50.0",
	//         "toPerp":false
	//     }
	// }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var timestamp interface{} = this.SafeInteger(transaction, "time")
	var delta interface{} = this.SafeDict(transaction, "delta", map[string]interface{}{})
	var fee interface{} = nil
	var feeCost interface{} = this.SafeInteger(delta, "fee")
	if IsTrue(!IsEqual(feeCost, nil)) {
		fee = map[string]interface{}{
			"currency": "USDC",
			"cost":     feeCost,
		}
	}
	var internal interface{} = nil
	var typeVar interface{} = this.SafeString(delta, "type")
	if IsTrue(!IsEqual(typeVar, nil)) {
		internal = (IsEqual(typeVar, "internalTransfer"))
	}
	return map[string]interface{}{
		"info":        transaction,
		"id":          nil,
		"txid":        this.SafeString(transaction, "hash"),
		"timestamp":   timestamp,
		"datetime":    this.Iso8601(timestamp),
		"network":     nil,
		"address":     nil,
		"addressTo":   this.SafeString(delta, "destination"),
		"addressFrom": this.SafeString(delta, "user"),
		"tag":         nil,
		"tagTo":       nil,
		"tagFrom":     nil,
		"type":        nil,
		"amount":      this.SafeNumber(delta, "usdc"),
		"currency":    nil,
		"status":      this.SafeString(transaction, "status"),
		"updated":     nil,
		"comment":     nil,
		"internal":    internal,
		"fee":         fee,
	}
}

/**
 * @method
 * @name hyperliquid#fetchTradingFee
 * @description fetch the trading fees for a market
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.user] user address, will default to this.walletAddress if not provided
 * @param {string} [params.subAccountAddress] sub account user address
 * @returns {object} a [fee structure]{@link https://docs.ccxt.com/?id=fee-structure}
 */
func (this *HyperliquidCore) FetchTradingFee(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes38968 := (<-this.LoadMarkets())
		PanicOnError(retRes38968)
		var userAddress interface{} = nil
		userAddressparamsVariable := this.HandlePublicAddress("fetchTradingFee", params)
		userAddress = GetValue(userAddressparamsVariable, 0)
		params = GetValue(userAddressparamsVariable, 1)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"type": "userFees",
			"user": userAddress,
		}

		response := (<-this.PublicPostInfo(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "dailyUserVlm": [
		//             {
		//                 "date": "2024-07-08",
		//                 "userCross": "0.0",
		//                 "userAdd": "0.0",
		//                 "exchange": "90597185.23639999"
		//             }
		//         ],
		//         "feeSchedule": {
		//             "cross": "0.00035",
		//             "add": "0.0001",
		//             "tiers": {
		//                 "vip": [
		//                     {
		//                         "ntlCutoff": "5000000.0",
		//                         "cross": "0.0003",
		//                         "add": "0.00005"
		//                     }
		//                 ],
		//                 "mm": [
		//                     {
		//                         "makerFractionCutoff": "0.005",
		//                         "add": "-0.00001"
		//                     }
		//                 ]
		//             },
		//             "referralDiscount": "0.04"
		//         },
		//         "userCrossRate": "0.00035",
		//         "userAddRate": "0.0001",
		//         "activeReferralDiscount": "0.0"
		//     }
		//
		var data interface{} = map[string]interface{}{
			"userCrossRate": this.SafeString(response, "userCrossRate"),
			"userAddRate":   this.SafeString(response, "userAddRate"),
		}

		ch <- this.ParseTradingFee(data, market)
		return nil

	}()
	return ch
}
func (this *HyperliquidCore) ParseTradingFee(fee interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "dailyUserVlm": [
	//             {
	//                 "date": "2024-07-08",
	//                 "userCross": "0.0",
	//                 "userAdd": "0.0",
	//                 "exchange": "90597185.23639999"
	//             }
	//         ],
	//         "feeSchedule": {
	//             "cross": "0.00035",
	//             "add": "0.0001",
	//             "tiers": {
	//                 "vip": [
	//                     {
	//                         "ntlCutoff": "5000000.0",
	//                         "cross": "0.0003",
	//                         "add": "0.00005"
	//                     }
	//                 ],
	//                 "mm": [
	//                     {
	//                         "makerFractionCutoff": "0.005",
	//                         "add": "-0.00001"
	//                     }
	//                 ]
	//             },
	//             "referralDiscount": "0.04"
	//         },
	//         "userCrossRate": "0.00035",
	//         "userAddRate": "0.0001",
	//         "activeReferralDiscount": "0.0"
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var symbol interface{} = this.SafeSymbol(nil, market)
	return map[string]interface{}{
		"info":       fee,
		"symbol":     symbol,
		"maker":      this.SafeNumber(fee, "userAddRate"),
		"taker":      this.SafeNumber(fee, "userCrossRate"),
		"percentage": nil,
		"tierBased":  nil,
	}
}

/**
 * @method
 * @name hyperliquid#fetchLedger
 * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
 * @param {string} [code] unified currency code
 * @param {int} [since] timestamp in ms of the earliest ledger entry
 * @param {int} [limit] max number of ledger entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest ledger entry
 * @param {string} [params.subAccountAddress] sub account user address
 * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/?id=ledger-entry-structure}
 */
func (this *HyperliquidCore) FetchLedger(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes40078 := (<-this.LoadMarkets())
		PanicOnError(retRes40078)
		var userAddress interface{} = nil
		userAddressparamsVariable := this.HandlePublicAddress("fetchLedger", params)
		userAddress = GetValue(userAddressparamsVariable, 0)
		params = GetValue(userAddressparamsVariable, 1)
		var request interface{} = map[string]interface{}{
			"type": "userNonFundingLedgerUpdates",
			"user": userAddress,
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
		}
		var until interface{} = this.SafeInteger(params, "until")
		if IsTrue(!IsEqual(until, nil)) {
			AddElementToObject(request, "endTime", until)
			params = this.Omit(params, []interface{}{"until"})
		}

		response := (<-this.PublicPostInfo(this.Extend(request, params)))
		PanicOnError(response)

		//
		// [
		//     {
		//         "time":1724762307531,
		//         "hash":"0x620a234a7e0eb7930575040f59482a01050058b0802163b4767bfd9033e77781",
		//         "delta":{
		//             "type":"accountClassTransfer",
		//             "usdc":"50.0",
		//             "toPerp":false
		//         }
		//     }
		// ]
		//
		ch <- this.ParseLedger(response, nil, since, limit)
		return nil

	}()
	return ch
}
func (this *HyperliquidCore) ParseLedgerEntry(item interface{}, optionalArgs ...interface{}) interface{} {
	//
	// {
	//     "time":1724762307531,
	//     "hash":"0x620a234a7e0eb7930575040f59482a01050058b0802163b4767bfd9033e77781",
	//     "delta":{
	//         "type":"accountClassTransfer",
	//         "usdc":"50.0",
	//         "toPerp":false
	//     }
	// }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var timestamp interface{} = this.SafeInteger(item, "time")
	var delta interface{} = this.SafeDict(item, "delta", map[string]interface{}{})
	var fee interface{} = nil
	var feeCost interface{} = this.SafeInteger(delta, "fee")
	if IsTrue(!IsEqual(feeCost, nil)) {
		fee = map[string]interface{}{
			"currency": "USDC",
			"cost":     feeCost,
		}
	}
	var typeVar interface{} = this.SafeString(delta, "type")
	var amount interface{} = this.SafeString(delta, "usdc")
	return this.SafeLedgerEntry(map[string]interface{}{
		"info":             item,
		"id":               this.SafeString(item, "hash"),
		"direction":        nil,
		"account":          nil,
		"referenceAccount": this.SafeString(delta, "user"),
		"referenceId":      this.SafeString(item, "hash"),
		"type":             this.ParseLedgerEntryType(typeVar),
		"currency":         nil,
		"amount":           this.ParseNumber(amount),
		"timestamp":        timestamp,
		"datetime":         this.Iso8601(timestamp),
		"before":           nil,
		"after":            nil,
		"status":           nil,
		"fee":              fee,
	}, currency)
}
func (this *HyperliquidCore) ParseLedgerEntryType(typeVar interface{}) interface{} {
	var ledgerType interface{} = map[string]interface{}{
		"internalTransfer":     "transfer",
		"accountClassTransfer": "transfer",
	}
	return this.SafeString(ledgerType, typeVar, typeVar)
}

/**
 * @method
 * @name hyperliquid#fetchDeposits
 * @description fetch all deposits made to an account
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch withdrawals for
 * @param {string} [params.subAccountAddress] sub account user address
 * @param {string} [params.vaultAddress] vault address
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/?id=transaction-structure}
 */
func (this *HyperliquidCore) FetchDeposits(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes41048 := (<-this.LoadMarkets())
		PanicOnError(retRes41048)
		var userAddress interface{} = nil
		userAddressparamsVariable := this.HandlePublicAddress("fetchDepositsWithdrawals", params)
		userAddress = GetValue(userAddressparamsVariable, 0)
		params = GetValue(userAddressparamsVariable, 1)
		var request interface{} = map[string]interface{}{
			"type": "userNonFundingLedgerUpdates",
			"user": userAddress,
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
		}
		var until interface{} = this.SafeInteger(params, "until")
		if IsTrue(!IsEqual(until, nil)) {
			if IsTrue(IsEqual(since, nil)) {
				panic(ArgumentsRequired(Add(this.Id, " fetchDeposits requires since while until is set")))
			}
			AddElementToObject(request, "endTime", until)
			params = this.Omit(params, []interface{}{"until"})
		}

		response := (<-this.PublicPostInfo(this.Extend(request, params)))
		PanicOnError(response)
		//
		// [
		//     {
		//         "time":1724762307531,
		//         "hash":"0x620a234a7e0eb7930575040f59482a01050058b0802163b4767bfd9033e77781",
		//         "delta":{
		//             "type":"accountClassTransfer",
		//             "usdc":"50.0",
		//             "toPerp":false
		//         }
		//     }
		// ]
		//
		var records interface{} = this.ExtractTypeFromDelta(response)
		var vaultAddress interface{} = nil
		vaultAddressparamsVariable := this.HandleOptionAndParams(params, "fetchDepositsWithdrawals", "vaultAddress")
		vaultAddress = GetValue(vaultAddressparamsVariable, 0)
		params = GetValue(vaultAddressparamsVariable, 1)
		vaultAddress = this.FormatVaultAddress(vaultAddress)
		var deposits interface{} = []interface{}{}
		if IsTrue(!IsEqual(vaultAddress, nil)) {
			for i := 0; IsLessThan(i, GetArrayLength(records)); i++ {
				var record interface{} = GetValue(records, i)
				if IsTrue(IsEqual(GetValue(record, "type"), "vaultDeposit")) {
					var delta interface{} = this.SafeDict(record, "delta")
					if IsTrue(IsEqual(GetValue(delta, "vault"), Add("0x", vaultAddress))) {
						AppendToArray(&deposits, record)
					}
				}
			}
		} else {
			deposits = this.FilterByArray(records, "type", []interface{}{"deposit"}, false)
		}

		ch <- this.ParseTransactions(deposits, nil, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name hyperliquid#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawals structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch withdrawals for
 * @param {string} [params.subAccountAddress] sub account user address
 * @param {string} [params.vaultAddress] vault address
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/?id=transaction-structure}
 */
func (this *HyperliquidCore) FetchWithdrawals(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes41718 := (<-this.LoadMarkets())
		PanicOnError(retRes41718)
		var userAddress interface{} = nil
		userAddressparamsVariable := this.HandlePublicAddress("fetchDepositsWithdrawals", params)
		userAddress = GetValue(userAddressparamsVariable, 0)
		params = GetValue(userAddressparamsVariable, 1)
		var request interface{} = map[string]interface{}{
			"type": "userNonFundingLedgerUpdates",
			"user": userAddress,
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
		}
		var until interface{} = this.SafeInteger(params, "until")
		if IsTrue(!IsEqual(until, nil)) {
			AddElementToObject(request, "endTime", until)
			params = this.Omit(params, []interface{}{"until"})
		}

		response := (<-this.PublicPostInfo(this.Extend(request, params)))
		PanicOnError(response)
		//
		// [
		//     {
		//         "time":1724762307531,
		//         "hash":"0x620a234a7e0eb7930575040f59482a01050058b0802163b4767bfd9033e77781",
		//         "delta":{
		//             "type":"accountClassTransfer",
		//             "usdc":"50.0",
		//             "toPerp":false
		//         }
		//     }
		// ]
		//
		var records interface{} = this.ExtractTypeFromDelta(response)
		var vaultAddress interface{} = nil
		vaultAddressparamsVariable := this.HandleOptionAndParams(params, "fetchDepositsWithdrawals", "vaultAddress")
		vaultAddress = GetValue(vaultAddressparamsVariable, 0)
		params = GetValue(vaultAddressparamsVariable, 1)
		vaultAddress = this.FormatVaultAddress(vaultAddress)
		var withdrawals interface{} = []interface{}{}
		if IsTrue(!IsEqual(vaultAddress, nil)) {
			for i := 0; IsLessThan(i, GetArrayLength(records)); i++ {
				var record interface{} = GetValue(records, i)
				if IsTrue(IsEqual(GetValue(record, "type"), "vaultWithdraw")) {
					var delta interface{} = this.SafeDict(record, "delta")
					if IsTrue(IsEqual(GetValue(delta, "vault"), Add("0x", vaultAddress))) {
						AppendToArray(&withdrawals, record)
					}
				}
			}
		} else {
			withdrawals = this.FilterByArray(records, "type", []interface{}{"withdraw"}, false)
		}

		ch <- this.ParseTransactions(withdrawals, nil, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name hyperliquid#fetchOpenInterests
 * @description Retrieves the open interest for a list of symbols
 * @param {string[]} [symbols] Unified CCXT market symbol
 * @param {object} [params] exchange specific parameters
 * @returns {object} an open interest structure{@link https://docs.ccxt.com/?id=open-interest-structure}
 */
func (this *HyperliquidCore) FetchOpenInterests(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes42308 := (<-this.LoadMarkets())
		PanicOnError(retRes42308)
		symbols = this.MarketSymbols(symbols)

		swapMarkets := (<-this.FetchSwapMarkets())
		PanicOnError(swapMarkets)

		ch <- this.ParseOpenInterests(swapMarkets, symbols)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name hyperliquid#fetchOpenInterest
 * @description retrieves the open interest of a contract trading pair
 * @param {string} symbol unified CCXT market symbol
 * @param {object} [params] exchange specific parameters
 * @returns {object} an [open interest structure]{@link https://docs.ccxt.com/?id=open-interest-structure}
 */
func (this *HyperliquidCore) FetchOpenInterest(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		symbol = this.Symbol(symbol)

		retRes42468 := (<-this.LoadMarkets())
		PanicOnError(retRes42468)

		ois := (<-this.FetchOpenInterests([]interface{}{symbol}, params))
		PanicOnError(ois)

		ch <- GetValue(ois, symbol)
		return nil

	}()
	return ch
}
func (this *HyperliquidCore) ParseOpenInterest(interest interface{}, optionalArgs ...interface{}) interface{} {
	//
	//  {
	//      szDecimals: '2',
	//      name: 'HYPE',
	//      maxLeverage: '3',
	//      funding: '0.00014735',
	//      openInterest: '14677900.74',
	//      prevDayPx: '26.145',
	//      dayNtlVlm: '299643445.12560016',
	//      premium: '0.00081613',
	//      oraclePx: '27.569',
	//      markPx: '27.63',
	//      midPx: '27.599',
	//      impactPxs: [ '27.5915', '27.6319' ],
	//      dayBaseVlm: '10790652.83',
	//      baseId: 159
	//  }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	interest = this.SafeDict(interest, "info", map[string]interface{}{})
	var coin interface{} = this.SafeString(interest, "name")
	var marketId interface{} = nil
	if IsTrue(!IsEqual(coin, nil)) {
		marketId = this.CoinToMarketId(coin)
	}
	return this.SafeOpenInterest(map[string]interface{}{
		"symbol":             this.SafeSymbol(marketId),
		"openInterestAmount": this.SafeNumber(interest, "openInterest"),
		"openInterestValue":  nil,
		"timestamp":          nil,
		"datetime":           nil,
		"info":               interest,
	}, market)
}

/**
 * @method
 * @name hyperliquid#fetchFundingHistory
 * @description fetch the history of funding payments paid and received on this account
 * @param {string} [symbol] unified market symbol
 * @param {int} [since] the earliest time in ms to fetch funding history for
 * @param {int} [limit] the maximum number of funding history structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.subAccountAddress] sub account user address
 * @returns {object} a [funding history structure]{@link https://docs.ccxt.com/?id=funding-history-structure}
 */
func (this *HyperliquidCore) FetchFundingHistory(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes42988 := (<-this.LoadMarkets())
		PanicOnError(retRes42988)
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
		}
		var userAddress interface{} = nil
		userAddressparamsVariable := this.HandlePublicAddress("fetchFundingHistory", params)
		userAddress = GetValue(userAddressparamsVariable, 0)
		params = GetValue(userAddressparamsVariable, 1)
		var request interface{} = map[string]interface{}{
			"user": userAddress,
			"type": "userFunding",
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
		}
		var until interface{} = this.SafeInteger(params, "until")
		params = this.Omit(params, "until")
		if IsTrue(!IsEqual(until, nil)) {
			AddElementToObject(request, "endTime", until)
		}

		response := (<-this.PublicPostInfo(this.Extend(request, params)))
		PanicOnError(response)

		//
		// [
		//     {
		//         "time": 1734026400057,
		//         "hash": "0x0000000000000000000000000000000000000000000000000000000000000000",
		//         "delta": {
		//             "type": "funding",
		//             "coin": "SOL",
		//             "usdc": "75.635093",
		//             "szi": "-7375.9",
		//             "fundingRate": "0.00004381",
		//             "nSamples": null
		//         }
		//     }
		// ]
		//
		ch <- this.ParseIncomes(response, market, since, limit)
		return nil

	}()
	return ch
}
func (this *HyperliquidCore) ParseIncome(income interface{}, optionalArgs ...interface{}) interface{} {
	//
	// {
	//     "time": 1734026400057,
	//     "hash": "0x0000000000000000000000000000000000000000000000000000000000000000",
	//     "delta": {
	//         "type": "funding",
	//         "coin": "SOL",
	//         "usdc": "75.635093",
	//         "szi": "-7375.9",
	//         "fundingRate": "0.00004381",
	//         "nSamples": null
	//     }
	// }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var id interface{} = this.SafeString(income, "hash")
	var timestamp interface{} = this.SafeInteger(income, "time")
	var delta interface{} = this.SafeDict(income, "delta")
	var baseId interface{} = this.SafeString(delta, "coin")
	var marketSymbol interface{} = Add(baseId, "/USDC:USDC")
	market = this.SafeMarket(marketSymbol)
	var symbol interface{} = GetValue(market, "symbol")
	var amount interface{} = this.SafeString(delta, "usdc")
	var code interface{} = this.SafeCurrencyCode("USDC")
	var rate interface{} = this.SafeNumber(delta, "fundingRate")
	return map[string]interface{}{
		"info":      income,
		"symbol":    symbol,
		"code":      code,
		"timestamp": timestamp,
		"datetime":  this.Iso8601(timestamp),
		"id":        id,
		"amount":    this.ParseNumber(amount),
		"rate":      rate,
	}
}

/**
 * @method
 * @name hyperliquid#reserveRequestWeight
 * @description Instead of trading to increase the address based rate limits, this action allows reserving additional actions for 0.0005 USDC per request. The cost is paid from the Perps balance.
 * @param {number} weight the weight to reserve, 1 weight = 1 action, 0.0005 USDC per action
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a response object
 */
func (this *HyperliquidCore) ReserveRequestWeight(weight interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		var nonce interface{} = this.Milliseconds()
		var request interface{} = map[string]interface{}{
			"nonce": nonce,
		}
		var action interface{} = map[string]interface{}{
			"type":   "reserveRequestWeight",
			"weight": weight,
		}
		var signature interface{} = this.SignL1Action(action, nonce)
		AddElementToObject(request, "action", action)
		AddElementToObject(request, "signature", signature)

		response := (<-this.PrivatePostExchange(this.Extend(request, params)))
		PanicOnError(response)

		ch <- response
		return nil

	}()
	return ch
}

/**
 * @method
 * @name hyperliquid#createAccount
 * @description creates a sub-account under the main account
 * @param {string} name the name of the sub-account
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.expiresAfter] time in ms after which the sub-account will expire
 * @returns {object} a response object
 */
func (this *HyperliquidCore) CreateSubAccount(name interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		var nonce interface{} = this.Milliseconds()
		var request interface{} = map[string]interface{}{
			"nonce": nonce,
		}
		var action interface{} = map[string]interface{}{
			"type": "createSubAccount",
			"name": name,
		}
		var expiresAfter interface{} = this.SafeInteger(params, "expiresAfter")
		if IsTrue(!IsEqual(expiresAfter, nil)) {
			params = this.Omit(params, "expiresAfter")
			AddElementToObject(request, "expiresAfter", expiresAfter)
		}
		var signature interface{} = this.SignL1Action(action, nonce, nil, expiresAfter)
		AddElementToObject(request, "action", action)
		AddElementToObject(request, "signature", signature)

		response := (<-this.PrivatePostExchange(this.Extend(request, params)))
		PanicOnError(response)

		ch <- response
		return nil

	}()
	return ch
}
func (this *HyperliquidCore) ExtractTypeFromDelta(optionalArgs ...interface{}) interface{} {
	data := GetArg(optionalArgs, 0, []interface{}{})
	_ = data
	var records interface{} = []interface{}{}
	for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
		var record interface{} = GetValue(data, i)
		AddElementToObject(record, "type", GetValue(GetValue(record, "delta"), "type"))
		AppendToArray(&records, record)
	}
	return records
}
func (this *HyperliquidCore) FormatVaultAddress(optionalArgs ...interface{}) interface{} {
	address := GetArg(optionalArgs, 0, nil)
	_ = address
	if IsTrue(IsEqual(address, nil)) {
		return nil
	}
	if IsTrue(StartsWith(address, "0x")) {
		return Replace(address, "0x", "")
	}
	return address
}
func (this *HyperliquidCore) HandlePublicAddress(methodName interface{}, params interface{}) interface{} {
	var userAux interface{} = nil
	userAuxparamsVariable := this.HandleOptionAndParams2(params, methodName, "user", "subAccountAddress")
	userAux = GetValue(userAuxparamsVariable, 0)
	params = GetValue(userAuxparamsVariable, 1)
	var user interface{} = userAux
	userparamsVariable := this.HandleOptionAndParams(params, methodName, "address", userAux)
	user = GetValue(userparamsVariable, 0)
	params = GetValue(userparamsVariable, 1)
	if IsTrue(IsTrue((!IsEqual(user, nil))) && IsTrue((!IsEqual(user, "")))) {
		return []interface{}{user, params}
	}
	if IsTrue(IsTrue((!IsEqual(this.WalletAddress, nil))) && IsTrue((!IsEqual(this.WalletAddress, "")))) {
		return []interface{}{this.WalletAddress, params}
	}
	panic(ArgumentsRequired(Add(Add(Add(this.Id, " "), methodName), "() requires a user parameter inside \\'params\\' or the wallet address set")))
}
func (this *HyperliquidCore) CoinToMarketId(coin interface{}) interface{} {
	// handle also hip3 tokens like flx:CRCL
	if IsTrue(IsEqual(coin, nil)) {
		return nil
	}
	var hi3TokensByname interface{} = this.SafeDict(this.Options, "hip3TokensByName", map[string]interface{}{})
	if IsTrue(this.SafeDict(hi3TokensByname, coin)) {
		var hip3Dict interface{} = this.SafeDict(hi3TokensByname, coin)
		var quote interface{} = this.SafeString(hip3Dict, "quote", "USDC")
		var code interface{} = this.SafeString(hip3Dict, "code", coin)
		return Add(Add(Add(Add(code, "/"), quote), ":"), quote)
	}
	if IsTrue(IsTrue(IsGreaterThan(GetIndexOf(coin, "/"), OpNeg(1))) || IsTrue(IsGreaterThan(GetIndexOf(coin, "@"), OpNeg(1)))) {
		return coin // spot
	}
	if IsTrue(IsGreaterThan(GetIndexOf(coin, ":"), OpNeg(1))) {
		coin = Replace(coin, ":", "-") // hip3
	}
	return Add(this.SafeCurrencyCode(coin), "/USDC:USDC")
}
func (this *HyperliquidCore) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{} {
	if !IsTrue(response) {
		return nil // fallback to default error handler
	}
	// {"status":"err","response":"User or API Wallet 0xb8a6f8b26223de27c31938d56e470a5b832703a5 does not exist."}
	//
	//     {
	//         status: 'ok',
	//         response: { type: 'order', data: { statuses: [ { error: 'Insufficient margin to place order. asset=4' } ] } }
	//     }
	// {"status":"ok","response":{"type":"order","data":{"statuses":[{"error":"Insufficient margin to place order. asset=84"}]}}}
	//
	// {"status":"unknownOid"}
	//
	var status interface{} = this.SafeString(response, "status", "")
	var error interface{} = this.SafeString(response, "error")
	var message interface{} = nil
	if IsTrue(IsEqual(status, "err")) {
		message = this.SafeString(response, "response")
	} else if IsTrue(IsEqual(status, "unknownOid")) {
		panic(OrderNotFound(Add(Add(this.Id, " "), body)))
	} else if IsTrue(!IsEqual(error, nil)) {
		message = error
	} else {
		var responsePayload interface{} = this.SafeDict(response, "response", map[string]interface{}{})
		var data interface{} = this.SafeDict(responsePayload, "data", map[string]interface{}{})
		var statuses interface{} = this.SafeList(data, "statuses", []interface{}{})
		for i := 0; IsLessThan(i, GetArrayLength(statuses)); i++ {
			message = this.SafeString(GetValue(statuses, i), "error")
			if IsTrue(!IsEqual(message, nil)) {
				break
			}
		}
	}
	var feedback interface{} = Add(Add(this.Id, " "), body)
	var nonEmptyMessage interface{} = (IsTrue((!IsEqual(message, nil))) && IsTrue((!IsEqual(message, ""))))
	if IsTrue(nonEmptyMessage) {
		this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), message, feedback)
		this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), message, feedback)
	}
	if IsTrue(nonEmptyMessage) {
		panic(ExchangeError(feedback))
	}
	return nil
}
func (this *HyperliquidCore) Sign(path interface{}, optionalArgs ...interface{}) interface{} {
	api := GetArg(optionalArgs, 0, "public")
	_ = api
	method := GetArg(optionalArgs, 1, "GET")
	_ = method
	params := GetArg(optionalArgs, 2, map[string]interface{}{})
	_ = params
	headers := GetArg(optionalArgs, 3, nil)
	_ = headers
	body := GetArg(optionalArgs, 4, nil)
	_ = body
	var url interface{} = Add(Add(this.ImplodeHostname(GetValue(GetValue(this.Urls, "api"), api)), "/"), path)
	if IsTrue(IsEqual(method, "POST")) {
		headers = map[string]interface{}{
			"Content-Type": "application/json",
		}
		body = this.Json(params)
	}
	return map[string]interface{}{
		"url":     url,
		"method":  method,
		"body":    body,
		"headers": headers,
	}
}
func (this *HyperliquidCore) CalculateRateLimiterCost(api interface{}, method interface{}, path interface{}, params interface{}, optionalArgs ...interface{}) interface{} {
	config := GetArg(optionalArgs, 0, map[string]interface{}{})
	_ = config
	if IsTrue(IsTrue((InOp(config, "byType"))) && IsTrue((InOp(params, "type")))) {
		var typeVar interface{} = GetValue(params, "type")
		var byType interface{} = GetValue(config, "byType")
		if IsTrue(InOp(byType, typeVar)) {
			return GetValue(byType, typeVar)
		}
	}
	return this.SafeValue(config, "cost", 1)
}
func (this *HyperliquidCore) ParseCreateEditOrderArgs(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{} {
	price := GetArg(optionalArgs, 0, nil)
	_ = price
	params := GetArg(optionalArgs, 1, map[string]interface{}{})
	_ = params
	var market interface{} = this.Market(symbol)
	var vaultAddress interface{} = nil
	vaultAddressparamsVariable := this.HandleOptionAndParams2(params, "createOrder", "vaultAddress", "subAccountAddress")
	vaultAddress = GetValue(vaultAddressparamsVariable, 0)
	params = GetValue(vaultAddressparamsVariable, 1)
	vaultAddress = this.FormatVaultAddress(vaultAddress)
	symbol = GetValue(market, "symbol")
	var order interface{} = map[string]interface{}{
		"symbol": symbol,
		"type":   typeVar,
		"side":   side,
		"amount": amount,
		"price":  price,
		"params": params,
	}
	var globalParams interface{} = map[string]interface{}{}
	if IsTrue(!IsEqual(vaultAddress, nil)) {
		AddElementToObject(globalParams, "vaultAddress", vaultAddress)
	}
	if IsTrue(!IsEqual(id, nil)) {
		AddElementToObject(order, "id", id)
	}
	return []interface{}{order, globalParams}
}

func (this *HyperliquidCore) Init(userConfig map[string]interface{}) {
	this.Exchange = Exchange{}
	this.Exchange.DerivedExchange = this
	this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
}
