package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type coinlist struct {
    Exchange

}

func NewCoinlistCore() coinlist {
   p := coinlist{}
   setDefaults(&p)
   return p
}

func  (this *coinlist) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "coinlist",
        "name": "Coinlist",
        "countries": []interface{}{"US"},
        "version": "v1",
        "rateLimit": 300,
        "certified": false,
        "pro": false,
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": false,
            "swap": false,
            "future": false,
            "option": false,
            "addMargin": false,
            "cancelAllOrders": true,
            "cancelOrder": true,
            "cancelOrders": true,
            "closeAllPositions": false,
            "closePosition": false,
            "createDepositAddress": false,
            "createOrder": true,
            "createPostOnlyOrder": true,
            "createReduceOnlyOrder": false,
            "createStopLimitOrder": true,
            "createStopMarketOrder": true,
            "createStopOrder": true,
            "deposit": false,
            "editOrder": true,
            "fetchAccounts": true,
            "fetchBalance": true,
            "fetchBidsAsks": false,
            "fetchBorrowInterest": false,
            "fetchBorrowRateHistories": false,
            "fetchBorrowRateHistory": false,
            "fetchCanceledOrders": true,
            "fetchClosedOrder": false,
            "fetchClosedOrders": true,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchCurrencies": true,
            "fetchDeposit": false,
            "fetchDepositAddress": false,
            "fetchDepositAddresses": false,
            "fetchDepositAddressesByNetwork": false,
            "fetchDeposits": false,
            "fetchDepositsWithdrawals": true,
            "fetchDepositWithdrawFee": false,
            "fetchDepositWithdrawFees": false,
            "fetchFundingHistory": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchIndexOHLCV": false,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchL3OrderBook": false,
            "fetchLedger": true,
            "fetchLeverage": false,
            "fetchLeverageTiers": false,
            "fetchMarketLeverageTiers": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrder": false,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrderBooks": false,
            "fetchOrders": true,
            "fetchOrderTrades": true,
            "fetchPosition": false,
            "fetchPositionHistory": false,
            "fetchPositionMode": false,
            "fetchPositions": false,
            "fetchPositionsForSymbol": false,
            "fetchPositionsHistory": false,
            "fetchPositionsRisk": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchStatus": false,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTime": true,
            "fetchTrades": true,
            "fetchTradingFee": false,
            "fetchTradingFees": true,
            "fetchTradingLimits": false,
            "fetchTransactionFee": false,
            "fetchTransactionFees": false,
            "fetchTransactions": true,
            "fetchTransfers": true,
            "fetchWithdrawal": false,
            "fetchWithdrawals": false,
            "fetchWithdrawalWhitelist": false,
            "reduceMargin": false,
            "repayCrossMargin": false,
            "repayIsolatedMargin": false,
            "setLeverage": false,
            "setMargin": false,
            "setMarginMode": false,
            "setPositionMode": false,
            "signIn": false,
            "transfer": true,
            "withdraw": true,
            "ws": false,
        },
        "timeframes": map[string]interface{} {
            "1m": "1m",
            "5m": "5m",
            "30m": "30m",
        },
        "urls": map[string]interface{} {
            "logo": "https://github-production-user-asset-6210df.s3.amazonaws.com/1294454/281108917-eff2ae1d-ce8a-4b2a-950d-8678b12da965.jpg",
            "api": map[string]interface{} {
                "public": "https://trade-api.coinlist.co",
                "private": "https://trade-api.coinlist.co",
            },
            "www": "https://coinlist.co",
            "doc": []interface{}{"https://trade-docs.coinlist.co"},
            "fees": "https://coinlist.co/fees",
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": map[string]interface{} {
                    "v1/symbols": 1,
                    "v1/symbols/summary": 1,
                    "v1/symbols/{symbol}": 1,
                    "v1/symbols/{symbol}/summary": 1,
                    "v1/symbols/{symbol}/book": 1,
                    "v1/symbols/{symbol}/quote": 1,
                    "v1/symbols/{symbol}/candles": 1,
                    "v1/symbols/{symbol}/auctions": 1,
                    "v1/symbols/{symbol}/auctions/{auction_code}": 1,
                    "v1/time": 1,
                    "v1/assets": 1,
                    "v1/leaderboard": 1,
                    "v1/affiliate/{competition_code}": 1,
                    "v1/competition/{competition_id}": 1,
                },
            },
            "private": map[string]interface{} {
                "get": map[string]interface{} {
                    "v1/fees": 1,
                    "v1/accounts": 1,
                    "v1/accounts/{trader_id}": 1,
                    "v1/accounts/{trader_id}/alias": 1,
                    "v1/accounts/{trader_id}/ledger": 1,
                    "v1/accounts/{trader_id}/wallets": 1,
                    "v1/accounts/{trader_id}/wallet-ledger": 1,
                    "v1/accounts/{trader_id}/ledger-summary": 1,
                    "v1/keys": 1,
                    "v1/fills": 1,
                    "v1/orders": 1,
                    "v1/orders/{order_id}": 1,
                    "v1/reports": 1,
                    "v1/balances": 1,
                    "v1/transfers": 1,
                    "v1/user": 1,
                    "v1/credits": 1,
                    "v1/positions": 1,
                    "v1/accounts/{trader_id}/competitions": 1,
                },
                "post": map[string]interface{} {
                    "v1/keys": 1,
                    "v1/orders": 1,
                    "v1/orders/cancel-all-after": 1,
                    "v1/reports": 1,
                    "v1/transfers/to-wallet": 1,
                    "v1/transfers/from-wallet": 1,
                    "v1/transfers/internal-transfer": 1,
                    "v1/transfers/withdrawal-request": 1,
                    "v1/orders/bulk": 1,
                    "v1/accounts/{trader_id}/competitions": 1,
                    "v1/accounts/{trader_id}/create-competition": 1,
                },
                "patch": map[string]interface{} {
                    "v1/orders/{order_id}": 1,
                    "v1/orders/bulk": 1,
                },
                "delete": map[string]interface{} {
                    "v1/keys/{key}": 1,
                    "v1/orders": 1,
                    "v1/orders/{order_id}": 1,
                    "v1/orders/bulk": 1,
                },
            },
        },
        "features": map[string]interface{} {
            "default": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": true,
                    "triggerPriceType": map[string]interface{} {
                        "last": true,
                        "mark": true,
                        "index": true,
                    },
                    "triggerDirection": false,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": false,
                        "FOK": false,
                        "PO": true,
                        "GTD": false,
                    },
                    "hedged": false,
                    "trailing": true,
                    "leverage": false,
                    "marketBuyByCost": false,
                    "marketBuyRequiresPrice": false,
                    "selfTradePrevention": true,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": 500,
                    "daysBack": 100000,
                    "untilDays": 100000,
                    "symbolRequired": false,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 500,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 500,
                    "daysBack": 100000,
                    "untilDays": 100000,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchClosedOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 500,
                    "daysBack": 100000,
                    "daysBackCanceled": nil,
                    "untilDays": 100000,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOHLCV": map[string]interface{} {
                    "limit": 300,
                },
            },
            "swap": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "feeSide": "get",
                "tierBased": true,
                "percentage": true,
                "taker": this.ParseNumber("0.0045"),
                "maker": this.ParseNumber("0.0025"),
                "tiers": map[string]interface{} {
                    "taker": []interface{}{[]interface{}{this.ParseNumber("0"), this.ParseNumber("0.0045")}, []interface{}{this.ParseNumber("20000"), this.ParseNumber("0.003")}, []interface{}{this.ParseNumber("50000"), this.ParseNumber("0.0025")}, []interface{}{this.ParseNumber("100000"), this.ParseNumber("0.002")}, []interface{}{this.ParseNumber("500000"), this.ParseNumber("0.0018")}, []interface{}{this.ParseNumber("750000"), this.ParseNumber("0.0018")}, []interface{}{this.ParseNumber("1000000"), this.ParseNumber("0.0016")}, []interface{}{this.ParseNumber("2500000"), this.ParseNumber("0.0013")}, []interface{}{this.ParseNumber("5000000"), this.ParseNumber("0.0012")}, []interface{}{this.ParseNumber("10000000"), this.ParseNumber("0.001")}, []interface{}{this.ParseNumber("50000000"), this.ParseNumber("0.0005")}, []interface{}{this.ParseNumber("100000000"), this.ParseNumber("0.0005")}},
                    "maker": []interface{}{[]interface{}{this.ParseNumber("0"), this.ParseNumber("0.0025")}, []interface{}{this.ParseNumber("20000"), this.ParseNumber("0.0025")}, []interface{}{this.ParseNumber("50000"), this.ParseNumber("0.0025")}, []interface{}{this.ParseNumber("100000"), this.ParseNumber("0.002")}, []interface{}{this.ParseNumber("500000"), this.ParseNumber("0.0015")}, []interface{}{this.ParseNumber("750000"), this.ParseNumber("0.0012")}, []interface{}{this.ParseNumber("1000000"), this.ParseNumber("0.001")}, []interface{}{this.ParseNumber("2500000"), this.ParseNumber("0.0008")}, []interface{}{this.ParseNumber("5000000"), this.ParseNumber("0.0007")}, []interface{}{this.ParseNumber("10000000"), this.ParseNumber("0.0006")}, []interface{}{this.ParseNumber("50000000"), this.ParseNumber("0.0000")}, []interface{}{this.ParseNumber("100000000"), this.ParseNumber("0.00")}},
                },
            },
        },
        "precisionMode": TICK_SIZE,
        "options": map[string]interface{} {
            "accountsByType": map[string]interface{} {
                "CoinList Pro": "trading",
                "CoinList Pro trading account": "trading",
                "Pro": "trading",
                "pro": "trading",
                "trade": "trading",
                "trading": "trading",
                "CoinList": "funding",
                "CoinList wallet": "funding",
                "Wallet": "funding",
                "wallet": "funding",
                "fund": "funding",
                "funding": "funding",
            },
        },
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "AUTH_SIG_INVALID": AuthenticationError,
                "DENIED_MAINTENANCE": OnMaintenance,
                "ORDER_REJECT_BAD_STATUS": InvalidOrder,
                "ORDER_REJECT_INVALID_POST_ONLY": InvalidOrder,
                "ORDER_REJECT_INVALID_CLOSE_ONLY": InvalidOrder,
                "ORDER_REJECT_POST_ONLY_REQUIRED": InvalidOrder,
                "ORDER_REJECT_FROZEN_ORDER": InvalidOrder,
                "ORDER_REJECT_LIMIT_PRICE_PROTECTION_VIOLATION": InvalidOrder,
                "ORDER_REJECT_CLOSED": NotSupported,
                "ORDER_REJECT_MAX_ORDERS": BadRequest,
                "ORDER_REJECT_NOT_FOUND": OrderNotFound,
                "ORDER_REJECT_PARSE_ERROR": BadRequest,
                "ORDER_REJECT_PRICE_INVALID": InvalidOrder,
                "ORDER_REJECT_QUANTITY_ZERO": InvalidOrder,
                "ORDER_REJECT_TOKEN_LIMIT": InsufficientFunds,
                "ORDER_REJECT_TOKEN_LIMIT_OTHER": InvalidOrder,
                "ORDER_REJECT_SELF_TRADE": InvalidOrder,
                "ORDER_VALIDATE_BAD_SIZE_ALIGNMENT": InvalidOrder,
                "ORDER_VALIDATE_BAD_TICK_ALIGNMENT": InvalidOrder,
                "ORDER_VALIDATE_SYMBOL_NOT_FOUND": BadSymbol,
                "TRANSFERS_WITHDRAWAL_REQUEST_TOO_LARGE": InsufficientFunds,
                "WITHDRAWAL_REQUEST_NOT_ALLOWED": PermissionDenied,
            },
            "broad": map[string]interface{} {
                "A destinationAddress is required for non-USD withdrawals": InvalidAddress,
                "fails to match the JsonSchema date-time format pattern": BadRequest,
                "is required": ArgumentsRequired,
                "must be a string": BadRequest,
                "must be a valid GUID": BadRequest,
                "must be greater than or equal to": BadRequest,
                "must be less than or equal to": BadRequest,
                "must be one of": BadRequest,
                "Symbol not found": BadSymbol,
            },
        },
    })
}
func  (this *coinlist) CalculateRateLimiterCost(api interface{}, method interface{}, path interface{}, params interface{}, optionalArgs ...interface{}) interface{}  {
    config := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = config
    if IsTrue(IsArray(params)) {
        var length interface{} =         GetArrayLength(params)
        return MathCeil(Divide(length, 2))
    }
    return 1
}
/**
 * @method
 * @name coinlist#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @see https://trade-docs.coinlist.co/?javascript--nodejs#get-system-time
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func  (this *coinlist) FetchTime(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetV1Time(params))
            PanicOnError(response)
            //
            //     {
            //         "epoch": 1698087996.039,
            //         "iso": "2023-10-23T19:06:36.039Z"
            //     }
            //
            var string interface{} = this.SafeString(response, "iso")
        
            ch <- this.Parse8601(string)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinlist#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see https://trade-docs.coinlist.co/?javascript--nodejs#list-supported-assets
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func  (this *coinlist) FetchCurrencies(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetV1Assets(params))
            PanicOnError(response)
            //
            //     {
            //         "assets": [
            //             {
            //                 "asset": "AAVE",
            //                 "index_code": ".AAVEUSD",
            //                 "decimal_places": 18,
            //                 "min_withdrawal": "1.0000",
            //                 "is_transferable": true,
            //                 "is_visible": true
            //             },
            //             {
            //                 "asset": "ALGO",
            //                 "index_code": ".ALGOUSD",
            //                 "decimal_places": 6,
            //                 "min_withdrawal": "1.0000",
            //                 "is_transferable": true,
            //                 "is_visible": true
            //             }
            //         ]
            //     }
            //
            var currencies interface{} = this.SafeValue(response, "assets", []interface{}{})
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(currencies)); i++ {
                var currency interface{} = GetValue(currencies, i)
                var id interface{} = this.SafeString(currency, "asset")
                var code interface{} = this.SafeCurrencyCode(id)
                var isTransferable interface{} = this.SafeBool(currency, "is_transferable", false)
                var withdrawEnabled interface{} = isTransferable
                var depositEnabled interface{} = isTransferable
                var active interface{} = isTransferable
                var decimalPlaces interface{} = this.SafeString(currency, "decimal_places")
                var precision interface{} = this.ParseNumber(this.ParsePrecision(decimalPlaces))
                var minWithdrawal interface{} = this.SafeString(currency, "min_withdrawal")
                AddElementToObject(result, code, map[string]interface{} {
            "id": id,
            "code": code,
            "name": code,
            "info": currency,
            "active": active,
            "deposit": depositEnabled,
            "withdraw": withdrawEnabled,
            "fee": nil,
            "precision": precision,
            "limits": map[string]interface{} {
                "amount": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
                "withdraw": map[string]interface{} {
                    "min": minWithdrawal,
                    "max": nil,
                },
            },
            "networks": map[string]interface{} {},
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinlist#fetchMarkets
 * @description retrieves data on all markets for coinlist
 * @see https://trade-docs.coinlist.co/?javascript--nodejs#list-symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *coinlist) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetV1Symbols(params))
            PanicOnError(response)
            //
            //     {
            //         "symbols": [
            //             {
            //                 "symbol": "CQT-USDT",
            //                 "base_currency": "CQT",
            //                 "is_trader_geofenced": false,
            //                 "list_time": "2021-06-15T00:00:00.000Z",
            //                 "type": "spot",
            //                 "series_code": "CQT-USDT-SPOT",
            //                 "long_name": "Covalent",
            //                 "asset_class": "CRYPTO",
            //                 "minimum_price_increment": "0.0001",
            //                 "minimum_size_increment": "0.0001",
            //                 "quote_currency": "USDT",
            //                 "index_code": null,
            //                 "price_band_threshold_market": "0.05",
            //                 "price_band_threshold_limit": "0.25",
            //                 "last_price": "0.12160000",
            //                 "fair_price": "0.12300000",
            //                 "index_price": null
            //             },
            //         ]
            //     }
            //
            var markets interface{} = this.SafeValue(response, "symbols", []interface{}{})
        
            ch <- this.ParseMarkets(markets)
            return nil
        
            }()
            return ch
        }
func  (this *coinlist) ParseMarket(market interface{}) interface{}  {
    var id interface{} = this.SafeString(market, "symbol")
    var baseId interface{} = this.SafeString(market, "base_currency")
    var quoteId interface{} = this.SafeString(market, "quote_currency")
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    var amountPrecision interface{} = this.SafeString(market, "minimum_size_increment")
    var pricePrecision interface{} = this.SafeString(market, "minimum_price_increment")
    var created interface{} = this.SafeString(market, "list_time")
    return map[string]interface{} {
        "id": id,
        "symbol": Add(Add(base, "/"), quote),
        "base": base,
        "quote": quote,
        "settle": nil,
        "baseId": baseId,
        "quoteId": quoteId,
        "settleId": nil,
        "type": "spot",
        "spot": true,
        "margin": false,
        "swap": false,
        "future": false,
        "option": false,
        "active": true,
        "contract": false,
        "linear": nil,
        "inverse": nil,
        "contractSize": nil,
        "expiry": nil,
        "expiryDatetime": nil,
        "strike": nil,
        "optionType": nil,
        "precision": map[string]interface{} {
            "amount": this.ParseNumber(amountPrecision),
            "price": this.ParseNumber(pricePrecision),
        },
        "limits": map[string]interface{} {
            "leverage": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "amount": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "price": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "cost": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
        },
        "created": this.Parse8601(created),
        "info": market,
    }
}
/**
 * @method
 * @name coinlist#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://trade-docs.coinlist.co/?javascript--nodejs#get-symbol-summaries
 * @param {string[]} [symbols] unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *coinlist) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes5878 := (<-this.LoadMarkets())
            PanicOnError(retRes5878)
            var request interface{} = map[string]interface{} {}
        
            tickers:= (<-this.PublicGetV1SymbolsSummary(this.Extend(request, params)))
            PanicOnError(tickers)
        
                //
            //     {
            //         "MATIC-USD": {
            //             "type":"spot",
            //             "last_price":"0.60990000",
            //             "lowest_ask":"0.61190000",
            //             "highest_bid":"0.60790000",
            //             "last_trade": {
            //                 "price":"0.60000000",
            //                 "volume":"2.0000",
            //                 "imbalance":"198.0000",
            //                 "logicalTime":"2023-10-22T23:02:25.000Z",
            //                 "auctionCode":"MATIC-USD-2023-10-22T23:02:25.000Z"
            //         },
            //             "volume_base_24h":"34.0555",
            //             "volume_quote_24h":"19.9282",
            //             "price_change_percent_24h":"7.50925436",
            //             "highest_price_24h":"0.68560000",
            //             "lowest_price_24h":"0.55500000"
            //         },
            //     }
            //
        ch <- this.ParseTickers(tickers, symbols, params)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinlist#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://trade-docs.coinlist.co/?javascript--nodejs#get-market-summary
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *coinlist) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes6258 := (<-this.LoadMarkets())
            PanicOnError(retRes6258)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            ticker:= (<-this.PublicGetV1SymbolsSymbolSummary(this.Extend(request, params)))
            PanicOnError(ticker)
        
                //
            //     {
            //         "type":"spot",
            //         "last_price":"31125.00000000",
            //         "lowest_ask":"31349.99000000",
            //         "highest_bid":"30900.00000000",
            //         "last_trade": {
            //             "price":"31000.00000000",
            //             "volume":"0.0003",
            //             "imbalance":"0.0000",
            //             "logicalTime":"2023-10-23T16:57:15.000Z",
            //             "auctionCode":"BTC-USDT-2023-10-23T16:57:15.000Z"
            //         },
            //         "volume_base_24h":"0.3752",
            //         "volume_quote_24h":"11382.7181",
            //         "price_change_percent_24h":"3.66264694",
            //         "highest_price_24h":"31225.12000000",
            //         "lowest_price_24h":"29792.81000000"
            //     }
            //
        ch <- this.ParseTicker(ticker, market)
            return nil
        
            }()
            return ch
        }
func  (this *coinlist) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "type":"spot",
    //         "last_price":"0.60990000",
    //         "lowest_ask":"0.61190000",
    //         "highest_bid":"0.60790000",
    //         "last_trade": {
    //             "price":"0.60000000",
    //             "volume":"2.0000",
    //             "imbalance":"198.0000",
    //             "logicalTime":"2023-10-22T23:02:25.000Z",
    //             "auctionCode":"MATIC-USD-2023-10-22T23:02:25.000Z"
    //          },
    //         "volume_base_24h":"34.0555",
    //         "volume_quote_24h":"19.9282",
    //         "price_change_percent_24h":"7.50925436",
    //         "highest_price_24h":"0.68560000",
    //         "lowest_price_24h":"0.55500000"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var lastTrade interface{} = this.SafeValue(ticker, "last_trade", map[string]interface{} {})
    var timestamp interface{} = this.Parse8601(this.SafeString(lastTrade, "logicalTime"))
    var bid interface{} = this.SafeString(ticker, "highest_bid")
    var ask interface{} = this.SafeString(ticker, "lowest_ask")
    var baseVolume interface{} = this.SafeString(ticker, "volume_base_24h")
    var quoteVolume interface{} = this.SafeString(ticker, "volume_quote_24h")
    var high interface{} = this.SafeString(ticker, "highest_price_24h")
    var low interface{} = this.SafeString(ticker, "lowest_price_24h")
    var close interface{} = this.SafeString(ticker, "last_price")
    var changePcnt interface{} = this.SafeString(ticker, "price_change_percent_24h")
    return this.SafeTicker(map[string]interface{} {
        "symbol": GetValue(market, "symbol"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "open": nil,
        "high": high,
        "low": low,
        "close": close,
        "bid": bid,
        "bidVolume": nil,
        "ask": ask,
        "askVolume": nil,
        "vwap": nil,
        "previousClose": nil,
        "change": nil,
        "percentage": changePcnt,
        "average": nil,
        "baseVolume": baseVolume,
        "quoteVolume": quoteVolume,
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name coinlist#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://trade-docs.coinlist.co/?javascript--nodejs#get-order-book-level-2
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return (default 100, max 200)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *coinlist) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes7198 := (<-this.LoadMarkets())
            PanicOnError(retRes7198)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetV1SymbolsSymbolBook(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "bids": [
            //             [ "30900.00000000", "0.0001" ],
            //             [ "30664.21000000", "0.0172" ],
            //             [ "30664.20000000", "0.0906" ],
            //         ],
            //         "asks": [
            //             [ "31349.99000000", "0.0003" ],
            //             [ "31350.00000000", "0.0023" ],
            //             [ "31359.33000000", "0.0583" ],
            //         ],
            //         "after_auction_code": "BTC-USDT-2023-10-23T18:40:51.000Z",
            //         "call_time": "2023-10-23T18:40:51.068Z",
            //         "logical_time": "2023-10-23T18:40:51.000Z"
            //     }
            //
            var logical_time interface{} = this.Parse8601(this.SafeString(response, "logical_time"))
            var orderbook interface{} = this.ParseOrderBook(response, symbol, logical_time)
            AddElementToObject(orderbook, "nonce", nil)
        
            ch <- orderbook
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinlist#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://trade-docs.coinlist.co/?javascript--nodejs#get-candles
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch entries for
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *coinlist) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes7628 := (<-this.LoadMarkets())
            PanicOnError(retRes7628)
            var market interface{} = this.Market(symbol)
            var granularity interface{} = this.SafeString(this.Timeframes, timeframe)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "granularity": granularity,
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_time", this.Iso8601(since))
                if IsTrue(!IsEqual(limit, nil)) {
                    var duration interface{} = Multiply(this.ParseTimeframe(timeframe), 1000)
                    AddElementToObject(request, "end_time", this.Iso8601(this.Sum(since, Multiply(duration, (limit)))))
                } else {
                    AddElementToObject(request, "end_time", this.Iso8601(this.Milliseconds()))
                }
            }
            var until interface{} = this.SafeInteger(params, "until")
            if IsTrue(!IsEqual(until, nil)) {
                params = this.Omit(params, []interface{}{"until"})
                AddElementToObject(request, "end_time", this.Iso8601(until))
            }
        
            response:= (<-this.PublicGetV1SymbolsSymbolCandles(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "candles": [
            //             [
            //                 "2023-10-17T15:00:00.000Z",
            //                 "28522.96000000",
            //                 "28522.96000000",
            //                 "28522.96000000",
            //                 "28522.96000000",
            //                 "0.1881",
            //                 null
            //             ],
            //             [
            //                 "2023-10-17T15:30:00.000Z",
            //                 "28582.64000000",
            //                 "28582.64000000",
            //                 "28582.64000000",
            //                 "28582.64000000",
            //                 "0.0050",
            //                 null
            //             ]
            //         ]
            //     }
            //
            var candles interface{} = this.SafeList(response, "candles", []interface{}{})
        
            ch <- this.ParseOHLCVs(candles, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *coinlist) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     [
    //         "2023-10-17T15:30:00.000Z",
    //         "28582.64000000",
    //         "28582.64000000",
    //         "28582.64000000",
    //         "28582.64000000",
    //         "0.0050",
    //         null
    //     ]
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.Parse8601(this.SafeString(ohlcv, 0)), this.SafeNumber(ohlcv, 1), this.SafeNumber(ohlcv, 2), this.SafeNumber(ohlcv, 3), this.SafeNumber(ohlcv, 4), this.SafeNumber(ohlcv, 5)}
}
/**
 * @method
 * @name coinlist#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://trade-docs.coinlist.co/?javascript--nodejs#list-auctions
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch (default 200, max 500)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch entries for
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *coinlist) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes8478 := (<-this.LoadMarkets())
            PanicOnError(retRes8478)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_time", this.Iso8601(since))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "count", mathMin(limit, 500))
            }
            var until interface{} = this.SafeInteger(params, "until")
            if IsTrue(!IsEqual(until, nil)) {
                params = this.Omit(params, []interface{}{"until"})
                AddElementToObject(request, "end_time", this.Iso8601(until))
            }
        
            response:= (<-this.PublicGetV1SymbolsSymbolAuctions(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "auctions": [
            //             {
            //                 "symbol":"BTC-USDT",
            //                 "auction_code":"BTC-USDT-2023-10-01T08:05:56.000Z",
            //                 "price":"27241.53000000",
            //                 "volume":"0.0052",
            //                 "imbalance":"-1.0983",
            //                 "logical_time":"2023-10-01T08:05:56.000Z",
            //                 "call_time":"2023-10-01T08:05:56.068Z"
            //             },
            //             {
            //                 "symbol":"BTC-USDT",
            //                 "auction_code":"BTC-USDT-2023-10-01T08:09:09.000Z",
            //                 "price":"27236.83000000",
            //                 "volume":"0.0283",
            //                 "imbalance":"-1.0754",
            //                 "logical_time":"2023-10-01T08:09:09.000Z",
            //                 "call_time":"2023-10-01T08:09:09.078Z"
            //             }
            //         ]
            //     }
            //
            var auctions interface{} = this.SafeList(response, "auctions", []interface{}{})
        
            ch <- this.ParseTrades(auctions, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *coinlist) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTrades
    //     {
    //         "symbol": "BTC-USDT",
    //         "auction_code": "BTC-USDT-2023-10-01T08:05:56.000Z",
    //         "price": "27241.53000000",
    //         "volume": "0.0052",
    //         "imbalance": "-1.0983",
    //         "logical_time": "2023-10-01T08:05:56.000Z",
    //         "call_time": "2023-10-01T08:05:56.068Z"
    //     }
    //
    // fetchMyTrades
    //     {
    //         "symbol": "ETH-USDT",
    //         "auction_code": "ETH-USDT-2023-10-20T13:22:14.000Z",
    //         "order_id": "83ed365f-497d-433b-96c1-9d08c1a12842",
    //         "quantity": "0.0008",
    //         "price": "1615.24000000",
    //         "fee": "0.005815",
    //         "fee_type": "taker",
    //         "fee_currency": "USDT",
    //         "logical_time": "2023-10-20T13:22:14.000Z"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(trade, "symbol")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = GetValue(market, "symbol")
    var id interface{} = this.SafeString(trade, "auction_code")
    var timestamp interface{} = this.Parse8601(this.SafeString(trade, "logical_time"))
    var priceString interface{} = this.SafeString(trade, "price")
    var amountString interface{} = this.SafeString2(trade, "volume", "quantity")
    var order interface{} = this.SafeString(trade, "order_id")
    var fee interface{} = nil
    var side interface{} = nil
    var feeCost interface{} = this.SafeString(trade, "fee")
    if IsTrue(!IsEqual(feeCost, nil)) {
        // only in fetchMyTrades
        var amountIsNegative interface{} = Precise.StringLt(amountString, "0")
        if IsTrue(amountIsNegative) {
            side = "sell"
            amountString = Precise.StringNeg(amountString)
        } else {
            side = "buy"
        }
        fee = map[string]interface{} {
            "cost": feeCost,
            "currency": this.SafeString(trade, "fee_currency"),
        }
    } else {
        var imbalance interface{} = this.SafeString(trade, "imbalance")
        if IsTrue(Precise.StringLt(imbalance, "0")) {
            side = "buy"
        } else {
            side = "sell"
        }
    }
    var takerOrMaker interface{} = this.SafeString(trade, "fee_type")
    return this.SafeTrade(map[string]interface{} {
        "id": id,
        "order": order,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "type": nil,
        "side": side,
        "takerOrMaker": takerOrMaker,
        "price": priceString,
        "amount": amountString,
        "cost": nil,
        "fee": fee,
        "info": trade,
    }, market)
}
/**
 * @method
 * @name coinlist#fetchTradingFees
 * @description fetch the trading fees for multiple markets
 * @see https://trade-docs.coinlist.co/?javascript--nodejs#list-fees
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
 */
func  (this *coinlist) FetchTradingFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes9778 := (<-this.LoadMarkets())
            PanicOnError(retRes9778)
        
            response:= (<-this.PrivateGetV1Fees(params))
            PanicOnError(response)
            //
            //     {
            //         fees_by_symbols: {
            //             'BTC-USD,BTC-USDT,ETH-USD,ETH-USDT,ETH-BTC,AAVE-USD,AAVE-USDT,ALGO-USD,ALGO-USDT,AVAX-USD,AVAX-USDT,BICO-USD,BICO-USDT,BLD-USD,BLD-USDT,BTRST-USDT,BZZ-USDT,CELO-USD,CELO-BTC,CFG-USD,CFG-USDT,CLV-USDT,COMP-USD,COMP-USDT,CYBER-USDT,CQT-USDT,CSPR-USD,CSPR-USDT,CUSD-USD,CUSD-USDC,DOGE-USD,DOGE-USDT,DOT-USD,DOT-USDT,EFI-USDT,FIL-USD,FIL-USDT,FLOW-USD,FLOW-USDT,GAL-USD,GAL-USDT,GODS-USDT,GOG-USDT,HMT-USD,HMT-USDT,ICP-USD,ICP-USDT,IMX-USD,IMX-USDT,LINK-USD,LINK-USDT,MATIC-USD,MATIC-USDT,MINA-USD,MINA-USDT,MKR-USD,MKR-USDT,NEON-USDT,NYM-USD,NYM-USDT,OCEAN-USD,OXT-USD,ROSE-USD,ROSE-USDT,SKL-USD,SKL-USDT,SOL-USD,SOL-USDT,STX-USDT,SUI-USDT,T-USDT,UNI-USD,UNI-USDT,USDT-USD,VEGA-USDT,WAXL-USD,WAXL-USDT,WBTC-BTC,WCFG-USD,WCFG-USDT,XTZ-USD': {
            //                 base: {
            //                     fees: { maker: '0', taker: '0.0045', liquidation: '0' },
            //                     floors: { maker: null, taker: null }
            //                 },
            //                 volume_tier_1: {
            //                     fees: { maker: '0', taker: '0.003', liquidation: '0' },
            //                     floors: { maker: null, taker: null }
            //                 },
            //                 volume_tier_2: {
            //                     fees: { maker: '0', taker: '0.0025', liquidation: '0' },
            //                     floors: { maker: null, taker: null }
            //                 },
            //                 volume_tier_3: {
            //                     fees: { maker: '0', taker: '0.002', liquidation: '0' },
            //                     floors: { maker: null, taker: null }
            //                 },
            //                 volume_tier_4: {
            //                     fees: { maker: '0', taker: '0.0018', liquidation: '0' },
            //                     floors: { maker: null, taker: null }
            //                 },
            //                 volume_tier_5: {
            //                     fees: { maker: '0', taker: '0.0018', liquidation: '0' },
            //                     floors: { maker: null, taker: null }
            //                 },
            //                 volume_tier_6: {
            //                     fees: { maker: '0', taker: '0.0016', liquidation: '0' },
            //                     floors: { maker: null, taker: null }
            //                 },
            //                 volume_tier_7: {
            //                     fees: { maker: '0', taker: '0.0013', liquidation: '0' },
            //                     floors: { maker: null, taker: null }
            //                 },
            //                 volume_tier_8: {
            //                     fees: { maker: '0', taker: '0.0012', liquidation: '0' },
            //                     floors: { maker: null, taker: null }
            //                 },
            //                 volume_tier_9: {
            //                     fees: { maker: '0', taker: '0.001', liquidation: '0' },
            //                     floors: { maker: null, taker: null }
            //                 }
            //                 volume_tier_10: {
            //                     fees: { maker: '0', taker: '0.0005', liquidation: '0' },
            //                     floors: { maker: null, taker: null }
            //                 },
            //                 volume_tier_11: {
            //                     fees: { maker: '0', taker: '0.0005', liquidation: '0' },
            //                     floors: { maker: null, taker: null }
            //                 },
            //             }
            //         }
            //     }
            //
            var fees interface{} = this.SafeValue(response, "fees_by_symbols", map[string]interface{} {})
            var result interface{} = map[string]interface{} {}
            var groupsOfSymbols interface{} = ObjectKeys(fees)
            for i := 0; IsLessThan(i, GetArrayLength(groupsOfSymbols)); i++ {
                var group interface{} = GetValue(groupsOfSymbols, i)
                var feeTiers interface{} = this.SafeValue(fees, group, map[string]interface{} {})
                var tiers interface{} = this.ParseFeeTiers(feeTiers)
                var firstTier interface{} = this.SafeValue(feeTiers, "base", map[string]interface{} {})
                var firstTierFees interface{} = this.SafeValue(firstTier, "fees", map[string]interface{} {})
                var ids interface{} = Split(group, ",")
                for j := 0; IsLessThan(j, GetArrayLength(ids)); j++ {
                    var id interface{} = GetValue(ids, j)
                    var market interface{} = this.SafeMarket(id)
                    var symbol interface{} = GetValue(market, "symbol")
                    var info interface{} = map[string]interface{} {}
                    AddElementToObject(info, group, feeTiers)
                    AddElementToObject(result, symbol, map[string]interface{} {
            "info": info,
            "symbol": symbol,
            "maker": this.SafeNumber(firstTierFees, "maker"),
            "taker": this.SafeNumber(firstTierFees, "taker"),
            "percentage": true,
            "tierBased": true,
            "tiers": tiers,
        })
                }
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *coinlist) ParseFeeTiers(feeTiers interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     base: {
    //         fees: { maker: '0', taker: '0.0045', liquidation: '0' },
    //         floors: { maker: null, taker: null }
    //     },
    //     volume_tier_1: {
    //         fees: { maker: '0', taker: '0.003', liquidation: '0' },
    //         floors: { maker: null, taker: null }
    //     },
    //     volume_tier_2: {
    //         fees: { maker: '0', taker: '0.0025', liquidation: '0' },
    //         floors: { maker: null, taker: null }
    //     },
    //     volume_tier_3: {
    //         fees: { maker: '0', taker: '0.002', liquidation: '0' },
    //         floors: { maker: null, taker: null }
    //     },
    //     volume_tier_4: {
    //         fees: { maker: '0', taker: '0.0018', liquidation: '0' },
    //         floors: { maker: null, taker: null }
    //     },
    //     volume_tier_5: {
    //         fees: { maker: '0', taker: '0.0018', liquidation: '0' },
    //         floors: { maker: null, taker: null }
    //     },
    //     volume_tier_6: {
    //         fees: { maker: '0', taker: '0.0016', liquidation: '0' },
    //         floors: { maker: null, taker: null }
    //     },
    //     volume_tier_7: {
    //         fees: { maker: '0', taker: '0.0013', liquidation: '0' },
    //         floors: { maker: null, taker: null }
    //     },
    //     volume_tier_8: {
    //         fees: { maker: '0', taker: '0.0012', liquidation: '0' },
    //         floors: { maker: null, taker: null }
    //     },
    //     volume_tier_9: {
    //         fees: { maker: '0', taker: '0.001', liquidation: '0' },
    //         floors: { maker: null, taker: null }
    //     }
    //     volume_tier_10: {
    //         fees: { maker: '0', taker: '0.0005', liquidation: '0' },
    //         floors: { maker: null, taker: null }
    //     },
    //     volume_tier_11: {
    //         fees: { maker: '0', taker: '0.0005', liquidation: '0' },
    //         floors: { maker: null, taker: null }
    //     },
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var takerFees interface{} = []interface{}{}
    var makerFees interface{} = []interface{}{}
    var keys interface{} = ObjectKeys(feeTiers)
    var keysLength interface{} =     GetArrayLength(keys)
    if IsTrue(IsGreaterThan(keysLength, 0)) {
        for i := 0; IsLessThan(i, keysLength); i++ {
            var key interface{} = GetValue(keys, i)
            var tier interface{} = this.SafeValue(feeTiers, key, map[string]interface{} {})
            var tierFees interface{} = this.SafeValue(tier, "fees", map[string]interface{} {})
            var taker interface{} = this.SafeString(tierFees, "taker")
            var maker interface{} = this.SafeString(tierFees, "maker")
            AppendToArray(&makerFees,[]interface{}{nil, this.ParseNumber(maker)})
            AppendToArray(&takerFees,[]interface{}{nil, this.ParseNumber(taker)})
        }
        takerFees = this.SortBy(takerFees, 1, true)
        makerFees = this.SortBy(makerFees, 1, true)
        var firstTier interface{} = this.SafeDict(takerFees, 0, []interface{}{})
        var exchangeFees interface{} = this.SafeDict(this, "fees", map[string]interface{} {})
        var exchangeFeesTrading interface{} = this.SafeDict(exchangeFees, "trading", map[string]interface{} {})
        var exchangeFeesTradingTiers interface{} = this.SafeDict(exchangeFeesTrading, "tiers", map[string]interface{} {})
        var exchangeFeesTradingTiersTaker interface{} = this.SafeList(exchangeFeesTradingTiers, "taker", []interface{}{})
        var exchangeFeesTradingTiersMaker interface{} = this.SafeList(exchangeFeesTradingTiers, "maker", []interface{}{})
        var exchangeFeesTradingTiersTakerLength interface{} =         GetArrayLength(exchangeFeesTradingTiersTaker)
        var firstTierLength interface{} =         GetArrayLength(firstTier)
        if IsTrue(IsTrue((IsEqual(keysLength, exchangeFeesTradingTiersTakerLength))) && IsTrue((IsGreaterThan(firstTierLength, 0)))) {
            for i := 0; IsLessThan(i, keysLength); i++ {
                AddElementToObject(GetValue(takerFees, i), 0, GetValue(GetValue(exchangeFeesTradingTiersTaker, i), 0))
                AddElementToObject(GetValue(makerFees, i), 0, GetValue(GetValue(exchangeFeesTradingTiersMaker, i), 0))
            }
        }
    }
    return map[string]interface{} {
        "maker": makerFees,
        "taker": takerFees,
    }
}
/**
 * @method
 * @name coinlist#fetchAccounts
 * @description fetch all the accounts associated with a profile
 * @see https://trade-docs.coinlist.co/?javascript--nodejs#list-accounts
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/#/?id=account-structure} indexed by the account type
 */
func  (this *coinlist) FetchAccounts(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes11628 := (<-this.LoadMarkets())
            PanicOnError(retRes11628)
        
            response:= (<-this.PrivateGetV1Accounts(params))
            PanicOnError(response)
            //
            //     {
            //         "accounts": [
            //             {
            //                 "trader_id": "b18507ce-7d55-4bf1-b12a-0ccca5b90936",
            //                 "name": "string"
            //             }
            //         ]
            //     }
            //
            var accounts interface{} = this.SafeValue(response, "accounts", []interface{}{})
        
            ch <- this.ParseAccounts(accounts, params)
            return nil
        
            }()
            return ch
        }
func  (this *coinlist) ParseAccount(account interface{}) interface{}  {
    //
    //     {
    //         "trader_id": "b18507ce-7d55-4bf1-b12a-0ccca5b90936",
    //         "name": "string"
    //     }
    //
    return map[string]interface{} {
        "id": this.SafeString(account, "trader_id"),
        "type": "trading",
        "code": nil,
        "info": account,
    }
}
/**
 * @method
 * @name coinlist#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://trade-docs.coinlist.co/?javascript--nodejs#list-balances
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *coinlist) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes12028 := (<-this.LoadMarkets())
            PanicOnError(retRes12028)
        
            response:= (<-this.PrivateGetV1Balances(params))
            PanicOnError(response)
        
            ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
func  (this *coinlist) ParseBalance(response interface{}) interface{}  {
    //
    //     {
    //         "asset_balances": {
    //             "BTC": "0.00308696",
    //             "ETH": "20.000000000000000000"
    //         },
    //         "asset_holds": {
    //             "BTC": "0.00000000",
    //             "ETH": "1.000000000000000000"
    //         },
    //         "net_liquidation_value_usd": "string"
    //     }
    //
    var result interface{} = map[string]interface{} {
        "info": response,
        "timestamp": nil,
        "datetime": nil,
    }
    var totalBalances interface{} = this.SafeValue(response, "asset_balances", map[string]interface{} {})
    var usedBalances interface{} = this.SafeValue(response, "asset_holds", map[string]interface{} {})
    var currencyIds interface{} = ObjectKeys(totalBalances)
    for i := 0; IsLessThan(i, GetArrayLength(currencyIds)); i++ {
        var currencyId interface{} = GetValue(currencyIds, i)
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        AddElementToObject(account, "total", this.SafeString(totalBalances, currencyId))
        AddElementToObject(account, "used", this.SafeString(usedBalances, currencyId, "0"))
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name coinlist#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://trade-docs.coinlist.co/?javascript--nodejs#list-fills
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve (default 200, max 500)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch entries for
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *coinlist) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes12538 := (<-this.LoadMarkets())
            PanicOnError(retRes12538)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_time", this.Iso8601(since))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "count", limit)
            }
            var until interface{} = this.SafeInteger(params, "until")
            if IsTrue(!IsEqual(until, nil)) {
                params = this.Omit(params, []interface{}{"until"})
                AddElementToObject(request, "end_time", this.Iso8601(until))
            }
        
            response:= (<-this.PrivateGetV1Fills(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "fills": [
            //             {
            //                 "symbol": "ETH-USDT",
            //                 "auction_code": "ETH-USDT-2023-10-20T13:16:30.000Z",
            //                 "order_id": "39911d5f-c789-4a7d-ad34-820a804d1da6",
            //                 "quantity": "-0.0009",
            //                 "price": "1608.83000000",
            //                 "fee": "0.006516",
            //                 "fee_type": "taker",
            //                 "fee_currency": "USDT",
            //                 "logical_time": "2023-10-20T13:16:30.000Z"
            //             },
            //             {
            //                 "symbol": "ETH-USDT",
            //                 "auction_code": "ETH-USDT-2023-10-20T13:22:14.000Z",
            //                 "order_id": "83ed365f-497d-433b-96c1-9d08c1a12842",
            //                 "quantity": "0.0008",
            //                 "price": "1615.24000000",
            //                 "fee": "0.005815",
            //                 "fee_type": "taker",
            //                 "fee_currency": "USDT",
            //                 "logical_time": "2023-10-20T13:22:14.000Z"
            //             },
            //         ]
            //     }
            //
            var fills interface{} = this.SafeList(response, "fills", []interface{}{})
        
            ch <- this.ParseTrades(fills, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinlist#fetchOrderTrades
 * @description fetch all the trades made from a single order
 * @see https://trade-docs.coinlist.co/?javascript--nodejs#list-fills
 * @param {string} id order id
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *coinlist) FetchOrderTrades(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "order_id": id,
            }
        
                retRes132015 :=  (<-this.FetchMyTrades(symbol, since, limit, this.Extend(request, params)))
                PanicOnError(retRes132015)
                ch <- retRes132015
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinlist#fetchOrders
 * @description fetches information on multiple orders made by the user
 * @see https://trade-docs.coinlist.co/?javascript--nodejs#list-orders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve (default 200, max 500)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch entries for
 * @param {string|string[]} [params.status] the status of the order - 'accepted', 'done', 'canceled', 'rejected', 'pending' (default [ 'accepted', 'done', 'canceled', 'rejected', 'pending' ])
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinlist) FetchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes13378 := (<-this.LoadMarkets())
            PanicOnError(retRes13378)
            var status interface{} = this.SafeString(params, "status")
            if IsTrue(IsEqual(status, nil)) {
                status = []interface{}{"accepted", "done", "canceled", "rejected", "pending"}
            }
            var request interface{} = map[string]interface{} {
                "status": status,
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_time", this.Iso8601(since))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "count", limit)
            }
            var until interface{} = this.SafeInteger(params, "until")
            if IsTrue(!IsEqual(until, nil)) {
                params = this.Omit(params, []interface{}{"until"})
                AddElementToObject(request, "end_time", this.Iso8601(until))
            }
        
            response:= (<-this.PrivateGetV1Orders(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "orders":[
            //             {
            //                 "order_id":"913ea6e7-9fc9-43fb-9db1-f195d3baa93f",
            //                 "price":"35800.00000000",
            //                 "stop_price":null,
            //                 "cost":"0.00000000",
            //                 "fill_fees":"0.00000000",
            //                 "trader_id":"9c6f737e-a829-4843-87b1-b1ce86f2853b",
            //                 "status":"accepted",
            //                 "epoch_timestamp":"2023-10-26T08:20:56.307Z",
            //                 "origin":"web",
            //                 "self_trade_prevention":null,
            //                 "client_id":null,
            //                 "created_at":"2023-10-26T08:20:56.307Z",
            //                 "symbol":"BTC-USDT",
            //                 "size":"0.0003",
            //                 "side":"sell",
            //                 "type":"limit",
            //                 "post_only":false,
            //                 "size_filled":"0.0000"
            //             }
            //         ]
            //     }
            //
            var orders interface{} = this.SafeList(response, "orders", []interface{}{})
        
            ch <- this.ParseOrders(orders, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinlist#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://trade-docs.coinlist.co/?javascript--nodejs#get-specific-order-by-id
 * @param {int|string} id order id
 * @param {string} symbol not used by coinlist fetchOrder ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinlist) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes14038 := (<-this.LoadMarkets())
            PanicOnError(retRes14038)
            var request interface{} = map[string]interface{} {
                "order_id": id,
            }
        
            response:= (<-this.PrivateGetV1OrdersOrderId(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "order_id": "93101167-9065-4b9c-b98b-5d789a3ed9fe",
            //         "client_id": "string",
            //         "symbol": "string",
            //         "type": "market",
            //         "side": "buy",
            //         "size": "string",
            //         "price": "string",
            //         "stop_price": "string",
            //         "stop_trigger": "last",
            //         "self_trade_prevention": "keep-newest",
            //         "average_fill_price": "string",
            //         "fill_fees": "string",
            //         "size_filled": "string",
            //         "created_at": "2019-08-24T14:15:22Z",
            //         "epoch_timestamp": "2019-08-24T14:15:22Z",
            //         "post_only": true,
            //         "peg_price_type": "trailing-stop",
            //         "peg_offset_value": "string",
            //         "origin": "web",
            //         "status": "pending"
            //     }
            //
        ch <- this.ParseOrder(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinlist#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://trade-docs.coinlist.co/?javascript--nodejs#list-orders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of open order structures to retrieve (default 200, max 500)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch entries for
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinlist) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes14488 := (<-this.LoadMarkets())
            PanicOnError(retRes14488)
            var request interface{} = map[string]interface{} {
                "status": "accepted",
            }
        
            ch <- this.FetchOrders(symbol, since, limit, this.Extend(request, params))
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinlist#fetchClosedOrders
 * @description fetches information on multiple closed orders made by the user
 * @see https://trade-docs.coinlist.co/?javascript--nodejs#list-orders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of closed order structures to retrieve (default 200, max 500)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch entries for
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinlist) FetchClosedOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes14688 := (<-this.LoadMarkets())
            PanicOnError(retRes14688)
            var request interface{} = map[string]interface{} {
                "status": "done",
            }
        
            ch <- this.FetchOrders(symbol, since, limit, this.Extend(request, params))
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinlist#fetchCanceledOrders
 * @description fetches information on multiple canceled orders made by the user
 * @see https://trade-docs.coinlist.co/?javascript--nodejs#list-orders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of canceled order structures to retrieve (default 200, max 500)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch entries for
 * @returns {object} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinlist) FetchCanceledOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes14888 := (<-this.LoadMarkets())
            PanicOnError(retRes14888)
            var request interface{} = map[string]interface{} {
                "status": "canceled",
            }
        
            ch <- this.FetchOrders(symbol, since, limit, this.Extend(request, params))
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinlist#cancelAllOrders
 * @description cancel open orders of market
 * @see https://trade-docs.coinlist.co/?javascript--nodejs#cancel-all-orders
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinlist) CancelAllOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes15058 := (<-this.LoadMarkets())
            PanicOnError(retRes15058)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
        
            response:= (<-this.PrivateDeleteV1Orders(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "message": "Order cancellation request received.",
            //         "timestamp": "2023-10-26T10:29:28.652Z"
            //     }
            //
            var orders interface{} = []interface{}{response}
        
            ch <- this.ParseOrders(orders, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinlist#cancelOrder
 * @description cancels an open order
 * @see https://trade-docs.coinlist.co/?javascript--nodejs#cancel-specific-order-by-id
 * @param {string} id order id
 * @param {string} symbol not used by coinlist cancelOrder ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinlist) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes15348 := (<-this.LoadMarkets())
            PanicOnError(retRes15348)
            var request interface{} = map[string]interface{} {
                "order_id": id,
            }
        
            response:= (<-this.PrivateDeleteV1OrdersOrderId(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "message": "Cancel order request received.",
            //         "order_id": "d36e7588-6525-485c-b768-8ad8b3f745f9",
            //         "timestamp": "2023-10-26T14:36:37.559Z"
            //     }
            //
        ch <- this.ParseOrder(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinlist#cancelOrders
 * @description cancel multiple orders
 * @see https://trade-docs.coinlist.co/?javascript--nodejs#cancel-specific-orders
 * @param {string[]} ids order ids
 * @param {string} symbol not used by coinlist cancelOrders ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinlist) CancelOrders(ids interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes15608 := (<-this.LoadMarkets())
            PanicOnError(retRes15608)
            params = ids
        
            response:= (<-this.PrivateDeleteV1OrdersBulk(params))
            PanicOnError(response)
            //
            //    {
            //        "message": "Cancel order requests received.",
            //        "order_ids": [
            //            "ff132955-43bc-4fe5-9d9c-5ba226cc89a0"
            //        ],
            //        "timestamp": "2024-06-01T02:32:30.305Z"
            //    }
            //
            var orderIds interface{} = this.SafeList(response, "order_ids", []interface{}{})
            var orders interface{} = []interface{}{}
            var datetime interface{} = this.SafeString(response, "timestamp")
            for i := 0; IsLessThan(i, GetArrayLength(orderIds)); i++ {
                AppendToArray(&orders,this.SafeOrder(map[string]interface{} {
                    "info": GetValue(orderIds, i),
                    "id": GetValue(orderIds, i),
                    "lastUpdateTimestamp": this.Parse8601(datetime),
                }))
            }
        
            ch <- orders
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinlist#createOrder
 * @description create a trade order
 * @see https://trade-docs.coinlist.co/?javascript--nodejs#create-new-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit' or 'stop_market' or 'stop_limit' or 'take_market' or 'take_limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {bool} [params.postOnly] if true, the order will only be posted to the order book and not executed immediately (default false)
 * @param {float} [params.triggerPrice] only for the 'stop_market', 'stop_limit', 'take_market' or 'take_limit' orders (the price at which an order is triggered)
 * @param {string} [params.clientOrderId] client order id (default undefined)
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinlist) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes16028 := (<-this.LoadMarkets())
            PanicOnError(retRes16028)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "type": typeVar,
                "side": side,
                "size": this.AmountToPrecision(symbol, amount),
            }
            var isMarket interface{} = false
            if IsTrue(IsTrue(IsTrue((IsEqual(typeVar, "limit"))) || IsTrue((IsEqual(typeVar, "stop_limit")))) || IsTrue((IsEqual(typeVar, "take_limit")))) {
                if IsTrue(IsEqual(price, nil)) {
                    panic(ArgumentsRequired(Add(Add(Add(this.Id, " createOrder() requires a price argument for a "), typeVar), " order")))
                }
                AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
            } else {
                isMarket = true
            }
            var postOnly interface{} = nil
            postOnlyparamsVariable := this.HandlePostOnly(isMarket, false, params);
            postOnly = GetValue(postOnlyparamsVariable,0);
            params = GetValue(postOnlyparamsVariable,1)
            if IsTrue(postOnly) {
                AddElementToObject(request, "post_only", true)
            }
            var triggerPrice interface{} = this.SafeNumberN(params, []interface{}{"triggerPrice", "trigger_price", "stopPrice", "stop_price"})
            if IsTrue(!IsEqual(triggerPrice, nil)) {
                params = this.Omit(params, []interface{}{"triggerPrice", "trigger_price", "stopPrice"})
                AddElementToObject(request, "stop_price", this.PriceToPrecision(symbol, triggerPrice))
                if IsTrue(IsEqual(typeVar, "market")) {
                    AddElementToObject(request, "type", "stop_market")
                } else if IsTrue(IsEqual(typeVar, "limit")) {
                    AddElementToObject(request, "type", "stop_limit")
                }
            } else if IsTrue(IsTrue(IsTrue(IsTrue((IsEqual(typeVar, "stop_market"))) || IsTrue((IsEqual(typeVar, "stop_limit")))) || IsTrue((IsEqual(typeVar, "take_market")))) || IsTrue((IsEqual(typeVar, "take_limit")))) {
                panic(ArgumentsRequired(Add(this.Id, " createOrder() requires a triggerPrice parameter for stop-loss and take-profit orders")))
            }
            var clientOrderId interface{} = this.SafeString2(params, "clientOrderId", "client_id")
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                AddElementToObject(request, "client_id", clientOrderId)
                params = this.Omit(params, []interface{}{"clientOrderId", "client_id"})
            }
        
            response:= (<-this.PrivatePostV1Orders(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "message": "New order request received.",
            //         "order": {
            //             "symbol": "BTC-USDT",
            //             "type": "market",
            //             "side": "sell",
            //             "size": "0.0003",
            //             "order_id": "cad67c0f-9aec-4ac8-ac03-aaf5db299ff7",
            //             "trader_id": "9c6f737e-a829-4843-87b1-b1ce86f2853b"
            //         },
            //         "timestamp": "2023-10-26T11:30:55.376Z"
            //     }
            //
            var order interface{} = this.SafeDict(response, "order", map[string]interface{} {})
        
            ch <- this.ParseOrder(order, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinlist#editOrder
 * @description create a trade order
 * @see https://trade-docs.coinlist.co/?javascript--nodejs#modify-existing-order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit' or 'stop_market' or 'stop_limit' or 'take_market' or 'take_limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinlist) EditOrder(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    amount := GetArg(optionalArgs, 0, nil)
            _ = amount
            price := GetArg(optionalArgs, 1, nil)
            _ = price
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes16758 := (<-this.LoadMarkets())
            PanicOnError(retRes16758)
            if IsTrue(IsEqual(amount, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " editOrder() requires an amount argument")))
            }
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "order_id": id,
                "type": typeVar,
                "side": side,
                "size": this.AmountToPrecision(symbol, amount),
            }
            if IsTrue(!IsEqual(price, nil)) {
                AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
            }
        
            response:= (<-this.PrivatePatchV1OrdersOrderId(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
func  (this *coinlist) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchOrder
    //     {
    //         "order_id": "913ea6e7-9fc9-43fb-9db1-f195d3baa93f",
    //         "price": "35800.00000000",
    //         "stop_price":null,
    //         "cost": "0.00000000",
    //         "fill_fees": "0.00000000",
    //         "trader_id": "9c6f737e-a829-4843-87b1-b1ce86f2853b",
    //         "status": "canceled",
    //         "epoch_timestamp": "2023-10-26T08:20:56.307Z",
    //         "origin": "web",
    //         "self_trade_prevention":null,
    //         "client_id":null,
    //         "symbol": "BTC-USDT",
    //         "size": "0.0003",
    //         "side": "sell",
    //         "type": "limit",
    //         "post_only":false,
    //         "size_filled": "0.0000"
    //     }
    //
    // fetchOrders
    //     {
    //         "order_id":"913ea6e7-9fc9-43fb-9db1-f195d3baa93f",
    //         "price":"35800.00000000",
    //         "stop_price":null,
    //         "cost":"0.00000000",
    //         "fill_fees":"0.00000000",
    //         "trader_id":"9c6f737e-a829-4843-87b1-b1ce86f2853b",
    //         "status":"accepted",
    //         "epoch_timestamp":"2023-10-26T08:20:56.307Z",
    //         "origin":"web",
    //         "self_trade_prevention":null,
    //         "client_id":null,
    //         "created_at":"2023-10-26T08:20:56.307Z",
    //         "symbol":"BTC-USDT",
    //         "size":"0.0003",
    //         "side":"sell",
    //         "type":"limit",
    //         "post_only":false,
    //         "size_filled":"0.0000"
    //     }
    //
    // createOrder
    //     {
    //         "symbol": "BTC-USDT",
    //         "type": "market",
    //         "side": "sell",
    //         "size": "0.0003",
    //         "order_id": "cad67c0f-9aec-4ac8-ac03-aaf5db299ff7",
    //         "trader_id": "9c6f737e-a829-4843-87b1-b1ce86f2853b"
    //     },
    //
    // cancelOrder
    //     {
    //         "message": "Cancel order request received.",
    //         "order_id": "d36e7588-6525-485c-b768-8ad8b3f745f9",
    //         "timestamp": "2023-10-26T14:36:37.559Z"
    //     }
    //
    // cancelOrders
    //     {
    //         "message": "Order cancellation request received.",
    //         "timestamp": "2023-10-26T10:29:28.652Z"
    //     }
    //
    // cancelAllOrders
    //     {
    //         "message": "Order cancellation request received.",
    //         "timestamp": "2023-10-26T10:29:28.652Z"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeString(order, "order_id")
    var marketId interface{} = this.SafeString(order, "symbol")
    market = this.SafeMarket(marketId, market)
    var clientOrderId interface{} = this.SafeString(order, "client_id")
    var timestampString interface{} = this.SafeString2(order, "created_at", "epoch_timestamp")
    if IsTrue(IsEqual(timestampString, nil)) {
        timestampString = this.SafeString(order, "timestamp")
    }
    var timestamp interface{} = this.Parse8601(timestampString)
    var status interface{} = this.ParseOrderStatus(this.SafeString(order, "status"))
    var typeVar interface{} = this.ParseOrderType(this.SafeString(order, "type"))
    var side interface{} = this.SafeString(order, "side")
    var price interface{} = this.SafeString(order, "price")
    var triggerPrice interface{} = this.SafeString(order, "stop_price")
    var average interface{} = this.SafeString(order, "average_fill_price") // from documentation
    var amount interface{} = this.SafeString(order, "size")
    var filled interface{} = this.SafeString(order, "size_filled")
    var feeCost interface{} = this.SafeString(order, "fill_fees")
    var postOnly interface{} = this.SafeValue(order, "post_only")
    var fee interface{} = nil
    if IsTrue(!IsEqual(feeCost, nil)) {
        fee = map[string]interface{} {
            "currency": GetValue(market, "quote"),
            "cost": feeCost,
            "rate": nil,
        }
    }
    return this.SafeOrder(map[string]interface{} {
        "id": id,
        "clientOrderId": clientOrderId,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "status": status,
        "symbol": GetValue(market, "symbol"),
        "type": typeVar,
        "timeInForce": "GTC",
        "side": side,
        "price": price,
        "triggerPrice": triggerPrice,
        "average": average,
        "amount": amount,
        "cost": nil,
        "filled": filled,
        "remaining": nil,
        "fee": fee,
        "trades": nil,
        "info": order,
        "postOnly": postOnly,
    }, market)
}
func  (this *coinlist) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "pending": "open",
        "accepted": "open",
        "rejected": "rejected",
        "done": "closed",
        "canceled": "canceled",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *coinlist) ParseOrderType(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "market": "market",
        "limit": "limit",
        "stop_market": "market",
        "stop_limit": "limit",
        "take_market": "market",
        "take_limit": "limit",
    }
    return this.SafeString(statuses, status, status)
}
/**
 * @method
 * @name coinlist#transfer
 * @description transfer currency internally between wallets on the same account
 * @see https://trade-docs.coinlist.co/?javascript--nodejs#transfer-funds-between-entities
 * @see https://trade-docs.coinlist.co/?javascript--nodejs#transfer-funds-from-wallet-to-pro
 * @see https://trade-docs.coinlist.co/?javascript--nodejs#transfer-funds-from-pro-to-wallet
 * @param {string} code unified currency code
 * @param {float} amount amount to transfer
 * @param {string} fromAccount account to transfer from
 * @param {string} toAccount account to transfer to
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func  (this *coinlist) Transfer(code interface{}, amount interface{}, fromAccount interface{}, toAccount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes18578 := (<-this.LoadMarkets())
            PanicOnError(retRes18578)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "asset": GetValue(currency, "id"),
                "amount": this.CurrencyToPrecision(code, amount),
            }
            var accountsByType interface{} = this.SafeValue(this.Options, "accountsByType", map[string]interface{} {})
            var fromAcc interface{} = this.SafeString(accountsByType, fromAccount, fromAccount)
            var toAcc interface{} = this.SafeString(accountsByType, toAccount, toAccount)
            var response interface{} = nil
            if IsTrue(IsTrue((IsEqual(fromAcc, "funding"))) && IsTrue((IsEqual(toAcc, "trading")))) {
                
        response = (<-this.PrivatePostV1TransfersFromWallet(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(IsTrue((IsEqual(fromAcc, "trading"))) && IsTrue((IsEqual(toAcc, "funding")))) {
                
        response = (<-this.PrivatePostV1TransfersToWallet(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                AddElementToObject(request, "from_trader_id", fromAcc)
                AddElementToObject(request, "to_trader_id", toAcc)
                
        response = (<-this.PrivatePostV1TransfersInternalTransfer(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            // privatePostV1TransfersInternalTransfer
            //     {
            //         "from_trader_id": "1f494ace-b3ed-4324-b202-55526ed06381",
            //         "to_trader_id": "d32c7a40-cc24-44b0-8597-f9edb3da989f",
            //         "asset": "string",
            //         "amount": "string"
            //     }
            //
            // privatePostV1TransfersFromWallet, privatePostV1TransfersToWallet
            //     {
            //         "transfer_id": "bb34f528-d9b0-47c6-b11f-4d4840b86ee3"
            //     }
            //
            var transfer interface{} = this.ParseTransfer(response, currency)
        
            ch <- transfer
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinlist#fetchTransfers
 * @description fetch a history of internal transfers between CoinList.co and CoinList Pro. It does not return external deposits or withdrawals
 * @see https://trade-docs.coinlist.co/?javascript--nodejs#list-transfers
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch transfers for
 * @param {int} [limit] the maximum number of transfer structures to retrieve (default 200, max 500)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch entries for
 * @returns {object[]} a list of [transfer structures]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func  (this *coinlist) FetchTransfers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes19078 := (<-this.LoadMarkets())
            PanicOnError(retRes19078)
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
            }
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_time", this.Iso8601(since))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "count", limit)
            }
            var until interface{} = this.SafeInteger(params, "until")
            if IsTrue(!IsEqual(until, nil)) {
                params = this.Omit(params, []interface{}{"until"})
                AddElementToObject(request, "end_time", this.Iso8601(until))
            }
        
            response:= (<-this.PrivateGetV1Transfers(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "transfers": [
            //             {
            //                 "transfer_id": "2c02db25-e8f2-4271-8222-e110bfd0aa2a",
            //                 "created_at": "2023-10-20T13:15:37.000Z",
            //                 "confirmed_at": "2023-10-20T13:15:37.000Z",
            //                 "asset": "ETH",
            //                 "amount": "0.010000000000000000",
            //                 "status": "confirmed"
            //             },
            //             {
            //                 "transfer_id": "890694db-156c-4e93-a3ef-4db61685aca7",
            //                 "created_at": "2023-10-26T14:32:22.000Z",
            //                 "confirmed_at": "2023-10-26T14:32:22.000Z",
            //                 "asset": "USD",
            //                 "amount": "-3.00",
            //                 "status": "confirmed"
            //             }
            //         ]
            //     }
            //
            var transfers interface{} = this.SafeList(response, "transfers", []interface{}{})
        
            ch <- this.ParseTransfers(transfers, currency, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *coinlist) ParseTransfer(transfer interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTransfers
    //     {
    //         "transfer_id": "890694db-156c-4e93-a3ef-4db61685aca7",
    //         "created_at": "2023-10-26T14:32:22.000Z",
    //         "confirmed_at": "2023-10-26T14:32:22.000Z",
    //         "asset": "USD",
    //         "amount": "-3.00",
    //         "status": "confirmed"
    //     }
    //
    // transfer - privatePostV1TransfersInternalTransfer
    //     {
    //         "from_trader_id": "1f494ace-b3ed-4324-b202-55526ed06381",
    //         "to_trader_id": "d32c7a40-cc24-44b0-8597-f9edb3da989f",
    //         "asset": "string",
    //         "amount": "string"
    //     }
    //
    // transfer - privatePostV1TransfersFromWallet, privatePostV1TransfersToWallet
    //     {
    //         "transfer_id": "bb34f528-d9b0-47c6-b11f-4d4840b86ee3"
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var currencyId interface{} = this.SafeString(transfer, "asset")
    var confirmedAt interface{} = this.SafeString(transfer, "confirmed_at")
    var timetstamp interface{} = this.Parse8601(confirmedAt)
    var status interface{} = this.SafeString(transfer, "status")
    var amountString interface{} = this.SafeString(transfer, "amount")
    var fromAccount interface{} = nil
    var toAccount interface{} = nil
    var amount interface{} = nil
    if IsTrue(!IsEqual(amountString, nil)) {
        var amountIsNegative interface{} = Precise.StringLt(amountString, "0")
        if IsTrue(amountIsNegative) {
            fromAccount = "trading"
            toAccount = "funding"
            amountString = Precise.StringNeg(amountString)
        } else {
            fromAccount = "funding"
            toAccount = "trading"
        }
        amount = this.ParseNumber(amountString)
    }
    return map[string]interface{} {
        "info": transfer,
        "id": this.SafeString(transfer, "transfer_id"),
        "timestamp": timetstamp,
        "datetime": this.Iso8601(timetstamp),
        "currency": this.SafeCurrencyCode(currencyId, currency),
        "amount": amount,
        "fromAccount": fromAccount,
        "toAccount": toAccount,
        "status": this.ParseTransferStatus(status),
    }
}
func  (this *coinlist) ParseTransferStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "confirmed": "ok",
    }
    return this.SafeString(statuses, status, status)
}
/**
 * @method
 * @name coinlist#fetchDepositsWithdrawals
 * @description fetch history of deposits and withdrawals from external wallets and between CoinList Pro trading account and CoinList wallet
 * @see https://trade-docs.coinlist.co/?javascript--nodejs#get-coinlist-wallet-ledger
 * @param {string} [code] unified currency code for the currency of the deposit/withdrawals
 * @param {int} [since] timestamp in ms of the earliest deposit/withdrawal
 * @param {int} [limit] max number of deposit/withdrawals to return (default 200, max 500)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *coinlist) FetchDepositsWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(code, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchDepositsWithdrawals() requires a code argument")))
            }
            var traderId interface{} = this.SafeString2(params, "trader_id", "traderId")
            if IsTrue(IsEqual(traderId, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchDepositsWithdrawals() requires a traderId argument in the params")))
            }
        
            retRes20358 := (<-this.LoadMarkets())
            PanicOnError(retRes20358)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "asset": GetValue(currency, "id"),
                "trader_id": traderId,
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "count", limit)
            }
            params = this.Omit(params, []interface{}{"trader_id", "traderId"})
        
            response:= (<-this.PrivateGetV1AccountsTraderIdWalletLedger(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "id": "2c02db25-e8f2-4271-8222-e110bfd0aa2a",
            //             "asset": "ETH",
            //             "amount": "0.01",
            //             "created_at": "2023-10-20T13:15:37.000Z",
            //             "description": "Transfer to CoinList Pro",
            //             "type": "PRO_TRANSFER",
            //             "delta": "-0.010000000000000000"
            //         },
            //         {
            //             "id": "7139384d-6cec-479e-a19c-d498647ccb47",
            //             "asset": "ETH",
            //             "amount": "0.01",
            //             "created_at": "2023-10-20T13:10:55.000Z",
            //             "description": "CRYPTO_DEPOSIT",
            //             "type": "CRYPTO_DEPOSIT",
            //             "delta": "0.010000000000000000"
            //         },
            //
            //         ...
            //
            //         {
            //             "id": "91bbbb22-5ede-4e9a-81ef-3f9318aa83d2",
            //             "asset": "USDT",
            //             "amount": "4.169654",
            //             "withdrawal_fee_amount": "8.830346000000000000",
            //             "created_at": "2023-10-27T16:14:11.000Z",
            //             "description": "CRYPTO_WITHDRAWAL",
            //             "type": "CRYPTO_WITHDRAWAL",
            //             "delta": "-4.169654000000000000"
            //         },
            //         {
            //             "id": "830261bd-cda9-401f-b6df-105f4da3b37c",
            //             "asset": "USDT",
            //             "amount": "13",
            //             "created_at": "2023-10-27T14:52:05.000Z",
            //             "description": "Transfer from CoinList Pro",
            //             "type": "PRO_TRANSFER",
            //             "delta": "13.000000000000000000"
            //         }
            //     ]
            //
            // coinlist returns both internal transfers and blockchain transactions
        ch <- this.ParseTransactions(response, currency, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinlist#withdraw
 * @description request a withdrawal from CoinList wallet. (Disabled by default. Contact CoinList to apply for an exception.)
 * @see https://trade-docs.coinlist.co/?javascript--nodejs#request-withdrawal-from-wallet
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *coinlist) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes21078 := (<-this.LoadMarkets())
            PanicOnError(retRes21078)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "asset": GetValue(currency, "id"),
                "amount": this.CurrencyToPrecision(code, amount),
                "destination_address": address,
            }
        
            response:= (<-this.PrivatePostV1TransfersWithdrawalRequest(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "transfer_id": "d4a2d8dd-7def-4545-a062-761683b9aa05"
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseTransaction(data, currency)
            return nil
        
            }()
            return ch
        }
func  (this *coinlist) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    // withdraw
    //
    //     {
    //         "transfer_id": "d4a2d8dd-7def-4545-a062-761683b9aa05"
    //     }
    //
    // fetchDepositsWithdrawals
    //     {
    //         "id": "91bbbb22-5ede-4e9a-81ef-3f9318aa83d2",
    //         "asset": "USDT",
    //         "amount": "4.169654",
    //         "withdrawal_fee_amount": "8.830346000000000000",
    //         "created_at": "2023-10-27T16:14:11.000Z",
    //         "description": "CRYPTO_WITHDRAWAL",
    //         "type": "CRYPTO_WITHDRAWAL",
    //         "delta": "-4.169654000000000000"
    //     },
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var currencyId interface{} = this.SafeString(transaction, "asset")
    var code interface{} = this.SafeCurrencyCode(currencyId, currency)
    var id interface{} = this.SafeString2(transaction, "id", "transfer_id")
    var amount interface{} = this.SafeNumber(transaction, "amount")
    var timestamp interface{} = this.Parse8601(this.SafeString(transaction, "created_at"))
    var typeVar interface{} = this.SafeString(transaction, "type", nil)
    if IsTrue(IsEqual(typeVar, nil)) {
        typeVar = "withdrawal" // undefined only in withdraw() method
    } else {
        typeVar = this.ParseTransactionType(typeVar)
    }
    var fee interface{} = nil
    var feeCost interface{} = this.SafeString(transaction, "withdrawal_fee_amount")
    if IsTrue(!IsEqual(feeCost, nil)) {
        fee = map[string]interface{} {
            "cost": feeCost,
            "currency": code,
        }
    }
    return map[string]interface{} {
        "info": transaction,
        "id": id,
        "txid": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "network": nil,
        "addressFrom": nil,
        "address": nil,
        "addressTo": nil,
        "tagFrom": nil,
        "tag": nil,
        "tagTo": nil,
        "type": typeVar,
        "amount": amount,
        "currency": code,
        "status": nil,
        "updated": nil,
        "fee": fee,
        "comment": this.SafeString(transaction, "description"),
        "internal": nil,
    }
}
func  (this *coinlist) ParseTransactionType(typeVar interface{}) interface{}  {
    var types interface{} = map[string]interface{} {
        "CRYPTO_DEPOSIT": "deposit",
        "CRYPTO_WITHDRAWAL": "withdrawal",
        "PRO_TRANSFER": "transfer",
    }
    return this.SafeString(types, typeVar, typeVar)
}
/**
 * @method
 * @name coinlist#fetchLedger
 * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
 * @see https://trade-docs.coinlist.co/?javascript--nodejs#get-account-history
 * @param {string} [code] unified currency code, default is undefined
 * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
 * @param {int} [limit] max number of ledger entries to return (default 200, max 500)
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch entries for
 * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger}
 */
func  (this *coinlist) FetchLedger(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var traderId interface{} = this.SafeString2(params, "trader_id", "traderId")
            if IsTrue(IsEqual(traderId, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchLedger() requires a traderId argument in the params")))
            }
        
            retRes22128 := (<-this.LoadMarkets())
            PanicOnError(retRes22128)
            var request interface{} = map[string]interface{} {
                "trader_id": traderId,
            }
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_time", this.Iso8601(since))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "count", limit)
            }
            var until interface{} = this.SafeInteger(params, "until")
            if IsTrue(!IsEqual(until, nil)) {
                params = this.Omit(params, []interface{}{"until"})
                AddElementToObject(request, "end_time", this.Iso8601(until))
            }
            params = this.Omit(params, []interface{}{"trader_id", "traderId"})
        
            response:= (<-this.PrivateGetV1AccountsTraderIdLedger(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "transactions": [
            //             {
            //                 "transaction_id": "0288634e-49bd-494d-b04a-18fd1832d394",
            //                 "transaction_type": "XFER",
            //                 "type": "deposit",
            //                 "asset": "ETH",
            //                 "symbol": null,
            //                 "amount": "0.010000000000000000",
            //                 "details": null,
            //                 "created_at": "2023-10-20T13:15:39.443Z"
            //             },
            //             {
            //                 "transaction_id": "47a45928-abcd-4c12-8bd6-587c3028025f",
            //                 "transaction_type": "SWAP",
            //                 "type": "atomic token swap",
            //                 "asset": "USDT",
            //                 "symbol": "ETH-USDT",
            //                 "amount": "1.447947",
            //                 "details": null,
            //                 "created_at": "2023-10-20T13:16:30.373Z"
            //             },
            //             {
            //                 "transaction_id": "1ffe3a54-916e-41f0-b957-3a01309eb009",
            //                 "transaction_type": "FEE",
            //                 "type": "fee",
            //                 "asset": "USDT",
            //                 "symbol": "ETH-USDT",
            //                 "amount": "-0.006516",
            //                 "details": {
            //                     "fee_details": [
            //                         {
            //                             "insurance_fee": "0",
            //                             "order_id": "39911d5f-c789-4a7d-ad34-820a804d1da6",
            //                             "fee_type": "taker",
            //                             "fee_currency": "USDT"
            //                         }
            //                     ]
            //                 },
            //                 "created_at": "2023-10-20T13:16:30.373Z"
            //             },
            //             {
            //                 "transaction_id": "3930e8a3-2218-481f-8c3c-2219287e205e",
            //                 "transaction_type": "SWAP",
            //                 "type": "atomic token swap",
            //                 "asset": "ETH",
            //                 "symbol": "ETH-USDT",
            //                 "amount": "-0.000900000000000000",
            //                 "details": null,
            //                 "created_at": "2023-10-20T13:16:30.373Z"
            //             },
            //             {
            //                 "transaction_id": "a6c65cb3-95d0-44e2-8202-f70581d6e55c",
            //                 "transaction_type": "XFER",
            //                 "type": "withdrawal",
            //                 "asset": "USD",
            //                 "symbol": null,
            //                 "amount": "-3.00",
            //                 "details": null,
            //                 "created_at": "2023-10-26T14:32:24.887Z"
            //             }
            //         ]
            //     }
            //
            var ledger interface{} = this.SafeValue(response, "transactions", []interface{}{})
        
            ch <- this.ParseLedger(ledger, currency, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *coinlist) ParseLedgerEntry(item interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // deposit transaction from wallet (funding) to pro (trading)
    //     {
    //         "transaction_id": "0288634e-49bd-494d-b04a-18fd1832d394",
    //         "transaction_type": "XFER",
    //         "type": "deposit",
    //         "asset": "ETH",
    //         "symbol": null,
    //         "amount": "0.010000000000000000",
    //         "details": null,
    //         "created_at": "2023-10-20T13:15:39.443Z"
    //     }
    //
    // withdrawal transaction from pro (trading) to wallet (funding)
    //     {
    //         "transaction_id": "a6c65cb3-95d0-44e2-8202-f70581d6e55c",
    //         "transaction_type": "XFER",
    //         "type": "withdrawal",
    //         "asset": "USD",
    //         "symbol": null,
    //         "amount": "-3.00",
    //         "details": null,
    //         "created_at": "2023-10-26T14:32:24.887Z"
    //     }
    //
    // sell trade
    //     {
    //         "transaction_id": "47a45928-abcd-4c12-8bd6-587c3028025f",
    //         "transaction_type": "SWAP",
    //         "type": "atomic token swap",
    //         "asset": "USDT",
    //         "symbol": "ETH-USDT",
    //         "amount": "1.447947",
    //         "details": null,
    //         "created_at": "2023-10-20T13:16:30.373Z"
    //     }
    //
    // buy trade
    //     {
    //         "transaction_id": "46d20a93-45c4-4441-a238-f89602eb8c8c",
    //         "transaction_type": "SWAP",
    //         "type": "atomic token swap",
    //         "asset": "ETH",
    //         "symbol": "ETH-USDT",
    //         "amount": "0.000800000000000000",
    //         "details": null,
    //         "created_at": "2023-10-20T13:22:14.256Z"
    //     },
    //
    //  fee
    //     {
    //         "transaction_id": "57fd526c-36b1-4721-83ce-42aadcb1e953",
    //         "transaction_type": "FEE",
    //         "type": "fee",
    //         "asset": "USDT",
    //         "symbol": "BTC-USDT",
    //         "amount": "-0.047176",
    //         "details": {
    //             "fee_details": [
    //                 {
    //                     "insurance_fee": "0",
    //                     "order_id": "c0bc33cd-eeb9-40a0-ab5f-2d99f323ef58",
    //                     "fee_type": "taker",
    //                     "fee_currency": "USDT"
    //                 }
    //             ]
    //         },
    //         "created_at": "2023-10-25T16:46:24.294Z"
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var id interface{} = this.SafeString(item, "transaction_id")
    var createdAt interface{} = this.SafeString(item, "created_at")
    var timestamp interface{} = this.Parse8601(createdAt)
    var amount interface{} = this.SafeString(item, "amount")
    var amountIsNegative interface{} = Precise.StringLt(amount, "0")
    var direction interface{} = nil
    if IsTrue(amountIsNegative) {
        direction = "out"
        amount = Precise.StringNeg(amount)
    } else {
        direction = "in"
    }
    var currencyId interface{} = this.SafeString(item, "asset")
    var code interface{} = this.SafeCurrencyCode(currencyId, currency)
    currency = this.SafeCurrency(currencyId, currency)
    var typeVar interface{} = this.ParseLedgerEntryType(this.SafeString(item, "type"))
    return this.SafeLedgerEntry(map[string]interface{} {
        "info": item,
        "id": id,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "direction": direction,
        "account": "trading",
        "referenceId": nil,
        "referenceAccount": nil,
        "type": typeVar,
        "currency": code,
        "amount": this.ParseNumber(amount),
        "before": nil,
        "after": nil,
        "status": "ok",
        "fee": nil,
    }, currency)
}
func  (this *coinlist) ParseLedgerEntryType(typeVar interface{}) interface{}  {
    var types interface{} = map[string]interface{} {
        "atomic token swap": "trade",
        "fee": "fee",
        "deposit": "transfer",
        "withdrawal": "transfer",
    }
    return this.SafeString(types, typeVar, typeVar)
}
func  (this *coinlist) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var request interface{} = this.Omit(params, this.ExtractParams(path))
    var endpoint interface{} = Add("/", this.ImplodeParams(path, params))
    var url interface{} = Add(GetValue(GetValue(this.Urls, "api"), api), endpoint)
    var isBulk interface{} = IsArray(params)
    var query interface{} = nil
    if !IsTrue(isBulk) {
        query = this.Urlencode(request)
    }
    if IsTrue(IsEqual(api, "private")) {
        this.CheckRequiredCredentials()
        var timestamp interface{} = ToString(this.Seconds())
        var auth interface{} = Add(Add(timestamp, method), endpoint)
        if IsTrue(IsTrue(IsTrue((IsEqual(method, "POST"))) || IsTrue((IsEqual(method, "PATCH")))) || IsTrue(isBulk)) {
            body = this.Json(request)
            auth = Add(auth, body)
        } else if IsTrue(IsTrue(!IsEqual(query, nil)) && IsTrue(!IsEqual(GetLength(query), 0))) {
            auth = Add(auth, Add("?", query))
            url = Add(url, Add("?", query))
        }
        var signature interface{} = this.Hmac(this.Encode(auth), this.Base64ToBinary(this.Secret), sha256, "base64")
        headers = map[string]interface{} {
            "CL-ACCESS-KEY": this.ApiKey,
            "CL-ACCESS-SIG": signature,
            "CL-ACCESS-TIMESTAMP": timestamp,
            "Content-Type": "application/json",
        }
    } else if IsTrue(IsTrue(!IsEqual(query, nil)) && IsTrue(!IsEqual(GetLength(query), 0))) {
        url = Add(url, Add("?", query))
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *coinlist) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsEqual(response, nil)) {
        // In some cases the exchange returns 202 Accepted for bad orders.
        // The body of that response contains order_id of the order.
        // Some bad orders will get status 'rejected' and could be fetched later (by using fetchOrders() or fetchOrder(order_id)).
        // While others don't get any status, they simply disappear, but the response is still 202 Accepted and contains their order_id.
        // When using fechOrder(order_id) for such disappeared orders, the exchange returns an empty response with code 404.
        if IsTrue(IsTrue(IsTrue((IsEqual(code, 404))) && IsTrue((IsGreaterThanOrEqual(GetIndexOf(url, "/orders/"), 0)))) && IsTrue((IsEqual(method, "GET")))) {
            var parts interface{} = Split(url, "/orders/")
            var orderId interface{} = this.SafeString(parts, 1)
            panic(OrderNotFound(Add(Add(Add(this.Id, " order "), orderId), " not found (or rejected on the exchange side)")))
        }
        return nil
    }
    var responseCode interface{} = this.SafeString(response, "status")
    var messageCode interface{} = this.SafeString(response, "message_code")
    if IsTrue(IsTrue((!IsEqual(messageCode, nil))) || IsTrue((IsTrue(IsTrue(IsTrue(IsTrue((!IsEqual(responseCode, nil))) && IsTrue((!IsEqual(code, 200)))) && IsTrue((!IsEqual(code, 202)))) && IsTrue((!IsEqual(responseCode, "200")))) && IsTrue((!IsEqual(responseCode, "202")))))) {
        var feedback interface{} = Add(Add(this.Id, " "), body)
        var message interface{} = this.SafeString(response, "message")
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), message, feedback)
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), messageCode, feedback)
        panic(ExchangeError(feedback))
    }
    return nil
}


func (this *coinlist) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
