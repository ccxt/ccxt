package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type timex struct {
    Exchange

}

func NewTimexCore() timex {
   p := timex{}
   setDefaults(&p)
   return p
}

func  (this *timex) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "timex",
        "name": "TimeX",
        "countries": []interface{}{"AU"},
        "version": "v1",
        "rateLimit": 1500,
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": false,
            "swap": false,
            "future": false,
            "option": false,
            "addMargin": false,
            "cancelOrder": true,
            "cancelOrders": true,
            "createOrder": true,
            "createReduceOnlyOrder": false,
            "createStopLimitOrder": false,
            "createStopMarketOrder": false,
            "createStopOrder": false,
            "editOrder": true,
            "fetchBalance": true,
            "fetchBorrowRateHistories": false,
            "fetchBorrowRateHistory": false,
            "fetchClosedOrders": true,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchCurrencies": true,
            "fetchDeposit": false,
            "fetchDepositAddress": true,
            "fetchDepositAddresses": false,
            "fetchDepositAddressesByNetwork": false,
            "fetchDeposits": true,
            "fetchFundingHistory": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchIndexOHLCV": false,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchLeverage": false,
            "fetchLeverageTiers": false,
            "fetchMarginMode": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchPosition": false,
            "fetchPositionHistory": false,
            "fetchPositionMode": false,
            "fetchPositions": false,
            "fetchPositionsForSymbol": false,
            "fetchPositionsHistory": false,
            "fetchPositionsRisk": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTime": true,
            "fetchTrades": true,
            "fetchTradingFee": true,
            "fetchWithdrawal": false,
            "fetchWithdrawals": true,
            "reduceMargin": false,
            "setLeverage": false,
            "setMarginMode": false,
            "setPositionMode": false,
        },
        "timeframes": map[string]interface{} {
            "1m": "I1",
            "5m": "I5",
            "15m": "I15",
            "30m": "I30",
            "1h": "H1",
            "2h": "H2",
            "4h": "H4",
            "6h": "H6",
            "12h": "H12",
            "1d": "D1",
            "1w": "W1",
        },
        "urls": map[string]interface{} {
            "logo": "https://user-images.githubusercontent.com/1294454/70423869-6839ab00-1a7f-11ea-8f94-13ae72c31115.jpg",
            "api": map[string]interface{} {
                "rest": "https://plasma-relay-backend.timex.io",
            },
            "www": "https://timex.io",
            "doc": "https://plasma-relay-backend.timex.io/swagger-ui/index.html",
            "referral": "https://timex.io/?refcode=1x27vNkTbP1uwkCck",
        },
        "api": map[string]interface{} {
            "addressbook": map[string]interface{} {
                "get": []interface{}{"me"},
                "post": []interface{}{"", "id/{id}", "id/{id}/remove"},
            },
            "custody": map[string]interface{} {
                "get": []interface{}{"credentials", "credentials/h/{hash}", "credentials/k/{key}", "credentials/me", "credentials/me/address", "deposit-addresses", "deposit-addresses/h/{hash}"},
            },
            "history": map[string]interface{} {
                "get": []interface{}{"orders", "orders/details", "orders/export/csv", "trades", "trades/export/csv"},
            },
            "currencies": map[string]interface{} {
                "get": []interface{}{"a/{address}", "i/{id}", "s/{symbol}"},
                "post": []interface{}{"perform", "prepare", "remove/perform", "s/{symbol}/remove/prepare", "s/{symbol}/update/perform", "s/{symbol}/update/prepare"},
            },
            "manager": map[string]interface{} {
                "get": []interface{}{"deposits", "transfers", "withdrawals"},
            },
            "markets": map[string]interface{} {
                "get": []interface{}{"i/{id}", "s/{symbol}"},
                "post": []interface{}{"perform", "prepare", "remove/perform", "s/{symbol}/remove/prepare", "s/{symbol}/update/perform", "s/{symbol}/update/prepare"},
            },
            "public": map[string]interface{} {
                "get": []interface{}{"candles", "currencies", "markets", "orderbook", "orderbook/raw", "orderbook/v2", "tickers", "trades"},
            },
            "statistics": map[string]interface{} {
                "get": []interface{}{"address"},
            },
            "trading": map[string]interface{} {
                "get": []interface{}{"balances", "fees", "orders"},
                "post": []interface{}{"orders", "orders/json"},
                "put": []interface{}{"orders", "orders/json"},
                "delete": []interface{}{"orders", "orders/json"},
            },
            "tradingview": map[string]interface{} {
                "get": []interface{}{"config", "history", "symbol_info", "time"},
            },
        },
        "precisionMode": TICK_SIZE,
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "0": ExchangeError,
                "1": NotSupported,
                "4000": BadRequest,
                "4001": BadRequest,
                "4002": InsufficientFunds,
                "4003": AuthenticationError,
                "4004": AuthenticationError,
                "4005": BadRequest,
                "4006": BadRequest,
                "4007": BadRequest,
                "4300": PermissionDenied,
                "4100": AuthenticationError,
                "4400": OrderNotFound,
                "5001": InvalidOrder,
                "5002": ExchangeError,
                "400": BadRequest,
                "401": AuthenticationError,
                "403": PermissionDenied,
                "404": OrderNotFound,
                "429": RateLimitExceeded,
                "500": ExchangeError,
                "503": ExchangeNotAvailable,
            },
            "broad": map[string]interface{} {
                "Insufficient": InsufficientFunds,
            },
        },
        "options": map[string]interface{} {
            "expireIn": 31536000,
            "fetchTickers": map[string]interface{} {
                "period": "1d",
            },
            "fetchTrades": map[string]interface{} {
                "sort": "timestamp,asc",
            },
            "fetchMyTrades": map[string]interface{} {
                "sort": "timestamp,asc",
            },
            "fetchOpenOrders": map[string]interface{} {
                "sort": "createdAt,asc",
            },
            "fetchClosedOrders": map[string]interface{} {
                "sort": "createdAt,asc",
            },
            "defaultSort": "timestamp,asc",
            "defaultSortOrders": "createdAt,asc",
        },
        "features": map[string]interface{} {
            "spot": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": false,
                    "triggerDirection": false,
                    "triggerPriceType": nil,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": true,
                        "FOK": true,
                        "PO": false,
                        "GTD": true,
                    },
                    "hedged": false,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyByCost": false,
                    "marketBuyRequiresPrice": false,
                    "selfTradePrevention": false,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": 100000,
                    "untilDays": 100000,
                    "symbolRequired": false,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOrders": nil,
                "fetchClosedOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": 100000,
                    "daysBackCanceled": 1,
                    "untilDays": 100000,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOHLCV": map[string]interface{} {
                    "limit": nil,
                },
            },
            "swap": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
    })
}
/**
 * @method
 * @name timex#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func  (this *timex) FetchTime(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.TradingviewGetTime(params))
            PanicOnError(response)
        
                //
            //     1708682617
            //
        ch <- Multiply(this.ParseToInt(response), 1000)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name timex#fetchMarkets
 * @description retrieves data on all markets for timex
 * @see https://plasma-relay-backend.timex.io/swagger-ui/index.html?urls.primaryName=Relay#/Public/listMarkets
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *timex) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetMarkets(params))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "symbol": "ETHBTC",
            //             "name": "ETH/BTC",
            //             "baseCurrency": "ETH",
            //             "baseTokenAddress": "0x45932db54b38af1f5a57136302eeba66a5975c15",
            //             "quoteCurrency": "BTC",
            //             "quoteTokenAddress": "0x8370fbc6ddec1e18b4e41e72ed943e238458487c",
            //             "feeCurrency": "BTC",
            //             "feeTokenAddress": "0x8370fbc6ddec1e18b4e41e72ed943e238458487c",
            //             "quantityIncrement": "0.0000001",
            //             "takerFee": "0.005",
            //             "makerFee": "0.0025",
            //             "tickSize": "0.00000001",
            //             "baseMinSize": "0.0001",
            //             "quoteMinSize": "0.00001",
            //             "locked": false
            //         }
            //     ]
            //
        ch <- this.ParseMarkets(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name timex#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see https://plasma-relay-backend.timex.io/swagger-ui/index.html?urls.primaryName=Relay#/Public/listCurrencies
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func  (this *timex) FetchCurrencies(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetCurrencies(params))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "symbol": "BTC",
            //             "name": "Bitcoin",
            //             "address": "0x8370fbc6ddec1e18b4e41e72ed943e238458487c",
            //             "icon": "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA2MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggb3BhY2l0eT0iMC41IiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTMwIDUzQzQyLjcwMjUgNTMgNTMgNDIuNzAyNSA1MyAzMEM1MyAxNy4yOTc1IDQyLjcwMjUgNyAzMCA3QzE3LjI5NzUgNyA3IDE3LjI5NzUgNyAzMEM3IDQyLjcwMjUgMTcuMjk3NSA1MyAzMCA1M1pNMzAgNTVDNDMuODA3MSA1NSA1NSA0My44MDcxIDU1IDMwQzU1IDE2LjE5MjkgNDMuODA3MSA1IDMwIDVDMTYuMTkyOSA1IDUgMTYuMTkyOSA1IDMwQzUgNDMuODA3MSAxNi4xOTI5IDU1IDMwIDU1WiIvPgo8cGF0aCBkPSJNNDAuOTQyNSAyNi42NTg1QzQxLjQwMDMgMjMuNjExMyAzOS4wNzA1IDIxLjk3MzIgMzUuODg0OCAyMC44ODA0TDM2LjkxODIgMTYuNzUyNkwzNC4zOTUxIDE2LjEyNjRMMzMuMzg5IDIwLjE0NTVDMzIuNzI1OCAxOS45ODA5IDMyLjA0NDUgMTkuODI1NiAzMS4zNjc1IDE5LjY3MTdMMzIuMzgwOCAxNS42MjYyTDI5Ljg1OTEgMTVMMjguODI1IDE5LjEyNjRDMjguMjc2IDE5LjAwMTkgMjcuNzM3IDE4Ljg3ODggMjcuMjEzOSAxOC43NDkzTDI3LjIxNjggMTguNzM2NEwyMy43MzcyIDE3Ljg3MTJMMjMuMDY2IDIwLjU1NDhDMjMuMDY2IDIwLjU1NDggMjQuOTM4IDIwLjk4MjEgMjQuODk4NSAyMS4wMDg1QzI1LjkyMDQgMjEuMjYyNiAyNi4xMDUgMjEuOTM2IDI2LjA3NDEgMjIuNDY5OUwyNC44OTcgMjcuMTcyNEMyNC45Njc1IDI3LjE5MDMgMjUuMDU4NyAyNy4yMTYgMjUuMTU5MyAyNy4yNTYxQzI1LjA3NTMgMjcuMjM1NCAyNC45ODU0IDI3LjIxMjQgMjQuODkyNyAyNy4xOTAzTDIzLjI0MjggMzMuNzc3OEMyMy4xMTc3IDM0LjA4NjkgMjIuODAwOCAzNC41NTA2IDIyLjA4NjUgMzQuMzc0NkMyMi4xMTE3IDM0LjQxMTEgMjAuMjUyNiAzMy45MTg3IDIwLjI1MjYgMzMuOTE4N0wxOSAzNi43OTQ5TDIyLjI4MzQgMzcuNjFDMjIuODk0MiAzNy43NjI0IDIzLjQ5MjggMzcuOTIyIDI0LjA4MjEgMzguMDcyM0wyMy4wMzggNDIuMjQ3NEwyNS41NTgyIDQyLjg3MzZMMjYuNTkyMyAzOC43NDI5QzI3LjI4MDcgMzguOTI5IDI3Ljk0OSAzOS4xMDA3IDI4LjYwMyAzOS4yNjI0TDI3LjU3MjUgNDMuMzczOEwzMC4wOTU2IDQ0TDMxLjEzOTcgMzkuODMyOEMzNS40NDIyIDQwLjY0MzYgMzguNjc3NCA0MC4zMTY2IDQwLjAzOTIgMzYuNDQxNEM0MS4xMzY1IDMzLjMyMTIgMzkuOTg0NiAzMS41MjEzIDM3LjcyMDkgMzAuMzQ3N0MzOS4zNjk0IDI5Ljk2OTEgNDAuNjExMiAyOC44ODkyIDQwLjk0MjUgMjYuNjU4NVYyNi42NTg1Wk0zNS4xNzc3IDM0LjcwODhDMzQuMzk4IDM3LjgyOSAyOS4xMjI2IDM2LjE0MjIgMjcuNDEyMiAzNS43MTkzTDI4Ljc5NzcgMzAuMTg4MUMzMC41MDgxIDMwLjYxMzIgMzUuOTkyNiAzMS40NTQ4IDM1LjE3NzcgMzQuNzA4OFpNMzUuOTU4MSAyNi42MTM0QzM1LjI0NjcgMjkuNDUxNyAzMC44NTU5IDI4LjAwOTcgMjkuNDMxNiAyNy42NTYxTDMwLjY4NzcgMjIuNjM5NUMzMi4xMTIgMjIuOTkzIDM2LjY5OSAyMy42NTI4IDM1Ljk1ODEgMjYuNjEzNFoiLz4KPC9zdmc+Cg==",
            //             "background": "transparent",
            //             "fiatSymbol": "BTC",
            //             "decimals": 8,
            //             "tradeDecimals": 20,
            //             "displayDecimals": 4,
            //             "crypto": true,
            //             "depositEnabled": true,
            //             "withdrawalEnabled": true,
            //             "transferEnabled": true,
            //             "buyEnabled": false,
            //             "purchaseEnabled": false,
            //             "redeemEnabled": false,
            //             "active": true,
            //             "withdrawalFee": "50000000000000000",
            //             "purchaseCommissions": []
            //         },
            //     ]
            //
        ch <- this.ParseCurrencies(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name timex#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://plasma-relay-backend.timex.io/swagger-ui/index.html?urls.primaryName=Relay#/Manager/getDeposits
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *timex) FetchDeposits(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var address interface{} = this.SafeString(params, "address")
            params = this.Omit(params, "address")
            if IsTrue(IsEqual(address, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchDeposits() requires an address parameter")))
            }
            var request interface{} = map[string]interface{} {
                "address": address,
            }
        
            response:= (<-this.ManagerGetDeposits(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     [
            //         {
            //             "from": "0x1134cc86b45039cc211c6d1d2e4b3c77f60207ed",
            //             "timestamp": "2022-01-01T00:00:00Z",
            //             "to": "0x1134cc86b45039cc211c6d1d2e4b3c77f60207ed",
            //             "token": "0x6baad3fe5d0fd4be604420e728adbd68d67e119e",
            //             "transferHash": "0x5464cdff35448314e178b8677ea41e670ea0f2533f4e52bfbd4e4a6cfcdef4c2",
            //             "value": "100"
            //         }
            //     ]
            //
            var currency interface{} = this.SafeCurrency(code)
        
            ch <- this.ParseTransactions(response, currency, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name timex#fetchWithdrawals
 * @description fetch all withdrawals made to an account
 * @see https://plasma-relay-backend.timex.io/swagger-ui/index.html?urls.primaryName=Relay#/Manager/getWithdraws
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of transaction structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *timex) FetchWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var address interface{} = this.SafeString(params, "address")
            params = this.Omit(params, "address")
            if IsTrue(IsEqual(address, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchDeposits() requires an address parameter")))
            }
            var request interface{} = map[string]interface{} {
                "address": address,
            }
        
            response:= (<-this.ManagerGetWithdrawals(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     [
            //         {
            //             "from": "0x1134cc86b45039cc211c6d1d2e4b3c77f60207ed",
            //             "timestamp": "2022-01-01T00:00:00Z",
            //             "to": "0x1134cc86b45039cc211c6d1d2e4b3c77f60207ed",
            //             "token": "0x6baad3fe5d0fd4be604420e728adbd68d67e119e",
            //             "transferHash": "0x5464cdff35448314e178b8677ea41e670ea0f2533f4e52bfbd4e4a6cfcdef4c2",
            //             "value": "100"
            //         }
            //     ]
            //
            var currency interface{} = this.SafeCurrency(code)
        
            ch <- this.ParseTransactions(response, currency, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *timex) GetCurrencyByAddress(address interface{}) interface{}  {
    var currencies interface{} = this.Currencies
    for i := 0; IsLessThan(i, GetArrayLength(currencies)); i++ {
        var currency interface{} = GetValue(currencies, i)
        var info interface{} = this.SafeValue(currency, "info", map[string]interface{} {})
        var a interface{} = this.SafeString(info, "address")
        if IsTrue(IsEqual(a, address)) {
            return currency
        }
    }
    return nil
}
func  (this *timex) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "from": "0x1134cc86b45039cc211c6d1d2e4b3c77f60207ed",
    //         "timestamp": "2022-01-01T00:00:00Z",
    //         "to": "0x1134cc86b45039cc211c6d1d2e4b3c77f60207ed",
    //         "token": "0x6baad3fe5d0fd4be604420e728adbd68d67e119e",
    //         "transferHash": "0x5464cdff35448314e178b8677ea41e670ea0f2533f4e52bfbd4e4a6cfcdef4c2",
    //         "value": "100"
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var datetime interface{} = this.SafeString(transaction, "timestamp")
    var currencyAddresss interface{} = this.SafeString(transaction, "token", "")
    currency = this.GetCurrencyByAddress(currencyAddresss)
    return map[string]interface{} {
        "info": transaction,
        "id": this.SafeString(transaction, "transferHash"),
        "txid": this.SafeString(transaction, "txid"),
        "timestamp": this.Parse8601(datetime),
        "datetime": datetime,
        "network": nil,
        "address": nil,
        "addressTo": this.SafeString(transaction, "to"),
        "addressFrom": this.SafeString(transaction, "from"),
        "tag": nil,
        "tagTo": nil,
        "tagFrom": nil,
        "type": nil,
        "amount": this.SafeNumber(transaction, "value"),
        "currency": this.SafeCurrencyCode(nil, currency),
        "status": "ok",
        "updated": nil,
        "internal": nil,
        "comment": nil,
        "fee": nil,
    }
}
/**
 * @method
 * @name timex#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://plasma-relay-backend.timex.io/swagger-ui/index.html?urls.primaryName=Relay#/Public/listTickers
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *timex) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes5648 := (<-this.LoadMarkets())
            PanicOnError(retRes5648)
            var period interface{} = this.SafeString(GetValue(this.Options, "fetchTickers"), "period", "1d")
            var request interface{} = map[string]interface{} {
                "period": GetValue(this.Timeframes, period),
            }
        
            response:= (<-this.PublicGetTickers(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "ask": 0.017,
            //             "bid": 0.016,
            //             "high": 0.019,
            //             "last": 0.017,
            //             "low": 0.015,
            //             "market": "TIME/ETH",
            //             "open": 0.016,
            //             "period": "H1",
            //             "timestamp": "2018-12-14T20:50:36.134Z",
            //             "volume": 4.57,
            //             "volumeQuote": 0.07312
            //         }
            //     ]
            //
        ch <- this.ParseTickers(response, symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name timex#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://plasma-relay-backend.timex.io/swagger-ui/index.html?urls.primaryName=Relay#/Public/listTickers
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *timex) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes6008 := (<-this.LoadMarkets())
            PanicOnError(retRes6008)
            var market interface{} = this.Market(symbol)
            var period interface{} = this.SafeString(GetValue(this.Options, "fetchTickers"), "period", "1d")
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
                "period": GetValue(this.Timeframes, period),
            }
        
            response:= (<-this.PublicGetTickers(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     [
            //         {
            //             "ask": 0.017,
            //             "bid": 0.016,
            //             "high": 0.019,
            //             "last": 0.017,
            //             "low": 0.015,
            //             "market": "TIME/ETH",
            //             "open": 0.016,
            //             "period": "H1",
            //             "timestamp": "2018-12-14T20:50:36.134Z",
            //             "volume": 4.57,
            //             "volumeQuote": 0.07312
            //         }
            //     ]
            //
            var ticker interface{} = this.SafeDict(response, 0)
        
            ch <- this.ParseTicker(ticker, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name timex#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://plasma-relay-backend.timex.io/swagger-ui/index.html?urls.primaryName=Relay#/Public/orderbookV2
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *timex) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes6408 := (<-this.LoadMarkets())
            PanicOnError(retRes6408)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.PublicGetOrderbookV2(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "timestamp":"2019-12-05T00:21:09.538",
            //         "bid":[
            //             {
            //                 "index":"2",
            //                 "price":"0.02024007",
            //                 "baseTokenAmount":"0.0096894",
            //                 "baseTokenCumulativeAmount":"0.0096894",
            //                 "quoteTokenAmount":"0.000196114134258",
            //                 "quoteTokenCumulativeAmount":"0.000196114134258"
            //             },
            //         "ask":[
            //             {
            //                 "index":"-3",
            //                 "price":"0.02024012",
            //                 "baseTokenAmount":"0.005",
            //                 "baseTokenCumulativeAmount":"0.005",
            //                 "quoteTokenAmount":"0.0001012006",
            //                 "quoteTokenCumulativeAmount":"0.0001012006"
            //             },
            //         ]
            //     }
            //
            var timestamp interface{} = this.Parse8601(this.SafeString(response, "timestamp"))
        
            ch <- this.ParseOrderBook(response, symbol, timestamp, "bid", "ask", "price", "baseTokenAmount")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name timex#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://plasma-relay-backend.timex.io/swagger-ui/index.html?urls.primaryName=Relay#/Public/listTrades
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *timex) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes6898 := (<-this.LoadMarkets())
            PanicOnError(retRes6898)
            var market interface{} = this.Market(symbol)
            var options interface{} = this.SafeValue(this.Options, "fetchTrades", map[string]interface{} {})
            var defaultSort interface{} = this.SafeValue(options, "sort", "timestamp,asc")
            var sort interface{} = this.SafeString(params, "sort", defaultSort)
            var query interface{} = this.Omit(params, "sort")
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
                "sort": sort,
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "from", this.Iso8601(since))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "size", limit) // default is 100
            }
        
            response:= (<-this.PublicGetTrades(this.Extend(request, query)))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "id":1,
            //             "timestamp":"2019-06-25T17:01:50.309",
            //             "direction":"BUY",
            //             "price":"0.027",
            //             "quantity":"0.001"
            //         }
            //     ]
            //
        ch <- this.ParseTrades(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name timex#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://plasma-relay-backend.timex.io/swagger-ui/index.html?urls.primaryName=Relay#/Public/listCandles
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest candle to fetch
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *timex) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes7408 := (<-this.LoadMarkets())
            PanicOnError(retRes7408)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
                "period": this.SafeString(this.Timeframes, timeframe, timeframe),
            }
            // if since and limit are not specified
            var duration interface{} = this.ParseTimeframe(timeframe)
            var until interface{} = this.SafeInteger(params, "until")
            if IsTrue(IsEqual(limit, nil)) {
                limit = 1000 // exchange provides tens of thousands of data, but we set generous default value
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "from", this.Iso8601(since))
                if IsTrue(IsEqual(until, nil)) {
                    AddElementToObject(request, "till", this.Iso8601(this.Sum(since, Multiply(Multiply(this.Sum(limit, 1), duration), 1000))))
                } else {
                    AddElementToObject(request, "till", this.Iso8601(until))
                }
            } else if IsTrue(!IsEqual(until, nil)) {
                AddElementToObject(request, "till", this.Iso8601(until))
                var fromTimestamp interface{} = Subtract(until, Multiply(Multiply(this.Sum(limit, 1), duration), 1000))
                AddElementToObject(request, "from", this.Iso8601(fromTimestamp))
            } else {
                var now interface{} = this.Milliseconds()
                AddElementToObject(request, "till", this.Iso8601(now))
                AddElementToObject(request, "from", this.Iso8601(Subtract(Subtract(now, Multiply(Multiply(this.Sum(limit, 1), duration), 1000)), 1)))
            }
            params = this.Omit(params, "until")
        
            response:= (<-this.PublicGetCandles(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "timestamp":"2019-12-04T23:00:00",
            //             "open":"0.02024009",
            //             "high":"0.02024009",
            //             "low":"0.02024009",
            //             "close":"0.02024009",
            //             "volume":"0.00008096036",
            //             "volumeQuote":"0.004",
            //         },
            //     ]
            //
        ch <- this.ParseOHLCVs(response, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *timex) ParseBalance(response interface{}) interface{}  {
    var result interface{} = map[string]interface{} {
        "info": response,
        "timestamp": nil,
        "datetime": nil,
    }
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        var balance interface{} = GetValue(response, i)
        var currencyId interface{} = this.SafeString(balance, "currency")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        AddElementToObject(account, "total", this.SafeString(balance, "totalBalance"))
        AddElementToObject(account, "used", this.SafeString(balance, "lockedBalance"))
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name timex#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://plasma-relay-backend.timex.io/swagger-ui/index.html?urls.primaryName=Relay#/Trading/getBalances
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *timex) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes8138 := (<-this.LoadMarkets())
            PanicOnError(retRes8138)
        
            response:= (<-this.TradingGetBalances(params))
            PanicOnError(response)
        
                //
            //     [
            //         {"currency":"BTC","totalBalance":"0","lockedBalance":"0"},
            //         {"currency":"AUDT","totalBalance":"0","lockedBalance":"0"},
            //         {"currency":"ETH","totalBalance":"0","lockedBalance":"0"},
            //         {"currency":"TIME","totalBalance":"0","lockedBalance":"0"},
            //         {"currency":"USDT","totalBalance":"0","lockedBalance":"0"}
            //     ]
            //
        ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name timex#createOrder
 * @description create a trade order
 * @see https://plasma-relay-backend.timex.io/swagger-ui/index.html?urls.primaryName=Relay#/Trading/createOrder
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *timex) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes8418 := (<-this.LoadMarkets())
            PanicOnError(retRes8418)
            var market interface{} = this.Market(symbol)
            var uppercaseSide interface{} = ToUpper(side)
            var uppercaseType interface{} = ToUpper(typeVar)
            var postOnly interface{} = this.SafeBool(params, "postOnly", false)
            if IsTrue(postOnly) {
                uppercaseType = "POST_ONLY"
                params = this.Omit(params, []interface{}{"postOnly"})
            }
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "quantity": this.AmountToPrecision(symbol, amount),
                "side": uppercaseSide,
                "orderTypes": uppercaseType,
            }
            var query interface{} = params
            if IsTrue(IsTrue((IsEqual(uppercaseType, "LIMIT"))) || IsTrue((IsEqual(uppercaseType, "POST_ONLY")))) {
                AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
                var defaultExpireIn interface{} = this.SafeInteger(this.Options, "expireIn")
                var expireTime interface{} = this.SafeValue(params, "expireTime")
                var expireIn interface{} = this.SafeValue(params, "expireIn", defaultExpireIn)
                if IsTrue(!IsEqual(expireTime, nil)) {
                    AddElementToObject(request, "expireTime", expireTime)
                } else if IsTrue(!IsEqual(expireIn, nil)) {
                    AddElementToObject(request, "expireIn", expireIn)
                } else {
                    panic(InvalidOrder(Add(Add(Add(this.Id, " createOrder() method requires a expireTime or expireIn param for a "), typeVar), " order, you can also set the expireIn exchange-wide option")))
                }
                query = this.Omit(params, []interface{}{"expireTime", "expireIn"})
            } else {
                AddElementToObject(request, "price", 0)
            }
        
            response:= (<-this.TradingPostOrders(this.Extend(request, query)))
            PanicOnError(response)
            //
            //     {
            //         "orders": [
            //             {
            //                 "cancelledQuantity": "0.3",
            //                 "clientOrderId": "my-order-1",
            //                 "createdAt": "1970-01-01T00:00:00",
            //                 "cursorId": 50,
            //                 "expireTime": "1970-01-01T00:00:00",
            //                 "filledQuantity": "0.3",
            //                 "id": "string",
            //                 "price": "0.017",
            //                 "quantity": "0.3",
            //                 "side": "BUY",
            //                 "symbol": "TIMEETH",
            //                 "type": "LIMIT",
            //                 "updatedAt": "1970-01-01T00:00:00"
            //             }
            //         ]
            //     }
            //
            var orders interface{} = this.SafeValue(response, "orders", []interface{}{})
            var order interface{} = this.SafeDict(orders, 0, map[string]interface{} {})
        
            ch <- this.ParseOrder(order, market)
            return nil
        
            }()
            return ch
        }
func  (this *timex) EditOrder(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    amount := GetArg(optionalArgs, 0, nil)
            _ = amount
            price := GetArg(optionalArgs, 1, nil)
            _ = price
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes9048 := (<-this.LoadMarkets())
            PanicOnError(retRes9048)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "id": id,
            }
            if IsTrue(!IsEqual(amount, nil)) {
                AddElementToObject(request, "quantity", this.AmountToPrecision(symbol, amount))
            }
            if IsTrue(!IsEqual(price, nil)) {
                AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
            }
        
            response:= (<-this.TradingPutOrders(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "changedOrders": [
            //             {
            //                 "newOrder": {
            //                 "cancelledQuantity": "0.3",
            //                 "clientOrderId": "my-order-1",
            //                 "createdAt": "1970-01-01T00:00:00",
            //                 "cursorId": 50,
            //                 "expireTime": "1970-01-01T00:00:00",
            //                 "filledQuantity": "0.3",
            //                 "id": "string",
            //                 "price": "0.017",
            //                 "quantity": "0.3",
            //                 "side": "BUY",
            //                 "symbol": "TIMEETH",
            //                 "type": "LIMIT",
            //                 "updatedAt": "1970-01-01T00:00:00"
            //                 },
            //                 "oldId": "string",
            //             },
            //         ],
            //         "unchangedOrders": [ "string" ],
            //     }
            //
            if IsTrue(InOp(response, "unchangedOrders")) {
                var orderIds interface{} = this.SafeValue(response, "unchangedOrders", []interface{}{})
                var orderId interface{} = this.SafeString(orderIds, 0)
        
                ch <- this.SafeOrder(map[string]interface{} {
                    "id": orderId,
                    "info": response,
                })
                return nil
            }
            var orders interface{} = this.SafeValue(response, "changedOrders", []interface{}{})
            var firstOrder interface{} = this.SafeValue(orders, 0, map[string]interface{} {})
            var order interface{} = this.SafeDict(firstOrder, "newOrder", map[string]interface{} {})
        
            ch <- this.ParseOrder(order, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name timex#cancelOrder
 * @description cancels an open order
 * @see https://plasma-relay-backend.timex.io/swagger-ui/index.html?urls.primaryName=Relay#/Trading/deleteOrders
 * @param {string} id order id
 * @param {string} symbol not used by timex cancelOrder ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *timex) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes9668 := (<-this.LoadMarkets())
            PanicOnError(retRes9668)
        
            orders:= (<-this.CancelOrders([]interface{}{id}, symbol, params))
            PanicOnError(orders)
        
            ch <- this.SafeDict(orders, 0)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name timex#cancelOrders
 * @description cancel multiple orders
 * @see https://plasma-relay-backend.timex.io/swagger-ui/index.html?urls.primaryName=Relay#/Trading/deleteOrders
 * @param {string[]} ids order ids
 * @param {string} symbol unified market symbol, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *timex) CancelOrders(ids interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes9828 := (<-this.LoadMarkets())
            PanicOnError(retRes9828)
            var request interface{} = map[string]interface{} {
                "id": ids,
            }
        
            response:= (<-this.TradingDeleteOrders(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "changedOrders": [
            //             {
            //                 "newOrder": {
            //                     "cancelledQuantity": "0.3",
            //                     "clientOrderId": "my-order-1",
            //                     "createdAt": "1970-01-01T00:00:00",
            //                     "cursorId": 50,
            //                     "expireTime": "1970-01-01T00:00:00",
            //                     "filledQuantity": "0.3",
            //                     "id": "string",
            //                     "price": "0.017",
            //                     "quantity": "0.3",
            //                     "side": "BUY",
            //                     "symbol": "TIMEETH",
            //                     "type": "LIMIT",
            //                     "updatedAt": "1970-01-01T00:00:00"
            //                 },
            //                 "oldId": "string",
            //             },
            //         ],
            //         "unchangedOrders": [ "string" ],
            //     }
            //
            var changedOrders interface{} = this.SafeList(response, "changedOrders", []interface{}{})
            var unchangedOrders interface{} = this.SafeList(response, "unchangedOrders", []interface{}{})
            var orders interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(changedOrders)); i++ {
                var newOrder interface{} = this.SafeDict(GetValue(changedOrders, i), "newOrder")
                AppendToArray(&orders,this.ParseOrder(newOrder))
            }
            for i := 0; IsLessThan(i, GetArrayLength(unchangedOrders)); i++ {
                AppendToArray(&orders,this.SafeOrder(map[string]interface{} {
                    "info": GetValue(unchangedOrders, i),
                    "id": GetValue(unchangedOrders, i),
                    "status": "unchanged",
                }))
            }
        
            ch <- orders
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name timex#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://plasma-relay-backend.timex.io/swagger-ui/index.html?urls.primaryName=Relay#/History/getOrderDetails
 * @param {string} id order id
 * @param {string} symbol not used by timex fetchOrder
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *timex) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes10408 := (<-this.LoadMarkets())
            PanicOnError(retRes10408)
            var request interface{} = map[string]interface{} {
                "orderHash": id,
            }
        
            response:= (<-this.HistoryGetOrdersDetails(request))
            PanicOnError(response)
            //
            //     {
            //         "order": {
            //             "cancelledQuantity": "0.3",
            //             "clientOrderId": "my-order-1",
            //             "createdAt": "1970-01-01T00:00:00",
            //             "cursorId": 50,
            //             "expireTime": "1970-01-01T00:00:00",
            //             "filledQuantity": "0.3",
            //             "id": "string",
            //             "price": "0.017",
            //             "quantity": "0.3",
            //             "side": "BUY",
            //             "symbol": "TIMEETH",
            //             "type": "LIMIT",
            //             "updatedAt": "1970-01-01T00:00:00"
            //         },
            //         "trades": [
            //             {
            //                 "fee": "0.3",
            //                 "id": 100,
            //                 "makerOrTaker": "MAKER",
            //                 "makerOrderId": "string",
            //                 "price": "0.017",
            //                 "quantity": "0.3",
            //                 "side": "BUY",
            //                 "symbol": "TIMEETH",
            //                 "takerOrderId": "string",
            //                 "timestamp": "2019-12-05T07:48:26.310Z"
            //             }
            //         ]
            //     }
            //
            var order interface{} = this.SafeValue(response, "order", map[string]interface{} {})
            var trades interface{} = this.SafeList(response, "trades", []interface{}{})
        
            ch <- this.ParseOrder(this.Extend(order, map[string]interface{} {
                "trades": trades,
            }))
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name timex#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://plasma-relay-backend.timex.io/swagger-ui/index.html?urls.primaryName=Relay#/Trading/getOpenOrders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *timex) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes10958 := (<-this.LoadMarkets())
            PanicOnError(retRes10958)
            var options interface{} = this.SafeValue(this.Options, "fetchOpenOrders", map[string]interface{} {})
            var defaultSort interface{} = this.SafeValue(options, "sort", "createdAt,asc")
            var sort interface{} = this.SafeString(params, "sort", defaultSort)
            var query interface{} = this.Omit(params, "sort")
            var request interface{} = map[string]interface{} {
                "sort": sort,
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "size", limit)
            }
        
            response:= (<-this.TradingGetOrders(this.Extend(request, query)))
            PanicOnError(response)
            //
            //     {
            //         "orders": [
            //             {
            //                 "cancelledQuantity": "0.3",
            //                 "clientOrderId": "my-order-1",
            //                 "createdAt": "1970-01-01T00:00:00",
            //                 "cursorId": 50,
            //                 "expireTime": "1970-01-01T00:00:00",
            //                 "filledQuantity": "0.3",
            //                 "id": "string",
            //                 "price": "0.017",
            //                 "quantity": "0.3",
            //                 "side": "BUY",
            //                 "symbol": "TIMEETH",
            //                 "type": "LIMIT",
            //                 "updatedAt": "1970-01-01T00:00:00"
            //             }
            //         ]
            //     }
            //
            var orders interface{} = this.SafeList(response, "orders", []interface{}{})
        
            ch <- this.ParseOrders(orders, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name timex#fetchClosedOrders
 * @description fetches information on multiple closed orders made by the user
 * @see https://plasma-relay-backend.timex.io/swagger-ui/index.html?urls.primaryName=Relay#/History/getOrders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *timex) FetchClosedOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes11518 := (<-this.LoadMarkets())
            PanicOnError(retRes11518)
            var options interface{} = this.SafeValue(this.Options, "fetchClosedOrders", map[string]interface{} {})
            var defaultSort interface{} = this.SafeValue(options, "sort", "createdAt,asc")
            var sort interface{} = this.SafeString(params, "sort", defaultSort)
            var query interface{} = this.Omit(params, "sort")
            var request interface{} = map[string]interface{} {
                "sort": sort,
                "side": "BUY",
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "from", this.Iso8601(since))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "size", limit)
            }
        
            response:= (<-this.HistoryGetOrders(this.Extend(request, query)))
            PanicOnError(response)
            //
            //     {
            //         "orders": [
            //             {
            //                 "cancelledQuantity": "0.3",
            //                 "clientOrderId": "my-order-1",
            //                 "createdAt": "1970-01-01T00:00:00",
            //                 "cursorId": 50,
            //                 "expireTime": "1970-01-01T00:00:00",
            //                 "filledQuantity": "0.3",
            //                 "id": "string",
            //                 "price": "0.017",
            //                 "quantity": "0.3",
            //                 "side": "BUY",
            //                 "symbol": "TIMEETH",
            //                 "type": "LIMIT",
            //                 "updatedAt": "1970-01-01T00:00:00"
            //             }
            //         ]
            //     }
            //
            var orders interface{} = this.SafeList(response, "orders", []interface{}{})
        
            ch <- this.ParseOrders(orders, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name timex#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://plasma-relay-backend.timex.io/swagger-ui/index.html?urls.primaryName=Relay#/History/getTrades_1
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *timex) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes12128 := (<-this.LoadMarkets())
            PanicOnError(retRes12128)
            var options interface{} = this.SafeValue(this.Options, "fetchMyTrades", map[string]interface{} {})
            var defaultSort interface{} = this.SafeValue(options, "sort", "timestamp,asc")
            var sort interface{} = this.SafeString(params, "sort", defaultSort)
            var query interface{} = this.Omit(params, "sort")
            var request interface{} = map[string]interface{} {
                "sort": sort,
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "from", this.Iso8601(since))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "size", limit)
            }
        
            response:= (<-this.HistoryGetTrades(this.Extend(request, query)))
            PanicOnError(response)
            //
            //     {
            //         "trades": [
            //             {
            //                 "fee": "0.3",
            //                 "id": 100,
            //                 "makerOrTaker": "MAKER",
            //                 "makerOrderId": "string",
            //                 "price": "0.017",
            //                 "quantity": "0.3",
            //                 "side": "BUY",
            //                 "symbol": "TIMEETH",
            //                 "takerOrderId": "string",
            //                 "timestamp": "2019-12-08T04:54:11.171Z"
            //             }
            //         ]
            //     }
            //
            var trades interface{} = this.SafeList(response, "trades", []interface{}{})
        
            ch <- this.ParseTrades(trades, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *timex) ParseTradingFee(fee interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "fee": 0.0075,
    //         "market": "ETHBTC"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(fee, "market")
    var rate interface{} = this.SafeNumber(fee, "fee")
    return map[string]interface{} {
        "info": fee,
        "symbol": this.SafeSymbol(marketId, market),
        "maker": rate,
        "taker": rate,
        "percentage": nil,
        "tierBased": nil,
    }
}
/**
 * @method
 * @name timex#fetchTradingFee
 * @description fetch the trading fees for a market
 * @see https://plasma-relay-backend.timex.io/swagger-ui/index.html?urls.primaryName=Relay#/Trading/getFees
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func  (this *timex) FetchTradingFee(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes12938 := (<-this.LoadMarkets())
            PanicOnError(retRes12938)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "markets": GetValue(market, "id"),
            }
        
            response:= (<-this.TradingGetFees(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     [
            //         {
            //             "fee": 0.0075,
            //             "market": "ETHBTC"
            //         }
            //     ]
            //
            var result interface{} = this.SafeValue(response, 0, map[string]interface{} {})
        
            ch <- this.ParseTradingFee(result, market)
            return nil
        
            }()
            return ch
        }
func  (this *timex) ParseMarket(market interface{}) interface{}  {
    //
    //     {
    //         "symbol": "ETHBTC",
    //         "name": "ETH/BTC",
    //         "baseCurrency": "ETH",
    //         "baseTokenAddress": "0x45932db54b38af1f5a57136302eeba66a5975c15",
    //         "quoteCurrency": "BTC",
    //         "quoteTokenAddress": "0x8370fbc6ddec1e18b4e41e72ed943e238458487c",
    //         "feeCurrency": "BTC",
    //         "feeTokenAddress": "0x8370fbc6ddec1e18b4e41e72ed943e238458487c",
    //         "quantityIncrement": "0.0000001",
    //         "takerFee": "0.005",
    //         "makerFee": "0.0025",
    //         "tickSize": "0.00000001",
    //         "baseMinSize": "0.0001",
    //         "quoteMinSize": "0.00001",
    //         "locked": false
    //     }
    //
    var locked interface{} = this.SafeValue(market, "locked")
    var id interface{} = this.SafeString(market, "symbol")
    var baseId interface{} = this.SafeString(market, "baseCurrency")
    var quoteId interface{} = this.SafeString(market, "quoteCurrency")
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    var amountIncrement interface{} = this.SafeString(market, "quantityIncrement")
    var minBase interface{} = this.SafeString(market, "baseMinSize")
    var minAmount interface{} = Precise.StringMax(amountIncrement, minBase)
    var priceIncrement interface{} = this.SafeString(market, "tickSize")
    var minCost interface{} = this.SafeNumber(market, "quoteMinSize")
    return map[string]interface{} {
        "id": id,
        "symbol": Add(Add(base, "/"), quote),
        "base": base,
        "quote": quote,
        "settle": nil,
        "baseId": baseId,
        "quoteId": quoteId,
        "settleId": nil,
        "type": "spot",
        "spot": true,
        "margin": false,
        "swap": false,
        "future": false,
        "option": false,
        "active": !IsTrue(locked),
        "contract": false,
        "linear": nil,
        "inverse": nil,
        "taker": this.SafeNumber(market, "takerFee"),
        "maker": this.SafeNumber(market, "makerFee"),
        "contractSize": nil,
        "expiry": nil,
        "expiryDatetime": nil,
        "strike": nil,
        "optionType": nil,
        "precision": map[string]interface{} {
            "amount": this.SafeNumber(market, "quantityIncrement"),
            "price": this.SafeNumber(market, "tickSize"),
        },
        "limits": map[string]interface{} {
            "leverage": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "amount": map[string]interface{} {
                "min": this.ParseNumber(minAmount),
                "max": nil,
            },
            "price": map[string]interface{} {
                "min": this.ParseNumber(priceIncrement),
                "max": nil,
            },
            "cost": map[string]interface{} {
                "min": minCost,
                "max": nil,
            },
        },
        "created": nil,
        "info": market,
    }
}
func  (this *timex) ParseCurrency(currency interface{}) interface{}  {
    //
    //     {
    //         "symbol": "BTC",
    //         "name": "Bitcoin",
    //         "address": "0x8370fbc6ddec1e18b4e41e72ed943e238458487c",
    //         "icon": "data:image/svg+xml;base64,PHN2ZyB3aWR...mc+Cg==",
    //         "background": "transparent",
    //         "fiatSymbol": "BTC",
    //         "decimals": 8,
    //         "tradeDecimals": 20,
    //         "displayDecimals": 4,
    //         "crypto": true,
    //         "depositEnabled": true,
    //         "withdrawalEnabled": true,
    //         "transferEnabled": true,
    //         "buyEnabled": false,
    //         "purchaseEnabled": false,
    //         "redeemEnabled": false,
    //         "active": true,
    //         "withdrawalFee": "50000000000000000",
    //         "purchaseCommissions": []
    //     }
    //
    // https://github.com/ccxt/ccxt/issues/6878
    //
    //     {
    //         "symbol":"XRP",
    //         "name":"Ripple",
    //         "address":"0x0dc8882914f3ddeebf4cec6dc20edb99df3def6c",
    //         "decimals":6,
    //         "tradeDecimals":16,
    //         "depositEnabled":true,
    //         "withdrawalEnabled":true,
    //         "transferEnabled":true,
    //         "active":true
    //     }
    //
    var id interface{} = this.SafeString(currency, "symbol")
    var code interface{} = this.SafeCurrencyCode(id)
    var name interface{} = this.SafeString(currency, "name")
    var depositEnabled interface{} = this.SafeValue(currency, "depositEnabled")
    var withdrawEnabled interface{} = this.SafeValue(currency, "withdrawalEnabled")
    var isActive interface{} = this.SafeValue(currency, "active")
    var active interface{} = IsTrue(IsTrue(depositEnabled) && IsTrue(withdrawEnabled)) && IsTrue(isActive)
    // const fee = this.safeNumber (currency, 'withdrawalFee');
    var feeString interface{} = this.SafeString(currency, "withdrawalFee")
    var tradeDecimals interface{} = this.SafeInteger(currency, "tradeDecimals")
    var fee interface{} = nil
    if IsTrue(IsTrue((!IsEqual(feeString, nil))) && IsTrue((!IsEqual(tradeDecimals, nil)))) {
        var feeStringLen interface{} =         GetLength(feeString)
        var dotIndex interface{} = Subtract(feeStringLen, tradeDecimals)
        if IsTrue(IsGreaterThan(dotIndex, 0)) {
            var whole interface{} = Slice(feeString, 0, dotIndex)
            var fraction interface{} = Slice(feeString, OpNeg(dotIndex), nil)
            fee = this.ParseNumber(Add(Add(whole, "."), fraction))
        } else {
            var fraction interface{} = "."
            for i := 0; IsLessThan(i, OpNeg(dotIndex)); i++ {
                fraction = Add(fraction, "0")
            }
            fee = this.ParseNumber(Add(fraction, feeString))
        }
    }
    return this.SafeCurrencyStructure(map[string]interface{} {
        "id": code,
        "code": code,
        "info": currency,
        "type": nil,
        "name": name,
        "active": active,
        "deposit": depositEnabled,
        "withdraw": withdrawEnabled,
        "fee": fee,
        "precision": this.ParseNumber(this.ParsePrecision(this.SafeString(currency, "decimals"))),
        "limits": map[string]interface{} {
            "withdraw": map[string]interface{} {
                "min": fee,
                "max": nil,
            },
            "amount": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
        },
        "networks": map[string]interface{} {},
    })
}
func  (this *timex) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "ask": 0.017,
    //         "bid": 0.016,
    //         "high": 0.019,
    //         "last": 0.017,
    //         "low": 0.015,
    //         "market": "TIME/ETH",
    //         "open": 0.016,
    //         "period": "H1",
    //         "timestamp": "2018-12-14T20:50:36.134Z",
    //         "volume": 4.57,
    //         "volumeQuote": 0.07312
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(ticker, "market")
    var symbol interface{} = this.SafeSymbol(marketId, market, "/")
    var timestamp interface{} = this.Parse8601(this.SafeString(ticker, "timestamp"))
    var last interface{} = this.SafeString(ticker, "last")
    var open interface{} = this.SafeString(ticker, "open")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "info": ticker,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeString(ticker, "high"),
        "low": this.SafeString(ticker, "low"),
        "bid": this.SafeString(ticker, "bid"),
        "bidVolume": nil,
        "ask": this.SafeString(ticker, "ask"),
        "askVolume": nil,
        "vwap": nil,
        "open": open,
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": nil,
        "percentage": nil,
        "average": nil,
        "baseVolume": this.SafeString(ticker, "volume"),
        "quoteVolume": this.SafeString(ticker, "volumeQuote"),
    }, market)
}
func  (this *timex) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTrades (public)
    //
    //     {
    //         "id":1,
    //         "timestamp":"2019-06-25T17:01:50.309",
    //         "direction":"BUY",
    //         "price":"0.027",
    //         "quantity":"0.001"
    //     }
    //
    // fetchMyTrades, fetchOrder (private)
    //
    //     {
    //         "id": "7613414",
    //         "makerOrderId": "0x8420af060722f560098f786a2894d4358079b6ea5d14b395969ed77bc87a623a",
    //         "takerOrderId": "0x1235ef158a361815b54c9988b6241c85aedcbc1fe81caf8df8587d5ab0373d1a",
    //         "symbol": "LTCUSDT",
    //         "side": "BUY",
    //         "quantity": "0.2",
    //         "fee": "0.22685",
    //         "feeToken": "USDT",
    //         "price": "226.85",
    //         "makerOrTaker": "TAKER",
    //         "timestamp": "2021-04-09T15:39:45.608"
    //    }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(trade, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var timestamp interface{} = this.Parse8601(this.SafeString(trade, "timestamp"))
    var priceString interface{} = this.SafeString(trade, "price")
    var amountString interface{} = this.SafeString(trade, "quantity")
    var price interface{} = this.ParseNumber(priceString)
    var amount interface{} = this.ParseNumber(amountString)
    var cost interface{} = this.ParseNumber(Precise.StringMul(priceString, amountString))
    var id interface{} = this.SafeString(trade, "id")
    var side interface{} = this.SafeStringLower2(trade, "direction", "side")
    var takerOrMaker interface{} = this.SafeStringLower(trade, "makerOrTaker")
    var orderId interface{} = nil
    if IsTrue(!IsEqual(takerOrMaker, nil)) {
        orderId = this.SafeString(trade, Add(takerOrMaker, "OrderId"))
    }
    var fee interface{} = nil
    var feeCost interface{} = this.SafeNumber(trade, "fee")
    var feeCurrency interface{} = this.SafeCurrencyCode(this.SafeString(trade, "feeToken"))
    if IsTrue(!IsEqual(feeCost, nil)) {
        fee = map[string]interface{} {
            "cost": feeCost,
            "currency": feeCurrency,
        }
    }
    return map[string]interface{} {
        "info": trade,
        "id": id,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "order": orderId,
        "type": nil,
        "side": side,
        "price": price,
        "amount": amount,
        "cost": cost,
        "takerOrMaker": takerOrMaker,
        "fee": fee,
    }
}
func  (this *timex) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "timestamp":"2019-12-04T23:00:00",
    //         "open":"0.02024009",
    //         "high":"0.02024009",
    //         "low":"0.02024009",
    //         "close":"0.02024009",
    //         "volume":"0.00008096036",
    //         "volumeQuote":"0.004",
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.Parse8601(this.SafeString(ohlcv, "timestamp")), this.SafeNumber(ohlcv, "open"), this.SafeNumber(ohlcv, "high"), this.SafeNumber(ohlcv, "low"), this.SafeNumber(ohlcv, "close"), this.SafeNumber(ohlcv, "volume")}
}
func  (this *timex) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchOrder, createOrder, cancelOrder, cancelOrders, fetchOpenOrders, fetchClosedOrders
    //
    //     {
    //         "cancelledQuantity": "0.3",
    //         "clientOrderId": "my-order-1",
    //         "createdAt": "1970-01-01T00:00:00",
    //         "cursorId": 50,
    //         "expireTime": "1970-01-01T00:00:00",
    //         "filledQuantity": "0.3",
    //         "id": "string",
    //         "price": "0.017",
    //         "quantity": "0.3",
    //         "side": "BUY",
    //         "symbol": "TIMEETH",
    //         "type": "LIMIT",
    //         "updatedAt": "1970-01-01T00:00:00"
    //         "trades": [], // injected from the outside
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeString(order, "id")
    var typeVar interface{} = this.SafeStringLower(order, "type")
    var side interface{} = this.SafeStringLower(order, "side")
    var marketId interface{} = this.SafeString(order, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var timestamp interface{} = this.Parse8601(this.SafeString(order, "createdAt"))
    var price interface{} = this.SafeString(order, "price")
    var amount interface{} = this.SafeString(order, "quantity")
    var filled interface{} = this.SafeString(order, "filledQuantity")
    var canceledQuantity interface{} = this.OmitZero(this.SafeString(order, "cancelledQuantity"))
    var status interface{} = nil
    if IsTrue(Precise.StringEquals(filled, amount)) {
        status = "closed"
    } else if IsTrue(!IsEqual(canceledQuantity, nil)) {
        status = "canceled"
    } else {
        status = "open"
    }
    var rawTrades interface{} = this.SafeValue(order, "trades", []interface{}{})
    var clientOrderId interface{} = this.SafeString(order, "clientOrderId")
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": id,
        "clientOrderId": clientOrderId,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "symbol": symbol,
        "type": typeVar,
        "timeInForce": nil,
        "postOnly": nil,
        "side": side,
        "price": price,
        "triggerPrice": nil,
        "amount": amount,
        "cost": nil,
        "average": nil,
        "filled": filled,
        "remaining": nil,
        "status": status,
        "fee": nil,
        "trades": rawTrades,
    }, market)
}
/**
 * @method
 * @name timex#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account, does not accept params["network"]
 * @see https://plasma-relay-backend.timex.io/swagger-ui/index.html?urls.primaryName=Relay#/Currency/selectCurrencyBySymbol
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *timex) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes16908 := (<-this.LoadMarkets())
            PanicOnError(retRes16908)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(currency, "code"),
            }
        
            response:= (<-this.CurrenciesGetSSymbol(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        id: '1',
            //        currency: {
            //            symbol: 'BTC',
            //            name: 'Bitcoin',
            //            address: '0x8370fbc6ddec1e18b4e41e72ed943e238458487c',
            //            decimals: '8',
            //            tradeDecimals: '20',
            //            fiatSymbol: 'BTC',
            //            depositEnabled: true,
            //            withdrawalEnabled: true,
            //            transferEnabled: true,
            //            active: true
            //        }
            //    }
            //
            var data interface{} = this.SafeDict(response, "currency", map[string]interface{} {})
        
            ch <- this.ParseDepositAddress(data, currency)
            return nil
        
            }()
            return ch
        }
func  (this *timex) ParseDepositAddress(depositAddress interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        symbol: 'BTC',
    //        name: 'Bitcoin',
    //        address: '0x8370fbc6ddec1e18b4e41e72ed943e238458487c',
    //        decimals: '8',
    //        tradeDecimals: '20',
    //        fiatSymbol: 'BTC',
    //        depositEnabled: true,
    //        withdrawalEnabled: true,
    //        transferEnabled: true,
    //        active: true
    //    }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var currencyId interface{} = this.SafeString(depositAddress, "symbol")
    return map[string]interface{} {
        "info": depositAddress,
        "currency": this.SafeCurrencyCode(currencyId, currency),
        "network": nil,
        "address": this.SafeString(depositAddress, "address"),
        "tag": nil,
    }
}
func  (this *timex) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var paramsToExtract interface{} = this.ExtractParams(path)
    path = this.ImplodeParams(path, params)
    params = this.Omit(params, paramsToExtract)
    var url interface{} = Add(Add(Add(Add(GetValue(GetValue(this.Urls, "api"), "rest"), "/"), api), "/"), path)
    if IsTrue(GetArrayLength(ObjectKeys(params))) {
        url = Add(url, Add("?", this.UrlencodeWithArrayRepeat(params)))
    }
    if IsTrue(IsTrue(!IsEqual(api, "public")) && IsTrue(!IsEqual(api, "tradingview"))) {
        this.CheckRequiredCredentials()
        var auth interface{} = this.StringToBase64(Add(Add(this.ApiKey, ":"), this.Secret))
        var secret interface{} = Add("Basic ", auth)
        headers = map[string]interface{} {
            "authorization": secret,
        }
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *timex) HandleErrors(statusCode interface{}, statusText interface{}, url interface{}, method interface{}, responseHeaders interface{}, responseBody interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsEqual(response, nil)) {
        return nil
    }
    if IsTrue(IsGreaterThanOrEqual(statusCode, 400)) {
        //
        //     {"error":{"timestamp":"05.12.2019T05:25:43.584+0000","status":"BAD_REQUEST","message":"Insufficient ETH balance. Required: 1, actual: 0.","code":4001}}
        //     {"error":{"timestamp":"05.12.2019T04:03:25.419+0000","status":"FORBIDDEN","message":"Access denied","code":4300}}
        //
        var feedback interface{} = Add(Add(this.Id, " "), responseBody)
        var error interface{} = this.SafeValue(response, "error")
        if IsTrue(IsEqual(error, nil)) {
            error = response
        }
        var code interface{} = this.SafeString2(error, "code", "status")
        var message interface{} = this.SafeString2(error, "message", "debugMessage")
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), message, feedback)
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), code, feedback)
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), message, feedback)
        panic(ExchangeError(feedback))
    }
    return nil
}


func (this *timex) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
