package ccxt

import "strconv"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type PionexCore struct {
	Exchange
}

func NewPionexCore() *PionexCore {
	p := &PionexCore{}
	setDefaults(p)
	return p
}

func (this *PionexCore) Describe() interface{} {
	return this.DeepExtend(this.Exchange.Describe(), map[string]interface{}{
		"id":        "pionex",
		"name":      "Pionex",
		"countries": []interface{}{"SG"},
		"rateLimit": 50,
		"certified": false,
		"pro":       true,
		"has": map[string]interface{}{
			"CORS":                    nil,
			"spot":                    true,
			"margin":                  false,
			"swap":                    false,
			"future":                  false,
			"option":                  false,
			"cancelAllOrders":         true,
			"cancelOrder":             true,
			"cancelOrders":            false,
			"closeAllPositions":       false,
			"closePosition":           false,
			"createOrder":             true,
			"createOrders":            true,
			"editOrder":               false,
			"fetchBalance":            true,
			"fetchBidsAsks":           true,
			"fetchClosedOrders":       true,
			"fetchCurrencies":         false,
			"fetchDeposits":           false,
			"fetchFundingRate":        false,
			"fetchFundingRateHistory": false,
			"fetchFundingRates":       false,
			"fetchMarkets":            true,
			"fetchMyTrades":           true,
			"fetchOHLCV":              true,
			"fetchOpenOrders":         true,
			"fetchOrder":              true,
			"fetchOrderBook":          true,
			"fetchOrders":             true,
			"fetchPositions":          false,
			"fetchTicker":             true,
			"fetchTickers":            true,
			"fetchTime":               false,
			"fetchTrades":             true,
			"fetchTradingFee":         false,
			"fetchTradingFees":        false,
			"fetchWithdrawals":        false,
			"setLeverage":             false,
			"setMarginMode":           false,
			"transfer":                false,
			"withdraw":                false,
		},
		"timeframes": map[string]interface{}{
			"1m":  "1M",
			"5m":  "5M",
			"15m": "15M",
			"30m": "30M",
			"1h":  "60M",
			"4h":  "4H",
			"8h":  "8H",
			"12h": "12H",
			"1d":  "1D",
		},
		"urls": map[string]interface{}{
			"logo": "https://user-images.githubusercontent.com/1294454/118521618-4c87b500-b76e-11eb-9a05-6e74e8a6c9cf.jpg",
			"api": map[string]interface{}{
				"public":  "https://api.pionex.com",
				"private": "https://api.pionex.com",
			},
			"www":  "https://www.pionex.com",
			"doc":  []interface{}{"https://pionex-doc.gitbook.io/apidocs"},
			"fees": "https://www.pionex.com/fees",
		},
		"api": map[string]interface{}{
			"public": map[string]interface{}{
				"get": map[string]interface{}{
					"api/v1/common/symbols":     1,
					"api/v1/common/timestamp":   1,
					"api/v1/market/depth":       1,
					"api/v1/market/trades":      1,
					"api/v1/market/klines":      1,
					"api/v1/market/tickers":     1,
					"api/v1/market/bookTickers": 1,
				},
			},
			"private": map[string]interface{}{
				"get": map[string]interface{}{
					"api/v1/account/balances":           1,
					"api/v1/trade/order":                1,
					"api/v1/trade/orderByClientOrderId": 1,
					"api/v1/trade/openOrders":           1,
					"api/v1/trade/allOrders":            1,
					"api/v1/trade/fills":                1,
					"api/v1/trade/fillsByOrderId":       5,
				},
				"post": map[string]interface{}{
					"api/v1/trade/order":     1,
					"api/v1/trade/massOrder": 1,
				},
				"delete": map[string]interface{}{
					"api/v1/trade/order":     1,
					"api/v1/trade/allOrders": 1,
				},
			},
		},
		"fees": map[string]interface{}{
			"trading": map[string]interface{}{
				"tierBased":  false,
				"percentage": true,
				"maker":      this.ParseNumber("0.0005"),
				"taker":      this.ParseNumber("0.0005"),
			},
		},
		"requiredCredentials": map[string]interface{}{
			"apiKey": true,
			"secret": true,
		},
		"options": map[string]interface{}{
			"defaultType": "spot",
			"recvWindow":  5000,
		},
		"exceptions": map[string]interface{}{
			"exact": map[string]interface{}{
				"-1000": ExchangeError,
				"-1001": ExchangeError,
				"-1002": AuthenticationError,
				"-1003": RateLimitExceeded,
				"-1006": ExchangeNotAvailable,
				"-1007": RequestTimeout,
				"-1013": InvalidOrder,
				"-1014": InvalidOrder,
				"-1015": RateLimitExceeded,
				"-1016": ExchangeError,
				"-1020": NotSupported,
				"-1021": InvalidNonce,
				"-1022": AuthenticationError,
				"-1100": BadRequest,
				"-1101": BadRequest,
				"-1102": BadRequest,
				"-1103": BadRequest,
				"-1104": BadRequest,
				"-1105": BadRequest,
				"-1106": BadRequest,
				"-1111": BadRequest,
				"-1112": InvalidOrder,
				"-1114": BadRequest,
				"-1115": BadRequest,
				"-1116": BadRequest,
				"-1117": BadRequest,
				"-1118": BadRequest,
				"-1119": BadRequest,
				"-1120": BadRequest,
				"-1121": BadSymbol,
				"-1125": AuthenticationError,
				"-1127": BadRequest,
				"-1128": BadRequest,
				"-1130": BadRequest,
				"-2010": InvalidOrder,
				"-2011": OrderNotFound,
				"-2013": OrderNotFound,
				"-2014": AuthenticationError,
				"-2015": AuthenticationError,
			},
			"broad": map[string]interface{}{},
		},
		"precisionMode": TICK_SIZE,
	})
}

func (this *PionexCore) Init(userConfig map[string]interface{}) {
	this.Exchange.DerivedExchange = this
	this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
}

func (this *PionexCore) Sign(path interface{}, optionalArgs ...interface{}) interface{} {
	api := GetArg(optionalArgs, 0, "public")
	method := GetArg(optionalArgs, 1, "GET")
	params := GetArg(optionalArgs, 2, map[string]interface{}{})
	headers := GetArg(optionalArgs, 3, nil)
	body := GetArg(optionalArgs, 4, nil)

	var url interface{} = Add(Add(GetValue(GetValue(this.Urls, "api"), api), "/"), path)
	var query interface{} = this.Omit(params, this.ExtractParams(path))

	if IsTrue(IsEqual(api, "public")) {
		if IsTrue(GetArrayLength(ObjectKeys(query))) {
			url = Add(url, Add("?", this.Urlencode(query)))
		}
	} else {
		this.CheckRequiredCredentials()
		var timestamp interface{} = ToString(this.Milliseconds())

		if IsTrue(IsTrue(IsEqual(method, "POST")) || IsTrue(IsEqual(method, "DELETE"))) {
			// For POST and DELETE requests:
			// - All params including timestamp go in query string (sorted) for signature
			// - Body contains all params except timestamp as JSON
			// Signature format: METHOD/path?sortedQueryString + JSON_body
			AddElementToObject(query, "timestamp", timestamp)
			var sortedQueryString interface{} = this.Urlencode(query, true)

			// Signature = METHOD/path?sortedQuery + body
			var pathUrl interface{} = Add(Add("/", path), Add("?", sortedQueryString))
			var signaturePayload interface{} = Add(method, pathUrl)

			// URL includes all params in query string
			url = Add(url, Add("?", sortedQueryString))

			// Body contains all params except timestamp
			var bodyParams interface{} = this.Omit(query, []interface{}{"timestamp"})
			if IsTrue(GetArrayLength(ObjectKeys(bodyParams))) {
				body = this.Json(bodyParams)
				// Append body to signature payload
				signaturePayload = Add(signaturePayload, body)
			}

			// Debug output
			//println("=== Pionex Signature Debug ===")
			//println("Method:", method.(string))
			//println("Path:", path.(string))
			//println("Signature Payload:", signaturePayload.(string))
			//println("Body:", body.(string))
			//println("URL:", url.(string))
			//println("==============================")

			var signature interface{} = this.Hmac(this.Encode(signaturePayload), this.Encode(this.Secret), sha256)
			headers = map[string]interface{}{
				"Content-Type":     "application/json",
				"PIONEX-KEY":       this.ApiKey,
				"PIONEX-SIGNATURE": signature,
			}
		} else {
			// For GET requests:
			// - All params including timestamp go in query string (sorted)
			// Signature format: METHOD/path?sortedQueryString
			AddElementToObject(query, "timestamp", timestamp)
			var queryString interface{} = this.Urlencode(query, true)
			var pathUrl interface{} = Add(Add("/", path), Add("?", queryString))
			var signaturePayload interface{} = Add(method, pathUrl)

			url = Add(url, Add("?", queryString))

			var signature interface{} = this.Hmac(this.Encode(signaturePayload), this.Encode(this.Secret), sha256)
			headers = map[string]interface{}{
				"PIONEX-KEY":       this.ApiKey,
				"PIONEX-SIGNATURE": signature,
			}
		}
	}

	return map[string]interface{}{
		"url":     url,
		"method":  method,
		"body":    body,
		"headers": headers,
	}
}

func (this *PionexCore) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{} {
	market := GetArg(optionalArgs, 0, nil)
	marketId := this.SafeString(ticker, "symbol")
	market = this.SafeMarket(marketId, market)
	symbol := GetValue(market, "symbol")

	timestamp := this.SafeInteger2(ticker, "time", "timestamp")
	last := this.SafeString(ticker, "close")

	return this.SafeTicker(map[string]interface{}{
		"symbol":        symbol,
		"timestamp":     timestamp,
		"datetime":      this.Iso8601(timestamp),
		"high":          this.SafeString(ticker, "high"),
		"low":           this.SafeString(ticker, "low"),
		"bid":           this.SafeString(ticker, "bidPrice"),
		"bidVolume":     this.SafeString(ticker, "bidSize"),
		"ask":           this.SafeString(ticker, "askPrice"),
		"askVolume":     this.SafeString(ticker, "askSize"),
		"vwap":          nil,
		"open":          this.SafeString(ticker, "open"),
		"close":         last,
		"last":          last,
		"previousClose": nil,
		"change":        nil,
		"percentage":    nil,
		"average":       nil,
		"baseVolume":    this.SafeString(ticker, "volume"),
		"quoteVolume":   this.SafeString(ticker, "amount"),
		"info":          ticker,
	}, market)
}

func (this *PionexCore) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{} {
	market := GetArg(optionalArgs, 0, nil)
	marketId := this.SafeString(trade, "symbol")
	market = this.SafeMarket(marketId, market)
	symbol := GetValue(market, "symbol")

	timestamp := this.SafeInteger(trade, "timestamp")
	id := this.SafeString(trade, "tradeId")
	orderId := this.SafeString(trade, "orderId")
	side := this.SafeStringLower(trade, "side")
	price := this.SafeString(trade, "price")
	amount := this.SafeString(trade, "size")
	fee := interface{}(nil)
	feeCost := this.SafeString(trade, "fee")
	if IsTrue(!IsEqual(feeCost, nil)) {
		feeCurrency := this.SafeString(trade, "feeCoin")
		fee = map[string]interface{}{
			"cost":     feeCost,
			"currency": this.SafeCurrencyCode(feeCurrency),
		}
	}

	return this.SafeTrade(map[string]interface{}{
		"id":           id,
		"info":         trade,
		"timestamp":    timestamp,
		"datetime":     this.Iso8601(timestamp),
		"symbol":       symbol,
		"order":        orderId,
		"type":         nil,
		"side":         side,
		"takerOrMaker": nil,
		"price":        price,
		"amount":       amount,
		"cost":         nil,
		"fee":          fee,
	}, market)
}

func (this *PionexCore) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{} {
	// ohlcv: {"time":1764936180000,"open":"91220.33","close":"91303.98","high":"91303.98","low":"91220.00","volume":"31.887558"}
	return []interface{}{
		this.SafeInteger(ohlcv, "time"),
		this.SafeNumber(ohlcv, "open"),
		this.SafeNumber(ohlcv, "high"),
		this.SafeNumber(ohlcv, "low"),
		this.SafeNumber(ohlcv, "close"),
		this.SafeNumber(ohlcv, "volume"),
	}
}

func (this *PionexCore) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{} {
	market := GetArg(optionalArgs, 0, nil)
	marketId := this.SafeString(order, "symbol")
	market = this.SafeMarket(marketId, market)
	symbol := GetValue(market, "symbol")

	timestamp := this.SafeInteger(order, "createTime")
	id := this.SafeString(order, "orderId")
	clientOrderId := this.SafeString(order, "clientOrderId")
	side := this.SafeStringLower(order, "side")
	orderType := this.SafeStringLower(order, "type")
	price := this.SafeString(order, "price")
	amount := this.SafeString(order, "size")
	filled := this.SafeString(order, "filledSize")
	cost := this.SafeString(order, "filledAmount")
	status := this.ParseOrderStatus(this.SafeString(order, "status"))

	return this.SafeOrder(map[string]interface{}{
		"id":                 id,
		"clientOrderId":      clientOrderId,
		"info":               order,
		"timestamp":          timestamp,
		"datetime":           this.Iso8601(timestamp),
		"lastTradeTimestamp": nil,
		"symbol":             symbol,
		"type":               orderType,
		"timeInForce":        nil,
		"postOnly":           nil,
		"side":               side,
		"price":              price,
		"stopPrice":          nil,
		"triggerPrice":       nil,
		"amount":             amount,
		"cost":               cost,
		"average":            nil,
		"filled":             filled,
		"remaining":          nil,
		"status":             status,
		"fee":                nil,
		"trades":             nil,
	}, market)
}

func (this *PionexCore) ParseOrderStatus(status interface{}) interface{} {
	statuses := map[string]interface{}{
		"NEW":              "open",
		"PARTIALLY_FILLED": "open",
		"FILLED":           "closed",
		"CANCELED":         "canceled",
		"PENDING_CANCEL":   "canceling",
		"REJECTED":         "rejected",
		"EXPIRED":          "expired",
	}
	return this.SafeString(statuses, status, status)
}

func (this *PionexCore) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{} {
	if IsTrue(IsEqual(response, nil)) {
		return nil
	}
	// Check for result field - Pionex returns result: true/false
	result := this.SafeBool(response, "result", true)
	if IsTrue(IsEqual(result, false)) {
		var errorCode interface{} = this.SafeString(response, "code")
		var message interface{} = this.SafeString(response, "message", "")
		var feedback interface{} = Add(Add(this.Id, " "), body)
		this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), errorCode, feedback)
		this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), message, feedback)
		if IsTrue(!IsEqual(errorCode, nil)) {
			panic(ExchangeError(feedback))
		}
	}
	return nil
}

func (this *PionexCore) ParseBalance(response interface{}) interface{} {
	var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
	var balances interface{} = this.SafeList(data, "balances", []interface{}{})
	var result interface{} = map[string]interface{}{
		"info": response,
	}
	for i := 0; IsLessThan(i, GetArrayLength(balances)); i++ {
		var balance interface{} = GetValue(balances, i)
		var currencyId interface{} = this.SafeString(balance, "coin")
		var code interface{} = this.SafeCurrencyCode(currencyId)
		var account interface{} = this.Account()
		AddElementToObject(account, "free", this.SafeString(balance, "free"))
		AddElementToObject(account, "used", this.SafeString(balance, "frozen"))
		AddElementToObject(account, "total", this.SafeString(balance, "total"))
		AddElementToObject(result, code, account)
	}
	return this.SafeBalance(result)
}

// Exchange interface implementations

func (this *PionexCore) FetchMarkets(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})

		response := (<-this.PublicGetApiV1CommonSymbols(params))
		PanicOnError(response)

		data := this.SafeDict(response, "data", map[string]interface{}{})
		symbols := this.SafeList(data, "symbols", []interface{}{})
		var result interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(symbols)); i++ {
			market := GetValue(symbols, i)
			id := this.SafeString(market, "symbol")
			baseId := this.SafeString(market, "baseCurrency")
			quoteId := this.SafeString(market, "quoteCurrency")
			base := this.SafeCurrencyCode(baseId)
			quote := this.SafeCurrencyCode(quoteId)
			symbol := Add(Add(base, "/"), quote)
			status := this.SafeString(market, "enable")
			AppendToArray(&result, map[string]interface{}{
				"id":             id,
				"symbol":         symbol,
				"base":           base,
				"quote":          quote,
				"settle":         nil,
				"baseId":         baseId,
				"quoteId":        quoteId,
				"settleId":       nil,
				"type":           "spot",
				"spot":           true,
				"margin":         false,
				"swap":           false,
				"future":         false,
				"option":         false,
				"active":         IsEqual(status, "true"),
				"contract":       false,
				"linear":         nil,
				"inverse":        nil,
				"contractSize":   nil,
				"expiry":         nil,
				"expiryDatetime": nil,
				"strike":         nil,
				"optionType":     nil,
				"precision": map[string]interface{}{
					"amount": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "basePrecision"))),
					"price":  this.ParseNumber(this.ParsePrecision(this.SafeString(market, "quotePrecision"))),
				},
				"limits": map[string]interface{}{
					"leverage": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
					"amount": map[string]interface{}{
						"min": this.SafeNumber(market, "minAmount"),
						"max": this.SafeNumber(market, "maxAmount"),
					},
					"price": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
					"cost": map[string]interface{}{
						"min": this.SafeNumber(market, "minNotional"),
						"max": nil,
					},
				},
				"info": market,
			})
		}
		ch <- result
	}()
	return ch
}

func (this *PionexCore) FetchBalance(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})

		retRes := (<-this.LoadMarkets())
		PanicOnError(retRes)

		response := (<-this.PrivateGetApiV1AccountBalances(params))
		PanicOnError(response)

		data := this.SafeDict(response, "data", map[string]interface{}{})
		balances := this.SafeList(data, "balances", []interface{}{})
		result := map[string]interface{}{
			"info": response,
		}
		for i := 0; IsLessThan(i, GetArrayLength(balances)); i++ {
			balance := GetValue(balances, i)
			currencyId := this.SafeString(balance, "coin")
			code := this.SafeCurrencyCode(currencyId)
			account := this.Account()
			AddElementToObject(account, "free", this.SafeString(balance, "free"))
			AddElementToObject(account, "used", this.SafeString(balance, "frozen"))
			AddElementToObject(account, "total", this.SafeString(balance, "total"))
			AddElementToObject(result, code, account)
		}
		ch <- this.SafeBalance(result)
	}()
	return ch
}

func (this *PionexCore) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() {
		defer close(ch)
		defer ReturnPanicError(ch)
		limit := GetArg(optionalArgs, 0, nil)
		params := GetArg(optionalArgs, 1, map[string]interface{}{})

		retRes := (<-this.LoadMarkets())
		PanicOnError(retRes)
		market := this.Market(symbol)
		request := map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}

		response := (<-this.PublicGetApiV1MarketDepth(this.Extend(request, params)))
		PanicOnError(response)

		data := this.SafeDict(response, "data", map[string]interface{}{})
		timestamp := this.SafeInteger(data, "time")
		ch <- this.ParseOrderBook(data, GetValue(market, "symbol"), timestamp, "bids", "asks", 0, 1)
	}()
	return ch
}

func (this *PionexCore) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})

		retRes := (<-this.LoadMarkets())
		PanicOnError(retRes)
		market := this.Market(symbol)
		request := map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}

		response := (<-this.PublicGetApiV1MarketTickers(this.Extend(request, params)))
		PanicOnError(response)

		data := this.SafeDict(response, "data", map[string]interface{}{})
		tickers := this.SafeList(data, "tickers", []interface{}{})
		ticker := this.SafeDict(tickers, 0, map[string]interface{}{})
		ch <- this.ParseTicker(ticker, market)
	}()
	return ch
}

func (this *PionexCore) FetchTickers(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		params := GetArg(optionalArgs, 1, map[string]interface{}{})

		retRes := (<-this.LoadMarkets())
		PanicOnError(retRes)

		response := (<-this.PublicGetApiV1MarketTickers(params))
		PanicOnError(response)

		data := this.SafeDict(response, "data", map[string]interface{}{})
		tickers := this.SafeList(data, "tickers", []interface{}{})
		ch <- this.ParseTickers(tickers, symbols)
	}()
	return ch
}

func (this *PionexCore) FetchBidsAsks(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		params := GetArg(optionalArgs, 1, map[string]interface{}{})

		retRes := (<-this.LoadMarkets())
		PanicOnError(retRes)

		response := (<-this.PublicGetApiV1MarketBookTickers(params))
		PanicOnError(response)

		data := this.SafeDict(response, "data", map[string]interface{}{})
		tickers := this.SafeList(data, "tickers", []interface{}{})
		ch <- this.ParseTickers(tickers, symbols)
	}()
	return ch
}

func (this *PionexCore) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() {
		defer close(ch)
		defer ReturnPanicError(ch)
		timeframe := GetArg(optionalArgs, 0, "1m")
		since := GetArg(optionalArgs, 1, nil)
		limit := GetArg(optionalArgs, 2, nil)
		params := GetArg(optionalArgs, 3, map[string]interface{}{})

		retRes := (<-this.LoadMarkets())
		PanicOnError(retRes)
		market := this.Market(symbol)
		request := map[string]interface{}{
			"symbol":   GetValue(market, "id"),
			"interval": this.SafeString(this.Timeframes, timeframe, timeframe),
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}

		response := (<-this.PublicGetApiV1MarketKlines(this.Extend(request, params)))
		PanicOnError(response)

		data := this.SafeDict(response, "data", map[string]interface{}{})
		klines := this.SafeList(data, "klines", []interface{}{})
		ch <- this.ParseOHLCVs(klines, market, timeframe, since, limit)
	}()
	return ch
}

func (this *PionexCore) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() {
		defer close(ch)
		defer ReturnPanicError(ch)
		since := GetArg(optionalArgs, 0, nil)
		limit := GetArg(optionalArgs, 1, nil)
		params := GetArg(optionalArgs, 2, map[string]interface{}{})

		retRes := (<-this.LoadMarkets())
		PanicOnError(retRes)
		market := this.Market(symbol)
		request := map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}

		response := (<-this.PublicGetApiV1MarketTrades(this.Extend(request, params)))
		PanicOnError(response)

		data := this.SafeDict(response, "data", map[string]interface{}{})
		trades := this.SafeList(data, "trades", []interface{}{})
		ch <- this.ParseTrades(trades, market, since, limit)
	}()
	return ch
}

func (this *PionexCore) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() {
		defer close(ch)
		defer ReturnPanicError(ch)
		price := GetArg(optionalArgs, 0, nil)
		params := GetArg(optionalArgs, 1, map[string]interface{}{})

		retRes := (<-this.LoadMarkets())
		PanicOnError(retRes)
		market := this.Market(symbol)
		var uppercaseType interface{} = ToUpper(typeVar)
		var uppercaseSide interface{} = ToUpper(side)
		request := map[string]interface{}{
			"symbol": GetValue(market, "id"),
			"side":   uppercaseSide,
			"type":   uppercaseType,
		}
		if IsTrue(IsEqual(uppercaseType, "LIMIT")) {
			AddElementToObject(request, "size", this.AmountToPrecision(symbol, amount))
			AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
		} else {
			// Market orders
			if IsTrue(IsEqual(uppercaseSide, "BUY")) {
				// Market buy uses amount (quote currency)
				// If price is provided, calculate quote amount = base amount * price
				// If price is not provided, treat amount as quote currency directly
				var quoteAmount interface{}
				if IsTrue(!IsEqual(price, nil)) {
					quoteAmount = this.CostToPrecision(symbol, Multiply(amount, price))
				} else {
					// Assume amount is already in quote currency
					quoteAmount = this.CostToPrecision(symbol, amount)
				}
				AddElementToObject(request, "amount", quoteAmount)
			} else {
				// Market sell uses size (base currency)
				AddElementToObject(request, "size", this.AmountToPrecision(symbol, amount))
			}
		}
		response := (<-this.PrivatePostApiV1TradeOrder(this.Extend(request, params)))
		PanicOnError(response)

		data := this.SafeDict(response, "data", map[string]interface{}{})
		ch <- this.ParseOrder(data, market)
	}()
	return ch
}

func (this *PionexCore) FetchOrder(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		params := GetArg(optionalArgs, 1, map[string]interface{}{})

		retRes := (<-this.LoadMarkets())
		PanicOnError(retRes)
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
		}
		request := map[string]interface{}{
			"orderId": id,
		}

		response := (<-this.PrivateGetApiV1TradeOrder(this.Extend(request, params)))
		PanicOnError(response)

		data := this.SafeDict(response, "data", map[string]interface{}{})
		ch <- this.ParseOrder(data, market)
	}()
	return ch
}

func (this *PionexCore) FetchOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		since := GetArg(optionalArgs, 1, nil)
		limit := GetArg(optionalArgs, 2, nil)
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchOrders() requires a symbol argument")))
		}

		retRes := (<-this.LoadMarkets())
		PanicOnError(retRes)
		market := this.Market(symbol)
		request := map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}

		response := (<-this.PrivateGetApiV1TradeAllOrders(this.Extend(request, params)))
		PanicOnError(response)

		data := this.SafeDict(response, "data", map[string]interface{}{})
		orders := this.SafeList(data, "orders", []interface{}{})
		ch <- this.ParseOrders(orders, market, since, limit)
	}()
	return ch
}

func (this *PionexCore) FetchOpenOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		since := GetArg(optionalArgs, 1, nil)
		limit := GetArg(optionalArgs, 2, nil)
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchOpenOrders() requires a symbol argument")))
		}

		retRes := (<-this.LoadMarkets())
		PanicOnError(retRes)
		market := this.Market(symbol)
		request := map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}

		response := (<-this.PrivateGetApiV1TradeOpenOrders(this.Extend(request, params)))
		PanicOnError(response)

		data := this.SafeDict(response, "data", map[string]interface{}{})
		orders := this.SafeList(data, "orders", []interface{}{})
		ch <- this.ParseOrders(orders, market, since, limit)
	}()
	return ch
}

func (this *PionexCore) FetchClosedOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		since := GetArg(optionalArgs, 1, nil)
		limit := GetArg(optionalArgs, 2, nil)
		params := GetArg(optionalArgs, 3, map[string]interface{}{})

		retRes := (<-this.FetchOrders(symbol, since, limit, params))
		PanicOnError(retRes)
		orders := retRes
		var result interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(orders)); i++ {
			order := GetValue(orders, i)
			status := this.SafeString(order, "status")
			if IsTrue(IsEqual(status, "closed")) {
				AppendToArray(&result, order)
			}
		}
		ch <- result
	}()
	return ch
}

func (this *PionexCore) FetchMyTrades(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		since := GetArg(optionalArgs, 1, nil)
		limit := GetArg(optionalArgs, 2, nil)
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " fetchMyTrades() requires a symbol argument")))
		}

		retRes := (<-this.LoadMarkets())
		PanicOnError(retRes)
		market := this.Market(symbol)
		request := map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "limit", limit)
		}

		response := (<-this.PrivateGetApiV1TradeFills(this.Extend(request, params)))
		PanicOnError(response)

		data := this.SafeDict(response, "data", map[string]interface{}{})
		fills := this.SafeList(data, "fills", []interface{}{})
		ch <- this.ParseTrades(fills, market, since, limit)
	}()
	return ch
}

func (this *PionexCore) CancelOrder(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " cancelOrder() requires a symbol argument")))
		}

		retRes := (<-this.LoadMarkets())
		PanicOnError(retRes)
		market := this.Market(symbol)
		// Convert orderId to int64 directly if it's a string
		var orderId interface{} = id
		if idStr, ok := id.(string); ok {
			if parsed, err := strconv.ParseInt(idStr, 10, 64); err == nil {
				orderId = parsed
			}
		}
		request := map[string]interface{}{
			"symbol":  GetValue(market, "id"),
			"orderId": orderId,
		}

		response := (<-this.PrivateDeleteApiV1TradeOrder(this.Extend(request, params)))
		PanicOnError(response)

		data := this.SafeDict(response, "data", map[string]interface{}{"orderId": id})
		ch <- this.ParseOrder(data, market)
	}()
	return ch
}

func (this *PionexCore) CancelAllOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		if IsTrue(IsEqual(symbol, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " cancelAllOrders() requires a symbol argument")))
		}

		retRes := (<-this.LoadMarkets())
		PanicOnError(retRes)
		market := this.Market(symbol)
		request := map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}

		response := (<-this.PrivateDeleteApiV1TradeAllOrders(this.Extend(request, params)))
		PanicOnError(response)

		data := this.SafeList(response, "data", []interface{}{})
		ch <- this.ParseOrders(data, market)
	}()
	return ch
}
