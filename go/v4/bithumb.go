package ccxt


// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type BithumbCore struct {
    Exchange

}

func NewBithumbCore() *BithumbCore {
    p := &BithumbCore{}
    setDefaults(p)
    return p
}

func  (this *BithumbCore) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "bithumb",
        "name": "Bithumb",
        "countries": []interface{}{"KR"},
        "rateLimit": 500,
        "pro": true,
        "has": map[string]interface{} {
            "CORS": true,
            "spot": true,
            "margin": false,
            "swap": false,
            "future": false,
            "option": false,
            "addMargin": false,
            "borrowCrossMargin": false,
            "borrowIsolatedMargin": false,
            "borrowMargin": false,
            "cancelOrder": true,
            "closeAllPositions": false,
            "closePosition": false,
            "createMarketOrder": true,
            "createOrder": true,
            "createOrderWithTakeProfitAndStopLoss": false,
            "createOrderWithTakeProfitAndStopLossWs": false,
            "createReduceOnlyOrder": false,
            "fetchBalance": true,
            "fetchBorrowInterest": false,
            "fetchBorrowRate": false,
            "fetchBorrowRateHistories": false,
            "fetchBorrowRateHistory": false,
            "fetchBorrowRates": false,
            "fetchBorrowRatesPerSymbol": false,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchCurrencies": false,
            "fetchFundingHistory": false,
            "fetchFundingInterval": false,
            "fetchFundingIntervals": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchGreeks": false,
            "fetchIndexOHLCV": false,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchIsolatedPositions": false,
            "fetchLeverage": false,
            "fetchLeverages": false,
            "fetchLeverageTiers": false,
            "fetchLiquidations": false,
            "fetchLongShortRatio": false,
            "fetchLongShortRatioHistory": false,
            "fetchMarginAdjustmentHistory": false,
            "fetchMarginMode": false,
            "fetchMarginModes": false,
            "fetchMarketLeverageTiers": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMarkPrices": false,
            "fetchMyLiquidations": false,
            "fetchMySettlementHistory": false,
            "fetchOHLCV": true,
            "fetchOpenInterest": false,
            "fetchOpenInterestHistory": false,
            "fetchOpenInterests": false,
            "fetchOpenOrders": true,
            "fetchOption": false,
            "fetchOptionChain": false,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchPosition": false,
            "fetchPositionHistory": false,
            "fetchPositionMode": false,
            "fetchPositions": false,
            "fetchPositionsForSymbol": false,
            "fetchPositionsHistory": false,
            "fetchPositionsRisk": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchSettlementHistory": false,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTrades": true,
            "fetchTransfer": false,
            "fetchTransfers": false,
            "fetchVolatilityHistory": false,
            "reduceMargin": false,
            "repayCrossMargin": false,
            "repayIsolatedMargin": false,
            "setLeverage": false,
            "setMargin": false,
            "setMarginMode": false,
            "setPositionMode": false,
            "transfer": false,
            "withdraw": true,
        },
        "hostname": "bithumb.com",
        "urls": map[string]interface{} {
            "logo": "https://github.com/user-attachments/assets/c9e0eefb-4777-46b9-8f09-9d7f7c4af82d",
            "api": map[string]interface{} {
                "public": "https://api.{hostname}/public",
                "private": "https://api.{hostname}",
                "v2public": "https://api.bithumb.com/v1",
                "v2private": "https://api.bithumb.com/v1",
                "v2order": "https://api.bithumb.com/v2",
            },
            "www": "https://www.bithumb.com",
            "doc": "https://apidocs.bithumb.com",
            "fees": "https://en.bithumb.com/customer_support/info_fee",
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": []interface{}{"ticker/ALL_{quoteId}", "ticker/{baseId}_{quoteId}", "orderbook/ALL_{quoteId}", "orderbook/{baseId}_{quoteId}", "transaction_history/{baseId}_{quoteId}", "network-info", "assetsstatus/multichain/ALL", "assetsstatus/multichain/{currency}", "withdraw/minimum/ALL", "withdraw/minimum/{currency}", "assetsstatus/ALL", "assetsstatus/{baseId}", "candlestick/{baseId}_{quoteId}/{interval}"},
            },
            "private": map[string]interface{} {
                "post": []interface{}{"info/account", "info/balance", "info/wallet_address", "info/ticker", "info/orders", "info/user_transactions", "info/order_detail", "trade/place", "trade/cancel", "trade/btc_withdrawal", "trade/krw_deposit", "trade/krw_withdrawal", "trade/market_buy", "trade/market_sell", "trade/stop_limit"},
            },
            "v2public": map[string]interface{} {
                "get": []interface{}{"market/all", "ticker", "orderbook", "trades/ticks", "candles/minutes/{unit}", "candles/{interval}", "candlestick/{market}/{interval}"},
            },
            "v2private": map[string]interface{} {
                "get": []interface{}{"accounts", "orders/chance", "order", "orders"},
                "post": []interface{}{"orders"},
                "delete": []interface{}{"order"},
            },
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "maker": this.ParseNumber("0.0025"),
                "taker": this.ParseNumber("0.0025"),
            },
        },
        "precisionMode": SIGNIFICANT_DIGITS,
        "features": map[string]interface{} {
            "spot": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": false,
                    "triggerPriceType": nil,
                    "triggerDirection": false,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": false,
                        "FOK": false,
                        "PO": false,
                        "GTD": false,
                    },
                    "hedged": false,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyRequiresPrice": false,
                    "marketBuyByCost": false,
                    "selfTradePrevention": false,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": nil,
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 1000,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchOrders": nil,
                "fetchClosedOrders": nil,
                "fetchOHLCV": map[string]interface{} {
                    "limit": 1000,
                },
            },
            "swap": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "exceptions": map[string]interface{} {
            "Bad Request(SSL)": BadRequest,
            "Bad Request(Bad Method)": BadRequest,
            "Bad Request.(Auth Data)": AuthenticationError,
            "Not Member": AuthenticationError,
            "Invalid Apikey": AuthenticationError,
            "Method Not Allowed.(Access IP)": PermissionDenied,
            "Method Not Allowed.(BTC Adress)": InvalidAddress,
            "Method Not Allowed.(Access)": PermissionDenied,
            "Database Fail": ExchangeNotAvailable,
            "Invalid Parameter": BadRequest,
            "5600": ExchangeError,
            "Unknown Error": ExchangeError,
            "After May 23th, recent_transactions is no longer, hence users will not be able to connect to recent_transactions": ExchangeError,
        },
        "timeframes": map[string]interface{} {
            "1m": "1",
            "3m": "3",
            "5m": "5",
            "10m": "10",
            "15m": "15",
            "30m": "30",
            "1h": "60",
            "4h": "240",
            "1d": "days",
            "1w": "weeks",
            "1M": "months",
        },
        "options": map[string]interface{} {
            "quoteCurrencies": map[string]interface{} {
                "BTC": map[string]interface{} {
                    "limits": map[string]interface{} {
                        "cost": map[string]interface{} {
                            "min": 0.0002,
                            "max": 100,
                        },
                    },
                },
                "KRW": map[string]interface{} {
                    "limits": map[string]interface{} {
                        "cost": map[string]interface{} {
                            "min": 500,
                            "max": 5000000000,
                        },
                    },
                },
                "USDT": map[string]interface{} {
                    "limits": map[string]interface{} {
                        "cost": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                    },
                },
            },
        },
        "commonCurrencies": map[string]interface{} {
            "ALT": "ArchLoot",
            "FTC": "FTC2",
            "SOC": "Soda Coin",
        },
    })
}
func  (this *BithumbCore) SafeMarket(optionalArgs ...interface{}) interface{}  {
    // bithumb has a different type of conflict in markets, because
    // their ids are the base currency (BTC for instance), so we can have
    // multiple "BTC" ids representing the different markets (BTC/ETH, "BTC/DOGE", etc)
    // since they're the same we just need to return one
    marketId := GetArg(optionalArgs, 0, nil)
    _ = marketId
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    delimiter := GetArg(optionalArgs, 2, nil)
    _ = delimiter
    marketType := GetArg(optionalArgs, 3, nil)
    _ = marketType
    return this.Exchange.SafeMarket(marketId, market, delimiter, "spot")
}
func  (this *BithumbCore) AmountToPrecision(symbol interface{}, amount interface{}) interface{}  {
    return this.DecimalToPrecision(amount, TRUNCATE, GetValue(GetValue(GetValue(this.Markets, symbol), "precision"), "amount"), DECIMAL_PLACES)
}
/**
 * @method
 * @name bithumb#fetchMarkets
 * @description retrieves data on all markets for bithumb
 * @see https://apidocs.bithumb.com/v1.2.0/reference/%ED%98%84%EC%9E%AC%EA%B0%80-%EC%A0%95%EB%B3%B4-%EC%A1%B0%ED%9A%8C-all
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *BithumbCore) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.V2publicGetMarketAll(params))
            PanicOnError(response)
            //
            //    [
            //        {
            //            "market": "KRW-BTC",
            //            "korean_name": "비트코인",
            //            "english_name": "Bitcoin",
            //            "market_warning": "NONE"
            //        },
            //        ...
            //    ]
            //
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
                var entry interface{} = GetValue(response, i)
                var marketId interface{} = this.SafeString(entry, "market")
                quoteIdbaseIdVariable := Split(marketId, "-");
                quoteId := GetValue(quoteIdbaseIdVariable,0);
                baseId := GetValue(quoteIdbaseIdVariable,1)
                var base interface{} = this.SafeCurrencyCode(baseId)
                var quote interface{} = this.SafeCurrencyCode(quoteId)
                var symbol interface{} = Add(Add(base, "/"), quote)
                AppendToArray(&result, map[string]interface{} {
                    "id": marketId,
                    "symbol": symbol,
                    "base": base,
                    "quote": quote,
                    "settle": nil,
                    "baseId": baseId,
                    "quoteId": quoteId,
                    "settleId": nil,
                    "type": "spot",
                    "spot": true,
                    "margin": false,
                    "swap": false,
                    "future": false,
                    "option": false,
                    "active": true,
                    "contract": false,
                    "linear": nil,
                    "inverse": nil,
                    "contractSize": nil,
                    "expiry": nil,
                    "expiryDateTime": nil,
                    "strike": nil,
                    "optionType": nil,
                    "precision": map[string]interface{} {
                        "amount": ParseInt("4"),
                        "price": ParseInt("4"),
                    },
                    "limits": map[string]interface{} {
                        "leverage": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "amount": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "price": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "cost": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                    },
                    "created": nil,
                    "info": entry,
                })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *BithumbCore) ParseBalance(response interface{}) interface{}  {
    var result interface{} = map[string]interface{} {
        "info": response,
    }
    var balances interface{} = this.SafeList(response, "data", []interface{}{})
    for i := 0; IsLessThan(i, GetArrayLength(balances)); i++ {
        var entry interface{} = GetValue(balances, i)
        var currencyId interface{} = this.SafeString(entry, "currency")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        AddElementToObject(account, "free", this.SafeString(entry, "balance"))
        AddElementToObject(account, "used", this.SafeString(entry, "locked"))
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name bithumb#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://apidocs.bithumb.com/v1.2.0/reference/%EB%B3%B4%EC%9C%A0%EC%9E%90%EC%82%B0-%EC%A1%B0%ED%9A%8C
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/?id=balance-structure}
 */
func  (this *BithumbCore) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes4248 := (<-this.LoadMarkets())
            PanicOnError(retRes4248)
        
            response:= (<-this.V2privateGetAccounts(params))
            PanicOnError(response)
        
            ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bithumb#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://apidocs.bithumb.com/v1.2.0/reference/%ED%98%B8%EA%B0%80-%EC%A0%95%EB%B3%B4-%EC%A1%B0%ED%9A%8C
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/?id=order-book-structure} indexed by market symbols
 */
func  (this *BithumbCore) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes4408 := (<-this.LoadMarkets())
            PanicOnError(retRes4408)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "markets": Add(Add(GetValue(market, "quote"), "-"), GetValue(market, "base")),
            }
        
            response:= (<-this.V2publicGetOrderbook(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    [
            //        {
            //            "market": "KRW-BTC",
            //            "timestamp": 1698125744837,
            //            "total_ask_size": 12.345,
            //            "total_bid_size": 23.456,
            //            "orderbook_units": [
            //                {
            //                    "ask_price": 45831000,
            //                    "bid_price": 45830000,
            //                    "ask_size": 0.123,
            //                    "bid_size": 0.234
            //                },
            //                ...
            //            ]
            //        }
            //    ]
            //
            var data interface{} = this.SafeDict(response, 0, map[string]interface{} {})
            var timestamp interface{} = this.SafeInteger(data, "timestamp")
            var orderbookUnits interface{} = this.SafeList(data, "orderbook_units", []interface{}{})
            var bids interface{} = []interface{}{}
            var asks interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(orderbookUnits)); i++ {
                var entry interface{} = GetValue(orderbookUnits, i)
                var askPrice interface{} = this.SafeNumber(entry, "ask_price")
                var askSize interface{} = this.SafeNumber(entry, "ask_size")
                var bidPrice interface{} = this.SafeNumber(entry, "bid_price")
                var bidSize interface{} = this.SafeNumber(entry, "bid_size")
                if IsTrue(IsTrue(!IsEqual(askPrice, nil)) && IsTrue(!IsEqual(askSize, nil))) {
                    if IsTrue(IsGreaterThan(askSize, 0)) {
                        AppendToArray(&asks, []interface{}{askPrice, askSize})
                    }
                }
                if IsTrue(IsTrue(!IsEqual(bidPrice, nil)) && IsTrue(!IsEqual(bidSize, nil))) {
                    if IsTrue(IsGreaterThan(bidSize, 0)) {
                        AppendToArray(&bids, []interface{}{bidPrice, bidSize})
                    }
                }
            }
        
            ch <- map[string]interface{} {
                "symbol": symbol,
                "bids": this.SortBy(bids, 0, true),
                "asks": this.SortBy(asks, 0),
                "timestamp": timestamp,
                "datetime": this.Iso8601(timestamp),
                "nonce": nil,
            }
            return nil
        
            }()
            return ch
        }
func  (this *BithumbCore) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger(ticker, "timestamp")
    if IsTrue(IsEqual(timestamp, nil)) {
        timestamp = this.SafeInteger(ticker, "trade_timestamp")
    }
    var marketId interface{} = this.SafeString(ticker, "market")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var open interface{} = this.SafeString(ticker, "opening_price")
    var close interface{} = this.SafeString(ticker, "trade_price")
    var high interface{} = this.SafeString(ticker, "high_price")
    var low interface{} = this.SafeString(ticker, "low_price")
    // workaround for Bithumb data inconsistency
    if IsTrue(!IsEqual(close, nil)) {
        if IsTrue(!IsEqual(high, nil)) {
            if IsTrue(Precise.StringLt(high, close)) {
                high = close
            }
        }
        if IsTrue(!IsEqual(low, nil)) {
            if IsTrue(Precise.StringGt(low, close)) {
                low = close
            }
        }
    }
    var baseVolume interface{} = this.SafeString(ticker, "acc_trade_volume_24h")
    var quoteVolume interface{} = this.SafeString(ticker, "acc_trade_price_24h")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": high,
        "low": low,
        "bid": nil,
        "bidVolume": nil,
        "ask": nil,
        "askVolume": nil,
        "vwap": nil,
        "open": open,
        "close": close,
        "last": close,
        "previousClose": this.SafeString(ticker, "prev_closing_price"),
        "change": this.SafeString(ticker, "change_price"),
        "percentage": this.SafeString(ticker, "change_rate"),
        "average": nil,
        "baseVolume": baseVolume,
        "quoteVolume": quoteVolume,
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name bithumb#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://apidocs.bithumb.com/v1.2.0/reference/%ED%98%84%EC%9E%AC%EA%B0%80-%EC%A0%95%EB%B3%B4-%EC%A1%B0%ED%9A%8C-all
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *BithumbCore) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes5578 := (<-this.LoadMarkets())
            PanicOnError(retRes5578)
            symbols = this.MarketSymbols(symbols)
            var marketIds interface{} = []interface{}{}
            if IsTrue(IsEqual(symbols, nil)) {
                marketIds = ObjectKeys(this.Markets_by_id)
            } else {
                marketIds = this.MarketIds(symbols)
            }
            var promises interface{} = []interface{}{}
            var chunkSize interface{} = 20 // safe chunk size
            for i := 0; IsLessThan(i, GetArrayLength(marketIds)); i = Add(i, chunkSize) {
                var chunk interface{} = Slice(marketIds, i, Add(i, chunkSize))
                var markets interface{} = []interface{}{}
                for j := 0; IsLessThan(j, GetArrayLength(chunk)); j++ {
                    var marketId interface{} = GetValue(chunk, j)
                    var market interface{} = this.SafeMarket(marketId)
                    AppendToArray(&markets, Add(Add(GetValue(market, "quote"), "-"), GetValue(market, "base")))
                }
                var marketsString interface{} = Join(markets, ",")
                AppendToArray(&promises, this.V2publicGetTicker(this.Extend(params, map[string]interface{} {
                    "markets": marketsString,
                })))
            }
        
            responses:= (<-promiseAll(promises))
            PanicOnError(responses)
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(responses)); i++ {
                var response interface{} = GetValue(responses, i)
                //
                //     {
                //         "status":"0000",
                //         "data":{
                //             "opening_price":"227100",
                //             "closing_price":"228400",
                //             "min_price":"222300",
                //             "max_price":"230000",
                //             "units_traded":"82618.56075337",
                //             "acc_trade_value":"18767376138.6031",
                //             "prev_closing_price":"227100",
                //             "units_traded_24H":"151871.13484676",
                //             "acc_trade_value_24H":"34247610416.8974",
                //             "fluctate_24H":"8700",
                //             "fluctate_rate_24H":"3.96",
                //             "date":"1587710327264", // fetchTickers inject this
                //         }
                //     }
                //
                for j := 0; IsLessThan(j, GetArrayLength(response)); j++ {
                    AppendToArray(&result, GetValue(response, j))
                }
            }
        
            ch <- this.ParseTickers(result, symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bithumb#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://apidocs.bithumb.com/v1.2.0/reference/%ED%98%84%EC%9E%AC%EA%B0%80-%EC%A0%95%EB%B3%B4-%EC%A1%B0%ED%9A%8C
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/?id=ticker-structure}
 */
func  (this *BithumbCore) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes6188 := (<-this.LoadMarkets())
            PanicOnError(retRes6188)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "markets": Add(Add(GetValue(market, "quote"), "-"), GetValue(market, "base")),
            }
        
            response:= (<-this.V2publicGetTicker(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "status":"0000",
            //         "data":{
            //             "opening_price":"227100",
            //             "closing_price":"228400",
            //             "min_price":"222300",
            //             "max_price":"230000",
            //             "units_traded":"82618.56075337",
            //             "acc_trade_value":"18767376138.6031",
            //             "prev_closing_price":"227100",
            //             "units_traded_24H":"151871.13484676",
            //             "acc_trade_value_24H":"34247610416.8974",
            //             "fluctate_24H":"8700",
            //             "fluctate_rate_24H":"3.96",
            //             "date":"1587710327264",
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, 0, map[string]interface{} {})
        
            ch <- this.ParseTicker(data, market)
            return nil
        
            }()
            return ch
        }
func  (this *BithumbCore) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.Parse8601(this.SafeString(ohlcv, "candle_date_time_utc")), this.SafeNumber(ohlcv, "opening_price"), this.SafeNumber(ohlcv, "high_price"), this.SafeNumber(ohlcv, "low_price"), this.SafeNumber(ohlcv, "trade_price"), this.SafeNumber(ohlcv, "candle_acc_trade_volume")}
}
/**
 * @method
 * @name bithumb#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://apidocs.bithumb.com/v1.2.0/reference/candlestick-rest-api
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *BithumbCore) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes6718 := (<-this.LoadMarkets())
            PanicOnError(retRes6718)
            var market interface{} = this.Market(symbol)
            var interval interface{} = this.SafeString(this.Timeframes, timeframe, timeframe)
            var request interface{} = map[string]interface{} {
                "market": Add(Add(GetValue(market, "quote"), "-"), GetValue(market, "base")),
            }
            if IsTrue(IsTrue(IsTrue(IsEqual(timeframe, "1d")) || IsTrue(IsEqual(timeframe, "1w"))) || IsTrue(IsEqual(timeframe, "1M"))) {
                AddElementToObject(request, "interval", interval)
            } else {
                AddElementToObject(request, "unit", interval)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "count", limit)
            }
            var response interface{} = nil
            if IsTrue(IsTrue(IsTrue(IsEqual(timeframe, "1d")) || IsTrue(IsEqual(timeframe, "1w"))) || IsTrue(IsEqual(timeframe, "1M"))) {
                
            response = (<-this.V2publicGetCandlesInterval(this.Extend(request, params)))
                    PanicOnError(response)
            } else {
                
            response = (<-this.V2publicGetCandlesMinutesUnit(this.Extend(request, params)))
                    PanicOnError(response)
            }
        
                //
            //    [
            //        {
            //            "market": "KRW-BTC",
            //            "candle_date_time_utc": "2023-10-24T06:35:00",
            //            "candle_date_time_kts": "2023-10-24T15:35:00",
            //            "opening_price": 45831000,
            //            "high_price": 45831000,
            //            "low_price": 45831000,
            //            "trade_price": 45831000,
            //            "timestamp": 1698125700000,
            //            "candle_acc_trade_price": 435133614.99125,
            //            "candle_acc_trade_volume": 9.4943,
            //            "unit": 1
            //        },
            //        ...
            //    ]
            //
        ch <- this.ParseOHLCVs(response, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *BithumbCore) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger(trade, "timestamp")
    var side interface{} = Ternary(IsTrue(IsEqual(this.SafeStringLower(trade, "ask_bid"), "ask")), "sell", "buy")
    var price interface{} = this.SafeString(trade, "trade_price")
    var amount interface{} = this.SafeString(trade, "trade_volume")
    var id interface{} = this.SafeString(trade, "sequential_id")
    var symbol interface{} = this.SafeSymbol(nil, market)
    return this.SafeTrade(map[string]interface{} {
        "id": id,
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "order": nil,
        "type": nil,
        "side": side,
        "takerOrMaker": nil,
        "price": price,
        "amount": amount,
        "cost": nil,
        "fee": nil,
    }, market)
}
/**
 * @method
 * @name bithumb#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://apidocs.bithumb.com/v1.2.0/reference/%EC%B5%9C%EA%B7%BC-%EC%B2%B4%EA%B2%B0-%EB%82%B4%EC%97%AD
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/?id=public-trades}
 */
func  (this *BithumbCore) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes7488 := (<-this.LoadMarkets())
            PanicOnError(retRes7488)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": Add(Add(GetValue(market, "quote"), "-"), GetValue(market, "base")),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "count", limit)
            }
        
            response:= (<-this.V2publicGetTradesTicks(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseTrades(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bithumb#createOrder
 * @description create a trade order
 * @see https://apidocs.bithumb.com/v1.2.0/reference/%EC%A7%80%EC%A0%95%EA%B0%80-%EC%A3%BC%EB%AC%B8%ED%95%98%EA%B8%B0
 * @see https://apidocs.bithumb.com/v1.2.0/reference/%EC%8B%9C%EC%9E%A5%EA%B0%80-%EB%A7%A4%EC%88%98%ED%95%98%EA%B8%B0
 * @see https://apidocs.bithumb.com/v1.2.0/reference/%EC%8B%9C%EC%9E%A5%EA%B0%80-%EB%A7%A4%EB%8F%84%ED%95%98%EA%B8%B0
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *BithumbCore) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes7768 := (<-this.LoadMarkets())
            PanicOnError(retRes7768)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": Add(Add(GetValue(market, "quote"), "-"), GetValue(market, "base")),
                "side": Ternary(IsTrue((IsEqual(side, "buy"))), "bid", "ask"),
                "volume": this.AmountToPrecision(symbol, amount),
                "ord_type": Ternary(IsTrue((IsEqual(typeVar, "limit"))), "limit", "price"),
            }
            if IsTrue(IsEqual(typeVar, "limit")) {
                AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
            }
        
            response:= (<-this.V2privatePostOrders(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bithumb#cancelOrder
 * @description cancels an open order
 * @see https://apidocs.bithumb.com/v1.2.0/reference/%EC%A3%BC%EB%AC%B8-%EC%B7%A8%EC%86%8C%ED%95%98%EA%B8%B0
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *BithumbCore) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "uuid": id,
            }
        
            response:= (<-this.V2privateDeleteOrder(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseOrder(response)
            return nil
        
            }()
            return ch
        }
func  (this *BithumbCore) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.Parse8601(this.SafeString(order, "created_at"))
    var status interface{} = this.ParseOrderStatus(this.SafeString(order, "state"))
    var symbol interface{} = this.SafeSymbol(this.SafeString(order, "market"), market)
    var side interface{} = Ternary(IsTrue(IsEqual(this.SafeStringLower(order, "side"), "bid")), "buy", "sell")
    var typeVar interface{} = this.SafeStringLower(order, "ord_type")
    var price interface{} = this.SafeString(order, "price")
    var amount interface{} = this.SafeString(order, "volume")
    var remaining interface{} = this.SafeString(order, "remaining_volume")
    var filled interface{} = this.SafeString(order, "executed_volume")
    var id interface{} = this.SafeString(order, "uuid")
    return this.SafeOrder(map[string]interface{} {
        "id": id,
        "clientOrderId": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "status": status,
        "symbol": symbol,
        "type": typeVar,
        "timeInForce": nil,
        "postOnly": nil,
        "side": side,
        "price": price,
        "stopPrice": nil,
        "triggerPrice": nil,
        "amount": amount,
        "filled": filled,
        "remaining": remaining,
        "cost": nil,
        "trades": nil,
        "fee": map[string]interface{} {
            "currency": nil,
            "cost": this.SafeString(order, "paid_fee"),
        },
        "info": order,
    }, market)
}
func  (this *BithumbCore) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "wait": "open",
        "done": "closed",
        "cancel": "canceled",
    }
    return this.SafeString(statuses, status, status)
}
/**
 * @method
 * @name bithumb#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://apidocs.bithumb.com/v1.2.0/reference/%EA%B1%B0%EB%9E%98-%EC%A3%BC%EB%AC%B8%EB%82%B4%EC%97%AD-%EC%A1%B0%ED%9A%8C
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of open order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *BithumbCore) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes8698 := (<-this.LoadMarkets())
            PanicOnError(retRes8698)
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbol, nil)) {
                var market interface{} = this.Market(symbol)
                AddElementToObject(request, "market", Add(Add(GetValue(market, "quote"), "-"), GetValue(market, "base")))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.V2privateGetOrders(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "status": "0000",
            //         "data": [
            //             {
            //                 "order_currency": "BTC",
            //                 "payment_currency": "KRW",
            //                 "order_id": "C0101000007408440032",
            //                 "order_date": "1571728739360570",
            //                 "type": "bid",
            //                 "units": "5.0",
            //                 "units_remaining": "5.0",
            //                 "price": "501000",
            //             }
            //         ]
            //     }
            //
        ch <- this.ParseOrders(response, nil, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bithumb#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://apidocs.bithumb.com/v1.2.0/reference/%EA%B1%B0%EB%9E%98-%EC%A3%BC%EB%AC%B8%EB%82%B4%EC%97%AD-%EC%83%81%EC%84%B8-%EC%A1%B0%ED%9A%8C
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/?id=order-structure}
 */
func  (this *BithumbCore) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes9108 := (<-this.LoadMarkets())
            PanicOnError(retRes9108)
            var request interface{} = map[string]interface{} {
                "uuid": id,
            }
        
            response:= (<-this.V2privateGetOrder(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseOrder(response)
            return nil
        
            }()
            return ch
        }
func  (this *BithumbCore) HandleErrors(httpCode interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsEqual(response, nil)) {
        return nil  // fallback to default error handler
    }
    if IsTrue(InOp(response, "status")) {
        //
        //     {"status":"5100","message":"After May 23th, recent_transactions is no longer, hence users will not be able to connect to recent_transactions"}
        //
        var status interface{} = this.SafeString(response, "status")
        var message interface{} = this.SafeString(response, "message")
        if IsTrue(!IsEqual(status, nil)) {
            if IsTrue(IsEqual(status, "0000")) {
                return nil  // no error
            }
            if IsTrue(IsEqual(message, "거래 진행중인 내역이 존재하지 않습니다.")) {
                // https://github.com/ccxt/ccxt/issues/9017
                return nil  // no error
            }
            var feedback interface{} = Add(Add(this.Id, " "), message)
            this.ThrowExactlyMatchedException(this.Exceptions, status, feedback)
            this.ThrowExactlyMatchedException(this.Exceptions, message, feedback)
            panic(ExchangeError(feedback))
        }
    }
    return nil
}
func  (this *BithumbCore) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var endpoint interface{} = this.ImplodeParams(path, params)
    var url interface{} = Add(Add(GetValue(GetValue(this.Urls, "api"), api), "/"), endpoint)
    var query interface{} = this.Omit(params, this.ExtractParams(path))
    if IsTrue(IsTrue(IsEqual(api, "v2public")) || IsTrue(IsEqual(api, "v2private"))) {
        if IsTrue(GetArrayLength(ObjectKeys(query))) {
            url = Add(url, Add("?", this.Urlencode(query)))
        }
        if IsTrue(IsEqual(api, "v2private")) {
            this.CheckRequiredCredentials()
            var nonce interface{} = this.Uuid()
            var timestamp interface{} = this.Milliseconds()
            var payload interface{} = map[string]interface{} {
                "access_key": this.ApiKey,
                "nonce": nonce,
                "timestamp": timestamp,
            }
            if IsTrue(GetArrayLength(ObjectKeys(query))) {
                if IsTrue(IsTrue(IsEqual(method, "GET")) || IsTrue(IsEqual(method, "DELETE"))) {
                    var queryString interface{} = this.Urlencode(query)
                    AddElementToObject(payload, "query_hash", this.Hash(this.Encode(queryString), sha512))
                    AddElementToObject(payload, "query_hash_alg", "SHA512")
                } else {
                    body = this.Json(query)
                    AddElementToObject(payload, "query_hash", this.Hash(this.Encode(body), sha512))
                    AddElementToObject(payload, "query_hash_alg", "SHA512")
                }
            }
            var token interface{} = Jwt(payload, this.Encode(this.Secret), sha256)
            headers = map[string]interface{} {
                "Authorization": Add("Bearer ", token),
            }
            if IsTrue(IsEqual(method, "POST")) {
                AddElementToObject(headers, "Content-Type", "application/json")
            }
        }
    } else {
        if IsTrue(IsEqual(api, "public")) {
            if IsTrue(GetArrayLength(ObjectKeys(query))) {
                url = Add(url, Add("?", this.Urlencode(query)))
            }
        } else {
            this.CheckRequiredCredentials()
            body = this.Urlencode(this.Extend(map[string]interface{} {
                "endpoint": Add("/", endpoint),
            }, query))
            var nonce interface{} = ToString(this.Milliseconds())
            var auth interface{} = Add(Add(Add(Add(Add("/", endpoint), ";"), body), ";"), nonce)
            var signature interface{} = this.Hmac(this.Encode(auth), this.Encode(this.Secret), sha512, "hex")
            var signature64 interface{} = this.StringToBase64(signature)
            headers = map[string]interface{} {
                "Api-Key": this.ApiKey,
                "Api-Sign": signature64,
                "Api-Nonce": nonce,
                "Content-Type": "application/x-www-form-urlencoded",
            }
        }
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
/**
 * @method
 * @name bithumb#withdraw
 * @description make a withdrawal
 * @see https://apidocs.bithumb.com/v1.2.0/reference/%EC%BD%94%EC%9D%B8-%EC%B6%9C%EA%B8%88%ED%95%98%EA%B8%B0-%EA%B0%9C%EC%9D%B8
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/?id=transaction-structure}
 */
func  (this *BithumbCore) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params);
            tag = GetValue(tagparamsVariable,0);
            params = GetValue(tagparamsVariable,1)
            this.CheckAddress(address)
        
            retRes10218 := (<-this.LoadMarkets())
            PanicOnError(retRes10218)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "units": amount,
                "address": address,
                "currency": GetValue(currency, "id"),
            }
            if IsTrue(IsTrue(IsTrue(IsTrue(IsTrue(IsEqual(code, "XRP")) || IsTrue(IsEqual(code, "XMR"))) || IsTrue(IsEqual(code, "EOS"))) || IsTrue(IsEqual(code, "STEEM"))) || IsTrue(IsEqual(code, "TON"))) {
                var destination interface{} = this.SafeString(params, "destination")
                if IsTrue(IsTrue((IsEqual(tag, nil))) && IsTrue((IsEqual(destination, nil)))) {
                    panic(ArgumentsRequired(Add(Add(Add(this.Id, " "), code), " withdraw() requires a tag argument or an extra destination param")))
                } else if IsTrue(!IsEqual(tag, nil)) {
                    AddElementToObject(request, "destination", tag)
                }
            }
        
            response:= (<-this.PrivatePostTradeBtcWithdrawal(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            // { "status" : "0000"}
            //
        ch <- this.ParseTransaction(response, currency)
            return nil
        
            }()
            return ch
        }


func (this *BithumbCore) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.DerivedExchange = this
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
}
