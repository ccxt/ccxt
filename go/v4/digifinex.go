package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type digifinex struct {
    Exchange

}

func NewDigifinexCore() digifinex {
   p := digifinex{}
   setDefaults(&p)
   return p
}

func  (this *digifinex) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "digifinex",
        "name": "DigiFinex",
        "countries": []interface{}{"SG"},
        "version": "v3",
        "rateLimit": 900,
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": true,
            "swap": true,
            "future": false,
            "option": false,
            "addMargin": true,
            "cancelOrder": true,
            "cancelOrders": true,
            "createMarketBuyOrderWithCost": true,
            "createMarketOrderWithCost": false,
            "createMarketSellOrderWithCost": false,
            "createOrder": true,
            "createOrders": true,
            "createPostOnlyOrder": true,
            "createReduceOnlyOrder": true,
            "createStopLimitOrder": false,
            "createStopMarketOrder": false,
            "createStopOrder": false,
            "fetchBalance": true,
            "fetchBorrowInterest": true,
            "fetchBorrowRateHistories": false,
            "fetchBorrowRateHistory": false,
            "fetchCrossBorrowRate": true,
            "fetchCrossBorrowRates": true,
            "fetchCurrencies": true,
            "fetchDepositAddress": true,
            "fetchDepositAddresses": false,
            "fetchDepositAddressesByNetwork": false,
            "fetchDeposits": true,
            "fetchDepositWithdrawFee": "emulated",
            "fetchDepositWithdrawFees": true,
            "fetchFundingHistory": true,
            "fetchFundingInterval": true,
            "fetchFundingIntervals": false,
            "fetchFundingRate": true,
            "fetchFundingRateHistory": true,
            "fetchFundingRates": false,
            "fetchIndexOHLCV": false,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchLedger": true,
            "fetchLeverage": false,
            "fetchLeverageTiers": true,
            "fetchMarginMode": false,
            "fetchMarketLeverageTiers": true,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrders": true,
            "fetchPosition": true,
            "fetchPositionMode": false,
            "fetchPositions": true,
            "fetchPositionsRisk": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchStatus": true,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTime": true,
            "fetchTrades": true,
            "fetchTradingFee": true,
            "fetchTradingFees": false,
            "fetchTransfers": true,
            "fetchWithdrawals": true,
            "reduceMargin": true,
            "setLeverage": true,
            "setMargin": false,
            "setMarginMode": true,
            "setPositionMode": false,
            "transfer": true,
            "withdraw": true,
        },
        "timeframes": map[string]interface{} {
            "1m": "1",
            "5m": "5",
            "15m": "15",
            "30m": "30",
            "1h": "60",
            "4h": "240",
            "12h": "720",
            "1d": "1D",
            "1w": "1W",
        },
        "urls": map[string]interface{} {
            "logo": "https://user-images.githubusercontent.com/51840849/87443315-01283a00-c5fe-11ea-8628-c2a0feaf07ac.jpg",
            "api": map[string]interface{} {
                "rest": "https://openapi.digifinex.com",
            },
            "www": "https://www.digifinex.com",
            "doc": []interface{}{"https://docs.digifinex.com"},
            "fees": "https://digifinex.zendesk.com/hc/en-us/articles/360000328422-Fee-Structure-on-DigiFinex",
            "referral": "https://www.digifinex.com/en-ww/from/DhOzBg?channelCode=ljaUPp",
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "spot": map[string]interface{} {
                    "get": []interface{}{"{market}/symbols", "kline", "margin/currencies", "margin/symbols", "markets", "order_book", "ping", "spot/symbols", "time", "trades", "trades/symbols", "ticker", "currencies"},
                },
                "swap": map[string]interface{} {
                    "get": []interface{}{"public/api_weight", "public/candles", "public/candles_history", "public/depth", "public/funding_rate", "public/funding_rate_history", "public/instrument", "public/instruments", "public/ticker", "public/tickers", "public/time", "public/trades"},
                },
            },
            "private": map[string]interface{} {
                "spot": map[string]interface{} {
                    "get": []interface{}{"{market}/financelog", "{market}/mytrades", "{market}/order", "{market}/order/detail", "{market}/order/current", "{market}/order/history", "margin/assets", "margin/financelog", "margin/mytrades", "margin/order", "margin/order/current", "margin/order/history", "margin/positions", "otc/financelog", "spot/assets", "spot/financelog", "spot/mytrades", "spot/order", "spot/order/current", "spot/order/history", "deposit/address", "deposit/history", "withdraw/history"},
                    "post": []interface{}{"{market}/order/cancel", "{market}/order/new", "{market}/order/batch_new", "margin/order/cancel", "margin/order/new", "margin/position/close", "spot/order/cancel", "spot/order/new", "transfer", "withdraw/new", "withdraw/cancel"},
                },
                "swap": map[string]interface{} {
                    "get": []interface{}{"account/balance", "account/positions", "account/finance_record", "account/trading_fee_rate", "account/transfer_record", "account/funding_fee", "trade/history_orders", "trade/history_trades", "trade/open_orders", "trade/order_info"},
                    "post": []interface{}{"account/transfer", "account/leverage", "account/position_mode", "account/position_margin", "trade/batch_cancel_order", "trade/batch_order", "trade/cancel_order", "trade/order_place", "follow/sponsor_order", "follow/close_order", "follow/cancel_order", "follow/user_center_current", "follow/user_center_history", "follow/expert_current_open_order", "follow/add_algo", "follow/cancel_algo", "follow/account_available", "follow/plan_task", "follow/instrument_list"},
                },
            },
        },
        "features": map[string]interface{} {
            "default": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": true,
                    "triggerPrice": false,
                    "triggerPriceType": nil,
                    "triggerDirection": false,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": false,
                        "FOK": false,
                        "PO": true,
                        "GTD": false,
                    },
                    "hedged": false,
                    "selfTradePrevention": false,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyByCost": false,
                    "marketBuyRequiresPrice": false,
                    "iceberg": false,
                },
                "createOrders": map[string]interface{} {
                    "max": 10,
                },
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": true,
                    "limit": 500,
                    "daysBack": 100000,
                    "untilDays": 30,
                    "symbolRequired": false,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": true,
                    "trigger": false,
                    "trailing": false,
                    "marketType": true,
                    "symbolRequired": true,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": true,
                    "limit": nil,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOrders": map[string]interface{} {
                    "marginMode": true,
                    "limit": 100,
                    "daysBack": 100000,
                    "untilDays": 30,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchClosedOrders": nil,
                "fetchOHLCV": map[string]interface{} {
                    "limit": 500,
                },
            },
            "spot": map[string]interface{} {
                "extends": "default",
            },
            "forDerivatives": map[string]interface{} {
                "extends": "default",
                "createOrders": map[string]interface{} {
                    "max": 20,
                    "marginMode": false,
                },
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": 100000,
                    "untilDays": 100000,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                },
                "fetchOrders": map[string]interface{} {
                    "marginMode": false,
                    "daysBack": 100000,
                },
                "fetchOHLCV": map[string]interface{} {
                    "limit": 100,
                },
            },
            "swap": map[string]interface{} {
                "linear": map[string]interface{} {
                    "extends": "forDerivatives",
                },
                "inverse": map[string]interface{} {
                    "extends": "forDerivatives",
                },
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "tierBased": true,
                "percentage": true,
                "maker": this.ParseNumber("0.002"),
                "taker": this.ParseNumber("0.002"),
            },
        },
        "precisionMode": TICK_SIZE,
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "10001": []interface{}{BadRequest, "Wrong request method, please check it\\'s a GET ot POST request"},
                "10002": []interface{}{AuthenticationError, "Invalid ApiKey"},
                "10003": []interface{}{AuthenticationError, "Sign doesn\\'t match"},
                "10004": []interface{}{BadRequest, "Illegal request parameters"},
                "10005": []interface{}{DDoSProtection, "Request frequency exceeds the limit"},
                "10006": []interface{}{PermissionDenied, "Unauthorized to execute this request"},
                "10007": []interface{}{PermissionDenied, "IP address Unauthorized"},
                "10008": []interface{}{InvalidNonce, "Timestamp for this request is invalid, timestamp must within 1 minute"},
                "10009": []interface{}{NetworkError, "Unexist endpoint, please check endpoint URL"},
                "10011": []interface{}{AccountSuspended, "ApiKey expired. Please go to client side to re-create an ApiKey"},
                "20001": []interface{}{PermissionDenied, "Trade is not open for this trading pair"},
                "20002": []interface{}{PermissionDenied, "Trade of this trading pair is suspended"},
                "20003": []interface{}{InvalidOrder, "Invalid price or amount"},
                "20007": []interface{}{InvalidOrder, "Price precision error"},
                "20008": []interface{}{InvalidOrder, "Amount precision error"},
                "20009": []interface{}{InvalidOrder, "Amount is less than the minimum requirement"},
                "20010": []interface{}{InvalidOrder, "Cash Amount is less than the minimum requirement"},
                "20011": []interface{}{InsufficientFunds, "Insufficient balance"},
                "20012": []interface{}{BadRequest, "Invalid trade type, valid value: buy/sell)"},
                "20013": []interface{}{InvalidOrder, "No order info found"},
                "20014": []interface{}{BadRequest, "Invalid date, Valid format: 2018-07-25)"},
                "20015": []interface{}{BadRequest, "Date exceeds the limit"},
                "20018": []interface{}{PermissionDenied, "Your trading rights have been banned by the system"},
                "20019": []interface{}{BadSymbol, "Wrong trading pair symbol. Correct format:\"usdt_btc\". Quote asset is in the front"},
                "20020": []interface{}{DDoSProtection, "You have violated the API operation trading rules and temporarily forbid trading. At present, we have certain restrictions on the user\\'s transaction rate and withdrawal rate."},
                "50000": []interface{}{ExchangeError, "Exception error"},
                "20021": []interface{}{BadRequest, "Invalid currency"},
                "20022": []interface{}{BadRequest, "The ending timestamp must be larger than the starting timestamp"},
                "20023": []interface{}{BadRequest, "Invalid transfer type"},
                "20024": []interface{}{BadRequest, "Invalid amount"},
                "20025": []interface{}{BadRequest, "This currency is not transferable at the moment"},
                "20026": []interface{}{InsufficientFunds, "Transfer amount exceed your balance"},
                "20027": []interface{}{PermissionDenied, "Abnormal account status"},
                "20028": []interface{}{PermissionDenied, "Blacklist for transfer"},
                "20029": []interface{}{PermissionDenied, "Transfer amount exceed your daily limit"},
                "20030": []interface{}{BadRequest, "You have no position on this trading pair"},
                "20032": []interface{}{PermissionDenied, "Withdrawal limited"},
                "20033": []interface{}{BadRequest, "Wrong Withdrawal ID"},
                "20034": []interface{}{PermissionDenied, "Withdrawal service of this crypto has been closed"},
                "20035": []interface{}{PermissionDenied, "Withdrawal limit"},
                "20036": []interface{}{ExchangeError, "Withdrawal cancellation failed"},
                "20037": []interface{}{InvalidAddress, "The withdrawal address, Tag or chain type is not included in the withdrawal management list"},
                "20038": []interface{}{InvalidAddress, "The withdrawal address is not on the white list"},
                "20039": []interface{}{ExchangeError, "Can\\'t be canceled in current status"},
                "20040": []interface{}{RateLimitExceeded, "Withdraw too frequently; limitation: 3 times a minute, 100 times a day"},
                "20041": []interface{}{PermissionDenied, "Beyond the daily withdrawal limit"},
                "20042": []interface{}{BadSymbol, "Current trading pair does not support API trading"},
                "400002": []interface{}{BadRequest, "Invalid Parameter"},
            },
            "broad": map[string]interface{} {},
        },
        "options": map[string]interface{} {
            "defaultType": "spot",
            "types": []interface{}{"spot", "margin", "otc"},
            "createMarketBuyOrderRequiresPrice": true,
            "accountsByType": map[string]interface{} {
                "spot": "1",
                "margin": "2",
                "OTC": "3",
            },
            "networks": map[string]interface{} {
                "ARBITRUM": "Arbitrum",
                "AVALANCEC": "AVAX-CCHAIN",
                "AVALANCEX": "AVAX-XCHAIN",
                "BEP20": "BEP20",
                "BSC": "BEP20",
                "CARDANO": "Cardano",
                "CELO": "Celo",
                "CHILIZ": "Chiliz",
                "COSMOS": "COSMOS",
                "CRC20": "Crypto.com",
                "CRONOS": "Crypto.com",
                "DOGECOIN": "DogeChain",
                "ERC20": "ERC20",
                "ETH": "ERC20",
                "ETHW": "ETHW",
                "IOTA": "MIOTA",
                "KLAYTN": "KLAY",
                "MATIC": "Polygon",
                "METIS": "MetisDAO",
                "MOONBEAM": "GLMR",
                "MOONRIVER": "Moonriver",
                "OPTIMISM": "OPETH",
                "POLYGON": "Polygon",
                "RIPPLE": "XRP",
                "SOLANA": "SOL",
                "STELLAR": "Stella",
                "TERRACLASSIC": "TerraClassic",
                "TERRA": "Terra",
                "TON": "Ton",
                "TRC20": "TRC20",
                "TRON": "TRC20",
                "TRX": "TRC20",
                "VECHAIN": "Vechain",
            },
        },
        "commonCurrencies": map[string]interface{} {
            "BHT": "Black House Test",
            "EPS": "Epanus",
            "FREE": "FreeRossDAO",
            "MBN": "Mobilian Coin",
            "TEL": "TEL666",
        },
    })
}
/**
 * @method
 * @name digifinex#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func  (this *digifinex) FetchCurrencies(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicSpotGetCurrencies(params))
            PanicOnError(response)
            //
            //     {
            //         "data":[
            //             {
            //                 "deposit_status":1,
            //                 "min_deposit_amount":10,
            //                 "withdraw_fee_rate":0,
            //                 "min_withdraw_amount":10,
            //                 "min_withdraw_fee":5,
            //                 "currency":"USDT",
            //                 "withdraw_status":0,
            //                 "chain":"OMNI"
            //             },
            //             {
            //                 "deposit_status":1,
            //                 "min_deposit_amount":10,
            //                 "withdraw_fee_rate":0,
            //                 "min_withdraw_amount":10,
            //                 "min_withdraw_fee":3,
            //                 "currency":"USDT",
            //                 "withdraw_status":1,
            //                 "chain":"ERC20"
            //             },
            //             {
            //                 "deposit_status":0,
            //                 "min_deposit_amount":0,
            //                 "withdraw_fee_rate":0,
            //                 "min_withdraw_amount":0,
            //                 "min_withdraw_fee":0,
            //                 "currency":"DGF13",
            //                 "withdraw_status":0,
            //                 "chain":""
            //             },
            //         ],
            //         "code":200
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", []interface{}{})
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
                var currency interface{} = GetValue(data, i)
                var id interface{} = this.SafeString(currency, "currency")
                var code interface{} = this.SafeCurrencyCode(id)
                var depositStatus interface{} = this.SafeInteger(currency, "deposit_status", 1)
                var withdrawStatus interface{} = this.SafeInteger(currency, "withdraw_status", 1)
                var deposit interface{} = IsGreaterThan(depositStatus, 0)
                var withdraw interface{} = IsGreaterThan(withdrawStatus, 0)
                var active interface{} = IsTrue(deposit) && IsTrue(withdraw)
                var feeString interface{} = this.SafeString(currency, "min_withdraw_fee") // withdraw_fee_rate was zero for all currencies, so this was the worst case scenario
                var minWithdrawString interface{} = this.SafeString(currency, "min_withdraw_amount")
                var minDepositString interface{} = this.SafeString(currency, "min_deposit_amount")
                var minDeposit interface{} = this.ParseNumber(minDepositString)
                var minWithdraw interface{} = this.ParseNumber(minWithdrawString)
                var fee interface{} = this.ParseNumber(feeString)
                // define precision with temporary way
                var minFoundPrecision interface{} = Precise.StringMin(feeString, Precise.StringMin(minDepositString, minWithdrawString))
                var precision interface{} = this.ParseNumber(minFoundPrecision)
                var networkId interface{} = this.SafeString(currency, "chain")
                var networkCode interface{} = nil
                if IsTrue(!IsEqual(networkId, nil)) {
                    networkCode = this.NetworkIdToCode(networkId)
                }
                var network interface{} = map[string]interface{} {
                    "info": currency,
                    "id": networkId,
                    "network": networkCode,
                    "active": active,
                    "fee": fee,
                    "precision": precision,
                    "deposit": deposit,
                    "withdraw": withdraw,
                    "limits": map[string]interface{} {
                        "amount": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "withdraw": map[string]interface{} {
                            "min": minWithdraw,
                            "max": nil,
                        },
                        "deposit": map[string]interface{} {
                            "min": minDeposit,
                            "max": nil,
                        },
                    },
                }
                if IsTrue(InOp(result, code)) {
                    var resultCodeInfo interface{} = GetValue(GetValue(result, code), "info")
                    if IsTrue(IsArray(resultCodeInfo)) {
                        AppendToArray(&resultCodeInfo,currency)
                    } else {
                        resultCodeInfo = []interface{}{resultCodeInfo, currency}
                    }
                    if IsTrue(withdraw) {
                        AddElementToObject(GetValue(result, code), "withdraw", true)
                        AddElementToObject(GetValue(GetValue(GetValue(result, code), "limits"), "withdraw"), "min", mathMin(GetValue(GetValue(GetValue(GetValue(result, code), "limits"), "withdraw"), "min"), minWithdraw))
                    }
                    if IsTrue(deposit) {
                        AddElementToObject(GetValue(result, code), "deposit", true)
                        AddElementToObject(GetValue(GetValue(GetValue(result, code), "limits"), "deposit"), "min", mathMin(GetValue(GetValue(GetValue(GetValue(result, code), "limits"), "deposit"), "min"), minDeposit))
                    }
                    if IsTrue(active) {
                        AddElementToObject(GetValue(result, code), "active", true)
                    }
                } else {
                    AddElementToObject(result, code, map[string]interface{} {
            "id": id,
            "code": code,
            "info": currency,
            "type": nil,
            "name": nil,
            "active": active,
            "deposit": deposit,
            "withdraw": withdraw,
            "fee": this.ParseNumber(feeString),
            "precision": nil,
            "limits": map[string]interface{} {
                "amount": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
                "withdraw": map[string]interface{} {
                    "min": minWithdraw,
                    "max": nil,
                },
                "deposit": map[string]interface{} {
                    "min": minDeposit,
                    "max": nil,
                },
            },
            "networks": map[string]interface{} {},
        })
                }
                if IsTrue(!IsEqual(networkId, nil)) {
                    AddElementToObject(GetValue(GetValue(result, code), "networks"), networkId, network)
                } else {
                    AddElementToObject(GetValue(result, code), "active", active)
                    AddElementToObject(GetValue(result, code), "fee", this.ParseNumber(feeString))
                    AddElementToObject(GetValue(result, code), "deposit", deposit)
                    AddElementToObject(GetValue(result, code), "withdraw", withdraw)
                    AddElementToObject(GetValue(result, code), "limits", map[string]interface{} {
            "amount": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "withdraw": map[string]interface{} {
                "min": minWithdraw,
                "max": nil,
            },
            "deposit": map[string]interface{} {
                "min": minDeposit,
                "max": nil,
            },
        })
                }
                AddElementToObject(GetValue(result, code), "precision", Ternary(IsTrue((IsEqual(GetValue(GetValue(result, code), "precision"), nil))), precision, mathMax(GetValue(GetValue(result, code), "precision"), precision)))
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name digifinex#fetchMarkets
 * @description retrieves data on all markets for digifinex
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *digifinex) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var options interface{} = this.SafeValue(this.Options, "fetchMarkets", map[string]interface{} {})
            var method interface{} = this.SafeString(options, "method", "fetch_markets_v2")
            if IsTrue(IsEqual(method, "fetch_markets_v2")) {
        
                    retRes64219 :=  (<-this.FetchMarketsV2(params))
                    PanicOnError(retRes64219)
                    ch <- retRes64219
                    return nil
            }
        
                retRes64415 :=  (<-this.FetchMarketsV1(params))
                PanicOnError(retRes64415)
                ch <- retRes64415
                return nil
        
            }()
            return ch
        }
func  (this *digifinex) FetchMarketsV2(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var defaultType interface{} = this.SafeString(this.Options, "defaultType")
            marginModequeryVariable := this.HandleMarginModeAndParams("fetchMarketsV2", params);
            marginMode := GetValue(marginModequeryVariable,0);
            query := GetValue(marginModequeryVariable,1)
            var promisesRaw interface{} = []interface{}{}
            if IsTrue(!IsEqual(marginMode, nil)) {
                AppendToArray(&promisesRaw,this.PublicSpotGetMarginSymbols(query))
            } else {
                AppendToArray(&promisesRaw,this.PublicSpotGetTradesSymbols(query))
            }
            AppendToArray(&promisesRaw,this.PublicSwapGetPublicInstruments(params))
        
            promises:= (<-promiseAll(promisesRaw))
            PanicOnError(promises)
            var spotMarkets interface{} = GetValue(promises, 0)
            var swapMarkets interface{} = GetValue(promises, 1)
            //
            // spot and margin
            //
            //     {
            //         "symbol_list":[
            //             {
            //                 "order_types":["LIMIT","MARKET"],
            //                 "quote_asset":"USDT",
            //                 "minimum_value":2,
            //                 "amount_precision":4,
            //                 "status":"TRADING",
            //                 "minimum_amount":0.0001,
            //                 "symbol":"BTC_USDT",
            //                 "is_allow":1,
            //                 "zone":"MAIN",
            //                 "base_asset":"BTC",
            //                 "price_precision":2
            //             }
            //         ],
            //         "code":0
            //     }
            //
            // swap
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "instrument_id": "BTCUSDTPERP",
            //                 "type": "REAL",
            //                 "contract_type": "PERPETUAL",
            //                 "base_currency": "BTC",
            //                 "quote_currency": "USDT",
            //                 "clear_currency": "USDT",
            //                 "contract_value": "0.001",
            //                 "contract_value_currency": "BTC",
            //                 "is_inverse": false,
            //                 "is_trading": true,
            //                 "status": "ONLINE",
            //                 "price_precision": 4,
            //                 "tick_size": "0.0001",
            //                 "min_order_amount": 1,
            //                 "open_max_limits": [
            //                     {
            //                         "leverage": "50",
            //                         "max_limit": "1000000"
            //                     }
            //                 ]
            //             },
            //         ]
            //     }
            //
            var spotData interface{} = this.SafeValue(spotMarkets, "symbol_list", []interface{}{})
            var swapData interface{} = this.SafeValue(swapMarkets, "data", []interface{}{})
            var response interface{} = this.ArrayConcat(spotData, swapData)
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
                var market interface{} = GetValue(response, i)
                var id interface{} = this.SafeString2(market, "symbol", "instrument_id")
                var baseId interface{} = this.SafeString2(market, "base_asset", "base_currency")
                var quoteId interface{} = this.SafeString2(market, "quote_asset", "quote_currency")
                var settleId interface{} = this.SafeString(market, "clear_currency")
                var base interface{} = this.SafeCurrencyCode(baseId)
                var quote interface{} = this.SafeCurrencyCode(quoteId)
                var settle interface{} = this.SafeCurrencyCode(settleId)
                //
                // The status is documented in the exchange API docs as follows:
                // TRADING, HALT (delisted), BREAK (trading paused)
                // https://docs.digifinex.vip/en-ww/v3/#/public/spot/symbols
                // However, all spot markets actually have status === 'HALT'
                // despite that they appear to be active on the exchange website.
                // Apparently, we can't trust this status.
                // const status = this.safeString (market, 'status');
                // const active = (status === 'TRADING');
                //
                var isAllowed interface{} = this.SafeInteger(market, "is_allow", 1)
                var typeVar interface{} = Ternary(IsTrue((IsEqual(defaultType, "margin"))), "margin", "spot")
                var spot interface{} = IsEqual(settle, nil)
                var swap interface{} =         !IsTrue(spot)
                var margin interface{} = Ternary(IsTrue((!IsEqual(marginMode, nil))), true, nil)
                var symbol interface{} = Add(Add(base, "/"), quote)
                var isInverse interface{} = nil
                var isLinear interface{} = nil
                if IsTrue(swap) {
                    typeVar = "swap"
                    symbol = Add(Add(Add(Add(base, "/"), quote), ":"), settle)
                    isInverse = this.SafeValue(market, "is_inverse")
                    isLinear = Ternary(IsTrue((!IsTrue(isInverse))), true, false)
                    var isTrading interface{} = this.SafeValue(market, "isTrading")
                    if IsTrue(isTrading) {
                        isAllowed = 1
                    }
                }
                AppendToArray(&result,map[string]interface{} {
                    "id": id,
                    "symbol": symbol,
                    "base": base,
                    "quote": quote,
                    "settle": settle,
                    "baseId": baseId,
                    "quoteId": quoteId,
                    "settleId": settleId,
                    "type": typeVar,
                    "spot": spot,
                    "margin": margin,
                    "swap": swap,
                    "future": false,
                    "option": false,
                    "active": Ternary(IsTrue(isAllowed), true, false),
                    "contract": swap,
                    "linear": isLinear,
                    "inverse": isInverse,
                    "contractSize": this.SafeNumber(market, "contract_value"),
                    "expiry": nil,
                    "expiryDatetime": nil,
                    "strike": nil,
                    "optionType": nil,
                    "precision": map[string]interface{} {
                        "amount": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "amount_precision"))),
                        "price": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "price_precision"))),
                    },
                    "limits": map[string]interface{} {
                        "leverage": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "amount": map[string]interface{} {
                            "min": this.SafeNumber2(market, "minimum_amount", "min_order_amount"),
                            "max": nil,
                        },
                        "price": map[string]interface{} {
                            "min": this.SafeNumber(market, "tick_size"),
                            "max": nil,
                        },
                        "cost": map[string]interface{} {
                            "min": this.SafeNumber(market, "minimum_value"),
                            "max": nil,
                        },
                    },
                    "created": nil,
                    "info": market,
                })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *digifinex) FetchMarketsV1(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicSpotGetMarkets(params))
            PanicOnError(response)
            //
            //     {
            //         "data": [
            //             {
            //                 "volume_precision":4,
            //                 "price_precision":2,
            //                 "market":"btc_usdt",
            //                 "min_amount":2,
            //                 "min_volume":0.0001
            //             },
            //         ],
            //         "date":1564507456,
            //         "code":0
            //     }
            //
            var markets interface{} = this.SafeValue(response, "data", []interface{}{})
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(markets)); i++ {
                var market interface{} = GetValue(markets, i)
                var id interface{} = this.SafeString(market, "market")
                baseIdquoteIdVariable := Split(id, "_");
                baseId := GetValue(baseIdquoteIdVariable,0);
                quoteId := GetValue(baseIdquoteIdVariable,1)
                var base interface{} = this.SafeCurrencyCode(baseId)
                var quote interface{} = this.SafeCurrencyCode(quoteId)
                AppendToArray(&result,map[string]interface{} {
                    "id": id,
                    "symbol": Add(Add(base, "/"), quote),
                    "base": base,
                    "quote": quote,
                    "settle": nil,
                    "baseId": baseId,
                    "quoteId": quoteId,
                    "settleId": nil,
                    "type": "spot",
                    "spot": true,
                    "margin": nil,
                    "swap": false,
                    "future": false,
                    "option": false,
                    "active": nil,
                    "contract": false,
                    "linear": nil,
                    "inverse": nil,
                    "contractSize": nil,
                    "expiry": nil,
                    "expiryDatetime": nil,
                    "strike": nil,
                    "optionType": nil,
                    "precision": map[string]interface{} {
                        "price": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "price_precision"))),
                        "amount": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "volume_precision"))),
                    },
                    "limits": map[string]interface{} {
                        "leverage": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "amount": map[string]interface{} {
                            "min": this.SafeNumber(market, "min_volume"),
                            "max": nil,
                        },
                        "price": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "cost": map[string]interface{} {
                            "min": this.SafeNumber(market, "min_amount"),
                            "max": nil,
                        },
                    },
                    "info": market,
                })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *digifinex) ParseBalance(response interface{}) interface{}  {
    //
    // spot and margin
    //
    //     {
    //         "currency": "BTC",
    //         "free": 4723846.89208129,
    //         "total": 0
    //     }
    //
    // swap
    //
    //     {
    //         "equity": "0",
    //         "currency": "BTC",
    //         "margin": "0",
    //         "frozen_margin": "0",
    //         "frozen_money": "0",
    //         "margin_ratio": "0",
    //         "realized_pnl": "0",
    //         "avail_balance": "0",
    //         "unrealized_pnl": "0",
    //         "time_stamp": 1661487402396
    //     }
    //
    var result interface{} = map[string]interface{} {
        "info": response,
    }
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        var balance interface{} = GetValue(response, i)
        var currencyId interface{} = this.SafeString(balance, "currency")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        var free interface{} = this.SafeString2(balance, "free", "avail_balance")
        var total interface{} = this.SafeString2(balance, "total", "equity")
        AddElementToObject(account, "free", free)
        AddElementToObject(account, "used", Precise.StringSub(total, free))
        AddElementToObject(account, "total", total)
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name digifinex#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://docs.digifinex.com/en-ww/spot/v3/rest.html#spot-account-assets
 * @see https://docs.digifinex.com/en-ww/spot/v3/rest.html#margin-assets
 * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#accountbalance
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *digifinex) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes9358 := (<-this.LoadMarkets())
            PanicOnError(retRes9358)
            var marketType interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchBalance", nil, params);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            marginModequeryVariable := this.HandleMarginModeAndParams("fetchBalance", params);
            marginMode := GetValue(marginModequeryVariable,0);
            query := GetValue(marginModequeryVariable,1)
            var response interface{} = nil
            if IsTrue(IsTrue(!IsEqual(marginMode, nil)) || IsTrue(IsEqual(marketType, "margin"))) {
                marketType = "margin"
                
        response = (<-this.PrivateSpotGetMarginAssets(query))
                PanicOnError(response)
            } else if IsTrue(IsEqual(marketType, "spot")) {
                
        response = (<-this.PrivateSpotGetSpotAssets(query))
                PanicOnError(response)
            } else if IsTrue(IsEqual(marketType, "swap")) {
                
        response = (<-this.PrivateSwapGetAccountBalance(query))
                PanicOnError(response)
            } else {
                panic(NotSupported(Add(this.Id, " fetchBalance() not support this market type")))
            }
            //
            // spot and margin
            //
            //     {
            //         "code": 0,
            //         "list": [
            //             {
            //                 "currency": "BTC",
            //                 "free": 4723846.89208129,
            //                 "total": 0
            //             },
            //             ...
            //         ]
            //     }
            //
            // swap
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "equity": "0",
            //                 "currency": "BTC",
            //                 "margin": "0",
            //                 "frozen_margin": "0",
            //                 "frozen_money": "0",
            //                 "margin_ratio": "0",
            //                 "realized_pnl": "0",
            //                 "avail_balance": "0",
            //                 "unrealized_pnl": "0",
            //                 "time_stamp": 1661487402396
            //             },
            //             ...
            //         ]
            //     }
            //
            var balanceRequest interface{} = Ternary(IsTrue((IsEqual(marketType, "swap"))), "data", "list")
            var balances interface{} = this.SafeValue(response, balanceRequest, []interface{}{})
        
            ch <- this.ParseBalance(balances)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name digifinex#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://docs.digifinex.com/en-ww/spot/v3/rest.html#get-orderbook
 * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#orderbook
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *digifinex) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes10038 := (<-this.LoadMarkets())
            PanicOnError(retRes10038)
            var market interface{} = this.Market(symbol)
            marketTypequeryVariable := this.HandleMarketTypeAndParams("fetchOrderBook", market, params);
            marketType := GetValue(marketTypequeryVariable,0);
            query := GetValue(marketTypequeryVariable,1)
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            var response interface{} = nil
            if IsTrue(IsEqual(marketType, "swap")) {
                AddElementToObject(request, "instrument_id", GetValue(market, "id"))
                
        response = (<-this.PublicSwapGetPublicDepth(this.Extend(request, query)))
                PanicOnError(response)
            } else {
                AddElementToObject(request, "symbol", GetValue(market, "id"))
                
        response = (<-this.PublicSpotGetOrderBook(this.Extend(request, query)))
                PanicOnError(response)
            }
            //
            // spot
            //
            //     {
            //         "bids": [
            //             [9605.77,0.0016],
            //             [9605.46,0.0003],
            //             [9602.04,0.0127],
            //         ],
            //         "asks": [
            //             [9627.22,0.025803],
            //             [9627.12,0.168543],
            //             [9626.52,0.0011529],
            //         ],
            //         "date":1564509499,
            //         "code":0
            //     }
            //
            // swap
            //
            //     {
            //         "code": 0,
            //         "data": {
            //             "instrument_id": "BTCUSDTPERP",
            //             "timestamp": 1667975290425,
            //             "asks": [
            //                 ["18384.7",3492],
            //                 ["18402.7",5000],
            //                 ["18406.7",5000],
            //             ],
            //             "bids": [
            //                 ["18366.2",4395],
            //                 ["18364.3",3070],
            //                 ["18359.4",5000],
            //             ]
            //         }
            //     }
            //
            var timestamp interface{} = nil
            var orderBook interface{} = nil
            if IsTrue(IsEqual(marketType, "swap")) {
                orderBook = this.SafeValue(response, "data", map[string]interface{} {})
                timestamp = this.SafeInteger(orderBook, "timestamp")
            } else {
                orderBook = response
                timestamp = this.SafeTimestamp(response, "date")
            }
        
            ch <- this.ParseOrderBook(orderBook, GetValue(market, "symbol"), timestamp)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name digifinex#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://docs.digifinex.com/en-ww/spot/v3/rest.html#ticker-price
 * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#tickers
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *digifinex) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes10798 := (<-this.LoadMarkets())
            PanicOnError(retRes10798)
            symbols = this.MarketSymbols(symbols)
            var first interface{} = this.SafeString(symbols, 0)
            var market interface{} = nil
            if IsTrue(!IsEqual(first, nil)) {
                market = this.Market(first)
            }
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchTickers", market, params);
            typeVar = GetValue(typeVarparamsVariable,0);
            params = GetValue(typeVarparamsVariable,1)
            var request interface{} = map[string]interface{} {}
            var response interface{} = nil
            if IsTrue(IsEqual(typeVar, "swap")) {
                
        response = (<-this.PublicSwapGetPublicTickers(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PublicSpotGetTicker(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            // spot
            //
            //    {
            //        "ticker": [{
            //            "vol": 40717.4461,
            //            "change": -1.91,
            //            "base_vol": 392447999.65374,
            //            "sell": 9592.23,
            //            "last": 9592.22,
            //            "symbol": "btc_usdt",
            //            "low": 9476.24,
            //            "buy": 9592.03,
            //            "high": 9793.87
            //        }],
            //        "date": 1589874294,
            //        "code": 0
            //    }
            //
            // swap
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "instrument_id": "SUSHIUSDTPERP",
            //                 "index_price": "1.1297",
            //                 "mark_price": "1.1289",
            //                 "max_buy_price": "1.1856",
            //                 "min_sell_price": "1.0726",
            //                 "best_bid": "1.1278",
            //                 "best_bid_size": "500",
            //                 "best_ask": "1.1302",
            //                 "best_ask_size": "471",
            //                 "high_24h": "1.2064",
            //                 "open_24h": "1.1938",
            //                 "low_24h": "1.1239",
            //                 "last": "1.1302",
            //                 "last_qty": "29",
            //                 "volume_24h": "4946163",
            //                 "price_change_percent": "-0.053275255486681085",
            //                 "open_interest": "-",
            //                 "timestamp": 1663222782100
            //             },
            //             ...
            //         ]
            //     }
            //
            var result interface{} = map[string]interface{} {}
            var tickers interface{} = this.SafeValue2(response, "ticker", "data", []interface{}{})
            var date interface{} = this.SafeInteger(response, "date")
            for i := 0; IsLessThan(i, GetArrayLength(tickers)); i++ {
                var rawTicker interface{} = this.Extend(map[string]interface{} {
                    "date": date,
                }, GetValue(tickers, i))
                var ticker interface{} = this.ParseTicker(rawTicker)
                var symbol interface{} = GetValue(ticker, "symbol")
                AddElementToObject(result, symbol, ticker)
            }
        
            ch <- this.FilterByArrayTickers(result, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name digifinex#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://docs.digifinex.com/en-ww/spot/v3/rest.html#ticker-price
 * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#ticker
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *digifinex) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes11688 := (<-this.LoadMarkets())
            PanicOnError(retRes11688)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {}
            var response interface{} = nil
            if IsTrue(GetValue(market, "swap")) {
                AddElementToObject(request, "instrument_id", GetValue(market, "id"))
                
        response = (<-this.PublicSwapGetPublicTicker(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                AddElementToObject(request, "symbol", GetValue(market, "id"))
                
        response = (<-this.PublicSpotGetTicker(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            // spot
            //
            //    {
            //        "ticker": [{
            //            "vol": 40717.4461,
            //            "change": -1.91,
            //            "base_vol": 392447999.65374,
            //            "sell": 9592.23,
            //            "last": 9592.22,
            //            "symbol": "btc_usdt",
            //            "low": 9476.24,
            //            "buy": 9592.03,
            //            "high": 9793.87
            //        }],
            //        "date": 1589874294,
            //        "code": 0
            //    }
            //
            // swap
            //
            //     {
            //         "code": 0,
            //         "data": {
            //             "instrument_id": "BTCUSDTPERP",
            //             "index_price": "20141.9967",
            //             "mark_price": "20139.3404",
            //             "max_buy_price": "21146.4838",
            //             "min_sell_price": "19132.2725",
            //             "best_bid": "20140.0998",
            //             "best_bid_size": "3116",
            //             "best_ask": "20140.0999",
            //             "best_ask_size": "9004",
            //             "high_24h": "20410.6496",
            //             "open_24h": "20308.6998",
            //             "low_24h": "19600",
            //             "last": "20140.0999",
            //             "last_qty": "2",
            //             "volume_24h": "49382816",
            //             "price_change_percent": "-0.008301855936636448",
            //             "open_interest": "-",
            //             "timestamp": 1663221614998
            //         }
            //     }
            //
            var date interface{} = this.SafeInteger(response, "date")
            var tickers interface{} = this.SafeValue(response, "ticker", []interface{}{})
            var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
            var firstTicker interface{} = this.SafeValue(tickers, 0, map[string]interface{} {})
            var result interface{} = nil
            if IsTrue(GetValue(market, "swap")) {
                result = data
            } else {
                result = this.Extend(map[string]interface{} {
                    "date": date,
                }, firstTicker)
            }
        
            ch <- this.ParseTicker(result, market)
            return nil
        
            }()
            return ch
        }
func  (this *digifinex) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // spot: fetchTicker, fetchTickers
    //
    //     {
    //         "last":0.021957,
    //         "symbol": "btc_usdt",
    //         "base_vol":2249.3521732227,
    //         "change":-0.6,
    //         "vol":102443.5111,
    //         "sell":0.021978,
    //         "low":0.021791,
    //         "buy":0.021946,
    //         "high":0.022266,
    //         "date"1564518452, // injected from fetchTicker/fetchTickers
    //     }
    //
    // swap: fetchTicker, fetchTickers
    //
    //     {
    //         "instrument_id": "BTCUSDTPERP",
    //         "index_price": "20141.9967",
    //         "mark_price": "20139.3404",
    //         "max_buy_price": "21146.4838",
    //         "min_sell_price": "19132.2725",
    //         "best_bid": "20140.0998",
    //         "best_bid_size": "3116",
    //         "best_ask": "20140.0999",
    //         "best_ask_size": "9004",
    //         "high_24h": "20410.6496",
    //         "open_24h": "20308.6998",
    //         "low_24h": "19600",
    //         "last": "20140.0999",
    //         "last_qty": "2",
    //         "volume_24h": "49382816",
    //         "price_change_percent": "-0.008301855936636448",
    //         "open_interest": "-",
    //         "timestamp": 1663221614998
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var indexPrice interface{} = this.SafeNumber(ticker, "index_price")
    var marketType interface{} = Ternary(IsTrue((!IsEqual(indexPrice, nil))), "contract", "spot")
    var marketId interface{} = this.SafeStringUpper2(ticker, "symbol", "instrument_id")
    var symbol interface{} = this.SafeSymbol(marketId, market, nil, marketType)
    market = this.SafeMarket(marketId, market, nil, marketType)
    var timestamp interface{} = this.SafeTimestamp(ticker, "date")
    if IsTrue(GetValue(market, "swap")) {
        timestamp = this.SafeInteger(ticker, "timestamp")
    }
    var last interface{} = this.SafeString(ticker, "last")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeString2(ticker, "high", "high_24h"),
        "low": this.SafeString2(ticker, "low", "low_24h"),
        "bid": this.SafeString2(ticker, "buy", "best_bid"),
        "bidVolume": this.SafeString(ticker, "best_bid_size"),
        "ask": this.SafeString2(ticker, "sell", "best_ask"),
        "askVolume": this.SafeString(ticker, "best_ask_size"),
        "vwap": nil,
        "open": this.SafeString(ticker, "open_24h"),
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": nil,
        "percentage": this.SafeString2(ticker, "change", "price_change_percent"),
        "average": nil,
        "baseVolume": this.SafeString2(ticker, "vol", "volume_24h"),
        "quoteVolume": this.SafeString(ticker, "base_vol"),
        "markPrice": this.SafeString(ticker, "mark_price"),
        "indexPrice": indexPrice,
        "info": ticker,
    }, market)
}
func  (this *digifinex) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // spot: fetchTrades
    //
    //     {
    //         "date":1564520003,
    //         "id":1596149203,
    //         "amount":0.7073,
    //         "type":"buy",
    //         "price":0.02193,
    //     }
    //
    // swap: fetchTrades
    //
    //     {
    //         "instrument_id": "BTCUSDTPERP",
    //         "trade_id": "1595190773677035521",
    //         "direction": "4",
    //         "volume": "4",
    //         "price": "16188.3",
    //         "trade_time": 1669158092314
    //     }
    //
    // spot: fetchMyTrades
    //
    //     {
    //         "symbol": "BTC_USDT",
    //         "order_id": "6707cbdcda0edfaa7f4ab509e4cbf966",
    //         "id": 28457,
    //         "price": 0.1,
    //         "amount": 0,
    //         "fee": 0.096,
    //         "fee_currency": "USDT",
    //         "timestamp": 1499865549,
    //         "side": "buy", // or "side": "sell_market"
    //         "is_maker": true
    //     }
    //
    // swap: fetchMyTrades
    //
    //     {
    //         "trade_id": "1590136768424841218",
    //         "instrument_id": "BTCUSDTPERP",
    //         "order_id": "1590136768156405760",
    //         "type": 1,
    //         "order_type": 8,
    //         "price": "18514.5",
    //         "size": "1",
    //         "fee": "0.00925725",
    //         "close_profit": "0",
    //         "leverage": "20",
    //         "trade_type": 0,
    //         "match_role": 1,
    //         "trade_time": 1667953123562
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeString2(trade, "id", "trade_id")
    var orderId interface{} = this.SafeString(trade, "order_id")
    var priceString interface{} = this.SafeString(trade, "price")
    var amountString interface{} = this.SafeStringN(trade, []interface{}{"amount", "volume", "size"})
    var marketId interface{} = this.SafeStringUpper2(trade, "symbol", "instrument_id")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    if IsTrue(IsEqual(market, nil)) {
        market = this.SafeMarket(marketId)
    }
    var timestamp interface{} = this.SafeTimestamp2(trade, "date", "timestamp")
    var side interface{} = this.SafeString2(trade, "type", "side")
    var typeVar interface{} = nil
    var takerOrMaker interface{} = nil
    if IsTrue(IsEqual(GetValue(market, "type"), "swap")) {
        timestamp = this.SafeInteger(trade, "trade_time")
        var orderType interface{} = this.SafeString(trade, "order_type")
        var tradeRole interface{} = this.SafeString(trade, "match_role")
        var direction interface{} = this.SafeString(trade, "direction")
        if IsTrue(!IsEqual(orderType, nil)) {
            typeVar = Ternary(IsTrue((IsEqual(orderType, "0"))), "limit", nil)
        }
        if IsTrue(IsEqual(tradeRole, "1")) {
            takerOrMaker = "taker"
        } else if IsTrue(IsEqual(tradeRole, "2")) {
            takerOrMaker = "maker"
        } else {
            takerOrMaker = nil
        }
        if IsTrue(IsTrue((IsEqual(side, "1"))) || IsTrue((IsEqual(direction, "1")))) {
            // side = 'open long';
            side = "buy"
        } else if IsTrue(IsTrue((IsEqual(side, "2"))) || IsTrue((IsEqual(direction, "2")))) {
            // side = 'open short';
            side = "sell"
        } else if IsTrue(IsTrue((IsEqual(side, "3"))) || IsTrue((IsEqual(direction, "3")))) {
            // side = 'close long';
            side = "sell"
        } else if IsTrue(IsTrue((IsEqual(side, "4"))) || IsTrue((IsEqual(direction, "4")))) {
            // side = 'close short';
            side = "buy"
        }
    } else {
        var parts interface{} = Split(side, "_")
        side = this.SafeString(parts, 0)
        typeVar = this.SafeString(parts, 1)
        if IsTrue(IsEqual(typeVar, nil)) {
            typeVar = "limit"
        }
        var isMaker interface{} = this.SafeValue(trade, "is_maker")
        takerOrMaker = Ternary(IsTrue(isMaker), "maker", "taker")
    }
    var fee interface{} = nil
    var feeCostString interface{} = this.SafeString(trade, "fee")
    if IsTrue(!IsEqual(feeCostString, nil)) {
        var feeCurrencyId interface{} = this.SafeString(trade, "fee_currency")
        var feeCurrencyCode interface{} = nil
        if IsTrue(!IsEqual(feeCurrencyId, nil)) {
            feeCurrencyCode = this.SafeCurrencyCode(feeCurrencyId)
        }
        fee = map[string]interface{} {
            "cost": feeCostString,
            "currency": feeCurrencyCode,
        }
    }
    return this.SafeTrade(map[string]interface{} {
        "id": id,
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "type": typeVar,
        "order": orderId,
        "side": side,
        "price": priceString,
        "amount": amountString,
        "cost": nil,
        "takerOrMaker": takerOrMaker,
        "fee": fee,
    }, market)
}
/**
 * @method
 * @name digifinex#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func  (this *digifinex) FetchTime(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicSpotGetTime(params))
            PanicOnError(response)
        
                //
            //     {
            //         "server_time": 1589873762,
            //         "code": 0
            //     }
            //
        ch <- this.SafeTimestamp(response, "server_time")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name digifinex#fetchStatus
 * @description the latest known information on the availability of the exchange API
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [status structure]{@link https://docs.ccxt.com/#/?id=exchange-status-structure}
 */
func  (this *digifinex) FetchStatus(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicSpotGetPing(params))
            PanicOnError(response)
            //
            //     {
            //         "msg": "pong",
            //         "code": 0
            //     }
            //
            var code interface{} = this.SafeInteger(response, "code")
            var status interface{} = Ternary(IsTrue((IsEqual(code, 0))), "ok", "maintenance")
        
            ch <- map[string]interface{} {
                "status": status,
                "updated": nil,
                "eta": nil,
                "url": nil,
                "info": response,
            }
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name digifinex#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://docs.digifinex.com/en-ww/spot/v3/rest.html#get-recent-trades
 * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#recenttrades
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *digifinex) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes15078 := (<-this.LoadMarkets())
            PanicOnError(retRes15078)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", Ternary(IsTrue(GetValue(market, "swap")), mathMin(limit, 100), limit))
            }
            var response interface{} = nil
            if IsTrue(GetValue(market, "swap")) {
                AddElementToObject(request, "instrument_id", GetValue(market, "id"))
                
        response = (<-this.PublicSwapGetPublicTrades(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                AddElementToObject(request, "symbol", GetValue(market, "id"))
                
        response = (<-this.PublicSpotGetTrades(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            // spot
            //
            //     {
            //         "data":[
            //             {
            //                 "date":1564520003,
            //                 "id":1596149203,
            //                 "amount":0.7073,
            //                 "type":"buy",
            //                 "price":0.02193,
            //             },
            //             {
            //                 "date":1564520002,
            //                 "id":1596149165,
            //                 "amount":0.3232,
            //                 "type":"sell",
            //                 "price":0.021927,
            //             },
            //         ],
            //         "code": 0,
            //         "date": 1564520003,
            //     }
            //
            // swap
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "instrument_id": "BTCUSDTPERP",
            //                 "trade_id": "1595190773677035521",
            //                 "direction": "4",
            //                 "volume": "4",
            //                 "price": "16188.3",
            //                 "trade_time": 1669158092314
            //             },
            //             ...
            //         ]
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTrades(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *digifinex) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     [
    //         1556712900,
    //         2205.899,
    //         0.029967,
    //         0.02997,
    //         0.029871,
    //         0.029927
    //     ]
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    if IsTrue(GetValue(market, "swap")) {
        return []interface{}{this.SafeInteger(ohlcv, 0), this.SafeNumber(ohlcv, 1), this.SafeNumber(ohlcv, 2), this.SafeNumber(ohlcv, 3), this.SafeNumber(ohlcv, 4), this.SafeNumber(ohlcv, 5)}
    } else {
        return []interface{}{this.SafeTimestamp(ohlcv, 0), this.SafeNumber(ohlcv, 5), this.SafeNumber(ohlcv, 3), this.SafeNumber(ohlcv, 4), this.SafeNumber(ohlcv, 2), this.SafeNumber(ohlcv, 1)}
    }
}
/**
 * @method
 * @name digifinex#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://docs.digifinex.com/en-ww/spot/v3/rest.html#get-candles-data
 * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#recentcandle
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest candle to fetch
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *digifinex) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes16138 := (<-this.LoadMarkets())
            PanicOnError(retRes16138)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {}
            var response interface{} = nil
            if IsTrue(GetValue(market, "swap")) {
                AddElementToObject(request, "instrument_id", GetValue(market, "id"))
                AddElementToObject(request, "granularity", timeframe)
                if IsTrue(!IsEqual(limit, nil)) {
                    AddElementToObject(request, "limit", mathMin(limit, 100))
                }
                
        response = (<-this.PublicSwapGetPublicCandles(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                var until interface{} = this.SafeInteger(params, "until")
                AddElementToObject(request, "symbol", GetValue(market, "id"))
                AddElementToObject(request, "period", this.SafeString(this.Timeframes, timeframe, timeframe))
                var startTime interface{} = since
                var duration interface{} = this.ParseTimeframe(timeframe)
                if IsTrue(IsEqual(startTime, nil)) {
                    if IsTrue(IsTrue((!IsEqual(limit, nil))) || IsTrue((!IsEqual(until, nil)))) {
                        var endTime interface{} = Ternary(IsTrue((!IsEqual(until, nil))), until, this.Milliseconds())
                        var startLimit interface{} = Ternary(IsTrue((!IsEqual(limit, nil))), limit, 200)
                        startTime = Subtract(endTime, (Multiply(Multiply(startLimit, duration), 1000)))
                    }
                }
                if IsTrue(!IsEqual(startTime, nil)) {
                    startTime = this.ParseToInt(Divide(startTime, 1000))
                    AddElementToObject(request, "start_time", startTime)
                    if IsTrue(IsTrue((!IsEqual(limit, nil))) || IsTrue((!IsEqual(until, nil)))) {
                        if IsTrue(!IsEqual(until, nil)) {
                            var endByUntil interface{} = this.ParseToInt(Divide(until, 1000))
                            if IsTrue(!IsEqual(limit, nil)) {
                                var endByLimit interface{} = this.Sum(startTime, Multiply(limit, duration))
                                AddElementToObject(request, "end_time", mathMin(endByLimit, endByUntil))
                            } else {
                                AddElementToObject(request, "end_time", endByUntil)
                            }
                        } else {
                            AddElementToObject(request, "end_time", this.Sum(startTime, Multiply(limit, duration)))
                        }
                    }
                }
                params = this.Omit(params, "until")
                
        response = (<-this.PublicSpotGetKline(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            // spot
            //
            //     {
            //         "code":0,
            //         "data":[
            //             [1556712900,2205.899,0.029967,0.02997,0.029871,0.029927],
            //             [1556713800,1912.9174,0.029992,0.030014,0.029955,0.02996],
            //             [1556714700,1556.4795,0.029974,0.030019,0.029969,0.02999],
            //         ]
            //     }
            //
            // swap
            //
            //     {
            //         "code": 0,
            //         "data": {
            //             "instrument_id": "BTCUSDTPERP",
            //             "granularity": "1m",
            //             "candles": [
            //                 [1588089660000,"6900","6900","6900","6900","0","0"],
            //                 [1588089720000,"6900","6900","6900","6900","0","0"],
            //                 [1588089780000,"6900","6900","6900","6900","0","0"],
            //             ]
            //         }
            //     }
            //
            var candles interface{} = nil
            if IsTrue(GetValue(market, "swap")) {
                var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
                candles = this.SafeValue(data, "candles", []interface{}{})
            } else {
                candles = this.SafeValue(response, "data", []interface{}{})
            }
        
            ch <- this.ParseOHLCVs(candles, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name digifinex#createOrder
 * @description create a trade order
 * @see https://docs.digifinex.com/en-ww/spot/v3/rest.html#create-new-order
 * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#orderplace
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much you want to trade in units of the base currency, spot market orders use the quote currency, swap requires the number of contracts
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.timeInForce] "GTC", "IOC", "FOK", or "PO"
 * @param {bool} [params.postOnly] true or false
 * @param {bool} [params.reduceOnly] true or false
 * @param {string} [params.marginMode] 'cross' or 'isolated', for spot margin trading
 * @param {float} [params.cost] *spot market buy only* the quote quantity that can be used as an alternative for the amount
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *digifinex) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes17148 := (<-this.LoadMarkets())
            PanicOnError(retRes17148)
            var market interface{} = this.Market(symbol)
            var marginResult interface{} = this.HandleMarginModeAndParams("createOrder", params)
            var marginMode interface{} = GetValue(marginResult, 0)
            var request interface{} = this.CreateOrderRequest(symbol, typeVar, side, amount, price, params)
            var response interface{} = nil
            if IsTrue(GetValue(market, "swap")) {
                
        response = (<-this.PrivateSwapPostTradeOrderPlace(request))
                PanicOnError(response)
            } else {
                if IsTrue(!IsEqual(marginMode, nil)) {
                    
        response = (<-this.PrivateSpotPostMarginOrderNew(request))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.PrivateSpotPostSpotOrderNew(request))
                    PanicOnError(response)
                }
            }
            //
            // spot and margin
            //
            //     {
            //         "code": 0,
            //         "order_id": "198361cecdc65f9c8c9bb2fa68faec40"
            //     }
            //
            // swap
            //
            //     {
            //         "code": 0,
            //         "data": "1590873693003714560"
            //     }
            //
            var order interface{} = this.ParseOrder(response, market)
            AddElementToObject(order, "symbol", GetValue(market, "symbol"))
            AddElementToObject(order, "type", typeVar)
            AddElementToObject(order, "side", side)
            AddElementToObject(order, "amount", amount)
            AddElementToObject(order, "price", price)
        
            ch <- order
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name digifinex#createOrders
 * @description create a list of trade orders (all orders should be of the same symbol)
 * @see https://docs.digifinex.com/en-ww/spot/v3/rest.html#create-multiple-order
 * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#batchorder
 * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *digifinex) CreateOrders(orders interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes17648 := (<-this.LoadMarkets())
            PanicOnError(retRes17648)
            var ordersRequests interface{} = []interface{}{}
            var symbol interface{} = nil
            var marginMode interface{} = nil
            for i := 0; IsLessThan(i, GetArrayLength(orders)); i++ {
                var rawOrder interface{} = GetValue(orders, i)
                var marketId interface{} = this.SafeString(rawOrder, "symbol")
                if IsTrue(IsEqual(symbol, nil)) {
                    symbol = marketId
                } else {
                    if IsTrue(!IsEqual(symbol, marketId)) {
                        panic(BadRequest(Add(this.Id, " createOrders() requires all orders to have the same symbol")))
                    }
                }
                var typeVar interface{} = this.SafeString(rawOrder, "type")
                var side interface{} = this.SafeString(rawOrder, "side")
                var amount interface{} = this.SafeValue(rawOrder, "amount")
                var price interface{} = this.SafeValue(rawOrder, "price")
                var orderParams interface{} = this.SafeValue(rawOrder, "params", map[string]interface{} {})
                var marginResult interface{} = this.HandleMarginModeAndParams("createOrders", orderParams)
                var currentMarginMode interface{} = GetValue(marginResult, 0)
                if IsTrue(!IsEqual(currentMarginMode, nil)) {
                    if IsTrue(IsEqual(marginMode, nil)) {
                        marginMode = currentMarginMode
                    } else {
                        if IsTrue(!IsEqual(marginMode, currentMarginMode)) {
                            panic(BadRequest(Add(this.Id, " createOrders() requires all orders to have the same margin mode (isolated or cross)")))
                        }
                    }
                }
                var orderRequest interface{} = this.CreateOrderRequest(marketId, typeVar, side, amount, price, orderParams)
                AppendToArray(&ordersRequests,orderRequest)
            }
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {}
            var response interface{} = nil
            if IsTrue(GetValue(market, "swap")) {
                
        response = (<-this.PrivateSwapPostTradeBatchOrder(ordersRequests))
                PanicOnError(response)
            } else {
                AddElementToObject(request, "market", Ternary(IsTrue((!IsEqual(marginMode, nil))), "margin", "spot"))
                AddElementToObject(request, "symbol", GetValue(market, "id"))
                AddElementToObject(request, "list", this.Json(ordersRequests))
                
        response = (<-this.PrivateSpotPostMarketOrderBatchNew(request))
                PanicOnError(response)
            }
            //
            // spot
            //
            //     {
            //         "code": 0,
            //         "order_ids": [
            //             "064290fbe2d26e7b28d7e6c0a5cf70a5",
            //             "24c8f9b73d81e4d9d8d7e3280281c258"
            //         ]
            //     }
            //
            // swap
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             "1720297963537829888",
            //             "1720297963537829889"
            //         ]
            //     }
            //
            var data interface{} = []interface{}{}
            if IsTrue(GetValue(market, "swap")) {
                data = this.SafeValue(response, "data", []interface{}{})
            } else {
                data = this.SafeValue(response, "order_ids", []interface{}{})
            }
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(orders)); i++ {
                var rawOrder interface{} = GetValue(orders, i)
                var individualOrder interface{} = map[string]interface{} {}
                AddElementToObject(individualOrder, "order_id", GetValue(data, i))
                AddElementToObject(individualOrder, "instrument_id", GetValue(market, "id"))
                AddElementToObject(individualOrder, "amount", this.SafeNumber(rawOrder, "amount"))
                AddElementToObject(individualOrder, "price", this.SafeNumber(rawOrder, "price"))
                AppendToArray(&result,individualOrder)
            }
        
            ch <- this.ParseOrders(result, market)
            return nil
        
            }()
            return ch
        }
func  (this *digifinex) CreateOrderRequest(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @method
    * @ignore
    * @name digifinex#createOrderRequest
    * @description helper function to build request
    * @param {string} symbol unified symbol of the market to create an order in
    * @param {string} type 'market' or 'limit'
    * @param {string} side 'buy' or 'sell'
    * @param {float} amount how much you want to trade in units of the base currency, spot market orders use the quote currency, swap requires the number of contracts
    * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @returns {object} request to be sent to the exchange
    */
    price := GetArg(optionalArgs, 0, nil)
    _ = price
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    var market interface{} = this.Market(symbol)
    var marketType interface{} = nil
    var marginMode interface{} = nil
    marketTypeparamsVariable := this.HandleMarketTypeAndParams("createOrderRequest", market, params);
    marketType = GetValue(marketTypeparamsVariable,0);
    params = GetValue(marketTypeparamsVariable,1)
    marginModeparamsVariable := this.HandleMarginModeAndParams("createOrderRequest", params);
    marginMode = GetValue(marginModeparamsVariable,0);
    params = GetValue(marginModeparamsVariable,1)
    if IsTrue(!IsEqual(marginMode, nil)) {
        marketType = "margin"
    }
    var request interface{} = map[string]interface{} {}
    var swap interface{} =     (IsEqual(marketType, "swap"))
    var isMarketOrder interface{} =     (IsEqual(typeVar, "market"))
    var isLimitOrder interface{} =     (IsEqual(typeVar, "limit"))
    var marketIdRequest interface{} = Ternary(IsTrue(swap), "instrument_id", "symbol")
    AddElementToObject(request, marketIdRequest, GetValue(market, "id"))
    var postOnly interface{} = this.IsPostOnly(isMarketOrder, false, params)
    var postOnlyParsed interface{} = nil
    if IsTrue(swap) {
        var reduceOnly interface{} = this.SafeBool(params, "reduceOnly", false)
        var timeInForce interface{} = this.SafeString(params, "timeInForce")
        var orderType interface{} = nil
        if IsTrue(IsEqual(side, "buy")) {
            var requestType interface{} = Ternary(IsTrue((reduceOnly)), 4, 1)
            AddElementToObject(request, "type", requestType)
        } else {
            var requestType interface{} = Ternary(IsTrue((reduceOnly)), 3, 2)
            AddElementToObject(request, "type", requestType)
        }
        if IsTrue(isLimitOrder) {
            orderType = 0
        }
        if IsTrue(IsEqual(timeInForce, "FOK")) {
            orderType = Ternary(IsTrue(isMarketOrder), 15, 9)
        } else if IsTrue(IsEqual(timeInForce, "IOC")) {
            orderType = Ternary(IsTrue(isMarketOrder), 13, 4)
        } else if IsTrue(IsTrue((IsEqual(timeInForce, "GTC"))) || IsTrue((isMarketOrder))) {
            orderType = 14
        } else if IsTrue(IsEqual(timeInForce, "PO")) {
            postOnly = true
        }
        if IsTrue(!IsEqual(price, nil)) {
            AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
        }
        AddElementToObject(request, "order_type", orderType)
        AddElementToObject(request, "size", amount) // swap orders require the amount to be the number of contracts
        params = this.Omit(params, []interface{}{"reduceOnly", "timeInForce"})
    } else {
        postOnlyParsed = Ternary(IsTrue((IsEqual(postOnly, true))), 1, 2)
        AddElementToObject(request, "market", marketType)
        var suffix interface{} = ""
        if IsTrue(IsEqual(typeVar, "market")) {
            suffix = "_market"
        } else {
            AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
        }
        AddElementToObject(request, "type", Add(side, suffix))
        // limit orders require the amount in the base currency, market orders require the amount in the quote currency
        var quantity interface{} = nil
        var createMarketBuyOrderRequiresPrice interface{} = true
        createMarketBuyOrderRequiresPriceparamsVariable := this.HandleOptionAndParams(params, "createOrderRequest", "createMarketBuyOrderRequiresPrice", true);
        createMarketBuyOrderRequiresPrice = GetValue(createMarketBuyOrderRequiresPriceparamsVariable,0);
        params = GetValue(createMarketBuyOrderRequiresPriceparamsVariable,1)
        if IsTrue(IsTrue(isMarketOrder) && IsTrue((IsEqual(side, "buy")))) {
            var cost interface{} = this.SafeNumber(params, "cost")
            params = this.Omit(params, "cost")
            if IsTrue(!IsEqual(cost, nil)) {
                quantity = this.CostToPrecision(symbol, cost)
            } else if IsTrue(createMarketBuyOrderRequiresPrice) {
                if IsTrue(IsEqual(price, nil)) {
                    panic(InvalidOrder(Add(this.Id, " createOrder() requires a price argument for market buy orders on spot markets to calculate the total amount to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend in the amount argument")))
                } else {
                    var amountString interface{} = this.NumberToString(amount)
                    var priceString interface{} = this.NumberToString(price)
                    var costRequest interface{} = this.ParseNumber(Precise.StringMul(amountString, priceString))
                    quantity = this.CostToPrecision(symbol, costRequest)
                }
            } else {
                quantity = this.CostToPrecision(symbol, amount)
            }
        } else {
            quantity = this.AmountToPrecision(symbol, amount)
        }
        AddElementToObject(request, "amount", quantity)
    }
    if IsTrue(postOnly) {
        if IsTrue(postOnlyParsed) {
            AddElementToObject(request, "post_only", postOnlyParsed)
        } else {
            AddElementToObject(request, "post_only", postOnly)
        }
    }
    params = this.Omit(params, []interface{}{"postOnly"})
    return this.Extend(request, params)
}
/**
 * @method
 * @name digifinex#createMarketBuyOrderWithCost
 * @description create a market buy order by providing the symbol and cost
 * @see https://docs.digifinex.com/en-ww/spot/v3/rest.html#create-new-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {float} cost how much you want to trade in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *digifinex) CreateMarketBuyOrderWithCost(symbol interface{}, cost interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes19658 := (<-this.LoadMarkets())
            PanicOnError(retRes19658)
            var market interface{} = this.Market(symbol)
            if !IsTrue(GetValue(market, "spot")) {
                panic(NotSupported(Add(this.Id, " createMarketBuyOrderWithCost() supports spot orders only")))
            }
            AddElementToObject(params, "createMarketBuyOrderRequiresPrice", false)
        
                retRes197115 :=  (<-this.CreateOrder(symbol, "market", "buy", cost, nil, params))
                PanicOnError(retRes197115)
                ch <- retRes197115
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name digifinex#cancelOrder
 * @description cancels an open order
 * @see https://docs.digifinex.com/en-ww/spot/v3/rest.html#cancel-order
 * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#cancelorder
 * @param {string} id order id
 * @param {string} symbol not used by digifinex cancelOrder ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *digifinex) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes19868 := (<-this.LoadMarkets())
            PanicOnError(retRes19868)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            id = ToString(id)
            var marketType interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("cancelOrder", market, params);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            var request interface{} = map[string]interface{} {
                "order_id": id,
            }
            if IsTrue(IsEqual(marketType, "swap")) {
                if IsTrue(IsEqual(symbol, nil)) {
                    panic(ArgumentsRequired(Add(this.Id, " cancelOrder() requires a symbol argument")))
                }
                AddElementToObject(request, "instrument_id", GetValue(market, "id"))
            } else {
                AddElementToObject(request, "market", marketType)
            }
            marginModequeryVariable := this.HandleMarginModeAndParams("cancelOrder", params);
            marginMode := GetValue(marginModequeryVariable,0);
            query := GetValue(marginModequeryVariable,1)
            var response interface{} = nil
            if IsTrue(IsTrue(!IsEqual(marginMode, nil)) || IsTrue(IsEqual(marketType, "margin"))) {
                marketType = "margin"
                
        response = (<-this.PrivateSpotPostMarginOrderCancel(this.Extend(request, query)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(marketType, "spot")) {
                
        response = (<-this.PrivateSpotPostSpotOrderCancel(this.Extend(request, query)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(marketType, "swap")) {
                
        response = (<-this.PrivateSwapPostTradeCancelOrder(this.Extend(request, query)))
                PanicOnError(response)
            } else {
                panic(NotSupported(Add(this.Id, " cancelOrder() not support this market type")))
            }
            //
            // spot and margin
            //
            //     {
            //         "code": 0,
            //         "success": [
            //             "198361cecdc65f9c8c9bb2fa68faec40",
            //             "3fb0d98e51c18954f10d439a9cf57de0"
            //         ],
            //         "error": [
            //             "78a7104e3c65cc0c5a212a53e76d0205"
            //         ]
            //     }
            //
            // swap
            //
            //     {
            //         "code": 0,
            //         "data": "1590923061186531328"
            //     }
            //
            if IsTrue(IsTrue((IsEqual(marketType, "spot"))) || IsTrue((IsEqual(marketType, "margin")))) {
                var canceledOrders interface{} = this.SafeValue(response, "success", []interface{}{})
                var numCanceledOrders interface{} =         GetArrayLength(canceledOrders)
                if IsTrue(!IsEqual(numCanceledOrders, 1)) {
                    panic(OrderNotFound(Add(Add(Add(this.Id, " cancelOrder() "), id), " not found")))
                }
                var orders interface{} = this.ParseCancelOrders(response)
        
                ch <- this.SafeDict(orders, 0)
                return nil
            } else {
        
                ch <- this.SafeOrder(map[string]interface{} {
                    "info": response,
                    "orderId": this.SafeString(response, "data"),
                })
                return nil
            }
                return nil
            }()
            return ch
        }
func  (this *digifinex) ParseCancelOrders(response interface{}) interface{}  {
    var success interface{} = this.SafeList(response, "success")
    var error interface{} = this.SafeList(response, "error")
    var result interface{} = []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(success)); i++ {
        var order interface{} = GetValue(success, i)
        AppendToArray(&result,this.SafeOrder(map[string]interface{} {
            "info": order,
            "id": order,
            "status": "canceled",
        }))
    }
    for i := 0; IsLessThan(i, GetArrayLength(error)); i++ {
        var order interface{} = GetValue(error, i)
        AppendToArray(&result,this.SafeOrder(map[string]interface{} {
            "info": order,
            "id": this.SafeString2(order, "order-id", "order_id"),
            "status": "failed",
            "clientOrderId": this.SafeString(order, "client-order-id"),
        }))
    }
    return result
}
/**
 * @method
 * @name digifinex#cancelOrders
 * @description cancel multiple orders
 * @param {string[]} ids order ids
 * @param {string} symbol not used by digifinex cancelOrders ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *digifinex) CancelOrders(ids interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes20888 := (<-this.LoadMarkets())
            PanicOnError(retRes20888)
            var defaultType interface{} = this.SafeString(this.Options, "defaultType", "spot")
            var orderType interface{} = this.SafeString(params, "type", defaultType)
            params = this.Omit(params, "type")
            var request interface{} = map[string]interface{} {
                "market": orderType,
                "order_id": Join(ids, ","),
            }
        
            response:= (<-this.PrivateSpotPostSpotOrderCancel(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "code": 0,
            //         "success": [
            //             "198361cecdc65f9c8c9bb2fa68faec40",
            //             "3fb0d98e51c18954f10d439a9cf57de0"
            //         ],
            //         "error": [
            //             "78a7104e3c65cc0c5a212a53e76d0205"
            //         ]
            //     }
            //
        ch <- this.ParseCancelOrders(response)
            return nil
        
            }()
            return ch
        }
func  (this *digifinex) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "0": "open",
        "1": "open",
        "2": "closed",
        "3": "canceled",
        "4": "canceled",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *digifinex) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // spot: createOrder
    //
    //     {
    //         "code": 0,
    //         "order_id": "198361cecdc65f9c8c9bb2fa68faec40"
    //     }
    //
    // swap: createOrder
    //
    //     {
    //         "code": 0,
    //         "data": "1590873693003714560"
    //     }
    //
    // spot and swap: createOrders
    //
    //     {
    //         "order_id": "d64d92a5e0a120f792f385485bc3d95b",
    //         "instrument_id": "BTC_USDT",
    //         "amount": 0.0001,
    //         "price": 27000
    //     }
    //
    // spot: fetchOrder, fetchOpenOrders, fetchOrders
    //
    //     {
    //         "symbol": "BTC_USDT",
    //         "order_id": "dd3164b333a4afa9d5730bb87f6db8b3",
    //         "created_date": 1562303547,
    //         "finished_date": 0,
    //         "price": 0.1,
    //         "amount": 1,
    //         "cash_amount": 1,
    //         "executed_amount": 0,
    //         "avg_price": 0,
    //         "status": 1,
    //         "type": "buy",
    //         "kind": "margin"
    //     }
    //
    // swap: fetchOrder, fetchOpenOrders, fetchOrders
    //
    //     {
    //         "order_id": "1590898207657824256",
    //         "instrument_id": "BTCUSDTPERP",
    //         "margin_mode": "crossed",
    //         "contract_val": "0.001",
    //         "type": 1,
    //         "order_type": 0,
    //         "price": "14000",
    //         "size": "6",
    //         "filled_qty": "0",
    //         "price_avg": "0",
    //         "fee": "0",
    //         "state": 0,
    //         "leverage": "20",
    //         "turnover": "0",
    //         "has_stop": 0,
    //         "insert_time": 1668134664828,
    //         "time_stamp": 1668134664828
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = nil
    var lastTradeTimestamp interface{} = nil
    var timeInForce interface{} = nil
    var typeVar interface{} = nil
    var side interface{} = this.SafeString(order, "type")
    var marketId interface{} = this.SafeString2(order, "symbol", "instrument_id")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    market = this.Market(symbol)
    if IsTrue(IsEqual(GetValue(market, "type"), "swap")) {
        var orderType interface{} = this.SafeInteger(order, "order_type")
        if IsTrue(!IsEqual(orderType, nil)) {
            if IsTrue(IsTrue(IsTrue(IsTrue(IsTrue((IsEqual(orderType, 9))) || IsTrue((IsEqual(orderType, 10)))) || IsTrue((IsEqual(orderType, 11)))) || IsTrue((IsEqual(orderType, 12)))) || IsTrue((IsEqual(orderType, 15)))) {
                timeInForce = "FOK"
            } else if IsTrue(IsTrue(IsTrue(IsTrue(IsTrue((IsEqual(orderType, 1))) || IsTrue((IsEqual(orderType, 2)))) || IsTrue((IsEqual(orderType, 3)))) || IsTrue((IsEqual(orderType, 4)))) || IsTrue((IsEqual(orderType, 13)))) {
                timeInForce = "IOC"
            } else if IsTrue(IsTrue(IsTrue(IsTrue((IsEqual(orderType, 6))) || IsTrue((IsEqual(orderType, 7)))) || IsTrue((IsEqual(orderType, 8)))) || IsTrue((IsEqual(orderType, 14)))) {
                timeInForce = "GTC"
            }
            if IsTrue(IsTrue(IsTrue(IsTrue(IsTrue(IsTrue((IsEqual(orderType, 0))) || IsTrue((IsEqual(orderType, 1)))) || IsTrue((IsEqual(orderType, 4)))) || IsTrue((IsEqual(orderType, 5)))) || IsTrue((IsEqual(orderType, 9)))) || IsTrue((IsEqual(orderType, 10)))) {
                typeVar = "limit"
            } else {
                typeVar = "market"
            }
        }
        if IsTrue(IsEqual(side, "1")) {
            side = "open long"
        } else if IsTrue(IsEqual(side, "2")) {
            side = "open short"
        } else if IsTrue(IsEqual(side, "3")) {
            side = "close long"
        } else if IsTrue(IsEqual(side, "4")) {
            side = "close short"
        }
        timestamp = this.SafeInteger(order, "insert_time")
        lastTradeTimestamp = this.SafeInteger(order, "time_stamp")
    } else {
        timestamp = this.SafeTimestamp(order, "created_date")
        lastTradeTimestamp = this.SafeTimestamp(order, "finished_date")
        if IsTrue(!IsEqual(side, nil)) {
            var parts interface{} = Split(side, "_")
            var numParts interface{} =             GetArrayLength(parts)
            if IsTrue(IsGreaterThan(numParts, 1)) {
                side = GetValue(parts, 0)
                typeVar = GetValue(parts, 1)
            } else {
                typeVar = "limit"
            }
        }
    }
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": this.SafeString2(order, "order_id", "data"),
        "clientOrderId": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": lastTradeTimestamp,
        "symbol": symbol,
        "type": typeVar,
        "timeInForce": timeInForce,
        "postOnly": nil,
        "side": side,
        "price": this.SafeNumber(order, "price"),
        "triggerPrice": nil,
        "amount": this.SafeNumber2(order, "amount", "size"),
        "filled": this.SafeNumber2(order, "executed_amount", "filled_qty"),
        "remaining": nil,
        "cost": nil,
        "average": this.SafeNumber2(order, "avg_price", "price_avg"),
        "status": this.ParseOrderStatus(this.SafeString2(order, "status", "state")),
        "fee": map[string]interface{} {
            "cost": this.SafeNumber(order, "fee"),
        },
        "trades": nil,
    }, market)
}
/**
 * @method
 * @name digifinex#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://docs.digifinex.com/en-ww/spot/v3/rest.html#current-active-orders
 * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#openorder
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *digifinex) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes22768 := (<-this.LoadMarkets())
            PanicOnError(retRes22768)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var marketType interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchOpenOrders", market, params);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            marginModequeryVariable := this.HandleMarginModeAndParams("fetchOpenOrders", params);
            marginMode := GetValue(marginModequeryVariable,0);
            query := GetValue(marginModequeryVariable,1)
            var request interface{} = map[string]interface{} {}
            var swap interface{} =     (IsEqual(marketType, "swap"))
            if IsTrue(swap) {
                if IsTrue(!IsEqual(since, nil)) {
                    AddElementToObject(request, "start_timestamp", since)
                }
                if IsTrue(!IsEqual(limit, nil)) {
                    AddElementToObject(request, "limit", limit)
                }
            } else {
                AddElementToObject(request, "market", marketType)
            }
            if IsTrue(!IsEqual(market, nil)) {
                var marketIdRequest interface{} = Ternary(IsTrue(swap), "instrument_id", "symbol")
                AddElementToObject(request, marketIdRequest, GetValue(market, "id"))
            }
            var response interface{} = nil
            if IsTrue(IsTrue(!IsEqual(marginMode, nil)) || IsTrue(IsEqual(marketType, "margin"))) {
                marketType = "margin"
                
        response = (<-this.PrivateSpotGetMarginOrderCurrent(this.Extend(request, query)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(marketType, "spot")) {
                
        response = (<-this.PrivateSpotGetSpotOrderCurrent(this.Extend(request, query)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(marketType, "swap")) {
                
        response = (<-this.PrivateSwapGetTradeOpenOrders(this.Extend(request, query)))
                PanicOnError(response)
            } else {
                panic(NotSupported(Add(this.Id, " fetchOpenOrders() not support this market type")))
            }
            //
            // spot and margin
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "symbol": "BTC_USDT",
            //                 "order_id": "dd3164b333a4afa9d5730bb87f6db8b3",
            //                 "created_date": 1562303547,
            //                 "finished_date": 0,
            //                 "price": 0.1,
            //                 "amount": 1,
            //                 "cash_amount": 1,
            //                 "executed_amount": 0,
            //                 "avg_price": 0,
            //                 "status": 1,
            //                 "type": "buy",
            //                 "kind": "margin"
            //             }
            //         ]
            //     }
            //
            // swap
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "order_id": "1590898207657824256",
            //                 "instrument_id": "BTCUSDTPERP",
            //                 "margin_mode": "crossed",
            //                 "contract_val": "0.001",
            //                 "type": 1,
            //                 "order_type": 0,
            //                 "price": "14000",
            //                 "size": "6",
            //                 "filled_qty": "0",
            //                 "price_avg": "0",
            //                 "fee": "0",
            //                 "state": 0,
            //                 "leverage": "20",
            //                 "turnover": "0",
            //                 "has_stop": 0,
            //                 "insert_time": 1668134664828,
            //                 "time_stamp": 1668134664828
            //             },
            //             ...
            //         ]
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseOrders(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name digifinex#fetchOrders
 * @description fetches information on multiple orders made by the user
 * @see https://docs.digifinex.com/en-ww/spot/v3/rest.html#get-all-orders-including-history-orders
 * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#historyorder
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *digifinex) FetchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes23798 := (<-this.LoadMarkets())
            PanicOnError(retRes23798)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var marketType interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchOrders", market, params);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            marginModequeryVariable := this.HandleMarginModeAndParams("fetchOrders", params);
            marginMode := GetValue(marginModequeryVariable,0);
            query := GetValue(marginModequeryVariable,1)
            var request interface{} = map[string]interface{} {}
            if IsTrue(IsEqual(marketType, "swap")) {
                if IsTrue(!IsEqual(since, nil)) {
                    AddElementToObject(request, "start_timestamp", since)
                }
            } else {
                AddElementToObject(request, "market", marketType)
                if IsTrue(!IsEqual(since, nil)) {
                    AddElementToObject(request, "start_time", this.ParseToInt(Divide(since, 1000))) // default 3 days from now, max 30 days
                }
            }
            if IsTrue(!IsEqual(market, nil)) {
                var marketIdRequest interface{} = Ternary(IsTrue((IsEqual(marketType, "swap"))), "instrument_id", "symbol")
                AddElementToObject(request, marketIdRequest, GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            var response interface{} = nil
            if IsTrue(IsTrue(!IsEqual(marginMode, nil)) || IsTrue(IsEqual(marketType, "margin"))) {
                marketType = "margin"
                
        response = (<-this.PrivateSpotGetMarginOrderHistory(this.Extend(request, query)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(marketType, "spot")) {
                
        response = (<-this.PrivateSpotGetSpotOrderHistory(this.Extend(request, query)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(marketType, "swap")) {
                
        response = (<-this.PrivateSwapGetTradeHistoryOrders(this.Extend(request, query)))
                PanicOnError(response)
            } else {
                panic(NotSupported(Add(this.Id, " fetchOrders() not support this market type")))
            }
            //
            // spot and margin
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "symbol": "BTC_USDT",
            //                 "order_id": "dd3164b333a4afa9d5730bb87f6db8b3",
            //                 "created_date": 1562303547,
            //                 "finished_date": 0,
            //                 "price": 0.1,
            //                 "amount": 1,
            //                 "cash_amount": 1,
            //                 "executed_amount": 0,
            //                 "avg_price": 0,
            //                 "status": 1,
            //                 "type": "buy",
            //                 "kind": "margin"
            //             }
            //         ]
            //     }
            //
            // swap
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "order_id": "1590136768156405760",
            //                 "instrument_id": "BTCUSDTPERP",
            //                 "margin_mode": "crossed",
            //                 "contract_val": "0.001",
            //                 "type": 1,
            //                 "order_type": 8,
            //                 "price": "18660.2",
            //                 "size": "1",
            //                 "filled_qty": "1",
            //                 "price_avg": "18514.5",
            //                 "fee": "0.00925725",
            //                 "state": 2,
            //                 "leverage": "20",
            //                 "turnover": "18.5145",
            //                 "has_stop": 0,
            //                 "insert_time": 1667953123526,
            //                 "time_stamp": 1667953123596
            //             },
            //             ...
            //         ]
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseOrders(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name digifinex#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://docs.digifinex.com/en-ww/spot/v3/rest.html#get-order-status
 * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#orderinfo
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *digifinex) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes24838 := (<-this.LoadMarkets())
            PanicOnError(retRes24838)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var marketType interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchOrder", market, params);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            marginModequeryVariable := this.HandleMarginModeAndParams("fetchOrder", params);
            marginMode := GetValue(marginModequeryVariable,0);
            query := GetValue(marginModequeryVariable,1)
            var request interface{} = map[string]interface{} {
                "order_id": id,
            }
            if IsTrue(IsEqual(marketType, "swap")) {
                if IsTrue(!IsEqual(market, nil)) {
                    AddElementToObject(request, "instrument_id", GetValue(market, "id"))
                }
            } else {
                AddElementToObject(request, "market", marketType)
            }
            var response interface{} = nil
            if IsTrue(IsTrue((!IsEqual(marginMode, nil))) || IsTrue((IsEqual(marketType, "margin")))) {
                marketType = "margin"
                
        response = (<-this.PrivateSpotGetMarginOrder(this.Extend(request, query)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(marketType, "spot")) {
                
        response = (<-this.PrivateSpotGetSpotOrder(this.Extend(request, query)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(marketType, "swap")) {
                
        response = (<-this.PrivateSwapGetTradeOrderInfo(this.Extend(request, query)))
                PanicOnError(response)
            } else {
                panic(NotSupported(Add(this.Id, " fetchOrder() not support this market type")))
            }
            //
            // spot and margin
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "symbol": "BTC_USDT",
            //                 "order_id": "dd3164b333a4afa9d5730bb87f6db8b3",
            //                 "created_date": 1562303547,
            //                 "finished_date": 0,
            //                 "price": 0.1,
            //                 "amount": 1,
            //                 "cash_amount": 1,
            //                 "executed_amount": 0,
            //                 "avg_price": 0,
            //                 "status": 1,
            //                 "type": "buy",
            //                 "kind": "margin"
            //             }
            //         ]
            //     }
            //
            // swap
            //
            //     {
            //         "code": 0,
            //         "data": {
            //             "order_id": "1590923061186531328",
            //             "instrument_id": "ETHUSDTPERP",
            //             "margin_mode": "crossed",
            //             "contract_val": "0.01",
            //             "type": 1,
            //             "order_type": 0,
            //             "price": "900",
            //             "size": "6",
            //             "filled_qty": "0",
            //             "price_avg": "0",
            //             "fee": "0",
            //             "state": 0,
            //             "leverage": "20",
            //             "turnover": "0",
            //             "has_stop": 0,
            //             "insert_time": 1668140590372,
            //             "time_stamp": 1668140590372
            //         }
            //     }
            //
            var data interface{} = this.SafeValue(response, "data")
            var order interface{} = Ternary(IsTrue((IsEqual(marketType, "swap"))), data, this.SafeValue(data, 0))
            if IsTrue(IsEqual(order, nil)) {
                panic(OrderNotFound(Add(Add(Add(this.Id, " fetchOrder() order "), ToString(id)), " not found")))
            }
        
            ch <- this.ParseOrder(order, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name digifinex#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://docs.digifinex.com/en-ww/spot/v3/rest.html#customer-39-s-trades
 * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#historytrade
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *digifinex) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes25818 := (<-this.LoadMarkets())
            PanicOnError(retRes25818)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var marketType interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchMyTrades", market, params);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            marginModequeryVariable := this.HandleMarginModeAndParams("fetchMyTrades", params);
            marginMode := GetValue(marginModequeryVariable,0);
            query := GetValue(marginModequeryVariable,1)
            if IsTrue(IsEqual(marketType, "swap")) {
                if IsTrue(!IsEqual(since, nil)) {
                    AddElementToObject(request, "start_timestamp", since)
                }
            } else {
                AddElementToObject(request, "market", marketType)
                if IsTrue(!IsEqual(since, nil)) {
                    AddElementToObject(request, "start_time", this.ParseToInt(Divide(since, 1000))) // default 3 days from now, max 30 days
                }
            }
            var marketIdRequest interface{} = Ternary(IsTrue((IsEqual(marketType, "swap"))), "instrument_id", "symbol")
            if IsTrue(!IsEqual(symbol, nil)) {
                AddElementToObject(request, marketIdRequest, GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            var response interface{} = nil
            if IsTrue(IsTrue(!IsEqual(marginMode, nil)) || IsTrue(IsEqual(marketType, "margin"))) {
                marketType = "margin"
                
        response = (<-this.PrivateSpotGetMarginMytrades(this.Extend(request, query)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(marketType, "spot")) {
                
        response = (<-this.PrivateSpotGetSpotMytrades(this.Extend(request, query)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(marketType, "swap")) {
                
        response = (<-this.PrivateSwapGetTradeHistoryTrades(this.Extend(request, query)))
                PanicOnError(response)
            } else {
                panic(NotSupported(Add(this.Id, " fetchMyTrades() not support this market type")))
            }
            //
            // spot and margin
            //
            //      {
            //          "list":[
            //              {
            //                  "timestamp":1639506068,
            //                  "is_maker":false,
            //                  "id":"8975951332",
            //                  "amount":31.83,
            //                  "side":"sell_market",
            //                  "symbol":"DOGE_USDT",
            //                  "fee_currency":"USDT",
            //                  "fee":0.01163774826
            //                  ,"order_id":"32b169792f4a7a19e5907dc29fc123d4",
            //                  "price":0.182811
            //                }
            //             ],
            //           "code": 0
            //      }
            //
            // swap
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "trade_id": "1590136768424841218",
            //                 "instrument_id": "BTCUSDTPERP",
            //                 "order_id": "1590136768156405760",
            //                 "type": 1,
            //                 "order_type": 8,
            //                 "price": "18514.5",
            //                 "size": "1",
            //                 "fee": "0.00925725",
            //                 "close_profit": "0",
            //                 "leverage": "20",
            //                 "trade_type": 0,
            //                 "match_role": 1,
            //                 "trade_time": 1667953123562
            //             },
            //             ...
            //         ]
            //     }
            //
            var responseRequest interface{} = Ternary(IsTrue((IsEqual(marketType, "swap"))), "data", "list")
            var data interface{} = this.SafeList(response, responseRequest, []interface{}{})
        
            ch <- this.ParseTrades(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *digifinex) ParseLedgerEntryType(typeVar interface{}) interface{}  {
    var types interface{} = map[string]interface{} {}
    return this.SafeString(types, typeVar, typeVar)
}
func  (this *digifinex) ParseLedgerEntry(item interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // spot and margin
    //
    //     {
    //         "currency_mark": "BTC",
    //         "type": 100234,
    //         "num": -10,
    //         "balance": 0.1,
    //         "time": 1546272000
    //     }
    //
    // swap
    //
    //     {
    //         "currency": "USDT",
    //         "finance_type": 17,
    //         "change": "-3.01",
    //         "timestamp": 1650809432000
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var typeVar interface{} = this.ParseLedgerEntryType(this.SafeString2(item, "type", "finance_type"))
    var currencyId interface{} = this.SafeString2(item, "currency_mark", "currency")
    var code interface{} = this.SafeCurrencyCode(currencyId, currency)
    currency = this.SafeCurrency(currencyId, currency)
    var amount interface{} = this.SafeNumber2(item, "num", "change")
    var after interface{} = this.SafeNumber(item, "balance")
    var timestamp interface{} = this.SafeTimestamp(item, "time")
    if IsTrue(IsEqual(timestamp, nil)) {
        timestamp = this.SafeInteger(item, "timestamp")
    }
    return this.SafeLedgerEntry(map[string]interface{} {
        "info": item,
        "id": nil,
        "direction": nil,
        "account": nil,
        "referenceId": nil,
        "referenceAccount": nil,
        "type": typeVar,
        "currency": code,
        "amount": amount,
        "before": nil,
        "after": after,
        "status": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "fee": nil,
    }, currency)
}
/**
 * @method
 * @name digifinex#fetchLedger
 * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
 * @see https://docs.digifinex.com/en-ww/spot/v3/rest.html#spot-margin-otc-financial-logs
 * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#bills
 * @param {string} [code] unified currency code, default is undefined
 * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
 * @param {int} [limit] max number of ledger entries to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger}
 */
func  (this *digifinex) FetchLedger(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes27368 := (<-this.LoadMarkets())
            PanicOnError(retRes27368)
            var request interface{} = map[string]interface{} {}
            var marketType interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchLedger", nil, params);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            marginModequeryVariable := this.HandleMarginModeAndParams("fetchLedger", params);
            marginMode := GetValue(marginModequeryVariable,0);
            query := GetValue(marginModequeryVariable,1)
            if IsTrue(IsEqual(marketType, "swap")) {
                if IsTrue(!IsEqual(since, nil)) {
                    AddElementToObject(request, "start_timestamp", since)
                }
            } else {
                AddElementToObject(request, "market", marketType)
                if IsTrue(!IsEqual(since, nil)) {
                    AddElementToObject(request, "start_time", this.ParseToInt(Divide(since, 1000))) // default 3 days from now, max 30 days
                }
            }
            var currencyIdRequest interface{} = Ternary(IsTrue((IsEqual(marketType, "swap"))), "currency", "currency_mark")
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, currencyIdRequest, GetValue(currency, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            var response interface{} = nil
            if IsTrue(IsTrue(!IsEqual(marginMode, nil)) || IsTrue(IsEqual(marketType, "margin"))) {
                marketType = "margin"
                
        response = (<-this.PrivateSpotGetMarginFinancelog(this.Extend(request, query)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(marketType, "spot")) {
                
        response = (<-this.PrivateSpotGetSpotFinancelog(this.Extend(request, query)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(marketType, "swap")) {
                
        response = (<-this.PrivateSwapGetAccountFinanceRecord(this.Extend(request, query)))
                PanicOnError(response)
            } else {
                panic(NotSupported(Add(this.Id, " fetchLedger() not support this market type")))
            }
            //
            // spot and margin
            //
            //     {
            //         "code": 0,
            //         "data": {
            //             "total": 521,
            //             "finance": [
            //                 {
            //                     "currency_mark": "BTC",
            //                     "type": 100234,
            //                     "num": 28457,
            //                     "balance": 0.1,
            //                     "time": 1546272000
            //                 }
            //             ]
            //         }
            //     }
            //
            // swap
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "currency": "USDT",
            //                 "finance_type": 17,
            //                 "change": "3.01",
            //                 "timestamp": 1650809432000
            //             },
            //         ]
            //     }
            //
            var ledger interface{} = nil
            if IsTrue(IsEqual(marketType, "swap")) {
                ledger = this.SafeValue(response, "data", []interface{}{})
            } else {
                var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
                ledger = this.SafeValue(data, "finance", []interface{}{})
            }
        
            ch <- this.ParseLedger(ledger, currency, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *digifinex) ParseDepositAddress(depositAddress interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "addressTag":"",
    //         "address":"0xf1104d9f8624f89775a3e9d480fc0e75a8ef4373",
    //         "currency":"USDT",
    //         "chain":"ERC20"
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var address interface{} = this.SafeString(depositAddress, "address")
    var tag interface{} = this.SafeString(depositAddress, "addressTag")
    var currencyId interface{} = this.SafeStringUpper(depositAddress, "currency")
    var code interface{} = this.SafeCurrencyCode(currencyId)
    return map[string]interface{} {
        "info": depositAddress,
        "currency": code,
        "network": nil,
        "address": address,
        "tag": tag,
    }
}
/**
 * @method
 * @name digifinex#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *digifinex) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes28458 := (<-this.LoadMarkets())
            PanicOnError(retRes28458)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "currency": GetValue(currency, "id"),
            }
        
            response:= (<-this.PrivateSpotGetDepositAddress(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "data":[
            //             {
            //                 "addressTag":"",
            //                 "address":"0xf1104d9f8624f89775a3e9d480fc0e75a8ef4373",
            //                 "currency":"USDT",
            //                 "chain":"ERC20"
            //             }
            //         ],
            //         "code":200
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", []interface{}{})
            var addresses interface{} = this.ParseDepositAddresses(data, []interface{}{GetValue(currency, "code")})
            var address interface{} = this.SafeValue(addresses, code)
            if IsTrue(IsEqual(address, nil)) {
                panic(InvalidAddress(Add(Add(Add(this.Id, " fetchDepositAddress() did not return an address for "), code), " - create the deposit address in the user settings on the exchange website first.")))
            }
        
            ch <- address
            return nil
        
            }()
            return ch
        }
func  (this *digifinex) FetchTransactionsByType(typeVar interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes28748 := (<-this.LoadMarkets())
            PanicOnError(retRes28748)
            var currency interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "currency", GetValue(currency, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "size", mathMin(500, limit))
            }
            var response interface{} = nil
            if IsTrue(IsEqual(typeVar, "deposit")) {
                
        response = (<-this.PrivateSpotGetDepositHistory(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PrivateSpotGetWithdrawHistory(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            //     {
            //         "code": 200,
            //         "data": [
            //             {
            //                 "id": 1171,
            //                 "currency": "xrp",
            //                 "hash": "ed03094b84eafbe4bc16e7ef766ee959885ee5bcb265872baaa9c64e1cf86c2b",
            //                 "chain": "",
            //                 "amount": 7.457467,
            //                 "address": "rae93V8d2mdoUQHwBDBdM4NHCMehRJAsbm",
            //                 "memo": "100040",
            //                 "fee": 0,
            //                 "state": "safe",
            //                 "created_date": "2020-04-20 11:23:00",
            //                 "finished_date": "2020-04-20 13:23:00"
            //             },
            //         ]
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTransactions(data, currency, since, limit, map[string]interface{} {
                "type": typeVar,
            })
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name digifinex#fetchDeposits
 * @description fetch all deposits made to an account
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *digifinex) FetchDeposits(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
                retRes293015 :=  (<-this.FetchTransactionsByType("deposit", code, since, limit, params))
                PanicOnError(retRes293015)
                ch <- retRes293015
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name digifinex#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawals structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *digifinex) FetchWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
                retRes294415 :=  (<-this.FetchTransactionsByType("withdrawal", code, since, limit, params))
                PanicOnError(retRes294415)
                ch <- retRes294415
                return nil
        
            }()
            return ch
        }
func  (this *digifinex) ParseTransactionStatus(status interface{}) interface{}  {
    // deposit state includes: 1 (in deposit), 2 (to be confirmed), 3 (successfully deposited), 4 (stopped)
    // withdrawal state includes: 1 (application in progress), 2 (to be confirmed), 3 (completed), 4 (rejected)
    var statuses interface{} = map[string]interface{} {
        "1": "pending",
        "2": "pending",
        "3": "ok",
        "4": "failed",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *digifinex) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // withdraw
    //
    //     {
    //         "code": 200,
    //         "withdraw_id": 700
    //     }
    //
    // fetchDeposits, fetchWithdrawals
    //
    //     {
    //         "id": 1171,
    //         "currency": "xrp",
    //         "hash": "ed03094b84eafbe4bc16e7ef766ee959885ee5bcb265872baaa9c64e1cf86c2b",
    //         "chain": "",
    //         "amount": 7.457467,
    //         "address": "rae93V8d2mdoUQHwBDBdM4NHCMehRJAsbm",
    //         "memo": "100040",
    //         "fee": 0,
    //         "state": "safe",
    //         "created_date": "2020-04-20 11:23:00",
    //         "finished_date": "2020-04-20 13:23:00"
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var id interface{} = this.SafeString2(transaction, "id", "withdraw_id")
    var address interface{} = this.SafeString(transaction, "address")
    var tag interface{} = this.SafeString(transaction, "memo")
    var txid interface{} = this.SafeString(transaction, "hash")
    var currencyId interface{} = this.SafeStringUpper(transaction, "currency")
    var code interface{} = this.SafeCurrencyCode(currencyId, currency)
    var timestamp interface{} = this.Parse8601(this.SafeString(transaction, "created_date"))
    var updated interface{} = this.Parse8601(this.SafeString(transaction, "finished_date"))
    var status interface{} = this.ParseTransactionStatus(this.SafeString(transaction, "state"))
    var amount interface{} = this.SafeNumber(transaction, "amount")
    var feeCost interface{} = this.SafeNumber(transaction, "fee")
    var fee interface{} = nil
    if IsTrue(!IsEqual(feeCost, nil)) {
        fee = map[string]interface{} {
            "currency": code,
            "cost": feeCost,
        }
    }
    var network interface{} = this.SafeString(transaction, "chain")
    return map[string]interface{} {
        "info": transaction,
        "id": id,
        "txid": txid,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "network": network,
        "address": address,
        "addressTo": address,
        "addressFrom": nil,
        "tag": tag,
        "tagTo": tag,
        "tagFrom": nil,
        "type": nil,
        "amount": amount,
        "currency": code,
        "status": status,
        "updated": updated,
        "internal": nil,
        "comment": nil,
        "fee": fee,
    }
}
func  (this *digifinex) ParseTransferStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "0": "ok",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *digifinex) ParseTransfer(transfer interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // transfer between spot, margin and OTC
    //
    //     {
    //         "code": 0
    //     }
    //
    // transfer between spot and swap
    //
    //     {
    //         "code": 0,
    //         "data": {
    //             "type": 2,
    //             "currency": "USDT",
    //             "transfer_amount": "5"
    //         }
    //     }
    //
    // fetchTransfers
    //
    //     {
    //         "transfer_id": 130524,
    //         "type": 1,
    //         "currency": "USDT",
    //         "amount": "24",
    //         "timestamp": 1666505659000
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var fromAccount interface{} = nil
    var toAccount interface{} = nil
    var data interface{} = this.SafeDict(transfer, "data", transfer)
    var typeVar interface{} = this.SafeInteger(data, "type")
    if IsTrue(IsEqual(typeVar, 1)) {
        fromAccount = "spot"
        toAccount = "swap"
    } else if IsTrue(IsEqual(typeVar, 2)) {
        fromAccount = "swap"
        toAccount = "spot"
    }
    var timestamp interface{} = this.SafeInteger(transfer, "timestamp")
    return map[string]interface{} {
        "info": transfer,
        "id": this.SafeString(transfer, "transfer_id"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "currency": this.SafeCurrencyCode(this.SafeString(data, "currency"), currency),
        "amount": this.SafeNumber2(data, "amount", "transfer_amount"),
        "fromAccount": fromAccount,
        "toAccount": toAccount,
        "status": this.ParseTransferStatus(this.SafeString(transfer, "code")),
    }
}
/**
 * @method
 * @name digifinex#transfer
 * @description transfer currency internally between wallets on the same account
 * @see https://docs.digifinex.com/en-ww/spot/v3/rest.html#transfer-assets-among-accounts
 * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#accounttransfer
 * @param {string} code unified currency code
 * @param {float} amount amount to transfer
 * @param {string} fromAccount 'spot', 'swap', 'margin', 'OTC' - account to transfer from
 * @param {string} toAccount 'spot', 'swap', 'margin', 'OTC' - account to transfer to
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func  (this *digifinex) Transfer(code interface{}, amount interface{}, fromAccount interface{}, toAccount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes30998 := (<-this.LoadMarkets())
            PanicOnError(retRes30998)
            var currency interface{} = this.Currency(code)
            var currencyId interface{} = GetValue(currency, "id")
            var accountsByType interface{} = this.SafeValue(this.Options, "accountsByType", map[string]interface{} {})
            var fromId interface{} = this.SafeString(accountsByType, fromAccount, fromAccount)
            var toId interface{} = this.SafeString(accountsByType, toAccount, toAccount)
            var request interface{} = map[string]interface{} {}
            var fromSwap interface{} =     (IsEqual(fromAccount, "swap"))
            var toSwap interface{} =     (IsEqual(toAccount, "swap"))
            var response interface{} = nil
            var amountString interface{} = this.CurrencyToPrecision(code, amount)
            if IsTrue(IsTrue(fromSwap) || IsTrue(toSwap)) {
                if IsTrue(IsTrue((!IsEqual(fromId, "1"))) && IsTrue((!IsEqual(toId, "1")))) {
                    panic(ExchangeError(Add(this.Id, " transfer() supports transferring between spot and swap, spot and margin, spot and OTC only")))
                }
                AddElementToObject(request, "type", Ternary(IsTrue(toSwap), 1, 2)) // 1 = spot to swap, 2 = swap to spot
                AddElementToObject(request, "currency", currencyId)
                AddElementToObject(request, "transfer_amount", amountString)
                //
                //     {
                //         "code": 0,
                //         "data": {
                //             "type": 2,
                //             "currency": "USDT",
                //             "transfer_amount": "5"
                //         }
                //     }
                //
                
        response = (<-this.PrivateSwapPostAccountTransfer(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                AddElementToObject(request, "currency_mark", currencyId)
                AddElementToObject(request, "num", amountString)
                AddElementToObject(request, "from", fromId) // 1 = SPOT, 2 = MARGIN, 3 = OTC
                AddElementToObject(request, "to", toId) // 1 = SPOT, 2 = MARGIN, 3 = OTC
                //
                //     {
                //         "code": 0
                //     }
                //
                
        response = (<-this.PrivateSpotPostTransfer(this.Extend(request, params)))
                PanicOnError(response)
            }
        
            ch <- this.ParseTransfer(response, currency)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name digifinex#withdraw
 * @description make a withdrawal
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *digifinex) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params);
            tag = GetValue(tagparamsVariable,0);
            params = GetValue(tagparamsVariable,1)
            this.CheckAddress(address)
        
            retRes31578 := (<-this.LoadMarkets())
            PanicOnError(retRes31578)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "address": address,
                "amount": this.CurrencyToPrecision(code, amount),
                "currency": GetValue(currency, "id"),
            }
            if IsTrue(!IsEqual(tag, nil)) {
                AddElementToObject(request, "memo", tag)
            }
        
            response:= (<-this.PrivateSpotPostWithdrawNew(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "code": 200,
            //         "withdraw_id": 700
            //     }
            //
        ch <- this.ParseTransaction(response, currency)
            return nil
        
            }()
            return ch
        }
func  (this *digifinex) FetchBorrowInterest(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            symbol := GetArg(optionalArgs, 1, nil)
            _ = symbol
            since := GetArg(optionalArgs, 2, nil)
            _ = since
            limit := GetArg(optionalArgs, 3, nil)
            _ = limit
            params := GetArg(optionalArgs, 4, map[string]interface{} {})
            _ = params
        
            retRes31798 := (<-this.LoadMarkets())
            PanicOnError(retRes31798)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
        
            response:= (<-this.PrivateSpotGetMarginPositions(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "margin": "45.71246418952618",
            //         "code": 0,
            //         "margin_rate": "7.141978570340037",
            //         "positions": [
            //             {
            //                 "amount": 0.0006103,
            //                 "side": "go_long",
            //                 "entry_price": 31428.72,
            //                 "liquidation_rate": 0.3,
            //                 "liquidation_price": 10225.335481159,
            //                 "unrealized_roe": -0.0076885829266987,
            //                 "symbol": "BTC_USDT",
            //                 "unrealized_pnl": -0.049158102631999,
            //                 "leverage_ratio": 3
            //             }
            //         ],
            //         "unrealized_pnl": "-0.049158102631998504"
            //     }
            //
            var rows interface{} = this.SafeValue(response, "positions")
            var interest interface{} = this.ParseBorrowInterests(rows, market)
        
            ch <- this.FilterByCurrencySinceLimit(interest, code, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *digifinex) ParseBorrowInterest(info interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "amount": 0.0006103,
    //         "side": "go_long",
    //         "entry_price": 31428.72,
    //         "liquidation_rate": 0.3,
    //         "liquidation_price": 10225.335481159,
    //         "unrealized_roe": -0.0076885829266987,
    //         "symbol": "BTC_USDT",
    //         "unrealized_pnl": -0.049158102631999,
    //         "leverage_ratio": 3
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(info, "symbol")
    var amountString interface{} = this.SafeString(info, "amount")
    var leverageString interface{} = this.SafeString(info, "leverage_ratio")
    var amountInvested interface{} = Precise.StringDiv(amountString, leverageString)
    var amountBorrowed interface{} = Precise.StringSub(amountString, amountInvested)
    var currency interface{} = Ternary(IsTrue((IsEqual(market, nil))), nil, GetValue(market, "base"))
    var symbol interface{} = this.SafeSymbol(marketId, market)
    return map[string]interface{} {
        "info": info,
        "symbol": symbol,
        "currency": currency,
        "interest": nil,
        "interestRate": 0.001,
        "amountBorrowed": this.ParseNumber(amountBorrowed),
        "marginMode": nil,
        "timestamp": nil,
        "datetime": nil,
    }
}
/**
 * @method
 * @name digifinex#fetchCrossBorrowRate
 * @description fetch the rate of interest to borrow a currency for margin trading
 * @see https://docs.digifinex.com/en-ww/spot/v3/rest.html#margin-assets
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [borrow rate structure]{@link https://github.com/ccxt/ccxt/wiki/Manual#borrow-rate-structure}
 */
func  (this *digifinex) FetchCrossBorrowRate(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes32578 := (<-this.LoadMarkets())
            PanicOnError(retRes32578)
            var request interface{} = map[string]interface{} {}
        
            response:= (<-this.PrivateSpotGetMarginAssets(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "list": [
            //             {
            //                 "valuation_rate": 1,
            //                 "total": 1.92012186174,
            //                 "free": 1.92012186174,
            //                 "currency": "USDT"
            //             },
            //         ],
            //         "total": 45.133305540922,
            //         "code": 0,
            //         "unrealized_pnl": 0,
            //         "free": 45.133305540922,
            //         "equity": 45.133305540922
            //     }
            //
            var data interface{} = this.SafeValue(response, "list", []interface{}{})
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
                var entry interface{} = GetValue(data, i)
                if IsTrue(IsEqual(this.SafeString(entry, "currency"), code)) {
                    result = entry
                }
            }
            var currency interface{} = this.Currency(code)
        
            ch <- this.ParseBorrowRate(result, currency)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name digifinex#fetchCrossBorrowRates
 * @description fetch the borrow interest rates of all currencies
 * @see https://docs.digifinex.com/en-ww/spot/v3/rest.html#margin-assets
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [borrow rate structures]{@link https://docs.ccxt.com/#/?id=borrow-rate-structure}
 */
func  (this *digifinex) FetchCrossBorrowRates(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes32988 := (<-this.LoadMarkets())
            PanicOnError(retRes32988)
        
            response:= (<-this.PrivateSpotGetMarginAssets(params))
            PanicOnError(response)
            //
            //     {
            //         "list": [
            //             {
            //                 "valuation_rate": 1,
            //                 "total": 1.92012186174,
            //                 "free": 1.92012186174,
            //                 "currency": "USDT"
            //             },
            //         ],
            //         "total": 45.133305540922,
            //         "code": 0,
            //         "unrealized_pnl": 0,
            //         "free": 45.133305540922,
            //         "equity": 45.133305540922
            //     }
            //
            var result interface{} = this.SafeValue(response, "list", []interface{}{})
        
            ch <- this.ParseBorrowRates(result, "currency")
            return nil
        
            }()
            return ch
        }
func  (this *digifinex) ParseBorrowRate(info interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "valuation_rate": 1,
    //         "total": 1.92012186174,
    //         "free": 1.92012186174,
    //         "currency": "USDT"
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var timestamp interface{} = this.Milliseconds()
    var currencyId interface{} = this.SafeString(info, "currency")
    return map[string]interface{} {
        "currency": this.SafeCurrencyCode(currencyId, currency),
        "rate": 0.001,
        "period": 86400000,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "info": info,
    }
}
func  (this *digifinex) ParseBorrowRates(info interface{}, codeKey interface{}) interface{}  {
    //
    //     {
    //         "valuation_rate": 1,
    //         "total": 1.92012186174,
    //         "free": 1.92012186174,
    //         "currency": "USDT"
    //     },
    //
    var result interface{} = map[string]interface{} {}
    for i := 0; IsLessThan(i, GetArrayLength(info)); i++ {
        var item interface{} = GetValue(info, i)
        var currency interface{} = this.SafeString(item, codeKey)
        var code interface{} = this.SafeCurrencyCode(currency)
        var borrowRate interface{} = this.ParseBorrowRate(item)
        AddElementToObject(result, code, borrowRate)
    }
    return result
}
/**
 * @method
 * @name digifinex#fetchFundingRate
 * @description fetch the current funding rate
 * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#currentfundingrate
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
 */
func  (this *digifinex) FetchFundingRate(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes33728 := (<-this.LoadMarkets())
            PanicOnError(retRes33728)
            var market interface{} = this.Market(symbol)
            if !IsTrue(GetValue(market, "swap")) {
                panic(BadSymbol(Add(this.Id, " fetchFundingRate() supports swap contracts only")))
            }
            var request interface{} = map[string]interface{} {
                "instrument_id": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicSwapGetPublicFundingRate(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": 0,
            //         "data": {
            //             "instrument_id": "BTCUSDTPERP",
            //             "funding_rate": "-0.00012",
            //             "funding_time": 1662710400000,
            //             "next_funding_rate": "0.0001049907085171607",
            //             "next_funding_time": 1662739200000
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseFundingRate(data, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name digifinex#fetchFundingInterval
 * @description fetch the current funding rate interval
 * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#currentfundingrate
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
 */
func  (this *digifinex) FetchFundingInterval(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes340715 :=  (<-this.FetchFundingRate(symbol, params))
                PanicOnError(retRes340715)
                ch <- retRes340715
                return nil
        
            }()
            return ch
        }
func  (this *digifinex) ParseFundingRate(contract interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "instrument_id": "BTCUSDTPERP",
    //         "funding_rate": "-0.00012",
    //         "funding_time": 1662710400000,
    //         "next_funding_rate": "0.0001049907085171607",
    //         "next_funding_time": 1662739200000
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(contract, "instrument_id")
    var timestamp interface{} = this.SafeInteger(contract, "funding_time")
    var nextTimestamp interface{} = this.SafeInteger(contract, "next_funding_time")
    var fundingTimeString interface{} = this.SafeString(contract, "funding_time")
    var nextFundingTimeString interface{} = this.SafeString(contract, "next_funding_time")
    var millisecondsInterval interface{} = Precise.StringSub(nextFundingTimeString, fundingTimeString)
    return map[string]interface{} {
        "info": contract,
        "symbol": this.SafeSymbol(marketId, market),
        "markPrice": nil,
        "indexPrice": nil,
        "interestRate": nil,
        "estimatedSettlePrice": nil,
        "timestamp": nil,
        "datetime": nil,
        "fundingRate": this.SafeNumber(contract, "funding_rate"),
        "fundingTimestamp": timestamp,
        "fundingDatetime": this.Iso8601(timestamp),
        "nextFundingRate": this.SafeNumber(contract, "next_funding_rate"),
        "nextFundingTimestamp": nextTimestamp,
        "nextFundingDatetime": this.Iso8601(nextTimestamp),
        "previousFundingRate": nil,
        "previousFundingTimestamp": nil,
        "previousFundingDatetime": nil,
        "interval": this.ParseFundingInterval(millisecondsInterval),
    }
}
func  (this *digifinex) ParseFundingInterval(interval interface{}) interface{}  {
    var intervals interface{} = map[string]interface{} {
        "3600000": "1h",
        "14400000": "4h",
        "28800000": "8h",
        "57600000": "16h",
        "86400000": "24h",
    }
    return this.SafeString(intervals, interval, interval)
}
/**
 * @method
 * @name digifinex#fetchFundingRateHistory
 * @description fetches historical funding rate prices
 * @param {string} symbol unified symbol of the market to fetch the funding rate history for
 * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
 * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure} to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
 */
func  (this *digifinex) FetchFundingRateHistory(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchFundingRateHistory() requires a symbol argument")))
            }
        
            retRes34738 := (<-this.LoadMarkets())
            PanicOnError(retRes34738)
            var market interface{} = this.Market(symbol)
            if !IsTrue(GetValue(market, "swap")) {
                panic(BadSymbol(Add(this.Id, " fetchFundingRateHistory() supports swap contracts only")))
            }
            var request interface{} = map[string]interface{} {
                "instrument_id": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_timestamp", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.PublicSwapGetPublicFundingRateHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": 0,
            //         "data": {
            //             "instrument_id": "BTCUSDTPERP",
            //             "funding_rates": [
            //                 {
            //                     "rate": "-0.00375",
            //                     "time": 1607673600000
            //                 },
            //                 ...
            //             ]
            //         }
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
            var result interface{} = this.SafeValue(data, "funding_rates", []interface{}{})
            var rates interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(result)); i++ {
                var entry interface{} = GetValue(result, i)
                var marketId interface{} = this.SafeString(data, "instrument_id")
                var symbolInner interface{} = this.SafeSymbol(marketId)
                var timestamp interface{} = this.SafeInteger(entry, "time")
                AppendToArray(&rates,map[string]interface{} {
                    "info": entry,
                    "symbol": symbolInner,
                    "fundingRate": this.SafeNumber(entry, "rate"),
                    "timestamp": timestamp,
                    "datetime": this.Iso8601(timestamp),
                })
            }
            var sorted interface{} = this.SortBy(rates, "timestamp")
        
            ch <- this.FilterBySymbolSinceLimit(sorted, symbol, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name digifinex#fetchTradingFee
 * @description fetch the trading fees for a market
 * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#tradingfee
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func  (this *digifinex) FetchTradingFee(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes35338 := (<-this.LoadMarkets())
            PanicOnError(retRes35338)
            var market interface{} = this.Market(symbol)
            if !IsTrue(GetValue(market, "swap")) {
                panic(BadRequest(Add(this.Id, " fetchTradingFee() supports swap markets only")))
            }
            var request interface{} = map[string]interface{} {
                "instrument_id": GetValue(market, "id"),
            }
        
            response:= (<-this.PrivateSwapGetAccountTradingFeeRate(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": 0,
            //         "data": {
            //             "instrument_id": "BTCUSDTPERP",
            //             "taker_fee_rate": "0.0005",
            //             "maker_fee_rate": "0.0003"
            //         }
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
        
            ch <- this.ParseTradingFee(data, market)
            return nil
        
            }()
            return ch
        }
func  (this *digifinex) ParseTradingFee(fee interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "instrument_id": "BTCUSDTPERP",
    //         "taker_fee_rate": "0.0005",
    //         "maker_fee_rate": "0.0003"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(fee, "instrument_id")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    return map[string]interface{} {
        "info": fee,
        "symbol": symbol,
        "maker": this.SafeNumber(fee, "maker_fee_rate"),
        "taker": this.SafeNumber(fee, "taker_fee_rate"),
        "percentage": nil,
        "tierBased": nil,
    }
}
/**
 * @method
 * @name digifinex#fetchPositions
 * @description fetch all open positions
 * @see https://docs.digifinex.com/en-ww/spot/v3/rest.html#margin-positions
 * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#positions
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structures]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *digifinex) FetchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes35878 := (<-this.LoadMarkets())
            PanicOnError(retRes35878)
            symbols = this.MarketSymbols(symbols)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            var marketType interface{} = nil
            if IsTrue(!IsEqual(symbols, nil)) {
                var symbol interface{} = nil
                if IsTrue(IsArray(symbols)) {
                    var symbolsLength interface{} =             GetArrayLength(symbols)
                    if IsTrue(IsGreaterThan(symbolsLength, 1)) {
                        panic(BadRequest(Add(this.Id, " fetchPositions() symbols argument cannot contain more than 1 symbol")))
                    }
                    symbol = GetValue(symbols, 0)
                } else {
                    symbol = symbols
                }
                market = this.Market(symbol)
            }
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchPositions", market, params);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            marginModequeryVariable := this.HandleMarginModeAndParams("fetchPositions", params);
            marginMode := GetValue(marginModequeryVariable,0);
            query := GetValue(marginModequeryVariable,1)
            if IsTrue(!IsEqual(marginMode, nil)) {
                marketType = "margin"
            }
            if IsTrue(!IsEqual(market, nil)) {
                var marketIdRequest interface{} = Ternary(IsTrue((IsEqual(marketType, "swap"))), "instrument_id", "symbol")
                AddElementToObject(request, marketIdRequest, GetValue(market, "id"))
            }
            var response interface{} = nil
            if IsTrue(IsTrue(IsEqual(marketType, "spot")) || IsTrue(IsEqual(marketType, "margin"))) {
                
        response = (<-this.PrivateSpotGetMarginPositions(this.Extend(request, query)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(marketType, "swap")) {
                
        response = (<-this.PrivateSwapGetAccountPositions(this.Extend(request, query)))
                PanicOnError(response)
            } else {
                panic(NotSupported(Add(this.Id, " fetchPositions() not support this market type")))
            }
            //
            // swap
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "instrument_id": "BTCUSDTPERP",
            //                 "margin_mode": "crossed",
            //                 "avail_position": "1",
            //                 "avg_cost": "18369.3",
            //                 "last": "18404.7",
            //                 "leverage": "20",
            //                 "liquidation_price": "451.12820512820264",
            //                 "maint_margin_ratio": "0.005",
            //                 "margin": "0.918465",
            //                 "position": "1",
            //                 "realized_pnl": "0",
            //                 "unrealized_pnl": "0.03410000000000224",
            //                 "unrealized_pnl_rate": "0.03712716325608732",
            //                 "side": "long",
            //                 "open_outstanding": "0",
            //                 "risk_score": "0.495049504950495",
            //                 "margin_ratio": "0.4029464788983229",
            //                 "timestamp": 1667960497145
            //             },
            //             ...
            //         ]
            //     }
            //
            // margin
            //
            //     {
            //         "margin": "77.71534772983289",
            //         "code": 0,
            //         "margin_rate": "10.284503769497306",
            //         "positions": [
            //             {
            //                 "amount": 0.0010605,
            //                 "side": "go_long",
            //                 "entry_price": 18321.39,
            //                 "liquidation_rate": 0.3,
            //                 "liquidation_price": -52754.371758471,
            //                 "unrealized_roe": -0.002784390267332,
            //                 "symbol": "BTC_USDT",
            //                 "unrealized_pnl": -0.010820048189999,
            //                 "leverage_ratio": 5
            //             },
            //             ...
            //         ],
            //         "unrealized_pnl": "-0.10681600018999979"
            //     }
            //
            var positionRequest interface{} = Ternary(IsTrue((IsEqual(marketType, "swap"))), "data", "positions")
            var positions interface{} = this.SafeValue(response, positionRequest, []interface{}{})
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(positions)); i++ {
                AppendToArray(&result,this.ParsePosition(GetValue(positions, i), market))
            }
        
            ch <- this.FilterByArrayPositions(result, "symbol", symbols, false)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name digifinex#fetchPosition
 * @see https://docs.digifinex.com/en-ww/spot/v3/rest.html#margin-positions
 * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#positions
 * @description fetch data on a single open contract trade position
 * @param {string} symbol unified market symbol of the market the position is held in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *digifinex) FetchPosition(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes36958 := (<-this.LoadMarkets())
            PanicOnError(retRes36958)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {}
            var marketType interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("fetchPosition", market, params);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            marginModequeryVariable := this.HandleMarginModeAndParams("fetchPosition", params);
            marginMode := GetValue(marginModequeryVariable,0);
            query := GetValue(marginModequeryVariable,1)
            if IsTrue(!IsEqual(marginMode, nil)) {
                marketType = "margin"
            }
            var marketIdRequest interface{} = Ternary(IsTrue((IsEqual(marketType, "swap"))), "instrument_id", "symbol")
            AddElementToObject(request, marketIdRequest, GetValue(market, "id"))
            var response interface{} = nil
            if IsTrue(IsTrue(IsEqual(marketType, "spot")) || IsTrue(IsEqual(marketType, "margin"))) {
                
        response = (<-this.PrivateSpotGetMarginPositions(this.Extend(request, query)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(marketType, "swap")) {
                
        response = (<-this.PrivateSwapGetAccountPositions(this.Extend(request, query)))
                PanicOnError(response)
            } else {
                panic(NotSupported(Add(this.Id, " fetchPosition() not support this market type")))
            }
            //
            // swap
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "instrument_id": "BTCUSDTPERP",
            //                 "margin_mode": "crossed",
            //                 "avail_position": "1",
            //                 "avg_cost": "18369.3",
            //                 "last": "18388.9",
            //                 "leverage": "20",
            //                 "liquidation_price": "383.38712921065553",
            //                 "maint_margin_ratio": "0.005",
            //                 "margin": "0.918465",
            //                 "position": "1",
            //                 "realized_pnl": "0",
            //                 "unrealized_pnl": "0.021100000000004115",
            //                 "unrealized_pnl_rate": "0.02297311274790451",
            //                 "side": "long",
            //                 "open_outstanding": "0",
            //                 "risk_score": "0.4901960784313725",
            //                 "margin_ratio": "0.40486964045976204",
            //                 "timestamp": 1667960241758
            //             }
            //         ]
            //     }
            //
            // margin
            //
            //     {
            //         "margin": "77.71534772983289",
            //         "code": 0,
            //         "margin_rate": "10.284503769497306",
            //         "positions": [
            //             {
            //                 "amount": 0.0010605,
            //                 "side": "go_long",
            //                 "entry_price": 18321.39,
            //                 "liquidation_rate": 0.3,
            //                 "liquidation_price": -52754.371758471,
            //                 "unrealized_roe": -0.002784390267332,
            //                 "symbol": "BTC_USDT",
            //                 "unrealized_pnl": -0.010820048189999,
            //                 "leverage_ratio": 5
            //             }
            //         ],
            //         "unrealized_pnl": "-0.10681600018999979"
            //     }
            //
            var dataRequest interface{} = Ternary(IsTrue((IsEqual(marketType, "swap"))), "data", "positions")
            var data interface{} = this.SafeValue(response, dataRequest, []interface{}{})
            var position interface{} = this.ParsePosition(GetValue(data, 0), market)
            if IsTrue(IsEqual(marketType, "swap")) {
        
                ch <- position
                return nil
            } else {
                AddElementToObject(position, "collateral", this.SafeNumber(response, "margin"))
                AddElementToObject(position, "marginRatio", this.SafeNumber(response, "margin_rate"))
        
                ch <- position
                return nil
            }
                return nil
            }()
            return ch
        }
func  (this *digifinex) ParsePosition(position interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // swap
    //
    //     {
    //         "instrument_id": "BTCUSDTPERP",
    //         "margin_mode": "crossed",
    //         "avail_position": "1",
    //         "avg_cost": "18369.3",
    //         "last": "18388.9",
    //         "leverage": "20",
    //         "liquidation_price": "383.38712921065553",
    //         "maint_margin_ratio": "0.005",
    //         "margin": "0.918465",
    //         "position": "1",
    //         "realized_pnl": "0",
    //         "unrealized_pnl": "0.021100000000004115",
    //         "unrealized_pnl_rate": "0.02297311274790451",
    //         "side": "long",
    //         "open_outstanding": "0",
    //         "risk_score": "0.4901960784313725",
    //         "margin_ratio": "0.40486964045976204",
    //         "timestamp": 1667960241758
    //     }
    //
    // margin
    //
    //     {
    //         "amount": 0.0010605,
    //         "side": "go_long",
    //         "entry_price": 18321.39,
    //         "liquidation_rate": 0.3,
    //         "liquidation_price": -52754.371758471,
    //         "unrealized_roe": -0.002784390267332,
    //         "symbol": "BTC_USDT",
    //         "unrealized_pnl": -0.010820048189999,
    //         "leverage_ratio": 5
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString2(position, "instrument_id", "symbol")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = GetValue(market, "symbol")
    var marginMode interface{} = this.SafeString(position, "margin_mode")
    if IsTrue(!IsEqual(marginMode, nil)) {
        marginMode = Ternary(IsTrue((IsEqual(marginMode, "crossed"))), "cross", "isolated")
    } else {
        marginMode = "crossed"
    }
    var timestamp interface{} = this.SafeInteger(position, "timestamp")
    var side interface{} = this.SafeString(position, "side")
    if IsTrue(IsEqual(side, "go_long")) {
        side = "long"
    } else if IsTrue(IsEqual(side, "go_short")) {
        side = "short"
    }
    return this.SafePosition(map[string]interface{} {
        "info": position,
        "id": nil,
        "symbol": symbol,
        "notional": this.SafeNumber(position, "amount"),
        "marginMode": marginMode,
        "liquidationPrice": this.SafeNumber(position, "liquidation_price"),
        "entryPrice": this.SafeNumber2(position, "avg_cost", "entry_price"),
        "unrealizedPnl": this.SafeNumber(position, "unrealized_pnl"),
        "contracts": this.SafeNumber(position, "avail_position"),
        "contractSize": this.SafeNumber(market, "contractSize"),
        "markPrice": this.SafeNumber(position, "last"),
        "side": side,
        "hedged": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "maintenanceMargin": this.SafeNumber(position, "margin"),
        "maintenanceMarginPercentage": this.SafeNumber(position, "maint_margin_ratio"),
        "collateral": nil,
        "initialMargin": nil,
        "initialMarginPercentage": nil,
        "leverage": this.SafeNumber2(position, "leverage", "leverage_ratio"),
        "marginRatio": this.SafeNumber(position, "margin_ratio"),
        "percentage": nil,
        "stopLossPrice": nil,
        "takeProfitPrice": nil,
    })
}
/**
 * @method
 * @name digifinex#setLeverage
 * @description set the level of leverage for a market
 * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#setleverage
 * @param {float} leverage the rate of leverage
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] either 'cross' or 'isolated', default is cross
 * @param {string} [params.side] either 'long' or 'short', required for isolated markets only
 * @returns {object} response from the exchange
 */
func  (this *digifinex) SetLeverage(leverage interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " setLeverage() requires a symbol argument")))
            }
        
            retRes38778 := (<-this.LoadMarkets())
            PanicOnError(retRes38778)
            var market interface{} = this.Market(symbol)
            if IsTrue(!IsEqual(GetValue(market, "type"), "swap")) {
                panic(BadSymbol(Add(this.Id, " setLeverage() supports swap contracts only")))
            }
            if IsTrue(IsTrue((IsLessThan(leverage, 1))) || IsTrue((IsGreaterThan(leverage, 100)))) {
                panic(BadRequest(Add(this.Id, " leverage should be between 1 and 100")))
            }
            var request interface{} = map[string]interface{} {
                "instrument_id": GetValue(market, "id"),
                "leverage": leverage,
            }
            var defaultMarginMode interface{} = this.SafeString2(this.Options, "marginMode", "defaultMarginMode")
            var marginMode interface{} = this.SafeStringLower2(params, "marginMode", "defaultMarginMode", defaultMarginMode)
            if IsTrue(!IsEqual(marginMode, nil)) {
                marginMode = Ternary(IsTrue((IsEqual(marginMode, "cross"))), "crossed", "isolated")
                AddElementToObject(request, "margin_mode", marginMode)
                params = this.Omit(params, []interface{}{"marginMode", "defaultMarginMode"})
            }
            if IsTrue(IsEqual(marginMode, "isolated")) {
                var side interface{} = this.SafeString(params, "side")
                if IsTrue(!IsEqual(side, nil)) {
                    AddElementToObject(request, "side", side)
                    params = this.Omit(params, "side")
                } else {
                    this.CheckRequiredArgument("setLeverage", side, "side", []interface{}{"long", "short"})
                }
            }
        
                retRes390515 :=  (<-this.PrivateSwapPostAccountLeverage(this.Extend(request, params)))
                PanicOnError(retRes390515)
                ch <- retRes390515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name digifinex#fetchTransfers
 * @description fetch the transfer history, only transfers between spot and swap accounts are supported
 * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#transferrecord
 * @param {string} code unified currency code of the currency transferred
 * @param {int} [since] the earliest time in ms to fetch transfers for
 * @param {int} [limit] the maximum number of  transfers to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transfer structures]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func  (this *digifinex) FetchTransfers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes39318 := (<-this.LoadMarkets())
            PanicOnError(retRes39318)
            var currency interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.SafeCurrencyCode(code)
                AddElementToObject(request, "currency", GetValue(currency, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_timestamp", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit) // default 20 max 100
            }
        
            response:= (<-this.PrivateSwapGetAccountTransferRecord(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "transfer_id": 130524,
            //                 "type": 1,
            //                 "currency": "USDT",
            //                 "amount": "24",
            //                 "timestamp": 1666505659000
            //             },
            //             ...
            //         ]
            //     }
            //
            var transfers interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTransfers(transfers, currency, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name digifinex#fetchLeverageTiers
 * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#instruments
 * @description retrieve information on the maximum leverage, for different trade sizes
 * @param {string[]|undefined} symbols a list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [leverage tiers structures]{@link https://docs.ccxt.com/#/?id=leverage-tiers-structure}, indexed by market symbols
 */
func  (this *digifinex) FetchLeverageTiers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes39748 := (<-this.LoadMarkets())
            PanicOnError(retRes39748)
        
            response:= (<-this.PublicSwapGetPublicInstruments(params))
            PanicOnError(response)
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "instrument_id": "BTCUSDTPERP",
            //                 "type": "REAL",
            //                 "contract_type": "PERPETUAL",
            //                 "base_currency": "BTC",
            //                 "quote_currency": "USDT",
            //                 "clear_currency": "USDT",
            //                 "contract_value": "0.001",
            //                 "contract_value_currency": "BTC",
            //                 "is_inverse": false,
            //                 "is_trading": true,
            //                 "status": "ONLINE",
            //                 "price_precision": 1,
            //                 "tick_size": "0.1",
            //                 "min_order_amount": 1,
            //                 "open_max_limits": [
            //                     {
            //                         "leverage": "50",
            //                         "max_limit": "1000000"
            //                     },
            //                 ]
            //             },
            //         ]
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", []interface{}{})
            symbols = this.MarketSymbols(symbols)
        
            ch <- this.ParseLeverageTiers(data, symbols, "instrument_id")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name digifinex#fetchMarketLeverageTiers
 * @description retrieve information on the maximum leverage, for different trade sizes for a single market
 * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#instrument
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [leverage tiers structure]{@link https://docs.ccxt.com/#/?id=leverage-tiers-structure}
 */
func  (this *digifinex) FetchMarketLeverageTiers(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes40208 := (<-this.LoadMarkets())
            PanicOnError(retRes40208)
            var market interface{} = this.Market(symbol)
            if !IsTrue(GetValue(market, "swap")) {
                panic(BadRequest(Add(this.Id, " fetchMarketLeverageTiers() supports swap markets only")))
            }
            var request interface{} = map[string]interface{} {
                "instrument_id": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicSwapGetPublicInstrument(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": 0,
            //         "data": {
            //             "instrument_id": "BTCUSDTPERP",
            //             "type": "REAL",
            //             "contract_type": "PERPETUAL",
            //             "base_currency": "BTC",
            //             "quote_currency": "USDT",
            //             "clear_currency": "USDT",
            //             "contract_value": "0.001",
            //             "contract_value_currency": "BTC",
            //             "is_inverse": false,
            //             "is_trading": true,
            //             "status": "ONLINE",
            //             "price_precision": 1,
            //             "tick_size": "0.1",
            //             "min_order_amount": 1,
            //             "open_max_limits": [
            //                 {
            //                     "leverage": "50",
            //                     "max_limit": "1000000"
            //                 }
            //             ]
            //         }
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
        
            ch <- this.ParseMarketLeverageTiers(data, market)
            return nil
        
            }()
            return ch
        }
func  (this *digifinex) ParseMarketLeverageTiers(info interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "instrument_id": "BTCUSDTPERP",
    //         "type": "REAL",
    //         "contract_type": "PERPETUAL",
    //         "base_currency": "BTC",
    //         "quote_currency": "USDT",
    //         "clear_currency": "USDT",
    //         "contract_value": "0.001",
    //         "contract_value_currency": "BTC",
    //         "is_inverse": false,
    //         "is_trading": true,
    //         "status": "ONLINE",
    //         "price_precision": 1,
    //         "tick_size": "0.1",
    //         "min_order_amount": 1,
    //         "open_max_limits": [
    //             {
    //                 "leverage": "50",
    //                 "max_limit": "1000000"
    //             }
    //         ]
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var tiers interface{} = []interface{}{}
    var brackets interface{} = this.SafeValue(info, "open_max_limits", map[string]interface{} {})
    for i := 0; IsLessThan(i, GetArrayLength(brackets)); i++ {
        var tier interface{} = GetValue(brackets, i)
        var marketId interface{} = this.SafeString(info, "instrument_id")
        market = this.SafeMarket(marketId, market)
        AppendToArray(&tiers,map[string]interface{} {
            "tier": this.Sum(i, 1),
            "symbol": this.SafeSymbol(marketId, market, nil, "swap"),
            "currency": GetValue(market, "settle"),
            "minNotional": nil,
            "maxNotional": this.SafeNumber(tier, "max_limit"),
            "maintenanceMarginRate": nil,
            "maxLeverage": this.SafeNumber(tier, "leverage"),
            "info": tier,
        })
    }
    return tiers
}
func  (this *digifinex) HandleMarginModeAndParams(methodName interface{}, optionalArgs ...interface{}) interface{}  {
    /**
    * @ignore
    * @method
    * @description marginMode specified by params["marginMode"], this.options["marginMode"], this.options["defaultMarginMode"], params["margin"] = true or this.options["defaultType"] = 'margin'
    * @param {object} [params] extra parameters specific to the exchange API endpoint
    * @returns {Array} the marginMode in lowercase
    */
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    defaultValue := GetArg(optionalArgs, 1, nil)
    _ = defaultValue
    var defaultType interface{} = this.SafeString(this.Options, "defaultType")
    var isMargin interface{} = this.SafeBool(params, "margin", false)
    var marginMode interface{} = nil
    marginModeparamsVariable := this.Exchange.HandleMarginModeAndParams(methodName, params, defaultValue);
    marginMode = GetValue(marginModeparamsVariable,0);
    params = GetValue(marginModeparamsVariable,1)
    if IsTrue(!IsEqual(marginMode, nil)) {
        if IsTrue(!IsEqual(marginMode, "cross")) {
            panic(NotSupported(Add(this.Id, " only cross margin is supported")))
        }
    } else {
        if IsTrue(IsTrue((IsEqual(defaultType, "margin"))) || IsTrue((IsEqual(isMargin, true)))) {
            marginMode = "cross"
        }
    }
    return []interface{}{marginMode, params}
}
/**
 * @method
 * @name digifinex#fetchDepositWithdrawFees
 * @description fetch deposit and withdraw fees
 * @see https://docs.digifinex.com/en-ww/spot/v3/rest.html#get-currency-deposit-and-withdrawal-information
 * @param {string[]|undefined} codes not used by fetchDepositWithdrawFees ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func  (this *digifinex) FetchDepositWithdrawFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    codes := GetArg(optionalArgs, 0, nil)
            _ = codes
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes41398 := (<-this.LoadMarkets())
            PanicOnError(retRes41398)
        
            response:= (<-this.PublicSpotGetCurrencies(params))
            PanicOnError(response)
            //
            //   {
            //       "data": [
            //           {
            //               "deposit_status": 0,
            //               "min_withdraw_fee": 5,
            //               "withdraw_fee_currency": "USDT",
            //               "chain": "OMNI",
            //               "withdraw_fee_rate": 0,
            //               "min_withdraw_amount": 10,
            //               "currency": "USDT",
            //               "withdraw_status": 0,
            //               "min_deposit_amount": 10
            //           },
            //           {
            //               "deposit_status": 1,
            //               "min_withdraw_fee": 5,
            //               "withdraw_fee_currency": "USDT",
            //               "chain": "ERC20",
            //               "withdraw_fee_rate": 0,
            //               "min_withdraw_amount": 10,
            //               "currency": "USDT",
            //               "withdraw_status": 1,
            //               "min_deposit_amount": 10
            //           },
            //       ],
            //       "code": 200,
            //   }
            //
            var data interface{} = this.SafeList(response, "data")
        
            ch <- this.ParseDepositWithdrawFees(data, codes)
            return nil
        
            }()
            return ch
        }
func  (this *digifinex) ParseDepositWithdrawFees(response interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     [
    //         {
    //             "deposit_status": 0,
    //             "min_withdraw_fee": 5,
    //             "withdraw_fee_currency": "USDT",
    //             "chain": "OMNI",
    //             "withdraw_fee_rate": 0,
    //             "min_withdraw_amount": 10,
    //             "currency": "USDT",
    //             "withdraw_status": 0,
    //             "min_deposit_amount": 10
    //         },
    //         {
    //             "deposit_status": 1,
    //             "min_withdraw_fee": 5,
    //             "withdraw_fee_currency": "USDT",
    //             "chain": "ERC20",
    //             "withdraw_fee_rate": 0,
    //             "min_withdraw_amount": 10,
    //             "currency": "USDT",
    //             "withdraw_status": 1,
    //             "min_deposit_amount": 10
    //         },
    //     ]
    //
    codes := GetArg(optionalArgs, 0, nil)
    _ = codes
    currencyIdKey := GetArg(optionalArgs, 1, nil)
    _ = currencyIdKey
    var depositWithdrawFees interface{} = map[string]interface{} {}
    codes = this.MarketCodes(codes)
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        var entry interface{} = GetValue(response, i)
        var currencyId interface{} = this.SafeString(entry, "currency")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        if IsTrue(IsTrue((IsEqual(codes, nil))) || IsTrue((this.InArray(code, codes)))) {
            var depositWithdrawFee interface{} = this.SafeValue(depositWithdrawFees, code)
            if IsTrue(IsEqual(depositWithdrawFee, nil)) {
                AddElementToObject(depositWithdrawFees, code, this.DepositWithdrawFee(map[string]interface{} {}))
                AddElementToObject(GetValue(depositWithdrawFees, code), "info", []interface{}{})
            }
            var depositWithdrawInfo interface{} = GetValue(GetValue(depositWithdrawFees, code), "info")
            AppendToArray(&depositWithdrawInfo,entry)
            var networkId interface{} = this.SafeString(entry, "chain")
            var withdrawFee interface{} = this.SafeValue(entry, "min_withdraw_fee")
            var withdrawResult interface{} = map[string]interface{} {
                "fee": withdrawFee,
                "percentage": Ternary(IsTrue((!IsEqual(withdrawFee, nil))), false, nil),
            }
            var depositResult interface{} = map[string]interface{} {
                "fee": nil,
                "percentage": nil,
            }
            if IsTrue(!IsEqual(networkId, nil)) {
                var networkCode interface{} = this.NetworkIdToCode(networkId)
                AddElementToObject(GetValue(GetValue(depositWithdrawFees, code), "networks"), networkCode, map[string]interface{} {
    "withdraw": withdrawResult,
    "deposit": depositResult,
})
            } else {
                AddElementToObject(GetValue(depositWithdrawFees, code), "withdraw", withdrawResult)
                AddElementToObject(GetValue(depositWithdrawFees, code), "deposit", depositResult)
            }
        }
    }
    var depositWithdrawCodes interface{} = ObjectKeys(depositWithdrawFees)
    for i := 0; IsLessThan(i, GetArrayLength(depositWithdrawCodes)); i++ {
        var code interface{} = GetValue(depositWithdrawCodes, i)
        var currency interface{} = this.Currency(code)
        AddElementToObject(depositWithdrawFees, code, this.AssignDefaultDepositWithdrawFees(GetValue(depositWithdrawFees, code), currency))
    }
    return depositWithdrawFees
}
/**
 * @method
 * @name digifinex#addMargin
 * @description add margin to a position
 * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#positionmargin
 * @param {string} symbol unified market symbol
 * @param {float} amount amount of margin to add
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} params.side the position side: 'long' or 'short'
 * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=margin-structure}
 */
func  (this *digifinex) AddMargin(symbol interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var side interface{} = this.SafeString(params, "side")
            this.CheckRequiredArgument("addMargin", side, "side", []interface{}{"long", "short"})
        
                retRes426015 :=  (<-this.ModifyMarginHelper(symbol, amount, 1, params))
                PanicOnError(retRes426015)
                ch <- retRes426015
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name digifinex#reduceMargin
 * @description remove margin from a position
 * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#positionmargin
 * @param {string} symbol unified market symbol
 * @param {float} amount the amount of margin to remove
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} params.side the position side: 'long' or 'short'
 * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=margin-structure}
 */
func  (this *digifinex) ReduceMargin(symbol interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var side interface{} = this.SafeString(params, "side")
            this.CheckRequiredArgument("reduceMargin", side, "side", []interface{}{"long", "short"})
        
                retRes427715 :=  (<-this.ModifyMarginHelper(symbol, amount, 2, params))
                PanicOnError(retRes427715)
                ch <- retRes427715
                return nil
        
            }()
            return ch
        }
func  (this *digifinex) ModifyMarginHelper(symbol interface{}, amount interface{}, typeVar interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes42818 := (<-this.LoadMarkets())
            PanicOnError(retRes42818)
            var side interface{} = this.SafeString(params, "side")
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "instrument_id": GetValue(market, "id"),
                "amount": this.NumberToString(amount),
                "type": typeVar,
                "side": side,
            }
        
            response:= (<-this.PrivateSwapPostAccountPositionMargin(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": 0,
            //         "data": {
            //             "instrument_id": "BTCUSDTPERP",
            //             "side": "long",
            //             "type": 1,
            //             "amount": "3.6834"
            //         }
            //     }
            //
            var code interface{} = this.SafeInteger(response, "code")
            var status interface{} = Ternary(IsTrue((IsEqual(code, 0))), "ok", "failed")
            var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
        
            ch <- this.Extend(this.ParseMarginModification(data, market), map[string]interface{} {
                "status": status,
            })
            return nil
        
            }()
            return ch
        }
func  (this *digifinex) ParseMarginModification(data interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "instrument_id": "BTCUSDTPERP",
    //         "side": "long",
    //         "type": 1,
    //         "amount": "3.6834"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(data, "instrument_id")
    var rawType interface{} = this.SafeInteger(data, "type")
    return map[string]interface{} {
        "info": data,
        "symbol": this.SafeSymbol(marketId, market, nil, "swap"),
        "type": Ternary(IsTrue((IsEqual(rawType, 1))), "add", "reduce"),
        "marginMode": "isolated",
        "amount": this.SafeNumber(data, "amount"),
        "total": nil,
        "code": GetValue(market, "settle"),
        "status": nil,
        "timestamp": nil,
        "datetime": nil,
    }
}
/**
 * @method
 * @name digifinex#fetchFundingHistory
 * @description fetch the history of funding payments paid and received on this account
 * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#funding-fee
 * @param {string} [symbol] unified market symbol
 * @param {int} [since] the earliest time in ms to fetch funding history for
 * @param {int} [limit] the maximum number of funding history structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] timestamp in ms of the latest funding payment
 * @returns {object} a [funding history structure]{@link https://docs.ccxt.com/#/?id=funding-history-structure}
 */
func  (this *digifinex) FetchFundingHistory(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes43488 := (<-this.LoadMarkets())
            PanicOnError(retRes43488)
            var request interface{} = map[string]interface{} {}
            requestparamsVariable := this.HandleUntilOption("end_timestamp", request, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "instrument_id", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_timestamp", since)
            }
        
            response:= (<-this.PrivateSwapGetAccountFundingFee(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "instrument_id": "BTCUSDTPERP",
            //                 "currency": "USDT",
            //                 "amount": "-0.000342814",
            //                 "timestamp": 1698768009440
            //             }
            //         ]
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseIncomes(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *digifinex) ParseIncome(income interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "instrument_id": "BTCUSDTPERP",
    //         "currency": "USDT",
    //         "amount": "-0.000342814",
    //         "timestamp": 1698768009440
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(income, "instrument_id")
    var currencyId interface{} = this.SafeString(income, "currency")
    var timestamp interface{} = this.SafeInteger(income, "timestamp")
    return map[string]interface{} {
        "info": income,
        "symbol": this.SafeSymbol(marketId, market, nil, "swap"),
        "code": this.SafeCurrencyCode(currencyId),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "id": nil,
        "amount": this.SafeNumber(income, "amount"),
    }
}
/**
 * @method
 * @name digifinex#setMarginMode
 * @description set margin mode to 'cross' or 'isolated'
 * @see https://docs.digifinex.com/en-ww/swap/v2/rest.html#positionmode
 * @param {string} marginMode 'cross' or 'isolated'
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} response from the exchange
 */
func  (this *digifinex) SetMarginMode(marginMode interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " setMarginMode() requires a symbol argument")))
            }
        
            retRes44178 := (<-this.LoadMarkets())
            PanicOnError(retRes44178)
            var market interface{} = this.Market(symbol)
            marginMode = ToLower(marginMode)
            if IsTrue(IsEqual(marginMode, "cross")) {
                marginMode = "crossed"
            }
            var request interface{} = map[string]interface{} {
                "instrument_id": GetValue(market, "id"),
                "margin_mode": marginMode,
            }
        
                retRes442715 :=  (<-this.PrivateSwapPostAccountPositionMode(this.Extend(request, params)))
                PanicOnError(retRes442715)
                ch <- retRes442715
                return nil
        
            }()
            return ch
        }
func  (this *digifinex) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, []interface{}{})
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var signed interface{} = IsEqual(GetValue(api, 0), "private")
    var endpoint interface{} = GetValue(api, 1)
    var pathPart interface{} = Ternary(IsTrue((IsEqual(endpoint, "spot"))), "/v3", "/swap/v2")
    var request interface{} = Add("/", this.ImplodeParams(path, params))
    var payload interface{} = Add(pathPart, request)
    var url interface{} = Add(GetValue(GetValue(this.Urls, "api"), "rest"), payload)
    var query interface{} = this.Omit(params, this.ExtractParams(path))
    var urlencoded interface{} = nil
    if IsTrue(IsTrue(IsTrue(signed) && IsTrue((IsEqual(pathPart, "/swap/v2")))) && IsTrue((IsEqual(method, "POST")))) {
        urlencoded = JsonStringify(params)
    } else {
        urlencoded = this.Urlencode(this.Keysort(query))
    }
    if IsTrue(signed) {
        var auth interface{} = nil
        var nonce interface{} = nil
        if IsTrue(IsEqual(pathPart, "/swap/v2")) {
            nonce = ToString(this.Milliseconds())
            auth = Add(Add(nonce, method), payload)
            if IsTrue(IsEqual(method, "GET")) {
                if IsTrue(urlencoded) {
                    auth = Add(auth, Add("?", urlencoded))
                }
            } else if IsTrue(IsEqual(method, "POST")) {
                auth = Add(auth, urlencoded)
            }
        } else {
            nonce = ToString(this.Nonce())
            auth = urlencoded
        }
        var signature interface{} = this.Hmac(this.Encode(auth), this.Encode(this.Secret), sha256)
        if IsTrue(IsEqual(method, "GET")) {
            if IsTrue(urlencoded) {
                url = Add(url, Add("?", urlencoded))
            }
        } else if IsTrue(IsEqual(method, "POST")) {
            headers = map[string]interface{} {
                "Content-Type": "application/x-www-form-urlencoded",
            }
            if IsTrue(urlencoded) {
                body = urlencoded
            }
        }
        headers = map[string]interface{} {
            "ACCESS-KEY": this.ApiKey,
            "ACCESS-SIGN": signature,
            "ACCESS-TIMESTAMP": nonce,
        }
    } else {
        if IsTrue(urlencoded) {
            url = Add(url, Add("?", urlencoded))
        }
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *digifinex) HandleErrors(statusCode interface{}, statusText interface{}, url interface{}, method interface{}, responseHeaders interface{}, responseBody interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if !IsTrue(response) {
        return nil  // fall back to default error handler
    }
    var code interface{} = this.SafeString(response, "code")
    if IsTrue(IsTrue((IsEqual(code, "0"))) || IsTrue((IsEqual(code, "200")))) {
        return nil  // no error
    }
    var feedback interface{} = Add(Add(this.Id, " "), responseBody)
    if IsTrue(IsEqual(code, nil)) {
        panic(BadResponse(feedback))
    }
    var unknownError interface{} = []interface{}{ExchangeError, feedback}
    ExceptionClassmessageVariable := this.SafeValue(GetValue(this.Exceptions, "exact"), code, unknownError);
    ExceptionClass := GetValue(ExceptionClassmessageVariable,0);
    message := GetValue(ExceptionClassmessageVariable,1)
    throwDynamicException(ExceptionClass, message);return nil;
}


func (this *digifinex) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
