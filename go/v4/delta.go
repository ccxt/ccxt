package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type delta struct {
    Exchange

}

func NewDeltaCore() delta {
   p := delta{}
   setDefaults(&p)
   return p
}

func  (this *delta) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "delta",
        "name": "Delta Exchange",
        "countries": []interface{}{"VC"},
        "rateLimit": 300,
        "version": "v2",
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": false,
            "swap": true,
            "future": false,
            "option": true,
            "addMargin": true,
            "cancelAllOrders": true,
            "cancelOrder": true,
            "closeAllPositions": true,
            "closePosition": false,
            "createOrder": true,
            "createReduceOnlyOrder": true,
            "editOrder": true,
            "fetchBalance": true,
            "fetchClosedOrders": true,
            "fetchCurrencies": true,
            "fetchDeposit": nil,
            "fetchDepositAddress": true,
            "fetchDepositAddresses": false,
            "fetchDepositAddressesByNetwork": false,
            "fetchDeposits": nil,
            "fetchFundingHistory": false,
            "fetchFundingRate": true,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": true,
            "fetchGreeks": true,
            "fetchIndexOHLCV": true,
            "fetchLedger": true,
            "fetchLeverage": true,
            "fetchLeverageTiers": false,
            "fetchMarginMode": true,
            "fetchMarginModes": false,
            "fetchMarketLeverageTiers": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": true,
            "fetchMySettlementHistory": false,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenInterest": true,
            "fetchOpenOrders": true,
            "fetchOption": true,
            "fetchOptionChain": false,
            "fetchOrderBook": true,
            "fetchPosition": true,
            "fetchPositionMode": false,
            "fetchPositions": true,
            "fetchPremiumIndexOHLCV": false,
            "fetchSettlementHistory": true,
            "fetchStatus": true,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTime": true,
            "fetchTrades": true,
            "fetchTransfer": nil,
            "fetchTransfers": nil,
            "fetchUnderlyingAssets": false,
            "fetchVolatilityHistory": false,
            "fetchWithdrawal": nil,
            "fetchWithdrawals": nil,
            "reduceMargin": true,
            "setLeverage": true,
            "setMargin": false,
            "setMarginMode": false,
            "setPositionMode": false,
            "transfer": false,
            "withdraw": false,
        },
        "timeframes": map[string]interface{} {
            "1m": "1m",
            "3m": "3m",
            "5m": "5m",
            "15m": "15m",
            "30m": "30m",
            "1h": "1h",
            "2h": "2h",
            "4h": "4h",
            "6h": "6h",
            "1d": "1d",
            "7d": "7d",
            "1w": "1w",
            "2w": "2w",
            "1M": "30d",
        },
        "urls": map[string]interface{} {
            "logo": "https://user-images.githubusercontent.com/1294454/99450025-3be60a00-2931-11eb-9302-f4fd8d8589aa.jpg",
            "test": map[string]interface{} {
                "public": "https://testnet-api.delta.exchange",
                "private": "https://testnet-api.delta.exchange",
            },
            "api": map[string]interface{} {
                "public": "https://api.delta.exchange",
                "private": "https://api.delta.exchange",
            },
            "www": "https://www.delta.exchange",
            "doc": []interface{}{"https://docs.delta.exchange"},
            "fees": "https://www.delta.exchange/fees",
            "referral": "https://www.delta.exchange/app/signup/?code=IULYNB",
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": []interface{}{"assets", "indices", "products", "products/{symbol}", "tickers", "tickers/{symbol}", "l2orderbook/{symbol}", "trades/{symbol}", "stats", "history/candles", "history/sparklines", "settings"},
            },
            "private": map[string]interface{} {
                "get": []interface{}{"orders", "products/{product_id}/orders/leverage", "positions/margined", "positions", "orders/history", "fills", "fills/history/download/csv", "wallet/balances", "wallet/transactions", "wallet/transactions/download", "wallets/sub_accounts_transfer_history", "users/trading_preferences", "sub_accounts", "profile", "deposits/address", "orders/leverage"},
                "post": []interface{}{"orders", "orders/bracket", "orders/batch", "products/{product_id}/orders/leverage", "positions/change_margin", "positions/close_all", "wallets/sub_account_balance_transfer", "orders/cancel_after", "orders/leverage"},
                "put": []interface{}{"orders", "orders/bracket", "orders/batch", "positions/auto_topup", "users/update_mmp", "users/reset_mmp"},
                "delete": []interface{}{"orders", "orders/all", "orders/batch"},
            },
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "tierBased": true,
                "percentage": true,
                "taker": this.ParseNumber("0.0015"),
                "maker": this.ParseNumber("0.0010"),
                "tiers": map[string]interface{} {
                    "taker": []interface{}{[]interface{}{this.ParseNumber("0"), this.ParseNumber("0.0015")}, []interface{}{this.ParseNumber("100"), this.ParseNumber("0.0013")}, []interface{}{this.ParseNumber("250"), this.ParseNumber("0.0013")}, []interface{}{this.ParseNumber("1000"), this.ParseNumber("0.001")}, []interface{}{this.ParseNumber("5000"), this.ParseNumber("0.0009")}, []interface{}{this.ParseNumber("10000"), this.ParseNumber("0.00075")}, []interface{}{this.ParseNumber("20000"), this.ParseNumber("0.00065")}},
                    "maker": []interface{}{[]interface{}{this.ParseNumber("0"), this.ParseNumber("0.001")}, []interface{}{this.ParseNumber("100"), this.ParseNumber("0.001")}, []interface{}{this.ParseNumber("250"), this.ParseNumber("0.0009")}, []interface{}{this.ParseNumber("1000"), this.ParseNumber("0.00075")}, []interface{}{this.ParseNumber("5000"), this.ParseNumber("0.0006")}, []interface{}{this.ParseNumber("10000"), this.ParseNumber("0.0005")}, []interface{}{this.ParseNumber("20000"), this.ParseNumber("0.0005")}},
                },
            },
        },
        "options": map[string]interface{} {
            "networks": map[string]interface{} {
                "TRC20": "TRC20(TRON)",
                "BEP20": "BEP20(BSC)",
            },
        },
        "features": map[string]interface{} {
            "default": map[string]interface{} {
                "sandbox": true,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": true,
                    "triggerPriceType": map[string]interface{} {
                        "last": true,
                        "mark": true,
                        "index": true,
                    },
                    "triggerDirection": false,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": map[string]interface{} {
                        "triggerPriceType": nil,
                        "price": true,
                    },
                    "timeInForce": map[string]interface{} {
                        "IOC": true,
                        "FOK": true,
                        "PO": true,
                        "GTD": false,
                    },
                    "hedged": false,
                    "selfTradePrevention": false,
                    "trailing": false,
                    "iceberg": false,
                    "leverage": false,
                    "marketBuyByCost": false,
                    "marketBuyRequiresPrice": false,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": 100000,
                    "untilDays": 100000,
                    "symbolRequired": false,
                },
                "fetchOrder": nil,
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOrders": nil,
                "fetchClosedOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 500,
                    "daysBack": 100000,
                    "daysBackCanceled": 1,
                    "untilDays": 100000,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOHLCV": map[string]interface{} {
                    "limit": 2000,
                },
            },
            "spot": map[string]interface{} {
                "extends": "default",
            },
            "swap": map[string]interface{} {
                "linear": map[string]interface{} {
                    "extends": "default",
                },
                "inverse": map[string]interface{} {
                    "extends": "default",
                },
            },
            "future": map[string]interface{} {
                "linear": map[string]interface{} {
                    "extends": "default",
                },
                "inverse": map[string]interface{} {
                    "extends": "default",
                },
            },
        },
        "precisionMode": TICK_SIZE,
        "requiredCredentials": map[string]interface{} {
            "apiKey": true,
            "secret": true,
        },
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "insufficient_margin": InsufficientFunds,
                "order_size_exceed_available": InvalidOrder,
                "risk_limits_breached": BadRequest,
                "invalid_contract": BadSymbol,
                "immediate_liquidation": InvalidOrder,
                "out_of_bankruptcy": InvalidOrder,
                "self_matching_disrupted_post_only": InvalidOrder,
                "immediate_execution_post_only": InvalidOrder,
                "bad_schema": BadRequest,
                "invalid_api_key": AuthenticationError,
                "invalid_signature": AuthenticationError,
                "open_order_not_found": OrderNotFound,
                "unavailable": ExchangeNotAvailable,
            },
            "broad": map[string]interface{} {},
        },
    })
}
func  (this *delta) CreateExpiredOptionMarket(symbol interface{}) interface{}  {
    // support expired option contracts
    var quote interface{} = "USDT"
    var optionParts interface{} = Split(symbol, "-")
    var symbolBase interface{} = Split(symbol, "/")
    var base interface{} = nil
    var expiry interface{} = nil
    var optionType interface{} = nil
    if IsTrue(IsGreaterThan(GetIndexOf(symbol, "/"), OpNeg(1))) {
        base = this.SafeString(symbolBase, 0)
        expiry = this.SafeString(optionParts, 1)
        optionType = this.SafeString(optionParts, 3)
    } else {
        base = this.SafeString(optionParts, 1)
        expiry = this.SafeString(optionParts, 3)
        optionType = this.SafeString(optionParts, 0)
    }
    if IsTrue(!IsEqual(expiry, nil)) {
        expiry = Add(Add(Slice(expiry, 4, nil), Slice(expiry, 2, 4)), Slice(expiry, 0, 2))
    }
    var settle interface{} = quote
    var strike interface{} = this.SafeString(optionParts, 2)
    var datetime interface{} = this.ConvertExpireDate(expiry)
    var timestamp interface{} = this.Parse8601(datetime)
    return map[string]interface{} {
        "id": Add(Add(Add(Add(Add(Add(optionType, "-"), base), "-"), strike), "-"), expiry),
        "symbol": Add(Add(Add(Add(Add(Add(Add(Add(Add(Add(base, "/"), quote), ":"), settle), "-"), expiry), "-"), strike), "-"), optionType),
        "base": base,
        "quote": quote,
        "settle": settle,
        "baseId": base,
        "quoteId": quote,
        "settleId": settle,
        "active": false,
        "type": "option",
        "linear": nil,
        "inverse": nil,
        "spot": false,
        "swap": false,
        "future": false,
        "option": true,
        "margin": false,
        "contract": true,
        "contractSize": this.ParseNumber("1"),
        "expiry": timestamp,
        "expiryDatetime": datetime,
        "optionType": Ternary(IsTrue((IsEqual(optionType, "C"))), "call", "put"),
        "strike": this.ParseNumber(strike),
        "precision": map[string]interface{} {
            "amount": nil,
            "price": nil,
        },
        "limits": map[string]interface{} {
            "amount": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "price": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "cost": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
        },
        "info": nil,
    }
}
func  (this *delta) SafeMarket(optionalArgs ...interface{}) interface{}  {
    marketId := GetArg(optionalArgs, 0, nil)
    _ = marketId
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    delimiter := GetArg(optionalArgs, 2, nil)
    _ = delimiter
    marketType := GetArg(optionalArgs, 3, nil)
    _ = marketType
    var isOption interface{} = IsTrue((!IsEqual(marketId, nil))) && IsTrue((IsTrue(IsTrue(IsTrue((EndsWith(marketId, "-C"))) || IsTrue((EndsWith(marketId, "-P")))) || IsTrue((StartsWith(marketId, "C-")))) || IsTrue((StartsWith(marketId, "P-")))))
    if IsTrue(IsTrue(isOption) && !IsTrue((InOp(this.Markets_by_id, marketId)))) {
        // handle expired option contracts
        return this.CreateExpiredOptionMarket(marketId)
    }
    return this.Exchange.SafeMarket(marketId, market, delimiter, marketType)
}
/**
 * @method
 * @name delta#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func  (this *delta) FetchTime(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetSettings(params))
            PanicOnError(response)
            // full response sample under `fetchStatus`
            var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
        
            ch <- this.SafeIntegerProduct(result, "server_time", 0.001)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name delta#fetchStatus
 * @description the latest known information on the availability of the exchange API
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [status structure]{@link https://docs.ccxt.com/#/?id=exchange-status-structure}
 */
func  (this *delta) FetchStatus(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetSettings(params))
            PanicOnError(response)
            //
            //     {
            //         "result": {
            //           "deto_liquidity_mining_daily_reward": "40775",
            //           "deto_msp": "1.0",
            //           "deto_staking_daily_reward": "23764.08",
            //           "enabled_wallets": [
            //             "BTC",
            //             ...
            //           ],
            //           "portfolio_margin_params": {
            //             "enabled_portfolios": {
            //               ".DEAVAXUSDT": {
            //                 "asset_id": 5,
            //                 "futures_contingency_margin_percent": "1",
            //                 "interest_rate": "0",
            //                 "maintenance_margin_multiplier": "0.8",
            //                 "max_price_shock": "20",
            //                 "max_short_notional_limit": "2000",
            //                 "options_contingency_margin_percent": "1",
            //                 "options_discount_range": "10",
            //                 "options_liq_band_range_percentage": "25",
            //                 "settling_asset": "USDT",
            //                 "sort_priority": 5,
            //                 "underlying_asset": "AVAX",
            //                 "volatility_down_shock": "30",
            //                 "volatility_up_shock": "45"
            //               },
            //               ...
            //             },
            //             "portfolio_enabled_contracts": [
            //               "futures",
            //               "perpetual_futures",
            //               "call_options",
            //               "put_options"
            //             ]
            //           },
            //           "server_time": 1650640673500273,
            //           "trade_farming_daily_reward": "100000",
            //           "circulating_supply": "140000000",
            //           "circulating_supply_update_time": "1636752800",
            //           "deto_referral_mining_daily_reward": "0",
            //           "deto_total_reward_pool": "100000000",
            //           "deto_trade_mining_daily_reward": "0",
            //           "kyc_deposit_limit": "20",
            //           "kyc_withdrawal_limit": "10000",
            //           "maintenance_start_time": "1650387600000000",
            //           "msp_deto_commission_percent": "25",
            //           "under_maintenance": "false"
            //         },
            //         "success": true
            //     }
            //
            var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
            var underMaintenance interface{} = this.SafeString(result, "under_maintenance")
            var status interface{} = Ternary(IsTrue((IsEqual(underMaintenance, "true"))), "maintenance", "ok")
            var updated interface{} = this.SafeIntegerProduct(result, "server_time", 0.001, this.Milliseconds())
        
            ch <- map[string]interface{} {
                "status": status,
                "updated": updated,
                "eta": nil,
                "url": nil,
                "info": response,
            }
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name delta#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see https://docs.delta.exchange/#get-list-of-all-assets
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func  (this *delta) FetchCurrencies(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetAssets(params))
            PanicOnError(response)
            //
            //    {
            //        "result": [
            //            {
            //                "base_withdrawal_fee": "0.005000000000000000",
            //                "id": "1",
            //                "interest_credit": false,
            //                "interest_slabs": null,
            //                "kyc_deposit_limit": "0.000000000000000000",
            //                "kyc_withdrawal_limit": "0.000000000000000000",
            //                "min_withdrawal_amount": "0.010000000000000000",
            //                "minimum_precision": "4",
            //                "name": "Ethereum",
            //                "networks": [
            //                    {
            //                        "allowed_deposit_groups": null,
            //                        "base_withdrawal_fee": "0.0025",
            //                        "deposit_status": "enabled",
            //                        "memo_required": false,
            //                        "min_deposit_amount": "0.000050000000000000",
            //                        "min_withdrawal_amount": "0.010000000000000000",
            //                        "minimum_deposit_confirmations": "12",
            //                        "network": "ERC20",
            //                        "variable_withdrawal_fee": "0",
            //                        "withdrawal_status": "enabled"
            //                    },
            //                    {
            //                        "allowed_deposit_groups": null,
            //                        "base_withdrawal_fee": "0.0001",
            //                        "deposit_status": "enabled",
            //                        "memo_required": false,
            //                        "min_deposit_amount": "0.000050000000000000",
            //                        "min_withdrawal_amount": "0.000300000000000000",
            //                        "minimum_deposit_confirmations": "15",
            //                        "network": "BEP20(BSC)",
            //                        "variable_withdrawal_fee": "0",
            //                        "withdrawal_status": "enabled"
            //                    }
            //                ],
            //                "precision": "18",
            //                "sort_priority": "3",
            //                "symbol": "ETH",
            //                "variable_withdrawal_fee": "0.000000000000000000"
            //            },
            //         ],
            //         "success":true
            //     }
            //
            var currencies interface{} = this.SafeList(response, "result", []interface{}{})
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(currencies)); i++ {
                var currency interface{} = GetValue(currencies, i)
                var id interface{} = this.SafeString(currency, "symbol")
                var numericId interface{} = this.SafeInteger(currency, "id")
                var code interface{} = this.SafeCurrencyCode(id)
                var chains interface{} = this.SafeList(currency, "networks", []interface{}{})
                var networks interface{} = map[string]interface{} {}
                for j := 0; IsLessThan(j, GetArrayLength(chains)); j++ {
                    var chain interface{} = GetValue(chains, j)
                    var networkId interface{} = this.SafeString(chain, "network")
                    var networkCode interface{} = this.NetworkIdToCode(networkId)
                    AddElementToObject(networks, networkCode, map[string]interface{} {
            "id": networkId,
            "network": networkCode,
            "name": this.SafeString(chain, "name"),
            "info": chain,
            "active": IsEqual(this.SafeString(chain, "status"), "enabled"),
            "deposit": IsEqual(this.SafeString(chain, "deposit_status"), "enabled"),
            "withdraw": IsEqual(this.SafeString(chain, "withdrawal_status"), "enabled"),
            "fee": this.SafeNumber(chain, "base_withdrawal_fee"),
            "limits": map[string]interface{} {
                "deposit": map[string]interface{} {
                    "min": this.SafeNumber(chain, "min_deposit_amount"),
                    "max": nil,
                },
                "withdraw": map[string]interface{} {
                    "min": this.SafeNumber(chain, "min_withdrawal_amount"),
                    "max": nil,
                },
            },
        })
                }
                AddElementToObject(result, code, this.SafeCurrencyStructure(map[string]interface{} {
            "id": id,
            "numericId": numericId,
            "code": code,
            "name": this.SafeString(currency, "name"),
            "info": currency,
            "active": nil,
            "deposit": IsEqual(this.SafeString(currency, "deposit_status"), "enabled"),
            "withdraw": IsEqual(this.SafeString(currency, "withdrawal_status"), "enabled"),
            "fee": this.SafeNumber(currency, "base_withdrawal_fee"),
            "precision": this.ParseNumber(this.ParsePrecision(this.SafeString(currency, "precision"))),
            "limits": map[string]interface{} {
                "amount": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
                "withdraw": map[string]interface{} {
                    "min": this.SafeNumber(currency, "min_withdrawal_amount"),
                    "max": nil,
                },
            },
            "networks": networks,
            "type": "crypto",
        }))
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *delta) LoadMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    reload := GetArg(optionalArgs, 0, false)
            _ = reload
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            markets:= (<-this.Exchange.LoadMarkets(reload, params))
            PanicOnError(markets)
            var currenciesByNumericId interface{} = this.SafeDict(this.Options, "currenciesByNumericId")
            if IsTrue(IsTrue((IsEqual(currenciesByNumericId, nil))) || IsTrue(reload)) {
                AddElementToObject(this.Options, "currenciesByNumericId", this.IndexByStringifiedNumericId(this.Currencies))
            }
            var marketsByNumericId interface{} = this.SafeDict(this.Options, "marketsByNumericId")
            if IsTrue(IsTrue((IsEqual(marketsByNumericId, nil))) || IsTrue(reload)) {
                AddElementToObject(this.Options, "marketsByNumericId", this.IndexByStringifiedNumericId(this.Markets))
            }
        
            ch <- markets
            return nil
        
            }()
            return ch
        }
func  (this *delta) IndexByStringifiedNumericId(input interface{}) interface{}  {
    var result interface{} = map[string]interface{} {}
    if IsTrue(IsEqual(input, nil)) {
        return nil
    }
    var keys interface{} = ObjectKeys(input)
    for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
        var key interface{} = GetValue(keys, i)
        var item interface{} = GetValue(input, key)
        var numericIdString interface{} = this.SafeString(item, "numericId")
        if IsTrue(IsEqual(numericIdString, nil)) {
            continue
        }
        AddElementToObject(result, numericIdString, item)
    }
    return result
}
/**
 * @method
 * @name delta#fetchMarkets
 * @description retrieves data on all markets for delta
 * @see https://docs.delta.exchange/#get-list-of-products
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *delta) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetProducts(params))
            PanicOnError(response)
            //
            //     {
            //         "meta":{ "after":null, "before":null, "limit":100, "total_count":81 },
            //         "result":[
            //             // the below response represents item from perpetual market
            //             {
            //                 "annualized_funding":"5.475000000000000000",
            //                 "is_quanto":false,
            //                 "ui_config":{
            //                     "default_trading_view_candle":"15",
            //                     "leverage_slider_values":[1,3,5,10,25,50],
            //                     "price_clubbing_values":[0.001,0.005,0.05,0.1,0.5,1,5],
            //                     "show_bracket_orders":false,
            //                     "sort_priority":29,
            //                     "tags":[]
            //                 },
            //                 "basis_factor_max_limit":"0.15",
            //                 "symbol":"P-LINK-D-151120",
            //                 "id":1584,
            //                 "default_leverage":"5.000000000000000000",
            //                 "maker_commission_rate":"0.0005",
            //                 "contract_unit_currency":"LINK",
            //                 "strike_price":"12.507948",
            //                 "settling_asset":{
            //                     // asset structure
            //                 },
            //                 "auction_start_time":null,
            //                 "auction_finish_time":null,
            //                 "settlement_time":"2020-11-15T12:00:00Z",
            //                 "launch_time":"2020-11-14T11:55:05Z",
            //                 "spot_index":{
            //                     // index structure
            //                 },
            //                 "trading_status":"operational",
            //                 "tick_size":"0.001",
            //                 "position_size_limit":100000,
            //                 "notional_type":"vanilla", // vanilla, inverse
            //                 "price_band":"0.4",
            //                 "barrier_price":null,
            //                 "description":"Daily LINK PUT options quoted in USDT and settled in USDT",
            //                 "insurance_fund_margin_contribution":"1",
            //                 "quoting_asset":{
            //                     // asset structure
            //                 },
            //                 "liquidation_penalty_factor":"0.2",
            //                 "product_specs":{"max_volatility":3,"min_volatility":0.3,"spot_price_band":"0.40"},
            //                 "initial_margin_scaling_factor":"0.0001",
            //                 "underlying_asset":{
            //                     // asset structure
            //                 },
            //                 "state":"live",
            //                 "contract_value":"1",
            //                 "initial_margin":"2",
            //                 "impact_size":5000,
            //                 "settlement_price":null,
            //                 "contract_type":"put_options", // put_options, call_options, move_options, perpetual_futures, interest_rate_swaps, futures, spreads
            //                 "taker_commission_rate":"0.0005",
            //                 "maintenance_margin":"1",
            //                 "short_description":"LINK Daily PUT Options",
            //                 "maintenance_margin_scaling_factor":"0.00005",
            //                 "funding_method":"mark_price",
            //                 "max_leverage_notional":"20000"
            //             },
            //             // the below response represents item from spot market
            //             {
            //                 "position_size_limit": 10000000,
            //                 "settlement_price": null,
            //                 "funding_method": "mark_price",
            //                 "settling_asset": null,
            //                 "impact_size": 10,
            //                 "id": 32258,
            //                 "auction_finish_time": null,
            //                 "description": "Solana tether spot market",
            //                 "trading_status": "operational",
            //                 "tick_size": "0.01",
            //                 "liquidation_penalty_factor": "1",
            //                 "spot_index": {
            //                     "config": { "quoting_asset": "USDT", "service_id": 8, "underlying_asset": "SOL" },
            //                     "constituent_exchanges": [
            //                         { "exchange": "binance", "health_interval": 60, "health_priority": 1, "weight": 1 },
            //                         { "exchange": "huobi", "health_interval": 60, "health_priority": 2, "weight": 1 }
            //                     ],
            //                     "constituent_indices": null,
            //                     "description": "Solana index from binance and huobi",
            //                     "health_interval": 300,
            //                     "id": 105,
            //                     "impact_size": "40.000000000000000000",
            //                     "index_type": "spot_pair",
            //                     "is_composite": false,
            //                     "price_method": "ltp",
            //                     "quoting_asset_id": 5,
            //                     "symbol": ".DESOLUSDT",
            //                     "tick_size": "0.000100000000000000",
            //                     "underlying_asset_id": 66
            //                 },
            //                 "contract_type": "spot",
            //                 "launch_time": "2022-02-03T10:18:11Z",
            //                 "symbol": "SOL_USDT",
            //                 "disruption_reason": null,
            //                 "settlement_time": null,
            //                 "insurance_fund_margin_contribution": "1",
            //                 "is_quanto": false,
            //                 "maintenance_margin": "5",
            //                 "taker_commission_rate": "0.0005",
            //                 "auction_start_time": null,
            //                 "max_leverage_notional": "10000000",
            //                 "state": "live",
            //                 "annualized_funding": "0",
            //                 "notional_type": "vanilla",
            //                 "price_band": "100",
            //                 "product_specs": { "kyc_required": false, "max_order_size": 2000, "min_order_size": 0.01, "quoting_precision": 4, "underlying_precision": 2 },
            //                 "default_leverage": "1.000000000000000000",
            //                 "initial_margin": "10",
            //                 "maintenance_margin_scaling_factor": "1",
            //                 "ui_config": {
            //                     "default_trading_view_candle": "1d",
            //                     "leverage_slider_values": [],
            //                     "price_clubbing_values": [ 0.01, 0.05, 0.1, 0.5, 1, 2.5, 5 ],
            //                     "show_bracket_orders": false,
            //                     "sort_priority": 2,
            //                     "tags": []
            //                 },
            //                 "basis_factor_max_limit": "10000",
            //                 "contract_unit_currency": "SOL",
            //                 "strike_price": null,
            //                 "quoting_asset": {
            //                     "base_withdrawal_fee": "10.000000000000000000",
            //                     "deposit_status": "enabled",
            //                     "id": 5,
            //                     "interest_credit": false,
            //                     "interest_slabs": null,
            //                     "kyc_deposit_limit": "100000.000000000000000000",
            //                     "kyc_withdrawal_limit": "10000.000000000000000000",
            //                     "min_withdrawal_amount": "30.000000000000000000",
            //                     "minimum_precision": 2,
            //                     "name": "Tether",
            //                     "networks": [
            //                         { "base_withdrawal_fee": "25", "deposit_status": "enabled", "memo_required": false, "network": "ERC20", "variable_withdrawal_fee": "0", "withdrawal_status": "enabled" },
            //                         { "base_withdrawal_fee": "1", "deposit_status": "enabled", "memo_required": false, "network": "BEP20(BSC)", "variable_withdrawal_fee": "0", "withdrawal_status": "enabled" },
            //                         { "base_withdrawal_fee": "1", "deposit_status": "disabled", "memo_required": false, "network": "TRC20(TRON)", "variable_withdrawal_fee": "0", "withdrawal_status": "disabled" }
            //                     ],
            //                     "precision": 8,
            //                     "sort_priority": 1,
            //                     "symbol": "USDT",
            //                     "variable_withdrawal_fee": "0.000000000000000000",
            //                     "withdrawal_status": "enabled"
            //                 },
            //                 "maker_commission_rate": "0.0005",
            //                 "initial_margin_scaling_factor": "2",
            //                 "underlying_asset": {
            //                     "base_withdrawal_fee": "0.000000000000000000",
            //                     "deposit_status": "enabled",
            //                     "id": 66,
            //                     "interest_credit": false,
            //                     "interest_slabs": null,
            //                     "kyc_deposit_limit": "0.000000000000000000",
            //                     "kyc_withdrawal_limit": "0.000000000000000000",
            //                     "min_withdrawal_amount": "0.020000000000000000",
            //                     "minimum_precision": 4,
            //                     "name": "Solana",
            //                     "networks": [
            //                         { "base_withdrawal_fee": "0.01", "deposit_status": "enabled", "memo_required": false, "network": "SOLANA", "variable_withdrawal_fee": "0", "withdrawal_status": "enabled" },
            //                         { "base_withdrawal_fee": "0.01", "deposit_status": "enabled", "memo_required": false, "network": "BEP20(BSC)", "variable_withdrawal_fee": "0", "withdrawal_status": "enabled" }
            //                     ],
            //                     "precision": 8,
            //                     "sort_priority": 7,
            //                     "symbol": "SOL",
            //                     "variable_withdrawal_fee": "0.000000000000000000",
            //                     "withdrawal_status": "enabled"
            //                 },
            //                 "barrier_price": null,
            //                 "contract_value": "1",
            //                 "short_description": "SOL-USDT spot market"
            //             },
            //         ],
            //         "success":true
            //     }
            //
            var markets interface{} = this.SafeList(response, "result", []interface{}{})
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(markets)); i++ {
                var market interface{} = GetValue(markets, i)
                var typeVar interface{} = this.SafeString(market, "contract_type")
                if IsTrue(IsEqual(typeVar, "options_combos")) {
                    continue
                }
                // const settlingAsset = this.safeValue (market, 'settling_asset', {});
                var quotingAsset interface{} = this.SafeDict(market, "quoting_asset", map[string]interface{} {})
                var underlyingAsset interface{} = this.SafeDict(market, "underlying_asset", map[string]interface{} {})
                var settlingAsset interface{} = this.SafeDict(market, "settling_asset")
                var productSpecs interface{} = this.SafeDict(market, "product_specs", map[string]interface{} {})
                var baseId interface{} = this.SafeString(underlyingAsset, "symbol")
                var quoteId interface{} = this.SafeString(quotingAsset, "symbol")
                var settleId interface{} = this.SafeString(settlingAsset, "symbol")
                var id interface{} = this.SafeString(market, "symbol")
                var numericId interface{} = this.SafeInteger(market, "id")
                var base interface{} = this.SafeCurrencyCode(baseId)
                var quote interface{} = this.SafeCurrencyCode(quoteId)
                var settle interface{} = this.SafeCurrencyCode(settleId)
                var callOptions interface{} =         (IsEqual(typeVar, "call_options"))
                var putOptions interface{} =         (IsEqual(typeVar, "put_options"))
                var moveOptions interface{} =         (IsEqual(typeVar, "move_options"))
                var spot interface{} =         (IsEqual(typeVar, "spot"))
                var swap interface{} =         (IsEqual(typeVar, "perpetual_futures"))
                var future interface{} =         (IsEqual(typeVar, "futures"))
                var option interface{} =         (IsTrue(IsTrue(callOptions) || IsTrue(putOptions)) || IsTrue(moveOptions))
                var strike interface{} = this.SafeString(market, "strike_price")
                var expiryDatetime interface{} = this.SafeString(market, "settlement_time")
                var expiry interface{} = this.Parse8601(expiryDatetime)
                var contractSize interface{} = this.SafeNumber(market, "contract_value")
                var amountPrecision interface{} = nil
                if IsTrue(spot) {
                    amountPrecision = this.ParseNumber(this.ParsePrecision(this.SafeString(productSpecs, "underlying_precision"))) // seems inverse of 'impact_size'
                } else {
                    // other markets (swap, futures, move, spread, irs) seem to use the step of '1' contract
                    amountPrecision = this.ParseNumber("1")
                }
                var linear interface{} =         (IsEqual(settle, quote))
                var optionType interface{} = nil
                var symbol interface{} = Add(Add(base, "/"), quote)
                if IsTrue(IsTrue(IsTrue(swap) || IsTrue(future)) || IsTrue(option)) {
                    symbol = Add(Add(symbol, ":"), settle)
                    if IsTrue(IsTrue(future) || IsTrue(option)) {
                        symbol = Add(Add(symbol, "-"), this.Yymmdd(expiry))
                        if IsTrue(option) {
                            typeVar = "option"
                            var letter interface{} = "C"
                            optionType = "call"
                            if IsTrue(putOptions) {
                                letter = "P"
                                optionType = "put"
                            } else if IsTrue(moveOptions) {
                                letter = "M"
                                optionType = "move"
                            }
                            symbol = Add(Add(Add(Add(symbol, "-"), strike), "-"), letter)
                        } else {
                            typeVar = "future"
                        }
                    } else {
                        typeVar = "swap"
                    }
                }
                var state interface{} = this.SafeString(market, "state")
                AppendToArray(&result,map[string]interface{} {
                    "id": id,
                    "numericId": numericId,
                    "symbol": symbol,
                    "base": base,
                    "quote": quote,
                    "settle": settle,
                    "baseId": baseId,
                    "quoteId": quoteId,
                    "settleId": settleId,
                    "type": typeVar,
                    "spot": spot,
                    "margin": Ternary(IsTrue(spot), nil, false),
                    "swap": swap,
                    "future": future,
                    "option": option,
                    "active": (IsEqual(state, "live")),
                    "contract": !IsTrue(spot),
                    "linear": Ternary(IsTrue(spot), nil, linear),
                    "inverse": Ternary(IsTrue(spot), nil, !IsTrue(linear)),
                    "taker": this.SafeNumber(market, "taker_commission_rate"),
                    "maker": this.SafeNumber(market, "maker_commission_rate"),
                    "contractSize": contractSize,
                    "expiry": expiry,
                    "expiryDatetime": expiryDatetime,
                    "strike": this.ParseNumber(strike),
                    "optionType": optionType,
                    "precision": map[string]interface{} {
                        "amount": amountPrecision,
                        "price": this.SafeNumber(market, "tick_size"),
                    },
                    "limits": map[string]interface{} {
                        "leverage": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "amount": map[string]interface{} {
                            "min": this.ParseNumber("1"),
                            "max": this.SafeNumber(market, "position_size_limit"),
                        },
                        "price": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "cost": map[string]interface{} {
                            "min": this.SafeNumber(market, "min_size"),
                            "max": nil,
                        },
                    },
                    "created": this.Parse8601(this.SafeString(market, "launch_time")),
                    "info": market,
                })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *delta) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // spot: fetchTicker, fetchTickers
    //
    //     {
    //         "close": 30634.0,
    //         "contract_type": "spot",
    //         "greeks": null,
    //         "high": 30780.0,
    //         "low": 30340.5,
    //         "mark_price": "48000",
    //         "oi": "0.0000",
    //         "oi_change_usd_6h": "0.0000",
    //         "oi_contracts": "0",
    //         "oi_value": "0.0000",
    //         "oi_value_symbol": "BTC",
    //         "oi_value_usd": "0.0000",
    //         "open": 30464.0,
    //         "price_band": null,
    //         "product_id": 8320,
    //         "quotes": {},
    //         "size": 2.6816639999999996,
    //         "spot_price": "30637.91465121",
    //         "symbol": "BTC_USDT",
    //         "timestamp": 1689139767621299,
    //         "turnover": 2.6816639999999996,
    //         "turnover_symbol": "BTC",
    //         "turnover_usd": 81896.45613400004,
    //         "volume": 2.6816639999999996
    //     }
    //
    // swap: fetchTicker, fetchTickers
    //
    //     {
    //         "close": 30600.5,
    //         "contract_type": "perpetual_futures",
    //         "funding_rate": "0.00602961",
    //         "greeks": null,
    //         "high": 30803.0,
    //         "low": 30265.5,
    //         "mark_basis": "-0.45601594",
    //         "mark_price": "30600.10481568",
    //         "oi": "469.9190",
    //         "oi_change_usd_6h": "2226314.9900",
    //         "oi_contracts": "469919",
    //         "oi_value": "469.9190",
    //         "oi_value_symbol": "BTC",
    //         "oi_value_usd": "14385640.6802",
    //         "open": 30458.5,
    //         "price_band": {
    //             "lower_limit": "29067.08312627",
    //             "upper_limit": "32126.77608693"
    //         },
    //         "product_id": 139,
    //         "quotes": {
    //             "ask_iv": null,
    //             "ask_size": "965",
    //             "best_ask": "30600.5",
    //             "best_bid": "30599.5",
    //             "bid_iv": null,
    //             "bid_size": "196",
    //             "impact_mid_price": null,
    //             "mark_iv": "-0.44931641"
    //         },
    //         "size": 1226303,
    //         "spot_price": "30612.85362773",
    //         "symbol": "BTCUSDT",
    //         "timestamp": 1689136597460456,
    //         "turnover": 37392218.45999999,
    //         "turnover_symbol": "USDT",
    //         "turnover_usd": 37392218.45999999,
    //         "volume": 1226.3029999999485
    //     }
    //
    // option: fetchTicker, fetchTickers
    //
    //     {
    //         "contract_type": "call_options",
    //         "greeks": {
    //             "delta": "0.60873994",
    //             "gamma": "0.00014854",
    //             "rho": "7.71808010",
    //             "spot": "30598.49040622",
    //             "theta": "-30.44743017",
    //             "vega": "24.83508248"
    //         },
    //         "mark_price": "1347.74819696",
    //         "mark_vol": "0.39966303",
    //         "oi": "2.7810",
    //         "oi_change_usd_6h": "0.0000",
    //         "oi_contracts": "2781",
    //         "oi_value": "2.7810",
    //         "oi_value_symbol": "BTC",
    //         "oi_value_usd": "85127.4337",
    //         "price_band": {
    //             "lower_limit": "91.27423497",
    //             "upper_limit": "7846.19454697"
    //         },
    //         "product_id": 107150,
    //         "quotes": {
    //             "ask_iv": "0.41023239",
    //             "ask_size": "2397",
    //             "best_ask": "1374",
    //             "best_bid": "1322",
    //             "bid_iv": "0.38929375",
    //             "bid_size": "3995",
    //             "impact_mid_price": null,
    //             "mark_iv": "0.39965618"
    //         },
    //         "spot_price": "30598.43379314",
    //         "strike_price": "30000",
    //         "symbol": "C-BTC-30000-280723",
    //         "timestamp": 1689136932893181,
    //         "turnover_symbol": "USDT"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeIntegerProduct(ticker, "timestamp", 0.001)
    var marketId interface{} = this.SafeString(ticker, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var last interface{} = this.SafeString(ticker, "close")
    var quotes interface{} = this.SafeDict(ticker, "quotes", map[string]interface{} {})
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeNumber(ticker, "high"),
        "low": this.SafeNumber(ticker, "low"),
        "bid": this.SafeNumber(quotes, "best_bid"),
        "bidVolume": this.SafeNumber(quotes, "bid_size"),
        "ask": this.SafeNumber(quotes, "best_ask"),
        "askVolume": this.SafeNumber(quotes, "ask_size"),
        "vwap": nil,
        "open": this.SafeString(ticker, "open"),
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": nil,
        "percentage": nil,
        "average": nil,
        "baseVolume": this.SafeNumber(ticker, "volume"),
        "quoteVolume": this.SafeNumber(ticker, "turnover"),
        "markPrice": this.SafeNumber(ticker, "mark_price"),
        "indexPrice": this.SafeNumber(ticker, "spot_price"),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name delta#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://docs.delta.exchange/#get-ticker-for-a-product-by-symbol
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *delta) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes11198 := (<-this.LoadMarkets())
            PanicOnError(retRes11198)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetTickersSymbol(this.Extend(request, params)))
            PanicOnError(response)
            //
            // spot
            //
            //     {
            //         "result": {
            //             "close": 30634.0,
            //             "contract_type": "spot",
            //             "greeks": null,
            //             "high": 30780.0,
            //             "low": 30340.5,
            //             "mark_price": "48000",
            //             "oi": "0.0000",
            //             "oi_change_usd_6h": "0.0000",
            //             "oi_contracts": "0",
            //             "oi_value": "0.0000",
            //             "oi_value_symbol": "BTC",
            //             "oi_value_usd": "0.0000",
            //             "open": 30464.0,
            //             "price_band": null,
            //             "product_id": 8320,
            //             "quotes": {},
            //             "size": 2.6816639999999996,
            //             "spot_price": "30637.91465121",
            //             "symbol": "BTC_USDT",
            //             "timestamp": 1689139767621299,
            //             "turnover": 2.6816639999999996,
            //             "turnover_symbol": "BTC",
            //             "turnover_usd": 81896.45613400004,
            //             "volume": 2.6816639999999996
            //         },
            //         "success": true
            //     }
            //
            // swap
            //
            //     {
            //         "result": {
            //             "close": 30600.5,
            //             "contract_type": "perpetual_futures",
            //             "funding_rate": "0.00602961",
            //             "greeks": null,
            //             "high": 30803.0,
            //             "low": 30265.5,
            //             "mark_basis": "-0.45601594",
            //             "mark_price": "30600.10481568",
            //             "oi": "469.9190",
            //             "oi_change_usd_6h": "2226314.9900",
            //             "oi_contracts": "469919",
            //             "oi_value": "469.9190",
            //             "oi_value_symbol": "BTC",
            //             "oi_value_usd": "14385640.6802",
            //             "open": 30458.5,
            //             "price_band": {
            //                 "lower_limit": "29067.08312627",
            //                 "upper_limit": "32126.77608693"
            //             },
            //             "product_id": 139,
            //             "quotes": {
            //                 "ask_iv": null,
            //                 "ask_size": "965",
            //                 "best_ask": "30600.5",
            //                 "best_bid": "30599.5",
            //                 "bid_iv": null,
            //                 "bid_size": "196",
            //                 "impact_mid_price": null,
            //                 "mark_iv": "-0.44931641"
            //             },
            //             "size": 1226303,
            //             "spot_price": "30612.85362773",
            //             "symbol": "BTCUSDT",
            //             "timestamp": 1689136597460456,
            //             "turnover": 37392218.45999999,
            //             "turnover_symbol": "USDT",
            //             "turnover_usd": 37392218.45999999,
            //             "volume": 1226.3029999999485
            //         },
            //         "success": true
            //     }
            //
            // option
            //
            //     {
            //         "result": {
            //             "contract_type": "call_options",
            //             "greeks": {
            //                 "delta": "0.60873994",
            //                 "gamma": "0.00014854",
            //                 "rho": "7.71808010",
            //                 "spot": "30598.49040622",
            //                 "theta": "-30.44743017",
            //                 "vega": "24.83508248"
            //             },
            //             "mark_price": "1347.74819696",
            //             "mark_vol": "0.39966303",
            //             "oi": "2.7810",
            //             "oi_change_usd_6h": "0.0000",
            //             "oi_contracts": "2781",
            //             "oi_value": "2.7810",
            //             "oi_value_symbol": "BTC",
            //             "oi_value_usd": "85127.4337",
            //             "price_band": {
            //                 "lower_limit": "91.27423497",
            //                 "upper_limit": "7846.19454697"
            //             },
            //             "product_id": 107150,
            //             "quotes": {
            //                 "ask_iv": "0.41023239",
            //                 "ask_size": "2397",
            //                 "best_ask": "1374",
            //                 "best_bid": "1322",
            //                 "bid_iv": "0.38929375",
            //                 "bid_size": "3995",
            //                 "impact_mid_price": null,
            //                 "mark_iv": "0.39965618"
            //             },
            //             "spot_price": "30598.43379314",
            //             "strike_price": "30000",
            //             "symbol": "C-BTC-30000-280723",
            //             "timestamp": 1689136932893181,
            //             "turnover_symbol": "USDT"
            //         },
            //         "success": true
            //     }
            //
            var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
        
            ch <- this.ParseTicker(result, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name delta#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://docs.delta.exchange/#get-tickers-for-products
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *delta) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes12638 := (<-this.LoadMarkets())
            PanicOnError(retRes12638)
            symbols = this.MarketSymbols(symbols)
        
            response:= (<-this.PublicGetTickers(params))
            PanicOnError(response)
            //
            // spot
            //
            //     {
            //         "result": [
            //             {
            //                 "close": 30634.0,
            //                 "contract_type": "spot",
            //                 "greeks": null,
            //                 "high": 30780.0,
            //                 "low": 30340.5,
            //                 "mark_price": "48000",
            //                 "oi": "0.0000",
            //                 "oi_change_usd_6h": "0.0000",
            //                 "oi_contracts": "0",
            //                 "oi_value": "0.0000",
            //                 "oi_value_symbol": "BTC",
            //                 "oi_value_usd": "0.0000",
            //                 "open": 30464.0,
            //                 "price_band": null,
            //                 "product_id": 8320,
            //                 "quotes": {},
            //                 "size": 2.6816639999999996,
            //                 "spot_price": "30637.91465121",
            //                 "symbol": "BTC_USDT",
            //                 "timestamp": 1689139767621299,
            //                 "turnover": 2.6816639999999996,
            //                 "turnover_symbol": "BTC",
            //                 "turnover_usd": 81896.45613400004,
            //                 "volume": 2.6816639999999996
            //             },
            //         ],
            //         "success":true
            //     }
            //
            // swap
            //
            //     {
            //         "result": [
            //             {
            //                 "close": 30600.5,
            //                 "contract_type": "perpetual_futures",
            //                 "funding_rate": "0.00602961",
            //                 "greeks": null,
            //                 "high": 30803.0,
            //                 "low": 30265.5,
            //                 "mark_basis": "-0.45601594",
            //                 "mark_price": "30600.10481568",
            //                 "oi": "469.9190",
            //                 "oi_change_usd_6h": "2226314.9900",
            //                 "oi_contracts": "469919",
            //                 "oi_value": "469.9190",
            //                 "oi_value_symbol": "BTC",
            //                 "oi_value_usd": "14385640.6802",
            //                 "open": 30458.5,
            //                 "price_band": {
            //                     "lower_limit": "29067.08312627",
            //                     "upper_limit": "32126.77608693"
            //                 },
            //                 "product_id": 139,
            //                 "quotes": {
            //                     "ask_iv": null,
            //                     "ask_size": "965",
            //                     "best_ask": "30600.5",
            //                     "best_bid": "30599.5",
            //                     "bid_iv": null,
            //                     "bid_size": "196",
            //                     "impact_mid_price": null,
            //                     "mark_iv": "-0.44931641"
            //                 },
            //                 "size": 1226303,
            //                 "spot_price": "30612.85362773",
            //                 "symbol": "BTCUSDT",
            //                 "timestamp": 1689136597460456,
            //                 "turnover": 37392218.45999999,
            //                 "turnover_symbol": "USDT",
            //                 "turnover_usd": 37392218.45999999,
            //                 "volume": 1226.3029999999485
            //             },
            //         ],
            //         "success":true
            //     }
            //
            // option
            //
            //     {
            //         "result": [
            //             {
            //                 "contract_type": "call_options",
            //                 "greeks": {
            //                     "delta": "0.60873994",
            //                     "gamma": "0.00014854",
            //                     "rho": "7.71808010",
            //                     "spot": "30598.49040622",
            //                     "theta": "-30.44743017",
            //                     "vega": "24.83508248"
            //                 },
            //                 "mark_price": "1347.74819696",
            //                 "mark_vol": "0.39966303",
            //                 "oi": "2.7810",
            //                 "oi_change_usd_6h": "0.0000",
            //                 "oi_contracts": "2781",
            //                 "oi_value": "2.7810",
            //                 "oi_value_symbol": "BTC",
            //                 "oi_value_usd": "85127.4337",
            //                 "price_band": {
            //                     "lower_limit": "91.27423497",
            //                     "upper_limit": "7846.19454697"
            //                 },
            //                 "product_id": 107150,
            //                 "quotes": {
            //                     "ask_iv": "0.41023239",
            //                     "ask_size": "2397",
            //                     "best_ask": "1374",
            //                     "best_bid": "1322",
            //                     "bid_iv": "0.38929375",
            //                     "bid_size": "3995",
            //                     "impact_mid_price": null,
            //                     "mark_iv": "0.39965618"
            //                 },
            //                 "spot_price": "30598.43379314",
            //                 "strike_price": "30000",
            //                 "symbol": "C-BTC-30000-280723",
            //                 "timestamp": 1689136932893181,
            //                 "turnover_symbol": "USDT"
            //             },
            //         ],
            //         "success":true
            //     }
            //
            var tickers interface{} = this.SafeList(response, "result", []interface{}{})
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(tickers)); i++ {
                var ticker interface{} = this.ParseTicker(GetValue(tickers, i))
                var symbol interface{} = GetValue(ticker, "symbol")
                AddElementToObject(result, symbol, ticker)
            }
        
            ch <- this.FilterByArrayTickers(result, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name delta#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://docs.delta.exchange/#get-l2-orderbook
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *delta) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes14178 := (<-this.LoadMarkets())
            PanicOnError(retRes14178)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "depth", limit)
            }
        
            response:= (<-this.PublicGetL2orderbookSymbol(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "result":{
            //             "buy":[
            //                 {"price":"15814.0","size":912},
            //                 {"price":"15813.5","size":1279},
            //                 {"price":"15813.0","size":1634},
            //             ],
            //             "sell":[
            //                 {"price":"15814.5","size":625},
            //                 {"price":"15815.0","size":982},
            //                 {"price":"15815.5","size":1328},
            //             ],
            //             "symbol":"BTCUSDT"
            //         },
            //         "success":true
            //     }
            //
            var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
        
            ch <- this.ParseOrderBook(result, GetValue(market, "symbol"), nil, "buy", "sell", "price", "size")
            return nil
        
            }()
            return ch
        }
func  (this *delta) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // public fetchTrades
    //
    //     {
    //         "buyer_role":"maker",
    //         "price":"15896.5",
    //         "seller_role":"taker",
    //         "size":241,
    //         "symbol":"BTCUSDT",
    //         "timestamp":1605376684714595
    //     }
    //
    // private fetchMyTrades
    //
    //     {
    //         "commission":"0.008335000000000000",
    //         "created_at":"2020-11-16T19:07:19Z",
    //         "fill_type":"normal",
    //         "id":"e7ff05c233a74245b72381f8dd91d1ce",
    //         "meta_data":{
    //             "effective_commission_rate":"0.0005",
    //             "order_price":"16249",
    //             "order_size":1,
    //             "order_type":"market_order",
    //             "order_unfilled_size":0,
    //             "trading_fee_credits_used":"0"
    //         },
    //         "order_id":"152999629",
    //         "price":"16669",
    //         "product":{
    //             "contract_type":"perpetual_futures",
    //             "contract_unit_currency":"BTC",
    //             "contract_value":"0.001",
    //             "id":139,
    //             "notional_type":"vanilla",
    //             "quoting_asset":{"minimum_precision":2,"precision":6,"symbol":"USDT"},
    //             "settling_asset":{"minimum_precision":2,"precision":6,"symbol":"USDT"},
    //             "symbol":"BTCUSDT",
    //             "tick_size":"0.5",
    //             "underlying_asset":{"minimum_precision":4,"precision":8,"symbol":"BTC"}
    //         },
    //         "product_id":139,
    //         "role":"taker",
    //         "side":"sell",
    //         "size":1
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeString(trade, "id")
    var orderId interface{} = this.SafeString(trade, "order_id")
    var timestamp interface{} = this.Parse8601(this.SafeString(trade, "created_at"))
    timestamp = this.SafeIntegerProduct(trade, "timestamp", 0.001, timestamp)
    var priceString interface{} = this.SafeString(trade, "price")
    var amountString interface{} = this.SafeString(trade, "size")
    var product interface{} = this.SafeDict(trade, "product", map[string]interface{} {})
    var marketId interface{} = this.SafeString(product, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var sellerRole interface{} = this.SafeString(trade, "seller_role")
    var side interface{} = this.SafeString(trade, "side")
    if IsTrue(IsEqual(side, nil)) {
        if IsTrue(IsEqual(sellerRole, "taker")) {
            side = "sell"
        } else if IsTrue(IsEqual(sellerRole, "maker")) {
            side = "buy"
        }
    }
    var takerOrMaker interface{} = this.SafeString(trade, "role")
    var metaData interface{} = this.SafeDict(trade, "meta_data", map[string]interface{} {})
    var typeVar interface{} = this.SafeString(metaData, "order_type")
    if IsTrue(!IsEqual(typeVar, nil)) {
        typeVar = Replace(typeVar, "_order", "")
    }
    var feeCostString interface{} = this.SafeString(trade, "commission")
    var fee interface{} = nil
    if IsTrue(!IsEqual(feeCostString, nil)) {
        var settlingAsset interface{} = this.SafeDict(product, "settling_asset", map[string]interface{} {})
        var feeCurrencyId interface{} = this.SafeString(settlingAsset, "symbol")
        var feeCurrencyCode interface{} = this.SafeCurrencyCode(feeCurrencyId)
        fee = map[string]interface{} {
            "cost": feeCostString,
            "currency": feeCurrencyCode,
        }
    }
    return this.SafeTrade(map[string]interface{} {
        "id": id,
        "order": orderId,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "type": typeVar,
        "side": side,
        "price": priceString,
        "amount": amountString,
        "cost": nil,
        "takerOrMaker": takerOrMaker,
        "fee": fee,
        "info": trade,
    }, market)
}
/**
 * @method
 * @name delta#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://docs.delta.exchange/#get-public-trades
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *delta) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes15608 := (<-this.LoadMarkets())
            PanicOnError(retRes15608)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetTradesSymbol(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "result":[
            //             {
            //                 "buyer_role":"maker",
            //                 "price":"15896.5",
            //                 "seller_role":"taker",
            //                 "size":241,
            //                 "symbol":"BTCUSDT",
            //                 "timestamp":1605376684714595
            //             }
            //         ],
            //         "success":true
            //     }
            //
            var result interface{} = this.SafeList(response, "result", []interface{}{})
        
            ch <- this.ParseTrades(result, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *delta) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "time":1605393120,
    //         "open":15989,
    //         "high":15989,
    //         "low":15987.5,
    //         "close":15987.5,
    //         "volume":565
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.SafeTimestamp(ohlcv, "time"), this.SafeNumber(ohlcv, "open"), this.SafeNumber(ohlcv, "high"), this.SafeNumber(ohlcv, "low"), this.SafeNumber(ohlcv, "close"), this.SafeNumber(ohlcv, "volume")}
}
/**
 * @method
 * @name delta#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://docs.delta.exchange/#delta-exchange-api-v2-historical-ohlc-candles-sparklines
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.until] timestamp in ms of the latest candle to fetch
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *delta) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes16208 := (<-this.LoadMarkets())
            PanicOnError(retRes16208)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "resolution": this.SafeString(this.Timeframes, timeframe, timeframe),
            }
            var duration interface{} = this.ParseTimeframe(timeframe)
            limit = Ternary(IsTrue(limit), limit, 2000) // max 2000
            var until interface{} = this.SafeIntegerProduct(params, "until", 0.001)
            var untilIsDefined interface{} =     (!IsEqual(until, nil))
            if IsTrue(untilIsDefined) {
                until = this.ParseToInt(until)
            }
            if IsTrue(IsEqual(since, nil)) {
                var end interface{} = Ternary(IsTrue(untilIsDefined), until, this.Seconds())
                AddElementToObject(request, "end", end)
                AddElementToObject(request, "start", Subtract(end, Multiply(limit, duration)))
            } else {
                var start interface{} = this.ParseToInt(Divide(since, 1000))
                AddElementToObject(request, "start", start)
                AddElementToObject(request, "end", Ternary(IsTrue(untilIsDefined), until, this.Sum(start, Multiply(limit, duration))))
            }
            var price interface{} = this.SafeString(params, "price")
            if IsTrue(IsEqual(price, "mark")) {
                AddElementToObject(request, "symbol", Add("MARK:", GetValue(market, "id")))
            } else if IsTrue(IsEqual(price, "index")) {
                AddElementToObject(request, "symbol", GetValue(GetValue(GetValue(market, "info"), "spot_index"), "symbol"))
            } else {
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            params = this.Omit(params, []interface{}{"price", "until"})
        
            response:= (<-this.PublicGetHistoryCandles(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "success":true,
            //         "result":[
            //             {"time":1605393120,"open":15989,"high":15989,"low":15987.5,"close":15987.5,"volume":565},
            //             {"time":1605393180,"open":15966,"high":15966,"low":15959,"close":15959,"volume":24},
            //             {"time":1605393300,"open":15973,"high":15973,"low":15973,"close":15973,"volume":1288},
            //         ]
            //     }
            //
            var result interface{} = this.SafeList(response, "result", []interface{}{})
        
            ch <- this.ParseOHLCVs(result, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *delta) ParseBalance(response interface{}) interface{}  {
    var balances interface{} = this.SafeList(response, "result", []interface{}{})
    var result interface{} = map[string]interface{} {
        "info": response,
    }
    var currenciesByNumericId interface{} = this.SafeDict(this.Options, "currenciesByNumericId", map[string]interface{} {})
    for i := 0; IsLessThan(i, GetArrayLength(balances)); i++ {
        var balance interface{} = GetValue(balances, i)
        var currencyId interface{} = this.SafeString(balance, "asset_id")
        var currency interface{} = this.SafeDict(currenciesByNumericId, currencyId)
        var code interface{} = Ternary(IsTrue((IsEqual(currency, nil))), currencyId, GetValue(currency, "code"))
        var account interface{} = this.Account()
        AddElementToObject(account, "total", this.SafeString(balance, "balance"))
        AddElementToObject(account, "free", this.SafeString(balance, "available_balance"))
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name delta#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://docs.delta.exchange/#get-wallet-balances
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *delta) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes16918 := (<-this.LoadMarkets())
            PanicOnError(retRes16918)
        
            response:= (<-this.PrivateGetWalletBalances(params))
            PanicOnError(response)
        
                //
            //     {
            //         "result":[
            //             {
            //                 "asset_id":1,
            //                 "available_balance":"0",
            //                 "balance":"0",
            //                 "commission":"0",
            //                 "id":154883,
            //                 "interest_credit":"0",
            //                 "order_margin":"0",
            //                 "pending_referral_bonus":"0",
            //                 "pending_trading_fee_credit":"0",
            //                 "position_margin":"0",
            //                 "trading_fee_credit":"0",
            //                 "user_id":22142
            //             },
            //         ],
            //         "success":true
            //     }
            //
        ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name delta#fetchPosition
 * @description fetch data on a single open contract trade position
 * @see https://docs.delta.exchange/#get-position
 * @param {string} symbol unified market symbol of the market the position is held in, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *delta) FetchPosition(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes17278 := (<-this.LoadMarkets())
            PanicOnError(retRes17278)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "product_id": GetValue(market, "numericId"),
            }
        
            response:= (<-this.PrivateGetPositions(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "result":{
            //             "entry_price":null,
            //             "size":0,
            //             "timestamp":1605454074268079
            //         },
            //         "success":true
            //     }
            //
            var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
        
            ch <- this.ParsePosition(result, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name delta#fetchPositions
 * @description fetch all open positions
 * @see https://docs.delta.exchange/#get-margined-positions
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *delta) FetchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes17578 := (<-this.LoadMarkets())
            PanicOnError(retRes17578)
        
            response:= (<-this.PrivateGetPositionsMargined(params))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "result": [
            //           {
            //             "user_id": 0,
            //             "size": 0,
            //             "entry_price": "string",
            //             "margin": "string",
            //             "liquidation_price": "string",
            //             "bankruptcy_price": "string",
            //             "adl_level": 0,
            //             "product_id": 0,
            //             "product_symbol": "string",
            //             "commission": "string",
            //             "realized_pnl": "string",
            //             "realized_funding": "string"
            //           }
            //         ]
            //     }
            //
            var result interface{} = this.SafeList(response, "result", []interface{}{})
        
            ch <- this.ParsePositions(result, symbols)
            return nil
        
            }()
            return ch
        }
func  (this *delta) ParsePosition(position interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchPosition
    //
    //     {
    //         "entry_price":null,
    //         "size":0,
    //         "timestamp":1605454074268079
    //     }
    //
    //
    // fetchPositions
    //
    //     {
    //         "user_id": 0,
    //         "size": 0,
    //         "entry_price": "string",
    //         "margin": "string",
    //         "liquidation_price": "string",
    //         "bankruptcy_price": "string",
    //         "adl_level": 0,
    //         "product_id": 0,
    //         "product_symbol": "string",
    //         "commission": "string",
    //         "realized_pnl": "string",
    //         "realized_funding": "string"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(position, "product_symbol")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = GetValue(market, "symbol")
    var timestamp interface{} = this.SafeIntegerProduct(position, "timestamp", 0.001)
    var sizeString interface{} = this.SafeString(position, "size")
    var side interface{} = nil
    if IsTrue(!IsEqual(sizeString, nil)) {
        if IsTrue(Precise.StringGt(sizeString, "0")) {
            side = "buy"
        } else if IsTrue(Precise.StringLt(sizeString, "0")) {
            side = "sell"
        }
    }
    return this.SafePosition(map[string]interface{} {
        "info": position,
        "id": nil,
        "symbol": symbol,
        "notional": nil,
        "marginMode": nil,
        "liquidationPrice": this.SafeNumber(position, "liquidation_price"),
        "entryPrice": this.SafeNumber(position, "entry_price"),
        "unrealizedPnl": nil,
        "percentage": nil,
        "contracts": this.ParseNumber(sizeString),
        "contractSize": this.SafeNumber(market, "contractSize"),
        "markPrice": nil,
        "side": side,
        "hedged": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "maintenanceMargin": nil,
        "maintenanceMarginPercentage": nil,
        "collateral": nil,
        "initialMargin": nil,
        "initialMarginPercentage": nil,
        "leverage": nil,
        "marginRatio": nil,
        "stopLossPrice": nil,
        "takeProfitPrice": nil,
    })
}
func  (this *delta) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "open": "open",
        "pending": "open",
        "closed": "closed",
        "cancelled": "canceled",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *delta) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // createOrder, cancelOrder, editOrder, fetchOpenOrders, fetchClosedOrders
    //
    //     {
    //         "average_fill_price":null,
    //         "bracket_order":null,
    //         "bracket_stop_loss_limit_price":null,
    //         "bracket_stop_loss_price":null,
    //         "bracket_take_profit_limit_price":null,
    //         "bracket_take_profit_price":null,
    //         "bracket_trail_amount":null,
    //         "cancellation_reason":null,
    //         "client_order_id":null,
    //         "close_on_trigger":"false",
    //         "commission":"0",
    //         "created_at":"2020-11-16T02:38:26Z",
    //         "id":152870626,
    //         "limit_price":"10000",
    //         "meta_data":{"source":"api"},
    //         "order_type":"limit_order",
    //         "paid_commission":"0",
    //         "product_id":139,
    //         "reduce_only":false,
    //         "side":"buy",
    //         "size":0,
    //         "state":"open",
    //         "stop_order_type":null,
    //         "stop_price":null,
    //         "stop_trigger_method":"mark_price",
    //         "time_in_force":"gtc",
    //         "trail_amount":null,
    //         "unfilled_size":0,
    //         "user_id":22142
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeString(order, "id")
    var clientOrderId interface{} = this.SafeString(order, "client_order_id")
    var timestamp interface{} = this.Parse8601(this.SafeString(order, "created_at"))
    var marketId interface{} = this.SafeString(order, "product_id")
    var marketsByNumericId interface{} = this.SafeDict(this.Options, "marketsByNumericId", map[string]interface{} {})
    market = this.SafeValue(marketsByNumericId, marketId, market)
    var symbol interface{} = Ternary(IsTrue((IsEqual(market, nil))), marketId, GetValue(market, "symbol"))
    var status interface{} = this.ParseOrderStatus(this.SafeString(order, "state"))
    var side interface{} = this.SafeString(order, "side")
    var typeVar interface{} = this.SafeString(order, "order_type")
    typeVar = Replace(typeVar, "_order", "")
    var price interface{} = this.SafeString(order, "limit_price")
    var amount interface{} = this.SafeString(order, "size")
    var remaining interface{} = this.SafeString(order, "unfilled_size")
    var average interface{} = this.SafeString(order, "average_fill_price")
    var fee interface{} = nil
    var feeCostString interface{} = this.SafeString(order, "paid_commission")
    if IsTrue(!IsEqual(feeCostString, nil)) {
        var feeCurrencyCode interface{} = nil
        if IsTrue(!IsEqual(market, nil)) {
            var settlingAsset interface{} = this.SafeDict(GetValue(market, "info"), "settling_asset", map[string]interface{} {})
            var feeCurrencyId interface{} = this.SafeString(settlingAsset, "symbol")
            feeCurrencyCode = this.SafeCurrencyCode(feeCurrencyId)
        }
        fee = map[string]interface{} {
            "cost": feeCostString,
            "currency": feeCurrencyCode,
        }
    }
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": id,
        "clientOrderId": clientOrderId,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "symbol": symbol,
        "type": typeVar,
        "side": side,
        "price": price,
        "amount": amount,
        "cost": nil,
        "average": average,
        "filled": nil,
        "remaining": remaining,
        "status": status,
        "fee": fee,
        "trades": nil,
    }, market)
}
/**
 * @method
 * @name delta#createOrder
 * @description create a trade order
 * @see https://docs.delta.exchange/#place-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {bool} [params.reduceOnly] *contract only* indicates if this order is to reduce the size of a position
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *delta) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes19668 := (<-this.LoadMarkets())
            PanicOnError(retRes19668)
            var orderType interface{} = Add(typeVar, "_order")
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "product_id": GetValue(market, "numericId"),
                "size": this.AmountToPrecision(GetValue(market, "symbol"), amount),
                "side": side,
                "order_type": orderType,
            }
            if IsTrue(IsEqual(typeVar, "limit")) {
                AddElementToObject(request, "limit_price", this.PriceToPrecision(GetValue(market, "symbol"), price))
            }
            var clientOrderId interface{} = this.SafeString2(params, "clientOrderId", "client_order_id")
            params = this.Omit(params, []interface{}{"clientOrderId", "client_order_id"})
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                AddElementToObject(request, "client_order_id", clientOrderId)
            }
            var reduceOnly interface{} = this.SafeBool(params, "reduceOnly")
            if IsTrue(reduceOnly) {
                AddElementToObject(request, "reduce_only", reduceOnly)
                params = this.Omit(params, "reduceOnly")
            }
        
            response:= (<-this.PrivatePostOrders(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "result":{
            //             "average_fill_price":null,
            //             "bracket_order":null,
            //             "bracket_stop_loss_limit_price":null,
            //             "bracket_stop_loss_price":null,
            //             "bracket_take_profit_limit_price":null,
            //             "bracket_take_profit_price":null,
            //             "bracket_trail_amount":null,
            //             "cancellation_reason":null,
            //             "client_order_id":null,
            //             "close_on_trigger":"false",
            //             "commission":"0",
            //             "created_at":"2020-11-16T02:38:26Z",
            //             "id":152870626,
            //             "limit_price":"10000",
            //             "meta_data":{"source":"api"},
            //             "order_type":"limit_order",
            //             "paid_commission":"0",
            //             "product_id":139,
            //             "reduce_only":false,
            //             "side":"buy",
            //             "size":0,
            //             "state":"open",
            //             "stop_order_type":null,
            //             "stop_price":null,
            //             "stop_trigger_method":"mark_price",
            //             "time_in_force":"gtc",
            //             "trail_amount":null,
            //             "unfilled_size":0,
            //             "user_id":22142
            //         },
            //         "success":true
            //     }
            //
            var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
        
            ch <- this.ParseOrder(result, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name delta#editOrder
 * @description edit a trade order
 * @see https://docs.delta.exchange/#edit-order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of the currency you want to trade in units of the base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *delta) EditOrder(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    amount := GetArg(optionalArgs, 0, nil)
            _ = amount
            price := GetArg(optionalArgs, 1, nil)
            _ = price
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes20498 := (<-this.LoadMarkets())
            PanicOnError(retRes20498)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "id": ParseInt(id),
                "product_id": GetValue(market, "numericId"),
            }
            if IsTrue(!IsEqual(amount, nil)) {
                AddElementToObject(request, "size", ParseInt(this.AmountToPrecision(symbol, amount)))
            }
            if IsTrue(!IsEqual(price, nil)) {
                AddElementToObject(request, "limit_price", this.PriceToPrecision(symbol, price))
            }
        
            response:= (<-this.PrivatePutOrders(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "result": {
            //             "id": "ashb1212",
            //             "product_id": 27,
            //             "limit_price": "9200",
            //             "side": "buy",
            //             "size": 100,
            //             "unfilled_size": 50,
            //             "user_id": 1,
            //             "order_type": "limit_order",
            //             "state": "open",
            //             "created_at": "..."
            //         }
            //     }
            //
            var result interface{} = this.SafeDict(response, "result")
        
            ch <- this.ParseOrder(result, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name delta#cancelOrder
 * @description cancels an open order
 * @see https://docs.delta.exchange/#cancel-order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *delta) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " cancelOrder() requires a symbol argument")))
            }
        
            retRes20998 := (<-this.LoadMarkets())
            PanicOnError(retRes20998)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "id": ParseInt(id),
                "product_id": GetValue(market, "numericId"),
            }
        
            response:= (<-this.PrivateDeleteOrders(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "result":{
            //             "average_fill_price":null,
            //             "bracket_order":null,
            //             "bracket_stop_loss_limit_price":null,
            //             "bracket_stop_loss_price":null,
            //             "bracket_take_profit_limit_price":null,
            //             "bracket_take_profit_price":null,
            //             "bracket_trail_amount":null,
            //             "cancellation_reason":"cancelled_by_user",
            //             "client_order_id":null,
            //             "close_on_trigger":"false",
            //             "commission":"0",
            //             "created_at":"2020-11-16T02:38:26Z",
            //             "id":152870626,
            //             "limit_price":"10000",
            //             "meta_data":{"source":"api"},
            //             "order_type":"limit_order",
            //             "paid_commission":"0",
            //             "product_id":139,
            //             "reduce_only":false,
            //             "side":"buy",
            //             "size":0,
            //             "state":"cancelled",
            //             "stop_order_type":null,
            //             "stop_price":null,
            //             "stop_trigger_method":"mark_price",
            //             "time_in_force":"gtc",
            //             "trail_amount":null,
            //             "unfilled_size":0,
            //             "user_id":22142
            //         },
            //         "success":true
            //     }
            //
            var result interface{} = this.SafeDict(response, "result")
        
            ch <- this.ParseOrder(result, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name delta#cancelAllOrders
 * @description cancel all open orders in a market
 * @see https://docs.delta.exchange/#cancel-all-open-orders
 * @param {string} symbol unified market symbol of the market to cancel orders in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *delta) CancelAllOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " cancelAllOrders() requires a symbol argument")))
            }
        
            retRes21598 := (<-this.LoadMarkets())
            PanicOnError(retRes21598)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "product_id": GetValue(market, "numericId"),
            }
            var response interface{} = this.PrivateDeleteOrdersAll(this.Extend(request, params))
        
                //
            //     {
            //         "result":{},
            //         "success":true
            //     }
            //
        ch <- []interface{}{this.SafeOrder(map[string]interface{} {
            "info": response,
        })}
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name delta#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://docs.delta.exchange/#get-active-orders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of open order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *delta) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
                retRes219215 :=  (<-this.FetchOrdersWithMethod("privateGetOrders", symbol, since, limit, params))
                PanicOnError(retRes219215)
                ch <- retRes219215
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name delta#fetchClosedOrders
 * @description fetches information on multiple closed orders made by the user
 * @see https://docs.delta.exchange/#get-order-history-cancelled-and-closed
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *delta) FetchClosedOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
                retRes220715 :=  (<-this.FetchOrdersWithMethod("privateGetOrdersHistory", symbol, since, limit, params))
                PanicOnError(retRes220715)
                ch <- retRes220715
                return nil
        
            }()
            return ch
        }
func  (this *delta) FetchOrdersWithMethod(method interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes22118 := (<-this.LoadMarkets())
            PanicOnError(retRes22118)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "product_ids", GetValue(market, "numericId")) // accepts a comma-separated list of ids
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_time", Add(ToString(since), "000"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "page_size", limit)
            }
            var response interface{} = nil
            if IsTrue(IsEqual(method, "privateGetOrders")) {
                
        response = (<-this.PrivateGetOrders(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(method, "privateGetOrdersHistory")) {
                
        response = (<-this.PrivateGetOrdersHistory(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            //     {
            //         "success": true,
            //         "result": [
            //             {
            //                 "id": "ashb1212",
            //                 "product_id": 27,
            //                 "limit_price": "9200",
            //                 "side": "buy",
            //                 "size": 100,
            //                 "unfilled_size": 50,
            //                 "user_id": 1,
            //                 "order_type": "limit_order",
            //                 "state": "open",
            //                 "created_at": "..."
            //             }
            //         ],
            //         "meta": {
            //             "after": "string",
            //             "before": "string"
            //         }
            //     }
            //
            var result interface{} = this.SafeList(response, "result", []interface{}{})
        
            ch <- this.ParseOrders(result, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name delta#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://docs.delta.exchange/#get-user-fills-by-filters
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *delta) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes22788 := (<-this.LoadMarkets())
            PanicOnError(retRes22788)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "product_ids", GetValue(market, "numericId")) // accepts a comma-separated list of ids
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_time", Add(ToString(since), "000"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "page_size", limit)
            }
        
            response:= (<-this.PrivateGetFills(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "meta":{
            //             "after":null,
            //             "before":null,
            //             "limit":10,
            //             "total_count":2
            //         },
            //         "result":[
            //             {
            //                 "commission":"0.008335000000000000",
            //                 "created_at":"2020-11-16T19:07:19Z",
            //                 "fill_type":"normal",
            //                 "id":"e7ff05c233a74245b72381f8dd91d1ce",
            //                 "meta_data":{
            //                     "effective_commission_rate":"0.0005",
            //                     "order_price":"16249",
            //                     "order_size":1,
            //                     "order_type":"market_order",
            //                     "order_unfilled_size":0,
            //                     "trading_fee_credits_used":"0"
            //                 },
            //                 "order_id":"152999629",
            //                 "price":"16669",
            //                 "product":{
            //                     "contract_type":"perpetual_futures",
            //                     "contract_unit_currency":"BTC",
            //                     "contract_value":"0.001",
            //                     "id":139,
            //                     "notional_type":"vanilla",
            //                     "quoting_asset":{"minimum_precision":2,"precision":6,"symbol":"USDT"},
            //                     "settling_asset":{"minimum_precision":2,"precision":6,"symbol":"USDT"},
            //                     "symbol":"BTCUSDT",
            //                     "tick_size":"0.5",
            //                     "underlying_asset":{"minimum_precision":4,"precision":8,"symbol":"BTC"}
            //                 },
            //                 "product_id":139,
            //                 "role":"taker",
            //                 "side":"sell",
            //                 "size":1
            //             }
            //         ],
            //         "success":true
            //     }
            //
            var result interface{} = this.SafeList(response, "result", []interface{}{})
        
            ch <- this.ParseTrades(result, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name delta#fetchLedger
 * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
 * @see https://docs.delta.exchange/#get-wallet-transactions
 * @param {string} [code] unified currency code, default is undefined
 * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
 * @param {int} [limit] max number of ledger entries to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger}
 */
func  (this *delta) FetchLedger(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes23618 := (<-this.LoadMarkets())
            PanicOnError(retRes23618)
            var request interface{} = map[string]interface{} {}
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "asset_id", GetValue(currency, "numericId"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "page_size", limit)
            }
        
            response:= (<-this.PrivateGetWalletTransactions(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "meta":{"after":null,"before":null,"limit":10,"total_count":1},
            //         "result":[
            //             {
            //                 "amount":"29.889184",
            //                 "asset_id":5,
            //                 "balance":"29.889184",
            //                 "created_at":"2020-11-15T21:25:01Z",
            //                 "meta_data":{
            //                     "deposit_id":3884,
            //                     "transaction_id":"0x41a60174849828530abb5008e98fc63c9b598288743ec4ba9620bcce900a3b8d"
            //                 },
            //                 "transaction_type":"deposit",
            //                 "user_id":22142,
            //                 "uuid":"70bb5679da3c4637884e2dc63efaa846"
            //             }
            //         ],
            //         "success":true
            //     }
            //
            var result interface{} = this.SafeList(response, "result", []interface{}{})
        
            ch <- this.ParseLedger(result, currency, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *delta) ParseLedgerEntryType(typeVar interface{}) interface{}  {
    var types interface{} = map[string]interface{} {
        "pnl": "pnl",
        "deposit": "transaction",
        "withdrawal": "transaction",
        "commission": "fee",
        "conversion": "trade",
        "referral_bonus": "referral",
        "commission_rebate": "rebate",
    }
    return this.SafeString(types, typeVar, typeVar)
}
func  (this *delta) ParseLedgerEntry(item interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "amount":"29.889184",
    //         "asset_id":5,
    //         "balance":"29.889184",
    //         "created_at":"2020-11-15T21:25:01Z",
    //         "meta_data":{
    //             "deposit_id":3884,
    //             "transaction_id":"0x41a60174849828530abb5008e98fc63c9b598288743ec4ba9620bcce900a3b8d"
    //         },
    //         "transaction_type":"deposit",
    //         "user_id":22142,
    //         "uuid":"70bb5679da3c4637884e2dc63efaa846"
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var id interface{} = this.SafeString(item, "uuid")
    var direction interface{} = nil
    var account interface{} = nil
    var metaData interface{} = this.SafeDict(item, "meta_data", map[string]interface{} {})
    var referenceId interface{} = this.SafeString(metaData, "transaction_id")
    var referenceAccount interface{} = nil
    var typeVar interface{} = this.SafeString(item, "transaction_type")
    if IsTrue(IsTrue(IsTrue(IsTrue(IsTrue(IsTrue((IsEqual(typeVar, "deposit"))) || IsTrue((IsEqual(typeVar, "commission_rebate")))) || IsTrue((IsEqual(typeVar, "referral_bonus")))) || IsTrue((IsEqual(typeVar, "pnl")))) || IsTrue((IsEqual(typeVar, "withdrawal_cancellation")))) || IsTrue((IsEqual(typeVar, "promo_credit")))) {
        direction = "in"
    } else if IsTrue(IsTrue(IsTrue(IsTrue((IsEqual(typeVar, "withdrawal"))) || IsTrue((IsEqual(typeVar, "commission")))) || IsTrue((IsEqual(typeVar, "conversion")))) || IsTrue((IsEqual(typeVar, "perpetual_futures_funding")))) {
        direction = "out"
    }
    typeVar = this.ParseLedgerEntryType(typeVar)
    var currencyId interface{} = this.SafeString(item, "asset_id")
    var currenciesByNumericId interface{} = this.SafeDict(this.Options, "currenciesByNumericId")
    currency = this.SafeValue(currenciesByNumericId, currencyId, currency)
    var code interface{} = Ternary(IsTrue((IsEqual(currency, nil))), nil, GetValue(currency, "code"))
    var amount interface{} = this.SafeString(item, "amount")
    var timestamp interface{} = this.Parse8601(this.SafeString(item, "created_at"))
    var after interface{} = this.SafeString(item, "balance")
    var before interface{} = Precise.StringMax("0", Precise.StringSub(after, amount))
    var status interface{} = "ok"
    return this.SafeLedgerEntry(map[string]interface{} {
        "info": item,
        "id": id,
        "direction": direction,
        "account": account,
        "referenceId": referenceId,
        "referenceAccount": referenceAccount,
        "type": typeVar,
        "currency": code,
        "amount": this.ParseNumber(amount),
        "before": this.ParseNumber(before),
        "after": this.ParseNumber(after),
        "status": status,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "fee": nil,
    }, currency)
}
/**
 * @method
 * @name delta#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.network] unified network code
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *delta) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes24868 := (<-this.LoadMarkets())
            PanicOnError(retRes24868)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "asset_symbol": GetValue(currency, "id"),
            }
            var networkCode interface{} = this.SafeStringUpper(params, "network")
            if IsTrue(!IsEqual(networkCode, nil)) {
                AddElementToObject(request, "network", this.NetworkCodeToId(networkCode, code))
                params = this.Omit(params, "network")
            }
        
            response:= (<-this.PrivateGetDepositsAddress(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "success": true,
            //        "result": {
            //            "id": 1915615,
            //            "user_id": 27854758,
            //            "address": "TXYB4GdKsXKEWbeSNPsmGZu4ZVCkhVh1Zz",
            //            "memo": "",
            //            "status": "active",
            //            "updated_at": "2023-01-12T06:03:46.000Z",
            //            "created_at": "2023-01-12T06:03:46.000Z",
            //            "asset_symbol": "USDT",
            //            "network": "TRC20(TRON)",
            //            "custodian": "fireblocks"
            //        }
            //    }
            //
            var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
        
            ch <- this.ParseDepositAddress(result, currency)
            return nil
        
            }()
            return ch
        }
func  (this *delta) ParseDepositAddress(depositAddress interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "id": 1915615,
    //        "user_id": 27854758,
    //        "address": "TXYB4GdKsXKEWbeSNPsmGZu4ZVCkhVh1Zz",
    //        "memo": "",
    //        "status": "active",
    //        "updated_at": "2023-01-12T06:03:46.000Z",
    //        "created_at": "2023-01-12T06:03:46.000Z",
    //        "asset_symbol": "USDT",
    //        "network": "TRC20(TRON)",
    //        "custodian": "fireblocks"
    //    }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var address interface{} = this.SafeString(depositAddress, "address")
    var marketId interface{} = this.SafeString(depositAddress, "asset_symbol")
    var networkId interface{} = this.SafeString(depositAddress, "network")
    this.CheckAddress(address)
    return map[string]interface{} {
        "info": depositAddress,
        "currency": this.SafeCurrencyCode(marketId, currency),
        "network": this.NetworkIdToCode(networkId),
        "address": address,
        "tag": this.SafeString(depositAddress, "memo"),
    }
}
/**
 * @method
 * @name delta#fetchFundingRate
 * @description fetch the current funding rate
 * @see https://docs.delta.exchange/#get-ticker-for-a-product-by-symbol
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
 */
func  (this *delta) FetchFundingRate(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes25568 := (<-this.LoadMarkets())
            PanicOnError(retRes25568)
            var market interface{} = this.Market(symbol)
            if !IsTrue(GetValue(market, "swap")) {
                panic(BadSymbol(Add(this.Id, " fetchFundingRate() supports swap contracts only")))
            }
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetTickersSymbol(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "result": {
            //             "close": 30600.5,
            //             "contract_type": "perpetual_futures",
            //             "funding_rate": "0.00602961",
            //             "greeks": null,
            //             "high": 30803.0,
            //             "low": 30265.5,
            //             "mark_basis": "-0.45601594",
            //             "mark_price": "30600.10481568",
            //             "oi": "469.9190",
            //             "oi_change_usd_6h": "2226314.9900",
            //             "oi_contracts": "469919",
            //             "oi_value": "469.9190",
            //             "oi_value_symbol": "BTC",
            //             "oi_value_usd": "14385640.6802",
            //             "open": 30458.5,
            //             "price_band": {
            //                 "lower_limit": "29067.08312627",
            //                 "upper_limit": "32126.77608693"
            //             },
            //             "product_id": 139,
            //             "quotes": {
            //                 "ask_iv": null,
            //                 "ask_size": "965",
            //                 "best_ask": "30600.5",
            //                 "best_bid": "30599.5",
            //                 "bid_iv": null,
            //                 "bid_size": "196",
            //                 "impact_mid_price": null,
            //                 "mark_iv": "-0.44931641"
            //             },
            //             "size": 1226303,
            //             "spot_price": "30612.85362773",
            //             "symbol": "BTCUSDT",
            //             "timestamp": 1689136597460456,
            //             "turnover": 37392218.45999999,
            //             "turnover_symbol": "USDT",
            //             "turnover_usd": 37392218.45999999,
            //             "volume": 1226.3029999999485
            //         },
            //         "success": true
            //     }
            //
            var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
        
            ch <- this.ParseFundingRate(result, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name delta#fetchFundingRates
 * @description fetch the funding rate for multiple markets
 * @see https://docs.delta.exchange/#get-tickers-for-products
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rates-structure}, indexed by market symbols
 */
func  (this *delta) FetchFundingRates(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes26248 := (<-this.LoadMarkets())
            PanicOnError(retRes26248)
            symbols = this.MarketSymbols(symbols)
            var request interface{} = map[string]interface{} {
                "contract_types": "perpetual_futures",
            }
        
            response:= (<-this.PublicGetTickers(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "result": [
            //             {
            //                 "close": 30600.5,
            //                 "contract_type": "perpetual_futures",
            //                 "funding_rate": "0.00602961",
            //                 "greeks": null,
            //                 "high": 30803.0,
            //                 "low": 30265.5,
            //                 "mark_basis": "-0.45601594",
            //                 "mark_price": "30600.10481568",
            //                 "oi": "469.9190",
            //                 "oi_change_usd_6h": "2226314.9900",
            //                 "oi_contracts": "469919",
            //                 "oi_value": "469.9190",
            //                 "oi_value_symbol": "BTC",
            //                 "oi_value_usd": "14385640.6802",
            //                 "open": 30458.5,
            //                 "price_band": {
            //                     "lower_limit": "29067.08312627",
            //                     "upper_limit": "32126.77608693"
            //                 },
            //                 "product_id": 139,
            //                 "quotes": {
            //                     "ask_iv": null,
            //                     "ask_size": "965",
            //                     "best_ask": "30600.5",
            //                     "best_bid": "30599.5",
            //                     "bid_iv": null,
            //                     "bid_size": "196",
            //                     "impact_mid_price": null,
            //                     "mark_iv": "-0.44931641"
            //                 },
            //                 "size": 1226303,
            //                 "spot_price": "30612.85362773",
            //                 "symbol": "BTCUSDT",
            //                 "timestamp": 1689136597460456,
            //                 "turnover": 37392218.45999999,
            //                 "turnover_symbol": "USDT",
            //                 "turnover_usd": 37392218.45999999,
            //                 "volume": 1226.3029999999485
            //             },
            //         ],
            //         "success":true
            //     }
            //
            var rates interface{} = this.SafeList(response, "result", []interface{}{})
        
            ch <- this.ParseFundingRates(rates, symbols)
            return nil
        
            }()
            return ch
        }
func  (this *delta) ParseFundingRate(contract interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "close": 30600.5,
    //         "contract_type": "perpetual_futures",
    //         "funding_rate": "0.00602961",
    //         "greeks": null,
    //         "high": 30803.0,
    //         "low": 30265.5,
    //         "mark_basis": "-0.45601594",
    //         "mark_price": "30600.10481568",
    //         "oi": "469.9190",
    //         "oi_change_usd_6h": "2226314.9900",
    //         "oi_contracts": "469919",
    //         "oi_value": "469.9190",
    //         "oi_value_symbol": "BTC",
    //         "oi_value_usd": "14385640.6802",
    //         "open": 30458.5,
    //         "price_band": {
    //             "lower_limit": "29067.08312627",
    //             "upper_limit": "32126.77608693"
    //         },
    //         "product_id": 139,
    //         "quotes": {
    //             "ask_iv": null,
    //             "ask_size": "965",
    //             "best_ask": "30600.5",
    //             "best_bid": "30599.5",
    //             "bid_iv": null,
    //             "bid_size": "196",
    //             "impact_mid_price": null,
    //             "mark_iv": "-0.44931641"
    //         },
    //         "size": 1226303,
    //         "spot_price": "30612.85362773",
    //         "symbol": "BTCUSDT",
    //         "timestamp": 1689136597460456,
    //         "turnover": 37392218.45999999,
    //         "turnover_symbol": "USDT",
    //         "turnover_usd": 37392218.45999999,
    //         "volume": 1226.3029999999485
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeIntegerProduct(contract, "timestamp", 0.001)
    var marketId interface{} = this.SafeString(contract, "symbol")
    var fundingRateString interface{} = this.SafeString(contract, "funding_rate")
    var fundingRate interface{} = Precise.StringDiv(fundingRateString, "100")
    return map[string]interface{} {
        "info": contract,
        "symbol": this.SafeSymbol(marketId, market),
        "markPrice": this.SafeNumber(contract, "mark_price"),
        "indexPrice": this.SafeNumber(contract, "spot_price"),
        "interestRate": nil,
        "estimatedSettlePrice": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "fundingRate": this.ParseNumber(fundingRate),
        "fundingTimestamp": nil,
        "fundingDatetime": nil,
        "nextFundingRate": nil,
        "nextFundingTimestamp": nil,
        "nextFundingDatetime": nil,
        "previousFundingRate": nil,
        "previousFundingTimestamp": nil,
        "previousFundingDatetime": nil,
        "interval": nil,
    }
}
/**
 * @method
 * @name delta#addMargin
 * @description add margin
 * @see https://docs.delta.exchange/#add-remove-position-margin
 * @param {string} symbol unified market symbol
 * @param {float} amount amount of margin to add
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=add-margin-structure}
 */
func  (this *delta) AddMargin(symbol interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes276115 :=  (<-this.ModifyMarginHelper(symbol, amount, "add", params))
                PanicOnError(retRes276115)
                ch <- retRes276115
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name delta#reduceMargin
 * @description remove margin from a position
 * @see https://docs.delta.exchange/#add-remove-position-margin
 * @param {string} symbol unified market symbol
 * @param {float} amount the amount of margin to remove
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=reduce-margin-structure}
 */
func  (this *delta) ReduceMargin(symbol interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes277515 :=  (<-this.ModifyMarginHelper(symbol, amount, "reduce", params))
                PanicOnError(retRes277515)
                ch <- retRes277515
                return nil
        
            }()
            return ch
        }
func  (this *delta) ModifyMarginHelper(symbol interface{}, amount interface{}, typeVar interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes27798 := (<-this.LoadMarkets())
            PanicOnError(retRes27798)
            var market interface{} = this.Market(symbol)
            amount = ToString(amount)
            if IsTrue(IsEqual(typeVar, "reduce")) {
                amount = Precise.StringMul(amount, "-1")
            }
            var request interface{} = map[string]interface{} {
                "product_id": GetValue(market, "numericId"),
                "delta_margin": amount,
            }
        
            response:= (<-this.PrivatePostPositionsChangeMargin(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "result": {
            //             "auto_topup": false,
            //             "bankruptcy_price": "24934.12",
            //             "commission": "0.01197072",
            //             "created_at": "2023-07-20T03:49:09.159401Z",
            //             "entry_price": "29926.8",
            //             "liquidation_price": "25083.754",
            //             "margin": "4.99268",
            //             "margin_mode": "isolated",
            //             "product_id": 84,
            //             "product_symbol": "BTCUSDT",
            //             "realized_cashflow": "0",
            //             "realized_funding": "0",
            //             "realized_pnl": "0",
            //             "size": 1,
            //             "updated_at": "2023-07-20T03:49:09.159401Z",
            //             "user_id": 30084879
            //         },
            //         "success": true
            //     }
            //
            var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
        
            ch <- this.ParseMarginModification(result, market)
            return nil
        
            }()
            return ch
        }
func  (this *delta) ParseMarginModification(data interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "auto_topup": false,
    //         "bankruptcy_price": "24934.12",
    //         "commission": "0.01197072",
    //         "created_at": "2023-07-20T03:49:09.159401Z",
    //         "entry_price": "29926.8",
    //         "liquidation_price": "25083.754",
    //         "margin": "4.99268",
    //         "margin_mode": "isolated",
    //         "product_id": 84,
    //         "product_symbol": "BTCUSDT",
    //         "realized_cashflow": "0",
    //         "realized_funding": "0",
    //         "realized_pnl": "0",
    //         "size": 1,
    //         "updated_at": "2023-07-20T03:49:09.159401Z",
    //         "user_id": 30084879
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(data, "product_symbol")
    market = this.SafeMarket(marketId, market)
    return map[string]interface{} {
        "info": data,
        "symbol": GetValue(market, "symbol"),
        "type": nil,
        "marginMode": "isolated",
        "amount": nil,
        "total": this.SafeNumber(data, "margin"),
        "code": nil,
        "status": nil,
        "timestamp": nil,
        "datetime": nil,
    }
}
/**
 * @method
 * @name delta#fetchOpenInterest
 * @description retrieves the open interest of a derivative market
 * @see https://docs.delta.exchange/#get-ticker-for-a-product-by-symbol
 * @param {string} symbol unified market symbol
 * @param {object} [params] exchange specific parameters
 * @returns {object} an open interest structure{@link https://docs.ccxt.com/#/?id=open-interest-structure}
 */
func  (this *delta) FetchOpenInterest(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes28648 := (<-this.LoadMarkets())
            PanicOnError(retRes28648)
            var market interface{} = this.Market(symbol)
            if !IsTrue(GetValue(market, "contract")) {
                panic(BadRequest(Add(this.Id, " fetchOpenInterest() supports contract markets only")))
            }
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetTickersSymbol(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "result": {
            //             "close": 894.0,
            //             "contract_type": "call_options",
            //             "greeks": {
            //                 "delta": "0.67324861",
            //                 "gamma": "0.00022178",
            //                 "rho": "4.34638266",
            //                 "spot": "30178.53195697",
            //                 "theta": "-35.64972577",
            //                 "vega": "16.34381277"
            //             },
            //             "high": 946.0,
            //             "low": 893.0,
            //             "mark_price": "1037.07582681",
            //             "mark_vol": "0.35899491",
            //             "oi": "0.0910",
            //             "oi_change_usd_6h": "-90.5500",
            //             "oi_contracts": "91",
            //             "oi_value": "0.0910",
            //             "oi_value_symbol": "BTC",
            //             "oi_value_usd": "2746.3549",
            //             "open": 946.0,
            //             "price_band": {
            //                 "lower_limit": "133.37794509",
            //                 "upper_limit": "5663.66930164"
            //             },
            //             "product_id": 116171,
            //             "quotes": {
            //                 "ask_iv": "0.36932389",
            //                 "ask_size": "1321",
            //                 "best_ask": "1054",
            //                 "best_bid": "1020",
            //                 "bid_iv": "0.34851914",
            //                 "bid_size": "2202",
            //                 "impact_mid_price": null,
            //                 "mark_iv": "0.35896335"
            //             },
            //             "size": 152,
            //             "spot_price": "30178.53195697",
            //             "strike_price": "29500",
            //             "symbol": "C-BTC-29500-280723",
            //             "timestamp": 1689834695286094,
            //             "turnover": 4546.601744940001,
            //             "turnover_symbol": "USDT",
            //             "turnover_usd": 4546.601744940001,
            //             "volume": 0.15200000000000002
            //         },
            //         "success": true
            //     }
            //
            var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
        
            ch <- this.ParseOpenInterest(result, market)
            return nil
        
            }()
            return ch
        }
func  (this *delta) ParseOpenInterest(interest interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "close": 894.0,
    //         "contract_type": "call_options",
    //         "greeks": {
    //             "delta": "0.67324861",
    //             "gamma": "0.00022178",
    //             "rho": "4.34638266",
    //             "spot": "30178.53195697",
    //             "theta": "-35.64972577",
    //             "vega": "16.34381277"
    //         },
    //         "high": 946.0,
    //         "low": 893.0,
    //         "mark_price": "1037.07582681",
    //         "mark_vol": "0.35899491",
    //         "oi": "0.0910",
    //         "oi_change_usd_6h": "-90.5500",
    //         "oi_contracts": "91",
    //         "oi_value": "0.0910",
    //         "oi_value_symbol": "BTC",
    //         "oi_value_usd": "2746.3549",
    //         "open": 946.0,
    //         "price_band": {
    //             "lower_limit": "133.37794509",
    //             "upper_limit": "5663.66930164"
    //         },
    //         "product_id": 116171,
    //         "quotes": {
    //             "ask_iv": "0.36932389",
    //             "ask_size": "1321",
    //             "best_ask": "1054",
    //             "best_bid": "1020",
    //             "bid_iv": "0.34851914",
    //             "bid_size": "2202",
    //             "impact_mid_price": null,
    //             "mark_iv": "0.35896335"
    //         },
    //         "size": 152,
    //         "spot_price": "30178.53195697",
    //         "strike_price": "29500",
    //         "symbol": "C-BTC-29500-280723",
    //         "timestamp": 1689834695286094,
    //         "turnover": 4546.601744940001,
    //         "turnover_symbol": "USDT",
    //         "turnover_usd": 4546.601744940001,
    //         "volume": 0.15200000000000002
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeIntegerProduct(interest, "timestamp", 0.001)
    var marketId interface{} = this.SafeString(interest, "symbol")
    return this.SafeOpenInterest(map[string]interface{} {
        "symbol": this.SafeSymbol(marketId, market),
        "baseVolume": this.SafeNumber(interest, "oi_value"),
        "quoteVolume": this.SafeNumber(interest, "oi_value_usd"),
        "openInterestAmount": this.SafeNumber(interest, "oi_contracts"),
        "openInterestValue": this.SafeNumber(interest, "oi"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "info": interest,
    }, market)
}
/**
 * @method
 * @name delta#fetchLeverage
 * @description fetch the set leverage for a market
 * @see https://docs.delta.exchange/#get-order-leverage
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [leverage structure]{@link https://docs.ccxt.com/#/?id=leverage-structure}
 */
func  (this *delta) FetchLeverage(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes30038 := (<-this.LoadMarkets())
            PanicOnError(retRes30038)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "product_id": GetValue(market, "numericId"),
            }
        
            response:= (<-this.PrivateGetProductsProductIdOrdersLeverage(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "result": {
            //             "index_symbol": null,
            //             "leverage": "10",
            //             "margin_mode": "isolated",
            //             "order_margin": "0",
            //             "product_id": 84,
            //             "user_id": 30084879
            //         },
            //         "success": true
            //     }
            //
            var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
        
            ch <- this.ParseLeverage(result, market)
            return nil
        
            }()
            return ch
        }
func  (this *delta) ParseLeverage(leverage interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(leverage, "index_symbol")
    var leverageValue interface{} = this.SafeInteger(leverage, "leverage")
    return map[string]interface{} {
        "info": leverage,
        "symbol": this.SafeSymbol(marketId, market),
        "marginMode": this.SafeStringLower(leverage, "margin_mode"),
        "longLeverage": leverageValue,
        "shortLeverage": leverageValue,
    }
}
/**
 * @method
 * @name delta#setLeverage
 * @description set the level of leverage for a market
 * @see https://docs.delta.exchange/#change-order-leverage
 * @param {float} leverage the rate of leverage
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} response from the exchange
 */
func  (this *delta) SetLeverage(leverage interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " setLeverage() requires a symbol argument")))
            }
        
            retRes30528 := (<-this.LoadMarkets())
            PanicOnError(retRes30528)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "product_id": GetValue(market, "numericId"),
                "leverage": leverage,
            }
        
                retRes306915 :=  (<-this.PrivatePostProductsProductIdOrdersLeverage(this.Extend(request, params)))
                PanicOnError(retRes306915)
                    //
            //     {
            //         "result": {
            //             "leverage": "20",
            //             "margin_mode": "isolated",
            //             "order_margin": "0",
            //             "product_id": 84
            //         },
            //         "success": true
            //     }
            //
        ch <- retRes306915
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name delta#fetchSettlementHistory
 * @description fetches historical settlement records
 * @see https://docs.delta.exchange/#get-product-settlement-prices
 * @param {string} symbol unified market symbol of the settlement history
 * @param {int} [since] timestamp in ms
 * @param {int} [limit] number of records
 * @param {object} [params] exchange specific params
 * @returns {object[]} a list of [settlement history objects]{@link https://docs.ccxt.com/#/?id=settlement-history-structure}
 */
func  (this *delta) FetchSettlementHistory(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes30848 := (<-this.LoadMarkets())
            PanicOnError(retRes30848)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var request interface{} = map[string]interface{} {
                "states": "expired",
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "page_size", limit)
            }
        
            response:= (<-this.PublicGetProducts(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "result": [
            //             {
            //                 "contract_value": "0.001",
            //                 "basis_factor_max_limit": "10.95",
            //                 "maker_commission_rate": "0.0003",
            //                 "launch_time": "2023-07-19T04:30:03Z",
            //                 "trading_status": "operational",
            //                 "product_specs": {
            //                     "backup_vol_expiry_time": 31536000,
            //                     "max_deviation_from_external_vol": 0.75,
            //                     "max_lower_deviation_from_external_vol": 0.75,
            //                     "max_upper_deviation_from_external_vol": 0.5,
            //                     "max_volatility": 3,
            //                     "min_volatility": 0.1,
            //                     "premium_commission_rate": 0.1,
            //                     "settlement_index_price": "29993.536675710806",
            //                     "vol_calculation_method": "orderbook",
            //                     "vol_expiry_time": 31536000
            //                 },
            //                 "description": "BTC call option expiring on 19-7-2023",
            //                 "settlement_price": "0",
            //                 "disruption_reason": null,
            //                 "settling_asset": {},
            //                 "initial_margin": "1",
            //                 "tick_size": "0.1",
            //                 "maintenance_margin": "0.5",
            //                 "id": 117542,
            //                 "notional_type": "vanilla",
            //                 "ui_config": {},
            //                 "contract_unit_currency": "BTC",
            //                 "symbol": "C-BTC-30900-190723",
            //                 "insurance_fund_margin_contribution": "1",
            //                 "price_band": "2",
            //                 "annualized_funding": "10.95",
            //                 "impact_size": 200,
            //                 "contract_type": "call_options",
            //                 "position_size_limit": 255633,
            //                 "max_leverage_notional": "200000",
            //                 "initial_margin_scaling_factor": "0.000002",
            //                 "strike_price": "30900",
            //                 "is_quanto": false,
            //                 "settlement_time": "2023-07-19T12:00:00Z",
            //                 "liquidation_penalty_factor": "0.5",
            //                 "funding_method": "mark_price",
            //                 "taker_commission_rate": "0.0003",
            //                 "default_leverage": "100.000000000000000000",
            //                 "state": "expired",
            //                 "auction_start_time": null,
            //                 "short_description": "BTC  Call",
            //                 "quoting_asset": {},
            //                 "maintenance_margin_scaling_factor":"0.000002"
            //             }
            //         ],
            //         "success": true
            //     }
            //
            var result interface{} = this.SafeList(response, "result", []interface{}{})
            var settlements interface{} = this.ParseSettlements(result, market)
            var sorted interface{} = this.SortBy(settlements, "timestamp")
        
            ch <- this.FilterBySymbolSinceLimit(sorted, GetValue(market, "symbol"), since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *delta) ParseSettlement(settlement interface{}, market interface{}) interface{}  {
    //
    //     {
    //         "contract_value": "0.001",
    //         "basis_factor_max_limit": "10.95",
    //         "maker_commission_rate": "0.0003",
    //         "launch_time": "2023-07-19T04:30:03Z",
    //         "trading_status": "operational",
    //         "product_specs": {
    //             "backup_vol_expiry_time": 31536000,
    //             "max_deviation_from_external_vol": 0.75,
    //             "max_lower_deviation_from_external_vol": 0.75,
    //             "max_upper_deviation_from_external_vol": 0.5,
    //             "max_volatility": 3,
    //             "min_volatility": 0.1,
    //             "premium_commission_rate": 0.1,
    //             "settlement_index_price": "29993.536675710806",
    //             "vol_calculation_method": "orderbook",
    //             "vol_expiry_time": 31536000
    //         },
    //         "description": "BTC call option expiring on 19-7-2023",
    //         "settlement_price": "0",
    //         "disruption_reason": null,
    //         "settling_asset": {},
    //         "initial_margin": "1",
    //         "tick_size": "0.1",
    //         "maintenance_margin": "0.5",
    //         "id": 117542,
    //         "notional_type": "vanilla",
    //         "ui_config": {},
    //         "contract_unit_currency": "BTC",
    //         "symbol": "C-BTC-30900-190723",
    //         "insurance_fund_margin_contribution": "1",
    //         "price_band": "2",
    //         "annualized_funding": "10.95",
    //         "impact_size": 200,
    //         "contract_type": "call_options",
    //         "position_size_limit": 255633,
    //         "max_leverage_notional": "200000",
    //         "initial_margin_scaling_factor": "0.000002",
    //         "strike_price": "30900",
    //         "is_quanto": false,
    //         "settlement_time": "2023-07-19T12:00:00Z",
    //         "liquidation_penalty_factor": "0.5",
    //         "funding_method": "mark_price",
    //         "taker_commission_rate": "0.0003",
    //         "default_leverage": "100.000000000000000000",
    //         "state": "expired",
    //         "auction_start_time": null,
    //         "short_description": "BTC  Call",
    //         "quoting_asset": {},
    //         "maintenance_margin_scaling_factor":"0.000002"
    //     }
    //
    var datetime interface{} = this.SafeString(settlement, "settlement_time")
    var marketId interface{} = this.SafeString(settlement, "symbol")
    return map[string]interface{} {
        "info": settlement,
        "symbol": this.SafeSymbol(marketId, market),
        "price": this.SafeNumber(settlement, "settlement_price"),
        "timestamp": this.Parse8601(datetime),
        "datetime": datetime,
    }
}
func  (this *delta) ParseSettlements(settlements interface{}, market interface{}) interface{}  {
    var result interface{} = []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(settlements)); i++ {
        AppendToArray(&result,this.ParseSettlement(GetValue(settlements, i), market))
    }
    return result
}
/**
 * @method
 * @name delta#fetchGreeks
 * @description fetches an option contracts greeks, financial metrics used to measure the factors that affect the price of an options contract
 * @see https://docs.delta.exchange/#get-ticker-for-a-product-by-symbol
 * @param {string} symbol unified symbol of the market to fetch greeks for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [greeks structure]{@link https://docs.ccxt.com/#/?id=greeks-structure}
 */
func  (this *delta) FetchGreeks(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes32438 := (<-this.LoadMarkets())
            PanicOnError(retRes32438)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetTickersSymbol(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "result": {
            //             "close": 6793.0,
            //             "contract_type": "call_options",
            //             "greeks": {
            //                 "delta": "0.94739174",
            //                 "gamma": "0.00002206",
            //                 "rho": "11.00890725",
            //                 "spot": "36839.58124652",
            //                 "theta": "-18.18365310",
            //                 "vega": "7.85209698"
            //             },
            //             "high": 7556.0,
            //             "low": 6793.0,
            //             "mark_price": "6955.70698909",
            //             "mark_vol": "0.66916863",
            //             "oi": "1.8980",
            //             "oi_change_usd_6h": "110.4600",
            //             "oi_contracts": "1898",
            //             "oi_value": "1.8980",
            //             "oi_value_symbol": "BTC",
            //             "oi_value_usd": "69940.7319",
            //             "open": 7.2e3,
            //             "price_band": {
            //                 "lower_limit": "5533.89814767",
            //                 "upper_limit": "11691.37688371"
            //             },
            //             "product_id": 129508,
            //             "quotes": {
            //                 "ask_iv": "0.90180438",
            //                 "ask_size": "1898",
            //                 "best_ask": "7210",
            //                 "best_bid": "6913",
            //                 "bid_iv": "0.60881706",
            //                 "bid_size": "3163",
            //                 "impact_mid_price": null,
            //                 "mark_iv": "0.66973549"
            //             },
            //             "size": 5,
            //             "spot_price": "36839.58153868",
            //             "strike_price": "30000",
            //             "symbol": "C-BTC-30000-241123",
            //             "timestamp": 1699584998504530,
            //             "turnover": 184.41206804,
            //             "turnover_symbol": "USDT",
            //             "turnover_usd": 184.41206804,
            //             "volume": 0.005
            //         },
            //         "success": true
            //     }
            //
            var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
        
            ch <- this.ParseGreeks(result, market)
            return nil
        
            }()
            return ch
        }
func  (this *delta) ParseGreeks(greeks interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "close": 6793.0,
    //         "contract_type": "call_options",
    //         "greeks": {
    //             "delta": "0.94739174",
    //             "gamma": "0.00002206",
    //             "rho": "11.00890725",
    //             "spot": "36839.58124652",
    //             "theta": "-18.18365310",
    //             "vega": "7.85209698"
    //         },
    //         "high": 7556.0,
    //         "low": 6793.0,
    //         "mark_price": "6955.70698909",
    //         "mark_vol": "0.66916863",
    //         "oi": "1.8980",
    //         "oi_change_usd_6h": "110.4600",
    //         "oi_contracts": "1898",
    //         "oi_value": "1.8980",
    //         "oi_value_symbol": "BTC",
    //         "oi_value_usd": "69940.7319",
    //         "open": 7.2e3,
    //         "price_band": {
    //             "lower_limit": "5533.89814767",
    //             "upper_limit": "11691.37688371"
    //         },
    //         "product_id": 129508,
    //         "quotes": {
    //             "ask_iv": "0.90180438",
    //             "ask_size": "1898",
    //             "best_ask": "7210",
    //             "best_bid": "6913",
    //             "bid_iv": "0.60881706",
    //             "bid_size": "3163",
    //             "impact_mid_price": null,
    //             "mark_iv": "0.66973549"
    //         },
    //         "size": 5,
    //         "spot_price": "36839.58153868",
    //         "strike_price": "30000",
    //         "symbol": "C-BTC-30000-241123",
    //         "timestamp": 1699584998504530,
    //         "turnover": 184.41206804,
    //         "turnover_symbol": "USDT",
    //         "turnover_usd": 184.41206804,
    //         "volume": 0.005
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeIntegerProduct(greeks, "timestamp", 0.001)
    var marketId interface{} = this.SafeString(greeks, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var stats interface{} = this.SafeDict(greeks, "greeks", map[string]interface{} {})
    var quotes interface{} = this.SafeDict(greeks, "quotes", map[string]interface{} {})
    return map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "delta": this.SafeNumber(stats, "delta"),
        "gamma": this.SafeNumber(stats, "gamma"),
        "theta": this.SafeNumber(stats, "theta"),
        "vega": this.SafeNumber(stats, "vega"),
        "rho": this.SafeNumber(stats, "rho"),
        "bidSize": this.SafeNumber(quotes, "bid_size"),
        "askSize": this.SafeNumber(quotes, "ask_size"),
        "bidImpliedVolatility": this.SafeNumber(quotes, "bid_iv"),
        "askImpliedVolatility": this.SafeNumber(quotes, "ask_iv"),
        "markImpliedVolatility": this.SafeNumber(quotes, "mark_iv"),
        "bidPrice": this.SafeNumber(quotes, "best_bid"),
        "askPrice": this.SafeNumber(quotes, "best_ask"),
        "markPrice": this.SafeNumber(greeks, "mark_price"),
        "lastPrice": nil,
        "underlyingPrice": this.SafeNumber(greeks, "spot_price"),
        "info": greeks,
    }
}
/**
 * @method
 * @name delta#closeAllPositions
 * @description closes all open positions for a market type
 * @see https://docs.delta.exchange/#close-all-positions
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.user_id] the users id
 * @returns {object[]} A list of [position structures]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *delta) CloseAllPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes33938 := (<-this.LoadMarkets())
            PanicOnError(retRes33938)
            var request interface{} = map[string]interface{} {
                "close_all_portfolio": true,
                "close_all_isolated": true,
            }
        
            response:= (<-this.PrivatePostPositionsCloseAll(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {"result":{},"success":true}
            //
            var position interface{} = this.ParsePosition(this.SafeDict(response, "result", map[string]interface{} {}))
        
            ch <- []interface{}{position}
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name delta#fetchMarginMode
 * @description fetches the margin mode of a trading pair
 * @see https://docs.delta.exchange/#get-user
 * @param {string} symbol unified symbol of the market to fetch the margin mode for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [margin mode structure]{@link https://docs.ccxt.com/#/?id=margin-mode-structure}
 */
func  (this *delta) FetchMarginMode(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes34178 := (<-this.LoadMarkets())
            PanicOnError(retRes34178)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
        
            response:= (<-this.PrivateGetProfile(params))
            PanicOnError(response)
            //
            //     {
            //         "result": {
            //             "is_password_set": true,
            //             "kyc_expiry_date": null,
            //             "phishing_code": "12345",
            //             "preferences": {
            //                 "favorites": []
            //             },
            //             "is_kyc_provisioned": false,
            //             "country": "Canada",
            //             "margin_mode": "isolated",
            //             "mfa_updated_at": "2023-07-19T01:04:43Z",
            //             "last_name": "",
            //             "oauth_apple_active": false,
            //             "pf_index_symbol": null,
            //             "proof_of_identity_status": "approved",
            //             "dob": null,
            //             "email": "abc_123@gmail.com",
            //             "force_change_password": false,
            //             "nick_name": "still-breeze-123",
            //             "oauth_google_active": false,
            //             "phone_verification_status": "verified",
            //             "id": 12345678,
            //             "last_seen": null,
            //             "is_withdrawal_enabled": true,
            //             "force_change_mfa": false,
            //             "enable_bots": false,
            //             "kyc_verified_on": null,
            //             "created_at": "2023-07-19T01:02:32Z",
            //             "withdrawal_blocked_till": null,
            //             "proof_of_address_status": "approved",
            //             "is_password_change_blocked": false,
            //             "is_mfa_enabled": true,
            //             "is_kyc_done": true,
            //             "oauth": null,
            //             "account_name": "Main",
            //             "sub_account_permissions": null,
            //             "phone_number": null,
            //             "tracking_info": {
            //                 "ga_cid": "1234.4321",
            //                 "is_kyc_gtm_tracked": true,
            //                 "sub_account_config": {
            //                     "cross": 2,
            //                     "isolated": 2,
            //                     "portfolio": 2
            //                 }
            //             },
            //             "first_name": "",
            //             "phone_verified_on": null,
            //             "seen_intro": false,
            //             "password_updated_at": null,
            //             "is_login_enabled": true,
            //             "registration_date": "2023-07-19T01:02:32Z",
            //             "permissions": {},
            //             "max_sub_accounts_limit": 2,
            //             "country_calling_code": null,
            //             "is_sub_account": false,
            //             "is_kyc_refresh_required": false
            //         },
            //         "success": true
            //     }
            //
            var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
        
            ch <- this.ParseMarginMode(result, market)
            return nil
        
            }()
            return ch
        }
func  (this *delta) ParseMarginMode(marginMode interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var symbol interface{} = nil
    if IsTrue(!IsEqual(market, nil)) {
        symbol = GetValue(market, "symbol")
    }
    return map[string]interface{} {
        "info": marginMode,
        "symbol": symbol,
        "marginMode": this.SafeString(marginMode, "margin_mode"),
    }
}
/**
 * @method
 * @name delta#fetchOption
 * @description fetches option data that is commonly found in an option chain
 * @see https://docs.delta.exchange/#get-ticker-for-a-product-by-symbol
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [option chain structure]{@link https://docs.ccxt.com/#/?id=option-chain-structure}
 */
func  (this *delta) FetchOption(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes35128 := (<-this.LoadMarkets())
            PanicOnError(retRes35128)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetTickersSymbol(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "result": {
            //             "close": 6793.0,
            //             "contract_type": "call_options",
            //             "greeks": {
            //                 "delta": "0.94739174",
            //                 "gamma": "0.00002206",
            //                 "rho": "11.00890725",
            //                 "spot": "36839.58124652",
            //                 "theta": "-18.18365310",
            //                 "vega": "7.85209698"
            //             },
            //             "high": 7556.0,
            //             "low": 6793.0,
            //             "mark_price": "6955.70698909",
            //             "mark_vol": "0.66916863",
            //             "oi": "1.8980",
            //             "oi_change_usd_6h": "110.4600",
            //             "oi_contracts": "1898",
            //             "oi_value": "1.8980",
            //             "oi_value_symbol": "BTC",
            //             "oi_value_usd": "69940.7319",
            //             "open": 7.2e3,
            //             "price_band": {
            //                 "lower_limit": "5533.89814767",
            //                 "upper_limit": "11691.37688371"
            //             },
            //             "product_id": 129508,
            //             "quotes": {
            //                 "ask_iv": "0.90180438",
            //                 "ask_size": "1898",
            //                 "best_ask": "7210",
            //                 "best_bid": "6913",
            //                 "bid_iv": "0.60881706",
            //                 "bid_size": "3163",
            //                 "impact_mid_price": null,
            //                 "mark_iv": "0.66973549"
            //             },
            //             "size": 5,
            //             "spot_price": "36839.58153868",
            //             "strike_price": "30000",
            //             "symbol": "C-BTC-30000-241123",
            //             "timestamp": 1699584998504530,
            //             "turnover": 184.41206804,
            //             "turnover_symbol": "USDT",
            //             "turnover_usd": 184.41206804,
            //             "volume": 0.005
            //         },
            //         "success": true
            //     }
            //
            var result interface{} = this.SafeDict(response, "result", map[string]interface{} {})
        
            ch <- this.ParseOption(result, nil, market)
            return nil
        
            }()
            return ch
        }
func  (this *delta) ParseOption(chain interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "close": 6793.0,
    //         "contract_type": "call_options",
    //         "greeks": {
    //             "delta": "0.94739174",
    //             "gamma": "0.00002206",
    //             "rho": "11.00890725",
    //             "spot": "36839.58124652",
    //             "theta": "-18.18365310",
    //             "vega": "7.85209698"
    //         },
    //         "high": 7556.0,
    //         "low": 6793.0,
    //         "mark_price": "6955.70698909",
    //         "mark_vol": "0.66916863",
    //         "oi": "1.8980",
    //         "oi_change_usd_6h": "110.4600",
    //         "oi_contracts": "1898",
    //         "oi_value": "1.8980",
    //         "oi_value_symbol": "BTC",
    //         "oi_value_usd": "69940.7319",
    //         "open": 7.2e3,
    //         "price_band": {
    //             "lower_limit": "5533.89814767",
    //             "upper_limit": "11691.37688371"
    //         },
    //         "product_id": 129508,
    //         "quotes": {
    //             "ask_iv": "0.90180438",
    //             "ask_size": "1898",
    //             "best_ask": "7210",
    //             "best_bid": "6913",
    //             "bid_iv": "0.60881706",
    //             "bid_size": "3163",
    //             "impact_mid_price": null,
    //             "mark_iv": "0.66973549"
    //         },
    //         "size": 5,
    //         "spot_price": "36839.58153868",
    //         "strike_price": "30000",
    //         "symbol": "C-BTC-30000-241123",
    //         "timestamp": 1699584998504530,
    //         "turnover": 184.41206804,
    //         "turnover_symbol": "USDT",
    //         "turnover_usd": 184.41206804,
    //         "volume": 0.005
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    var marketId interface{} = this.SafeString(chain, "symbol")
    market = this.SafeMarket(marketId, market)
    var quotes interface{} = this.SafeDict(chain, "quotes", map[string]interface{} {})
    var timestamp interface{} = this.SafeIntegerProduct(chain, "timestamp", 0.001)
    return map[string]interface{} {
        "info": chain,
        "currency": nil,
        "symbol": GetValue(market, "symbol"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "impliedVolatility": this.SafeNumber(quotes, "mark_iv"),
        "openInterest": this.SafeNumber(chain, "oi"),
        "bidPrice": this.SafeNumber(quotes, "best_bid"),
        "askPrice": this.SafeNumber(quotes, "best_ask"),
        "midPrice": this.SafeNumber(quotes, "impact_mid_price"),
        "markPrice": this.SafeNumber(chain, "mark_price"),
        "lastPrice": nil,
        "underlyingPrice": this.SafeNumber(chain, "spot_price"),
        "change": nil,
        "percentage": nil,
        "baseVolume": this.SafeNumber(chain, "volume"),
        "quoteVolume": nil,
    }
}
func  (this *delta) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var requestPath interface{} = Add(Add(Add("/", this.Version), "/"), this.ImplodeParams(path, params))
    var url interface{} = Add(GetValue(GetValue(this.Urls, "api"), api), requestPath)
    var query interface{} = this.Omit(params, this.ExtractParams(path))
    if IsTrue(IsEqual(api, "public")) {
        if IsTrue(GetArrayLength(ObjectKeys(query))) {
            url = Add(url, Add("?", this.Urlencode(query)))
        }
    } else if IsTrue(IsEqual(api, "private")) {
        this.CheckRequiredCredentials()
        var timestamp interface{} = ToString(this.Seconds())
        headers = map[string]interface{} {
            "api-key": this.ApiKey,
            "timestamp": timestamp,
        }
        var auth interface{} = Add(Add(method, timestamp), requestPath)
        if IsTrue(IsEqual(method, "GET")) {
            if IsTrue(GetArrayLength(ObjectKeys(query))) {
                var queryString interface{} = Add("?", this.Urlencode(query))
                auth = Add(auth, queryString)
                url = Add(url, queryString)
            }
        } else {
            body = this.Json(query)
            auth = Add(auth, body)
            AddElementToObject(headers, "Content-Type", "application/json")
        }
        var signature interface{} = this.Hmac(this.Encode(auth), this.Encode(this.Secret), sha256)
        AddElementToObject(headers, "signature", signature)
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *delta) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsEqual(response, nil)) {
        return nil
    }
    //
    // {"error":{"code":"insufficient_margin","context":{"available_balance":"0.000000000000000000","required_additional_balance":"1.618626000000000000000000000"}},"success":false}
    //
    var error interface{} = this.SafeDict(response, "error", map[string]interface{} {})
    var errorCode interface{} = this.SafeString(error, "code")
    if IsTrue(!IsEqual(errorCode, nil)) {
        var feedback interface{} = Add(Add(this.Id, " "), body)
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), errorCode, feedback)
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), errorCode, feedback)
        panic(ExchangeError(feedback))
    }
    return nil
}


func (this *delta) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.DerivedExchange = this
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
}
