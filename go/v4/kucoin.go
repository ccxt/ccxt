package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type kucoin struct {
	Exchange
}

func NewKucoinCore() *kucoin {
	p := &kucoin{}
	setDefaults(p)
	return p
}

func (this *kucoin) Describe() interface{} {
	return this.DeepExtend(this.Exchange.Describe(), map[string]interface{}{
		"id":               "kucoin",
		"name":             "KuCoin",
		"countries":        []interface{}{"SC"},
		"rateLimit":        10,
		"version":          "v2",
		"certified":        true,
		"pro":              true,
		"comment":          "Platform 2.0",
		"quoteJsonNumbers": false,
		"has": map[string]interface{}{
			"CORS":                           nil,
			"spot":                           true,
			"margin":                         true,
			"swap":                           false,
			"future":                         false,
			"option":                         false,
			"borrowCrossMargin":              true,
			"borrowIsolatedMargin":           true,
			"cancelAllOrders":                true,
			"cancelOrder":                    true,
			"closeAllPositions":              false,
			"closePosition":                  false,
			"createDepositAddress":           true,
			"createMarketBuyOrderWithCost":   true,
			"createMarketOrderWithCost":      true,
			"createMarketSellOrderWithCost":  true,
			"createOrder":                    true,
			"createOrders":                   true,
			"createPostOnlyOrder":            true,
			"createStopLimitOrder":           true,
			"createStopMarketOrder":          true,
			"createStopOrder":                true,
			"createTriggerOrder":             true,
			"editOrder":                      true,
			"fetchAccounts":                  true,
			"fetchBalance":                   true,
			"fetchBorrowInterest":            true,
			"fetchBorrowRateHistories":       true,
			"fetchBorrowRateHistory":         true,
			"fetchClosedOrders":              true,
			"fetchCrossBorrowRate":           false,
			"fetchCrossBorrowRates":          false,
			"fetchCurrencies":                true,
			"fetchDepositAddress":            true,
			"fetchDepositAddresses":          false,
			"fetchDepositAddressesByNetwork": true,
			"fetchDeposits":                  true,
			"fetchDepositWithdrawFee":        true,
			"fetchDepositWithdrawFees":       true,
			"fetchFundingHistory":            false,
			"fetchFundingRate":               false,
			"fetchFundingRateHistory":        false,
			"fetchFundingRates":              false,
			"fetchIndexOHLCV":                false,
			"fetchIsolatedBorrowRate":        false,
			"fetchIsolatedBorrowRates":       false,
			"fetchL3OrderBook":               true,
			"fetchLedger":                    true,
			"fetchLeverageTiers":             false,
			"fetchMarginAdjustmentHistory":   false,
			"fetchMarginMode":                false,
			"fetchMarketLeverageTiers":       false,
			"fetchMarkets":                   true,
			"fetchMarkOHLCV":                 false,
			"fetchMarkPrice":                 true,
			"fetchMarkPrices":                true,
			"fetchMyTrades":                  true,
			"fetchOHLCV":                     true,
			"fetchOpenInterest":              false,
			"fetchOpenInterestHistory":       false,
			"fetchOpenOrders":                true,
			"fetchOrder":                     true,
			"fetchOrderBook":                 true,
			"fetchOrderBooks":                false,
			"fetchOrdersByStatus":            true,
			"fetchOrderTrades":               true,
			"fetchPositionHistory":           false,
			"fetchPositionMode":              false,
			"fetchPositionsHistory":          false,
			"fetchPremiumIndexOHLCV":         false,
			"fetchStatus":                    true,
			"fetchTicker":                    true,
			"fetchTickers":                   true,
			"fetchTime":                      true,
			"fetchTrades":                    true,
			"fetchTradingFee":                true,
			"fetchTradingFees":               false,
			"fetchTransactionFee":            true,
			"fetchTransfers":                 false,
			"fetchWithdrawals":               true,
			"repayCrossMargin":               true,
			"repayIsolatedMargin":            true,
			"setLeverage":                    true,
			"setMarginMode":                  false,
			"setPositionMode":                false,
			"signIn":                         false,
			"transfer":                       true,
			"withdraw":                       true,
		},
		"urls": map[string]interface{}{
			"logo":     "https://user-images.githubusercontent.com/51840849/87295558-132aaf80-c50e-11ea-9801-a2fb0c57c799.jpg",
			"referral": "https://www.kucoin.com/ucenter/signup?rcode=E5wkqe",
			"api": map[string]interface{}{
				"public":         "https://api.kucoin.com",
				"private":        "https://api.kucoin.com",
				"futuresPrivate": "https://api-futures.kucoin.com",
				"futuresPublic":  "https://api-futures.kucoin.com",
				"webExchange":    "https://kucoin.com/_api",
				"broker":         "https://api-broker.kucoin.com",
				"earn":           "https://api.kucoin.com",
			},
			"www": "https://www.kucoin.com",
			"doc": []interface{}{"https://docs.kucoin.com"},
		},
		"requiredCredentials": map[string]interface{}{
			"apiKey":   true,
			"secret":   true,
			"password": true,
		},
		"api": map[string]interface{}{
			"public": map[string]interface{}{
				"get": map[string]interface{}{
					"currencies":                            4.5,
					"currencies/{currency}":                 4.5,
					"symbols":                               6,
					"market/orderbook/level1":               3,
					"market/allTickers":                     22.5,
					"market/stats":                          22.5,
					"markets":                               4.5,
					"market/orderbook/level{level}_{limit}": 6,
					"market/orderbook/level2_20":            3,
					"market/orderbook/level2_100":           6,
					"market/histories":                      4.5,
					"market/candles":                        4.5,
					"prices":                                4.5,
					"timestamp":                             4.5,
					"status":                                4.5,
					"mark-price/{symbol}/current":           3,
					"mark-price/all-symbols":                3,
					"margin/config":                         25,
					"announcements":                         20,
				},
				"post": map[string]interface{}{
					"bullet-public": 15,
				},
			},
			"private": map[string]interface{}{
				"get": map[string]interface{}{
					"user-info":                                 30,
					"accounts":                                  7.5,
					"accounts/{accountId}":                      7.5,
					"accounts/ledgers":                          3,
					"hf/accounts/ledgers":                       2,
					"hf/margin/account/ledgers":                 2,
					"transaction-history":                       3,
					"sub/user":                                  30,
					"sub-accounts/{subUserId}":                  22.5,
					"sub-accounts":                              30,
					"sub/api-key":                               30,
					"margin/account":                            40,
					"margin/accounts":                           15,
					"isolated/accounts":                         15,
					"deposit-addresses":                         7.5,
					"deposits":                                  7.5,
					"hist-deposits":                             7.5,
					"withdrawals":                               30,
					"hist-withdrawals":                          30,
					"withdrawals/quotas":                        30,
					"accounts/transferable":                     30,
					"transfer-list":                             30,
					"base-fee":                                  3,
					"trade-fees":                                3,
					"market/orderbook/level{level}":             3,
					"market/orderbook/level2":                   3,
					"market/orderbook/level3":                   3,
					"hf/accounts/opened":                        2,
					"hf/orders/active":                          2,
					"hf/orders/active/symbols":                  2,
					"hf/margin/order/active/symbols":            2,
					"hf/orders/done":                            2,
					"hf/orders/{orderId}":                       2,
					"hf/orders/client-order/{clientOid}":        2,
					"hf/orders/dead-cancel-all/query":           2,
					"hf/fills":                                  2,
					"orders":                                    2,
					"limit/orders":                              3,
					"orders/{orderId}":                          2,
					"order/client-order/{clientOid}":            3,
					"fills":                                     10,
					"limit/fills":                               20,
					"stop-order":                                8,
					"stop-order/{orderId}":                      3,
					"stop-order/queryOrderByClientOid":          3,
					"oco/order/{orderId}":                       2,
					"oco/order/details/{orderId}":               2,
					"oco/client-order/{clientOid}":              2,
					"oco/orders":                                2,
					"hf/margin/orders/active":                   4,
					"hf/margin/orders/done":                     10,
					"hf/margin/orders/{orderId}":                4,
					"hf/margin/orders/client-order/{clientOid}": 5,
					"hf/margin/fills":                           5,
					"etf/info":                                  25,
					"margin/currencies":                         20,
					"risk/limit/strategy":                       20,
					"isolated/symbols":                          20,
					"margin/symbols":                            5,
					"isolated/account/{symbol}":                 50,
					"margin/borrow":                             15,
					"margin/repay":                              15,
					"margin/interest":                           20,
					"project/list":                              10,
					"project/marketInterestRate":                7.5,
					"redeem/orders":                             10,
					"purchase/orders":                           10,
					"broker/api/rebase/download":                3,
					"migrate/user/account/status":               3,
					"affiliate/inviter/statistics":              30,
				},
				"post": map[string]interface{}{
					"sub/user/created":              22.5,
					"sub/api-key":                   30,
					"sub/api-key/update":            45,
					"deposit-addresses":             30,
					"withdrawals":                   7.5,
					"accounts/universal-transfer":   6,
					"accounts/sub-transfer":         45,
					"accounts/inner-transfer":       15,
					"transfer-out":                  30,
					"transfer-in":                   30,
					"hf/orders":                     1,
					"hf/orders/test":                1,
					"hf/orders/sync":                1,
					"hf/orders/multi":               1,
					"hf/orders/multi/sync":          1,
					"hf/orders/alter":               3,
					"hf/orders/dead-cancel-all":     2,
					"orders":                        2,
					"orders/test":                   2,
					"orders/multi":                  3,
					"stop-order":                    2,
					"oco/order":                     2,
					"hf/margin/order":               5,
					"hf/margin/order/test":          5,
					"margin/order":                  5,
					"margin/order/test":             5,
					"margin/borrow":                 15,
					"margin/repay":                  10,
					"purchase":                      15,
					"redeem":                        15,
					"lend/purchase/update":          10,
					"bullet-private":                10,
					"position/update-user-leverage": 5,
					"deposit-address/create":        20,
				},
				"delete": map[string]interface{}{
					"sub/api-key":                               45,
					"withdrawals/{withdrawalId}":                30,
					"hf/orders/{orderId}":                       1,
					"hf/orders/sync/{orderId}":                  1,
					"hf/orders/client-order/{clientOid}":        1,
					"hf/orders/sync/client-order/{clientOid}":   1,
					"hf/orders/cancel/{orderId}":                2,
					"hf/orders":                                 2,
					"hf/orders/cancelAll":                       30,
					"orders/{orderId}":                          3,
					"order/client-order/{clientOid}":            5,
					"orders":                                    20,
					"stop-order/{orderId}":                      3,
					"stop-order/cancelOrderByClientOid":         5,
					"stop-order/cancel":                         3,
					"oco/order/{orderId}":                       3,
					"oco/client-order/{clientOid}":              3,
					"oco/orders":                                3,
					"hf/margin/orders/{orderId}":                5,
					"hf/margin/orders/client-order/{clientOid}": 5,
					"hf/margin/orders":                          10,
				},
			},
			"futuresPublic": map[string]interface{}{
				"get": map[string]interface{}{
					"contracts/active":              4.5,
					"contracts/{symbol}":            4.5,
					"ticker":                        3,
					"level2/snapshot":               4.5,
					"level2/depth20":                7.5,
					"level2/depth100":               15,
					"trade/history":                 7.5,
					"kline/query":                   4.5,
					"interest/query":                7.5,
					"index/query":                   3,
					"mark-price/{symbol}/current":   4.5,
					"premium/query":                 4.5,
					"trade-statistics":              4.5,
					"funding-rate/{symbol}/current": 3,
					"contract/funding-rates":        7.5,
					"timestamp":                     3,
					"status":                        6,
					"level2/message/query":          1.3953,
				},
				"post": map[string]interface{}{
					"bullet-public": 15,
				},
			},
			"futuresPrivate": map[string]interface{}{
				"get": map[string]interface{}{
					"transaction-history":           3,
					"account-overview":              7.5,
					"account-overview-all":          9,
					"transfer-list":                 30,
					"orders":                        3,
					"stopOrders":                    9,
					"recentDoneOrders":              7.5,
					"orders/{orderId}":              7.5,
					"orders/byClientOid":            7.5,
					"fills":                         7.5,
					"recentFills":                   4.5,
					"openOrderStatistics":           15,
					"position":                      3,
					"positions":                     3,
					"margin/maxWithdrawMargin":      15,
					"contracts/risk-limit/{symbol}": 7.5,
					"funding-history":               7.5,
				},
				"post": map[string]interface{}{
					"transfer-out":                        30,
					"transfer-in":                         30,
					"orders":                              3,
					"orders/test":                         3,
					"orders/multi":                        4.5,
					"position/margin/auto-deposit-status": 6,
					"margin/withdrawMargin":               15,
					"position/margin/deposit-margin":      6,
					"position/risk-limit-level/change":    6,
					"bullet-private":                      15,
				},
				"delete": map[string]interface{}{
					"orders/{orderId}":                1.5,
					"orders/client-order/{clientOid}": 1.5,
					"orders":                          45,
					"stopOrders":                      22.5,
				},
			},
			"webExchange": map[string]interface{}{
				"get": map[string]interface{}{
					"currency/currency/chain-info": 1,
				},
			},
			"broker": map[string]interface{}{
				"get": map[string]interface{}{
					"broker/nd/info":              2,
					"broker/nd/account":           2,
					"broker/nd/account/apikey":    2,
					"broker/nd/rebase/download":   3,
					"asset/ndbroker/deposit/list": 1,
					"broker/nd/transfer/detail":   1,
					"broker/nd/deposit/detail":    1,
					"broker/nd/withdraw/detail":   1,
				},
				"post": map[string]interface{}{
					"broker/nd/transfer":              1,
					"broker/nd/account":               3,
					"broker/nd/account/apikey":        3,
					"broker/nd/account/update-apikey": 3,
				},
				"delete": map[string]interface{}{
					"broker/nd/account/apikey": 3,
				},
			},
			"earn": map[string]interface{}{
				"get": map[string]interface{}{
					"otc-loan/loan":             1,
					"otc-loan/accounts":         1,
					"earn/redeem-preview":       7.5,
					"earn/saving/products":      7.5,
					"earn/hold-assets":          7.5,
					"earn/promotion/products":   7.5,
					"earn/kcs-staking/products": 7.5,
					"earn/staking/products":     7.5,
					"earn/eth-staking/products": 7.5,
				},
				"post": map[string]interface{}{
					"earn/orders": 7.5,
				},
				"delete": map[string]interface{}{
					"earn/orders": 7.5,
				},
			},
		},
		"timeframes": map[string]interface{}{
			"1m":  "1min",
			"3m":  "3min",
			"5m":  "5min",
			"15m": "15min",
			"30m": "30min",
			"1h":  "1hour",
			"2h":  "2hour",
			"4h":  "4hour",
			"6h":  "6hour",
			"8h":  "8hour",
			"12h": "12hour",
			"1d":  "1day",
			"1w":  "1week",
			"1M":  "1month",
		},
		"precisionMode": TICK_SIZE,
		"exceptions": map[string]interface{}{
			"exact": map[string]interface{}{
				"The order does not exist.":                                OrderNotFound,
				"order not exist":                                          OrderNotFound,
				"order not exist.":                                         OrderNotFound,
				"order_not_exist":                                          OrderNotFound,
				"order_not_exist_or_not_allow_to_cancel":                   InvalidOrder,
				"Order size below the minimum requirement.":                InvalidOrder,
				"The withdrawal amount is below the minimum requirement.":  ExchangeError,
				"Unsuccessful! Exceeded the max. funds out-transfer limit": InsufficientFunds,
				"The amount increment is invalid.":                         BadRequest,
				"The quantity is below the minimum requirement.":           InvalidOrder,
				"400":    BadRequest,
				"401":    AuthenticationError,
				"403":    NotSupported,
				"404":    NotSupported,
				"405":    NotSupported,
				"415":    NotSupported,
				"429":    RateLimitExceeded,
				"500":    ExchangeNotAvailable,
				"503":    ExchangeNotAvailable,
				"101030": PermissionDenied,
				"103000": InvalidOrder,
				"130101": BadRequest,
				"130102": ExchangeError,
				"130103": OrderNotFound,
				"130104": ExchangeError,
				"130105": InsufficientFunds,
				"130106": NotSupported,
				"130107": ExchangeError,
				"130108": OrderNotFound,
				"130201": PermissionDenied,
				"130202": ExchangeError,
				"130203": InsufficientFunds,
				"130204": BadRequest,
				"130301": InsufficientFunds,
				"130302": PermissionDenied,
				"130303": NotSupported,
				"130304": NotSupported,
				"130305": NotSupported,
				"130306": NotSupported,
				"130307": NotSupported,
				"130308": InvalidOrder,
				"130309": InvalidOrder,
				"130310": ExchangeError,
				"130311": InvalidOrder,
				"130312": InvalidOrder,
				"130313": InvalidOrder,
				"130314": InvalidOrder,
				"130315": NotSupported,
				"126000": ExchangeError,
				"126001": NotSupported,
				"126002": ExchangeError,
				"126003": InvalidOrder,
				"126004": ExchangeError,
				"126005": PermissionDenied,
				"126006": ExchangeError,
				"126007": ExchangeError,
				"126009": ExchangeError,
				"126010": ExchangeError,
				"126011": ExchangeError,
				"126013": InsufficientFunds,
				"126015": ExchangeError,
				"126021": NotSupported,
				"126022": InvalidOrder,
				"126027": InvalidOrder,
				"126028": InvalidOrder,
				"126029": InvalidOrder,
				"126030": InvalidOrder,
				"126033": InvalidOrder,
				"126034": InvalidOrder,
				"126036": InvalidOrder,
				"126037": ExchangeError,
				"126038": ExchangeError,
				"126039": ExchangeError,
				"126041": ExchangeError,
				"126042": ExchangeError,
				"126043": OrderNotFound,
				"126044": InvalidOrder,
				"126045": NotSupported,
				"126046": NotSupported,
				"126047": PermissionDenied,
				"126048": PermissionDenied,
				"135005": ExchangeError,
				"135018": ExchangeError,
				"200004": InsufficientFunds,
				"210014": InvalidOrder,
				"210021": InsufficientFunds,
				"230003": InsufficientFunds,
				"260000": InvalidAddress,
				"260100": InsufficientFunds,
				"300000": InvalidOrder,
				"400000": BadSymbol,
				"400001": AuthenticationError,
				"400002": InvalidNonce,
				"400003": AuthenticationError,
				"400004": AuthenticationError,
				"400005": AuthenticationError,
				"400006": AuthenticationError,
				"400007": AuthenticationError,
				"400008": NotSupported,
				"400100": InsufficientFunds,
				"400200": InvalidOrder,
				"400330": InvalidOrder,
				"400350": InvalidOrder,
				"400370": InvalidOrder,
				"400400": BadRequest,
				"400401": AuthenticationError,
				"400500": InvalidOrder,
				"400600": BadSymbol,
				"400760": InvalidOrder,
				"401000": BadRequest,
				"408000": BadRequest,
				"411100": AccountSuspended,
				"415000": BadRequest,
				"400303": PermissionDenied,
				"500000": ExchangeNotAvailable,
				"260220": InvalidAddress,
				"600100": InsufficientFunds,
				"600101": InvalidOrder,
				"900014": BadRequest,
			},
			"broad": map[string]interface{}{
				"Exceeded the access frequency": RateLimitExceeded,
				"require more permission":       PermissionDenied,
			},
		},
		"fees": map[string]interface{}{
			"trading": map[string]interface{}{
				"tierBased":  true,
				"percentage": true,
				"taker":      this.ParseNumber("0.001"),
				"maker":      this.ParseNumber("0.001"),
				"tiers": map[string]interface{}{
					"taker": []interface{}{[]interface{}{this.ParseNumber("0"), this.ParseNumber("0.001")}, []interface{}{this.ParseNumber("50"), this.ParseNumber("0.001")}, []interface{}{this.ParseNumber("200"), this.ParseNumber("0.0009")}, []interface{}{this.ParseNumber("500"), this.ParseNumber("0.0008")}, []interface{}{this.ParseNumber("1000"), this.ParseNumber("0.0007")}, []interface{}{this.ParseNumber("2000"), this.ParseNumber("0.0007")}, []interface{}{this.ParseNumber("4000"), this.ParseNumber("0.0006")}, []interface{}{this.ParseNumber("8000"), this.ParseNumber("0.0005")}, []interface{}{this.ParseNumber("15000"), this.ParseNumber("0.00045")}, []interface{}{this.ParseNumber("25000"), this.ParseNumber("0.0004")}, []interface{}{this.ParseNumber("40000"), this.ParseNumber("0.00035")}, []interface{}{this.ParseNumber("60000"), this.ParseNumber("0.0003")}, []interface{}{this.ParseNumber("80000"), this.ParseNumber("0.00025")}},
					"maker": []interface{}{[]interface{}{this.ParseNumber("0"), this.ParseNumber("0.001")}, []interface{}{this.ParseNumber("50"), this.ParseNumber("0.0009")}, []interface{}{this.ParseNumber("200"), this.ParseNumber("0.0007")}, []interface{}{this.ParseNumber("500"), this.ParseNumber("0.0005")}, []interface{}{this.ParseNumber("1000"), this.ParseNumber("0.0003")}, []interface{}{this.ParseNumber("2000"), this.ParseNumber("0")}, []interface{}{this.ParseNumber("4000"), this.ParseNumber("0")}, []interface{}{this.ParseNumber("8000"), this.ParseNumber("0")}, []interface{}{this.ParseNumber("15000"), this.ParseNumber("-0.00005")}, []interface{}{this.ParseNumber("25000"), this.ParseNumber("-0.00005")}, []interface{}{this.ParseNumber("40000"), this.ParseNumber("-0.00005")}, []interface{}{this.ParseNumber("60000"), this.ParseNumber("-0.00005")}, []interface{}{this.ParseNumber("80000"), this.ParseNumber("-0.00005")}},
				},
			},
			"funding": map[string]interface{}{
				"tierBased":  false,
				"percentage": false,
				"withdraw":   map[string]interface{}{},
				"deposit":    map[string]interface{}{},
			},
		},
		"commonCurrencies": map[string]interface{}{
			"BIFI": "BIFIF",
			"VAI":  "VAIOT",
			"WAX":  "WAXP",
			"ALT":  "APTOSLAUNCHTOKEN",
			"KALT": "ALT",
			"FUD":  "FTX Users\\' Debt",
		},
		"options": map[string]interface{}{
			"hf":                      nil,
			"version":                 "v1",
			"symbolSeparator":         "-",
			"fetchMyTradesMethod":     "private_get_fills",
			"timeDifference":          0,
			"adjustForTimeDifference": false,
			"fetchCurrencies": map[string]interface{}{
				"webApiEnable":      true,
				"webApiRetries":     1,
				"webApiMuteFailure": true,
			},
			"fetchMarkets": map[string]interface{}{
				"fetchTickersFees": true,
			},
			"withdraw": map[string]interface{}{
				"includeFee": false,
			},
			"versions": map[string]interface{}{
				"public": map[string]interface{}{
					"GET": map[string]interface{}{
						"currencies":             "v3",
						"currencies/{currency}":  "v3",
						"symbols":                "v2",
						"mark-price/all-symbols": "v3",
						"announcements":          "v3",
					},
				},
				"private": map[string]interface{}{
					"GET": map[string]interface{}{
						"user-info":                                 "v2",
						"hf/margin/account/ledgers":                 "v3",
						"sub/user":                                  "v2",
						"sub-accounts":                              "v2",
						"margin/accounts":                           "v3",
						"isolated/accounts":                         "v3",
						"deposit-addresses":                         "v1",
						"market/orderbook/level2":                   "v3",
						"market/orderbook/level3":                   "v3",
						"market/orderbook/level{level}":             "v3",
						"oco/order/{orderId}":                       "v3",
						"oco/order/details/{orderId}":               "v3",
						"oco/client-order/{clientOid}":              "v3",
						"oco/orders":                                "v3",
						"hf/margin/orders/active":                   "v3",
						"hf/margin/order/active/symbols":            "v3",
						"hf/margin/orders/done":                     "v3",
						"hf/margin/orders/{orderId}":                "v3",
						"hf/margin/orders/client-order/{clientOid}": "v3",
						"hf/margin/fills":                           "v3",
						"etf/info":                                  "v3",
						"margin/currencies":                         "v3",
						"margin/borrow":                             "v3",
						"margin/repay":                              "v3",
						"margin/interest":                           "v3",
						"project/list":                              "v3",
						"project/marketInterestRate":                "v3",
						"redeem/orders":                             "v3",
						"purchase/orders":                           "v3",
						"migrate/user/account/status":               "v3",
						"margin/symbols":                            "v3",
						"affiliate/inviter/statistics":              "v2",
						"asset/ndbroker/deposit/list":               "v1",
					},
					"POST": map[string]interface{}{
						"sub/user/created":              "v2",
						"accounts/universal-transfer":   "v3",
						"accounts/sub-transfer":         "v2",
						"accounts/inner-transfer":       "v2",
						"transfer-out":                  "v3",
						"deposit-address/create":        "v3",
						"oco/order":                     "v3",
						"hf/margin/order":               "v3",
						"hf/margin/order/test":          "v3",
						"margin/borrow":                 "v3",
						"margin/repay":                  "v3",
						"purchase":                      "v3",
						"redeem":                        "v3",
						"lend/purchase/update":          "v3",
						"position/update-user-leverage": "v3",
						"withdrawals":                   "v3",
					},
					"DELETE": map[string]interface{}{
						"hf/margin/orders/{orderId}":                "v3",
						"hf/margin/orders/client-order/{clientOid}": "v3",
						"hf/margin/orders":                          "v3",
						"oco/order/{orderId}":                       "v3",
						"oco/client-order/{clientOid}":              "v3",
						"oco/orders":                                "v3",
					},
				},
				"futuresPrivate": map[string]interface{}{
					"POST": map[string]interface{}{
						"transfer-out": "v3",
					},
				},
			},
			"partner": map[string]interface{}{
				"spot": map[string]interface{}{
					"id":  "ccxt",
					"key": "9e58cc35-5b5e-4133-92ec-166e3f077cb8",
				},
				"future": map[string]interface{}{
					"id":  "ccxtfutures",
					"key": "1b327198-f30c-4f14-a0ac-918871282f15",
				},
			},
			"accountsByType": map[string]interface{}{
				"spot":     "trade",
				"margin":   "margin",
				"cross":    "margin",
				"isolated": "isolated",
				"main":     "main",
				"funding":  "main",
				"future":   "contract",
				"swap":     "contract",
				"mining":   "pool",
				"hf":       "trade_hf",
			},
			"networks": map[string]interface{}{
				"BRC20":           "btc",
				"BTCNATIVESEGWIT": "bech32",
				"ERC20":           "eth",
				"TRC20":           "trx",
				"HRC20":           "heco",
				"MATIC":           "matic",
				"KCC":             "kcc",
				"SOL":             "sol",
				"ALGO":            "algo",
				"EOS":             "eos",
				"BEP20":           "bsc",
				"BEP2":            "bnb",
				"ARBONE":          "arbitrum",
				"AVAXX":           "avax",
				"AVAXC":           "avaxc",
				"TLOS":            "tlos",
				"CFX":             "cfx",
				"ACA":             "aca",
				"OPTIMISM":        "optimism",
				"ONT":             "ont",
				"GLMR":            "glmr",
				"CSPR":            "cspr",
				"KLAY":            "klay",
				"XRD":             "xrd",
				"RVN":             "rvn",
				"NEAR":            "near",
				"APT":             "aptos",
				"ETHW":            "ethw",
				"TON":             "ton",
				"BCH":             "bch",
				"BSV":             "bchsv",
				"BCHA":            "bchabc",
				"OSMO":            "osmo",
				"NANO":            "nano",
				"XLM":             "xlm",
				"VET":             "vet",
				"IOST":            "iost",
				"ZIL":             "zil",
				"XRP":             "xrp",
				"TOMO":            "tomo",
				"XMR":             "xmr",
				"COTI":            "coti",
				"XTZ":             "xtz",
				"ADA":             "ada",
				"WAX":             "waxp",
				"THETA":           "theta",
				"ONE":             "one",
				"IOTEX":           "iotx",
				"NULS":            "nuls",
				"KSM":             "ksm",
				"LTC":             "ltc",
				"WAVES":           "waves",
				"DOT":             "dot",
				"STEEM":           "steem",
				"QTUM":            "qtum",
				"DOGE":            "doge",
				"FIL":             "fil",
				"XYM":             "xym",
				"FLUX":            "flux",
				"ATOM":            "atom",
				"XDC":             "xdc",
				"KDA":             "kda",
				"ICP":             "icp",
				"CELO":            "celo",
				"LSK":             "lsk",
				"VSYS":            "vsys",
				"KAR":             "kar",
				"XCH":             "xch",
				"FLOW":            "flow",
				"BAND":            "band",
				"EGLD":            "egld",
				"HBAR":            "hbar",
				"XPR":             "xpr",
				"AR":              "ar",
				"FTM":             "ftm",
				"KAVA":            "kava",
				"KMA":             "kma",
				"XEC":             "xec",
				"IOTA":            "iota",
				"HNT":             "hnt",
				"ASTR":            "astr",
				"PDEX":            "pdex",
				"METIS":           "metis",
				"ZEC":             "zec",
				"POKT":            "pokt",
				"OASYS":           "oas",
				"OASIS":           "oasis",
				"ETC":             "etc",
				"AKT":             "akt",
				"FSN":             "fsn",
				"SCRT":            "scrt",
				"CFG":             "cfg",
				"ICX":             "icx",
				"KMD":             "kmd",
				"NEM":             "NEM",
				"STX":             "stx",
				"DGB":             "dgb",
				"DCR":             "dcr",
				"CKB":             "ckb",
				"ELA":             "ela",
				"HYDRA":           "hydra",
				"BTM":             "btm",
				"KARDIA":          "kai",
				"SXP":             "sxp",
				"NEBL":            "nebl",
				"ZEN":             "zen",
				"SDN":             "sdn",
				"LTO":             "lto",
				"WEMIX":           "wemix",
				"EVER":            "ever",
				"BNC":             "bnc",
				"BNCDOT":          "bncdot",
				"AION":            "aion",
				"GRIN":            "grin",
				"LOKI":            "loki",
				"QKC":             "qkc",
				"TT":              "TT",
				"PIVX":            "pivx",
				"SERO":            "sero",
				"METER":           "meter",
				"STATEMINE":       "statemine",
				"DVPN":            "dvpn",
				"XPRT":            "xprt",
				"MOVR":            "movr",
				"ERGO":            "ergo",
				"ABBC":            "abbc",
				"DIVI":            "divi",
				"PURA":            "pura",
				"DFI":             "dfi",
				"NEON3":           "neon3",
				"DOCK":            "dock",
				"TRUE":            "true",
				"CS":              "cs",
				"ORAI":            "orai",
				"BASE":            "base",
				"TARA":            "tara",
			},
			"marginModes": map[string]interface{}{
				"cross":    "MARGIN_TRADE",
				"isolated": "MARGIN_ISOLATED_TRADE",
				"spot":     "TRADE",
			},
		},
		"features": map[string]interface{}{
			"spot": map[string]interface{}{
				"sandbox": false,
				"createOrder": map[string]interface{}{
					"marginMode":                 true,
					"triggerPrice":               true,
					"triggerPriceType":           nil,
					"triggerDirection":           false,
					"stopLossPrice":              true,
					"takeProfitPrice":            true,
					"attachedStopLossTakeProfit": nil,
					"timeInForce": map[string]interface{}{
						"IOC": true,
						"FOK": true,
						"PO":  true,
						"GTD": true,
					},
					"hedged":                 false,
					"trailing":               false,
					"leverage":               false,
					"marketBuyByCost":        true,
					"marketBuyRequiresPrice": false,
					"selfTradePrevention":    true,
					"iceberg":                true,
				},
				"createOrders": map[string]interface{}{
					"max": 5,
				},
				"fetchMyTrades": map[string]interface{}{
					"marginMode":     true,
					"limit":          nil,
					"daysBack":       nil,
					"untilDays":      7,
					"symbolRequired": true,
				},
				"fetchOrder": map[string]interface{}{
					"marginMode":     false,
					"trigger":        true,
					"trailing":       false,
					"symbolRequired": true,
				},
				"fetchOpenOrders": map[string]interface{}{
					"marginMode":     true,
					"limit":          500,
					"trigger":        true,
					"trailing":       false,
					"symbolRequired": true,
				},
				"fetchOrders": nil,
				"fetchClosedOrders": map[string]interface{}{
					"marginMode":       true,
					"limit":            500,
					"daysBack":         nil,
					"daysBackCanceled": nil,
					"untilDays":        7,
					"trigger":          true,
					"trailing":         false,
					"symbolRequired":   true,
				},
				"fetchOHLCV": map[string]interface{}{
					"limit": 1500,
				},
			},
			"swap": map[string]interface{}{
				"linear":  nil,
				"inverse": nil,
			},
			"future": map[string]interface{}{
				"linear":  nil,
				"inverse": nil,
			},
		},
	})
}
func (this *kucoin) Nonce() interface{} {
	return Subtract(this.Milliseconds(), GetValue(this.Options, "timeDifference"))
}

/**
 * @method
 * @name kucoin#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @see https://docs.kucoin.com/#server-time
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func (this *kucoin) FetchTime(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		response := (<-this.PublicGetTimestamp(params))
		PanicOnError(response)

		//
		//     {
		//         "code":"200000",
		//         "msg":"success",
		//         "data":1546837113087
		//     }
		//
		ch <- this.SafeInteger(response, "data")
		return nil

	}()
	return ch
}

/**
 * @method
 * @name kucoin#fetchStatus
 * @description the latest known information on the availability of the exchange API
 * @see https://docs.kucoin.com/#service-status
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [status structure]{@link https://docs.ccxt.com/#/?id=exchange-status-structure}
 */
func (this *kucoin) FetchStatus(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		response := (<-this.PublicGetStatus(params))
		PanicOnError(response)
		//
		//     {
		//         "code":"200000",
		//         "data":{
		//             "status":"open", //open, close, cancelonly
		//             "msg":"upgrade match engine" //remark for operation
		//         }
		//     }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		var status interface{} = this.SafeString(data, "status")

		ch <- map[string]interface{}{
			"status":  Ternary(IsTrue((IsEqual(status, "open"))), "ok", "maintenance"),
			"updated": nil,
			"eta":     nil,
			"url":     nil,
			"info":    response,
		}
		return nil

	}()
	return ch
}

/**
 * @method
 * @name kucoin#fetchMarkets
 * @description retrieves data on all markets for kucoin
 * @see https://docs.kucoin.com/#get-symbols-list-deprecated
 * @see https://docs.kucoin.com/#get-all-tickers
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func (this *kucoin) FetchMarkets(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params
		var fetchTickersFees interface{} = nil
		fetchTickersFeesparamsVariable := this.HandleOptionAndParams(params, "fetchMarkets", "fetchTickersFees", true)
		fetchTickersFees = GetValue(fetchTickersFeesparamsVariable, 0)
		params = GetValue(fetchTickersFeesparamsVariable, 1)
		var promises interface{} = []interface{}{}
		AppendToArray(&promises, this.PublicGetSymbols(params))
		//
		//     {
		//         "code": "200000",
		//         "data": [
		//             {
		//                 "symbol": "XLM-USDT",
		//                 "name": "XLM-USDT",
		//                 "baseCurrency": "XLM",
		//                 "quoteCurrency": "USDT",
		//                 "feeCurrency": "USDT",
		//                 "market": "USDS",
		//                 "baseMinSize": "0.1",
		//                 "quoteMinSize": "0.01",
		//                 "baseMaxSize": "10000000000",
		//                 "quoteMaxSize": "99999999",
		//                 "baseIncrement": "0.0001",
		//                 "quoteIncrement": "0.000001",
		//                 "priceIncrement": "0.000001",
		//                 "priceLimitRate": "0.1",
		//                 "isMarginEnabled": true,
		//                 "enableTrading": true
		//             },
		//
		var credentialsSet interface{} = this.CheckRequiredCredentials(false)
		var requestMarginables interface{} = IsTrue(credentialsSet) && IsTrue(this.SafeBool(params, "marginables", true))
		if IsTrue(requestMarginables) {
			AppendToArray(&promises, this.PrivateGetMarginSymbols(params)) // cross margin symbols
			//
			//    {
			//        "code": "200000",
			//        "data": {
			//            "timestamp": 1719393213421,
			//            "items": [
			//                {
			//                    // same object as in market, with one additional field:
			//                    "minFunds": "0.1"
			//                },
			//
			AppendToArray(&promises, this.PrivateGetIsolatedSymbols(params)) // isolated margin symbols
		}
		if IsTrue(fetchTickersFees) {
			AppendToArray(&promises, this.PublicGetMarketAllTickers(params))
		}
		if IsTrue(credentialsSet) {
			// load migration status for account
			AppendToArray(&promises, this.LoadMigrationStatus())
		}

		responses := (<-promiseAll(promises))
		PanicOnError(responses)
		var symbolsData interface{} = this.SafeList(GetValue(responses, 0), "data")
		var crossData interface{} = Ternary(IsTrue(requestMarginables), this.SafeDict(GetValue(responses, 1), "data", map[string]interface{}{}), map[string]interface{}{})
		var crossItems interface{} = this.SafeList(crossData, "items", []interface{}{})
		var crossById interface{} = this.IndexBy(crossItems, "symbol")
		var isolatedData interface{} = Ternary(IsTrue(requestMarginables), GetValue(responses, 2), map[string]interface{}{})
		var isolatedItems interface{} = this.SafeList(isolatedData, "data", []interface{}{})
		var isolatedById interface{} = this.IndexBy(isolatedItems, "symbol")
		var tickersIdx interface{} = Ternary(IsTrue(requestMarginables), 3, 1)
		var tickersResponse interface{} = this.SafeDict(responses, tickersIdx, map[string]interface{}{})
		var tickerItems interface{} = this.SafeList(this.SafeDict(tickersResponse, "data", map[string]interface{}{}), "ticker", []interface{}{})
		var tickersById interface{} = this.IndexBy(tickerItems, "symbol")
		var result interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(symbolsData)); i++ {
			var market interface{} = GetValue(symbolsData, i)
			var id interface{} = this.SafeString(market, "symbol")
			baseIdquoteIdVariable := Split(id, "-")
			baseId := GetValue(baseIdquoteIdVariable, 0)
			quoteId := GetValue(baseIdquoteIdVariable, 1)
			var base interface{} = this.SafeCurrencyCode(baseId)
			var quote interface{} = this.SafeCurrencyCode(quoteId)
			// const quoteIncrement = this.safeNumber (market, 'quoteIncrement');
			var ticker interface{} = this.SafeDict(tickersById, id, map[string]interface{}{})
			var makerFeeRate interface{} = this.SafeString(ticker, "makerFeeRate")
			var takerFeeRate interface{} = this.SafeString(ticker, "takerFeeRate")
			var makerCoefficient interface{} = this.SafeString(ticker, "makerCoefficient")
			var takerCoefficient interface{} = this.SafeString(ticker, "takerCoefficient")
			var hasCrossMargin interface{} = (InOp(crossById, id))
			var hasIsolatedMargin interface{} = (InOp(isolatedById, id))
			var isMarginable interface{} = IsTrue(IsTrue(this.SafeBool(market, "isMarginEnabled", false)) || IsTrue(hasCrossMargin)) || IsTrue(hasIsolatedMargin)
			AppendToArray(&result, map[string]interface{}{
				"id":       id,
				"symbol":   Add(Add(base, "/"), quote),
				"base":     base,
				"quote":    quote,
				"settle":   nil,
				"baseId":   baseId,
				"quoteId":  quoteId,
				"settleId": nil,
				"type":     "spot",
				"spot":     true,
				"margin":   isMarginable,
				"marginModes": map[string]interface{}{
					"cross":    hasCrossMargin,
					"isolated": hasIsolatedMargin,
				},
				"swap":           false,
				"future":         false,
				"option":         false,
				"active":         this.SafeBool(market, "enableTrading"),
				"contract":       false,
				"linear":         nil,
				"inverse":        nil,
				"taker":          this.ParseNumber(Precise.StringMul(takerFeeRate, takerCoefficient)),
				"maker":          this.ParseNumber(Precise.StringMul(makerFeeRate, makerCoefficient)),
				"contractSize":   nil,
				"expiry":         nil,
				"expiryDatetime": nil,
				"strike":         nil,
				"optionType":     nil,
				"precision": map[string]interface{}{
					"amount": this.SafeNumber(market, "baseIncrement"),
					"price":  this.SafeNumber(market, "priceIncrement"),
				},
				"limits": map[string]interface{}{
					"leverage": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
					"amount": map[string]interface{}{
						"min": this.SafeNumber(market, "baseMinSize"),
						"max": this.SafeNumber(market, "baseMaxSize"),
					},
					"price": map[string]interface{}{
						"min": nil,
						"max": nil,
					},
					"cost": map[string]interface{}{
						"min": this.SafeNumber(market, "quoteMinSize"),
						"max": this.SafeNumber(market, "quoteMaxSize"),
					},
				},
				"created": nil,
				"info":    market,
			})
		}
		if IsTrue(GetValue(this.Options, "adjustForTimeDifference")) {

			retRes131312 := (<-this.LoadTimeDifference())
			PanicOnError(retRes131312)
		}

		ch <- result
		return nil

	}()
	return ch
}

/**
 * @method
 * @name kucoin#loadMigrationStatus
 * @param {boolean} force load account state for non hf
 * @description loads the migration status for the account (hf or not)
 * @see https://www.kucoin.com/docs/rest/spot-trading/spot-hf-trade-pro-account/get-user-type
 * @returns {any} ignore
 */
func (this *kucoin) LoadMigrationStatus(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		force := GetArg(optionalArgs, 0, false)
		_ = force
		if IsTrue(IsTrue(!IsTrue((InOp(this.Options, "hf"))) || IsTrue((IsEqual(GetValue(this.Options, "hf"), nil)))) || IsTrue(force)) {

			result := (<-this.PrivateGetHfAccountsOpened())
			PanicOnError(result)
			AddElementToObject(this.Options, "hf", this.SafeBool(result, "data"))
		}

		ch <- true
		return nil

	}()
	return ch
}
func (this *kucoin) HandleHfAndParams(optionalArgs ...interface{}) interface{} {
	params := GetArg(optionalArgs, 0, map[string]interface{}{})
	_ = params
	var migrated interface{} = this.SafeBool(this.Options, "hf", false)
	var loadedHf interface{} = nil
	if IsTrue(!IsEqual(migrated, nil)) {
		if IsTrue(migrated) {
			loadedHf = true
		} else {
			loadedHf = false
		}
	}
	var hf interface{} = this.SafeBool(params, "hf", loadedHf)
	params = this.Omit(params, "hf")
	return []interface{}{hf, params}
}

/**
 * @method
 * @name kucoin#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see https://docs.kucoin.com/#get-currencies
 * @param {object} params extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func (this *kucoin) FetchCurrencies(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		response := (<-this.PublicGetCurrencies(params))
		PanicOnError(response)
		//
		//    {
		//        "code":"200000",
		//        "data":[
		//           {
		//              "currency":"CSP",
		//              "name":"CSP",
		//              "fullName":"Caspian",
		//              "precision":8,
		//              "confirms":null,
		//              "contractAddress":null,
		//              "isMarginEnabled":false,
		//              "isDebitEnabled":false,
		//              "chains":[
		//                 {
		//                    "chainName":"ERC20",
		//                    "chainId": "eth"
		//                    "withdrawalMinSize":"2999",
		//                    "depositMinSize":null,
		//                    "withdrawFeeRate":"0",
		//                    "withdrawalMinFee":"2999",
		//                    "isWithdrawEnabled":false,
		//                    "isDepositEnabled":false,
		//                    "confirms":12,
		//                    "preConfirms":12,
		//                    "withdrawPrecision": 8,
		//                    "maxWithdraw": null,
		//                    "maxDeposit": null,
		//                    "needTag": false,
		//                    "contractAddress":"0xa6446d655a0c34bc4f05042ee88170d056cbaf45",
		//                    "depositFeeRate": "0.001", // present for some currencies/networks
		//                 }
		//              ]
		//           },
		//        ]
		//    }
		//
		var currenciesData interface{} = this.SafeList(response, "data", []interface{}{})
		var brokenCurrencies interface{} = this.SafeList(this.Options, "brokenCurrencies", []interface{}{"00", "OPEN_ERROR", "HUF", "BDT"})
		var result interface{} = map[string]interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(currenciesData)); i++ {
			var entry interface{} = GetValue(currenciesData, i)
			var id interface{} = this.SafeString(entry, "currency")
			if IsTrue(this.InArray(id, brokenCurrencies)) {
				continue
			}
			var code interface{} = this.SafeCurrencyCode(id)
			var networks interface{} = map[string]interface{}{}
			var chains interface{} = this.SafeList(entry, "chains", []interface{}{})
			var chainsLength interface{} = GetArrayLength(chains)
			for j := 0; IsLessThan(j, chainsLength); j++ {
				var chain interface{} = GetValue(chains, j)
				var chainId interface{} = this.SafeString(chain, "chainId")
				var networkCode interface{} = this.NetworkIdToCode(chainId, code)
				AddElementToObject(networks, networkCode, map[string]interface{}{
					"info":      chain,
					"id":        chainId,
					"name":      this.SafeString(chain, "chainName"),
					"code":      networkCode,
					"active":    nil,
					"fee":       this.SafeNumber(chain, "withdrawalMinFee"),
					"deposit":   this.SafeBool(chain, "isDepositEnabled"),
					"withdraw":  this.SafeBool(chain, "isWithdrawEnabled"),
					"precision": this.ParseNumber(this.ParsePrecision(this.SafeString(chain, "withdrawPrecision"))),
					"limits": map[string]interface{}{
						"withdraw": map[string]interface{}{
							"min": this.SafeNumber(chain, "withdrawalMinSize"),
							"max": this.SafeNumber(chain, "maxWithdraw"),
						},
						"deposit": map[string]interface{}{
							"min": this.SafeNumber(chain, "depositMinSize"),
							"max": this.SafeNumber(chain, "maxDeposit"),
						},
					},
				})
			}
			// kucoin has determined 'fiat' currencies with below logic
			var rawPrecision interface{} = this.SafeString(entry, "precision")
			var precision interface{} = this.ParseNumber(this.ParsePrecision(rawPrecision))
			var isFiat interface{} = IsEqual(chainsLength, 0)
			AddElementToObject(result, code, this.SafeCurrencyStructure(map[string]interface{}{
				"id":        id,
				"name":      this.SafeString(entry, "fullName"),
				"code":      code,
				"type":      Ternary(IsTrue(isFiat), "fiat", "crypto"),
				"precision": precision,
				"info":      entry,
				"networks":  networks,
				"deposit":   nil,
				"withdraw":  nil,
				"active":    nil,
				"fee":       nil,
				"limits":    nil,
			}))
		}

		ch <- result
		return nil

	}()
	return ch
}

/**
 * @method
 * @name kucoin#fetchAccounts
 * @description fetch all the accounts associated with a profile
 * @see https://docs.kucoin.com/#list-accounts
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/#/?id=account-structure} indexed by the account type
 */
func (this *kucoin) FetchAccounts(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		response := (<-this.PrivateGetAccounts(params))
		PanicOnError(response)
		//
		//     {
		//         "code": "200000",
		//         "data": [
		//             {
		//                 "balance": "0.00009788",
		//                 "available": "0.00009788",
		//                 "holds": "0",
		//                 "currency": "BTC",
		//                 "id": "5c6a4fd399a1d81c4f9cc4d0",
		//                 "type": "trade"
		//             },
		//             {
		//                 "balance": "0.00000001",
		//                 "available": "0.00000001",
		//                 "holds": "0",
		//                 "currency": "ETH",
		//                 "id": "5c6a49ec99a1d819392e8e9f",
		//                 "type": "trade"
		//             }
		//         ]
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var result interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
			var account interface{} = GetValue(data, i)
			var accountId interface{} = this.SafeString(account, "id")
			var currencyId interface{} = this.SafeString(account, "currency")
			var code interface{} = this.SafeCurrencyCode(currencyId)
			var typeVar interface{} = this.SafeString(account, "type") // main or trade
			AppendToArray(&result, map[string]interface{}{
				"id":       accountId,
				"type":     typeVar,
				"currency": code,
				"code":     code,
				"info":     account,
			})
		}

		ch <- result
		return nil

	}()
	return ch
}

/**
 * @method
 * @name kucoin#fetchTransactionFee
 * @description *DEPRECATED* please use fetchDepositWithdrawFee instead
 * @see https://docs.kucoin.com/#get-withdrawal-quotas
 * @param {string} code unified currency code
 * @param {object} params extra parameters specific to the exchange API endpoint
 * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func (this *kucoin) FetchTransactionFee(code interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes15198 := (<-this.LoadMarkets())
		PanicOnError(retRes15198)
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"currency": GetValue(currency, "id"),
		}
		var networkCode interface{} = nil
		networkCodeparamsVariable := this.HandleNetworkCodeAndParams(params)
		networkCode = GetValue(networkCodeparamsVariable, 0)
		params = GetValue(networkCodeparamsVariable, 1)
		if IsTrue(!IsEqual(networkCode, nil)) {
			AddElementToObject(request, "chain", ToLower(this.NetworkCodeToId(networkCode)))
		}

		response := (<-this.PrivateGetWithdrawalsQuotas(this.Extend(request, params)))
		PanicOnError(response)
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		var withdrawFees interface{} = map[string]interface{}{}
		AddElementToObject(withdrawFees, code, this.SafeNumber(data, "withdrawMinFee"))

		ch <- map[string]interface{}{
			"info":     response,
			"withdraw": withdrawFees,
			"deposit":  map[string]interface{}{},
		}
		return nil

	}()
	return ch
}

/**
 * @method
 * @name kucoin#fetchDepositWithdrawFee
 * @description fetch the fee for deposits and withdrawals
 * @see https://docs.kucoin.com/#get-withdrawal-quotas
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.network] The chain of currency. This only apply for multi-chain currency, and there is no need for single chain currency; you can query the chain through the response of the GET /api/v2/currencies/{currency} interface
 * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func (this *kucoin) FetchDepositWithdrawFee(code interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes15518 := (<-this.LoadMarkets())
		PanicOnError(retRes15518)
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"currency": GetValue(currency, "id"),
		}
		var networkCode interface{} = nil
		networkCodeparamsVariable := this.HandleNetworkCodeAndParams(params)
		networkCode = GetValue(networkCodeparamsVariable, 0)
		params = GetValue(networkCodeparamsVariable, 1)
		if IsTrue(!IsEqual(networkCode, nil)) {
			AddElementToObject(request, "chain", ToLower(this.NetworkCodeToId(networkCode)))
		}

		response := (<-this.PrivateGetWithdrawalsQuotas(this.Extend(request, params)))
		PanicOnError(response)
		//
		//    {
		//        "code": "200000",
		//        "data": {
		//            "currency": "USDT",
		//            "limitBTCAmount": "1.00000000",
		//            "usedBTCAmount": "0.00000000",
		//            "remainAmount": "16548.072149",
		//            "availableAmount": "0",
		//            "withdrawMinFee": "25",
		//            "innerWithdrawMinFee": "0",
		//            "withdrawMinSize": "50",
		//            "isWithdrawEnabled": true,
		//            "precision": 6,
		//            "chain": "ERC20"
		//        }
		//    }
		//
		var data interface{} = this.SafeDict(response, "data")

		ch <- this.ParseDepositWithdrawFee(data, currency)
		return nil

	}()
	return ch
}
func (this *kucoin) ParseDepositWithdrawFee(fee interface{}, optionalArgs ...interface{}) interface{} {
	//
	//    {
	//        "currency": "USDT",
	//        "limitBTCAmount": "1.00000000",
	//        "usedBTCAmount": "0.00000000",
	//        "remainAmount": "16548.072149",
	//        "availableAmount": "0",
	//        "withdrawMinFee": "25",
	//        "innerWithdrawMinFee": "0",
	//        "withdrawMinSize": "50",
	//        "isWithdrawEnabled": true,
	//        "precision": 6,
	//        "chain": "ERC20"
	//    }
	//
	// if data obtained through `currencies` endpoint
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	if IsTrue(InOp(fee, "chains")) {
		var resultNew interface{} = map[string]interface{}{
			"info": fee,
			"withdraw": map[string]interface{}{
				"fee":        nil,
				"percentage": false,
			},
			"deposit": map[string]interface{}{
				"fee":        nil,
				"percentage": nil,
			},
			"networks": map[string]interface{}{},
		}
		var chains interface{} = this.SafeList(fee, "chains", []interface{}{})
		for i := 0; IsLessThan(i, GetArrayLength(chains)); i++ {
			var chain interface{} = GetValue(chains, i)
			var networkCodeNew interface{} = this.NetworkIdToCode(this.SafeString(chain, "chainId"), this.SafeString(currency, "code"))
			AddElementToObject(GetValue(resultNew, "networks"), networkCodeNew, map[string]interface{}{
				"withdraw": map[string]interface{}{
					"fee":        this.SafeNumber(chain, "withdrawMinFee"),
					"percentage": false,
				},
				"deposit": map[string]interface{}{
					"fee":        nil,
					"percentage": nil,
				},
			})
		}
		return resultNew
	}
	var minWithdrawFee interface{} = this.SafeNumber(fee, "withdrawMinFee")
	var result interface{} = map[string]interface{}{
		"info": fee,
		"withdraw": map[string]interface{}{
			"fee":        minWithdrawFee,
			"percentage": false,
		},
		"deposit": map[string]interface{}{
			"fee":        nil,
			"percentage": nil,
		},
		"networks": map[string]interface{}{},
	}
	var networkId interface{} = this.SafeString(fee, "chain")
	var networkCode interface{} = this.NetworkIdToCode(networkId, this.SafeString(currency, "code"))
	AddElementToObject(GetValue(result, "networks"), networkCode, map[string]interface{}{
		"withdraw": minWithdrawFee,
		"deposit": map[string]interface{}{
			"fee":        nil,
			"percentage": nil,
		},
	})
	return result
}
func (this *kucoin) IsFuturesMethod(methodName interface{}, params interface{}) interface{} {
	//
	// Helper
	// @methodName (string): The name of the method
	// @params (dict): The parameters passed into {methodName}
	// @return: true if the method used is meant for futures trading, false otherwise
	//
	var defaultType interface{} = this.SafeString2(this.Options, methodName, "defaultType", "trade")
	var requestedType interface{} = this.SafeString(params, "type", defaultType)
	var accountsByType interface{} = this.SafeDict(this.Options, "accountsByType")
	var typeVar interface{} = this.SafeString(accountsByType, requestedType)
	if IsTrue(IsEqual(typeVar, nil)) {
		var keys interface{} = ObjectKeys(accountsByType)
		panic(ExchangeError(Add(Add(this.Id, " isFuturesMethod() type must be one of "), Join(keys, ", "))))
	}
	params = this.Omit(params, "type")
	return IsTrue(IsTrue((IsEqual(typeVar, "contract"))) || IsTrue((IsEqual(typeVar, "future")))) || IsTrue((IsEqual(typeVar, "futures"))) // * (type === 'futures') deprecated, use (type === 'future')
}
func (this *kucoin) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "symbol": "BTC-USDT",   // symbol
	//         "symbolName":"BTC-USDT", // Name of trading pairs, it would change after renaming
	//         "buy": "11328.9",   // bestAsk
	//         "sell": "11329",    // bestBid
	//         "changeRate": "-0.0055",    // 24h change rate
	//         "changePrice": "-63.6", // 24h change price
	//         "high": "11610",    // 24h highest price
	//         "low": "11200", // 24h lowest price
	//         "vol": "2282.70993217", // 24h volumethe aggregated trading volume in BTC
	//         "volValue": "25984946.157790431",   // 24h total, the trading volume in quote currency of last 24 hours
	//         "last": "11328.9",  // last price
	//         "averagePrice": "11360.66065903",   // 24h average transaction price yesterday
	//         "takerFeeRate": "0.001",    // Basic Taker Fee
	//         "makerFeeRate": "0.001",    // Basic Maker Fee
	//         "takerCoefficient": "1",    // Taker Fee Coefficient
	//         "makerCoefficient": "1" // Maker Fee Coefficient
	//     }
	//
	//     {
	//         "trading": true,
	//         "symbol": "KCS-BTC",
	//         "buy": 0.00011,
	//         "sell": 0.00012,
	//         "sort": 100,
	//         "volValue": 3.13851792584,   //total
	//         "baseCurrency": "KCS",
	//         "market": "BTC",
	//         "quoteCurrency": "BTC",
	//         "symbolCode": "KCS-BTC",
	//         "datetime": 1548388122031,
	//         "high": 0.00013,
	//         "vol": 27514.34842,
	//         "low": 0.0001,
	//         "changePrice": -1.0e-5,
	//         "changeRate": -0.0769,
	//         "lastTradedPrice": 0.00012,
	//         "board": 0,
	//         "mark": 0
	//     }
	//
	// market/ticker ws subscription
	//
	//     {
	//         "bestAsk": "62258.9",
	//         "bestAskSize": "0.38579986",
	//         "bestBid": "62258.8",
	//         "bestBidSize": "0.0078381",
	//         "price": "62260.7",
	//         "sequence": "1621383297064",
	//         "size": "0.00002841",
	//         "time": 1634641777363
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var percentage interface{} = this.SafeString(ticker, "changeRate")
	if IsTrue(!IsEqual(percentage, nil)) {
		percentage = Precise.StringMul(percentage, "100")
	}
	var last interface{} = this.SafeString2(ticker, "last", "lastTradedPrice")
	last = this.SafeString(ticker, "price", last)
	var marketId interface{} = this.SafeString(ticker, "symbol")
	market = this.SafeMarket(marketId, market, "-")
	var symbol interface{} = GetValue(market, "symbol")
	var baseVolume interface{} = this.SafeString(ticker, "vol")
	var quoteVolume interface{} = this.SafeString(ticker, "volValue")
	var timestamp interface{} = this.SafeIntegerN(ticker, []interface{}{"time", "datetime", "timePoint"})
	return this.SafeTicker(map[string]interface{}{
		"symbol":        symbol,
		"timestamp":     timestamp,
		"datetime":      this.Iso8601(timestamp),
		"high":          this.SafeString(ticker, "high"),
		"low":           this.SafeString(ticker, "low"),
		"bid":           this.SafeString2(ticker, "buy", "bestBid"),
		"bidVolume":     this.SafeString(ticker, "bestBidSize"),
		"ask":           this.SafeString2(ticker, "sell", "bestAsk"),
		"askVolume":     this.SafeString(ticker, "bestAskSize"),
		"vwap":          nil,
		"open":          this.SafeString(ticker, "open"),
		"close":         last,
		"last":          last,
		"previousClose": nil,
		"change":        this.SafeString(ticker, "changePrice"),
		"percentage":    percentage,
		"average":       this.SafeString(ticker, "averagePrice"),
		"baseVolume":    baseVolume,
		"quoteVolume":   quoteVolume,
		"markPrice":     this.SafeString(ticker, "value"),
		"info":          ticker,
	}, market)
}

/**
 * @method
 * @name kucoin#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://docs.kucoin.com/#get-all-tickers
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func (this *kucoin) FetchTickers(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes17788 := (<-this.LoadMarkets())
		PanicOnError(retRes17788)
		symbols = this.MarketSymbols(symbols)

		response := (<-this.PublicGetMarketAllTickers(params))
		PanicOnError(response)
		//
		//     {
		//         "code": "200000",
		//         "data": {
		//             "time":1602832092060,
		//             "ticker":[
		//                 {
		//                     "symbol": "BTC-USDT",   // symbol
		//                     "symbolName":"BTC-USDT", // Name of trading pairs, it would change after renaming
		//                     "buy": "11328.9",   // bestAsk
		//                     "sell": "11329",    // bestBid
		//                     "changeRate": "-0.0055",    // 24h change rate
		//                     "changePrice": "-63.6", // 24h change price
		//                     "high": "11610",    // 24h highest price
		//                     "low": "11200", // 24h lowest price
		//                     "vol": "2282.70993217", // 24h volumethe aggregated trading volume in BTC
		//                     "volValue": "25984946.157790431",   // 24h total, the trading volume in quote currency of last 24 hours
		//                     "last": "11328.9",  // last price
		//                     "averagePrice": "11360.66065903",   // 24h average transaction price yesterday
		//                     "takerFeeRate": "0.001",    // Basic Taker Fee
		//                     "makerFeeRate": "0.001",    // Basic Maker Fee
		//                     "takerCoefficient": "1",    // Taker Fee Coefficient
		//                     "makerCoefficient": "1" // Maker Fee Coefficient
		//                 }
		//             ]
		//         }
		//     }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		var tickers interface{} = this.SafeList(data, "ticker", []interface{}{})
		var time interface{} = this.SafeInteger(data, "time")
		var result interface{} = map[string]interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(tickers)); i++ {
			AddElementToObject(GetValue(tickers, i), "time", time)
			var ticker interface{} = this.ParseTicker(GetValue(tickers, i))
			var symbol interface{} = this.SafeString(ticker, "symbol")
			if IsTrue(!IsEqual(symbol, nil)) {
				AddElementToObject(result, symbol, ticker)
			}
		}

		ch <- this.FilterByArrayTickers(result, "symbol", symbols)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name kucoin#fetchMarkPrices
 * @description fetches the mark price for multiple markets
 * @see https://www.kucoin.com/docs/rest/margin-trading/margin-info/get-all-margin-trading-pairs-mark-prices
 * @param {string[]} [symbols] unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func (this *kucoin) FetchMarkPrices(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbols := GetArg(optionalArgs, 0, nil)
		_ = symbols
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes18348 := (<-this.LoadMarkets())
		PanicOnError(retRes18348)
		symbols = this.MarketSymbols(symbols)

		response := (<-this.PublicGetMarkPriceAllSymbols(params))
		PanicOnError(response)
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseTickers(data)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name kucoin#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://docs.kucoin.com/#get-24hr-stats
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func (this *kucoin) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes18518 := (<-this.LoadMarkets())
		PanicOnError(retRes18518)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}

		response := (<-this.PublicGetMarketStats(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "200000",
		//         "data": {
		//             "time": 1602832092060,  // time
		//             "symbol": "BTC-USDT",   // symbol
		//             "buy": "11328.9",   // bestAsk
		//             "sell": "11329",    // bestBid
		//             "changeRate": "-0.0055",    // 24h change rate
		//             "changePrice": "-63.6", // 24h change price
		//             "high": "11610",    // 24h highest price
		//             "low": "11200", // 24h lowest price
		//             "vol": "2282.70993217", // 24h volumethe aggregated trading volume in BTC
		//             "volValue": "25984946.157790431",   // 24h total, the trading volume in quote currency of last 24 hours
		//             "last": "11328.9",  // last price
		//             "averagePrice": "11360.66065903",   // 24h average transaction price yesterday
		//             "takerFeeRate": "0.001",    // Basic Taker Fee
		//             "makerFeeRate": "0.001",    // Basic Maker Fee
		//             "takerCoefficient": "1",    // Taker Fee Coefficient
		//             "makerCoefficient": "1" // Maker Fee Coefficient
		//         }
		//     }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})

		ch <- this.ParseTicker(data, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name kucoin#fetchMarkPrice
 * @description fetches the mark price for a specific market
 * @see https://www.kucoin.com/docs/rest/margin-trading/margin-info/get-mark-price
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func (this *kucoin) FetchMarkPrice(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes18948 := (<-this.LoadMarkets())
		PanicOnError(retRes18948)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}

		response := (<-this.PublicGetMarkPriceSymbolCurrent(this.Extend(request, params)))
		PanicOnError(response)
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})

		ch <- this.ParseTicker(data, market)
		return nil

	}()
	return ch
}
func (this *kucoin) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     [
	//         "1545904980",             // Start time of the candle cycle
	//         "0.058",                  // opening price
	//         "0.049",                  // closing price
	//         "0.058",                  // highest price
	//         "0.049",                  // lowest price
	//         "0.018",                  // base volume
	//         "0.000945",               // quote volume
	//     ]
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	return []interface{}{this.SafeTimestamp(ohlcv, 0), this.SafeNumber(ohlcv, 1), this.SafeNumber(ohlcv, 3), this.SafeNumber(ohlcv, 4), this.SafeNumber(ohlcv, 2), this.SafeNumber(ohlcv, 5)}
}

/**
 * @method
 * @name kucoin#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://docs.kucoin.com/#get-klines
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func (this *kucoin) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		timeframe := GetArg(optionalArgs, 0, "1m")
		_ = timeframe
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes19418 := (<-this.LoadMarkets())
		PanicOnError(retRes19418)
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchOHLCV", "paginate")
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {

			retRes194519 := (<-this.FetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, params, 1500))
			PanicOnError(retRes194519)
			ch <- retRes194519
			return nil
		}
		var market interface{} = this.Market(symbol)
		var marketId interface{} = GetValue(market, "id")
		var request interface{} = map[string]interface{}{
			"symbol": marketId,
			"type":   this.SafeString(this.Timeframes, timeframe, timeframe),
		}
		var duration interface{} = Multiply(this.ParseTimeframe(timeframe), 1000)
		var endAt interface{} = this.Milliseconds() // required param
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startAt", this.ParseToInt(MathFloor(Divide(since, 1000))))
			if IsTrue(IsEqual(limit, nil)) {
				// https://docs.kucoin.com/#get-klines
				// https://docs.kucoin.com/#details
				// For each query, the system would return at most 1500 pieces of data.
				// To obtain more data, please page the data by time.
				limit = this.SafeInteger(this.Options, "fetchOHLCVLimit", 1500)
			}
			endAt = this.Sum(since, Multiply(limit, duration))
		} else if IsTrue(!IsEqual(limit, nil)) {
			since = Subtract(endAt, Multiply(limit, duration))
			AddElementToObject(request, "startAt", this.ParseToInt(MathFloor(Divide(since, 1000))))
		}
		AddElementToObject(request, "endAt", this.ParseToInt(MathFloor(Divide(endAt, 1000))))

		response := (<-this.PublicGetMarketCandles(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code":"200000",
		//         "data":[
		//             ["1591517700","0.025078","0.025069","0.025084","0.025064","18.9883256","0.4761861079404"],
		//             ["1591516800","0.025089","0.025079","0.025089","0.02506","99.4716622","2.494143499081"],
		//             ["1591515900","0.025079","0.02509","0.025091","0.025068","59.83701271","1.50060885172798"],
		//         ]
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseOHLCVs(data, market, timeframe, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name kucoin#createDepositAddress
 * @see https://www.kucoin.com/docs/rest/funding/deposit/create-deposit-address-v3-
 * @description create a currency deposit address
 * @param {string} code unified currency code of the currency for the deposit address
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.network] the blockchain network name
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func (this *kucoin) CreateDepositAddress(code interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes19968 := (<-this.LoadMarkets())
		PanicOnError(retRes19968)
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"currency": GetValue(currency, "id"),
		}
		var networkCode interface{} = nil
		networkCodeparamsVariable := this.HandleNetworkCodeAndParams(params)
		networkCode = GetValue(networkCodeparamsVariable, 0)
		params = GetValue(networkCodeparamsVariable, 1)
		if IsTrue(!IsEqual(networkCode, nil)) {
			AddElementToObject(request, "chain", this.NetworkCodeToId(networkCode)) // docs mention "chain-name", but seems "chain-id" is used, like in "fetchDepositAddress"
		}

		response := (<-this.PrivatePostDepositAddressCreate(this.Extend(request, params)))
		PanicOnError(response)
		// {"code":"260000","msg":"Deposit address already exists."}
		//
		//   {
		//     "code": "200000",
		//     "data": {
		//       "address": "0x2336d1834faab10b2dac44e468f2627138417431",
		//       "memo": null,
		//       "chainId": "bsc",
		//       "to": "MAIN",
		//       "expirationDate": 0,
		//       "currency": "BNB",
		//       "chainName": "BEP20"
		//     }
		//   }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})

		ch <- this.ParseDepositAddress(data, currency)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name kucoin#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account
 * @see https://docs.kucoin.com/#get-deposit-addresses-v2
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.network] the blockchain network name
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func (this *kucoin) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes20378 := (<-this.LoadMarkets())
		PanicOnError(retRes20378)
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"currency": GetValue(currency, "id"),
		}
		var networkCode interface{} = nil
		networkCodeparamsVariable := this.HandleNetworkCodeAndParams(params)
		networkCode = GetValue(networkCodeparamsVariable, 0)
		params = GetValue(networkCodeparamsVariable, 1)
		if IsTrue(!IsEqual(networkCode, nil)) {
			AddElementToObject(request, "chain", ToLower(this.NetworkCodeToId(networkCode)))
		}
		var version interface{} = GetValue(GetValue(GetValue(GetValue(this.Options, "versions"), "private"), "GET"), "deposit-addresses")
		AddElementToObject(GetValue(GetValue(GetValue(this.Options, "versions"), "private"), "GET"), "deposit-addresses", "v1")

		response := (<-this.PrivateGetDepositAddresses(this.Extend(request, params)))
		PanicOnError(response)
		// BCH {"code":"200000","data":{"address":"bitcoincash:qza3m4nj9rx7l9r0cdadfqxts6f92shvhvr5ls4q7z","memo":""}}
		// BTC {"code":"200000","data":{"address":"36SjucKqQpQSvsak9A7h6qzFjrVXpRNZhE","memo":""}}
		AddElementToObject(GetValue(GetValue(GetValue(this.Options, "versions"), "private"), "GET"), "deposit-addresses", version)
		var data interface{} = this.SafeValue(response, "data")
		if IsTrue(IsEqual(data, nil)) {
			panic(ExchangeError(Add(this.Id, " fetchDepositAddress() returned an empty response, you might try to run createDepositAddress() first and try again")))
		}

		ch <- this.ParseDepositAddress(data, currency)
		return nil

	}()
	return ch
}
func (this *kucoin) ParseDepositAddress(depositAddress interface{}, optionalArgs ...interface{}) interface{} {
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var address interface{} = this.SafeString(depositAddress, "address")
	// BCH/BSV is returned with a "bitcoincash:" prefix, which we cut off here and only keep the address
	if IsTrue(!IsEqual(address, nil)) {
		address = Replace(address, "bitcoincash:", "")
	}
	var code interface{} = nil
	if IsTrue(!IsEqual(currency, nil)) {
		code = this.SafeCurrencyCode(GetValue(currency, "id"))
		if IsTrue(!IsEqual(code, "NIM")) {
			// contains spaces
			this.CheckAddress(address)
		}
	}
	return map[string]interface{}{
		"info":     depositAddress,
		"currency": code,
		"network":  this.NetworkIdToCode(this.SafeString(depositAddress, "chainId")),
		"address":  address,
		"tag":      this.SafeString(depositAddress, "memo"),
	}
}

/**
 * @method
 * @name kucoin#fetchDepositAddressesByNetwork
 * @see https://docs.kucoin.com/#get-deposit-addresses-v2
 * @description fetch the deposit address for a currency associated with this account
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an array of [address structures]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func (this *kucoin) FetchDepositAddressesByNetwork(code interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes20968 := (<-this.LoadMarkets())
		PanicOnError(retRes20968)
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"currency": GetValue(currency, "id"),
		}
		var version interface{} = GetValue(GetValue(GetValue(GetValue(this.Options, "versions"), "private"), "GET"), "deposit-addresses")
		AddElementToObject(GetValue(GetValue(GetValue(this.Options, "versions"), "private"), "GET"), "deposit-addresses", "v2")

		response := (<-this.PrivateGetDepositAddresses(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "200000",
		//         "data": [
		//             {
		//                 "address": "fr1qvus7d4d5fgxj5e7zvqe6yhxd7txm95h2and69r",
		//                 "memo": "",
		//                 "chain": "BTC-Segwit",
		//                 "contractAddress": ""
		//             },
		//             {"address":"37icNMEWbiF8ZkwUMxmfzMxi2A1MQ44bMn","memo":"","chain":"BTC","contractAddress":""},
		//             {"address":"Deposit temporarily blocked","memo":"","chain":"TRC20","contractAddress":""}
		//         ]
		//     }
		//
		AddElementToObject(GetValue(GetValue(GetValue(this.Options, "versions"), "private"), "GET"), "deposit-addresses", version)
		var chains interface{} = this.SafeList(response, "data", []interface{}{})
		var parsed interface{} = this.ParseDepositAddresses(chains, []interface{}{GetValue(currency, "code")}, false, map[string]interface{}{
			"currency": GetValue(currency, "code"),
		})

		ch <- this.IndexBy(parsed, "network")
		return nil

	}()
	return ch
}

/**
 * @method
 * @name kucoin#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://www.kucoin.com/docs/rest/spot-trading/market-data/get-part-order-book-aggregated-
 * @see https://www.kucoin.com/docs/rest/spot-trading/market-data/get-full-order-book-aggregated-
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func (this *kucoin) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		limit := GetArg(optionalArgs, 0, nil)
		_ = limit
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes21398 := (<-this.LoadMarkets())
		PanicOnError(retRes21398)
		var market interface{} = this.Market(symbol)
		var level interface{} = this.SafeInteger(params, "level", 2)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		var isAuthenticated interface{} = this.CheckRequiredCredentials(false)
		var response interface{} = nil
		if IsTrue(!IsTrue(isAuthenticated) || IsTrue(!IsEqual(limit, nil))) {
			if IsTrue(IsEqual(level, 2)) {
				AddElementToObject(request, "level", level)
				if IsTrue(!IsEqual(limit, nil)) {
					if IsTrue(IsTrue((IsEqual(limit, 20))) || IsTrue((IsEqual(limit, 100)))) {
						AddElementToObject(request, "limit", limit)
					} else {
						panic(ExchangeError(Add(this.Id, " fetchOrderBook() limit argument must be 20 or 100")))
					}
				}
				AddElementToObject(request, "limit", Ternary(IsTrue(limit), limit, 100))
			}

			response = (<-this.PublicGetMarketOrderbookLevelLevelLimit(this.Extend(request, params)))
			PanicOnError(response)
		} else {

			response = (<-this.PrivateGetMarketOrderbookLevel2(this.Extend(request, params)))
			PanicOnError(response)
		}
		//
		// public (v1) market/orderbook/level2_20 and market/orderbook/level2_100
		//
		//     {
		//         "sequence": "3262786978",
		//         "time": 1550653727731,
		//         "bids": [
		//             ["6500.12", "0.45054140"],
		//             ["6500.11", "0.45054140"],
		//         ],
		//         "asks": [
		//             ["6500.16", "0.57753524"],
		//             ["6500.15", "0.57753524"],
		//         ]
		//     }
		//
		// private (v3) market/orderbook/level2
		//
		//     {
		//         "sequence": "3262786978",
		//         "time": 1550653727731,
		//         "bids": [
		//             ["6500.12", "0.45054140"],
		//             ["6500.11", "0.45054140"],
		//         ],
		//         "asks": [
		//             ["6500.16", "0.57753524"],
		//             ["6500.15", "0.57753524"],
		//         ]
		//     }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		var timestamp interface{} = this.SafeInteger(data, "time")
		var orderbook interface{} = this.ParseOrderBook(data, GetValue(market, "symbol"), timestamp, "bids", "asks", Subtract(level, 2), Subtract(level, 1))
		AddElementToObject(orderbook, "nonce", this.SafeInteger(data, "sequence"))

		ch <- orderbook
		return nil

	}()
	return ch
}
func (this *kucoin) HandleTriggerPrices(params interface{}) interface{} {
	var triggerPrice interface{} = this.SafeValue2(params, "triggerPrice", "stopPrice")
	var stopLossPrice interface{} = this.SafeValue(params, "stopLossPrice")
	var takeProfitPrice interface{} = this.SafeValue(params, "takeProfitPrice")
	var isStopLoss interface{} = !IsEqual(stopLossPrice, nil)
	var isTakeProfit interface{} = !IsEqual(takeProfitPrice, nil)
	if IsTrue(IsTrue(IsTrue((IsTrue(isStopLoss) && IsTrue(isTakeProfit))) || IsTrue((IsTrue(triggerPrice) && IsTrue(stopLossPrice)))) || IsTrue((IsTrue(triggerPrice) && IsTrue(isTakeProfit)))) {
		panic(ExchangeError(Add(this.Id, " createOrder() - you should use either triggerPrice or stopLossPrice or takeProfitPrice")))
	}
	return []interface{}{triggerPrice, stopLossPrice, takeProfitPrice}
}

/**
 * @method
 * @name kucoin#createOrder
 * @description Create an order on the exchange
 * @see https://docs.kucoin.com/spot#place-a-new-order
 * @see https://docs.kucoin.com/spot#place-a-new-order-2
 * @see https://docs.kucoin.com/spot#place-a-margin-order
 * @see https://docs.kucoin.com/spot-hf/#place-hf-order
 * @see https://www.kucoin.com/docs/rest/spot-trading/orders/place-order-test
 * @see https://www.kucoin.com/docs/rest/margin-trading/orders/place-margin-order-test
 * @see https://www.kucoin.com/docs/rest/spot-trading/spot-hf-trade-pro-account/sync-place-hf-order
 * @param {string} symbol Unified CCXT market symbol
 * @param {string} type 'limit' or 'market'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount the amount of currency to trade
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params]  extra parameters specific to the exchange API endpoint
 * @param {float} [params.triggerPrice] The price at which a trigger order is triggered at
 * @param {string} [params.marginMode] 'cross', // cross (cross mode) and isolated (isolated mode), set to cross by default, the isolated mode will be released soon, stay tuned
 * @param {string} [params.timeInForce] GTC, GTT, IOC, or FOK, default is GTC, limit orders only
 * @param {string} [params.postOnly] Post only flag, invalid when timeInForce is IOC or FOK
 *
 * EXCHANGE SPECIFIC PARAMETERS
 * @param {string} [params.clientOid] client order id, defaults to uuid if not passed
 * @param {string} [params.remark] remark for the order, length cannot exceed 100 utf8 characters
 * @param {string} [params.tradeType] 'TRADE', // TRADE, MARGIN_TRADE // not used with margin orders
 * limit orders ---------------------------------------------------
 * @param {float} [params.cancelAfter] long, // cancel after n seconds, requires timeInForce to be GTT
 * @param {bool} [params.hidden] false, // Order will not be displayed in the order book
 * @param {bool} [params.iceberg] false, // Only a portion of the order is displayed in the order book
 * @param {string} [params.visibleSize] this.amountToPrecision (symbol, visibleSize), // The maximum visible size of an iceberg order
 * market orders --------------------------------------------------
 * @param {string} [params.funds] // Amount of quote currency to use
 * stop orders ----------------------------------------------------
 * @param {string} [params.stop]  Either loss or entry, the default is loss. Requires triggerPrice to be defined
 * margin orders --------------------------------------------------
 * @param {float} [params.leverage] Leverage size of the order
 * @param {string} [params.stp] '', // self trade prevention, CN, CO, CB or DC
 * @param {bool} [params.autoBorrow] false, // The system will first borrow you funds at the optimal interest rate and then place an order for you
 * @param {bool} [params.hf] false, // true for hf order
 * @param {bool} [params.test] set to true to test an order, no order will be created but the request will be validated
 * @param {bool} [params.sync] set to true to use the hf sync call
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *kucoin) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		price := GetArg(optionalArgs, 0, nil)
		_ = price
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes22568 := (<-this.LoadMarkets())
		PanicOnError(retRes22568)
		var market interface{} = this.Market(symbol)
		var testOrder interface{} = this.SafeBool(params, "test", false)
		params = this.Omit(params, "test")
		var hf interface{} = nil
		hfparamsVariable := this.HandleHfAndParams(params)
		hf = GetValue(hfparamsVariable, 0)
		params = GetValue(hfparamsVariable, 1)
		var useSync interface{} = false
		useSyncparamsVariable := this.HandleOptionAndParams(params, "createOrder", "sync", false)
		useSync = GetValue(useSyncparamsVariable, 0)
		params = GetValue(useSyncparamsVariable, 1)
		triggerPricestopLossPricetakeProfitPriceVariable := this.HandleTriggerPrices(params)
		triggerPrice := GetValue(triggerPricestopLossPricetakeProfitPriceVariable, 0)
		stopLossPrice := GetValue(triggerPricestopLossPricetakeProfitPriceVariable, 1)
		takeProfitPrice := GetValue(triggerPricestopLossPricetakeProfitPriceVariable, 2)
		var tradeType interface{} = this.SafeString(params, "tradeType") // keep it for backward compatibility
		var isTriggerOrder interface{} = (IsTrue(IsTrue(triggerPrice) || IsTrue(stopLossPrice)) || IsTrue(takeProfitPrice))
		var marginResult interface{} = this.HandleMarginModeAndParams("createOrder", params)
		var marginMode interface{} = this.SafeString(marginResult, 0)
		var isMarginOrder interface{} = IsTrue(IsEqual(tradeType, "MARGIN_TRADE")) || IsTrue(!IsEqual(marginMode, nil))
		// don't omit anything before calling createOrderRequest
		var orderRequest interface{} = this.CreateOrderRequest(symbol, typeVar, side, amount, price, params)
		var response interface{} = nil
		if IsTrue(testOrder) {
			if IsTrue(isMarginOrder) {

				response = (<-this.PrivatePostMarginOrderTest(orderRequest))
				PanicOnError(response)
			} else if IsTrue(hf) {

				response = (<-this.PrivatePostHfOrdersTest(orderRequest))
				PanicOnError(response)
			} else {

				response = (<-this.PrivatePostOrdersTest(orderRequest))
				PanicOnError(response)
			}
		} else if IsTrue(isTriggerOrder) {

			response = (<-this.PrivatePostStopOrder(orderRequest))
			PanicOnError(response)
		} else if IsTrue(isMarginOrder) {

			response = (<-this.PrivatePostMarginOrder(orderRequest))
			PanicOnError(response)
		} else if IsTrue(useSync) {

			response = (<-this.PrivatePostHfOrdersSync(orderRequest))
			PanicOnError(response)
		} else if IsTrue(hf) {

			response = (<-this.PrivatePostHfOrders(orderRequest))
			PanicOnError(response)
		} else {

			response = (<-this.PrivatePostOrders(orderRequest))
			PanicOnError(response)
		}
		//
		//     {
		//         "code": "200000",
		//         "data": {
		//             "orderId": "5bd6e9286d99522a52e458de"
		//         }
		//    }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})

		ch <- this.ParseOrder(data, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name kucoin#createMarketOrderWithCost
 * @description create a market order by providing the symbol, side and cost
 * @see https://www.kucoin.com/docs/rest/spot-trading/orders/place-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} side 'buy' or 'sell'
 * @param {float} cost how much you want to trade in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *kucoin) CreateMarketOrderWithCost(symbol interface{}, side interface{}, cost interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes23168 := (<-this.LoadMarkets())
		PanicOnError(retRes23168)
		var req interface{} = map[string]interface{}{
			"cost": cost,
		}

		retRes232015 := (<-this.CreateOrder(symbol, "market", side, cost, nil, this.Extend(req, params)))
		PanicOnError(retRes232015)
		ch <- retRes232015
		return nil

	}()
	return ch
}

/**
 * @method
 * @name kucoin#createMarketBuyOrderWithCost
 * @description create a market buy order by providing the symbol and cost
 * @see https://www.kucoin.com/docs/rest/spot-trading/orders/place-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {float} cost how much you want to trade in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *kucoin) CreateMarketBuyOrderWithCost(symbol interface{}, cost interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes23348 := (<-this.LoadMarkets())
		PanicOnError(retRes23348)

		retRes233515 := (<-this.CreateMarketOrderWithCost(symbol, "buy", cost, params))
		PanicOnError(retRes233515)
		ch <- retRes233515
		return nil

	}()
	return ch
}

/**
 * @method
 * @name kucoin#createMarketSellOrderWithCost
 * @description create a market sell order by providing the symbol and cost
 * @see https://www.kucoin.com/docs/rest/spot-trading/orders/place-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {float} cost how much you want to trade in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *kucoin) CreateMarketSellOrderWithCost(symbol interface{}, cost interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes23498 := (<-this.LoadMarkets())
		PanicOnError(retRes23498)

		retRes235015 := (<-this.CreateMarketOrderWithCost(symbol, "sell", cost, params))
		PanicOnError(retRes235015)
		ch <- retRes235015
		return nil

	}()
	return ch
}

/**
 * @method
 * @name kucoin#createOrders
 * @description create a list of trade orders
 * @see https://www.kucoin.com/docs/rest/spot-trading/orders/place-multiple-orders
 * @see https://www.kucoin.com/docs/rest/spot-trading/spot-hf-trade-pro-account/place-multiple-hf-orders
 * @see https://www.kucoin.com/docs/rest/spot-trading/spot-hf-trade-pro-account/sync-place-multiple-hf-orders
 * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
 * @param {object} [params]  extra parameters specific to the exchange API endpoint
 * @param {bool} [params.hf] false, // true for hf orders
 * @param {bool} [params.sync] false, // true to use the hf sync call
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *kucoin) CreateOrders(orders interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes23678 := (<-this.LoadMarkets())
		PanicOnError(retRes23678)
		var ordersRequests interface{} = []interface{}{}
		var symbol interface{} = nil
		for i := 0; IsLessThan(i, GetArrayLength(orders)); i++ {
			var rawOrder interface{} = GetValue(orders, i)
			var marketId interface{} = this.SafeString(rawOrder, "symbol")
			if IsTrue(IsEqual(symbol, nil)) {
				symbol = marketId
			} else {
				if IsTrue(!IsEqual(symbol, marketId)) {
					panic(BadRequest(Add(this.Id, " createOrders() requires all orders to have the same symbol")))
				}
			}
			var typeVar interface{} = this.SafeString(rawOrder, "type")
			if IsTrue(!IsEqual(typeVar, "limit")) {
				panic(BadRequest(Add(this.Id, " createOrders() only supports limit orders")))
			}
			var side interface{} = this.SafeString(rawOrder, "side")
			var amount interface{} = this.SafeValue(rawOrder, "amount")
			var price interface{} = this.SafeValue(rawOrder, "price")
			var orderParams interface{} = this.SafeValue(rawOrder, "params", map[string]interface{}{})
			var orderRequest interface{} = this.CreateOrderRequest(marketId, typeVar, side, amount, price, orderParams)
			AppendToArray(&ordersRequests, orderRequest)
		}
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol":    GetValue(market, "id"),
			"orderList": ordersRequests,
		}
		var hf interface{} = nil
		hfparamsVariable := this.HandleHfAndParams(params)
		hf = GetValue(hfparamsVariable, 0)
		params = GetValue(hfparamsVariable, 1)
		var useSync interface{} = false
		useSyncparamsVariable := this.HandleOptionAndParams(params, "createOrders", "sync", false)
		useSync = GetValue(useSyncparamsVariable, 0)
		params = GetValue(useSyncparamsVariable, 1)
		var response interface{} = nil
		if IsTrue(useSync) {

			response = (<-this.PrivatePostHfOrdersMultiSync(this.Extend(request, params)))
			PanicOnError(response)
		} else if IsTrue(hf) {

			response = (<-this.PrivatePostHfOrdersMulti(this.Extend(request, params)))
			PanicOnError(response)
		} else {

			response = (<-this.PrivatePostOrdersMulti(this.Extend(request, params)))
			PanicOnError(response)
		}
		//
		// {
		//     "code": "200000",
		//     "data": {
		//        "data": [
		//           {
		//              "symbol": "LTC-USDT",
		//              "type": "limit",
		//              "side": "sell",
		//              "price": "90",
		//              "size": "0.1",
		//              "funds": null,
		//              "stp": "",
		//              "stop": "",
		//              "stopPrice": null,
		//              "timeInForce": "GTC",
		//              "cancelAfter": 0,
		//              "postOnly": false,
		//              "hidden": false,
		//              "iceberge": false,
		//              "iceberg": false,
		//              "visibleSize": null,
		//              "channel": "API",
		//              "id": "6539148443fcf500079d15e5",
		//              "status": "success",
		//              "failMsg": null,
		//              "clientOid": "5c4c5398-8ab2-4b4e-af8a-e2d90ad2488f"
		//           },
		// }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		data = this.SafeList(data, "data", []interface{}{})

		ch <- this.ParseOrders(data)
		return nil

	}()
	return ch
}
func (this *kucoin) MarketOrderAmountToPrecision(symbol interface{}, amount interface{}) interface{} {
	var market interface{} = this.Market(symbol)
	var result interface{} = this.DecimalToPrecision(amount, TRUNCATE, GetValue(GetValue(market, "info"), "quoteIncrement"), this.PrecisionMode, this.PaddingMode)
	if IsTrue(IsEqual(result, "0")) {
		panic(InvalidOrder(Add(Add(Add(Add(this.Id, " amount of "), GetValue(market, "symbol")), " must be greater than minimum amount precision of "), this.NumberToString(GetValue(GetValue(market, "precision"), "amount")))))
	}
	return result
}
func (this *kucoin) CreateOrderRequest(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{} {
	price := GetArg(optionalArgs, 0, nil)
	_ = price
	params := GetArg(optionalArgs, 1, map[string]interface{}{})
	_ = params
	var market interface{} = this.Market(symbol)
	// required param, cannot be used twice
	var clientOrderId interface{} = this.SafeString2(params, "clientOid", "clientOrderId", this.Uuid())
	params = this.Omit(params, []interface{}{"clientOid", "clientOrderId"})
	var request interface{} = map[string]interface{}{
		"clientOid": clientOrderId,
		"side":      side,
		"symbol":    GetValue(market, "id"),
		"type":      typeVar,
	}
	var quoteAmount interface{} = this.SafeNumber2(params, "cost", "funds")
	var amountString interface{} = nil
	var costString interface{} = nil
	var marginMode interface{} = nil
	marginModeparamsVariable := this.HandleMarginModeAndParams("createOrder", params)
	marginMode = GetValue(marginModeparamsVariable, 0)
	params = GetValue(marginModeparamsVariable, 1)
	if IsTrue(IsEqual(typeVar, "market")) {
		if IsTrue(!IsEqual(quoteAmount, nil)) {
			params = this.Omit(params, []interface{}{"cost", "funds"})
			// kucoin uses base precision even for quote values
			costString = this.MarketOrderAmountToPrecision(symbol, quoteAmount)
			AddElementToObject(request, "funds", costString)
		} else {
			amountString = this.AmountToPrecision(symbol, amount)
			AddElementToObject(request, "size", this.AmountToPrecision(symbol, amount))
		}
	} else {
		amountString = this.AmountToPrecision(symbol, amount)
		AddElementToObject(request, "size", amountString)
		AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
	}
	var tradeType interface{} = this.SafeString(params, "tradeType") // keep it for backward compatibility
	triggerPricestopLossPricetakeProfitPriceVariable := this.HandleTriggerPrices(params)
	triggerPrice := GetValue(triggerPricestopLossPricetakeProfitPriceVariable, 0)
	stopLossPrice := GetValue(triggerPricestopLossPricetakeProfitPriceVariable, 1)
	takeProfitPrice := GetValue(triggerPricestopLossPricetakeProfitPriceVariable, 2)
	var isTriggerOrder interface{} = (IsTrue(IsTrue(triggerPrice) || IsTrue(stopLossPrice)) || IsTrue(takeProfitPrice))
	var isMarginOrder interface{} = IsTrue(IsEqual(tradeType, "MARGIN_TRADE")) || IsTrue(!IsEqual(marginMode, nil))
	params = this.Omit(params, []interface{}{"stopLossPrice", "takeProfitPrice", "triggerPrice", "stopPrice"})
	if IsTrue(isTriggerOrder) {
		if IsTrue(triggerPrice) {
			AddElementToObject(request, "stopPrice", this.PriceToPrecision(symbol, triggerPrice))
		} else if IsTrue(IsTrue(stopLossPrice) || IsTrue(takeProfitPrice)) {
			if IsTrue(stopLossPrice) {
				AddElementToObject(request, "stop", Ternary(IsTrue((IsEqual(side, "buy"))), "entry", "loss"))
				AddElementToObject(request, "stopPrice", this.PriceToPrecision(symbol, stopLossPrice))
			} else {
				AddElementToObject(request, "stop", Ternary(IsTrue((IsEqual(side, "buy"))), "loss", "entry"))
				AddElementToObject(request, "stopPrice", this.PriceToPrecision(symbol, takeProfitPrice))
			}
		}
		if IsTrue(IsEqual(marginMode, "isolated")) {
			panic(BadRequest(Add(this.Id, " createOrder does not support isolated margin for stop orders")))
		} else if IsTrue(IsEqual(marginMode, "cross")) {
			AddElementToObject(request, "tradeType", GetValue(GetValue(this.Options, "marginModes"), marginMode))
		}
	} else if IsTrue(isMarginOrder) {
		if IsTrue(IsEqual(marginMode, "isolated")) {
			AddElementToObject(request, "marginModel", "isolated")
		}
	}
	var postOnly interface{} = nil
	postOnlyparamsVariable := this.HandlePostOnly(IsEqual(typeVar, "market"), false, params)
	postOnly = GetValue(postOnlyparamsVariable, 0)
	params = GetValue(postOnlyparamsVariable, 1)
	if IsTrue(postOnly) {
		AddElementToObject(request, "postOnly", true)
	}
	return this.Extend(request, params)
}

/**
 * @method
 * @name kucoin#editOrder
 * @description edit an order, kucoin currently only supports the modification of HF orders
 * @see https://docs.kucoin.com/spot-hf/#modify-order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type not used
 * @param {string} side not used
 * @param {float} amount how much of the currency you want to trade in units of the base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.clientOrderId] client order id, defaults to id if not passed
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *kucoin) EditOrder(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		amount := GetArg(optionalArgs, 0, nil)
		_ = amount
		price := GetArg(optionalArgs, 1, nil)
		_ = price
		params := GetArg(optionalArgs, 2, map[string]interface{}{})
		_ = params

		retRes25348 := (<-this.LoadMarkets())
		PanicOnError(retRes25348)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		var clientOrderId interface{} = this.SafeString2(params, "clientOid", "clientOrderId")
		if IsTrue(!IsEqual(clientOrderId, nil)) {
			AddElementToObject(request, "clientOid", clientOrderId)
		} else {
			AddElementToObject(request, "orderId", id)
		}
		if IsTrue(!IsEqual(amount, nil)) {
			AddElementToObject(request, "newSize", this.AmountToPrecision(symbol, amount))
		}
		if IsTrue(!IsEqual(price, nil)) {
			AddElementToObject(request, "newPrice", this.PriceToPrecision(symbol, price))
		}

		response := (<-this.PrivatePostHfOrdersAlter(this.Extend(request, params)))
		PanicOnError(response)
		//
		// {
		//     "code":"200000",
		//     "data":{
		//        "newOrderId":"6478d7a6c883280001e92d8b"
		//     }
		// }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})

		ch <- this.ParseOrder(data, market)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name kucoin#cancelOrder
 * @description cancels an open order
 * @see https://docs.kucoin.com/spot#cancel-an-order
 * @see https://docs.kucoin.com/spot#cancel-an-order-2
 * @see https://docs.kucoin.com/spot#cancel-single-order-by-clientoid
 * @see https://docs.kucoin.com/spot#cancel-single-order-by-clientoid-2
 * @see https://docs.kucoin.com/spot-hf/#cancel-orders-by-orderid
 * @see https://docs.kucoin.com/spot-hf/#cancel-order-by-clientoid
 * @see https://www.kucoin.com/docs/rest/spot-trading/spot-hf-trade-pro-account/sync-cancel-hf-order-by-orderid
 * @see https://www.kucoin.com/docs/rest/spot-trading/spot-hf-trade-pro-account/sync-cancel-hf-order-by-clientoid
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {bool} [params.trigger] True if cancelling a stop order
 * @param {bool} [params.hf] false, // true for hf order
 * @param {bool} [params.sync] false, // true to use the hf sync call
 * @returns Response from the exchange
 */
func (this *kucoin) CancelOrder(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes25858 := (<-this.LoadMarkets())
		PanicOnError(retRes25858)
		var request interface{} = map[string]interface{}{}
		var clientOrderId interface{} = this.SafeString2(params, "clientOid", "clientOrderId")
		var trigger interface{} = this.SafeBool2(params, "stop", "trigger", false)
		var hf interface{} = nil
		hfparamsVariable := this.HandleHfAndParams(params)
		hf = GetValue(hfparamsVariable, 0)
		params = GetValue(hfparamsVariable, 1)
		var useSync interface{} = false
		useSyncparamsVariable := this.HandleOptionAndParams(params, "cancelOrder", "sync", false)
		useSync = GetValue(useSyncparamsVariable, 0)
		params = GetValue(useSyncparamsVariable, 1)
		if IsTrue(IsTrue(hf) || IsTrue(useSync)) {
			if IsTrue(IsEqual(symbol, nil)) {
				panic(ArgumentsRequired(Add(this.Id, " cancelOrder() requires a symbol parameter for hf orders")))
			}
			var market interface{} = this.Market(symbol)
			AddElementToObject(request, "symbol", GetValue(market, "id"))
		}
		var response interface{} = nil
		params = this.Omit(params, []interface{}{"clientOid", "clientOrderId", "stop", "trigger"})
		if IsTrue(!IsEqual(clientOrderId, nil)) {
			AddElementToObject(request, "clientOid", clientOrderId)
			if IsTrue(trigger) {

				response = (<-this.PrivateDeleteStopOrderCancelOrderByClientOid(this.Extend(request, params)))
				PanicOnError(response)
			} else if IsTrue(useSync) {

				response = (<-this.PrivateDeleteHfOrdersSyncClientOrderClientOid(this.Extend(request, params)))
				PanicOnError(response)
			} else if IsTrue(hf) {

				response = (<-this.PrivateDeleteHfOrdersClientOrderClientOid(this.Extend(request, params)))
				PanicOnError(response)
			} else {

				response = (<-this.PrivateDeleteOrderClientOrderClientOid(this.Extend(request, params)))
				PanicOnError(response)
			}
			response = this.SafeDict(response, "data")

			ch <- this.ParseOrder(response)
			return nil
		} else {
			AddElementToObject(request, "orderId", id)
			if IsTrue(trigger) {

				response = (<-this.PrivateDeleteStopOrderOrderId(this.Extend(request, params)))
				PanicOnError(response)
			} else if IsTrue(useSync) {

				response = (<-this.PrivateDeleteHfOrdersSyncOrderId(this.Extend(request, params)))
				PanicOnError(response)
			} else if IsTrue(hf) {

				response = (<-this.PrivateDeleteHfOrdersOrderId(this.Extend(request, params)))
				PanicOnError(response)
				//
				//    {
				//        "code": "200000",
				//        "data": {
				//          "orderId": "630625dbd9180300014c8d52"
				//        }
				//    }
				//
				response = this.SafeDict(response, "data")

				ch <- this.ParseOrder(response)
				return nil
			} else {

				response = (<-this.PrivateDeleteOrdersOrderId(this.Extend(request, params)))
				PanicOnError(response)
			}
			var data interface{} = this.SafeDict(response, "data")
			var orderIds interface{} = this.SafeList(data, "cancelledOrderIds", []interface{}{})
			var orderId interface{} = this.SafeString(orderIds, 0)

			ch <- this.SafeOrder(map[string]interface{}{
				"info": data,
				"id":   orderId,
			})
			return nil
		}

	}()
	return ch
}

/**
 * @method
 * @name kucoin#cancelAllOrders
 * @description cancel all open orders
 * @see https://docs.kucoin.com/spot#cancel-all-orders
 * @see https://docs.kucoin.com/spot#cancel-orders
 * @see https://docs.kucoin.com/spot-hf/#cancel-all-hf-orders-by-symbol
 * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {bool} [params.trigger] *invalid for isolated margin* true if cancelling all stop orders
 * @param {string} [params.marginMode] 'cross' or 'isolated'
 * @param {string} [params.orderIds] *stop orders only* Comma seperated order IDs
 * @param {bool} [params.hf] false, // true for hf order
 * @returns Response from the exchange
 */
func (this *kucoin) CancelAllOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes27018 := (<-this.LoadMarkets())
		PanicOnError(retRes27018)
		var request interface{} = map[string]interface{}{}
		var trigger interface{} = this.SafeBool2(params, "trigger", "stop", false)
		var hf interface{} = nil
		hfparamsVariable := this.HandleHfAndParams(params)
		hf = GetValue(hfparamsVariable, 0)
		params = GetValue(hfparamsVariable, 1)
		params = this.Omit(params, "stop")
		marginModequeryVariable := this.HandleMarginModeAndParams("cancelAllOrders", params)
		marginMode := GetValue(marginModequeryVariable, 0)
		query := GetValue(marginModequeryVariable, 1)
		if IsTrue(!IsEqual(symbol, nil)) {
			AddElementToObject(request, "symbol", this.MarketId(symbol))
		}
		if IsTrue(!IsEqual(marginMode, nil)) {
			AddElementToObject(request, "tradeType", GetValue(GetValue(this.Options, "marginModes"), marginMode))
			if IsTrue(IsTrue(IsEqual(marginMode, "isolated")) && IsTrue(trigger)) {
				panic(BadRequest(Add(this.Id, " cancelAllOrders does not support isolated margin for stop orders")))
			}
		}
		var response interface{} = nil
		if IsTrue(trigger) {

			response = (<-this.PrivateDeleteStopOrderCancel(this.Extend(request, query)))
			PanicOnError(response)
		} else if IsTrue(hf) {
			if IsTrue(IsEqual(symbol, nil)) {

				response = (<-this.PrivateDeleteHfOrdersCancelAll(this.Extend(request, query)))
				PanicOnError(response)
			} else {

				response = (<-this.PrivateDeleteHfOrders(this.Extend(request, query)))
				PanicOnError(response)
			}
		} else {

			response = (<-this.PrivateDeleteOrders(this.Extend(request, query)))
			PanicOnError(response)
		}

		ch <- []interface{}{this.SafeOrder(map[string]interface{}{
			"info": response,
		})}
		return nil

	}()
	return ch
}

/**
 * @method
 * @name kucoin#fetchOrdersByStatus
 * @description fetch a list of orders
 * @see https://docs.kucoin.com/spot#list-orders
 * @see https://docs.kucoin.com/spot#list-stop-orders
 * @see https://docs.kucoin.com/spot-hf/#obtain-list-of-active-hf-orders
 * @see https://docs.kucoin.com/spot-hf/#obtain-list-of-filled-hf-orders
 * @param {string} status *not used for stop orders* 'open' or 'closed'
 * @param {string} symbol unified market symbol
 * @param {int} [since] timestamp in ms of the earliest order
 * @param {int} [limit] max number of orders to return
 * @param {object} [params] exchange specific params
 * @param {int} [params.until] end time in ms
 * @param {string} [params.side] buy or sell
 * @param {string} [params.type] limit, market, limit_stop or market_stop
 * @param {string} [params.tradeType] TRADE for spot trading, MARGIN_TRADE for Margin Trading
 * @param {int} [params.currentPage] *trigger orders only* current page
 * @param {string} [params.orderIds] *trigger orders only* comma seperated order ID list
 * @param {bool} [params.trigger] True if fetching a trigger order
 * @param {bool} [params.hf] false, // true for hf order
 * @returns An [array of order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *kucoin) FetchOrdersByStatus(status interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes27568 := (<-this.LoadMarkets())
		PanicOnError(retRes27568)
		var lowercaseStatus interface{} = ToLower(status)
		var until interface{} = this.SafeInteger(params, "until")
		var trigger interface{} = this.SafeBool2(params, "stop", "trigger", false)
		var hf interface{} = nil
		hfparamsVariable := this.HandleHfAndParams(params)
		hf = GetValue(hfparamsVariable, 0)
		params = GetValue(hfparamsVariable, 1)
		if IsTrue(IsTrue(hf) && IsTrue((IsEqual(symbol, nil)))) {
			panic(ArgumentsRequired(Add(this.Id, " fetchOrdersByStatus() requires a symbol parameter for hf orders")))
		}
		params = this.Omit(params, []interface{}{"stop", "trigger", "till", "until"})
		marginModequeryVariable := this.HandleMarginModeAndParams("fetchOrdersByStatus", params)
		marginMode := GetValue(marginModequeryVariable, 0)
		query := GetValue(marginModequeryVariable, 1)
		if IsTrue(IsEqual(lowercaseStatus, "open")) {
			lowercaseStatus = "active"
		} else if IsTrue(IsEqual(lowercaseStatus, "closed")) {
			lowercaseStatus = "done"
		}
		var request interface{} = map[string]interface{}{
			"status": lowercaseStatus,
		}
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			AddElementToObject(request, "symbol", GetValue(market, "id"))
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startAt", since)
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "pageSize", limit)
		}
		if IsTrue(until) {
			AddElementToObject(request, "endAt", until)
		}
		AddElementToObject(request, "tradeType", this.SafeString(GetValue(this.Options, "marginModes"), marginMode, "TRADE"))
		var response interface{} = nil
		if IsTrue(trigger) {

			response = (<-this.PrivateGetStopOrder(this.Extend(request, query)))
			PanicOnError(response)
		} else if IsTrue(hf) {
			if IsTrue(IsEqual(lowercaseStatus, "active")) {

				response = (<-this.PrivateGetHfOrdersActive(this.Extend(request, query)))
				PanicOnError(response)
			} else if IsTrue(IsEqual(lowercaseStatus, "done")) {

				response = (<-this.PrivateGetHfOrdersDone(this.Extend(request, query)))
				PanicOnError(response)
			}
		} else {

			response = (<-this.PrivateGetOrders(this.Extend(request, query)))
			PanicOnError(response)
		}
		//
		//     {
		//         "code": "200000",
		//         "data": {
		//             "currentPage": 1,
		//             "pageSize": 1,
		//             "totalNum": 153408,
		//             "totalPage": 153408,
		//             "items": [
		//                 {
		//                     "id": "5c35c02703aa673ceec2a168",   //orderid
		//                     "symbol": "BTC-USDT",   //symbol
		//                     "opType": "DEAL",      // operation type,deal is pending order,cancel is cancel order
		//                     "type": "limit",       // order type,e.g. limit,markrt,stop_limit.
		//                     "side": "buy",         // transaction direction,include buy and sell
		//                     "price": "10",         // order price
		//                     "size": "2",           // order quantity
		//                     "funds": "0",          // order funds
		//                     "dealFunds": "0.166",  // deal funds
		//                     "dealSize": "2",       // deal quantity
		//                     "fee": "0",            // fee
		//                     "feeCurrency": "USDT", // charge fee currency
		//                     "stp": "",             // self trade prevention,include CN,CO,DC,CB
		//                     "stop": "",            // stop type
		//                     "stopTriggered": false,  // stop order is triggered
		//                     "stopPrice": "0",      // stop price
		//                     "timeInForce": "GTC",  // time InForce,include GTC,GTT,IOC,FOK
		//                     "postOnly": false,     // postOnly
		//                     "hidden": false,       // hidden order
		//                     "iceberg": false,      // iceberg order
		//                     "visibleSize": "0",    // display quantity for iceberg order
		//                     "cancelAfter": 0,      // cancel orders timerequires timeInForce to be GTT
		//                     "channel": "IOS",      // order source
		//                     "clientOid": "",       // user-entered order unique mark
		//                     "remark": "",          // remark
		//                     "tags": "",            // tag order source
		//                     "isActive": false,     // status before unfilled or uncancelled
		//                     "cancelExist": false,   // order cancellation transaction record
		//                     "createdAt": 1547026471000  // time
		//                 },
		//             ]
		//         }
		//    }
		var listData interface{} = this.SafeList(response, "data")
		if IsTrue(!IsEqual(listData, nil)) {

			ch <- this.ParseOrders(listData, market, since, limit)
			return nil
		}
		var responseData interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		var orders interface{} = this.SafeList(responseData, "items", []interface{}{})

		ch <- this.ParseOrders(orders, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name kucoin#fetchClosedOrders
 * @description fetches information on multiple closed orders made by the user
 * @see https://docs.kucoin.com/spot#list-orders
 * @see https://docs.kucoin.com/spot#list-stop-orders
 * @see https://docs.kucoin.com/spot-hf/#obtain-list-of-active-hf-orders
 * @see https://docs.kucoin.com/spot-hf/#obtain-list-of-filled-hf-orders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] end time in ms
 * @param {string} [params.side] buy or sell
 * @param {string} [params.type] limit, market, limit_stop or market_stop
 * @param {string} [params.tradeType] TRADE for spot trading, MARGIN_TRADE for Margin Trading
 * @param {bool} [params.trigger] True if fetching a trigger order
 * @param {bool} [params.hf] false, // true for hf order
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *kucoin) FetchClosedOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes28768 := (<-this.LoadMarkets())
		PanicOnError(retRes28768)
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchClosedOrders", "paginate")
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {

			retRes288019 := (<-this.FetchPaginatedCallDynamic("fetchClosedOrders", symbol, since, limit, params))
			PanicOnError(retRes288019)
			ch <- retRes288019
			return nil
		}

		retRes288215 := (<-this.FetchOrdersByStatus("done", symbol, since, limit, params))
		PanicOnError(retRes288215)
		ch <- retRes288215
		return nil

	}()
	return ch
}

/**
 * @method
 * @name kucoin#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://docs.kucoin.com/spot#list-orders
 * @see https://docs.kucoin.com/spot#list-stop-orders
 * @see https://docs.kucoin.com/spot-hf/#obtain-list-of-active-hf-orders
 * @see https://docs.kucoin.com/spot-hf/#obtain-list-of-filled-hf-orders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] end time in ms
 * @param {bool} [params.trigger] true if fetching trigger orders
 * @param {string} [params.side] buy or sell
 * @param {string} [params.type] limit, market, limit_stop or market_stop
 * @param {string} [params.tradeType] TRADE for spot trading, MARGIN_TRADE for Margin Trading
 * @param {int} [params.currentPage] *trigger orders only* current page
 * @param {string} [params.orderIds] *trigger orders only* comma seperated order ID list
 * @param {bool} [params.hf] false, // true for hf order
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *kucoin) FetchOpenOrders(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes29098 := (<-this.LoadMarkets())
		PanicOnError(retRes29098)
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchOpenOrders", "paginate")
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {

			retRes291319 := (<-this.FetchPaginatedCallDynamic("fetchOpenOrders", symbol, since, limit, params))
			PanicOnError(retRes291319)
			ch <- retRes291319
			return nil
		}

		retRes291515 := (<-this.FetchOrdersByStatus("active", symbol, since, limit, params))
		PanicOnError(retRes291515)
		ch <- retRes291515
		return nil

	}()
	return ch
}

/**
 * @method
 * @name kucoin#fetchOrder
 * @description fetch an order
 * @see https://docs.kucoin.com/spot#get-an-order
 * @see https://docs.kucoin.com/spot#get-single-active-order-by-clientoid
 * @see https://docs.kucoin.com/spot#get-single-order-info
 * @see https://docs.kucoin.com/spot#get-single-order-by-clientoid
 * @see https://docs.kucoin.com/spot-hf/#details-of-a-single-hf-order
 * @see https://docs.kucoin.com/spot-hf/#obtain-details-of-a-single-hf-order-using-clientoid
 * @param {string} id Order id
 * @param {string} symbol not sent to exchange except for trigger orders with clientOid, but used internally by CCXT to filter
 * @param {object} [params] exchange specific parameters
 * @param {bool} [params.trigger] true if fetching a trigger order
 * @param {bool} [params.hf] false, // true for hf order
 * @param {bool} [params.clientOid] unique order id created by users to identify their orders
 * @returns An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func (this *kucoin) FetchOrder(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes29378 := (<-this.LoadMarkets())
		PanicOnError(retRes29378)
		var request interface{} = map[string]interface{}{}
		var clientOrderId interface{} = this.SafeString2(params, "clientOid", "clientOrderId")
		var trigger interface{} = this.SafeBool2(params, "stop", "trigger", false)
		var hf interface{} = nil
		hfparamsVariable := this.HandleHfAndParams(params)
		hf = GetValue(hfparamsVariable, 0)
		params = GetValue(hfparamsVariable, 1)
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
		}
		if IsTrue(hf) {
			if IsTrue(IsEqual(symbol, nil)) {
				panic(ArgumentsRequired(Add(this.Id, " fetchOrder() requires a symbol parameter for hf orders")))
			}
			AddElementToObject(request, "symbol", GetValue(market, "id"))
		}
		params = this.Omit(params, []interface{}{"stop", "clientOid", "clientOrderId", "trigger"})
		var response interface{} = nil
		if IsTrue(!IsEqual(clientOrderId, nil)) {
			AddElementToObject(request, "clientOid", clientOrderId)
			if IsTrue(trigger) {
				if IsTrue(!IsEqual(symbol, nil)) {
					AddElementToObject(request, "symbol", GetValue(market, "id"))
				}

				response = (<-this.PrivateGetStopOrderQueryOrderByClientOid(this.Extend(request, params)))
				PanicOnError(response)
			} else if IsTrue(hf) {

				response = (<-this.PrivateGetHfOrdersClientOrderClientOid(this.Extend(request, params)))
				PanicOnError(response)
			} else {

				response = (<-this.PrivateGetOrderClientOrderClientOid(this.Extend(request, params)))
				PanicOnError(response)
			}
		} else {
			// a special case for undefined ids
			// otherwise a wrong endpoint for all orders will be triggered
			// https://github.com/ccxt/ccxt/issues/7234
			if IsTrue(IsEqual(id, nil)) {
				panic(InvalidOrder(Add(this.Id, " fetchOrder() requires an order id")))
			}
			AddElementToObject(request, "orderId", id)
			if IsTrue(trigger) {

				response = (<-this.PrivateGetStopOrderOrderId(this.Extend(request, params)))
				PanicOnError(response)
			} else if IsTrue(hf) {

				response = (<-this.PrivateGetHfOrdersOrderId(this.Extend(request, params)))
				PanicOnError(response)
			} else {

				response = (<-this.PrivateGetOrdersOrderId(this.Extend(request, params)))
				PanicOnError(response)
			}
		}
		var responseData interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		if IsTrue(IsArray(responseData)) {
			responseData = this.SafeValue(responseData, 0)
		}

		ch <- this.ParseOrder(responseData, market)
		return nil

	}()
	return ch
}
func (this *kucoin) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{} {
	//
	// createOrder
	//
	//    {
	//        "orderId": "63c97e47d686c5000159a656"
	//    }
	//
	// cancelOrder
	//
	//    {
	//        "cancelledOrderIds": [ "63c97e47d686c5000159a656" ]
	//    }
	//
	// fetchOpenOrders, fetchClosedOrders
	//
	//    {
	//        "id": "63c97ce8d686c500015793bb",
	//        "symbol": "USDC-USDT",
	//        "opType": "DEAL",
	//        "type": "limit",
	//        "side": "sell",
	//        "price": "1.05",
	//        "size": "1",
	//        "funds": "0",
	//        "dealFunds": "0",
	//        "dealSize": "0",
	//        "fee": "0",
	//        "feeCurrency": "USDT",
	//        "stp": "",
	//        "stop": "",
	//        "stopTriggered": false,
	//        "stopPrice": "0",
	//        "timeInForce": "GTC",
	//        "postOnly": false,
	//        "hidden": false,
	//        "iceberg": false,
	//        "visibleSize": "0",
	//        "cancelAfter": 0,
	//        "channel": "API",
	//        "clientOid": "d602d73f-5424-4751-bef0-8debce8f0a82",
	//        "remark": null,
	//        "tags": "partner:ccxt",
	//        "isActive": true,
	//        "cancelExist": false,
	//        "createdAt": 1674149096927,
	//        "tradeType": "TRADE"
	//    }
	//
	// stop orders (fetchOpenOrders, fetchClosedOrders)
	//
	//    {
	//        "id": "vs9f6ou9e864rgq8000t4qnm",
	//        "symbol": "USDC-USDT",
	//        "userId": "613a896885d8660006151f01",
	//        "status": "NEW",
	//        "type": "market",
	//        "side": "sell",
	//        "price": null,
	//        "size": "1.00000000000000000000",
	//        "funds": null,
	//        "stp": null,
	//        "timeInForce": "GTC",
	//        "cancelAfter": -1,
	//        "postOnly": false,
	//        "hidden": false,
	//        "iceberg": false,
	//        "visibleSize": null,
	//        "channel": "API",
	//        "clientOid": "5d3fd727-6456-438d-9550-40d9d85eee0b",
	//        "remark": null,
	//        "tags": "partner:ccxt",
	//        "relatedNo": null,
	//        "orderTime": 1674146316994000028,
	//        "domainId": "kucoin",
	//        "tradeSource": "USER",
	//        "tradeType": "MARGIN_TRADE",
	//        "feeCurrency": "USDT",
	//        "takerFeeRate": "0.00100000000000000000",
	//        "makerFeeRate": "0.00100000000000000000",
	//        "createdAt": 1674146316994,
	//        "stop": "loss",
	//        "stopTriggerTime": null,
	//        "stopPrice": "0.97000000000000000000"
	//    }
	// hf order
	//    {
	//        "id":"6478cf1439bdfc0001528a1d",
	//        "symbol":"LTC-USDT",
	//        "opType":"DEAL",
	//        "type":"limit",
	//        "side":"buy",
	//        "price":"50",
	//        "size":"0.1",
	//        "funds":"5",
	//        "dealSize":"0",
	//        "dealFunds":"0",
	//        "fee":"0",
	//        "feeCurrency":"USDT",
	//        "stp":null,
	//        "timeInForce":"GTC",
	//        "postOnly":false,
	//        "hidden":false,
	//        "iceberg":false,
	//        "visibleSize":"0",
	//        "cancelAfter":0,
	//        "channel":"API",
	//        "clientOid":"d4d2016b-8e3a-445c-aa5d-dc6df5d1678d",
	//        "remark":null,
	//        "tags":"partner:ccxt",
	//        "cancelExist":false,
	//        "createdAt":1685638932074,
	//        "lastUpdatedAt":1685639013735,
	//        "tradeType":"TRADE",
	//        "inOrderBook":true,
	//        "cancelledSize":"0",
	//        "cancelledFunds":"0",
	//        "remainSize":"0.1",
	//        "remainFunds":"5",
	//        "active":true
	//    }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(order, "symbol")
	var timestamp interface{} = this.SafeInteger(order, "createdAt")
	var feeCurrencyId interface{} = this.SafeString(order, "feeCurrency")
	var cancelExist interface{} = this.SafeBool(order, "cancelExist", false)
	var responseStop interface{} = this.SafeString(order, "stop")
	var trigger interface{} = !IsEqual(responseStop, nil)
	var stopTriggered interface{} = this.SafeBool(order, "stopTriggered", false)
	var isActive interface{} = this.SafeBool2(order, "isActive", "active")
	var responseStatus interface{} = this.SafeString(order, "status")
	var status interface{} = nil
	if IsTrue(!IsEqual(isActive, nil)) {
		if IsTrue(IsEqual(isActive, true)) {
			status = "open"
		} else {
			status = "closed"
		}
	}
	if IsTrue(trigger) {
		if IsTrue(IsEqual(responseStatus, "NEW")) {
			status = "open"
		} else if IsTrue(!IsTrue(isActive) && !IsTrue(stopTriggered)) {
			status = "cancelled"
		}
	}
	if IsTrue(cancelExist) {
		status = "canceled"
	}
	if IsTrue(IsEqual(responseStatus, "fail")) {
		status = "rejected"
	}
	return this.SafeOrder(map[string]interface{}{
		"info":          order,
		"id":            this.SafeStringN(order, []interface{}{"id", "orderId", "newOrderId", "cancelledOrderId"}),
		"clientOrderId": this.SafeString(order, "clientOid"),
		"symbol":        this.SafeSymbol(marketId, market, "-"),
		"type":          this.SafeString(order, "type"),
		"timeInForce":   this.SafeString(order, "timeInForce"),
		"postOnly":      this.SafeBool(order, "postOnly"),
		"side":          this.SafeString(order, "side"),
		"amount":        this.SafeString(order, "size"),
		"price":         this.SafeString(order, "price"),
		"triggerPrice":  this.SafeNumber(order, "stopPrice"),
		"cost":          this.SafeString(order, "dealFunds"),
		"filled":        this.SafeString(order, "dealSize"),
		"remaining":     nil,
		"timestamp":     timestamp,
		"datetime":      this.Iso8601(timestamp),
		"fee": map[string]interface{}{
			"currency": this.SafeCurrencyCode(feeCurrencyId),
			"cost":     this.SafeNumber(order, "fee"),
		},
		"status":             status,
		"lastTradeTimestamp": nil,
		"average":            this.SafeString(order, "avgDealPrice"),
		"trades":             nil,
	}, market)
}

/**
 * @method
 * @name kucoin#fetchOrderTrades
 * @description fetch all the trades made from a single order
 * @see https://docs.kucoin.com/#list-fills
 * @see https://docs.kucoin.com/spot-hf/#transaction-details
 * @param {string} id order id
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func (this *kucoin) FetchOrderTrades(id interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params
		var request interface{} = map[string]interface{}{
			"orderId": id,
		}

		retRes318715 := (<-this.FetchMyTrades(symbol, since, limit, this.Extend(request, params)))
		PanicOnError(retRes318715)
		ch <- retRes318715
		return nil

	}()
	return ch
}

/**
 * @method
 * @name kucoin#fetchMyTrades
 * @see https://docs.kucoin.com/#list-fills
 * @see https://docs.kucoin.com/spot-hf/#transaction-details
 * @description fetch all trades made by the user
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch entries for
 * @param {bool} [params.hf] false, // true for hf order
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func (this *kucoin) FetchMyTrades(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes32068 := (<-this.LoadMarkets())
		PanicOnError(retRes32068)
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchMyTrades", "paginate")
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {

			retRes321019 := (<-this.FetchPaginatedCallDynamic("fetchMyTrades", symbol, since, limit, params))
			PanicOnError(retRes321019)
			ch <- retRes321019
			return nil
		}
		var request interface{} = map[string]interface{}{}
		var hf interface{} = nil
		hfparamsVariable := this.HandleHfAndParams(params)
		hf = GetValue(hfparamsVariable, 0)
		params = GetValue(hfparamsVariable, 1)
		if IsTrue(IsTrue(hf) && IsTrue(IsEqual(symbol, nil))) {
			panic(ArgumentsRequired(Add(this.Id, " fetchMyTrades() requires a symbol parameter for hf orders")))
		}
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
			AddElementToObject(request, "symbol", GetValue(market, "id"))
		}
		var method interface{} = GetValue(this.Options, "fetchMyTradesMethod")
		var parseResponseData interface{} = false
		var response interface{} = nil
		requestparamsVariable := this.HandleUntilOption("endAt", request, params)
		request = GetValue(requestparamsVariable, 0)
		params = GetValue(requestparamsVariable, 1)
		if IsTrue(hf) {
			// does not return trades earlier than 2019-02-18T00:00:00Z
			if IsTrue(!IsEqual(limit, nil)) {
				AddElementToObject(request, "limit", limit)
			}
			if IsTrue(!IsEqual(since, nil)) {
				// only returns trades up to one week after the since param
				AddElementToObject(request, "startAt", since)
			}

			response = (<-this.PrivateGetHfFills(this.Extend(request, params)))
			PanicOnError(response)
		} else if IsTrue(IsEqual(method, "private_get_fills")) {
			// does not return trades earlier than 2019-02-18T00:00:00Z
			if IsTrue(!IsEqual(since, nil)) {
				// only returns trades up to one week after the since param
				AddElementToObject(request, "startAt", since)
			}

			response = (<-this.PrivateGetFills(this.Extend(request, params)))
			PanicOnError(response)
		} else if IsTrue(IsEqual(method, "private_get_limit_fills")) {
			// does not return trades earlier than 2019-02-18T00:00:00Z
			// takes no params
			// only returns first 1000 trades (not only "in the last 24 hours" as stated in the docs)
			parseResponseData = true

			response = (<-this.PrivateGetLimitFills(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			panic(ExchangeError(Add(this.Id, " fetchMyTradesMethod() invalid method")))
		}
		//
		//     {
		//         "currentPage": 1,
		//         "pageSize": 50,
		//         "totalNum": 1,
		//         "totalPage": 1,
		//         "items": [
		//             {
		//                 "symbol":"BTC-USDT",       // symbol
		//                 "tradeId":"5c35c02709e4f67d5266954e",        // trade id
		//                 "orderId":"5c35c02703aa673ceec2a168",        // order id
		//                 "counterOrderId":"5c1ab46003aa676e487fa8e3", // counter order id
		//                 "side":"buy",              // transaction direction,include buy and sell
		//                 "liquidity":"taker",       // include taker and maker
		//                 "forceTaker":true,         // forced to become taker
		//                 "price":"0.083",           // order price
		//                 "size":"0.8424304",        // order quantity
		//                 "funds":"0.0699217232",    // order funds
		//                 "fee":"0",                 // fee
		//                 "feeRate":"0",             // fee rate
		//                 "feeCurrency":"USDT",      // charge fee currency
		//                 "stop":"",                 // stop type
		//                 "type":"limit",            // order type, e.g. limit, market, stop_limit.
		//                 "createdAt":1547026472000  // time
		//             },
		//             //------------------------------------------------------
		//             // v1 (historical) trade response structure
		//             {
		//                 "symbol": "SNOV-ETH",
		//                 "dealPrice": "0.0000246",
		//                 "dealValue": "0.018942",
		//                 "amount": "770",
		//                 "fee": "0.00001137",
		//                 "side": "sell",
		//                 "createdAt": 1540080199
		//                 "id":"5c4d389e4c8c60413f78e2e5",
		//             }
		//         ]
		//     }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		var trades interface{} = nil
		if IsTrue(parseResponseData) {
			trades = data
		} else {
			trades = this.SafeList(data, "items", []interface{}{})
		}

		ch <- this.ParseTrades(trades, market, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name kucoin#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://www.kucoin.com/docs/rest/spot-trading/market-data/get-trade-histories
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func (this *kucoin) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		since := GetArg(optionalArgs, 0, nil)
		_ = since
		limit := GetArg(optionalArgs, 1, nil)
		_ = limit
		params := GetArg(optionalArgs, 2, map[string]interface{}{})
		_ = params

		retRes33158 := (<-this.LoadMarkets())
		PanicOnError(retRes33158)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbol": GetValue(market, "id"),
		}
		// pagination is not supported on the exchange side anymore
		// if (since !== undefined) {
		//     request['startAt'] = Math.floor (since / 1000);
		// }
		// if (limit !== undefined) {
		//     request['pageSize'] = limit;
		// }

		response := (<-this.PublicGetMarketHistories(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "200000",
		//         "data": [
		//             {
		//                 "sequence": "1548764654235",
		//                 "side": "sell",
		//                 "size":"0.6841354",
		//                 "price":"0.03202",
		//                 "time":1548848575203567174
		//             }
		//         ]
		//     }
		//
		var trades interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseTrades(trades, market, since, limit)
		return nil

	}()
	return ch
}
func (this *kucoin) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{} {
	//
	// fetchTrades (public)
	//
	//     {
	//         "sequence": "1548764654235",
	//         "side": "sell",
	//         "size":"0.6841354",
	//         "price":"0.03202",
	//         "time":1548848575203567174
	//     }
	//
	//     {
	//         "sequence": "1568787654360",
	//         "symbol": "BTC-USDT",
	//         "side": "buy",
	//         "size": "0.00536577",
	//         "price": "9345",
	//         "takerOrderId": "5e356c4a9f1a790008f8d921",
	//         "time": "1580559434436443257",
	//         "type": "match",
	//         "makerOrderId": "5e356bffedf0010008fa5d7f",
	//         "tradeId": "5e356c4aeefabd62c62a1ece"
	//     }
	//
	// fetchMyTrades (private) v2
	//
	//     {
	//         "symbol":"BTC-USDT",
	//         "tradeId":"5c35c02709e4f67d5266954e",
	//         "orderId":"5c35c02703aa673ceec2a168",
	//         "counterOrderId":"5c1ab46003aa676e487fa8e3",
	//         "side":"buy",
	//         "liquidity":"taker",
	//         "forceTaker":true,
	//         "price":"0.083",
	//         "size":"0.8424304",
	//         "funds":"0.0699217232",
	//         "fee":"0",
	//         "feeRate":"0",
	//         "feeCurrency":"USDT",
	//         "stop":"",
	//         "type":"limit",
	//         "createdAt":1547026472000
	//     }
	//
	// fetchMyTrades v2 alternative format since 2019-05-21 https://github.com/ccxt/ccxt/pull/5162
	//
	//     {
	//         "symbol": "OPEN-BTC",
	//         "forceTaker":  false,
	//         "orderId": "5ce36420054b4663b1fff2c9",
	//         "fee": "0",
	//         "feeCurrency": "",
	//         "type": "",
	//         "feeRate": "0",
	//         "createdAt": 1558417615000,
	//         "size": "12.8206",
	//         "stop": "",
	//         "price": "0",
	//         "funds": "0",
	//         "tradeId": "5ce390cf6e0db23b861c6e80"
	//     }
	//
	// fetchMyTrades (private) v1 (historical)
	//
	//     {
	//         "symbol": "SNOV-ETH",
	//         "dealPrice": "0.0000246",
	//         "dealValue": "0.018942",
	//         "amount": "770",
	//         "fee": "0.00001137",
	//         "side": "sell",
	//         "createdAt": 1540080199
	//         "id":"5c4d389e4c8c60413f78e2e5",
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(trade, "symbol")
	market = this.SafeMarket(marketId, market, "-")
	var id interface{} = this.SafeString2(trade, "tradeId", "id")
	var orderId interface{} = this.SafeString(trade, "orderId")
	var takerOrMaker interface{} = this.SafeString(trade, "liquidity")
	var timestamp interface{} = this.SafeInteger(trade, "time")
	if IsTrue(!IsEqual(timestamp, nil)) {
		timestamp = this.ParseToInt(Divide(timestamp, 1000000))
	} else {
		timestamp = this.SafeInteger(trade, "createdAt")
		// if it's a historical v1 trade, the exchange returns timestamp in seconds
		if IsTrue(IsTrue((InOp(trade, "dealValue"))) && IsTrue((!IsEqual(timestamp, nil)))) {
			timestamp = Multiply(timestamp, 1000)
		}
	}
	var priceString interface{} = this.SafeString2(trade, "price", "dealPrice")
	var amountString interface{} = this.SafeString2(trade, "size", "amount")
	var side interface{} = this.SafeString(trade, "side")
	var fee interface{} = nil
	var feeCostString interface{} = this.SafeString(trade, "fee")
	if IsTrue(!IsEqual(feeCostString, nil)) {
		var feeCurrencyId interface{} = this.SafeString(trade, "feeCurrency")
		var feeCurrency interface{} = this.SafeCurrencyCode(feeCurrencyId)
		if IsTrue(IsEqual(feeCurrency, nil)) {
			feeCurrency = Ternary(IsTrue((IsEqual(side, "sell"))), GetValue(market, "quote"), GetValue(market, "base"))
		}
		fee = map[string]interface{}{
			"cost":     feeCostString,
			"currency": feeCurrency,
			"rate":     this.SafeString(trade, "feeRate"),
		}
	}
	var typeVar interface{} = this.SafeString(trade, "type")
	if IsTrue(IsEqual(typeVar, "match")) {
		typeVar = nil
	}
	var costString interface{} = this.SafeString2(trade, "funds", "dealValue")
	return this.SafeTrade(map[string]interface{}{
		"info":         trade,
		"id":           id,
		"order":        orderId,
		"timestamp":    timestamp,
		"datetime":     this.Iso8601(timestamp),
		"symbol":       GetValue(market, "symbol"),
		"type":         typeVar,
		"takerOrMaker": takerOrMaker,
		"side":         side,
		"price":        priceString,
		"amount":       amountString,
		"cost":         costString,
		"fee":          fee,
	}, market)
}

/**
 * @method
 * @name kucoin#fetchTradingFee
 * @description fetch the trading fees for a market
 * @see https://www.kucoin.com/docs/rest/funding/trade-fee/trading-pair-actual-fee-spot-margin-trade_hf
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func (this *kucoin) FetchTradingFee(symbol interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes34878 := (<-this.LoadMarkets())
		PanicOnError(retRes34878)
		var market interface{} = this.Market(symbol)
		var request interface{} = map[string]interface{}{
			"symbols": GetValue(market, "id"),
		}

		response := (<-this.PrivateGetTradeFees(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "200000",
		//         "data": [
		//           {
		//             "symbol": "BTC-USDT",
		//             "takerFeeRate": "0.001",
		//             "makerFeeRate": "0.001"
		//           }
		//         ]
		//     }
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})
		var first interface{} = this.SafeDict(data, 0)
		var marketId interface{} = this.SafeString(first, "symbol")

		ch <- map[string]interface{}{
			"info":       response,
			"symbol":     this.SafeSymbol(marketId, market),
			"maker":      this.SafeNumber(first, "makerFeeRate"),
			"taker":      this.SafeNumber(first, "takerFeeRate"),
			"percentage": true,
			"tierBased":  true,
		}
		return nil

	}()
	return ch
}

/**
 * @method
 * @name kucoin#withdraw
 * @description make a withdrawal
 * @see https://www.kucoin.com/docs/rest/funding/withdrawals/apply-withdraw-v3-
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func (this *kucoin) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		tag := GetArg(optionalArgs, 0, nil)
		_ = tag
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params
		tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params)
		tag = GetValue(tagparamsVariable, 0)
		params = GetValue(tagparamsVariable, 1)

		retRes35328 := (<-this.LoadMarkets())
		PanicOnError(retRes35328)
		this.CheckAddress(address)
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"currency":     GetValue(currency, "id"),
			"toAddress":    address,
			"withdrawType": "ADDRESS",
		}
		if IsTrue(!IsEqual(tag, nil)) {
			AddElementToObject(request, "memo", tag)
		}
		var networkCode interface{} = nil
		networkCodeparamsVariable := this.HandleNetworkCodeAndParams(params)
		networkCode = GetValue(networkCodeparamsVariable, 0)
		params = GetValue(networkCodeparamsVariable, 1)
		if IsTrue(!IsEqual(networkCode, nil)) {
			AddElementToObject(request, "chain", ToLower(this.NetworkCodeToId(networkCode)))
		}
		AddElementToObject(request, "amount", ParseFloat(this.CurrencyToPrecision(code, amount, networkCode)))
		var includeFee interface{} = nil
		includeFeeparamsVariable := this.HandleOptionAndParams(params, "withdraw", "includeFee", false)
		includeFee = GetValue(includeFeeparamsVariable, 0)
		params = GetValue(includeFeeparamsVariable, 1)
		if IsTrue(includeFee) {
			AddElementToObject(request, "feeDeductType", "INTERNAL")
		}

		response := (<-this.PrivatePostWithdrawals(this.Extend(request, params)))
		PanicOnError(response)
		//
		// the id is inside "data"
		//
		//     {
		//         "code":  200000,
		//         "data": {
		//             "withdrawalId":  "5bffb63303aa675e8bbe18f9"
		//         }
		//     }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})

		ch <- this.ParseTransaction(data, currency)
		return nil

	}()
	return ch
}
func (this *kucoin) ParseTransactionStatus(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"SUCCESS":           "ok",
		"PROCESSING":        "pending",
		"WALLET_PROCESSING": "pending",
		"FAILURE":           "failed",
	}
	return this.SafeString(statuses, status, status)
}
func (this *kucoin) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{} {
	//
	// fetchDeposits
	//
	//     {
	//         "address": "0x5f047b29041bcfdbf0e4478cdfa753a336ba6989",
	//         "memo": "5c247c8a03aa677cea2a251d",
	//         "amount": 1,
	//         "fee": 0.0001,
	//         "currency": "KCS",
	//         "chain": "",
	//         "isInner": false,
	//         "walletTxId": "5bbb57386d99522d9f954c5a@test004",
	//         "status": "SUCCESS",
	//         "createdAt": 1544178843000,
	//         "updatedAt": 1544178891000
	//         "remark":"foobar"
	//     }
	//
	// fetchWithdrawals
	//
	//     {
	//         "id": "5c2dc64e03aa675aa263f1ac",
	//         "address": "0x5bedb060b8eb8d823e2414d82acce78d38be7fe9",
	//         "memo": "",
	//         "currency": "ETH",
	//         "chain": "",
	//         "amount": 1.0000000,
	//         "fee": 0.0100000,
	//         "walletTxId": "3e2414d82acce78d38be7fe9",
	//         "isInner": false,
	//         "status": "FAILURE",
	//         "createdAt": 1546503758000,
	//         "updatedAt": 1546504603000
	//         "remark":"foobar"
	//     }
	//
	// withdraw
	//
	//     {
	//         "withdrawalId":  "5bffb63303aa675e8bbe18f9"
	//     }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var currencyId interface{} = this.SafeString(transaction, "currency")
	var code interface{} = this.SafeCurrencyCode(currencyId, currency)
	var address interface{} = this.SafeString(transaction, "address")
	var amount interface{} = this.SafeString(transaction, "amount")
	var txid interface{} = this.SafeString(transaction, "walletTxId")
	if IsTrue(!IsEqual(txid, nil)) {
		var txidParts interface{} = Split(txid, "@")
		var numTxidParts interface{} = GetArrayLength(txidParts)
		if IsTrue(IsGreaterThan(numTxidParts, 1)) {
			if IsTrue(IsEqual(address, nil)) {
				if IsTrue(IsGreaterThan(GetLength(GetValue(txidParts, 1)), 1)) {
					address = GetValue(txidParts, 1)
				}
			}
		}
		txid = GetValue(txidParts, 0)
	}
	var typeVar interface{} = Ternary(IsTrue((IsEqual(txid, nil))), "withdrawal", "deposit")
	var rawStatus interface{} = this.SafeString(transaction, "status")
	var fee interface{} = nil
	var feeCost interface{} = this.SafeString(transaction, "fee")
	if IsTrue(!IsEqual(feeCost, nil)) {
		var rate interface{} = nil
		if IsTrue(!IsEqual(amount, nil)) {
			rate = Precise.StringDiv(feeCost, amount)
		}
		fee = map[string]interface{}{
			"cost":     this.ParseNumber(feeCost),
			"rate":     this.ParseNumber(rate),
			"currency": code,
		}
	}
	var timestamp interface{} = this.SafeInteger2(transaction, "createdAt", "createAt")
	var updated interface{} = this.SafeInteger(transaction, "updatedAt")
	var isV1 interface{} = !IsTrue((InOp(transaction, "createdAt")))
	// if it's a v1 structure
	if IsTrue(isV1) {
		typeVar = Ternary(IsTrue((InOp(transaction, "address"))), "withdrawal", "deposit")
		if IsTrue(!IsEqual(timestamp, nil)) {
			timestamp = Multiply(timestamp, 1000)
		}
		if IsTrue(!IsEqual(updated, nil)) {
			updated = Multiply(updated, 1000)
		}
	}
	var internal interface{} = this.SafeBool(transaction, "isInner")
	var tag interface{} = this.SafeString(transaction, "memo")
	return map[string]interface{}{
		"info":        transaction,
		"id":          this.SafeString2(transaction, "id", "withdrawalId"),
		"timestamp":   timestamp,
		"datetime":    this.Iso8601(timestamp),
		"network":     this.NetworkIdToCode(this.SafeString(transaction, "chain")),
		"address":     address,
		"addressTo":   address,
		"addressFrom": nil,
		"tag":         tag,
		"tagTo":       tag,
		"tagFrom":     nil,
		"currency":    code,
		"amount":      this.ParseNumber(amount),
		"txid":        txid,
		"type":        typeVar,
		"status":      this.ParseTransactionStatus(rawStatus),
		"comment":     this.SafeString(transaction, "remark"),
		"internal":    internal,
		"fee":         fee,
		"updated":     updated,
	}
}

/**
 * @method
 * @name kucoin#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://www.kucoin.com/docs/rest/funding/deposit/get-deposit-list
 * @see https://www.kucoin.com/docs/rest/funding/deposit/get-v1-historical-deposits-list
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch entries for
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func (this *kucoin) FetchDeposits(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes37128 := (<-this.LoadMarkets())
		PanicOnError(retRes37128)
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchDeposits", "paginate")
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {

			retRes371619 := (<-this.FetchPaginatedCallDynamic("fetchDeposits", code, since, limit, params))
			PanicOnError(retRes371619)
			ch <- retRes371619
			return nil
		}
		var request interface{} = map[string]interface{}{}
		var currency interface{} = nil
		if IsTrue(!IsEqual(code, nil)) {
			currency = this.Currency(code)
			AddElementToObject(request, "currency", GetValue(currency, "id"))
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "pageSize", limit)
		}
		requestparamsVariable := this.HandleUntilOption("endAt", request, params)
		request = GetValue(requestparamsVariable, 0)
		params = GetValue(requestparamsVariable, 1)
		var response interface{} = nil
		if IsTrue(IsTrue(!IsEqual(since, nil)) && IsTrue(IsLessThan(since, 1550448000000))) {
			// if since is earlier than 2019-02-18T00:00:00Z
			AddElementToObject(request, "startAt", this.ParseToInt(Divide(since, 1000)))

			response = (<-this.PrivateGetHistDeposits(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			if IsTrue(!IsEqual(since, nil)) {
				AddElementToObject(request, "startAt", since)
			}

			response = (<-this.PrivateGetDeposits(this.Extend(request, params)))
			PanicOnError(response)
		}
		//
		//     {
		//         "code": "200000",
		//         "data": {
		//             "currentPage": 1,
		//             "pageSize": 5,
		//             "totalNum": 2,
		//             "totalPage": 1,
		//             "items": [
		//                 //--------------------------------------------------
		//                 // version 2 deposit response structure
		//                 {
		//                     "address": "0x5f047b29041bcfdbf0e4478cdfa753a336ba6989",
		//                     "memo": "5c247c8a03aa677cea2a251d",
		//                     "amount": 1,
		//                     "fee": 0.0001,
		//                     "currency": "KCS",
		//                     "isInner": false,
		//                     "walletTxId": "5bbb57386d99522d9f954c5a@test004",
		//                     "status": "SUCCESS",
		//                     "createdAt": 1544178843000,
		//                     "updatedAt": 1544178891000
		//                     "remark":"foobar"
		//                 },
		//                 //--------------------------------------------------
		//                 // version 1 (historical) deposit response structure
		//                 {
		//                     "currency": "BTC",
		//                     "createAt": 1528536998,
		//                     "amount": "0.03266638",
		//                     "walletTxId": "55c643bc2c68d6f17266383ac1be9e454038864b929ae7cee0bc408cc5c869e8@12ffGWmMMD1zA1WbFm7Ho3JZ1w6NYXjpFk@234",
		//                     "isInner": false,
		//                     "status": "SUCCESS",
		//                 }
		//             ]
		//         }
		//     }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		var items interface{} = this.SafeList(data, "items", []interface{}{})

		ch <- this.ParseTransactions(items, currency, since, limit, map[string]interface{}{
			"type": "deposit",
		})
		return nil

	}()
	return ch
}

/**
 * @method
 * @name kucoin#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @see https://www.kucoin.com/docs/rest/funding/withdrawals/get-withdrawals-list
 * @see https://www.kucoin.com/docs/rest/funding/withdrawals/get-v1-historical-withdrawals-list
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawals structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch entries for
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func (this *kucoin) FetchWithdrawals(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes37978 := (<-this.LoadMarkets())
		PanicOnError(retRes37978)
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchWithdrawals", "paginate")
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		if IsTrue(paginate) {

			retRes380119 := (<-this.FetchPaginatedCallDynamic("fetchWithdrawals", code, since, limit, params))
			PanicOnError(retRes380119)
			ch <- retRes380119
			return nil
		}
		var request interface{} = map[string]interface{}{}
		var currency interface{} = nil
		if IsTrue(!IsEqual(code, nil)) {
			currency = this.Currency(code)
			AddElementToObject(request, "currency", GetValue(currency, "id"))
		}
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "pageSize", limit)
		}
		requestparamsVariable := this.HandleUntilOption("endAt", request, params)
		request = GetValue(requestparamsVariable, 0)
		params = GetValue(requestparamsVariable, 1)
		var response interface{} = nil
		if IsTrue(IsTrue(!IsEqual(since, nil)) && IsTrue(IsLessThan(since, 1550448000000))) {
			// if since is earlier than 2019-02-18T00:00:00Z
			AddElementToObject(request, "startAt", this.ParseToInt(Divide(since, 1000)))

			response = (<-this.PrivateGetHistWithdrawals(this.Extend(request, params)))
			PanicOnError(response)
		} else {
			if IsTrue(!IsEqual(since, nil)) {
				AddElementToObject(request, "startAt", since)
			}

			response = (<-this.PrivateGetWithdrawals(this.Extend(request, params)))
			PanicOnError(response)
		}
		//
		//     {
		//         "code": "200000",
		//         "data": {
		//             "currentPage": 1,
		//             "pageSize": 5,
		//             "totalNum": 2,
		//             "totalPage": 1,
		//             "items": [
		//                 //--------------------------------------------------
		//                 // version 2 withdrawal response structure
		//                 {
		//                     "id": "5c2dc64e03aa675aa263f1ac",
		//                     "address": "0x5bedb060b8eb8d823e2414d82acce78d38be7fe9",
		//                     "memo": "",
		//                     "currency": "ETH",
		//                     "amount": 1.0000000,
		//                     "fee": 0.0100000,
		//                     "walletTxId": "3e2414d82acce78d38be7fe9",
		//                     "isInner": false,
		//                     "status": "FAILURE",
		//                     "createdAt": 1546503758000,
		//                     "updatedAt": 1546504603000
		//                 },
		//                 //--------------------------------------------------
		//                 // version 1 (historical) withdrawal response structure
		//                 {
		//                     "currency": "BTC",
		//                     "createAt": 1526723468,
		//                     "amount": "0.534",
		//                     "address": "33xW37ZSW4tQvg443Pc7NLCAs167Yc2XUV",
		//                     "walletTxId": "aeacea864c020acf58e51606169240e96774838dcd4f7ce48acf38e3651323f4",
		//                     "isInner": false,
		//                     "status": "SUCCESS"
		//                 }
		//             ]
		//         }
		//     }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		var items interface{} = this.SafeList(data, "items", []interface{}{})

		ch <- this.ParseTransactions(items, currency, since, limit, map[string]interface{}{
			"type": "withdrawal",
		})
		return nil

	}()
	return ch
}
func (this *kucoin) ParseBalanceHelper(entry interface{}) interface{} {
	var account interface{} = this.Account()
	AddElementToObject(account, "used", this.SafeString2(entry, "holdBalance", "hold"))
	AddElementToObject(account, "free", this.SafeString2(entry, "availableBalance", "available"))
	AddElementToObject(account, "total", this.SafeString2(entry, "totalBalance", "total"))
	var debt interface{} = this.SafeString(entry, "liability")
	var interest interface{} = this.SafeString(entry, "interest")
	AddElementToObject(account, "debt", Precise.StringAdd(debt, interest))
	return account
}

/**
 * @method
 * @name kucoin#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://www.kucoin.com/docs/rest/account/basic-info/get-account-list-spot-margin-trade_hf
 * @see https://www.kucoin.com/docs/rest/funding/funding-overview/get-account-detail-margin
 * @see https://www.kucoin.com/docs/rest/funding/funding-overview/get-account-detail-isolated-margin
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {object} [params.marginMode] 'cross' or 'isolated', margin type for fetching margin balance
 * @param {object} [params.type] extra parameters specific to the exchange API endpoint
 * @param {object} [params.hf] *default if false* if true, the result includes the balance of the high frequency account
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func (this *kucoin) FetchBalance(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes38938 := (<-this.LoadMarkets())
		PanicOnError(retRes38938)
		var code interface{} = this.SafeString(params, "code")
		var currency interface{} = nil
		if IsTrue(!IsEqual(code, nil)) {
			currency = this.Currency(code)
		}
		var defaultType interface{} = this.SafeString2(this.Options, "fetchBalance", "defaultType", "spot")
		var requestedType interface{} = this.SafeString(params, "type", defaultType)
		var accountsByType interface{} = this.SafeDict(this.Options, "accountsByType")
		var typeVar interface{} = this.SafeString(accountsByType, requestedType, requestedType)
		params = this.Omit(params, "type")
		var hf interface{} = nil
		hfparamsVariable := this.HandleHfAndParams(params)
		hf = GetValue(hfparamsVariable, 0)
		params = GetValue(hfparamsVariable, 1)
		if IsTrue(IsTrue(hf) && IsTrue((!IsEqual(typeVar, "main")))) {
			typeVar = "trade_hf"
		}
		marginModequeryVariable := this.HandleMarginModeAndParams("fetchBalance", params)
		marginMode := GetValue(marginModequeryVariable, 0)
		query := GetValue(marginModequeryVariable, 1)
		var response interface{} = nil
		var request interface{} = map[string]interface{}{}
		var isolated interface{} = IsTrue((IsEqual(marginMode, "isolated"))) || IsTrue((IsEqual(typeVar, "isolated")))
		var cross interface{} = IsTrue((IsEqual(marginMode, "cross"))) || IsTrue((IsEqual(typeVar, "margin")))
		if IsTrue(isolated) {
			if IsTrue(!IsEqual(currency, nil)) {
				AddElementToObject(request, "balanceCurrency", GetValue(currency, "id"))
			}

			response = (<-this.PrivateGetIsolatedAccounts(this.Extend(request, query)))
			PanicOnError(response)
		} else if IsTrue(cross) {

			response = (<-this.PrivateGetMarginAccount(this.Extend(request, query)))
			PanicOnError(response)
		} else {
			if IsTrue(!IsEqual(currency, nil)) {
				AddElementToObject(request, "currency", GetValue(currency, "id"))
			}
			AddElementToObject(request, "type", typeVar)

			response = (<-this.PrivateGetAccounts(this.Extend(request, query)))
			PanicOnError(response)
		}
		//
		// Spot
		//
		//    {
		//        "code": "200000",
		//        "data": [
		//            {
		//                "balance": "0.00009788",
		//                "available": "0.00009788",
		//                "holds": "0",
		//                "currency": "BTC",
		//                "id": "5c6a4fd399a1d81c4f9cc4d0",
		//                "type": "trade",
		//            },
		//        ]
		//    }
		//
		// Cross
		//
		//     {
		//         "code": "200000",
		//         "data": {
		//             "debtRatio": "0",
		//             "accounts": [
		//                 {
		//                     "currency": "USDT",
		//                     "totalBalance": "5",
		//                     "availableBalance": "5",
		//                     "holdBalance": "0",
		//                     "liability": "0",
		//                     "maxBorrowSize": "20"
		//                 },
		//             ]
		//         }
		//     }
		//
		// Isolated
		//
		//    {
		//        "code": "200000",
		//        "data": {
		//            "totalAssetOfQuoteCurrency": "0",
		//            "totalLiabilityOfQuoteCurrency": "0",
		//            "timestamp": 1712085661155,
		//            "assets": [
		//                {
		//                    "symbol": "MANA-USDT",
		//                    "status": "EFFECTIVE",
		//                    "debtRatio": "0",
		//                    "baseAsset": {
		//                        "currency": "MANA",
		//                        "borrowEnabled": true,
		//                        "transferInEnabled": true,
		//                        "total": "0",
		//                        "hold": "0",
		//                        "available": "0",
		//                        "liability": "0",
		//                        "interest": "0",
		//                        "maxBorrowSize": "0"
		//                    },
		//                    "quoteAsset": {
		//                        "currency": "USDT",
		//                        "borrowEnabled": true,
		//                        "transferInEnabled": true,
		//                        "total": "0",
		//                        "hold": "0",
		//                        "available": "0",
		//                        "liability": "0",
		//                        "interest": "0",
		//                        "maxBorrowSize": "0"
		//                    }
		//                },
		//                ...
		//            ]
		//        }
		//    }
		//
		var data interface{} = nil
		var result interface{} = map[string]interface{}{
			"info":      response,
			"timestamp": nil,
			"datetime":  nil,
		}
		if IsTrue(isolated) {
			data = this.SafeDict(response, "data", map[string]interface{}{})
			var assets interface{} = this.SafeValue(data, "assets", data)
			for i := 0; IsLessThan(i, GetArrayLength(assets)); i++ {
				var entry interface{} = GetValue(assets, i)
				var marketId interface{} = this.SafeString(entry, "symbol")
				var symbol interface{} = this.SafeSymbol(marketId, nil, "_")
				var base interface{} = this.SafeDict(entry, "baseAsset", map[string]interface{}{})
				var quote interface{} = this.SafeDict(entry, "quoteAsset", map[string]interface{}{})
				var baseCode interface{} = this.SafeCurrencyCode(this.SafeString(base, "currency"))
				var quoteCode interface{} = this.SafeCurrencyCode(this.SafeString(quote, "currency"))
				var subResult interface{} = map[string]interface{}{}
				AddElementToObject(subResult, baseCode, this.ParseBalanceHelper(base))
				AddElementToObject(subResult, quoteCode, this.ParseBalanceHelper(quote))
				AddElementToObject(result, symbol, this.SafeBalance(subResult))
			}
		} else if IsTrue(cross) {
			data = this.SafeDict(response, "data", map[string]interface{}{})
			var accounts interface{} = this.SafeList(data, "accounts", []interface{}{})
			for i := 0; IsLessThan(i, GetArrayLength(accounts)); i++ {
				var balance interface{} = GetValue(accounts, i)
				var currencyId interface{} = this.SafeString(balance, "currency")
				var codeInner interface{} = this.SafeCurrencyCode(currencyId)
				AddElementToObject(result, codeInner, this.ParseBalanceHelper(balance))
			}
		} else {
			data = this.SafeList(response, "data", []interface{}{})
			for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
				var balance interface{} = GetValue(data, i)
				var balanceType interface{} = this.SafeString(balance, "type")
				if IsTrue(IsEqual(balanceType, typeVar)) {
					var currencyId interface{} = this.SafeString(balance, "currency")
					var codeInner2 interface{} = this.SafeCurrencyCode(currencyId)
					var account interface{} = this.Account()
					AddElementToObject(account, "total", this.SafeString(balance, "balance"))
					AddElementToObject(account, "free", this.SafeString(balance, "available"))
					AddElementToObject(account, "used", this.SafeString(balance, "holds"))
					AddElementToObject(result, codeInner2, account)
				}
			}
		}
		var returnType interface{} = result
		if !IsTrue(isolated) {
			returnType = this.SafeBalance(result)
		}

		ch <- returnType
		return nil

	}()
	return ch
}

/**
 * @method
 * @name kucoin#transfer
 * @description transfer currency internally between wallets on the same account
 * @see https://www.kucoin.com/docs/rest/funding/transfer/inner-transfer
 * @see https://docs.kucoin.com/futures/#transfer-funds-to-kucoin-main-account-2
 * @see https://docs.kucoin.com/spot-hf/#internal-funds-transfers-in-high-frequency-trading-accounts
 * @param {string} code unified currency code
 * @param {float} amount amount to transfer
 * @param {string} fromAccount account to transfer from
 * @param {string} toAccount account to transfer to
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func (this *kucoin) Transfer(code interface{}, amount interface{}, fromAccount interface{}, toAccount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes40748 := (<-this.LoadMarkets())
		PanicOnError(retRes40748)
		var currency interface{} = this.Currency(code)
		var requestedAmount interface{} = this.CurrencyToPrecision(code, amount)
		var fromId interface{} = this.ConvertTypeToAccount(fromAccount)
		var toId interface{} = this.ConvertTypeToAccount(toAccount)
		var fromIsolated interface{} = this.InArray(fromId, this.Ids)
		var toIsolated interface{} = this.InArray(toId, this.Ids)
		if IsTrue(IsEqual(fromId, "contract")) {
			if IsTrue(!IsEqual(toId, "main")) {
				panic(ExchangeError(Add(this.Id, " transfer() only supports transferring from futures account to main account")))
			}
			var request interface{} = map[string]interface{}{
				"currency": GetValue(currency, "id"),
				"amount":   requestedAmount,
			}
			if !IsTrue((InOp(params, "bizNo"))) {
				// it doesn't like more than 24 characters
				AddElementToObject(request, "bizNo", this.Uuid22())
			}

			response := (<-this.FuturesPrivatePostTransferOut(this.Extend(request, params)))
			PanicOnError(response)
			//
			//     {
			//         "code": "200000",
			//         "data": {
			//             "applyId": "605a87217dff1500063d485d",
			//             "bizNo": "bcd6e5e1291f4905af84dc",
			//             "payAccountType": "CONTRACT",
			//             "payTag": "DEFAULT",
			//             "remark": '',
			//             "recAccountType": "MAIN",
			//             "recTag": "DEFAULT",
			//             "recRemark": '',
			//             "recSystem": "KUCOIN",
			//             "status": "PROCESSING",
			//             "currency": "XBT",
			//             "amount": "0.00001",
			//             "fee": "0",
			//             "sn": "573688685663948",
			//             "reason": '',
			//             "createdAt": 1616545569000,
			//             "updatedAt": 1616545569000
			//         }
			//     }
			//
			var data interface{} = this.SafeDict(response, "data")

			ch <- this.ParseTransfer(data, currency)
			return nil
		} else {
			var request interface{} = map[string]interface{}{
				"currency": GetValue(currency, "id"),
				"amount":   requestedAmount,
			}
			if IsTrue(IsTrue(fromIsolated) || IsTrue(toIsolated)) {
				if IsTrue(this.InArray(fromId, this.Ids)) {
					AddElementToObject(request, "fromTag", fromId)
					fromId = "isolated"
				}
				if IsTrue(this.InArray(toId, this.Ids)) {
					AddElementToObject(request, "toTag", toId)
					toId = "isolated"
				}
			}
			AddElementToObject(request, "from", fromId)
			AddElementToObject(request, "to", toId)
			if !IsTrue((InOp(params, "clientOid"))) {
				AddElementToObject(request, "clientOid", this.Uuid())
			}

			response := (<-this.PrivatePostAccountsInnerTransfer(this.Extend(request, params)))
			PanicOnError(response)
			//
			//     {
			//         "code": "200000",
			//         "data": {
			//              "orderId": "605a6211e657f00006ad0ad6"
			//         }
			//     }
			//
			var data interface{} = this.SafeDict(response, "data")

			ch <- this.ParseTransfer(data, currency)
			return nil
		}

	}()
	return ch
}
func (this *kucoin) ParseTransfer(transfer interface{}, optionalArgs ...interface{}) interface{} {
	//
	// transfer (spot)
	//
	//    {
	//        "orderId": "605a6211e657f00006ad0ad6"
	//    }
	//
	//    {
	//        "code": "200000",
	//        "msg": "Failed to transfer out. The amount exceeds the upper limit"
	//    }
	//
	// transfer (futures)
	//
	//     {
	//         "applyId": "605a87217dff1500063d485d",
	//         "bizNo": "bcd6e5e1291f4905af84dc",
	//         "payAccountType": "CONTRACT",
	//         "payTag": "DEFAULT",
	//         "remark": '',
	//         "recAccountType": "MAIN",
	//         "recTag": "DEFAULT",
	//         "recRemark": '',
	//         "recSystem": "KUCOIN",
	//         "status": "PROCESSING",
	//         "currency": "XBT",
	//         "amount": "0.00001",
	//         "fee": "0",
	//         "sn": "573688685663948",
	//         "reason": '',
	//         "createdAt": 1616545569000,
	//         "updatedAt": 1616545569000
	//     }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var timestamp interface{} = this.SafeInteger(transfer, "createdAt")
	var currencyId interface{} = this.SafeString(transfer, "currency")
	var rawStatus interface{} = this.SafeString(transfer, "status")
	var accountFromRaw interface{} = this.SafeStringLower(transfer, "payAccountType")
	var accountToRaw interface{} = this.SafeStringLower(transfer, "recAccountType")
	var accountsByType interface{} = this.SafeDict(this.Options, "accountsByType")
	var accountFrom interface{} = this.SafeString(accountsByType, accountFromRaw, accountFromRaw)
	var accountTo interface{} = this.SafeString(accountsByType, accountToRaw, accountToRaw)
	return map[string]interface{}{
		"id":          this.SafeString2(transfer, "applyId", "orderId"),
		"currency":    this.SafeCurrencyCode(currencyId, currency),
		"timestamp":   timestamp,
		"datetime":    this.Iso8601(timestamp),
		"amount":      this.SafeNumber(transfer, "amount"),
		"fromAccount": accountFrom,
		"toAccount":   accountTo,
		"status":      this.ParseTransferStatus(rawStatus),
		"info":        transfer,
	}
}
func (this *kucoin) ParseTransferStatus(status interface{}) interface{} {
	var statuses interface{} = map[string]interface{}{
		"PROCESSING": "pending",
	}
	return this.SafeString(statuses, status, status)
}
func (this *kucoin) ParseLedgerEntryType(typeVar interface{}) interface{} {
	var types interface{} = map[string]interface{}{
		"Assets Transferred in After Upgrading": "transfer",
		"Deposit":                               "transaction",
		"Withdrawal":                            "transaction",
		"Transfer":                              "transfer",
		"Trade_Exchange":                        "trade",
		"KuCoin Bonus":                          "bonus",
		"Referral Bonus":                        "referral",
		"Rewards":                               "bonus",
		"Airdrop/Fork":                          "airdrop",
		"Other rewards":                         "bonus",
		"Fee Rebate":                            "rebate",
		"Buy Crypto":                            "trade",
		"Sell Crypto":                           "sell",
		"Public Offering Purchase":              "trade",
		"Refunded Fees":                         "fee",
		"KCS Pay Fees":                          "fee",
		"Margin Trade":                          "trade",
		"Loans":                                 "Loans",
		"Instant Exchange":                      "trade",
		"Sub-account transfer":                  "transfer",
		"Liquidation Fees":                      "fee",
	}
	return this.SafeString(types, typeVar, typeVar)
}
func (this *kucoin) ParseLedgerEntry(item interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "id": "611a1e7c6a053300067a88d9", //unique key for each ledger entry
	//         "currency": "USDT", //Currency
	//         "amount": "10.00059547", //The total amount of assets (fees included) involved in assets changes such as transaction, withdrawal and bonus distribution.
	//         "fee": "0", //Deposit or withdrawal fee
	//         "balance": "0", //Total assets of a currency remaining funds after transaction
	//         "accountType": "MAIN", //Account Type
	//         "bizType": "Loans Repaid", //business type
	//         "direction": "in", //side, in or out
	//         "createdAt": 1629101692950, //Creation time
	//         "context": "{\"borrowerUserId\":\"601ad03e50dc810006d242ea\",\"loanRepayDetailNo\":\"611a1e7cc913d000066cf7ec\"}" //Business core parameters
	//     }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var id interface{} = this.SafeString(item, "id")
	var currencyId interface{} = this.SafeString(item, "currency")
	var code interface{} = this.SafeCurrencyCode(currencyId, currency)
	currency = this.SafeCurrency(currencyId, currency)
	var amount interface{} = this.SafeNumber(item, "amount")
	var balanceAfter interface{} = nil
	// const balanceAfter = this.safeNumber (item, 'balance'); only returns zero string
	var bizType interface{} = this.SafeString(item, "bizType")
	var typeVar interface{} = this.ParseLedgerEntryType(bizType)
	var direction interface{} = this.SafeString(item, "direction")
	var timestamp interface{} = this.SafeInteger(item, "createdAt")
	var datetime interface{} = this.Iso8601(timestamp)
	var account interface{} = this.SafeString(item, "accountType") // MAIN, TRADE, MARGIN, or CONTRACT
	var context interface{} = this.SafeString(item, "context")     // contains other information about the ledger entry
	//
	// withdrawal transaction
	//
	//     "{\"orderId\":\"617bb2d09e7b3b000196dac8\",\"txId\":\"0x79bb9855f86b351a45cab4dc69d78ca09586a94c45dde49475722b98f401b054\"}"
	//
	// deposit to MAIN, trade via MAIN
	//
	//     "{\"orderId\":\"617ab9949e7b3b0001948081\",\"txId\":\"0x7a06b16bbd6b03dbc3d96df5683b15229fc35e7184fd7179a5f3a310bd67d1fa@default@0\"}"
	//
	// sell trade
	//
	//     "{\"symbol\":\"ETH-USDT\",\"orderId\":\"617adcd1eb3fa20001dd29a1\",\"tradeId\":\"617adcd12e113d2b91222ff9\"}"
	//
	var referenceId interface{} = nil
	if IsTrue(IsTrue(!IsEqual(context, nil)) && IsTrue(!IsEqual(context, ""))) {

		{
			func(this *kucoin) (ret_ interface{}) {
				defer func() {
					if exc := recover(); exc != nil {
						if exc == "break" {
							return
						}
						ret_ = func(this *kucoin) interface{} {
							// catch block:
							referenceId = context
							return nil
						}(this)
					}
				}()
				// try block:
				var parsed interface{} = JsonParse(context)
				var orderId interface{} = this.SafeString(parsed, "orderId")
				var tradeId interface{} = this.SafeString(parsed, "tradeId")
				// transactions only have an orderId but for trades we wish to use tradeId
				if IsTrue(!IsEqual(tradeId, nil)) {
					referenceId = tradeId
				} else {
					referenceId = orderId
				}
				return nil
			}(this)

		}
	}
	var fee interface{} = nil
	var feeCost interface{} = this.SafeString(item, "fee")
	var feeCurrency interface{} = nil
	if IsTrue(!IsEqual(feeCost, "0")) {
		feeCurrency = code
		fee = map[string]interface{}{
			"cost":     this.ParseNumber(feeCost),
			"currency": feeCurrency,
		}
	}
	return this.SafeLedgerEntry(map[string]interface{}{
		"info":             item,
		"id":               id,
		"direction":        direction,
		"account":          account,
		"referenceId":      referenceId,
		"referenceAccount": account,
		"type":             typeVar,
		"currency":         code,
		"amount":           amount,
		"timestamp":        timestamp,
		"datetime":         datetime,
		"before":           nil,
		"after":            balanceAfter,
		"status":           nil,
		"fee":              fee,
	}, currency)
}

/**
 * @method
 * @name kucoin#fetchLedger
 * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
 * @see https://www.kucoin.com/docs/rest/account/basic-info/get-account-ledgers-spot-margin
 * @see https://www.kucoin.com/docs/rest/account/basic-info/get-account-ledgers-trade_hf
 * @see https://www.kucoin.com/docs/rest/account/basic-info/get-account-ledgers-margin_hf
 * @param {string} [code] unified currency code, default is undefined
 * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
 * @param {int} [limit] max number of ledger entries to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.hf] default false, when true will fetch ledger entries for the high frequency trading account
 * @param {int} [params.until] the latest time in ms to fetch entries for
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger}
 */
func (this *kucoin) FetchLedger(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes43638 := (<-this.LoadMarkets())
		PanicOnError(retRes43638)

		retRes43648 := (<-this.LoadAccounts())
		PanicOnError(retRes43648)
		var paginate interface{} = false
		paginateparamsVariable := this.HandleOptionAndParams(params, "fetchLedger", "paginate")
		paginate = GetValue(paginateparamsVariable, 0)
		params = GetValue(paginateparamsVariable, 1)
		var hf interface{} = nil
		hfparamsVariable := this.HandleHfAndParams(params)
		hf = GetValue(hfparamsVariable, 0)
		params = GetValue(hfparamsVariable, 1)
		if IsTrue(paginate) {

			retRes437019 := (<-this.FetchPaginatedCallDynamic("fetchLedger", code, since, limit, params))
			PanicOnError(retRes437019)
			ch <- retRes437019
			return nil
		}
		var request interface{} = map[string]interface{}{}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startAt", since)
		}
		// atm only single currency retrieval is supported
		var currency interface{} = nil
		if IsTrue(!IsEqual(code, nil)) {
			currency = this.Currency(code)
			AddElementToObject(request, "currency", GetValue(currency, "id"))
		}
		requestparamsVariable := this.HandleUntilOption("endAt", request, params)
		request = GetValue(requestparamsVariable, 0)
		params = GetValue(requestparamsVariable, 1)
		var marginMode interface{} = nil
		marginModeparamsVariable := this.HandleMarginModeAndParams("fetchLedger", params)
		marginMode = GetValue(marginModeparamsVariable, 0)
		params = GetValue(marginModeparamsVariable, 1)
		var response interface{} = nil
		if IsTrue(hf) {
			if IsTrue(!IsEqual(marginMode, nil)) {

				response = (<-this.PrivateGetHfMarginAccountLedgers(this.Extend(request, params)))
				PanicOnError(response)
			} else {

				response = (<-this.PrivateGetHfAccountsLedgers(this.Extend(request, params)))
				PanicOnError(response)
			}
		} else {

			response = (<-this.PrivateGetAccountsLedgers(this.Extend(request, params)))
			PanicOnError(response)
		}
		//
		//     {
		//         "code":"200000",
		//         "data":{
		//             "currentPage":1,
		//             "pageSize":50,
		//             "totalNum":1,
		//             "totalPage":1,
		//             "items":[
		//                 {
		//                     "id":"617cc528729f5f0001c03ceb",
		//                     "currency":"GAS",
		//                     "amount":"0.00000339",
		//                     "fee":"0",
		//                     "balance":"0",
		//                     "accountType":"MAIN",
		//                     "bizType":"Distribution",
		//                     "direction":"in",
		//                     "createdAt":1635566888183,
		//                     "context":"{\"orderId\":\"617cc47a1c47ed0001ce3606\",\"description\":\"Holding NEO,distribute GAS(2021/10/30)\"}"
		//                 }
		//                 {
		//                     "id": "611a1e7c6a053300067a88d9",//unique key
		//                     "currency": "USDT", //Currency
		//                     "amount": "10.00059547", //Change amount of the funds
		//                     "fee": "0", //Deposit or withdrawal fee
		//                     "balance": "0", //Total assets of a currency
		//                     "accountType": "MAIN", //Account Type
		//                     "bizType": "Loans Repaid", //business type
		//                     "direction": "in", //side, in or out
		//                     "createdAt": 1629101692950, //Creation time
		//                     "context": "{\"borrowerUserId\":\"601ad03e50dc810006d242ea\",\"loanRepayDetailNo\":\"611a1e7cc913d000066cf7ec\"}"
		//                 },
		//             ]
		//         }
		//     }
		//
		var dataList interface{} = this.SafeList(response, "data")
		if IsTrue(!IsEqual(dataList, nil)) {

			ch <- this.ParseLedger(dataList, currency, since, limit)
			return nil
		}
		var data interface{} = this.SafeDict(response, "data")
		var items interface{} = this.SafeList(data, "items", []interface{}{})

		ch <- this.ParseLedger(items, currency, since, limit)
		return nil

	}()
	return ch
}
func (this *kucoin) CalculateRateLimiterCost(api interface{}, method interface{}, path interface{}, params interface{}, optionalArgs ...interface{}) interface{} {
	config := GetArg(optionalArgs, 0, map[string]interface{}{})
	_ = config
	var versions interface{} = this.SafeDict(this.Options, "versions", map[string]interface{}{})
	var apiVersions interface{} = this.SafeDict(versions, api, map[string]interface{}{})
	var methodVersions interface{} = this.SafeDict(apiVersions, method, map[string]interface{}{})
	var defaultVersion interface{} = this.SafeString(methodVersions, path, GetValue(this.Options, "version"))
	var version interface{} = this.SafeString(params, "version", defaultVersion)
	if IsTrue(IsTrue(IsEqual(version, "v3")) && IsTrue((InOp(config, "v3")))) {
		return GetValue(config, "v3")
	} else if IsTrue(IsTrue(IsEqual(version, "v2")) && IsTrue((InOp(config, "v2")))) {
		return GetValue(config, "v2")
	} else if IsTrue(IsTrue(IsEqual(version, "v1")) && IsTrue((InOp(config, "v1")))) {
		return GetValue(config, "v1")
	}
	return this.SafeValue(config, "cost", 1)
}
func (this *kucoin) ParseBorrowRate(info interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "tradeId": "62db2dcaff219600012b56cd",
	//         "currency": "USDT",
	//         "size": "10",
	//         "dailyIntRate": "0.00003",
	//         "term": 7,
	//         "timestamp": 1658531274508488480
	//     },
	//
	//     {
	//         "createdAt": 1697783812257,
	//         "currency": "XMR",
	//         "interestAmount": "0.1",
	//         "dayRatio": "0.001"
	//     }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var timestampId interface{} = this.SafeString2(info, "createdAt", "timestamp")
	var timestamp interface{} = this.ParseToInt(Slice(timestampId, 0, 13))
	var currencyId interface{} = this.SafeString(info, "currency")
	return map[string]interface{}{
		"currency":  this.SafeCurrencyCode(currencyId, currency),
		"rate":      this.SafeNumber2(info, "dailyIntRate", "dayRatio"),
		"period":    86400000,
		"timestamp": timestamp,
		"datetime":  this.Iso8601(timestamp),
		"info":      info,
	}
}

/**
 * @method
 * @name kucoin#fetchBorrowInterest
 * @description fetch the interest owed by the user for borrowing currency for margin trading
 * @see https://docs.kucoin.com/#get-repay-record
 * @see https://docs.kucoin.com/#query-isolated-margin-account-info
 * @param {string} [code] unified currency code
 * @param {string} [symbol] unified market symbol, required for isolated margin
 * @param {int} [since] the earliest time in ms to fetch borrrow interest for
 * @param {int} [limit] the maximum number of structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] 'cross' or 'isolated' default is 'cross'
 * @returns {object[]} a list of [borrow interest structures]{@link https://docs.ccxt.com/#/?id=borrow-interest-structure}
 */
func (this *kucoin) FetchBorrowInterest(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		code := GetArg(optionalArgs, 0, nil)
		_ = code
		symbol := GetArg(optionalArgs, 1, nil)
		_ = symbol
		since := GetArg(optionalArgs, 2, nil)
		_ = since
		limit := GetArg(optionalArgs, 3, nil)
		_ = limit
		params := GetArg(optionalArgs, 4, map[string]interface{}{})
		_ = params

		retRes45098 := (<-this.LoadMarkets())
		PanicOnError(retRes45098)
		var marginMode interface{} = nil
		marginModeparamsVariable := this.HandleMarginModeAndParams("fetchBorrowInterest", params, "cross")
		marginMode = GetValue(marginModeparamsVariable, 0)
		params = GetValue(marginModeparamsVariable, 1)
		var request interface{} = map[string]interface{}{}
		var currency interface{} = nil
		if IsTrue(!IsEqual(code, nil)) {
			currency = this.Currency(code)
			if IsTrue(IsEqual(marginMode, "isolated")) {
				AddElementToObject(request, "balanceCurrency", GetValue(currency, "id"))
			} else {
				AddElementToObject(request, "quoteCurrency", GetValue(currency, "id"))
			}
		}
		var market interface{} = nil
		if IsTrue(!IsEqual(symbol, nil)) {
			market = this.Market(symbol)
		}
		var response interface{} = nil
		if IsTrue(IsEqual(marginMode, "isolated")) {

			response = (<-this.PrivateGetIsolatedAccounts(this.Extend(request, params)))
			PanicOnError(response)
		} else {

			response = (<-this.PrivateGetMarginAccounts(this.Extend(request, params)))
			PanicOnError(response)
		}
		//
		// Cross
		//
		//     {
		//         "code": "200000",
		//         "data": {
		//             "totalAssetOfQuoteCurrency": "0",
		//             "totalLiabilityOfQuoteCurrency": "0",
		//             "debtRatio": "0",
		//             "status": "EFFECTIVE",
		//             "accounts": [
		//                 {
		//                     "currency": "1INCH",
		//                     "total": "0",
		//                     "available": "0",
		//                     "hold": "0",
		//                     "liability": "0",
		//                     "maxBorrowSize": "0",
		//                     "borrowEnabled": true,
		//                     "transferInEnabled": true
		//                 }
		//             ]
		//         }
		//     }
		//
		// Isolated
		//
		//     {
		//         "code": "200000",
		//         "data": {
		//             "totalConversionBalance": "0.02138647",
		//             "liabilityConversionBalance": "0.01480001",
		//             "assets": [
		//                 {
		//                     "symbol": "MANA-USDT",
		//                     "debtRatio": "0",
		//                     "status": "BORROW",
		//                     "baseAsset": {
		//                         "currency": "MANA",
		//                         "borrowEnabled": true,
		//                         "repayEnabled": true,
		//                         "transferEnabled": true,
		//                         "borrowed": "0",
		//                         "totalAsset": "0",
		//                         "available": "0",
		//                         "hold": "0",
		//                         "maxBorrowSize": "1000"
		//                     },
		//                     "quoteAsset": {
		//                         "currency": "USDT",
		//                         "borrowEnabled": true,
		//                         "repayEnabled": true,
		//                         "transferEnabled": true,
		//                         "borrowed": "0",
		//                         "totalAsset": "0",
		//                         "available": "0",
		//                         "hold": "0",
		//                         "maxBorrowSize": "50000"
		//                     }
		//                 }
		//             ]
		//         }
		//     }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})
		var assets interface{} = Ternary(IsTrue((IsEqual(marginMode, "isolated"))), this.SafeList(data, "assets", []interface{}{}), this.SafeList(data, "accounts", []interface{}{}))
		var interest interface{} = this.ParseBorrowInterests(assets, market)
		var filteredByCurrency interface{} = this.FilterByCurrencySinceLimit(interest, code, since, limit)

		ch <- this.FilterBySymbolSinceLimit(filteredByCurrency, symbol, since, limit)
		return nil

	}()
	return ch
}
func (this *kucoin) ParseBorrowInterest(info interface{}, optionalArgs ...interface{}) interface{} {
	//
	// Cross
	//
	//     {
	//         "currency": "1INCH",
	//         "total": "0",
	//         "available": "0",
	//         "hold": "0",
	//         "liability": "0",
	//         "maxBorrowSize": "0",
	//         "borrowEnabled": true,
	//         "transferInEnabled": true
	//     }
	//
	// Isolated
	//
	//     {
	//         "symbol": "MANA-USDT",
	//         "debtRatio": "0",
	//         "status": "BORROW",
	//         "baseAsset": {
	//             "currency": "MANA",
	//             "borrowEnabled": true,
	//             "repayEnabled": true,
	//             "transferEnabled": true,
	//             "borrowed": "0",
	//             "totalAsset": "0",
	//             "available": "0",
	//             "hold": "0",
	//             "maxBorrowSize": "1000"
	//         },
	//         "quoteAsset": {
	//             "currency": "USDT",
	//             "borrowEnabled": true,
	//             "repayEnabled": true,
	//             "transferEnabled": true,
	//             "borrowed": "0",
	//             "totalAsset": "0",
	//             "available": "0",
	//             "hold": "0",
	//             "maxBorrowSize": "50000"
	//         }
	//     }
	//
	market := GetArg(optionalArgs, 0, nil)
	_ = market
	var marketId interface{} = this.SafeString(info, "symbol")
	var marginMode interface{} = Ternary(IsTrue((IsEqual(marketId, nil))), "cross", "isolated")
	market = this.SafeMarket(marketId, market)
	var symbol interface{} = this.SafeString(market, "symbol")
	var timestamp interface{} = this.SafeInteger(info, "createdAt")
	var isolatedBase interface{} = this.SafeDict(info, "baseAsset", map[string]interface{}{})
	var amountBorrowed interface{} = nil
	var interest interface{} = nil
	var currencyId interface{} = nil
	if IsTrue(IsEqual(marginMode, "isolated")) {
		amountBorrowed = this.SafeNumber(isolatedBase, "liability")
		interest = this.SafeNumber(isolatedBase, "interest")
		currencyId = this.SafeString(isolatedBase, "currency")
	} else {
		amountBorrowed = this.SafeNumber(info, "liability")
		interest = this.SafeNumber(info, "accruedInterest")
		currencyId = this.SafeString(info, "currency")
	}
	return map[string]interface{}{
		"info":           info,
		"symbol":         symbol,
		"currency":       this.SafeCurrencyCode(currencyId),
		"interest":       interest,
		"interestRate":   this.SafeNumber(info, "dailyIntRate"),
		"amountBorrowed": amountBorrowed,
		"marginMode":     marginMode,
		"timestamp":      timestamp,
		"datetime":       this.Iso8601(timestamp),
	}
}

/**
 * @method
 * @name kucoin#fetchBorrowRateHistories
 * @description retrieves a history of a multiple currencies borrow interest rate at specific time slots, returns all currencies if no symbols passed, default is undefined
 * @see https://www.kucoin.com/docs/rest/margin-trading/margin-trading-v3-/get-cross-isolated-margin-interest-records
 * @param {string[]|undefined} codes list of unified currency codes, default is undefined
 * @param {int} [since] timestamp in ms of the earliest borrowRate, default is undefined
 * @param {int} [limit] max number of borrow rate prices to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] 'cross' or 'isolated' default is 'cross'
 * @param {int} [params.until] the latest time in ms to fetch entries for
 * @returns {object} a dictionary of [borrow rate structures]{@link https://docs.ccxt.com/#/?id=borrow-rate-structure} indexed by the market symbol
 */
func (this *kucoin) FetchBorrowRateHistories(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		codes := GetArg(optionalArgs, 0, nil)
		_ = codes
		since := GetArg(optionalArgs, 1, nil)
		_ = since
		limit := GetArg(optionalArgs, 2, nil)
		_ = limit
		params := GetArg(optionalArgs, 3, map[string]interface{}{})
		_ = params

		retRes46938 := (<-this.LoadMarkets())
		PanicOnError(retRes46938)
		var marginResult interface{} = this.HandleMarginModeAndParams("fetchBorrowRateHistories", params)
		var marginMode interface{} = this.SafeString(marginResult, 0, "cross")
		var isIsolated interface{} = (IsEqual(marginMode, "isolated")) // true-isolated, false-cross
		var request interface{} = map[string]interface{}{
			"isIsolated": isIsolated,
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
		}
		requestparamsVariable := this.HandleUntilOption("endTime", request, params)
		request = GetValue(requestparamsVariable, 0)
		params = GetValue(requestparamsVariable, 1)
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "pageSize", limit) // default:50, min:10, max:500
		}

		response := (<-this.PrivateGetMarginInterest(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "200000",
		//         "data": {
		//             "timestamp": 1710829939673,
		//             "currentPage": 1,
		//             "pageSize": 50,
		//             "totalNum": 0,
		//             "totalPage": 0,
		//             "items": [
		//                 {
		//                     "createdAt": 1697783812257,
		//                     "currency": "XMR",
		//                     "interestAmount": "0.1",
		//                     "dayRatio": "0.001"
		//                 }
		//             ]
		//         }
		//     }
		//
		var data interface{} = this.SafeDict(response, "data")
		var rows interface{} = this.SafeList(data, "items", []interface{}{})

		ch <- this.ParseBorrowRateHistories(rows, codes, since, limit)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name kucoin#fetchBorrowRateHistory
 * @description retrieves a history of a currencies borrow interest rate at specific time slots
 * @see https://www.kucoin.com/docs/rest/margin-trading/margin-trading-v3-/get-cross-isolated-margin-interest-records
 * @param {string} code unified currency code
 * @param {int} [since] timestamp for the earliest borrow rate
 * @param {int} [limit] the maximum number of [borrow rate structures]{@link https://docs.ccxt.com/#/?id=borrow-rate-structure} to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] 'cross' or 'isolated' default is 'cross'
 * @param {int} [params.until] the latest time in ms to fetch entries for
 * @returns {object[]} an array of [borrow rate structures]{@link https://docs.ccxt.com/#/?id=borrow-rate-structure}
 */
func (this *kucoin) FetchBorrowRateHistory(code interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		since := GetArg(optionalArgs, 0, nil)
		_ = since
		limit := GetArg(optionalArgs, 1, nil)
		_ = limit
		params := GetArg(optionalArgs, 2, map[string]interface{}{})
		_ = params

		retRes47478 := (<-this.LoadMarkets())
		PanicOnError(retRes47478)
		var marginResult interface{} = this.HandleMarginModeAndParams("fetchBorrowRateHistories", params)
		var marginMode interface{} = this.SafeString(marginResult, 0, "cross")
		var isIsolated interface{} = (IsEqual(marginMode, "isolated")) // true-isolated, false-cross
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"isIsolated": isIsolated,
			"currency":   GetValue(currency, "id"),
		}
		if IsTrue(!IsEqual(since, nil)) {
			AddElementToObject(request, "startTime", since)
		}
		requestparamsVariable := this.HandleUntilOption("endTime", request, params)
		request = GetValue(requestparamsVariable, 0)
		params = GetValue(requestparamsVariable, 1)
		if IsTrue(!IsEqual(limit, nil)) {
			AddElementToObject(request, "pageSize", limit) // default:50, min:10, max:500
		}

		response := (<-this.PrivateGetMarginInterest(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "code": "200000",
		//         "data": {
		//             "timestamp": 1710829939673,
		//             "currentPage": 1,
		//             "pageSize": 50,
		//             "totalNum": 0,
		//             "totalPage": 0,
		//             "items": [
		//                 {
		//                     "createdAt": 1697783812257,
		//                     "currency": "XMR",
		//                     "interestAmount": "0.1",
		//                     "dayRatio": "0.001"
		//                 }
		//             ]
		//         }
		//     }
		//
		var data interface{} = this.SafeDict(response, "data")
		var rows interface{} = this.SafeList(data, "items", []interface{}{})

		ch <- this.ParseBorrowRateHistory(rows, code, since, limit)
		return nil

	}()
	return ch
}
func (this *kucoin) ParseBorrowRateHistories(response interface{}, codes interface{}, since interface{}, limit interface{}) interface{} {
	//
	//     [
	//         {
	//             "createdAt": 1697783812257,
	//             "currency": "XMR",
	//             "interestAmount": "0.1",
	//             "dayRatio": "0.001"
	//         }
	//     ]
	//
	var borrowRateHistories interface{} = map[string]interface{}{}
	for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
		var item interface{} = GetValue(response, i)
		var code interface{} = this.SafeCurrencyCode(this.SafeString(item, "currency"))
		if IsTrue(IsTrue(IsEqual(codes, nil)) || IsTrue(this.InArray(code, codes))) {
			if !IsTrue((InOp(borrowRateHistories, code))) {
				AddElementToObject(borrowRateHistories, code, []interface{}{})
			}
			var borrowRateStructure interface{} = this.ParseBorrowRate(item)
			var borrowRateHistoriesCode interface{} = GetValue(borrowRateHistories, code)
			AppendToArray(&borrowRateHistoriesCode, borrowRateStructure)
		}
	}
	var keys interface{} = ObjectKeys(borrowRateHistories)
	for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
		var code interface{} = GetValue(keys, i)
		AddElementToObject(borrowRateHistories, code, this.FilterByCurrencySinceLimit(GetValue(borrowRateHistories, code), code, since, limit))
	}
	return borrowRateHistories
}

/**
 * @method
 * @name kucoin#borrowCrossMargin
 * @description create a loan to borrow margin
 * @see https://docs.kucoin.com/#1-margin-borrowing
 * @param {string} code unified currency code of the currency to borrow
 * @param {float} amount the amount to borrow
 * @param {object} [params] extra parameters specific to the exchange API endpoints
 * @param {string} [params.timeInForce] either IOC or FOK
 * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
 */
func (this *kucoin) BorrowCrossMargin(code interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes48338 := (<-this.LoadMarkets())
		PanicOnError(retRes48338)
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"currency":    GetValue(currency, "id"),
			"size":        this.CurrencyToPrecision(code, amount),
			"timeInForce": "FOK",
		}

		response := (<-this.PrivatePostMarginBorrow(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "success": true,
		//         "code": "200",
		//         "msg": "success",
		//         "retry": false,
		//         "data": {
		//             "orderNo": "5da6dba0f943c0c81f5d5db5",
		//             "actualSize": 10
		//         }
		//     }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})

		ch <- this.ParseMarginLoan(data, currency)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name kucoin#borrowIsolatedMargin
 * @description create a loan to borrow margin
 * @see https://docs.kucoin.com/#1-margin-borrowing
 * @param {string} symbol unified market symbol, required for isolated margin
 * @param {string} code unified currency code of the currency to borrow
 * @param {float} amount the amount to borrow
 * @param {object} [params] extra parameters specific to the exchange API endpoints
 * @param {string} [params.timeInForce] either IOC or FOK
 * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
 */
func (this *kucoin) BorrowIsolatedMargin(symbol interface{}, code interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes48708 := (<-this.LoadMarkets())
		PanicOnError(retRes48708)
		var market interface{} = this.Market(symbol)
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"currency":    GetValue(currency, "id"),
			"size":        this.CurrencyToPrecision(code, amount),
			"symbol":      GetValue(market, "id"),
			"timeInForce": "FOK",
			"isIsolated":  true,
		}

		response := (<-this.PrivatePostMarginBorrow(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "success": true,
		//         "code": "200",
		//         "msg": "success",
		//         "retry": false,
		//         "data": {
		//             "orderNo": "5da6dba0f943c0c81f5d5db5",
		//             "actualSize": 10
		//         }
		//     }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})

		ch <- this.ParseMarginLoan(data, currency)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name kucoin#repayCrossMargin
 * @description repay borrowed margin and interest
 * @see https://docs.kucoin.com/#2-repayment
 * @param {string} code unified currency code of the currency to repay
 * @param {float} amount the amount to repay
 * @param {object} [params] extra parameters specific to the exchange API endpoints
 * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
 */
func (this *kucoin) RepayCrossMargin(code interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes49088 := (<-this.LoadMarkets())
		PanicOnError(retRes49088)
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"currency": GetValue(currency, "id"),
			"size":     this.CurrencyToPrecision(code, amount),
		}

		response := (<-this.PrivatePostMarginRepay(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "success": true,
		//         "code": "200",
		//         "msg": "success",
		//         "retry": false,
		//         "data": {
		//             "orderNo": "5da6dba0f943c0c81f5d5db5",
		//             "actualSize": 10
		//         }
		//     }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})

		ch <- this.ParseMarginLoan(data, currency)
		return nil

	}()
	return ch
}

/**
 * @method
 * @name kucoin#repayIsolatedMargin
 * @description repay borrowed margin and interest
 * @see https://docs.kucoin.com/#2-repayment
 * @param {string} symbol unified market symbol
 * @param {string} code unified currency code of the currency to repay
 * @param {float} amount the amount to repay
 * @param {object} [params] extra parameters specific to the exchange API endpoints
 * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
 */
func (this *kucoin) RepayIsolatedMargin(symbol interface{}, code interface{}, amount interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		params := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = params

		retRes49438 := (<-this.LoadMarkets())
		PanicOnError(retRes49438)
		var market interface{} = this.Market(symbol)
		var currency interface{} = this.Currency(code)
		var request interface{} = map[string]interface{}{
			"currency":   GetValue(currency, "id"),
			"size":       this.CurrencyToPrecision(code, amount),
			"symbol":     GetValue(market, "id"),
			"isIsolated": true,
		}

		response := (<-this.PrivatePostMarginRepay(this.Extend(request, params)))
		PanicOnError(response)
		//
		//     {
		//         "success": true,
		//         "code": "200",
		//         "msg": "success",
		//         "retry": false,
		//         "data": {
		//             "orderNo": "5da6dba0f943c0c81f5d5db5",
		//             "actualSize": 10
		//         }
		//     }
		//
		var data interface{} = this.SafeDict(response, "data", map[string]interface{}{})

		ch <- this.ParseMarginLoan(data, currency)
		return nil

	}()
	return ch
}
func (this *kucoin) ParseMarginLoan(info interface{}, optionalArgs ...interface{}) interface{} {
	//
	//     {
	//         "orderNo": "5da6dba0f943c0c81f5d5db5",
	//         "actualSize": 10
	//     }
	//
	currency := GetArg(optionalArgs, 0, nil)
	_ = currency
	var timestamp interface{} = this.Milliseconds()
	var currencyId interface{} = this.SafeString(info, "currency")
	return map[string]interface{}{
		"id":        this.SafeString(info, "orderNo"),
		"currency":  this.SafeCurrencyCode(currencyId, currency),
		"amount":    this.SafeNumber(info, "actualSize"),
		"symbol":    nil,
		"timestamp": timestamp,
		"datetime":  this.Iso8601(timestamp),
		"info":      info,
	}
}

/**
 * @method
 * @name kucoin#fetchDepositWithdrawFees
 * @description fetch deposit and withdraw fees - *IMPORTANT* use fetchDepositWithdrawFee to get more in-depth info
 * @see https://docs.kucoin.com/#get-currencies
 * @param {string[]|undefined} codes list of unified currency codes
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func (this *kucoin) FetchDepositWithdrawFees(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		codes := GetArg(optionalArgs, 0, nil)
		_ = codes
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes49998 := (<-this.LoadMarkets())
		PanicOnError(retRes49998)

		response := (<-this.PublicGetCurrencies(params))
		PanicOnError(response)
		//
		//  [
		//      {
		//        "currency": "CSP",
		//        "name": "CSP",
		//        "fullName": "Caspian",
		//        "precision": 8,
		//        "confirms": 12,
		//        "contractAddress": "0xa6446d655a0c34bc4f05042ee88170d056cbaf45",
		//        "withdrawalMinSize": "2000",
		//        "withdrawalMinFee": "1000",
		//        "isWithdrawEnabled": true,
		//        "isDepositEnabled": true,
		//        "isMarginEnabled": false,
		//        "isDebitEnabled": false
		//      },
		//  ]
		//
		var data interface{} = this.SafeList(response, "data", []interface{}{})

		ch <- this.ParseDepositWithdrawFees(data, codes, "currency")
		return nil

	}()
	return ch
}

/**
 * @method
 * @name kucoin#setLeverage
 * @description set the level of leverage for a market
 * @see https://www.kucoin.com/docs/rest/margin-trading/margin-trading-v3-/modify-leverage-multiplier
 * @param {int } [leverage] New leverage multiplier. Must be greater than 1 and up to two decimal places, and cannot be less than the user's current debt leverage or greater than the system's maximum leverage
 * @param {string} [symbol] unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} response from the exchange
 */
func (this *kucoin) SetLeverage(leverage interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		symbol := GetArg(optionalArgs, 0, nil)
		_ = symbol
		params := GetArg(optionalArgs, 1, map[string]interface{}{})
		_ = params

		retRes50348 := (<-this.LoadMarkets())
		PanicOnError(retRes50348)
		var market interface{} = nil
		var marketType interface{} = nil
		marketTypeparamsVariable := this.HandleMarketTypeAndParams("setLeverage", nil, params)
		marketType = GetValue(marketTypeparamsVariable, 0)
		params = GetValue(marketTypeparamsVariable, 1)
		if IsTrue(IsTrue((!IsEqual(symbol, nil))) || IsTrue(!IsEqual(marketType, "spot"))) {
			market = this.Market(symbol)
			if IsTrue(GetValue(market, "contract")) {
				panic(NotSupported(Add(this.Id, " setLeverage currently supports only spot margin")))
			}
		}
		var marginMode interface{} = nil
		marginModeparamsVariable := this.HandleMarginModeAndParams("setLeverage", params)
		marginMode = GetValue(marginModeparamsVariable, 0)
		params = GetValue(marginModeparamsVariable, 1)
		if IsTrue(IsEqual(marginMode, nil)) {
			panic(ArgumentsRequired(Add(this.Id, " setLeverage requires a marginMode parameter")))
		}
		var request interface{} = map[string]interface{}{}
		if IsTrue(IsTrue(IsEqual(marginMode, "isolated")) && IsTrue(IsEqual(symbol, nil))) {
			panic(ArgumentsRequired(Add(this.Id, " setLeverage requires a symbol parameter for isolated margin")))
		}
		if IsTrue(!IsEqual(symbol, nil)) {
			AddElementToObject(request, "symbol", GetValue(market, "id"))
		}
		AddElementToObject(request, "leverage", ToString(leverage))
		AddElementToObject(request, "isIsolated", (IsEqual(marginMode, "isolated")))

		retRes505815 := (<-this.PrivatePostPositionUpdateUserLeverage(this.Extend(request, params)))
		PanicOnError(retRes505815)
		ch <- retRes505815
		return nil

	}()
	return ch
}
func (this *kucoin) Sign(path interface{}, optionalArgs ...interface{}) interface{} {
	//
	// the v2 URL is https://openapi-v2.kucoin.com/api/v1/endpoint
	//                                                 
	//                                                 
	//
	api := GetArg(optionalArgs, 0, "public")
	_ = api
	method := GetArg(optionalArgs, 1, "GET")
	_ = method
	params := GetArg(optionalArgs, 2, map[string]interface{}{})
	_ = params
	headers := GetArg(optionalArgs, 3, nil)
	_ = headers
	body := GetArg(optionalArgs, 4, nil)
	_ = body
	var versions interface{} = this.SafeDict(this.Options, "versions", map[string]interface{}{})
	var apiVersions interface{} = this.SafeDict(versions, api, map[string]interface{}{})
	var methodVersions interface{} = this.SafeDict(apiVersions, method, map[string]interface{}{})
	var defaultVersion interface{} = this.SafeString(methodVersions, path, GetValue(this.Options, "version"))
	var version interface{} = this.SafeString(params, "version", defaultVersion)
	params = this.Omit(params, "version")
	var endpoint interface{} = Add(Add(Add("/api/", version), "/"), this.ImplodeParams(path, params))
	if IsTrue(IsEqual(api, "webExchange")) {
		endpoint = Add("/", this.ImplodeParams(path, params))
	}
	if IsTrue(IsEqual(api, "earn")) {
		endpoint = Add("/api/v1/", this.ImplodeParams(path, params))
	}
	var query interface{} = this.Omit(params, this.ExtractParams(path))
	var endpart interface{} = ""
	headers = Ternary(IsTrue((!IsEqual(headers, nil))), headers, map[string]interface{}{})
	var url interface{} = GetValue(GetValue(this.Urls, "api"), api)
	if !IsTrue(this.IsEmpty(query)) {
		if IsTrue(IsTrue((IsTrue((IsEqual(method, "GET"))) || IsTrue((IsEqual(method, "DELETE"))))) && IsTrue((!IsEqual(path, "orders/multi-cancel")))) {
			endpoint = Add(endpoint, Add("?", this.Rawencode(query)))
		} else {
			body = this.Json(query)
			endpart = body
			AddElementToObject(headers, "Content-Type", "application/json")
		}
	}
	url = Add(url, endpoint)
	var isFuturePrivate interface{} = (IsEqual(api, "futuresPrivate"))
	var isPrivate interface{} = (IsEqual(api, "private"))
	var isBroker interface{} = (IsEqual(api, "broker"))
	var isEarn interface{} = (IsEqual(api, "earn"))
	if IsTrue(IsTrue(IsTrue(IsTrue(isPrivate) || IsTrue(isFuturePrivate)) || IsTrue(isBroker)) || IsTrue(isEarn)) {
		this.CheckRequiredCredentials()
		var timestamp interface{} = ToString(this.Nonce())
		headers = this.Extend(map[string]interface{}{
			"KC-API-KEY-VERSION": "2",
			"KC-API-KEY":         this.ApiKey,
			"KC-API-TIMESTAMP":   timestamp,
		}, headers)
		var apiKeyVersion interface{} = this.SafeString(headers, "KC-API-KEY-VERSION")
		if IsTrue(IsEqual(apiKeyVersion, "2")) {
			var passphrase interface{} = this.Hmac(this.Encode(this.Password), this.Encode(this.Secret), sha256, "base64")
			AddElementToObject(headers, "KC-API-PASSPHRASE", passphrase)
		} else {
			AddElementToObject(headers, "KC-API-PASSPHRASE", this.Password)
		}
		var payload interface{} = Add(Add(Add(timestamp, method), endpoint), endpart)
		var signature interface{} = this.Hmac(this.Encode(payload), this.Encode(this.Secret), sha256, "base64")
		AddElementToObject(headers, "KC-API-SIGN", signature)
		var partner interface{} = this.SafeDict(this.Options, "partner", map[string]interface{}{})
		partner = Ternary(IsTrue(isFuturePrivate), this.SafeValue(partner, "future", partner), this.SafeValue(partner, "spot", partner))
		var partnerId interface{} = this.SafeString(partner, "id")
		var partnerSecret interface{} = this.SafeString2(partner, "secret", "key")
		if IsTrue(IsTrue((!IsEqual(partnerId, nil))) && IsTrue((!IsEqual(partnerSecret, nil)))) {
			var partnerPayload interface{} = Add(Add(timestamp, partnerId), this.ApiKey)
			var partnerSignature interface{} = this.Hmac(this.Encode(partnerPayload), this.Encode(partnerSecret), sha256, "base64")
			AddElementToObject(headers, "KC-API-PARTNER-SIGN", partnerSignature)
			AddElementToObject(headers, "KC-API-PARTNER", partnerId)
			AddElementToObject(headers, "KC-API-PARTNER-VERIFY", "true")
		}
		if IsTrue(isBroker) {
			var brokerName interface{} = this.SafeString(partner, "name")
			if IsTrue(!IsEqual(brokerName, nil)) {
				AddElementToObject(headers, "KC-BROKER-NAME", brokerName)
			}
		}
	}
	return map[string]interface{}{
		"url":     url,
		"method":  method,
		"body":    body,
		"headers": headers,
	}
}
func (this *kucoin) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{} {
	if !IsTrue(response) {
		this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), body, body)
		return nil
	}
	//
	// bad
	//     { "code": "400100", "msg": "validation.createOrder.clientOidIsRequired" }
	// good
	//     { code: '200000', data: { ... }}
	//
	var errorCode interface{} = this.SafeString(response, "code")
	var message interface{} = this.SafeString2(response, "msg", "data", "")
	var feedback interface{} = Add(Add(this.Id, " "), body)
	this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), message, feedback)
	this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), errorCode, feedback)
	this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), body, feedback)
	if IsTrue(IsTrue(!IsEqual(errorCode, "200000")) && IsTrue(!IsEqual(errorCode, "200"))) {
		panic(ExchangeError(feedback))
	}
	return nil
}

func (this *kucoin) Init(userConfig map[string]interface{}) {
	this.Exchange = Exchange{}
	this.Exchange.DerivedExchange = this
	this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
}
