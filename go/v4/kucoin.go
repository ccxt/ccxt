package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type kucoin struct {
    Exchange

}

func NewKucoinCore() kucoin {
   p := kucoin{}
   setDefaults(&p)
   return p
}

func  (this *kucoin) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "kucoin",
        "name": "KuCoin",
        "countries": []interface{}{"SC"},
        "rateLimit": 10,
        "version": "v2",
        "certified": true,
        "pro": true,
        "comment": "Platform 2.0",
        "quoteJsonNumbers": false,
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": true,
            "swap": false,
            "future": false,
            "option": false,
            "borrowCrossMargin": true,
            "borrowIsolatedMargin": true,
            "cancelAllOrders": true,
            "cancelOrder": true,
            "closeAllPositions": false,
            "closePosition": false,
            "createDepositAddress": true,
            "createMarketBuyOrderWithCost": true,
            "createMarketOrderWithCost": true,
            "createMarketSellOrderWithCost": true,
            "createOrder": true,
            "createOrders": true,
            "createPostOnlyOrder": true,
            "createStopLimitOrder": true,
            "createStopMarketOrder": true,
            "createStopOrder": true,
            "createTriggerOrder": true,
            "editOrder": true,
            "fetchAccounts": true,
            "fetchBalance": true,
            "fetchBorrowInterest": true,
            "fetchBorrowRateHistories": true,
            "fetchBorrowRateHistory": true,
            "fetchClosedOrders": true,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchCurrencies": true,
            "fetchDepositAddress": true,
            "fetchDepositAddresses": false,
            "fetchDepositAddressesByNetwork": true,
            "fetchDeposits": true,
            "fetchDepositWithdrawFee": true,
            "fetchDepositWithdrawFees": true,
            "fetchFundingHistory": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchIndexOHLCV": false,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchL3OrderBook": true,
            "fetchLedger": true,
            "fetchLeverageTiers": false,
            "fetchMarginAdjustmentHistory": false,
            "fetchMarginMode": false,
            "fetchMarketLeverageTiers": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMarkPrice": true,
            "fetchMarkPrices": true,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenInterest": false,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrderBooks": false,
            "fetchOrdersByStatus": true,
            "fetchOrderTrades": true,
            "fetchPositionHistory": false,
            "fetchPositionMode": false,
            "fetchPositionsHistory": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchStatus": true,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTime": true,
            "fetchTrades": true,
            "fetchTradingFee": true,
            "fetchTradingFees": false,
            "fetchTransactionFee": true,
            "fetchTransfers": false,
            "fetchWithdrawals": true,
            "repayCrossMargin": true,
            "repayIsolatedMargin": true,
            "setLeverage": true,
            "setMarginMode": false,
            "setPositionMode": false,
            "signIn": false,
            "transfer": true,
            "withdraw": true,
        },
        "urls": map[string]interface{} {
            "logo": "https://user-images.githubusercontent.com/51840849/87295558-132aaf80-c50e-11ea-9801-a2fb0c57c799.jpg",
            "referral": "https://www.kucoin.com/ucenter/signup?rcode=E5wkqe",
            "api": map[string]interface{} {
                "public": "https://api.kucoin.com",
                "private": "https://api.kucoin.com",
                "futuresPrivate": "https://api-futures.kucoin.com",
                "futuresPublic": "https://api-futures.kucoin.com",
                "webExchange": "https://kucoin.com/_api",
                "broker": "https://api-broker.kucoin.com",
                "earn": "https://api.kucoin.com",
            },
            "www": "https://www.kucoin.com",
            "doc": []interface{}{"https://docs.kucoin.com"},
        },
        "requiredCredentials": map[string]interface{} {
            "apiKey": true,
            "secret": true,
            "password": true,
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": map[string]interface{} {
                    "currencies": 4.5,
                    "currencies/{currency}": 4.5,
                    "symbols": 6,
                    "market/orderbook/level1": 3,
                    "market/allTickers": 22.5,
                    "market/stats": 22.5,
                    "markets": 4.5,
                    "market/orderbook/level{level}_{limit}": 6,
                    "market/orderbook/level2_20": 3,
                    "market/orderbook/level2_100": 6,
                    "market/histories": 4.5,
                    "market/candles": 4.5,
                    "prices": 4.5,
                    "timestamp": 4.5,
                    "status": 4.5,
                    "mark-price/{symbol}/current": 3,
                    "mark-price/all-symbols": 3,
                    "margin/config": 25,
                    "announcements": 20,
                },
                "post": map[string]interface{} {
                    "bullet-public": 15,
                },
            },
            "private": map[string]interface{} {
                "get": map[string]interface{} {
                    "user-info": 30,
                    "accounts": 7.5,
                    "accounts/{accountId}": 7.5,
                    "accounts/ledgers": 3,
                    "hf/accounts/ledgers": 2,
                    "hf/margin/account/ledgers": 2,
                    "transaction-history": 3,
                    "sub/user": 30,
                    "sub-accounts/{subUserId}": 22.5,
                    "sub-accounts": 30,
                    "sub/api-key": 30,
                    "margin/account": 40,
                    "margin/accounts": 15,
                    "isolated/accounts": 15,
                    "deposit-addresses": 7.5,
                    "deposits": 7.5,
                    "hist-deposits": 7.5,
                    "withdrawals": 30,
                    "hist-withdrawals": 30,
                    "withdrawals/quotas": 30,
                    "accounts/transferable": 30,
                    "transfer-list": 30,
                    "base-fee": 3,
                    "trade-fees": 3,
                    "market/orderbook/level{level}": 3,
                    "market/orderbook/level2": 3,
                    "market/orderbook/level3": 3,
                    "hf/accounts/opened": 2,
                    "hf/orders/active": 2,
                    "hf/orders/active/symbols": 2,
                    "hf/margin/order/active/symbols": 2,
                    "hf/orders/done": 2,
                    "hf/orders/{orderId}": 2,
                    "hf/orders/client-order/{clientOid}": 2,
                    "hf/orders/dead-cancel-all/query": 2,
                    "hf/fills": 2,
                    "orders": 2,
                    "limit/orders": 3,
                    "orders/{orderId}": 2,
                    "order/client-order/{clientOid}": 3,
                    "fills": 10,
                    "limit/fills": 20,
                    "stop-order": 8,
                    "stop-order/{orderId}": 3,
                    "stop-order/queryOrderByClientOid": 3,
                    "oco/order/{orderId}": 2,
                    "oco/order/details/{orderId}": 2,
                    "oco/client-order/{clientOid}": 2,
                    "oco/orders": 2,
                    "hf/margin/orders/active": 4,
                    "hf/margin/orders/done": 10,
                    "hf/margin/orders/{orderId}": 4,
                    "hf/margin/orders/client-order/{clientOid}": 5,
                    "hf/margin/fills": 5,
                    "etf/info": 25,
                    "margin/currencies": 20,
                    "risk/limit/strategy": 20,
                    "isolated/symbols": 20,
                    "margin/symbols": 5,
                    "isolated/account/{symbol}": 50,
                    "margin/borrow": 15,
                    "margin/repay": 15,
                    "margin/interest": 20,
                    "project/list": 10,
                    "project/marketInterestRate": 7.5,
                    "redeem/orders": 10,
                    "purchase/orders": 10,
                    "broker/api/rebase/download": 3,
                    "migrate/user/account/status": 3,
                    "affiliate/inviter/statistics": 30,
                },
                "post": map[string]interface{} {
                    "sub/user/created": 22.5,
                    "sub/api-key": 30,
                    "sub/api-key/update": 45,
                    "deposit-addresses": 30,
                    "withdrawals": 7.5,
                    "accounts/universal-transfer": 6,
                    "accounts/sub-transfer": 45,
                    "accounts/inner-transfer": 15,
                    "transfer-out": 30,
                    "transfer-in": 30,
                    "hf/orders": 1,
                    "hf/orders/test": 1,
                    "hf/orders/sync": 1,
                    "hf/orders/multi": 1,
                    "hf/orders/multi/sync": 1,
                    "hf/orders/alter": 3,
                    "hf/orders/dead-cancel-all": 2,
                    "orders": 2,
                    "orders/test": 2,
                    "orders/multi": 3,
                    "stop-order": 2,
                    "oco/order": 2,
                    "hf/margin/order": 5,
                    "hf/margin/order/test": 5,
                    "margin/order": 5,
                    "margin/order/test": 5,
                    "margin/borrow": 15,
                    "margin/repay": 10,
                    "purchase": 15,
                    "redeem": 15,
                    "lend/purchase/update": 10,
                    "bullet-private": 10,
                    "position/update-user-leverage": 5,
                    "deposit-address/create": 20,
                },
                "delete": map[string]interface{} {
                    "sub/api-key": 45,
                    "withdrawals/{withdrawalId}": 30,
                    "hf/orders/{orderId}": 1,
                    "hf/orders/sync/{orderId}": 1,
                    "hf/orders/client-order/{clientOid}": 1,
                    "hf/orders/sync/client-order/{clientOid}": 1,
                    "hf/orders/cancel/{orderId}": 2,
                    "hf/orders": 2,
                    "hf/orders/cancelAll": 30,
                    "orders/{orderId}": 3,
                    "order/client-order/{clientOid}": 5,
                    "orders": 20,
                    "stop-order/{orderId}": 3,
                    "stop-order/cancelOrderByClientOid": 5,
                    "stop-order/cancel": 3,
                    "oco/order/{orderId}": 3,
                    "oco/client-order/{clientOid}": 3,
                    "oco/orders": 3,
                    "hf/margin/orders/{orderId}": 5,
                    "hf/margin/orders/client-order/{clientOid}": 5,
                    "hf/margin/orders": 10,
                },
            },
            "futuresPublic": map[string]interface{} {
                "get": map[string]interface{} {
                    "contracts/active": 4.5,
                    "contracts/{symbol}": 4.5,
                    "ticker": 3,
                    "level2/snapshot": 4.5,
                    "level2/depth20": 7.5,
                    "level2/depth100": 15,
                    "trade/history": 7.5,
                    "kline/query": 4.5,
                    "interest/query": 7.5,
                    "index/query": 3,
                    "mark-price/{symbol}/current": 4.5,
                    "premium/query": 4.5,
                    "trade-statistics": 4.5,
                    "funding-rate/{symbol}/current": 3,
                    "contract/funding-rates": 7.5,
                    "timestamp": 3,
                    "status": 6,
                    "level2/message/query": 1.3953,
                },
                "post": map[string]interface{} {
                    "bullet-public": 15,
                },
            },
            "futuresPrivate": map[string]interface{} {
                "get": map[string]interface{} {
                    "transaction-history": 3,
                    "account-overview": 7.5,
                    "account-overview-all": 9,
                    "transfer-list": 30,
                    "orders": 3,
                    "stopOrders": 9,
                    "recentDoneOrders": 7.5,
                    "orders/{orderId}": 7.5,
                    "orders/byClientOid": 7.5,
                    "fills": 7.5,
                    "recentFills": 4.5,
                    "openOrderStatistics": 15,
                    "position": 3,
                    "positions": 3,
                    "margin/maxWithdrawMargin": 15,
                    "contracts/risk-limit/{symbol}": 7.5,
                    "funding-history": 7.5,
                },
                "post": map[string]interface{} {
                    "transfer-out": 30,
                    "transfer-in": 30,
                    "orders": 3,
                    "orders/test": 3,
                    "orders/multi": 4.5,
                    "position/margin/auto-deposit-status": 6,
                    "margin/withdrawMargin": 15,
                    "position/margin/deposit-margin": 6,
                    "position/risk-limit-level/change": 6,
                    "bullet-private": 15,
                },
                "delete": map[string]interface{} {
                    "orders/{orderId}": 1.5,
                    "orders/client-order/{clientOid}": 1.5,
                    "orders": 45,
                    "stopOrders": 22.5,
                },
            },
            "webExchange": map[string]interface{} {
                "get": map[string]interface{} {
                    "currency/currency/chain-info": 1,
                },
            },
            "broker": map[string]interface{} {
                "get": map[string]interface{} {
                    "broker/nd/info": 2,
                    "broker/nd/account": 2,
                    "broker/nd/account/apikey": 2,
                    "broker/nd/rebase/download": 3,
                    "asset/ndbroker/deposit/list": 1,
                    "broker/nd/transfer/detail": 1,
                    "broker/nd/deposit/detail": 1,
                    "broker/nd/withdraw/detail": 1,
                },
                "post": map[string]interface{} {
                    "broker/nd/transfer": 1,
                    "broker/nd/account": 3,
                    "broker/nd/account/apikey": 3,
                    "broker/nd/account/update-apikey": 3,
                },
                "delete": map[string]interface{} {
                    "broker/nd/account/apikey": 3,
                },
            },
            "earn": map[string]interface{} {
                "get": map[string]interface{} {
                    "otc-loan/loan": 1,
                    "otc-loan/accounts": 1,
                    "earn/redeem-preview": 7.5,
                    "earn/saving/products": 7.5,
                    "earn/hold-assets": 7.5,
                    "earn/promotion/products": 7.5,
                    "earn/kcs-staking/products": 7.5,
                    "earn/staking/products": 7.5,
                    "earn/eth-staking/products": 7.5,
                },
                "post": map[string]interface{} {
                    "earn/orders": 7.5,
                },
                "delete": map[string]interface{} {
                    "earn/orders": 7.5,
                },
            },
        },
        "timeframes": map[string]interface{} {
            "1m": "1min",
            "3m": "3min",
            "5m": "5min",
            "15m": "15min",
            "30m": "30min",
            "1h": "1hour",
            "2h": "2hour",
            "4h": "4hour",
            "6h": "6hour",
            "8h": "8hour",
            "12h": "12hour",
            "1d": "1day",
            "1w": "1week",
            "1M": "1month",
        },
        "precisionMode": TICK_SIZE,
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "The order does not exist.": OrderNotFound,
                "order not exist": OrderNotFound,
                "order not exist.": OrderNotFound,
                "order_not_exist": OrderNotFound,
                "order_not_exist_or_not_allow_to_cancel": InvalidOrder,
                "Order size below the minimum requirement.": InvalidOrder,
                "The withdrawal amount is below the minimum requirement.": ExchangeError,
                "Unsuccessful! Exceeded the max. funds out-transfer limit": InsufficientFunds,
                "The amount increment is invalid.": BadRequest,
                "The quantity is below the minimum requirement.": InvalidOrder,
                "400": BadRequest,
                "401": AuthenticationError,
                "403": NotSupported,
                "404": NotSupported,
                "405": NotSupported,
                "415": NotSupported,
                "429": RateLimitExceeded,
                "500": ExchangeNotAvailable,
                "503": ExchangeNotAvailable,
                "101030": PermissionDenied,
                "103000": InvalidOrder,
                "130101": BadRequest,
                "130102": ExchangeError,
                "130103": OrderNotFound,
                "130104": ExchangeError,
                "130105": InsufficientFunds,
                "130106": NotSupported,
                "130107": ExchangeError,
                "130108": OrderNotFound,
                "130201": PermissionDenied,
                "130202": ExchangeError,
                "130203": InsufficientFunds,
                "130204": BadRequest,
                "130301": InsufficientFunds,
                "130302": PermissionDenied,
                "130303": NotSupported,
                "130304": NotSupported,
                "130305": NotSupported,
                "130306": NotSupported,
                "130307": NotSupported,
                "130308": InvalidOrder,
                "130309": InvalidOrder,
                "130310": ExchangeError,
                "130311": InvalidOrder,
                "130312": InvalidOrder,
                "130313": InvalidOrder,
                "130314": InvalidOrder,
                "130315": NotSupported,
                "126000": ExchangeError,
                "126001": NotSupported,
                "126002": ExchangeError,
                "126003": InvalidOrder,
                "126004": ExchangeError,
                "126005": PermissionDenied,
                "126006": ExchangeError,
                "126007": ExchangeError,
                "126009": ExchangeError,
                "126010": ExchangeError,
                "126011": ExchangeError,
                "126013": InsufficientFunds,
                "126015": ExchangeError,
                "126021": NotSupported,
                "126022": InvalidOrder,
                "126027": InvalidOrder,
                "126028": InvalidOrder,
                "126029": InvalidOrder,
                "126030": InvalidOrder,
                "126033": InvalidOrder,
                "126034": InvalidOrder,
                "126036": InvalidOrder,
                "126037": ExchangeError,
                "126038": ExchangeError,
                "126039": ExchangeError,
                "126041": ExchangeError,
                "126042": ExchangeError,
                "126043": OrderNotFound,
                "126044": InvalidOrder,
                "126045": NotSupported,
                "126046": NotSupported,
                "126047": PermissionDenied,
                "126048": PermissionDenied,
                "135005": ExchangeError,
                "135018": ExchangeError,
                "200004": InsufficientFunds,
                "210014": InvalidOrder,
                "210021": InsufficientFunds,
                "230003": InsufficientFunds,
                "260000": InvalidAddress,
                "260100": InsufficientFunds,
                "300000": InvalidOrder,
                "400000": BadSymbol,
                "400001": AuthenticationError,
                "400002": InvalidNonce,
                "400003": AuthenticationError,
                "400004": AuthenticationError,
                "400005": AuthenticationError,
                "400006": AuthenticationError,
                "400007": AuthenticationError,
                "400008": NotSupported,
                "400100": InsufficientFunds,
                "400200": InvalidOrder,
                "400330": InvalidOrder,
                "400350": InvalidOrder,
                "400370": InvalidOrder,
                "400400": BadRequest,
                "400401": AuthenticationError,
                "400500": InvalidOrder,
                "400600": BadSymbol,
                "400760": InvalidOrder,
                "401000": BadRequest,
                "408000": BadRequest,
                "411100": AccountSuspended,
                "415000": BadRequest,
                "400303": PermissionDenied,
                "500000": ExchangeNotAvailable,
                "260220": InvalidAddress,
                "600100": InsufficientFunds,
                "600101": InvalidOrder,
                "900014": BadRequest,
            },
            "broad": map[string]interface{} {
                "Exceeded the access frequency": RateLimitExceeded,
                "require more permission": PermissionDenied,
            },
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "tierBased": true,
                "percentage": true,
                "taker": this.ParseNumber("0.001"),
                "maker": this.ParseNumber("0.001"),
                "tiers": map[string]interface{} {
                    "taker": []interface{}{[]interface{}{this.ParseNumber("0"), this.ParseNumber("0.001")}, []interface{}{this.ParseNumber("50"), this.ParseNumber("0.001")}, []interface{}{this.ParseNumber("200"), this.ParseNumber("0.0009")}, []interface{}{this.ParseNumber("500"), this.ParseNumber("0.0008")}, []interface{}{this.ParseNumber("1000"), this.ParseNumber("0.0007")}, []interface{}{this.ParseNumber("2000"), this.ParseNumber("0.0007")}, []interface{}{this.ParseNumber("4000"), this.ParseNumber("0.0006")}, []interface{}{this.ParseNumber("8000"), this.ParseNumber("0.0005")}, []interface{}{this.ParseNumber("15000"), this.ParseNumber("0.00045")}, []interface{}{this.ParseNumber("25000"), this.ParseNumber("0.0004")}, []interface{}{this.ParseNumber("40000"), this.ParseNumber("0.00035")}, []interface{}{this.ParseNumber("60000"), this.ParseNumber("0.0003")}, []interface{}{this.ParseNumber("80000"), this.ParseNumber("0.00025")}},
                    "maker": []interface{}{[]interface{}{this.ParseNumber("0"), this.ParseNumber("0.001")}, []interface{}{this.ParseNumber("50"), this.ParseNumber("0.0009")}, []interface{}{this.ParseNumber("200"), this.ParseNumber("0.0007")}, []interface{}{this.ParseNumber("500"), this.ParseNumber("0.0005")}, []interface{}{this.ParseNumber("1000"), this.ParseNumber("0.0003")}, []interface{}{this.ParseNumber("2000"), this.ParseNumber("0")}, []interface{}{this.ParseNumber("4000"), this.ParseNumber("0")}, []interface{}{this.ParseNumber("8000"), this.ParseNumber("0")}, []interface{}{this.ParseNumber("15000"), this.ParseNumber("-0.00005")}, []interface{}{this.ParseNumber("25000"), this.ParseNumber("-0.00005")}, []interface{}{this.ParseNumber("40000"), this.ParseNumber("-0.00005")}, []interface{}{this.ParseNumber("60000"), this.ParseNumber("-0.00005")}, []interface{}{this.ParseNumber("80000"), this.ParseNumber("-0.00005")}},
                },
            },
            "funding": map[string]interface{} {
                "tierBased": false,
                "percentage": false,
                "withdraw": map[string]interface{} {},
                "deposit": map[string]interface{} {},
            },
        },
        "commonCurrencies": map[string]interface{} {
            "BIFI": "BIFIF",
            "VAI": "VAIOT",
            "WAX": "WAXP",
            "ALT": "APTOSLAUNCHTOKEN",
            "KALT": "ALT",
            "FUD": "FTX Users\\' Debt",
        },
        "options": map[string]interface{} {
            "hf": nil,
            "version": "v1",
            "symbolSeparator": "-",
            "fetchMyTradesMethod": "private_get_fills",
            "timeDifference": 0,
            "adjustForTimeDifference": false,
            "fetchCurrencies": map[string]interface{} {
                "webApiEnable": true,
                "webApiRetries": 1,
                "webApiMuteFailure": true,
            },
            "fetchMarkets": map[string]interface{} {
                "fetchTickersFees": true,
            },
            "withdraw": map[string]interface{} {
                "includeFee": false,
            },
            "versions": map[string]interface{} {
                "public": map[string]interface{} {
                    "GET": map[string]interface{} {
                        "currencies": "v3",
                        "currencies/{currency}": "v3",
                        "symbols": "v2",
                        "mark-price/all-symbols": "v3",
                        "announcements": "v3",
                    },
                },
                "private": map[string]interface{} {
                    "GET": map[string]interface{} {
                        "user-info": "v2",
                        "hf/margin/account/ledgers": "v3",
                        "sub/user": "v2",
                        "sub-accounts": "v2",
                        "margin/accounts": "v3",
                        "isolated/accounts": "v3",
                        "deposit-addresses": "v1",
                        "market/orderbook/level2": "v3",
                        "market/orderbook/level3": "v3",
                        "market/orderbook/level{level}": "v3",
                        "oco/order/{orderId}": "v3",
                        "oco/order/details/{orderId}": "v3",
                        "oco/client-order/{clientOid}": "v3",
                        "oco/orders": "v3",
                        "hf/margin/orders/active": "v3",
                        "hf/margin/order/active/symbols": "v3",
                        "hf/margin/orders/done": "v3",
                        "hf/margin/orders/{orderId}": "v3",
                        "hf/margin/orders/client-order/{clientOid}": "v3",
                        "hf/margin/fills": "v3",
                        "etf/info": "v3",
                        "margin/currencies": "v3",
                        "margin/borrow": "v3",
                        "margin/repay": "v3",
                        "margin/interest": "v3",
                        "project/list": "v3",
                        "project/marketInterestRate": "v3",
                        "redeem/orders": "v3",
                        "purchase/orders": "v3",
                        "migrate/user/account/status": "v3",
                        "margin/symbols": "v3",
                        "affiliate/inviter/statistics": "v2",
                        "asset/ndbroker/deposit/list": "v1",
                    },
                    "POST": map[string]interface{} {
                        "sub/user/created": "v2",
                        "accounts/universal-transfer": "v3",
                        "accounts/sub-transfer": "v2",
                        "accounts/inner-transfer": "v2",
                        "transfer-out": "v3",
                        "deposit-address/create": "v3",
                        "oco/order": "v3",
                        "hf/margin/order": "v3",
                        "hf/margin/order/test": "v3",
                        "margin/borrow": "v3",
                        "margin/repay": "v3",
                        "purchase": "v3",
                        "redeem": "v3",
                        "lend/purchase/update": "v3",
                        "position/update-user-leverage": "v3",
                        "withdrawals": "v3",
                    },
                    "DELETE": map[string]interface{} {
                        "hf/margin/orders/{orderId}": "v3",
                        "hf/margin/orders/client-order/{clientOid}": "v3",
                        "hf/margin/orders": "v3",
                        "oco/order/{orderId}": "v3",
                        "oco/client-order/{clientOid}": "v3",
                        "oco/orders": "v3",
                    },
                },
                "futuresPrivate": map[string]interface{} {
                    "POST": map[string]interface{} {
                        "transfer-out": "v3",
                    },
                },
            },
            "partner": map[string]interface{} {
                "spot": map[string]interface{} {
                    "id": "ccxt",
                    "key": "9e58cc35-5b5e-4133-92ec-166e3f077cb8",
                },
                "future": map[string]interface{} {
                    "id": "ccxtfutures",
                    "key": "1b327198-f30c-4f14-a0ac-918871282f15",
                },
            },
            "accountsByType": map[string]interface{} {
                "spot": "trade",
                "margin": "margin",
                "cross": "margin",
                "isolated": "isolated",
                "main": "main",
                "funding": "main",
                "future": "contract",
                "swap": "contract",
                "mining": "pool",
                "hf": "trade_hf",
            },
            "networks": map[string]interface{} {
                "BRC20": "btc",
                "BTCNATIVESEGWIT": "bech32",
                "ERC20": "eth",
                "TRC20": "trx",
                "HRC20": "heco",
                "MATIC": "matic",
                "KCC": "kcc",
                "SOL": "sol",
                "ALGO": "algo",
                "EOS": "eos",
                "BEP20": "bsc",
                "BEP2": "bnb",
                "ARBONE": "arbitrum",
                "AVAXX": "avax",
                "AVAXC": "avaxc",
                "TLOS": "tlos",
                "CFX": "cfx",
                "ACA": "aca",
                "OP": "optimism",
                "ONT": "ont",
                "GLMR": "glmr",
                "CSPR": "cspr",
                "KLAY": "klay",
                "XRD": "xrd",
                "RVN": "rvn",
                "NEAR": "near",
                "APT": "aptos",
                "ETHW": "ethw",
                "TON": "ton",
                "BCH": "bch",
                "BSV": "bchsv",
                "BCHA": "bchabc",
                "OSMO": "osmo",
                "NANO": "nano",
                "XLM": "xlm",
                "VET": "vet",
                "IOST": "iost",
                "ZIL": "zil",
                "XRP": "xrp",
                "TOMO": "tomo",
                "XMR": "xmr",
                "COTI": "coti",
                "XTZ": "xtz",
                "ADA": "ada",
                "WAX": "waxp",
                "THETA": "theta",
                "ONE": "one",
                "IOTEX": "iotx",
                "NULS": "nuls",
                "KSM": "ksm",
                "LTC": "ltc",
                "WAVES": "waves",
                "DOT": "dot",
                "STEEM": "steem",
                "QTUM": "qtum",
                "DOGE": "doge",
                "FIL": "fil",
                "XYM": "xym",
                "FLUX": "flux",
                "ATOM": "atom",
                "XDC": "xdc",
                "KDA": "kda",
                "ICP": "icp",
                "CELO": "celo",
                "LSK": "lsk",
                "VSYS": "vsys",
                "KAR": "kar",
                "XCH": "xch",
                "FLOW": "flow",
                "BAND": "band",
                "EGLD": "egld",
                "HBAR": "hbar",
                "XPR": "xpr",
                "AR": "ar",
                "FTM": "ftm",
                "KAVA": "kava",
                "KMA": "kma",
                "XEC": "xec",
                "IOTA": "iota",
                "HNT": "hnt",
                "ASTR": "astr",
                "PDEX": "pdex",
                "METIS": "metis",
                "ZEC": "zec",
                "POKT": "pokt",
                "OASYS": "oas",
                "OASIS": "oasis",
                "ETC": "etc",
                "AKT": "akt",
                "FSN": "fsn",
                "SCRT": "scrt",
                "CFG": "cfg",
                "ICX": "icx",
                "KMD": "kmd",
                "NEM": "NEM",
                "STX": "stx",
                "DGB": "dgb",
                "DCR": "dcr",
                "CKB": "ckb",
                "ELA": "ela",
                "HYDRA": "hydra",
                "BTM": "btm",
                "KARDIA": "kai",
                "SXP": "sxp",
                "NEBL": "nebl",
                "ZEN": "zen",
                "SDN": "sdn",
                "LTO": "lto",
                "WEMIX": "wemix",
                "EVER": "ever",
                "BNC": "bnc",
                "BNCDOT": "bncdot",
                "AION": "aion",
                "GRIN": "grin",
                "LOKI": "loki",
                "QKC": "qkc",
                "TT": "TT",
                "PIVX": "pivx",
                "SERO": "sero",
                "METER": "meter",
                "STATEMINE": "statemine",
                "DVPN": "dvpn",
                "XPRT": "xprt",
                "MOVR": "movr",
                "ERGO": "ergo",
                "ABBC": "abbc",
                "DIVI": "divi",
                "PURA": "pura",
                "DFI": "dfi",
                "NEON3": "neon3",
                "DOCK": "dock",
                "TRUE": "true",
                "CS": "cs",
                "ORAI": "orai",
                "BASE": "base",
            },
            "marginModes": map[string]interface{} {
                "cross": "MARGIN_TRADE",
                "isolated": "MARGIN_ISOLATED_TRADE",
                "spot": "TRADE",
            },
        },
        "features": map[string]interface{} {
            "spot": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": true,
                    "triggerPrice": true,
                    "triggerPriceType": nil,
                    "triggerDirection": false,
                    "stopLossPrice": true,
                    "takeProfitPrice": true,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": true,
                        "FOK": true,
                        "PO": true,
                        "GTD": true,
                    },
                    "hedged": false,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyByCost": true,
                    "marketBuyRequiresPrice": false,
                    "selfTradePrevention": true,
                    "iceberg": true,
                },
                "createOrders": map[string]interface{} {
                    "max": 5,
                },
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": true,
                    "limit": nil,
                    "daysBack": nil,
                    "untilDays": 7,
                    "symbolRequired": true,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": true,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": true,
                    "limit": 500,
                    "trigger": true,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchOrders": nil,
                "fetchClosedOrders": map[string]interface{} {
                    "marginMode": true,
                    "limit": 500,
                    "daysBack": nil,
                    "daysBackCanceled": nil,
                    "untilDays": 7,
                    "trigger": true,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchOHLCV": map[string]interface{} {
                    "limit": 1500,
                },
            },
            "swap": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
    })
}
func  (this *kucoin) Nonce() interface{}  {
    return Subtract(this.Milliseconds(), GetValue(this.Options, "timeDifference"))
}
/**
 * @method
 * @name kucoin#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @see https://docs.kucoin.com/#server-time
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func  (this *kucoin) FetchTime(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetTimestamp(params))
            PanicOnError(response)
        
                //
            //     {
            //         "code":"200000",
            //         "msg":"success",
            //         "data":1546837113087
            //     }
            //
        ch <- this.SafeInteger(response, "data")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoin#fetchStatus
 * @description the latest known information on the availability of the exchange API
 * @see https://docs.kucoin.com/#service-status
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [status structure]{@link https://docs.ccxt.com/#/?id=exchange-status-structure}
 */
func  (this *kucoin) FetchStatus(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetStatus(params))
            PanicOnError(response)
            //
            //     {
            //         "code":"200000",
            //         "data":{
            //             "status":"open", //open, close, cancelonly
            //             "msg":"upgrade match engine" //remark for operation
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var status interface{} = this.SafeString(data, "status")
        
            ch <- map[string]interface{} {
                "status": Ternary(IsTrue((IsEqual(status, "open"))), "ok", "maintenance"),
                "updated": nil,
                "eta": nil,
                "url": nil,
                "info": response,
            }
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoin#fetchMarkets
 * @description retrieves data on all markets for kucoin
 * @see https://docs.kucoin.com/#get-symbols-list-deprecated
 * @see https://docs.kucoin.com/#get-all-tickers
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *kucoin) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var fetchTickersFees interface{} = nil
            fetchTickersFeesparamsVariable := this.HandleOptionAndParams(params, "fetchMarkets", "fetchTickersFees", true);
            fetchTickersFees = GetValue(fetchTickersFeesparamsVariable,0);
            params = GetValue(fetchTickersFeesparamsVariable,1)
            var promises interface{} = []interface{}{}
            AppendToArray(&promises,this.PublicGetSymbols(params))
            //
            //     {
            //         "code": "200000",
            //         "data": [
            //             {
            //                 "symbol": "XLM-USDT",
            //                 "name": "XLM-USDT",
            //                 "baseCurrency": "XLM",
            //                 "quoteCurrency": "USDT",
            //                 "feeCurrency": "USDT",
            //                 "market": "USDS",
            //                 "baseMinSize": "0.1",
            //                 "quoteMinSize": "0.01",
            //                 "baseMaxSize": "10000000000",
            //                 "quoteMaxSize": "99999999",
            //                 "baseIncrement": "0.0001",
            //                 "quoteIncrement": "0.000001",
            //                 "priceIncrement": "0.000001",
            //                 "priceLimitRate": "0.1",
            //                 "isMarginEnabled": true,
            //                 "enableTrading": true
            //             },
            //
            var credentialsSet interface{} = this.CheckRequiredCredentials(false)
            var requestMarginables interface{} = IsTrue(credentialsSet) && IsTrue(this.SafeBool(params, "marginables", true))
            if IsTrue(requestMarginables) {
                AppendToArray(&promises,this.PrivateGetMarginSymbols(params)) // cross margin symbols
                //
                //    {
                //        "code": "200000",
                //        "data": {
                //            "timestamp": 1719393213421,
                //            "items": [
                //                {
                //                    // same object as in market, with one additional field:
                //                    "minFunds": "0.1"
                //                },
                //
                AppendToArray(&promises,this.PrivateGetIsolatedSymbols(params)) // isolated margin symbols
            }
            if IsTrue(fetchTickersFees) {
                AppendToArray(&promises,this.PublicGetMarketAllTickers(params))
            }
            if IsTrue(credentialsSet) {
                // load migration status for account
                AppendToArray(&promises,this.LoadMigrationStatus())
            }
        
            responses:= (<-promiseAll(promises))
            PanicOnError(responses)
            var symbolsData interface{} = this.SafeList(GetValue(responses, 0), "data")
            var crossData interface{} = Ternary(IsTrue(requestMarginables), this.SafeDict(GetValue(responses, 1), "data", map[string]interface{} {}), map[string]interface{} {})
            var crossItems interface{} = this.SafeList(crossData, "items", []interface{}{})
            var crossById interface{} = this.IndexBy(crossItems, "symbol")
            var isolatedData interface{} = Ternary(IsTrue(requestMarginables), GetValue(responses, 2), map[string]interface{} {})
            var isolatedItems interface{} = this.SafeList(isolatedData, "data", []interface{}{})
            var isolatedById interface{} = this.IndexBy(isolatedItems, "symbol")
            var tickersIdx interface{} = Ternary(IsTrue(requestMarginables), 3, 1)
            var tickersResponse interface{} = this.SafeDict(responses, tickersIdx, map[string]interface{} {})
            var tickerItems interface{} = this.SafeList(this.SafeDict(tickersResponse, "data", map[string]interface{} {}), "ticker", []interface{}{})
            var tickersById interface{} = this.IndexBy(tickerItems, "symbol")
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(symbolsData)); i++ {
                var market interface{} = GetValue(symbolsData, i)
                var id interface{} = this.SafeString(market, "symbol")
                baseIdquoteIdVariable := Split(id, "-");
                baseId := GetValue(baseIdquoteIdVariable,0);
                quoteId := GetValue(baseIdquoteIdVariable,1)
                var base interface{} = this.SafeCurrencyCode(baseId)
                var quote interface{} = this.SafeCurrencyCode(quoteId)
                // const quoteIncrement = this.safeNumber (market, 'quoteIncrement');
                var ticker interface{} = this.SafeDict(tickersById, id, map[string]interface{} {})
                var makerFeeRate interface{} = this.SafeString(ticker, "makerFeeRate")
                var takerFeeRate interface{} = this.SafeString(ticker, "takerFeeRate")
                var makerCoefficient interface{} = this.SafeString(ticker, "makerCoefficient")
                var takerCoefficient interface{} = this.SafeString(ticker, "takerCoefficient")
                var hasCrossMargin interface{} =         (InOp(crossById, id))
                var hasIsolatedMargin interface{} =         (InOp(isolatedById, id))
                var isMarginable interface{} = IsTrue(IsTrue(this.SafeBool(market, "isMarginEnabled", false)) || IsTrue(hasCrossMargin)) || IsTrue(hasIsolatedMargin)
                AppendToArray(&result,map[string]interface{} {
                    "id": id,
                    "symbol": Add(Add(base, "/"), quote),
                    "base": base,
                    "quote": quote,
                    "settle": nil,
                    "baseId": baseId,
                    "quoteId": quoteId,
                    "settleId": nil,
                    "type": "spot",
                    "spot": true,
                    "margin": isMarginable,
                    "marginModes": map[string]interface{} {
                        "cross": hasCrossMargin,
                        "isolated": hasIsolatedMargin,
                    },
                    "swap": false,
                    "future": false,
                    "option": false,
                    "active": this.SafeBool(market, "enableTrading"),
                    "contract": false,
                    "linear": nil,
                    "inverse": nil,
                    "taker": this.ParseNumber(Precise.StringMul(takerFeeRate, takerCoefficient)),
                    "maker": this.ParseNumber(Precise.StringMul(makerFeeRate, makerCoefficient)),
                    "contractSize": nil,
                    "expiry": nil,
                    "expiryDatetime": nil,
                    "strike": nil,
                    "optionType": nil,
                    "precision": map[string]interface{} {
                        "amount": this.SafeNumber(market, "baseIncrement"),
                        "price": this.SafeNumber(market, "priceIncrement"),
                    },
                    "limits": map[string]interface{} {
                        "leverage": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "amount": map[string]interface{} {
                            "min": this.SafeNumber(market, "baseMinSize"),
                            "max": this.SafeNumber(market, "baseMaxSize"),
                        },
                        "price": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "cost": map[string]interface{} {
                            "min": this.SafeNumber(market, "quoteMinSize"),
                            "max": this.SafeNumber(market, "quoteMaxSize"),
                        },
                    },
                    "created": nil,
                    "info": market,
                })
            }
            if IsTrue(GetValue(this.Options, "adjustForTimeDifference")) {
        
                retRes131212 := (<-this.LoadTimeDifference())
                PanicOnError(retRes131212)
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoin#loadMigrationStatus
 * @param {boolean} force load account state for non hf
 * @description loads the migration status for the account (hf or not)
 * @see https://www.kucoin.com/docs/rest/spot-trading/spot-hf-trade-pro-account/get-user-type
 * @returns {any} ignore
 */
func  (this *kucoin) LoadMigrationStatus(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    force := GetArg(optionalArgs, 0, false)
            _ = force
            if IsTrue(IsTrue(!IsTrue((InOp(this.Options, "hf"))) || IsTrue((IsEqual(GetValue(this.Options, "hf"), nil)))) || IsTrue(force)) {
        
                result:= (<-this.PrivateGetHfAccountsOpened())
                PanicOnError(result)
                AddElementToObject(this.Options, "hf", this.SafeBool(result, "data"))
            }
        
            ch <- true
            return nil
        
            }()
            return ch
        }
func  (this *kucoin) HandleHfAndParams(optionalArgs ...interface{}) interface{}  {
    params := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = params
    var migrated interface{} = this.SafeBool(this.Options, "hf", false)
    var loadedHf interface{} = nil
    if IsTrue(!IsEqual(migrated, nil)) {
        if IsTrue(migrated) {
            loadedHf = true
        } else {
            loadedHf = false
        }
    }
    var hf interface{} = this.SafeBool(params, "hf", loadedHf)
    params = this.Omit(params, "hf")
    return []interface{}{hf, params}
}
/**
 * @method
 * @name kucoin#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see https://docs.kucoin.com/#get-currencies
 * @param {object} params extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func  (this *kucoin) FetchCurrencies(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetCurrencies(params))
            PanicOnError(response)
            //
            //    {
            //        "code":"200000",
            //        "data":[
            //           {
            //              "currency":"CSP",
            //              "name":"CSP",
            //              "fullName":"Caspian",
            //              "precision":8,
            //              "confirms":null,
            //              "contractAddress":null,
            //              "isMarginEnabled":false,
            //              "isDebitEnabled":false,
            //              "chains":[
            //                 {
            //                    "chainName":"ERC20",
            //                    "chainId": "eth"
            //                    "withdrawalMinSize":"2999",
            //                    "depositMinSize":null,
            //                    "withdrawFeeRate":"0",
            //                    "withdrawalMinFee":"2999",
            //                    "isWithdrawEnabled":false,
            //                    "isDepositEnabled":false,
            //                    "confirms":12,
            //                    "preConfirms":12,
            //                    "withdrawPrecision": 8,
            //                    "maxWithdraw": null,
            //                    "maxDeposit": null,
            //                    "needTag": false,
            //                    "contractAddress":"0xa6446d655a0c34bc4f05042ee88170d056cbaf45",
            //                    "depositFeeRate": "0.001", // present for some currencies/networks
            //                 }
            //              ]
            //           },
            //        ]
            //    }
            //
            var currenciesData interface{} = this.SafeList(response, "data", []interface{}{})
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(currenciesData)); i++ {
                var entry interface{} = GetValue(currenciesData, i)
                var id interface{} = this.SafeString(entry, "currency")
                var name interface{} = this.SafeString(entry, "fullName")
                var code interface{} = this.SafeCurrencyCode(id)
                var networks interface{} = map[string]interface{} {}
                var chains interface{} = this.SafeList(entry, "chains", []interface{}{})
                var rawPrecision interface{} = this.SafeString(entry, "precision")
                var precision interface{} = this.ParseNumber(this.ParsePrecision(rawPrecision))
                var chainsLength interface{} =         GetArrayLength(chains)
                if !IsTrue(chainsLength) {
                    continue
                }
                for j := 0; IsLessThan(j, chainsLength); j++ {
                    var chain interface{} = GetValue(chains, j)
                    var chainId interface{} = this.SafeString(chain, "chainId")
                    var networkCode interface{} = this.NetworkIdToCode(chainId, code)
                    var chainWithdrawEnabled interface{} = this.SafeBool(chain, "isWithdrawEnabled", false)
                    var chainDepositEnabled interface{} = this.SafeBool(chain, "isDepositEnabled", false)
                    AddElementToObject(networks, networkCode, map[string]interface{} {
            "info": chain,
            "id": chainId,
            "name": this.SafeString(chain, "chainName"),
            "code": networkCode,
            "active": IsTrue(chainWithdrawEnabled) && IsTrue(chainDepositEnabled),
            "fee": this.SafeNumber(chain, "withdrawalMinFee"),
            "deposit": chainDepositEnabled,
            "withdraw": chainWithdrawEnabled,
            "precision": this.ParseNumber(this.ParsePrecision(this.SafeString(chain, "withdrawPrecision"))),
            "limits": map[string]interface{} {
                "withdraw": map[string]interface{} {
                    "min": this.SafeNumber(chain, "withdrawalMinSize"),
                    "max": this.SafeNumber(chain, "maxWithdraw"),
                },
                "deposit": map[string]interface{} {
                    "min": this.SafeNumber(chain, "depositMinSize"),
                    "max": this.SafeNumber(chain, "maxDeposit"),
                },
            },
        })
                }
                // kucoin has determined 'fiat' currencies with below logic
                var isFiat interface{} = IsTrue((IsEqual(rawPrecision, "2"))) && IsTrue((IsEqual(chainsLength, 0)))
                AddElementToObject(result, code, this.SafeCurrencyStructure(map[string]interface{} {
            "id": id,
            "name": name,
            "code": code,
            "type": Ternary(IsTrue(isFiat), "fiat", "crypto"),
            "precision": precision,
            "info": entry,
            "networks": networks,
            "deposit": nil,
            "withdraw": nil,
            "active": nil,
            "fee": nil,
            "limits": nil,
        }))
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoin#fetchAccounts
 * @description fetch all the accounts associated with a profile
 * @see https://docs.kucoin.com/#list-accounts
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/#/?id=account-structure} indexed by the account type
 */
func  (this *kucoin) FetchAccounts(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PrivateGetAccounts(params))
            PanicOnError(response)
            //
            //     {
            //         "code": "200000",
            //         "data": [
            //             {
            //                 "balance": "0.00009788",
            //                 "available": "0.00009788",
            //                 "holds": "0",
            //                 "currency": "BTC",
            //                 "id": "5c6a4fd399a1d81c4f9cc4d0",
            //                 "type": "trade"
            //             },
            //             {
            //                 "balance": "0.00000001",
            //                 "available": "0.00000001",
            //                 "holds": "0",
            //                 "currency": "ETH",
            //                 "id": "5c6a49ec99a1d819392e8e9f",
            //                 "type": "trade"
            //             }
            //         ]
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
                var account interface{} = GetValue(data, i)
                var accountId interface{} = this.SafeString(account, "id")
                var currencyId interface{} = this.SafeString(account, "currency")
                var code interface{} = this.SafeCurrencyCode(currencyId)
                var typeVar interface{} = this.SafeString(account, "type") // main or trade
                AppendToArray(&result,map[string]interface{} {
                    "id": accountId,
                    "type": typeVar,
                    "currency": code,
                    "code": code,
                    "info": account,
                })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoin#fetchTransactionFee
 * @description *DEPRECATED* please use fetchDepositWithdrawFee instead
 * @see https://docs.kucoin.com/#get-withdrawal-quotas
 * @param {string} code unified currency code
 * @param {object} params extra parameters specific to the exchange API endpoint
 * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func  (this *kucoin) FetchTransactionFee(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes15218 := (<-this.LoadMarkets())
            PanicOnError(retRes15218)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "currency": GetValue(currency, "id"),
            }
            var networkCode interface{} = nil
            networkCodeparamsVariable := this.HandleNetworkCodeAndParams(params);
            networkCode = GetValue(networkCodeparamsVariable,0);
            params = GetValue(networkCodeparamsVariable,1)
            if IsTrue(!IsEqual(networkCode, nil)) {
                AddElementToObject(request, "chain", ToLower(this.NetworkCodeToId(networkCode)))
            }
        
            response:= (<-this.PrivateGetWithdrawalsQuotas(this.Extend(request, params)))
            PanicOnError(response)
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var withdrawFees interface{} = map[string]interface{} {}
            AddElementToObject(withdrawFees, code, this.SafeNumber(data, "withdrawMinFee"))
        
            ch <- map[string]interface{} {
                "info": response,
                "withdraw": withdrawFees,
                "deposit": map[string]interface{} {},
            }
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoin#fetchDepositWithdrawFee
 * @description fetch the fee for deposits and withdrawals
 * @see https://docs.kucoin.com/#get-withdrawal-quotas
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.network] The chain of currency. This only apply for multi-chain currency, and there is no need for single chain currency; you can query the chain through the response of the GET /api/v2/currencies/{currency} interface
 * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func  (this *kucoin) FetchDepositWithdrawFee(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes15538 := (<-this.LoadMarkets())
            PanicOnError(retRes15538)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "currency": GetValue(currency, "id"),
            }
            var networkCode interface{} = nil
            networkCodeparamsVariable := this.HandleNetworkCodeAndParams(params);
            networkCode = GetValue(networkCodeparamsVariable,0);
            params = GetValue(networkCodeparamsVariable,1)
            if IsTrue(!IsEqual(networkCode, nil)) {
                AddElementToObject(request, "chain", ToLower(this.NetworkCodeToId(networkCode)))
            }
        
            response:= (<-this.PrivateGetWithdrawalsQuotas(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "code": "200000",
            //        "data": {
            //            "currency": "USDT",
            //            "limitBTCAmount": "1.00000000",
            //            "usedBTCAmount": "0.00000000",
            //            "remainAmount": "16548.072149",
            //            "availableAmount": "0",
            //            "withdrawMinFee": "25",
            //            "innerWithdrawMinFee": "0",
            //            "withdrawMinSize": "50",
            //            "isWithdrawEnabled": true,
            //            "precision": 6,
            //            "chain": "ERC20"
            //        }
            //    }
            //
            var data interface{} = this.SafeDict(response, "data")
        
            ch <- this.ParseDepositWithdrawFee(data, currency)
            return nil
        
            }()
            return ch
        }
func  (this *kucoin) ParseDepositWithdrawFee(fee interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "currency": "USDT",
    //        "limitBTCAmount": "1.00000000",
    //        "usedBTCAmount": "0.00000000",
    //        "remainAmount": "16548.072149",
    //        "availableAmount": "0",
    //        "withdrawMinFee": "25",
    //        "innerWithdrawMinFee": "0",
    //        "withdrawMinSize": "50",
    //        "isWithdrawEnabled": true,
    //        "precision": 6,
    //        "chain": "ERC20"
    //    }
    //
    // if data obtained through `currencies` endpoint
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    if IsTrue(InOp(fee, "chains")) {
        var resultNew interface{} = map[string]interface{} {
            "info": fee,
            "withdraw": map[string]interface{} {
                "fee": nil,
                "percentage": false,
            },
            "deposit": map[string]interface{} {
                "fee": nil,
                "percentage": nil,
            },
            "networks": map[string]interface{} {},
        }
        var chains interface{} = this.SafeList(fee, "chains", []interface{}{})
        for i := 0; IsLessThan(i, GetArrayLength(chains)); i++ {
            var chain interface{} = GetValue(chains, i)
            var networkCodeNew interface{} = this.NetworkIdToCode(this.SafeString(chain, "chainId"), this.SafeString(currency, "code"))
            AddElementToObject(GetValue(resultNew, "networks"), networkCodeNew, map[string]interface{} {
    "withdraw": map[string]interface{} {
        "fee": this.SafeNumber(chain, "withdrawMinFee"),
        "percentage": false,
    },
    "deposit": map[string]interface{} {
        "fee": nil,
        "percentage": nil,
    },
})
        }
        return resultNew
    }
    var minWithdrawFee interface{} = this.SafeNumber(fee, "withdrawMinFee")
    var result interface{} = map[string]interface{} {
        "info": fee,
        "withdraw": map[string]interface{} {
            "fee": minWithdrawFee,
            "percentage": false,
        },
        "deposit": map[string]interface{} {
            "fee": nil,
            "percentage": nil,
        },
        "networks": map[string]interface{} {},
    }
    var networkId interface{} = this.SafeString(fee, "chain")
    var networkCode interface{} = this.NetworkIdToCode(networkId, this.SafeString(currency, "code"))
    AddElementToObject(GetValue(result, "networks"), networkCode, map[string]interface{} {
    "withdraw": minWithdrawFee,
    "deposit": map[string]interface{} {
        "fee": nil,
        "percentage": nil,
    },
})
    return result
}
func  (this *kucoin) IsFuturesMethod(methodName interface{}, params interface{}) interface{}  {
    //
    // Helper
    // @methodName (string): The name of the method
    // @params (dict): The parameters passed into {methodName}
    // @return: true if the method used is meant for futures trading, false otherwise
    //
    var defaultType interface{} = this.SafeString2(this.Options, methodName, "defaultType", "trade")
    var requestedType interface{} = this.SafeString(params, "type", defaultType)
    var accountsByType interface{} = this.SafeDict(this.Options, "accountsByType")
    var typeVar interface{} = this.SafeString(accountsByType, requestedType)
    if IsTrue(IsEqual(typeVar, nil)) {
        var keys interface{} = ObjectKeys(accountsByType)
        panic(ExchangeError(Add(Add(this.Id, " isFuturesMethod() type must be one of "), Join(keys, ", "))))
    }
    params = this.Omit(params, "type")
    return IsTrue(IsTrue((IsEqual(typeVar, "contract"))) || IsTrue((IsEqual(typeVar, "future")))) || IsTrue((IsEqual(typeVar, "futures")))  // * (type === 'futures') deprecated, use (type === 'future')
}
func  (this *kucoin) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "symbol": "BTC-USDT",   // symbol
    //         "symbolName":"BTC-USDT", // Name of trading pairs, it would change after renaming
    //         "buy": "11328.9",   // bestAsk
    //         "sell": "11329",    // bestBid
    //         "changeRate": "-0.0055",    // 24h change rate
    //         "changePrice": "-63.6", // 24h change price
    //         "high": "11610",    // 24h highest price
    //         "low": "11200", // 24h lowest price
    //         "vol": "2282.70993217", // 24h volume，the aggregated trading volume in BTC
    //         "volValue": "25984946.157790431",   // 24h total, the trading volume in quote currency of last 24 hours
    //         "last": "11328.9",  // last price
    //         "averagePrice": "11360.66065903",   // 24h average transaction price yesterday
    //         "takerFeeRate": "0.001",    // Basic Taker Fee
    //         "makerFeeRate": "0.001",    // Basic Maker Fee
    //         "takerCoefficient": "1",    // Taker Fee Coefficient
    //         "makerCoefficient": "1" // Maker Fee Coefficient
    //     }
    //
    //     {
    //         "trading": true,
    //         "symbol": "KCS-BTC",
    //         "buy": 0.00011,
    //         "sell": 0.00012,
    //         "sort": 100,
    //         "volValue": 3.13851792584,   //total
    //         "baseCurrency": "KCS",
    //         "market": "BTC",
    //         "quoteCurrency": "BTC",
    //         "symbolCode": "KCS-BTC",
    //         "datetime": 1548388122031,
    //         "high": 0.00013,
    //         "vol": 27514.34842,
    //         "low": 0.0001,
    //         "changePrice": -1.0e-5,
    //         "changeRate": -0.0769,
    //         "lastTradedPrice": 0.00012,
    //         "board": 0,
    //         "mark": 0
    //     }
    //
    // market/ticker ws subscription
    //
    //     {
    //         "bestAsk": "62258.9",
    //         "bestAskSize": "0.38579986",
    //         "bestBid": "62258.8",
    //         "bestBidSize": "0.0078381",
    //         "price": "62260.7",
    //         "sequence": "1621383297064",
    //         "size": "0.00002841",
    //         "time": 1634641777363
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var percentage interface{} = this.SafeString(ticker, "changeRate")
    if IsTrue(!IsEqual(percentage, nil)) {
        percentage = Precise.StringMul(percentage, "100")
    }
    var last interface{} = this.SafeString2(ticker, "last", "lastTradedPrice")
    last = this.SafeString(ticker, "price", last)
    var marketId interface{} = this.SafeString(ticker, "symbol")
    market = this.SafeMarket(marketId, market, "-")
    var symbol interface{} = GetValue(market, "symbol")
    var baseVolume interface{} = this.SafeString(ticker, "vol")
    var quoteVolume interface{} = this.SafeString(ticker, "volValue")
    var timestamp interface{} = this.SafeIntegerN(ticker, []interface{}{"time", "datetime", "timePoint"})
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeString(ticker, "high"),
        "low": this.SafeString(ticker, "low"),
        "bid": this.SafeString2(ticker, "buy", "bestBid"),
        "bidVolume": this.SafeString(ticker, "bestBidSize"),
        "ask": this.SafeString2(ticker, "sell", "bestAsk"),
        "askVolume": this.SafeString(ticker, "bestAskSize"),
        "vwap": nil,
        "open": this.SafeString(ticker, "open"),
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": this.SafeString(ticker, "changePrice"),
        "percentage": percentage,
        "average": this.SafeString(ticker, "averagePrice"),
        "baseVolume": baseVolume,
        "quoteVolume": quoteVolume,
        "markPrice": this.SafeString(ticker, "value"),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name kucoin#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://docs.kucoin.com/#get-all-tickers
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *kucoin) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes17808 := (<-this.LoadMarkets())
            PanicOnError(retRes17808)
            symbols = this.MarketSymbols(symbols)
        
            response:= (<-this.PublicGetMarketAllTickers(params))
            PanicOnError(response)
            //
            //     {
            //         "code": "200000",
            //         "data": {
            //             "time":1602832092060,
            //             "ticker":[
            //                 {
            //                     "symbol": "BTC-USDT",   // symbol
            //                     "symbolName":"BTC-USDT", // Name of trading pairs, it would change after renaming
            //                     "buy": "11328.9",   // bestAsk
            //                     "sell": "11329",    // bestBid
            //                     "changeRate": "-0.0055",    // 24h change rate
            //                     "changePrice": "-63.6", // 24h change price
            //                     "high": "11610",    // 24h highest price
            //                     "low": "11200", // 24h lowest price
            //                     "vol": "2282.70993217", // 24h volume，the aggregated trading volume in BTC
            //                     "volValue": "25984946.157790431",   // 24h total, the trading volume in quote currency of last 24 hours
            //                     "last": "11328.9",  // last price
            //                     "averagePrice": "11360.66065903",   // 24h average transaction price yesterday
            //                     "takerFeeRate": "0.001",    // Basic Taker Fee
            //                     "makerFeeRate": "0.001",    // Basic Maker Fee
            //                     "takerCoefficient": "1",    // Taker Fee Coefficient
            //                     "makerCoefficient": "1" // Maker Fee Coefficient
            //                 }
            //             ]
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var tickers interface{} = this.SafeList(data, "ticker", []interface{}{})
            var time interface{} = this.SafeInteger(data, "time")
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(tickers)); i++ {
                AddElementToObject(GetValue(tickers, i), "time", time)
                var ticker interface{} = this.ParseTicker(GetValue(tickers, i))
                var symbol interface{} = this.SafeString(ticker, "symbol")
                if IsTrue(!IsEqual(symbol, nil)) {
                    AddElementToObject(result, symbol, ticker)
                }
            }
        
            ch <- this.FilterByArrayTickers(result, "symbol", symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoin#fetchMarkPrices
 * @description fetches the mark price for multiple markets
 * @see https://www.kucoin.com/docs/rest/margin-trading/margin-info/get-all-margin-trading-pairs-mark-prices
 * @param {string[]} [symbols] unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *kucoin) FetchMarkPrices(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes18368 := (<-this.LoadMarkets())
            PanicOnError(retRes18368)
            symbols = this.MarketSymbols(symbols)
        
            response:= (<-this.PublicGetMarkPriceAllSymbols(params))
            PanicOnError(response)
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTickers(data)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoin#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://docs.kucoin.com/#get-24hr-stats
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *kucoin) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes18538 := (<-this.LoadMarkets())
            PanicOnError(retRes18538)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetMarketStats(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "200000",
            //         "data": {
            //             "time": 1602832092060,  // time
            //             "symbol": "BTC-USDT",   // symbol
            //             "buy": "11328.9",   // bestAsk
            //             "sell": "11329",    // bestBid
            //             "changeRate": "-0.0055",    // 24h change rate
            //             "changePrice": "-63.6", // 24h change price
            //             "high": "11610",    // 24h highest price
            //             "low": "11200", // 24h lowest price
            //             "vol": "2282.70993217", // 24h volume，the aggregated trading volume in BTC
            //             "volValue": "25984946.157790431",   // 24h total, the trading volume in quote currency of last 24 hours
            //             "last": "11328.9",  // last price
            //             "averagePrice": "11360.66065903",   // 24h average transaction price yesterday
            //             "takerFeeRate": "0.001",    // Basic Taker Fee
            //             "makerFeeRate": "0.001",    // Basic Maker Fee
            //             "takerCoefficient": "1",    // Taker Fee Coefficient
            //             "makerCoefficient": "1" // Maker Fee Coefficient
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseTicker(data, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoin#fetchMarkPrice
 * @description fetches the mark price for a specific market
 * @see https://www.kucoin.com/docs/rest/margin-trading/margin-info/get-mark-price
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *kucoin) FetchMarkPrice(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes18968 := (<-this.LoadMarkets())
            PanicOnError(retRes18968)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetMarkPriceSymbolCurrent(this.Extend(request, params)))
            PanicOnError(response)
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseTicker(data, market)
            return nil
        
            }()
            return ch
        }
func  (this *kucoin) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     [
    //         "1545904980",             // Start time of the candle cycle
    //         "0.058",                  // opening price
    //         "0.049",                  // closing price
    //         "0.058",                  // highest price
    //         "0.049",                  // lowest price
    //         "0.018",                  // base volume
    //         "0.000945",               // quote volume
    //     ]
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.SafeTimestamp(ohlcv, 0), this.SafeNumber(ohlcv, 1), this.SafeNumber(ohlcv, 3), this.SafeNumber(ohlcv, 4), this.SafeNumber(ohlcv, 2), this.SafeNumber(ohlcv, 5)}
}
/**
 * @method
 * @name kucoin#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://docs.kucoin.com/#get-klines
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *kucoin) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes19438 := (<-this.LoadMarkets())
            PanicOnError(retRes19438)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchOHLCV", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes194719 :=  (<-this.FetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, params, 1500))
                    PanicOnError(retRes194719)
                    ch <- retRes194719
                    return nil
            }
            var market interface{} = this.Market(symbol)
            var marketId interface{} = GetValue(market, "id")
            var request interface{} = map[string]interface{} {
                "symbol": marketId,
                "type": this.SafeString(this.Timeframes, timeframe, timeframe),
            }
            var duration interface{} = Multiply(this.ParseTimeframe(timeframe), 1000)
            var endAt interface{} = this.Milliseconds() // required param
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startAt", this.ParseToInt(MathFloor(Divide(since, 1000))))
                if IsTrue(IsEqual(limit, nil)) {
                    // https://docs.kucoin.com/#get-klines
                    // https://docs.kucoin.com/#details
                    // For each query, the system would return at most 1500 pieces of data.
                    // To obtain more data, please page the data by time.
                    limit = this.SafeInteger(this.Options, "fetchOHLCVLimit", 1500)
                }
                endAt = this.Sum(since, Multiply(limit, duration))
            } else if IsTrue(!IsEqual(limit, nil)) {
                since = Subtract(endAt, Multiply(limit, duration))
                AddElementToObject(request, "startAt", this.ParseToInt(MathFloor(Divide(since, 1000))))
            }
            AddElementToObject(request, "endAt", this.ParseToInt(MathFloor(Divide(endAt, 1000))))
        
            response:= (<-this.PublicGetMarketCandles(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code":"200000",
            //         "data":[
            //             ["1591517700","0.025078","0.025069","0.025084","0.025064","18.9883256","0.4761861079404"],
            //             ["1591516800","0.025089","0.025079","0.025089","0.02506","99.4716622","2.494143499081"],
            //             ["1591515900","0.025079","0.02509","0.025091","0.025068","59.83701271","1.50060885172798"],
            //         ]
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseOHLCVs(data, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoin#createDepositAddress
 * @see https://www.kucoin.com/docs/rest/funding/deposit/create-deposit-address-v3-
 * @description create a currency deposit address
 * @param {string} code unified currency code of the currency for the deposit address
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.network] the blockchain network name
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *kucoin) CreateDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes19988 := (<-this.LoadMarkets())
            PanicOnError(retRes19988)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "currency": GetValue(currency, "id"),
            }
            var networkCode interface{} = nil
            networkCodeparamsVariable := this.HandleNetworkCodeAndParams(params);
            networkCode = GetValue(networkCodeparamsVariable,0);
            params = GetValue(networkCodeparamsVariable,1)
            if IsTrue(!IsEqual(networkCode, nil)) {
                AddElementToObject(request, "chain", this.NetworkCodeToId(networkCode)) // docs mention "chain-name", but seems "chain-id" is used, like in "fetchDepositAddress"
            }
        
            response:= (<-this.PrivatePostDepositAddressCreate(this.Extend(request, params)))
            PanicOnError(response)
            // {"code":"260000","msg":"Deposit address already exists."}
            //
            //   {
            //     "code": "200000",
            //     "data": {
            //       "address": "0x2336d1834faab10b2dac44e468f2627138417431",
            //       "memo": null,
            //       "chainId": "bsc",
            //       "to": "MAIN",
            //       "expirationDate": 0,
            //       "currency": "BNB",
            //       "chainName": "BEP20"
            //     }
            //   }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseDepositAddress(data, currency)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoin#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account
 * @see https://docs.kucoin.com/#get-deposit-addresses-v2
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.network] the blockchain network name
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *kucoin) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes20398 := (<-this.LoadMarkets())
            PanicOnError(retRes20398)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "currency": GetValue(currency, "id"),
            }
            var networkCode interface{} = nil
            networkCodeparamsVariable := this.HandleNetworkCodeAndParams(params);
            networkCode = GetValue(networkCodeparamsVariable,0);
            params = GetValue(networkCodeparamsVariable,1)
            if IsTrue(!IsEqual(networkCode, nil)) {
                AddElementToObject(request, "chain", ToLower(this.NetworkCodeToId(networkCode)))
            }
            var version interface{} = GetValue(GetValue(GetValue(GetValue(this.Options, "versions"), "private"), "GET"), "deposit-addresses")
            AddElementToObject(GetValue(GetValue(GetValue(this.Options, "versions"), "private"), "GET"), "deposit-addresses", "v1")
        
            response:= (<-this.PrivateGetDepositAddresses(this.Extend(request, params)))
            PanicOnError(response)
            // BCH {"code":"200000","data":{"address":"bitcoincash:qza3m4nj9rx7l9r0cdadfqxts6f92shvhvr5ls4q7z","memo":""}}
            // BTC {"code":"200000","data":{"address":"36SjucKqQpQSvsak9A7h6qzFjrVXpRNZhE","memo":""}}
            AddElementToObject(GetValue(GetValue(GetValue(this.Options, "versions"), "private"), "GET"), "deposit-addresses", version)
            var data interface{} = this.SafeValue(response, "data")
            if IsTrue(IsEqual(data, nil)) {
                panic(ExchangeError(Add(this.Id, " fetchDepositAddress() returned an empty response, you might try to run createDepositAddress() first and try again")))
            }
        
            ch <- this.ParseDepositAddress(data, currency)
            return nil
        
            }()
            return ch
        }
func  (this *kucoin) ParseDepositAddress(depositAddress interface{}, optionalArgs ...interface{}) interface{}  {
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var address interface{} = this.SafeString(depositAddress, "address")
    // BCH/BSV is returned with a "bitcoincash:" prefix, which we cut off here and only keep the address
    if IsTrue(!IsEqual(address, nil)) {
        address = Replace(address, "bitcoincash:", "")
    }
    var code interface{} = nil
    if IsTrue(!IsEqual(currency, nil)) {
        code = this.SafeCurrencyCode(GetValue(currency, "id"))
        if IsTrue(!IsEqual(code, "NIM")) {
            // contains spaces
            this.CheckAddress(address)
        }
    }
    return map[string]interface{} {
        "info": depositAddress,
        "currency": code,
        "network": this.NetworkIdToCode(this.SafeString(depositAddress, "chainId")),
        "address": address,
        "tag": this.SafeString(depositAddress, "memo"),
    }
}
/**
 * @method
 * @name kucoin#fetchDepositAddressesByNetwork
 * @see https://docs.kucoin.com/#get-deposit-addresses-v2
 * @description fetch the deposit address for a currency associated with this account
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an array of [address structures]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *kucoin) FetchDepositAddressesByNetwork(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes20988 := (<-this.LoadMarkets())
            PanicOnError(retRes20988)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "currency": GetValue(currency, "id"),
            }
            var version interface{} = GetValue(GetValue(GetValue(GetValue(this.Options, "versions"), "private"), "GET"), "deposit-addresses")
            AddElementToObject(GetValue(GetValue(GetValue(this.Options, "versions"), "private"), "GET"), "deposit-addresses", "v2")
        
            response:= (<-this.PrivateGetDepositAddresses(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "200000",
            //         "data": [
            //             {
            //                 "address": "fr1qvus7d4d5fgxj5e7zvqe6yhxd7txm95h2and69r",
            //                 "memo": "",
            //                 "chain": "BTC-Segwit",
            //                 "contractAddress": ""
            //             },
            //             {"address":"37icNMEWbiF8ZkwUMxmfzMxi2A1MQ44bMn","memo":"","chain":"BTC","contractAddress":""},
            //             {"address":"Deposit temporarily blocked","memo":"","chain":"TRC20","contractAddress":""}
            //         ]
            //     }
            //
            AddElementToObject(GetValue(GetValue(GetValue(this.Options, "versions"), "private"), "GET"), "deposit-addresses", version)
            var chains interface{} = this.SafeList(response, "data", []interface{}{})
            var parsed interface{} = this.ParseDepositAddresses(chains, []interface{}{GetValue(currency, "code")}, false, map[string]interface{} {
                "currency": GetValue(currency, "code"),
            })
        
            ch <- this.IndexBy(parsed, "network")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoin#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://www.kucoin.com/docs/rest/spot-trading/market-data/get-part-order-book-aggregated-
 * @see https://www.kucoin.com/docs/rest/spot-trading/market-data/get-full-order-book-aggregated-
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *kucoin) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes21418 := (<-this.LoadMarkets())
            PanicOnError(retRes21418)
            var market interface{} = this.Market(symbol)
            var level interface{} = this.SafeInteger(params, "level", 2)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var isAuthenticated interface{} = this.CheckRequiredCredentials(false)
            var response interface{} = nil
            if IsTrue(!IsTrue(isAuthenticated) || IsTrue(!IsEqual(limit, nil))) {
                if IsTrue(IsEqual(level, 2)) {
                    AddElementToObject(request, "level", level)
                    if IsTrue(!IsEqual(limit, nil)) {
                        if IsTrue(IsTrue((IsEqual(limit, 20))) || IsTrue((IsEqual(limit, 100)))) {
                            AddElementToObject(request, "limit", limit)
                        } else {
                            panic(ExchangeError(Add(this.Id, " fetchOrderBook() limit argument must be 20 or 100")))
                        }
                    }
                    AddElementToObject(request, "limit", Ternary(IsTrue(limit), limit, 100))
                }
                
        response = (<-this.PublicGetMarketOrderbookLevelLevelLimit(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PrivateGetMarketOrderbookLevel2(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            // public (v1) market/orderbook/level2_20 and market/orderbook/level2_100
            //
            //     {
            //         "sequence": "3262786978",
            //         "time": 1550653727731,
            //         "bids": [
            //             ["6500.12", "0.45054140"],
            //             ["6500.11", "0.45054140"],
            //         ],
            //         "asks": [
            //             ["6500.16", "0.57753524"],
            //             ["6500.15", "0.57753524"],
            //         ]
            //     }
            //
            // private (v3) market/orderbook/level2
            //
            //     {
            //         "sequence": "3262786978",
            //         "time": 1550653727731,
            //         "bids": [
            //             ["6500.12", "0.45054140"],
            //             ["6500.11", "0.45054140"],
            //         ],
            //         "asks": [
            //             ["6500.16", "0.57753524"],
            //             ["6500.15", "0.57753524"],
            //         ]
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var timestamp interface{} = this.SafeInteger(data, "time")
            var orderbook interface{} = this.ParseOrderBook(data, GetValue(market, "symbol"), timestamp, "bids", "asks", Subtract(level, 2), Subtract(level, 1))
            AddElementToObject(orderbook, "nonce", this.SafeInteger(data, "sequence"))
        
            ch <- orderbook
            return nil
        
            }()
            return ch
        }
func  (this *kucoin) HandleTriggerPrices(params interface{}) interface{}  {
    var triggerPrice interface{} = this.SafeValue2(params, "triggerPrice", "stopPrice")
    var stopLossPrice interface{} = this.SafeValue(params, "stopLossPrice")
    var takeProfitPrice interface{} = this.SafeValue(params, "takeProfitPrice")
    var isStopLoss interface{} = !IsEqual(stopLossPrice, nil)
    var isTakeProfit interface{} = !IsEqual(takeProfitPrice, nil)
    if IsTrue(IsTrue(IsTrue((IsTrue(isStopLoss) && IsTrue(isTakeProfit))) || IsTrue((IsTrue(triggerPrice) && IsTrue(stopLossPrice)))) || IsTrue((IsTrue(triggerPrice) && IsTrue(isTakeProfit)))) {
        panic(ExchangeError(Add(this.Id, " createOrder() - you should use either triggerPrice or stopLossPrice or takeProfitPrice")))
    }
    return []interface{}{triggerPrice, stopLossPrice, takeProfitPrice}
}
/**
 * @method
 * @name kucoin#createOrder
 * @description Create an order on the exchange
 * @see https://docs.kucoin.com/spot#place-a-new-order
 * @see https://docs.kucoin.com/spot#place-a-new-order-2
 * @see https://docs.kucoin.com/spot#place-a-margin-order
 * @see https://docs.kucoin.com/spot-hf/#place-hf-order
 * @see https://www.kucoin.com/docs/rest/spot-trading/orders/place-order-test
 * @see https://www.kucoin.com/docs/rest/margin-trading/orders/place-margin-order-test
 * @see https://www.kucoin.com/docs/rest/spot-trading/spot-hf-trade-pro-account/sync-place-hf-order
 * @param {string} symbol Unified CCXT market symbol
 * @param {string} type 'limit' or 'market'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount the amount of currency to trade
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params]  extra parameters specific to the exchange API endpoint
 * @param {float} [params.triggerPrice] The price at which a trigger order is triggered at
 * @param {string} [params.marginMode] 'cross', // cross (cross mode) and isolated (isolated mode), set to cross by default, the isolated mode will be released soon, stay tuned
 * @param {string} [params.timeInForce] GTC, GTT, IOC, or FOK, default is GTC, limit orders only
 * @param {string} [params.postOnly] Post only flag, invalid when timeInForce is IOC or FOK
 *
 * EXCHANGE SPECIFIC PARAMETERS
 * @param {string} [params.clientOid] client order id, defaults to uuid if not passed
 * @param {string} [params.remark] remark for the order, length cannot exceed 100 utf8 characters
 * @param {string} [params.tradeType] 'TRADE', // TRADE, MARGIN_TRADE // not used with margin orders
 * limit orders ---------------------------------------------------
 * @param {float} [params.cancelAfter] long, // cancel after n seconds, requires timeInForce to be GTT
 * @param {bool} [params.hidden] false, // Order will not be displayed in the order book
 * @param {bool} [params.iceberg] false, // Only a portion of the order is displayed in the order book
 * @param {string} [params.visibleSize] this.amountToPrecision (symbol, visibleSize), // The maximum visible size of an iceberg order
 * market orders --------------------------------------------------
 * @param {string} [params.funds] // Amount of quote currency to use
 * stop orders ----------------------------------------------------
 * @param {string} [params.stop]  Either loss or entry, the default is loss. Requires triggerPrice to be defined
 * margin orders --------------------------------------------------
 * @param {float} [params.leverage] Leverage size of the order
 * @param {string} [params.stp] '', // self trade prevention, CN, CO, CB or DC
 * @param {bool} [params.autoBorrow] false, // The system will first borrow you funds at the optimal interest rate and then place an order for you
 * @param {bool} [params.hf] false, // true for hf order
 * @param {bool} [params.test] set to true to test an order, no order will be created but the request will be validated
 * @param {bool} [params.sync] set to true to use the hf sync call
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *kucoin) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes22588 := (<-this.LoadMarkets())
            PanicOnError(retRes22588)
            var market interface{} = this.Market(symbol)
            var testOrder interface{} = this.SafeBool(params, "test", false)
            params = this.Omit(params, "test")
            var hf interface{} = nil
            hfparamsVariable := this.HandleHfAndParams(params);
            hf = GetValue(hfparamsVariable,0);
            params = GetValue(hfparamsVariable,1)
            var useSync interface{} = false
            useSyncparamsVariable := this.HandleOptionAndParams(params, "createOrder", "sync", false);
            useSync = GetValue(useSyncparamsVariable,0);
            params = GetValue(useSyncparamsVariable,1)
            triggerPricestopLossPricetakeProfitPriceVariable := this.HandleTriggerPrices(params);
            triggerPrice := GetValue(triggerPricestopLossPricetakeProfitPriceVariable,0);
            stopLossPrice := GetValue(triggerPricestopLossPricetakeProfitPriceVariable,1);
            takeProfitPrice := GetValue(triggerPricestopLossPricetakeProfitPriceVariable,2)
            var tradeType interface{} = this.SafeString(params, "tradeType") // keep it for backward compatibility
            var isTriggerOrder interface{} =     (IsTrue(IsTrue(triggerPrice) || IsTrue(stopLossPrice)) || IsTrue(takeProfitPrice))
            var marginResult interface{} = this.HandleMarginModeAndParams("createOrder", params)
            var marginMode interface{} = this.SafeString(marginResult, 0)
            var isMarginOrder interface{} = IsTrue(IsEqual(tradeType, "MARGIN_TRADE")) || IsTrue(!IsEqual(marginMode, nil))
            // don't omit anything before calling createOrderRequest
            var orderRequest interface{} = this.CreateOrderRequest(symbol, typeVar, side, amount, price, params)
            var response interface{} = nil
            if IsTrue(testOrder) {
                if IsTrue(isMarginOrder) {
                    
        response = (<-this.PrivatePostMarginOrderTest(orderRequest))
                    PanicOnError(response)
                } else if IsTrue(hf) {
                    
        response = (<-this.PrivatePostHfOrdersTest(orderRequest))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.PrivatePostOrdersTest(orderRequest))
                    PanicOnError(response)
                }
            } else if IsTrue(isTriggerOrder) {
                
        response = (<-this.PrivatePostStopOrder(orderRequest))
                PanicOnError(response)
            } else if IsTrue(isMarginOrder) {
                
        response = (<-this.PrivatePostMarginOrder(orderRequest))
                PanicOnError(response)
            } else if IsTrue(useSync) {
                
        response = (<-this.PrivatePostHfOrdersSync(orderRequest))
                PanicOnError(response)
            } else if IsTrue(hf) {
                
        response = (<-this.PrivatePostHfOrders(orderRequest))
                PanicOnError(response)
            } else {
                
        response = (<-this.PrivatePostOrders(orderRequest))
                PanicOnError(response)
            }
            //
            //     {
            //         "code": "200000",
            //         "data": {
            //             "orderId": "5bd6e9286d99522a52e458de"
            //         }
            //    }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseOrder(data, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoin#createMarketOrderWithCost
 * @description create a market order by providing the symbol, side and cost
 * @see https://www.kucoin.com/docs/rest/spot-trading/orders/place-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} side 'buy' or 'sell'
 * @param {float} cost how much you want to trade in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *kucoin) CreateMarketOrderWithCost(symbol interface{}, side interface{}, cost interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes23188 := (<-this.LoadMarkets())
            PanicOnError(retRes23188)
            AddElementToObject(params, "cost", cost)
        
                retRes232015 :=  (<-this.CreateOrder(symbol, "market", side, cost, nil, params))
                PanicOnError(retRes232015)
                ch <- retRes232015
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoin#createMarketBuyOrderWithCost
 * @description create a market buy order by providing the symbol and cost
 * @see https://www.kucoin.com/docs/rest/spot-trading/orders/place-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {float} cost how much you want to trade in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *kucoin) CreateMarketBuyOrderWithCost(symbol interface{}, cost interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes23348 := (<-this.LoadMarkets())
            PanicOnError(retRes23348)
        
                retRes233515 :=  (<-this.CreateMarketOrderWithCost(symbol, "buy", cost, params))
                PanicOnError(retRes233515)
                ch <- retRes233515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoin#createMarketSellOrderWithCost
 * @description create a market sell order by providing the symbol and cost
 * @see https://www.kucoin.com/docs/rest/spot-trading/orders/place-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {float} cost how much you want to trade in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *kucoin) CreateMarketSellOrderWithCost(symbol interface{}, cost interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes23498 := (<-this.LoadMarkets())
            PanicOnError(retRes23498)
        
                retRes235015 :=  (<-this.CreateMarketOrderWithCost(symbol, "sell", cost, params))
                PanicOnError(retRes235015)
                ch <- retRes235015
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoin#createOrders
 * @description create a list of trade orders
 * @see https://www.kucoin.com/docs/rest/spot-trading/orders/place-multiple-orders
 * @see https://www.kucoin.com/docs/rest/spot-trading/spot-hf-trade-pro-account/place-multiple-hf-orders
 * @see https://www.kucoin.com/docs/rest/spot-trading/spot-hf-trade-pro-account/sync-place-multiple-hf-orders
 * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
 * @param {object} [params]  extra parameters specific to the exchange API endpoint
 * @param {bool} [params.hf] false, // true for hf orders
 * @param {bool} [params.sync] false, // true to use the hf sync call
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *kucoin) CreateOrders(orders interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes23678 := (<-this.LoadMarkets())
            PanicOnError(retRes23678)
            var ordersRequests interface{} = []interface{}{}
            var symbol interface{} = nil
            for i := 0; IsLessThan(i, GetArrayLength(orders)); i++ {
                var rawOrder interface{} = GetValue(orders, i)
                var marketId interface{} = this.SafeString(rawOrder, "symbol")
                if IsTrue(IsEqual(symbol, nil)) {
                    symbol = marketId
                } else {
                    if IsTrue(!IsEqual(symbol, marketId)) {
                        panic(BadRequest(Add(this.Id, " createOrders() requires all orders to have the same symbol")))
                    }
                }
                var typeVar interface{} = this.SafeString(rawOrder, "type")
                if IsTrue(!IsEqual(typeVar, "limit")) {
                    panic(BadRequest(Add(this.Id, " createOrders() only supports limit orders")))
                }
                var side interface{} = this.SafeString(rawOrder, "side")
                var amount interface{} = this.SafeValue(rawOrder, "amount")
                var price interface{} = this.SafeValue(rawOrder, "price")
                var orderParams interface{} = this.SafeValue(rawOrder, "params", map[string]interface{} {})
                var orderRequest interface{} = this.CreateOrderRequest(marketId, typeVar, side, amount, price, orderParams)
                AppendToArray(&ordersRequests,orderRequest)
            }
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "orderList": ordersRequests,
            }
            var hf interface{} = nil
            hfparamsVariable := this.HandleHfAndParams(params);
            hf = GetValue(hfparamsVariable,0);
            params = GetValue(hfparamsVariable,1)
            var useSync interface{} = false
            useSyncparamsVariable := this.HandleOptionAndParams(params, "createOrders", "sync", false);
            useSync = GetValue(useSyncparamsVariable,0);
            params = GetValue(useSyncparamsVariable,1)
            var response interface{} = nil
            if IsTrue(useSync) {
                
        response = (<-this.PrivatePostHfOrdersMultiSync(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(hf) {
                
        response = (<-this.PrivatePostHfOrdersMulti(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PrivatePostOrdersMulti(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            // {
            //     "code": "200000",
            //     "data": {
            //        "data": [
            //           {
            //              "symbol": "LTC-USDT",
            //              "type": "limit",
            //              "side": "sell",
            //              "price": "90",
            //              "size": "0.1",
            //              "funds": null,
            //              "stp": "",
            //              "stop": "",
            //              "stopPrice": null,
            //              "timeInForce": "GTC",
            //              "cancelAfter": 0,
            //              "postOnly": false,
            //              "hidden": false,
            //              "iceberge": false,
            //              "iceberg": false,
            //              "visibleSize": null,
            //              "channel": "API",
            //              "id": "6539148443fcf500079d15e5",
            //              "status": "success",
            //              "failMsg": null,
            //              "clientOid": "5c4c5398-8ab2-4b4e-af8a-e2d90ad2488f"
            //           },
            // }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            data = this.SafeList(data, "data", []interface{}{})
        
            ch <- this.ParseOrders(data)
            return nil
        
            }()
            return ch
        }
func  (this *kucoin) MarketOrderAmountToPrecision(symbol interface{}, amount interface{}) interface{}  {
    var market interface{} = this.Market(symbol)
    var result interface{} = this.DecimalToPrecision(amount, TRUNCATE, GetValue(GetValue(market, "info"), "quoteIncrement"), this.PrecisionMode, this.PaddingMode)
    if IsTrue(IsEqual(result, "0")) {
        panic(InvalidOrder(Add(Add(Add(Add(this.Id, " amount of "), GetValue(market, "symbol")), " must be greater than minimum amount precision of "), this.NumberToString(GetValue(GetValue(market, "precision"), "amount")))))
    }
    return result
}
func  (this *kucoin) CreateOrderRequest(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) interface{}  {
    price := GetArg(optionalArgs, 0, nil)
    _ = price
    params := GetArg(optionalArgs, 1, map[string]interface{} {})
    _ = params
    var market interface{} = this.Market(symbol)
    // required param, cannot be used twice
    var clientOrderId interface{} = this.SafeString2(params, "clientOid", "clientOrderId", this.Uuid())
    params = this.Omit(params, []interface{}{"clientOid", "clientOrderId"})
    var request interface{} = map[string]interface{} {
        "clientOid": clientOrderId,
        "side": side,
        "symbol": GetValue(market, "id"),
        "type": typeVar,
    }
    var quoteAmount interface{} = this.SafeNumber2(params, "cost", "funds")
    var amountString interface{} = nil
    var costString interface{} = nil
    var marginMode interface{} = nil
    marginModeparamsVariable := this.HandleMarginModeAndParams("createOrder", params);
    marginMode = GetValue(marginModeparamsVariable,0);
    params = GetValue(marginModeparamsVariable,1)
    if IsTrue(IsEqual(typeVar, "market")) {
        if IsTrue(!IsEqual(quoteAmount, nil)) {
            params = this.Omit(params, []interface{}{"cost", "funds"})
            // kucoin uses base precision even for quote values
            costString = this.MarketOrderAmountToPrecision(symbol, quoteAmount)
            AddElementToObject(request, "funds", costString)
        } else {
            amountString = this.AmountToPrecision(symbol, amount)
            AddElementToObject(request, "size", this.AmountToPrecision(symbol, amount))
        }
    } else {
        amountString = this.AmountToPrecision(symbol, amount)
        AddElementToObject(request, "size", amountString)
        AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
    }
    var tradeType interface{} = this.SafeString(params, "tradeType") // keep it for backward compatibility
    triggerPricestopLossPricetakeProfitPriceVariable := this.HandleTriggerPrices(params);
    triggerPrice := GetValue(triggerPricestopLossPricetakeProfitPriceVariable,0);
    stopLossPrice := GetValue(triggerPricestopLossPricetakeProfitPriceVariable,1);
    takeProfitPrice := GetValue(triggerPricestopLossPricetakeProfitPriceVariable,2)
    var isTriggerOrder interface{} =     (IsTrue(IsTrue(triggerPrice) || IsTrue(stopLossPrice)) || IsTrue(takeProfitPrice))
    var isMarginOrder interface{} = IsTrue(IsEqual(tradeType, "MARGIN_TRADE")) || IsTrue(!IsEqual(marginMode, nil))
    params = this.Omit(params, []interface{}{"stopLossPrice", "takeProfitPrice", "triggerPrice", "stopPrice"})
    if IsTrue(isTriggerOrder) {
        if IsTrue(triggerPrice) {
            AddElementToObject(request, "stopPrice", this.PriceToPrecision(symbol, triggerPrice))
        } else if IsTrue(IsTrue(stopLossPrice) || IsTrue(takeProfitPrice)) {
            if IsTrue(stopLossPrice) {
                AddElementToObject(request, "stop", Ternary(IsTrue((IsEqual(side, "buy"))), "entry", "loss"))
                AddElementToObject(request, "stopPrice", this.PriceToPrecision(symbol, stopLossPrice))
            } else {
                AddElementToObject(request, "stop", Ternary(IsTrue((IsEqual(side, "buy"))), "loss", "entry"))
                AddElementToObject(request, "stopPrice", this.PriceToPrecision(symbol, takeProfitPrice))
            }
        }
        if IsTrue(IsEqual(marginMode, "isolated")) {
            panic(BadRequest(Add(this.Id, " createOrder does not support isolated margin for stop orders")))
        } else if IsTrue(IsEqual(marginMode, "cross")) {
            AddElementToObject(request, "tradeType", GetValue(GetValue(this.Options, "marginModes"), marginMode))
        }
    } else if IsTrue(isMarginOrder) {
        if IsTrue(IsEqual(marginMode, "isolated")) {
            AddElementToObject(request, "marginModel", "isolated")
        }
    }
    var postOnly interface{} = nil
    postOnlyparamsVariable := this.HandlePostOnly(IsEqual(typeVar, "market"), false, params);
    postOnly = GetValue(postOnlyparamsVariable,0);
    params = GetValue(postOnlyparamsVariable,1)
    if IsTrue(postOnly) {
        AddElementToObject(request, "postOnly", true)
    }
    return this.Extend(request, params)
}
/**
 * @method
 * @name kucoin#editOrder
 * @description edit an order, kucoin currently only supports the modification of HF orders
 * @see https://docs.kucoin.com/spot-hf/#modify-order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type not used
 * @param {string} side not used
 * @param {float} amount how much of the currency you want to trade in units of the base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.clientOrderId] client order id, defaults to id if not passed
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *kucoin) EditOrder(id interface{}, symbol interface{}, typeVar interface{}, side interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    amount := GetArg(optionalArgs, 0, nil)
            _ = amount
            price := GetArg(optionalArgs, 1, nil)
            _ = price
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes25348 := (<-this.LoadMarkets())
            PanicOnError(retRes25348)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var clientOrderId interface{} = this.SafeString2(params, "clientOid", "clientOrderId")
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                AddElementToObject(request, "clientOid", clientOrderId)
            } else {
                AddElementToObject(request, "orderId", id)
            }
            if IsTrue(!IsEqual(amount, nil)) {
                AddElementToObject(request, "newSize", this.AmountToPrecision(symbol, amount))
            }
            if IsTrue(!IsEqual(price, nil)) {
                AddElementToObject(request, "newPrice", this.PriceToPrecision(symbol, price))
            }
        
            response:= (<-this.PrivatePostHfOrdersAlter(this.Extend(request, params)))
            PanicOnError(response)
            //
            // {
            //     "code":"200000",
            //     "data":{
            //        "newOrderId":"6478d7a6c883280001e92d8b"
            //     }
            // }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseOrder(data, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoin#cancelOrder
 * @description cancels an open order
 * @see https://docs.kucoin.com/spot#cancel-an-order
 * @see https://docs.kucoin.com/spot#cancel-an-order-2
 * @see https://docs.kucoin.com/spot#cancel-single-order-by-clientoid
 * @see https://docs.kucoin.com/spot#cancel-single-order-by-clientoid-2
 * @see https://docs.kucoin.com/spot-hf/#cancel-orders-by-orderid
 * @see https://docs.kucoin.com/spot-hf/#cancel-order-by-clientoid
 * @see https://www.kucoin.com/docs/rest/spot-trading/spot-hf-trade-pro-account/sync-cancel-hf-order-by-orderid
 * @see https://www.kucoin.com/docs/rest/spot-trading/spot-hf-trade-pro-account/sync-cancel-hf-order-by-clientoid
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {bool} [params.trigger] True if cancelling a stop order
 * @param {bool} [params.hf] false, // true for hf order
 * @param {bool} [params.sync] false, // true to use the hf sync call
 * @returns Response from the exchange
 */
func  (this *kucoin) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes25858 := (<-this.LoadMarkets())
            PanicOnError(retRes25858)
            var request interface{} = map[string]interface{} {}
            var clientOrderId interface{} = this.SafeString2(params, "clientOid", "clientOrderId")
            var trigger interface{} = this.SafeBool2(params, "stop", "trigger", false)
            var hf interface{} = nil
            hfparamsVariable := this.HandleHfAndParams(params);
            hf = GetValue(hfparamsVariable,0);
            params = GetValue(hfparamsVariable,1)
            var useSync interface{} = false
            useSyncparamsVariable := this.HandleOptionAndParams(params, "cancelOrder", "sync", false);
            useSync = GetValue(useSyncparamsVariable,0);
            params = GetValue(useSyncparamsVariable,1)
            if IsTrue(IsTrue(hf) || IsTrue(useSync)) {
                if IsTrue(IsEqual(symbol, nil)) {
                    panic(ArgumentsRequired(Add(this.Id, " cancelOrder() requires a symbol parameter for hf orders")))
                }
                var market interface{} = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            var response interface{} = nil
            params = this.Omit(params, []interface{}{"clientOid", "clientOrderId", "stop", "trigger"})
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                AddElementToObject(request, "clientOid", clientOrderId)
                if IsTrue(trigger) {
                    
        response = (<-this.PrivateDeleteStopOrderCancelOrderByClientOid(this.Extend(request, params)))
                    PanicOnError(response)
                } else if IsTrue(useSync) {
                    
        response = (<-this.PrivateDeleteHfOrdersSyncClientOrderClientOid(this.Extend(request, params)))
                    PanicOnError(response)
                } else if IsTrue(hf) {
                    
        response = (<-this.PrivateDeleteHfOrdersClientOrderClientOid(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.PrivateDeleteOrderClientOrderClientOid(this.Extend(request, params)))
                    PanicOnError(response)
                }
                response = this.SafeDict(response, "data")
        
                ch <- this.ParseOrder(response)
                return nil
            } else {
                AddElementToObject(request, "orderId", id)
                if IsTrue(trigger) {
                    
        response = (<-this.PrivateDeleteStopOrderOrderId(this.Extend(request, params)))
                    PanicOnError(response)
                } else if IsTrue(useSync) {
                    
        response = (<-this.PrivateDeleteHfOrdersSyncOrderId(this.Extend(request, params)))
                    PanicOnError(response)
                } else if IsTrue(hf) {
                    
        response = (<-this.PrivateDeleteHfOrdersOrderId(this.Extend(request, params)))
                    PanicOnError(response)
                    //
                    //    {
                    //        "code": "200000",
                    //        "data": {
                    //          "orderId": "630625dbd9180300014c8d52"
                    //        }
                    //    }
                    //
                    response = this.SafeDict(response, "data")
        
                    ch <- this.ParseOrder(response)
                    return nil
                } else {
                    
        response = (<-this.PrivateDeleteOrdersOrderId(this.Extend(request, params)))
                    PanicOnError(response)
                }
                var data interface{} = this.SafeDict(response, "data")
                var orderIds interface{} = this.SafeList(data, "cancelledOrderIds", []interface{}{})
                var orderId interface{} = this.SafeString(orderIds, 0)
        
                ch <- this.SafeOrder(map[string]interface{} {
                    "info": data,
                    "id": orderId,
                })
                return nil
            }
                return nil
            }()
            return ch
        }
/**
 * @method
 * @name kucoin#cancelAllOrders
 * @description cancel all open orders
 * @see https://docs.kucoin.com/spot#cancel-all-orders
 * @see https://docs.kucoin.com/spot#cancel-orders
 * @see https://docs.kucoin.com/spot-hf/#cancel-all-hf-orders-by-symbol
 * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {bool} [params.trigger] *invalid for isolated margin* true if cancelling all stop orders
 * @param {string} [params.marginMode] 'cross' or 'isolated'
 * @param {string} [params.orderIds] *stop orders only* Comma seperated order IDs
 * @param {bool} [params.hf] false, // true for hf order
 * @returns Response from the exchange
 */
func  (this *kucoin) CancelAllOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes27018 := (<-this.LoadMarkets())
            PanicOnError(retRes27018)
            var request interface{} = map[string]interface{} {}
            var trigger interface{} = this.SafeBool(params, "stop", false)
            var hf interface{} = nil
            hfparamsVariable := this.HandleHfAndParams(params);
            hf = GetValue(hfparamsVariable,0);
            params = GetValue(hfparamsVariable,1)
            params = this.Omit(params, "stop")
            marginModequeryVariable := this.HandleMarginModeAndParams("cancelAllOrders", params);
            marginMode := GetValue(marginModequeryVariable,0);
            query := GetValue(marginModequeryVariable,1)
            if IsTrue(!IsEqual(symbol, nil)) {
                AddElementToObject(request, "symbol", this.MarketId(symbol))
            }
            if IsTrue(!IsEqual(marginMode, nil)) {
                AddElementToObject(request, "tradeType", GetValue(GetValue(this.Options, "marginModes"), marginMode))
                if IsTrue(IsTrue(IsEqual(marginMode, "isolated")) && IsTrue(trigger)) {
                    panic(BadRequest(Add(this.Id, " cancelAllOrders does not support isolated margin for stop orders")))
                }
            }
            var response interface{} = nil
            if IsTrue(trigger) {
                
        response = (<-this.PrivateDeleteStopOrderCancel(this.Extend(request, query)))
                PanicOnError(response)
            } else if IsTrue(hf) {
                if IsTrue(IsEqual(symbol, nil)) {
                    
        response = (<-this.PrivateDeleteHfOrdersCancelAll(this.Extend(request, query)))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.PrivateDeleteHfOrders(this.Extend(request, query)))
                    PanicOnError(response)
                }
            } else {
                
        response = (<-this.PrivateDeleteOrders(this.Extend(request, query)))
                PanicOnError(response)
            }
        
            ch <- response
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoin#fetchOrdersByStatus
 * @description fetch a list of orders
 * @see https://docs.kucoin.com/spot#list-orders
 * @see https://docs.kucoin.com/spot#list-stop-orders
 * @see https://docs.kucoin.com/spot-hf/#obtain-list-of-active-hf-orders
 * @see https://docs.kucoin.com/spot-hf/#obtain-list-of-filled-hf-orders
 * @param {string} status *not used for stop orders* 'open' or 'closed'
 * @param {string} symbol unified market symbol
 * @param {int} [since] timestamp in ms of the earliest order
 * @param {int} [limit] max number of orders to return
 * @param {object} [params] exchange specific params
 * @param {int} [params.until] end time in ms
 * @param {string} [params.side] buy or sell
 * @param {string} [params.type] limit, market, limit_stop or market_stop
 * @param {string} [params.tradeType] TRADE for spot trading, MARGIN_TRADE for Margin Trading
 * @param {int} [params.currentPage] *trigger orders only* current page
 * @param {string} [params.orderIds] *trigger orders only* comma seperated order ID list
 * @param {bool} [params.trigger] True if fetching a trigger order
 * @param {bool} [params.hf] false, // true for hf order
 * @returns An [array of order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *kucoin) FetchOrdersByStatus(status interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes27568 := (<-this.LoadMarkets())
            PanicOnError(retRes27568)
            var lowercaseStatus interface{} = ToLower(status)
            var until interface{} = this.SafeInteger(params, "until")
            var trigger interface{} = this.SafeBool2(params, "stop", "trigger", false)
            var hf interface{} = nil
            hfparamsVariable := this.HandleHfAndParams(params);
            hf = GetValue(hfparamsVariable,0);
            params = GetValue(hfparamsVariable,1)
            if IsTrue(IsTrue(hf) && IsTrue((IsEqual(symbol, nil)))) {
                panic(ArgumentsRequired(Add(this.Id, " fetchOrdersByStatus() requires a symbol parameter for hf orders")))
            }
            params = this.Omit(params, []interface{}{"stop", "trigger", "till", "until"})
            marginModequeryVariable := this.HandleMarginModeAndParams("fetchOrdersByStatus", params);
            marginMode := GetValue(marginModequeryVariable,0);
            query := GetValue(marginModequeryVariable,1)
            if IsTrue(IsEqual(lowercaseStatus, "open")) {
                lowercaseStatus = "active"
            } else if IsTrue(IsEqual(lowercaseStatus, "closed")) {
                lowercaseStatus = "done"
            }
            var request interface{} = map[string]interface{} {
                "status": lowercaseStatus,
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startAt", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "pageSize", limit)
            }
            if IsTrue(until) {
                AddElementToObject(request, "endAt", until)
            }
            AddElementToObject(request, "tradeType", this.SafeString(GetValue(this.Options, "marginModes"), marginMode, "TRADE"))
            var response interface{} = nil
            if IsTrue(trigger) {
                
        response = (<-this.PrivateGetStopOrder(this.Extend(request, query)))
                PanicOnError(response)
            } else if IsTrue(hf) {
                if IsTrue(IsEqual(lowercaseStatus, "active")) {
                    
        response = (<-this.PrivateGetHfOrdersActive(this.Extend(request, query)))
                    PanicOnError(response)
                } else if IsTrue(IsEqual(lowercaseStatus, "done")) {
                    
        response = (<-this.PrivateGetHfOrdersDone(this.Extend(request, query)))
                    PanicOnError(response)
                }
            } else {
                
        response = (<-this.PrivateGetOrders(this.Extend(request, query)))
                PanicOnError(response)
            }
            //
            //     {
            //         "code": "200000",
            //         "data": {
            //             "currentPage": 1,
            //             "pageSize": 1,
            //             "totalNum": 153408,
            //             "totalPage": 153408,
            //             "items": [
            //                 {
            //                     "id": "5c35c02703aa673ceec2a168",   //orderid
            //                     "symbol": "BTC-USDT",   //symbol
            //                     "opType": "DEAL",      // operation type,deal is pending order,cancel is cancel order
            //                     "type": "limit",       // order type,e.g. limit,markrt,stop_limit.
            //                     "side": "buy",         // transaction direction,include buy and sell
            //                     "price": "10",         // order price
            //                     "size": "2",           // order quantity
            //                     "funds": "0",          // order funds
            //                     "dealFunds": "0.166",  // deal funds
            //                     "dealSize": "2",       // deal quantity
            //                     "fee": "0",            // fee
            //                     "feeCurrency": "USDT", // charge fee currency
            //                     "stp": "",             // self trade prevention,include CN,CO,DC,CB
            //                     "stop": "",            // stop type
            //                     "stopTriggered": false,  // stop order is triggered
            //                     "stopPrice": "0",      // stop price
            //                     "timeInForce": "GTC",  // time InForce,include GTC,GTT,IOC,FOK
            //                     "postOnly": false,     // postOnly
            //                     "hidden": false,       // hidden order
            //                     "iceberg": false,      // iceberg order
            //                     "visibleSize": "0",    // display quantity for iceberg order
            //                     "cancelAfter": 0,      // cancel orders time，requires timeInForce to be GTT
            //                     "channel": "IOS",      // order source
            //                     "clientOid": "",       // user-entered order unique mark
            //                     "remark": "",          // remark
            //                     "tags": "",            // tag order source
            //                     "isActive": false,     // status before unfilled or uncancelled
            //                     "cancelExist": false,   // order cancellation transaction record
            //                     "createdAt": 1547026471000  // time
            //                 },
            //             ]
            //         }
            //    }
            var listData interface{} = this.SafeList(response, "data")
            if IsTrue(!IsEqual(listData, nil)) {
        
                ch <- this.ParseOrders(listData, market, since, limit)
                return nil
            }
            var responseData interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var orders interface{} = this.SafeList(responseData, "items", []interface{}{})
        
            ch <- this.ParseOrders(orders, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoin#fetchClosedOrders
 * @description fetches information on multiple closed orders made by the user
 * @see https://docs.kucoin.com/spot#list-orders
 * @see https://docs.kucoin.com/spot#list-stop-orders
 * @see https://docs.kucoin.com/spot-hf/#obtain-list-of-active-hf-orders
 * @see https://docs.kucoin.com/spot-hf/#obtain-list-of-filled-hf-orders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] end time in ms
 * @param {string} [params.side] buy or sell
 * @param {string} [params.type] limit, market, limit_stop or market_stop
 * @param {string} [params.tradeType] TRADE for spot trading, MARGIN_TRADE for Margin Trading
 * @param {bool} [params.trigger] True if fetching a trigger order
 * @param {bool} [params.hf] false, // true for hf order
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *kucoin) FetchClosedOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes28768 := (<-this.LoadMarkets())
            PanicOnError(retRes28768)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchClosedOrders", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes288019 :=  (<-this.FetchPaginatedCallDynamic("fetchClosedOrders", symbol, since, limit, params))
                    PanicOnError(retRes288019)
                    ch <- retRes288019
                    return nil
            }
        
                retRes288215 :=  (<-this.FetchOrdersByStatus("done", symbol, since, limit, params))
                PanicOnError(retRes288215)
                ch <- retRes288215
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoin#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://docs.kucoin.com/spot#list-orders
 * @see https://docs.kucoin.com/spot#list-stop-orders
 * @see https://docs.kucoin.com/spot-hf/#obtain-list-of-active-hf-orders
 * @see https://docs.kucoin.com/spot-hf/#obtain-list-of-filled-hf-orders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] end time in ms
 * @param {bool} [params.trigger] true if fetching trigger orders
 * @param {string} [params.side] buy or sell
 * @param {string} [params.type] limit, market, limit_stop or market_stop
 * @param {string} [params.tradeType] TRADE for spot trading, MARGIN_TRADE for Margin Trading
 * @param {int} [params.currentPage] *trigger orders only* current page
 * @param {string} [params.orderIds] *trigger orders only* comma seperated order ID list
 * @param {bool} [params.hf] false, // true for hf order
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *kucoin) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes29098 := (<-this.LoadMarkets())
            PanicOnError(retRes29098)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchOpenOrders", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes291319 :=  (<-this.FetchPaginatedCallDynamic("fetchOpenOrders", symbol, since, limit, params))
                    PanicOnError(retRes291319)
                    ch <- retRes291319
                    return nil
            }
        
                retRes291515 :=  (<-this.FetchOrdersByStatus("active", symbol, since, limit, params))
                PanicOnError(retRes291515)
                ch <- retRes291515
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoin#fetchOrder
 * @description fetch an order
 * @see https://docs.kucoin.com/spot#get-an-order
 * @see https://docs.kucoin.com/spot#get-single-active-order-by-clientoid
 * @see https://docs.kucoin.com/spot#get-single-order-info
 * @see https://docs.kucoin.com/spot#get-single-order-by-clientoid
 * @see https://docs.kucoin.com/spot-hf/#details-of-a-single-hf-order
 * @see https://docs.kucoin.com/spot-hf/#obtain-details-of-a-single-hf-order-using-clientoid
 * @param {string} id Order id
 * @param {string} symbol not sent to exchange except for trigger orders with clientOid, but used internally by CCXT to filter
 * @param {object} [params] exchange specific parameters
 * @param {bool} [params.trigger] true if fetching a trigger order
 * @param {bool} [params.hf] false, // true for hf order
 * @param {bool} [params.clientOid] unique order id created by users to identify their orders
 * @returns An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *kucoin) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes29378 := (<-this.LoadMarkets())
            PanicOnError(retRes29378)
            var request interface{} = map[string]interface{} {}
            var clientOrderId interface{} = this.SafeString2(params, "clientOid", "clientOrderId")
            var trigger interface{} = this.SafeBool2(params, "stop", "trigger", false)
            var hf interface{} = nil
            hfparamsVariable := this.HandleHfAndParams(params);
            hf = GetValue(hfparamsVariable,0);
            params = GetValue(hfparamsVariable,1)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            if IsTrue(hf) {
                if IsTrue(IsEqual(symbol, nil)) {
                    panic(ArgumentsRequired(Add(this.Id, " fetchOrder() requires a symbol parameter for hf orders")))
                }
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            params = this.Omit(params, []interface{}{"stop", "clientOid", "clientOrderId", "trigger"})
            var response interface{} = nil
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                AddElementToObject(request, "clientOid", clientOrderId)
                if IsTrue(trigger) {
                    if IsTrue(!IsEqual(symbol, nil)) {
                        AddElementToObject(request, "symbol", GetValue(market, "id"))
                    }
                    
        response = (<-this.PrivateGetStopOrderQueryOrderByClientOid(this.Extend(request, params)))
                    PanicOnError(response)
                } else if IsTrue(hf) {
                    
        response = (<-this.PrivateGetHfOrdersClientOrderClientOid(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.PrivateGetOrderClientOrderClientOid(this.Extend(request, params)))
                    PanicOnError(response)
                }
            } else {
                // a special case for undefined ids
                // otherwise a wrong endpoint for all orders will be triggered
                // https://github.com/ccxt/ccxt/issues/7234
                if IsTrue(IsEqual(id, nil)) {
                    panic(InvalidOrder(Add(this.Id, " fetchOrder() requires an order id")))
                }
                AddElementToObject(request, "orderId", id)
                if IsTrue(trigger) {
                    
        response = (<-this.PrivateGetStopOrderOrderId(this.Extend(request, params)))
                    PanicOnError(response)
                } else if IsTrue(hf) {
                    
        response = (<-this.PrivateGetHfOrdersOrderId(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.PrivateGetOrdersOrderId(this.Extend(request, params)))
                    PanicOnError(response)
                }
            }
            var responseData interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            if IsTrue(IsArray(responseData)) {
                responseData = this.SafeValue(responseData, 0)
            }
        
            ch <- this.ParseOrder(responseData, market)
            return nil
        
            }()
            return ch
        }
func  (this *kucoin) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // createOrder
    //
    //    {
    //        "orderId": "63c97e47d686c5000159a656"
    //    }
    //
    // cancelOrder
    //
    //    {
    //        "cancelledOrderIds": [ "63c97e47d686c5000159a656" ]
    //    }
    //
    // fetchOpenOrders, fetchClosedOrders
    //
    //    {
    //        "id": "63c97ce8d686c500015793bb",
    //        "symbol": "USDC-USDT",
    //        "opType": "DEAL",
    //        "type": "limit",
    //        "side": "sell",
    //        "price": "1.05",
    //        "size": "1",
    //        "funds": "0",
    //        "dealFunds": "0",
    //        "dealSize": "0",
    //        "fee": "0",
    //        "feeCurrency": "USDT",
    //        "stp": "",
    //        "stop": "",
    //        "stopTriggered": false,
    //        "stopPrice": "0",
    //        "timeInForce": "GTC",
    //        "postOnly": false,
    //        "hidden": false,
    //        "iceberg": false,
    //        "visibleSize": "0",
    //        "cancelAfter": 0,
    //        "channel": "API",
    //        "clientOid": "d602d73f-5424-4751-bef0-8debce8f0a82",
    //        "remark": null,
    //        "tags": "partner:ccxt",
    //        "isActive": true,
    //        "cancelExist": false,
    //        "createdAt": 1674149096927,
    //        "tradeType": "TRADE"
    //    }
    //
    // stop orders (fetchOpenOrders, fetchClosedOrders)
    //
    //    {
    //        "id": "vs9f6ou9e864rgq8000t4qnm",
    //        "symbol": "USDC-USDT",
    //        "userId": "613a896885d8660006151f01",
    //        "status": "NEW",
    //        "type": "market",
    //        "side": "sell",
    //        "price": null,
    //        "size": "1.00000000000000000000",
    //        "funds": null,
    //        "stp": null,
    //        "timeInForce": "GTC",
    //        "cancelAfter": -1,
    //        "postOnly": false,
    //        "hidden": false,
    //        "iceberg": false,
    //        "visibleSize": null,
    //        "channel": "API",
    //        "clientOid": "5d3fd727-6456-438d-9550-40d9d85eee0b",
    //        "remark": null,
    //        "tags": "partner:ccxt",
    //        "relatedNo": null,
    //        "orderTime": 1674146316994000028,
    //        "domainId": "kucoin",
    //        "tradeSource": "USER",
    //        "tradeType": "MARGIN_TRADE",
    //        "feeCurrency": "USDT",
    //        "takerFeeRate": "0.00100000000000000000",
    //        "makerFeeRate": "0.00100000000000000000",
    //        "createdAt": 1674146316994,
    //        "stop": "loss",
    //        "stopTriggerTime": null,
    //        "stopPrice": "0.97000000000000000000"
    //    }
    // hf order
    //    {
    //        "id":"6478cf1439bdfc0001528a1d",
    //        "symbol":"LTC-USDT",
    //        "opType":"DEAL",
    //        "type":"limit",
    //        "side":"buy",
    //        "price":"50",
    //        "size":"0.1",
    //        "funds":"5",
    //        "dealSize":"0",
    //        "dealFunds":"0",
    //        "fee":"0",
    //        "feeCurrency":"USDT",
    //        "stp":null,
    //        "timeInForce":"GTC",
    //        "postOnly":false,
    //        "hidden":false,
    //        "iceberg":false,
    //        "visibleSize":"0",
    //        "cancelAfter":0,
    //        "channel":"API",
    //        "clientOid":"d4d2016b-8e3a-445c-aa5d-dc6df5d1678d",
    //        "remark":null,
    //        "tags":"partner:ccxt",
    //        "cancelExist":false,
    //        "createdAt":1685638932074,
    //        "lastUpdatedAt":1685639013735,
    //        "tradeType":"TRADE",
    //        "inOrderBook":true,
    //        "cancelledSize":"0",
    //        "cancelledFunds":"0",
    //        "remainSize":"0.1",
    //        "remainFunds":"5",
    //        "active":true
    //    }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(order, "symbol")
    var timestamp interface{} = this.SafeInteger(order, "createdAt")
    var feeCurrencyId interface{} = this.SafeString(order, "feeCurrency")
    var cancelExist interface{} = this.SafeBool(order, "cancelExist", false)
    var responseStop interface{} = this.SafeString(order, "stop")
    var trigger interface{} = !IsEqual(responseStop, nil)
    var stopTriggered interface{} = this.SafeBool(order, "stopTriggered", false)
    var isActive interface{} = this.SafeBool2(order, "isActive", "active")
    var responseStatus interface{} = this.SafeString(order, "status")
    var status interface{} = nil
    if IsTrue(!IsEqual(isActive, nil)) {
        if IsTrue(IsEqual(isActive, true)) {
            status = "open"
        } else {
            status = "closed"
        }
    }
    if IsTrue(trigger) {
        if IsTrue(IsEqual(responseStatus, "NEW")) {
            status = "open"
        } else if IsTrue(!IsTrue(isActive) && !IsTrue(stopTriggered)) {
            status = "cancelled"
        }
    }
    if IsTrue(cancelExist) {
        status = "canceled"
    }
    if IsTrue(IsEqual(responseStatus, "fail")) {
        status = "rejected"
    }
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": this.SafeStringN(order, []interface{}{"id", "orderId", "newOrderId", "cancelledOrderId"}),
        "clientOrderId": this.SafeString(order, "clientOid"),
        "symbol": this.SafeSymbol(marketId, market, "-"),
        "type": this.SafeString(order, "type"),
        "timeInForce": this.SafeString(order, "timeInForce"),
        "postOnly": this.SafeBool(order, "postOnly"),
        "side": this.SafeString(order, "side"),
        "amount": this.SafeString(order, "size"),
        "price": this.SafeString(order, "price"),
        "triggerPrice": this.SafeNumber(order, "stopPrice"),
        "cost": this.SafeString(order, "dealFunds"),
        "filled": this.SafeString(order, "dealSize"),
        "remaining": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "fee": map[string]interface{} {
            "currency": this.SafeCurrencyCode(feeCurrencyId),
            "cost": this.SafeNumber(order, "fee"),
        },
        "status": status,
        "lastTradeTimestamp": nil,
        "average": this.SafeString(order, "avgDealPrice"),
        "trades": nil,
    }, market)
}
/**
 * @method
 * @name kucoin#fetchOrderTrades
 * @description fetch all the trades made from a single order
 * @see https://docs.kucoin.com/#list-fills
 * @see https://docs.kucoin.com/spot-hf/#transaction-details
 * @param {string} id order id
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *kucoin) FetchOrderTrades(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "orderId": id,
            }
        
                retRes318715 :=  (<-this.FetchMyTrades(symbol, since, limit, this.Extend(request, params)))
                PanicOnError(retRes318715)
                ch <- retRes318715
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoin#fetchMyTrades
 * @see https://docs.kucoin.com/#list-fills
 * @see https://docs.kucoin.com/spot-hf/#transaction-details
 * @description fetch all trades made by the user
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch entries for
 * @param {bool} [params.hf] false, // true for hf order
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *kucoin) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes32068 := (<-this.LoadMarkets())
            PanicOnError(retRes32068)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchMyTrades", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes321019 :=  (<-this.FetchPaginatedCallDynamic("fetchMyTrades", symbol, since, limit, params))
                    PanicOnError(retRes321019)
                    ch <- retRes321019
                    return nil
            }
            var request interface{} = map[string]interface{} {}
            var hf interface{} = nil
            hfparamsVariable := this.HandleHfAndParams(params);
            hf = GetValue(hfparamsVariable,0);
            params = GetValue(hfparamsVariable,1)
            if IsTrue(IsTrue(hf) && IsTrue(IsEqual(symbol, nil))) {
                panic(ArgumentsRequired(Add(this.Id, " fetchMyTrades() requires a symbol parameter for hf orders")))
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            var method interface{} = GetValue(this.Options, "fetchMyTradesMethod")
            var parseResponseData interface{} = false
            var response interface{} = nil
            requestparamsVariable := this.HandleUntilOption("endAt", request, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
            if IsTrue(hf) {
                // does not return trades earlier than 2019-02-18T00:00:00Z
                if IsTrue(!IsEqual(limit, nil)) {
                    AddElementToObject(request, "limit", limit)
                }
                if IsTrue(!IsEqual(since, nil)) {
                    // only returns trades up to one week after the since param
                    AddElementToObject(request, "startAt", since)
                }
                
        response = (<-this.PrivateGetHfFills(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(method, "private_get_fills")) {
                // does not return trades earlier than 2019-02-18T00:00:00Z
                if IsTrue(!IsEqual(since, nil)) {
                    // only returns trades up to one week after the since param
                    AddElementToObject(request, "startAt", since)
                }
                
        response = (<-this.PrivateGetFills(this.Extend(request, params)))
                PanicOnError(response)
            } else if IsTrue(IsEqual(method, "private_get_limit_fills")) {
                // does not return trades earlier than 2019-02-18T00:00:00Z
                // takes no params
                // only returns first 1000 trades (not only "in the last 24 hours" as stated in the docs)
                parseResponseData = true
                
        response = (<-this.PrivateGetLimitFills(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                panic(ExchangeError(Add(this.Id, " fetchMyTradesMethod() invalid method")))
            }
            //
            //     {
            //         "currentPage": 1,
            //         "pageSize": 50,
            //         "totalNum": 1,
            //         "totalPage": 1,
            //         "items": [
            //             {
            //                 "symbol":"BTC-USDT",       // symbol
            //                 "tradeId":"5c35c02709e4f67d5266954e",        // trade id
            //                 "orderId":"5c35c02703aa673ceec2a168",        // order id
            //                 "counterOrderId":"5c1ab46003aa676e487fa8e3", // counter order id
            //                 "side":"buy",              // transaction direction,include buy and sell
            //                 "liquidity":"taker",       // include taker and maker
            //                 "forceTaker":true,         // forced to become taker
            //                 "price":"0.083",           // order price
            //                 "size":"0.8424304",        // order quantity
            //                 "funds":"0.0699217232",    // order funds
            //                 "fee":"0",                 // fee
            //                 "feeRate":"0",             // fee rate
            //                 "feeCurrency":"USDT",      // charge fee currency
            //                 "stop":"",                 // stop type
            //                 "type":"limit",            // order type, e.g. limit, market, stop_limit.
            //                 "createdAt":1547026472000  // time
            //             },
            //             //------------------------------------------------------
            //             // v1 (historical) trade response structure
            //             {
            //                 "symbol": "SNOV-ETH",
            //                 "dealPrice": "0.0000246",
            //                 "dealValue": "0.018942",
            //                 "amount": "770",
            //                 "fee": "0.00001137",
            //                 "side": "sell",
            //                 "createdAt": 1540080199
            //                 "id":"5c4d389e4c8c60413f78e2e5",
            //             }
            //         ]
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var trades interface{} = nil
            if IsTrue(parseResponseData) {
                trades = data
            } else {
                trades = this.SafeList(data, "items", []interface{}{})
            }
        
            ch <- this.ParseTrades(trades, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoin#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://www.kucoin.com/docs/rest/spot-trading/market-data/get-trade-histories
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *kucoin) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes33158 := (<-this.LoadMarkets())
            PanicOnError(retRes33158)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            // pagination is not supported on the exchange side anymore
            // if (since !== undefined) {
            //     request['startAt'] = Math.floor (since / 1000);
            // }
            // if (limit !== undefined) {
            //     request['pageSize'] = limit;
            // }
        
            response:= (<-this.PublicGetMarketHistories(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "200000",
            //         "data": [
            //             {
            //                 "sequence": "1548764654235",
            //                 "side": "sell",
            //                 "size":"0.6841354",
            //                 "price":"0.03202",
            //                 "time":1548848575203567174
            //             }
            //         ]
            //     }
            //
            var trades interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTrades(trades, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *kucoin) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTrades (public)
    //
    //     {
    //         "sequence": "1548764654235",
    //         "side": "sell",
    //         "size":"0.6841354",
    //         "price":"0.03202",
    //         "time":1548848575203567174
    //     }
    //
    //     {
    //         "sequence": "1568787654360",
    //         "symbol": "BTC-USDT",
    //         "side": "buy",
    //         "size": "0.00536577",
    //         "price": "9345",
    //         "takerOrderId": "5e356c4a9f1a790008f8d921",
    //         "time": "1580559434436443257",
    //         "type": "match",
    //         "makerOrderId": "5e356bffedf0010008fa5d7f",
    //         "tradeId": "5e356c4aeefabd62c62a1ece"
    //     }
    //
    // fetchMyTrades (private) v2
    //
    //     {
    //         "symbol":"BTC-USDT",
    //         "tradeId":"5c35c02709e4f67d5266954e",
    //         "orderId":"5c35c02703aa673ceec2a168",
    //         "counterOrderId":"5c1ab46003aa676e487fa8e3",
    //         "side":"buy",
    //         "liquidity":"taker",
    //         "forceTaker":true,
    //         "price":"0.083",
    //         "size":"0.8424304",
    //         "funds":"0.0699217232",
    //         "fee":"0",
    //         "feeRate":"0",
    //         "feeCurrency":"USDT",
    //         "stop":"",
    //         "type":"limit",
    //         "createdAt":1547026472000
    //     }
    //
    // fetchMyTrades v2 alternative format since 2019-05-21 https://github.com/ccxt/ccxt/pull/5162
    //
    //     {
    //         "symbol": "OPEN-BTC",
    //         "forceTaker":  false,
    //         "orderId": "5ce36420054b4663b1fff2c9",
    //         "fee": "0",
    //         "feeCurrency": "",
    //         "type": "",
    //         "feeRate": "0",
    //         "createdAt": 1558417615000,
    //         "size": "12.8206",
    //         "stop": "",
    //         "price": "0",
    //         "funds": "0",
    //         "tradeId": "5ce390cf6e0db23b861c6e80"
    //     }
    //
    // fetchMyTrades (private) v1 (historical)
    //
    //     {
    //         "symbol": "SNOV-ETH",
    //         "dealPrice": "0.0000246",
    //         "dealValue": "0.018942",
    //         "amount": "770",
    //         "fee": "0.00001137",
    //         "side": "sell",
    //         "createdAt": 1540080199
    //         "id":"5c4d389e4c8c60413f78e2e5",
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(trade, "symbol")
    market = this.SafeMarket(marketId, market, "-")
    var id interface{} = this.SafeString2(trade, "tradeId", "id")
    var orderId interface{} = this.SafeString(trade, "orderId")
    var takerOrMaker interface{} = this.SafeString(trade, "liquidity")
    var timestamp interface{} = this.SafeInteger(trade, "time")
    if IsTrue(!IsEqual(timestamp, nil)) {
        timestamp = this.ParseToInt(Divide(timestamp, 1000000))
    } else {
        timestamp = this.SafeInteger(trade, "createdAt")
        // if it's a historical v1 trade, the exchange returns timestamp in seconds
        if IsTrue(IsTrue((InOp(trade, "dealValue"))) && IsTrue((!IsEqual(timestamp, nil)))) {
            timestamp = Multiply(timestamp, 1000)
        }
    }
    var priceString interface{} = this.SafeString2(trade, "price", "dealPrice")
    var amountString interface{} = this.SafeString2(trade, "size", "amount")
    var side interface{} = this.SafeString(trade, "side")
    var fee interface{} = nil
    var feeCostString interface{} = this.SafeString(trade, "fee")
    if IsTrue(!IsEqual(feeCostString, nil)) {
        var feeCurrencyId interface{} = this.SafeString(trade, "feeCurrency")
        var feeCurrency interface{} = this.SafeCurrencyCode(feeCurrencyId)
        if IsTrue(IsEqual(feeCurrency, nil)) {
            feeCurrency = Ternary(IsTrue((IsEqual(side, "sell"))), GetValue(market, "quote"), GetValue(market, "base"))
        }
        fee = map[string]interface{} {
            "cost": feeCostString,
            "currency": feeCurrency,
            "rate": this.SafeString(trade, "feeRate"),
        }
    }
    var typeVar interface{} = this.SafeString(trade, "type")
    if IsTrue(IsEqual(typeVar, "match")) {
        typeVar = nil
    }
    var costString interface{} = this.SafeString2(trade, "funds", "dealValue")
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "id": id,
        "order": orderId,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": GetValue(market, "symbol"),
        "type": typeVar,
        "takerOrMaker": takerOrMaker,
        "side": side,
        "price": priceString,
        "amount": amountString,
        "cost": costString,
        "fee": fee,
    }, market)
}
/**
 * @method
 * @name kucoin#fetchTradingFee
 * @description fetch the trading fees for a market
 * @see https://www.kucoin.com/docs/rest/funding/trade-fee/trading-pair-actual-fee-spot-margin-trade_hf
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func  (this *kucoin) FetchTradingFee(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes34878 := (<-this.LoadMarkets())
            PanicOnError(retRes34878)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbols": GetValue(market, "id"),
            }
        
            response:= (<-this.PrivateGetTradeFees(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "200000",
            //         "data": [
            //           {
            //             "symbol": "BTC-USDT",
            //             "takerFeeRate": "0.001",
            //             "makerFeeRate": "0.001"
            //           }
            //         ]
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
            var first interface{} = this.SafeDict(data, 0)
            var marketId interface{} = this.SafeString(first, "symbol")
        
            ch <- map[string]interface{} {
                "info": response,
                "symbol": this.SafeSymbol(marketId, market),
                "maker": this.SafeNumber(first, "makerFeeRate"),
                "taker": this.SafeNumber(first, "takerFeeRate"),
                "percentage": true,
                "tierBased": true,
            }
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoin#withdraw
 * @description make a withdrawal
 * @see https://www.kucoin.com/docs/rest/funding/withdrawals/apply-withdraw-v3-
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *kucoin) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params);
            tag = GetValue(tagparamsVariable,0);
            params = GetValue(tagparamsVariable,1)
        
            retRes35328 := (<-this.LoadMarkets())
            PanicOnError(retRes35328)
            this.CheckAddress(address)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "currency": GetValue(currency, "id"),
                "toAddress": address,
                "withdrawType": "ADDRESS",
            }
            if IsTrue(!IsEqual(tag, nil)) {
                AddElementToObject(request, "memo", tag)
            }
            var networkCode interface{} = nil
            networkCodeparamsVariable := this.HandleNetworkCodeAndParams(params);
            networkCode = GetValue(networkCodeparamsVariable,0);
            params = GetValue(networkCodeparamsVariable,1)
            if IsTrue(!IsEqual(networkCode, nil)) {
                AddElementToObject(request, "chain", ToLower(this.NetworkCodeToId(networkCode)))
            }
            AddElementToObject(request, "amount", ParseFloat(this.CurrencyToPrecision(code, amount, networkCode)))
            var includeFee interface{} = nil
            includeFeeparamsVariable := this.HandleOptionAndParams(params, "withdraw", "includeFee", false);
            includeFee = GetValue(includeFeeparamsVariable,0);
            params = GetValue(includeFeeparamsVariable,1)
            if IsTrue(includeFee) {
                AddElementToObject(request, "feeDeductType", "INTERNAL")
            }
        
            response:= (<-this.PrivatePostWithdrawals(this.Extend(request, params)))
            PanicOnError(response)
            //
            // the id is inside "data"
            //
            //     {
            //         "code":  200000,
            //         "data": {
            //             "withdrawalId":  "5bffb63303aa675e8bbe18f9"
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseTransaction(data, currency)
            return nil
        
            }()
            return ch
        }
func  (this *kucoin) ParseTransactionStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "SUCCESS": "ok",
        "PROCESSING": "pending",
        "WALLET_PROCESSING": "pending",
        "FAILURE": "failed",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *kucoin) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchDeposits
    //
    //     {
    //         "address": "0x5f047b29041bcfdbf0e4478cdfa753a336ba6989",
    //         "memo": "5c247c8a03aa677cea2a251d",
    //         "amount": 1,
    //         "fee": 0.0001,
    //         "currency": "KCS",
    //         "chain": "",
    //         "isInner": false,
    //         "walletTxId": "5bbb57386d99522d9f954c5a@test004",
    //         "status": "SUCCESS",
    //         "createdAt": 1544178843000,
    //         "updatedAt": 1544178891000
    //         "remark":"foobar"
    //     }
    //
    // fetchWithdrawals
    //
    //     {
    //         "id": "5c2dc64e03aa675aa263f1ac",
    //         "address": "0x5bedb060b8eb8d823e2414d82acce78d38be7fe9",
    //         "memo": "",
    //         "currency": "ETH",
    //         "chain": "",
    //         "amount": 1.0000000,
    //         "fee": 0.0100000,
    //         "walletTxId": "3e2414d82acce78d38be7fe9",
    //         "isInner": false,
    //         "status": "FAILURE",
    //         "createdAt": 1546503758000,
    //         "updatedAt": 1546504603000
    //         "remark":"foobar"
    //     }
    //
    // withdraw
    //
    //     {
    //         "withdrawalId":  "5bffb63303aa675e8bbe18f9"
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var currencyId interface{} = this.SafeString(transaction, "currency")
    var code interface{} = this.SafeCurrencyCode(currencyId, currency)
    var address interface{} = this.SafeString(transaction, "address")
    var amount interface{} = this.SafeString(transaction, "amount")
    var txid interface{} = this.SafeString(transaction, "walletTxId")
    if IsTrue(!IsEqual(txid, nil)) {
        var txidParts interface{} = Split(txid, "@")
        var numTxidParts interface{} =         GetArrayLength(txidParts)
        if IsTrue(IsGreaterThan(numTxidParts, 1)) {
            if IsTrue(IsEqual(address, nil)) {
                if IsTrue(IsGreaterThan(GetLength(GetValue(txidParts, 1)), 1)) {
                    address = GetValue(txidParts, 1)
                }
            }
        }
        txid = GetValue(txidParts, 0)
    }
    var typeVar interface{} = Ternary(IsTrue((IsEqual(txid, nil))), "withdrawal", "deposit")
    var rawStatus interface{} = this.SafeString(transaction, "status")
    var fee interface{} = nil
    var feeCost interface{} = this.SafeString(transaction, "fee")
    if IsTrue(!IsEqual(feeCost, nil)) {
        var rate interface{} = nil
        if IsTrue(!IsEqual(amount, nil)) {
            rate = Precise.StringDiv(feeCost, amount)
        }
        fee = map[string]interface{} {
            "cost": this.ParseNumber(feeCost),
            "rate": this.ParseNumber(rate),
            "currency": code,
        }
    }
    var timestamp interface{} = this.SafeInteger2(transaction, "createdAt", "createAt")
    var updated interface{} = this.SafeInteger(transaction, "updatedAt")
    var isV1 interface{} =     !IsTrue((InOp(transaction, "createdAt")))
    // if it's a v1 structure
    if IsTrue(isV1) {
        typeVar = Ternary(IsTrue((InOp(transaction, "address"))), "withdrawal", "deposit")
        if IsTrue(!IsEqual(timestamp, nil)) {
            timestamp = Multiply(timestamp, 1000)
        }
        if IsTrue(!IsEqual(updated, nil)) {
            updated = Multiply(updated, 1000)
        }
    }
    var internal interface{} = this.SafeBool(transaction, "isInner")
    var tag interface{} = this.SafeString(transaction, "memo")
    return map[string]interface{} {
        "info": transaction,
        "id": this.SafeString2(transaction, "id", "withdrawalId"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "network": this.NetworkIdToCode(this.SafeString(transaction, "chain")),
        "address": address,
        "addressTo": address,
        "addressFrom": nil,
        "tag": tag,
        "tagTo": tag,
        "tagFrom": nil,
        "currency": code,
        "amount": this.ParseNumber(amount),
        "txid": txid,
        "type": typeVar,
        "status": this.ParseTransactionStatus(rawStatus),
        "comment": this.SafeString(transaction, "remark"),
        "internal": internal,
        "fee": fee,
        "updated": updated,
    }
}
/**
 * @method
 * @name kucoin#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://www.kucoin.com/docs/rest/funding/deposit/get-deposit-list
 * @see https://www.kucoin.com/docs/rest/funding/deposit/get-v1-historical-deposits-list
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch entries for
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *kucoin) FetchDeposits(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes37128 := (<-this.LoadMarkets())
            PanicOnError(retRes37128)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchDeposits", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes371619 :=  (<-this.FetchPaginatedCallDynamic("fetchDeposits", code, since, limit, params))
                    PanicOnError(retRes371619)
                    ch <- retRes371619
                    return nil
            }
            var request interface{} = map[string]interface{} {}
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "currency", GetValue(currency, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "pageSize", limit)
            }
            requestparamsVariable := this.HandleUntilOption("endAt", request, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
            var response interface{} = nil
            if IsTrue(IsTrue(!IsEqual(since, nil)) && IsTrue(IsLessThan(since, 1550448000000))) {
                // if since is earlier than 2019-02-18T00:00:00Z
                AddElementToObject(request, "startAt", this.ParseToInt(Divide(since, 1000)))
                
        response = (<-this.PrivateGetHistDeposits(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                if IsTrue(!IsEqual(since, nil)) {
                    AddElementToObject(request, "startAt", since)
                }
                
        response = (<-this.PrivateGetDeposits(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            //     {
            //         "code": "200000",
            //         "data": {
            //             "currentPage": 1,
            //             "pageSize": 5,
            //             "totalNum": 2,
            //             "totalPage": 1,
            //             "items": [
            //                 //--------------------------------------------------
            //                 // version 2 deposit response structure
            //                 {
            //                     "address": "0x5f047b29041bcfdbf0e4478cdfa753a336ba6989",
            //                     "memo": "5c247c8a03aa677cea2a251d",
            //                     "amount": 1,
            //                     "fee": 0.0001,
            //                     "currency": "KCS",
            //                     "isInner": false,
            //                     "walletTxId": "5bbb57386d99522d9f954c5a@test004",
            //                     "status": "SUCCESS",
            //                     "createdAt": 1544178843000,
            //                     "updatedAt": 1544178891000
            //                     "remark":"foobar"
            //                 },
            //                 //--------------------------------------------------
            //                 // version 1 (historical) deposit response structure
            //                 {
            //                     "currency": "BTC",
            //                     "createAt": 1528536998,
            //                     "amount": "0.03266638",
            //                     "walletTxId": "55c643bc2c68d6f17266383ac1be9e454038864b929ae7cee0bc408cc5c869e8@12ffGWmMMD1zA1WbFm7Ho3JZ1w6NYXjpFk@234",
            //                     "isInner": false,
            //                     "status": "SUCCESS",
            //                 }
            //             ]
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var items interface{} = this.SafeList(data, "items", []interface{}{})
        
            ch <- this.ParseTransactions(items, currency, since, limit, map[string]interface{} {
                "type": "deposit",
            })
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoin#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @see https://www.kucoin.com/docs/rest/funding/withdrawals/get-withdrawals-list
 * @see https://www.kucoin.com/docs/rest/funding/withdrawals/get-v1-historical-withdrawals-list
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawals structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch entries for
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *kucoin) FetchWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes37978 := (<-this.LoadMarkets())
            PanicOnError(retRes37978)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchWithdrawals", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes380119 :=  (<-this.FetchPaginatedCallDynamic("fetchWithdrawals", code, since, limit, params))
                    PanicOnError(retRes380119)
                    ch <- retRes380119
                    return nil
            }
            var request interface{} = map[string]interface{} {}
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "currency", GetValue(currency, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "pageSize", limit)
            }
            requestparamsVariable := this.HandleUntilOption("endAt", request, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
            var response interface{} = nil
            if IsTrue(IsTrue(!IsEqual(since, nil)) && IsTrue(IsLessThan(since, 1550448000000))) {
                // if since is earlier than 2019-02-18T00:00:00Z
                AddElementToObject(request, "startAt", this.ParseToInt(Divide(since, 1000)))
                
        response = (<-this.PrivateGetHistWithdrawals(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                if IsTrue(!IsEqual(since, nil)) {
                    AddElementToObject(request, "startAt", since)
                }
                
        response = (<-this.PrivateGetWithdrawals(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            //     {
            //         "code": "200000",
            //         "data": {
            //             "currentPage": 1,
            //             "pageSize": 5,
            //             "totalNum": 2,
            //             "totalPage": 1,
            //             "items": [
            //                 //--------------------------------------------------
            //                 // version 2 withdrawal response structure
            //                 {
            //                     "id": "5c2dc64e03aa675aa263f1ac",
            //                     "address": "0x5bedb060b8eb8d823e2414d82acce78d38be7fe9",
            //                     "memo": "",
            //                     "currency": "ETH",
            //                     "amount": 1.0000000,
            //                     "fee": 0.0100000,
            //                     "walletTxId": "3e2414d82acce78d38be7fe9",
            //                     "isInner": false,
            //                     "status": "FAILURE",
            //                     "createdAt": 1546503758000,
            //                     "updatedAt": 1546504603000
            //                 },
            //                 //--------------------------------------------------
            //                 // version 1 (historical) withdrawal response structure
            //                 {
            //                     "currency": "BTC",
            //                     "createAt": 1526723468,
            //                     "amount": "0.534",
            //                     "address": "33xW37ZSW4tQvg443Pc7NLCAs167Yc2XUV",
            //                     "walletTxId": "aeacea864c020acf58e51606169240e96774838dcd4f7ce48acf38e3651323f4",
            //                     "isInner": false,
            //                     "status": "SUCCESS"
            //                 }
            //             ]
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var items interface{} = this.SafeList(data, "items", []interface{}{})
        
            ch <- this.ParseTransactions(items, currency, since, limit, map[string]interface{} {
                "type": "withdrawal",
            })
            return nil
        
            }()
            return ch
        }
func  (this *kucoin) ParseBalanceHelper(entry interface{}) interface{}  {
    var account interface{} = this.Account()
    AddElementToObject(account, "used", this.SafeString2(entry, "holdBalance", "hold"))
    AddElementToObject(account, "free", this.SafeString2(entry, "availableBalance", "available"))
    AddElementToObject(account, "total", this.SafeString2(entry, "totalBalance", "total"))
    var debt interface{} = this.SafeString(entry, "liability")
    var interest interface{} = this.SafeString(entry, "interest")
    AddElementToObject(account, "debt", Precise.StringAdd(debt, interest))
    return account
}
/**
 * @method
 * @name kucoin#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://www.kucoin.com/docs/rest/account/basic-info/get-account-list-spot-margin-trade_hf
 * @see https://www.kucoin.com/docs/rest/funding/funding-overview/get-account-detail-margin
 * @see https://www.kucoin.com/docs/rest/funding/funding-overview/get-account-detail-isolated-margin
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {object} [params.marginMode] 'cross' or 'isolated', margin type for fetching margin balance
 * @param {object} [params.type] extra parameters specific to the exchange API endpoint
 * @param {object} [params.hf] *default if false* if true, the result includes the balance of the high frequency account
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *kucoin) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes38938 := (<-this.LoadMarkets())
            PanicOnError(retRes38938)
            var code interface{} = this.SafeString(params, "code")
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
            }
            var defaultType interface{} = this.SafeString2(this.Options, "fetchBalance", "defaultType", "spot")
            var requestedType interface{} = this.SafeString(params, "type", defaultType)
            var accountsByType interface{} = this.SafeDict(this.Options, "accountsByType")
            var typeVar interface{} = this.SafeString(accountsByType, requestedType, requestedType)
            params = this.Omit(params, "type")
            var hf interface{} = nil
            hfparamsVariable := this.HandleHfAndParams(params);
            hf = GetValue(hfparamsVariable,0);
            params = GetValue(hfparamsVariable,1)
            if IsTrue(IsTrue(hf) && IsTrue((!IsEqual(typeVar, "main")))) {
                typeVar = "trade_hf"
            }
            marginModequeryVariable := this.HandleMarginModeAndParams("fetchBalance", params);
            marginMode := GetValue(marginModequeryVariable,0);
            query := GetValue(marginModequeryVariable,1)
            var response interface{} = nil
            var request interface{} = map[string]interface{} {}
            var isolated interface{} = IsTrue((IsEqual(marginMode, "isolated"))) || IsTrue((IsEqual(typeVar, "isolated")))
            var cross interface{} = IsTrue((IsEqual(marginMode, "cross"))) || IsTrue((IsEqual(typeVar, "margin")))
            if IsTrue(isolated) {
                if IsTrue(!IsEqual(currency, nil)) {
                    AddElementToObject(request, "balanceCurrency", GetValue(currency, "id"))
                }
                
        response = (<-this.PrivateGetIsolatedAccounts(this.Extend(request, query)))
                PanicOnError(response)
            } else if IsTrue(cross) {
                
        response = (<-this.PrivateGetMarginAccount(this.Extend(request, query)))
                PanicOnError(response)
            } else {
                if IsTrue(!IsEqual(currency, nil)) {
                    AddElementToObject(request, "currency", GetValue(currency, "id"))
                }
                AddElementToObject(request, "type", typeVar)
                
        response = (<-this.PrivateGetAccounts(this.Extend(request, query)))
                PanicOnError(response)
            }
            //
            // Spot
            //
            //    {
            //        "code": "200000",
            //        "data": [
            //            {
            //                "balance": "0.00009788",
            //                "available": "0.00009788",
            //                "holds": "0",
            //                "currency": "BTC",
            //                "id": "5c6a4fd399a1d81c4f9cc4d0",
            //                "type": "trade",
            //            },
            //        ]
            //    }
            //
            // Cross
            //
            //     {
            //         "code": "200000",
            //         "data": {
            //             "debtRatio": "0",
            //             "accounts": [
            //                 {
            //                     "currency": "USDT",
            //                     "totalBalance": "5",
            //                     "availableBalance": "5",
            //                     "holdBalance": "0",
            //                     "liability": "0",
            //                     "maxBorrowSize": "20"
            //                 },
            //             ]
            //         }
            //     }
            //
            // Isolated
            //
            //    {
            //        "code": "200000",
            //        "data": {
            //            "totalAssetOfQuoteCurrency": "0",
            //            "totalLiabilityOfQuoteCurrency": "0",
            //            "timestamp": 1712085661155,
            //            "assets": [
            //                {
            //                    "symbol": "MANA-USDT",
            //                    "status": "EFFECTIVE",
            //                    "debtRatio": "0",
            //                    "baseAsset": {
            //                        "currency": "MANA",
            //                        "borrowEnabled": true,
            //                        "transferInEnabled": true,
            //                        "total": "0",
            //                        "hold": "0",
            //                        "available": "0",
            //                        "liability": "0",
            //                        "interest": "0",
            //                        "maxBorrowSize": "0"
            //                    },
            //                    "quoteAsset": {
            //                        "currency": "USDT",
            //                        "borrowEnabled": true,
            //                        "transferInEnabled": true,
            //                        "total": "0",
            //                        "hold": "0",
            //                        "available": "0",
            //                        "liability": "0",
            //                        "interest": "0",
            //                        "maxBorrowSize": "0"
            //                    }
            //                },
            //                ...
            //            ]
            //        }
            //    }
            //
            var data interface{} = nil
            var result interface{} = map[string]interface{} {
                "info": response,
                "timestamp": nil,
                "datetime": nil,
            }
            if IsTrue(isolated) {
                data = this.SafeDict(response, "data", map[string]interface{} {})
                var assets interface{} = this.SafeValue(data, "assets", data)
                for i := 0; IsLessThan(i, GetArrayLength(assets)); i++ {
                    var entry interface{} = GetValue(assets, i)
                    var marketId interface{} = this.SafeString(entry, "symbol")
                    var symbol interface{} = this.SafeSymbol(marketId, nil, "_")
                    var base interface{} = this.SafeDict(entry, "baseAsset", map[string]interface{} {})
                    var quote interface{} = this.SafeDict(entry, "quoteAsset", map[string]interface{} {})
                    var baseCode interface{} = this.SafeCurrencyCode(this.SafeString(base, "currency"))
                    var quoteCode interface{} = this.SafeCurrencyCode(this.SafeString(quote, "currency"))
                    var subResult interface{} = map[string]interface{} {}
                    AddElementToObject(subResult, baseCode, this.ParseBalanceHelper(base))
                    AddElementToObject(subResult, quoteCode, this.ParseBalanceHelper(quote))
                    AddElementToObject(result, symbol, this.SafeBalance(subResult))
                }
            } else if IsTrue(cross) {
                data = this.SafeDict(response, "data", map[string]interface{} {})
                var accounts interface{} = this.SafeList(data, "accounts", []interface{}{})
                for i := 0; IsLessThan(i, GetArrayLength(accounts)); i++ {
                    var balance interface{} = GetValue(accounts, i)
                    var currencyId interface{} = this.SafeString(balance, "currency")
                    var codeInner interface{} = this.SafeCurrencyCode(currencyId)
                    AddElementToObject(result, codeInner, this.ParseBalanceHelper(balance))
                }
            } else {
                data = this.SafeList(response, "data", []interface{}{})
                for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
                    var balance interface{} = GetValue(data, i)
                    var balanceType interface{} = this.SafeString(balance, "type")
                    if IsTrue(IsEqual(balanceType, typeVar)) {
                        var currencyId interface{} = this.SafeString(balance, "currency")
                        var codeInner2 interface{} = this.SafeCurrencyCode(currencyId)
                        var account interface{} = this.Account()
                        AddElementToObject(account, "total", this.SafeString(balance, "balance"))
                        AddElementToObject(account, "free", this.SafeString(balance, "available"))
                        AddElementToObject(account, "used", this.SafeString(balance, "holds"))
                        AddElementToObject(result, codeInner2, account)
                    }
                }
            }
            var returnType interface{} = result
            if !IsTrue(isolated) {
                returnType = this.SafeBalance(result)
            }
        
            ch <- returnType
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoin#transfer
 * @description transfer currency internally between wallets on the same account
 * @see https://www.kucoin.com/docs/rest/funding/transfer/inner-transfer
 * @see https://docs.kucoin.com/futures/#transfer-funds-to-kucoin-main-account-2
 * @see https://docs.kucoin.com/spot-hf/#internal-funds-transfers-in-high-frequency-trading-accounts
 * @param {string} code unified currency code
 * @param {float} amount amount to transfer
 * @param {string} fromAccount account to transfer from
 * @param {string} toAccount account to transfer to
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func  (this *kucoin) Transfer(code interface{}, amount interface{}, fromAccount interface{}, toAccount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes40748 := (<-this.LoadMarkets())
            PanicOnError(retRes40748)
            var currency interface{} = this.Currency(code)
            var requestedAmount interface{} = this.CurrencyToPrecision(code, amount)
            var fromId interface{} = this.ConvertTypeToAccount(fromAccount)
            var toId interface{} = this.ConvertTypeToAccount(toAccount)
            var fromIsolated interface{} = this.InArray(fromId, this.Ids)
            var toIsolated interface{} = this.InArray(toId, this.Ids)
            if IsTrue(IsEqual(fromId, "contract")) {
                if IsTrue(!IsEqual(toId, "main")) {
                    panic(ExchangeError(Add(this.Id, " transfer() only supports transferring from futures account to main account")))
                }
                var request interface{} = map[string]interface{} {
                    "currency": GetValue(currency, "id"),
                    "amount": requestedAmount,
                }
                if !IsTrue((InOp(params, "bizNo"))) {
                    // it doesn't like more than 24 characters
                    AddElementToObject(request, "bizNo", this.Uuid22())
                }
        
                response:= (<-this.FuturesPrivatePostTransferOut(this.Extend(request, params)))
                PanicOnError(response)
                //
                //     {
                //         "code": "200000",
                //         "data": {
                //             "applyId": "605a87217dff1500063d485d",
                //             "bizNo": "bcd6e5e1291f4905af84dc",
                //             "payAccountType": "CONTRACT",
                //             "payTag": "DEFAULT",
                //             "remark": '',
                //             "recAccountType": "MAIN",
                //             "recTag": "DEFAULT",
                //             "recRemark": '',
                //             "recSystem": "KUCOIN",
                //             "status": "PROCESSING",
                //             "currency": "XBT",
                //             "amount": "0.00001",
                //             "fee": "0",
                //             "sn": "573688685663948",
                //             "reason": '',
                //             "createdAt": 1616545569000,
                //             "updatedAt": 1616545569000
                //         }
                //     }
                //
                var data interface{} = this.SafeDict(response, "data")
        
                ch <- this.ParseTransfer(data, currency)
                return nil
            } else {
                var request interface{} = map[string]interface{} {
                    "currency": GetValue(currency, "id"),
                    "amount": requestedAmount,
                }
                if IsTrue(IsTrue(fromIsolated) || IsTrue(toIsolated)) {
                    if IsTrue(this.InArray(fromId, this.Ids)) {
                        AddElementToObject(request, "fromTag", fromId)
                        fromId = "isolated"
                    }
                    if IsTrue(this.InArray(toId, this.Ids)) {
                        AddElementToObject(request, "toTag", toId)
                        toId = "isolated"
                    }
                }
                AddElementToObject(request, "from", fromId)
                AddElementToObject(request, "to", toId)
                if !IsTrue((InOp(params, "clientOid"))) {
                    AddElementToObject(request, "clientOid", this.Uuid())
                }
        
                response:= (<-this.PrivatePostAccountsInnerTransfer(this.Extend(request, params)))
                PanicOnError(response)
                //
                //     {
                //         "code": "200000",
                //         "data": {
                //              "orderId": "605a6211e657f00006ad0ad6"
                //         }
                //     }
                //
                var data interface{} = this.SafeDict(response, "data")
        
                ch <- this.ParseTransfer(data, currency)
                return nil
            }
                return nil
            }()
            return ch
        }
func  (this *kucoin) ParseTransfer(transfer interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // transfer (spot)
    //
    //    {
    //        "orderId": "605a6211e657f00006ad0ad6"
    //    }
    //
    //    {
    //        "code": "200000",
    //        "msg": "Failed to transfer out. The amount exceeds the upper limit"
    //    }
    //
    // transfer (futures)
    //
    //     {
    //         "applyId": "605a87217dff1500063d485d",
    //         "bizNo": "bcd6e5e1291f4905af84dc",
    //         "payAccountType": "CONTRACT",
    //         "payTag": "DEFAULT",
    //         "remark": '',
    //         "recAccountType": "MAIN",
    //         "recTag": "DEFAULT",
    //         "recRemark": '',
    //         "recSystem": "KUCOIN",
    //         "status": "PROCESSING",
    //         "currency": "XBT",
    //         "amount": "0.00001",
    //         "fee": "0",
    //         "sn": "573688685663948",
    //         "reason": '',
    //         "createdAt": 1616545569000,
    //         "updatedAt": 1616545569000
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var timestamp interface{} = this.SafeInteger(transfer, "createdAt")
    var currencyId interface{} = this.SafeString(transfer, "currency")
    var rawStatus interface{} = this.SafeString(transfer, "status")
    var accountFromRaw interface{} = this.SafeStringLower(transfer, "payAccountType")
    var accountToRaw interface{} = this.SafeStringLower(transfer, "recAccountType")
    var accountsByType interface{} = this.SafeDict(this.Options, "accountsByType")
    var accountFrom interface{} = this.SafeString(accountsByType, accountFromRaw, accountFromRaw)
    var accountTo interface{} = this.SafeString(accountsByType, accountToRaw, accountToRaw)
    return map[string]interface{} {
        "id": this.SafeString2(transfer, "applyId", "orderId"),
        "currency": this.SafeCurrencyCode(currencyId, currency),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "amount": this.SafeNumber(transfer, "amount"),
        "fromAccount": accountFrom,
        "toAccount": accountTo,
        "status": this.ParseTransferStatus(rawStatus),
        "info": transfer,
    }
}
func  (this *kucoin) ParseTransferStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "PROCESSING": "pending",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *kucoin) ParseLedgerEntryType(typeVar interface{}) interface{}  {
    var types interface{} = map[string]interface{} {
        "Assets Transferred in After Upgrading": "transfer",
        "Deposit": "transaction",
        "Withdrawal": "transaction",
        "Transfer": "transfer",
        "Trade_Exchange": "trade",
        "KuCoin Bonus": "bonus",
        "Referral Bonus": "referral",
        "Rewards": "bonus",
        "Airdrop/Fork": "airdrop",
        "Other rewards": "bonus",
        "Fee Rebate": "rebate",
        "Buy Crypto": "trade",
        "Sell Crypto": "sell",
        "Public Offering Purchase": "trade",
        "Refunded Fees": "fee",
        "KCS Pay Fees": "fee",
        "Margin Trade": "trade",
        "Loans": "Loans",
        "Instant Exchange": "trade",
        "Sub-account transfer": "transfer",
        "Liquidation Fees": "fee",
    }
    return this.SafeString(types, typeVar, typeVar)
}
func  (this *kucoin) ParseLedgerEntry(item interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "id": "611a1e7c6a053300067a88d9", //unique key for each ledger entry
    //         "currency": "USDT", //Currency
    //         "amount": "10.00059547", //The total amount of assets (fees included) involved in assets changes such as transaction, withdrawal and bonus distribution.
    //         "fee": "0", //Deposit or withdrawal fee
    //         "balance": "0", //Total assets of a currency remaining funds after transaction
    //         "accountType": "MAIN", //Account Type
    //         "bizType": "Loans Repaid", //business type
    //         "direction": "in", //side, in or out
    //         "createdAt": 1629101692950, //Creation time
    //         "context": "{\"borrowerUserId\":\"601ad03e50dc810006d242ea\",\"loanRepayDetailNo\":\"611a1e7cc913d000066cf7ec\"}" //Business core parameters
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var id interface{} = this.SafeString(item, "id")
    var currencyId interface{} = this.SafeString(item, "currency")
    var code interface{} = this.SafeCurrencyCode(currencyId, currency)
    currency = this.SafeCurrency(currencyId, currency)
    var amount interface{} = this.SafeNumber(item, "amount")
    var balanceAfter interface{} = nil
    // const balanceAfter = this.safeNumber (item, 'balance'); only returns zero string
    var bizType interface{} = this.SafeString(item, "bizType")
    var typeVar interface{} = this.ParseLedgerEntryType(bizType)
    var direction interface{} = this.SafeString(item, "direction")
    var timestamp interface{} = this.SafeInteger(item, "createdAt")
    var datetime interface{} = this.Iso8601(timestamp)
    var account interface{} = this.SafeString(item, "accountType") // MAIN, TRADE, MARGIN, or CONTRACT
    var context interface{} = this.SafeString(item, "context") // contains other information about the ledger entry
    //
    // withdrawal transaction
    //
    //     "{\"orderId\":\"617bb2d09e7b3b000196dac8\",\"txId\":\"0x79bb9855f86b351a45cab4dc69d78ca09586a94c45dde49475722b98f401b054\"}"
    //
    // deposit to MAIN, trade via MAIN
    //
    //     "{\"orderId\":\"617ab9949e7b3b0001948081\",\"txId\":\"0x7a06b16bbd6b03dbc3d96df5683b15229fc35e7184fd7179a5f3a310bd67d1fa@default@0\"}"
    //
    // sell trade
    //
    //     "{\"symbol\":\"ETH-USDT\",\"orderId\":\"617adcd1eb3fa20001dd29a1\",\"tradeId\":\"617adcd12e113d2b91222ff9\"}"
    //
    var referenceId interface{} = nil
    if IsTrue(IsTrue(!IsEqual(context, nil)) && IsTrue(!IsEqual(context, ""))) {
        
        {		ret__ := func(this *kucoin) (ret_ interface{}) {
        		defer func() {
        			if e := recover(); e != nil {
                        if e == "break" {
        				    return
        			    }
        				ret_ = func(this *kucoin) interface{} {
        					// catch block:
                                        referenceId = context
                            return nil
        				}(this)
        			}
        		}()
        		// try block:
                            var parsed interface{} = JsonParse(context)
                    var orderId interface{} = this.SafeString(parsed, "orderId")
                    var tradeId interface{} = this.SafeString(parsed, "tradeId")
                    // transactions only have an orderId but for trades we wish to use tradeId
                    if IsTrue(!IsEqual(tradeId, nil)) {
                        referenceId = tradeId
                    } else {
                        referenceId = orderId
                    }
        		return nil
        	}(this)
        	if ret__ != nil {
        		return ret__
        	}
        }
    }
    var fee interface{} = nil
    var feeCost interface{} = this.SafeString(item, "fee")
    var feeCurrency interface{} = nil
    if IsTrue(!IsEqual(feeCost, "0")) {
        feeCurrency = code
        fee = map[string]interface{} {
            "cost": this.ParseNumber(feeCost),
            "currency": feeCurrency,
        }
    }
    return this.SafeLedgerEntry(map[string]interface{} {
        "info": item,
        "id": id,
        "direction": direction,
        "account": account,
        "referenceId": referenceId,
        "referenceAccount": account,
        "type": typeVar,
        "currency": code,
        "amount": amount,
        "timestamp": timestamp,
        "datetime": datetime,
        "before": nil,
        "after": balanceAfter,
        "status": nil,
        "fee": fee,
    }, currency)
}
/**
 * @method
 * @name kucoin#fetchLedger
 * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
 * @see https://www.kucoin.com/docs/rest/account/basic-info/get-account-ledgers-spot-margin
 * @see https://www.kucoin.com/docs/rest/account/basic-info/get-account-ledgers-trade_hf
 * @see https://www.kucoin.com/docs/rest/account/basic-info/get-account-ledgers-margin_hf
 * @param {string} [code] unified currency code, default is undefined
 * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
 * @param {int} [limit] max number of ledger entries to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {boolean} [params.hf] default false, when true will fetch ledger entries for the high frequency trading account
 * @param {int} [params.until] the latest time in ms to fetch entries for
 * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
 * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger}
 */
func  (this *kucoin) FetchLedger(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes43638 := (<-this.LoadMarkets())
            PanicOnError(retRes43638)
        
            retRes43648 := (<-this.LoadAccounts())
            PanicOnError(retRes43648)
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, "fetchLedger", "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            var hf interface{} = nil
            hfparamsVariable := this.HandleHfAndParams(params);
            hf = GetValue(hfparamsVariable,0);
            params = GetValue(hfparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes437019 :=  (<-this.FetchPaginatedCallDynamic("fetchLedger", code, since, limit, params))
                    PanicOnError(retRes437019)
                    ch <- retRes437019
                    return nil
            }
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startAt", since)
            }
            // atm only single currency retrieval is supported
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "currency", GetValue(currency, "id"))
            }
            requestparamsVariable := this.HandleUntilOption("endAt", request, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
            var marginMode interface{} = nil
            marginModeparamsVariable := this.HandleMarginModeAndParams("fetchLedger", params);
            marginMode = GetValue(marginModeparamsVariable,0);
            params = GetValue(marginModeparamsVariable,1)
            var response interface{} = nil
            if IsTrue(hf) {
                if IsTrue(!IsEqual(marginMode, nil)) {
                    
        response = (<-this.PrivateGetHfMarginAccountLedgers(this.Extend(request, params)))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.PrivateGetHfAccountsLedgers(this.Extend(request, params)))
                    PanicOnError(response)
                }
            } else {
                
        response = (<-this.PrivateGetAccountsLedgers(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            //     {
            //         "code":"200000",
            //         "data":{
            //             "currentPage":1,
            //             "pageSize":50,
            //             "totalNum":1,
            //             "totalPage":1,
            //             "items":[
            //                 {
            //                     "id":"617cc528729f5f0001c03ceb",
            //                     "currency":"GAS",
            //                     "amount":"0.00000339",
            //                     "fee":"0",
            //                     "balance":"0",
            //                     "accountType":"MAIN",
            //                     "bizType":"Distribution",
            //                     "direction":"in",
            //                     "createdAt":1635566888183,
            //                     "context":"{\"orderId\":\"617cc47a1c47ed0001ce3606\",\"description\":\"Holding NEO,distribute GAS(2021/10/30)\"}"
            //                 }
            //                 {
            //                     "id": "611a1e7c6a053300067a88d9",//unique key
            //                     "currency": "USDT", //Currency
            //                     "amount": "10.00059547", //Change amount of the funds
            //                     "fee": "0", //Deposit or withdrawal fee
            //                     "balance": "0", //Total assets of a currency
            //                     "accountType": "MAIN", //Account Type
            //                     "bizType": "Loans Repaid", //business type
            //                     "direction": "in", //side, in or out
            //                     "createdAt": 1629101692950, //Creation time
            //                     "context": "{\"borrowerUserId\":\"601ad03e50dc810006d242ea\",\"loanRepayDetailNo\":\"611a1e7cc913d000066cf7ec\"}"
            //                 },
            //             ]
            //         }
            //     }
            //
            var dataList interface{} = this.SafeList(response, "data")
            if IsTrue(!IsEqual(dataList, nil)) {
        
                ch <- this.ParseLedger(dataList, currency, since, limit)
                return nil
            }
            var data interface{} = this.SafeDict(response, "data")
            var items interface{} = this.SafeList(data, "items", []interface{}{})
        
            ch <- this.ParseLedger(items, currency, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *kucoin) CalculateRateLimiterCost(api interface{}, method interface{}, path interface{}, params interface{}, optionalArgs ...interface{}) interface{}  {
    config := GetArg(optionalArgs, 0, map[string]interface{} {})
    _ = config
    var versions interface{} = this.SafeDict(this.Options, "versions", map[string]interface{} {})
    var apiVersions interface{} = this.SafeDict(versions, api, map[string]interface{} {})
    var methodVersions interface{} = this.SafeDict(apiVersions, method, map[string]interface{} {})
    var defaultVersion interface{} = this.SafeString(methodVersions, path, GetValue(this.Options, "version"))
    var version interface{} = this.SafeString(params, "version", defaultVersion)
    if IsTrue(IsTrue(IsEqual(version, "v3")) && IsTrue((InOp(config, "v3")))) {
        return GetValue(config, "v3")
    } else if IsTrue(IsTrue(IsEqual(version, "v2")) && IsTrue((InOp(config, "v2")))) {
        return GetValue(config, "v2")
    } else if IsTrue(IsTrue(IsEqual(version, "v1")) && IsTrue((InOp(config, "v1")))) {
        return GetValue(config, "v1")
    }
    return this.SafeValue(config, "cost", 1)
}
func  (this *kucoin) ParseBorrowRate(info interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "tradeId": "62db2dcaff219600012b56cd",
    //         "currency": "USDT",
    //         "size": "10",
    //         "dailyIntRate": "0.00003",
    //         "term": 7,
    //         "timestamp": 1658531274508488480
    //     },
    //
    //     {
    //         "createdAt": 1697783812257,
    //         "currency": "XMR",
    //         "interestAmount": "0.1",
    //         "dayRatio": "0.001"
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var timestampId interface{} = this.SafeString2(info, "createdAt", "timestamp")
    var timestamp interface{} = this.ParseToInt(Slice(timestampId, 0, 13))
    var currencyId interface{} = this.SafeString(info, "currency")
    return map[string]interface{} {
        "currency": this.SafeCurrencyCode(currencyId, currency),
        "rate": this.SafeNumber2(info, "dailyIntRate", "dayRatio"),
        "period": 86400000,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "info": info,
    }
}
/**
 * @method
 * @name kucoin#fetchBorrowInterest
 * @description fetch the interest owed by the user for borrowing currency for margin trading
 * @see https://docs.kucoin.com/#get-repay-record
 * @see https://docs.kucoin.com/#query-isolated-margin-account-info
 * @param {string} [code] unified currency code
 * @param {string} [symbol] unified market symbol, required for isolated margin
 * @param {int} [since] the earliest time in ms to fetch borrrow interest for
 * @param {int} [limit] the maximum number of structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] 'cross' or 'isolated' default is 'cross'
 * @returns {object[]} a list of [borrow interest structures]{@link https://docs.ccxt.com/#/?id=borrow-interest-structure}
 */
func  (this *kucoin) FetchBorrowInterest(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            symbol := GetArg(optionalArgs, 1, nil)
            _ = symbol
            since := GetArg(optionalArgs, 2, nil)
            _ = since
            limit := GetArg(optionalArgs, 3, nil)
            _ = limit
            params := GetArg(optionalArgs, 4, map[string]interface{} {})
            _ = params
        
            retRes45098 := (<-this.LoadMarkets())
            PanicOnError(retRes45098)
            var marginMode interface{} = nil
            marginModeparamsVariable := this.HandleMarginModeAndParams("fetchBorrowInterest", params, "cross");
            marginMode = GetValue(marginModeparamsVariable,0);
            params = GetValue(marginModeparamsVariable,1)
            var request interface{} = map[string]interface{} {}
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                if IsTrue(IsEqual(marginMode, "isolated")) {
                    AddElementToObject(request, "balanceCurrency", GetValue(currency, "id"))
                } else {
                    AddElementToObject(request, "quoteCurrency", GetValue(currency, "id"))
                }
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var response interface{} = nil
            if IsTrue(IsEqual(marginMode, "isolated")) {
                
        response = (<-this.PrivateGetIsolatedAccounts(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PrivateGetMarginAccounts(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            // Cross
            //
            //     {
            //         "code": "200000",
            //         "data": {
            //             "totalAssetOfQuoteCurrency": "0",
            //             "totalLiabilityOfQuoteCurrency": "0",
            //             "debtRatio": "0",
            //             "status": "EFFECTIVE",
            //             "accounts": [
            //                 {
            //                     "currency": "1INCH",
            //                     "total": "0",
            //                     "available": "0",
            //                     "hold": "0",
            //                     "liability": "0",
            //                     "maxBorrowSize": "0",
            //                     "borrowEnabled": true,
            //                     "transferInEnabled": true
            //                 }
            //             ]
            //         }
            //     }
            //
            // Isolated
            //
            //     {
            //         "code": "200000",
            //         "data": {
            //             "totalConversionBalance": "0.02138647",
            //             "liabilityConversionBalance": "0.01480001",
            //             "assets": [
            //                 {
            //                     "symbol": "MANA-USDT",
            //                     "debtRatio": "0",
            //                     "status": "BORROW",
            //                     "baseAsset": {
            //                         "currency": "MANA",
            //                         "borrowEnabled": true,
            //                         "repayEnabled": true,
            //                         "transferEnabled": true,
            //                         "borrowed": "0",
            //                         "totalAsset": "0",
            //                         "available": "0",
            //                         "hold": "0",
            //                         "maxBorrowSize": "1000"
            //                     },
            //                     "quoteAsset": {
            //                         "currency": "USDT",
            //                         "borrowEnabled": true,
            //                         "repayEnabled": true,
            //                         "transferEnabled": true,
            //                         "borrowed": "0",
            //                         "totalAsset": "0",
            //                         "available": "0",
            //                         "hold": "0",
            //                         "maxBorrowSize": "50000"
            //                     }
            //                 }
            //             ]
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var assets interface{} = Ternary(IsTrue((IsEqual(marginMode, "isolated"))), this.SafeList(data, "assets", []interface{}{}), this.SafeList(data, "accounts", []interface{}{}))
            var interest interface{} = this.ParseBorrowInterests(assets, market)
            var filteredByCurrency interface{} = this.FilterByCurrencySinceLimit(interest, code, since, limit)
        
            ch <- this.FilterBySymbolSinceLimit(filteredByCurrency, symbol, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *kucoin) ParseBorrowInterest(info interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // Cross
    //
    //     {
    //         "currency": "1INCH",
    //         "total": "0",
    //         "available": "0",
    //         "hold": "0",
    //         "liability": "0",
    //         "maxBorrowSize": "0",
    //         "borrowEnabled": true,
    //         "transferInEnabled": true
    //     }
    //
    // Isolated
    //
    //     {
    //         "symbol": "MANA-USDT",
    //         "debtRatio": "0",
    //         "status": "BORROW",
    //         "baseAsset": {
    //             "currency": "MANA",
    //             "borrowEnabled": true,
    //             "repayEnabled": true,
    //             "transferEnabled": true,
    //             "borrowed": "0",
    //             "totalAsset": "0",
    //             "available": "0",
    //             "hold": "0",
    //             "maxBorrowSize": "1000"
    //         },
    //         "quoteAsset": {
    //             "currency": "USDT",
    //             "borrowEnabled": true,
    //             "repayEnabled": true,
    //             "transferEnabled": true,
    //             "borrowed": "0",
    //             "totalAsset": "0",
    //             "available": "0",
    //             "hold": "0",
    //             "maxBorrowSize": "50000"
    //         }
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(info, "symbol")
    var marginMode interface{} = Ternary(IsTrue((IsEqual(marketId, nil))), "cross", "isolated")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = this.SafeString(market, "symbol")
    var timestamp interface{} = this.SafeInteger(info, "createdAt")
    var isolatedBase interface{} = this.SafeDict(info, "baseAsset", map[string]interface{} {})
    var amountBorrowed interface{} = nil
    var interest interface{} = nil
    var currencyId interface{} = nil
    if IsTrue(IsEqual(marginMode, "isolated")) {
        amountBorrowed = this.SafeNumber(isolatedBase, "liability")
        interest = this.SafeNumber(isolatedBase, "interest")
        currencyId = this.SafeString(isolatedBase, "currency")
    } else {
        amountBorrowed = this.SafeNumber(info, "liability")
        interest = this.SafeNumber(info, "accruedInterest")
        currencyId = this.SafeString(info, "currency")
    }
    return map[string]interface{} {
        "info": info,
        "symbol": symbol,
        "currency": this.SafeCurrencyCode(currencyId),
        "interest": interest,
        "interestRate": this.SafeNumber(info, "dailyIntRate"),
        "amountBorrowed": amountBorrowed,
        "marginMode": marginMode,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
    }
}
/**
 * @method
 * @name kucoin#fetchBorrowRateHistories
 * @description retrieves a history of a multiple currencies borrow interest rate at specific time slots, returns all currencies if no symbols passed, default is undefined
 * @see https://www.kucoin.com/docs/rest/margin-trading/margin-trading-v3-/get-cross-isolated-margin-interest-records
 * @param {string[]|undefined} codes list of unified currency codes, default is undefined
 * @param {int} [since] timestamp in ms of the earliest borrowRate, default is undefined
 * @param {int} [limit] max number of borrow rate prices to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] 'cross' or 'isolated' default is 'cross'
 * @param {int} [params.until] the latest time in ms to fetch entries for
 * @returns {object} a dictionary of [borrow rate structures]{@link https://docs.ccxt.com/#/?id=borrow-rate-structure} indexed by the market symbol
 */
func  (this *kucoin) FetchBorrowRateHistories(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    codes := GetArg(optionalArgs, 0, nil)
            _ = codes
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes46938 := (<-this.LoadMarkets())
            PanicOnError(retRes46938)
            var marginResult interface{} = this.HandleMarginModeAndParams("fetchBorrowRateHistories", params)
            var marginMode interface{} = this.SafeString(marginResult, 0, "cross")
            var isIsolated interface{} =     (IsEqual(marginMode, "isolated")) // true-isolated, false-cross
            var request interface{} = map[string]interface{} {
                "isIsolated": isIsolated,
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            requestparamsVariable := this.HandleUntilOption("endTime", request, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "pageSize", limit) // default:50, min:10, max:500
            }
        
            response:= (<-this.PrivateGetMarginInterest(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "200000",
            //         "data": {
            //             "timestamp": 1710829939673,
            //             "currentPage": 1,
            //             "pageSize": 50,
            //             "totalNum": 0,
            //             "totalPage": 0,
            //             "items": [
            //                 {
            //                     "createdAt": 1697783812257,
            //                     "currency": "XMR",
            //                     "interestAmount": "0.1",
            //                     "dayRatio": "0.001"
            //                 }
            //             ]
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data")
            var rows interface{} = this.SafeList(data, "items", []interface{}{})
        
            ch <- this.ParseBorrowRateHistories(rows, codes, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoin#fetchBorrowRateHistory
 * @description retrieves a history of a currencies borrow interest rate at specific time slots
 * @see https://www.kucoin.com/docs/rest/margin-trading/margin-trading-v3-/get-cross-isolated-margin-interest-records
 * @param {string} code unified currency code
 * @param {int} [since] timestamp for the earliest borrow rate
 * @param {int} [limit] the maximum number of [borrow rate structures]{@link https://docs.ccxt.com/#/?id=borrow-rate-structure} to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.marginMode] 'cross' or 'isolated' default is 'cross'
 * @param {int} [params.until] the latest time in ms to fetch entries for
 * @returns {object[]} an array of [borrow rate structures]{@link https://docs.ccxt.com/#/?id=borrow-rate-structure}
 */
func  (this *kucoin) FetchBorrowRateHistory(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes47478 := (<-this.LoadMarkets())
            PanicOnError(retRes47478)
            var marginResult interface{} = this.HandleMarginModeAndParams("fetchBorrowRateHistories", params)
            var marginMode interface{} = this.SafeString(marginResult, 0, "cross")
            var isIsolated interface{} =     (IsEqual(marginMode, "isolated")) // true-isolated, false-cross
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "isIsolated": isIsolated,
                "currency": GetValue(currency, "id"),
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
            requestparamsVariable := this.HandleUntilOption("endTime", request, params);
            request = GetValue(requestparamsVariable,0);
            params = GetValue(requestparamsVariable,1)
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "pageSize", limit) // default:50, min:10, max:500
            }
        
            response:= (<-this.PrivateGetMarginInterest(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "code": "200000",
            //         "data": {
            //             "timestamp": 1710829939673,
            //             "currentPage": 1,
            //             "pageSize": 50,
            //             "totalNum": 0,
            //             "totalPage": 0,
            //             "items": [
            //                 {
            //                     "createdAt": 1697783812257,
            //                     "currency": "XMR",
            //                     "interestAmount": "0.1",
            //                     "dayRatio": "0.001"
            //                 }
            //             ]
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data")
            var rows interface{} = this.SafeList(data, "items", []interface{}{})
        
            ch <- this.ParseBorrowRateHistory(rows, code, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *kucoin) ParseBorrowRateHistories(response interface{}, codes interface{}, since interface{}, limit interface{}) interface{}  {
    //
    //     [
    //         {
    //             "createdAt": 1697783812257,
    //             "currency": "XMR",
    //             "interestAmount": "0.1",
    //             "dayRatio": "0.001"
    //         }
    //     ]
    //
    var borrowRateHistories interface{} = map[string]interface{} {}
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        var item interface{} = GetValue(response, i)
        var code interface{} = this.SafeCurrencyCode(this.SafeString(item, "currency"))
        if IsTrue(IsTrue(IsEqual(codes, nil)) || IsTrue(this.InArray(code, codes))) {
            if !IsTrue((InOp(borrowRateHistories, code))) {
                AddElementToObject(borrowRateHistories, code, []interface{}{})
            }
            var borrowRateStructure interface{} = this.ParseBorrowRate(item)
            var borrowRateHistoriesCode interface{} = GetValue(borrowRateHistories, code)
            AppendToArray(&borrowRateHistoriesCode,borrowRateStructure)
        }
    }
    var keys interface{} = ObjectKeys(borrowRateHistories)
    for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
        var code interface{} = GetValue(keys, i)
        AddElementToObject(borrowRateHistories, code, this.FilterByCurrencySinceLimit(GetValue(borrowRateHistories, code), code, since, limit))
    }
    return borrowRateHistories
}
/**
 * @method
 * @name kucoin#borrowCrossMargin
 * @description create a loan to borrow margin
 * @see https://docs.kucoin.com/#1-margin-borrowing
 * @param {string} code unified currency code of the currency to borrow
 * @param {float} amount the amount to borrow
 * @param {object} [params] extra parameters specific to the exchange API endpoints
 * @param {string} [params.timeInForce] either IOC or FOK
 * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
 */
func  (this *kucoin) BorrowCrossMargin(code interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes48338 := (<-this.LoadMarkets())
            PanicOnError(retRes48338)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "currency": GetValue(currency, "id"),
                "size": this.CurrencyToPrecision(code, amount),
                "timeInForce": "FOK",
            }
        
            response:= (<-this.PrivatePostMarginBorrow(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "code": "200",
            //         "msg": "success",
            //         "retry": false,
            //         "data": {
            //             "orderNo": "5da6dba0f943c0c81f5d5db5",
            //             "actualSize": 10
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseMarginLoan(data, currency)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoin#borrowIsolatedMargin
 * @description create a loan to borrow margin
 * @see https://docs.kucoin.com/#1-margin-borrowing
 * @param {string} symbol unified market symbol, required for isolated margin
 * @param {string} code unified currency code of the currency to borrow
 * @param {float} amount the amount to borrow
 * @param {object} [params] extra parameters specific to the exchange API endpoints
 * @param {string} [params.timeInForce] either IOC or FOK
 * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
 */
func  (this *kucoin) BorrowIsolatedMargin(symbol interface{}, code interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes48708 := (<-this.LoadMarkets())
            PanicOnError(retRes48708)
            var market interface{} = this.Market(symbol)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "currency": GetValue(currency, "id"),
                "size": this.CurrencyToPrecision(code, amount),
                "symbol": GetValue(market, "id"),
                "timeInForce": "FOK",
                "isIsolated": true,
            }
        
            response:= (<-this.PrivatePostMarginBorrow(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "code": "200",
            //         "msg": "success",
            //         "retry": false,
            //         "data": {
            //             "orderNo": "5da6dba0f943c0c81f5d5db5",
            //             "actualSize": 10
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseMarginLoan(data, currency)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoin#repayCrossMargin
 * @description repay borrowed margin and interest
 * @see https://docs.kucoin.com/#2-repayment
 * @param {string} code unified currency code of the currency to repay
 * @param {float} amount the amount to repay
 * @param {object} [params] extra parameters specific to the exchange API endpoints
 * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
 */
func  (this *kucoin) RepayCrossMargin(code interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes49088 := (<-this.LoadMarkets())
            PanicOnError(retRes49088)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "currency": GetValue(currency, "id"),
                "size": this.CurrencyToPrecision(code, amount),
            }
        
            response:= (<-this.PrivatePostMarginRepay(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "code": "200",
            //         "msg": "success",
            //         "retry": false,
            //         "data": {
            //             "orderNo": "5da6dba0f943c0c81f5d5db5",
            //             "actualSize": 10
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseMarginLoan(data, currency)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoin#repayIsolatedMargin
 * @description repay borrowed margin and interest
 * @see https://docs.kucoin.com/#2-repayment
 * @param {string} symbol unified market symbol
 * @param {string} code unified currency code of the currency to repay
 * @param {float} amount the amount to repay
 * @param {object} [params] extra parameters specific to the exchange API endpoints
 * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
 */
func  (this *kucoin) RepayIsolatedMargin(symbol interface{}, code interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes49438 := (<-this.LoadMarkets())
            PanicOnError(retRes49438)
            var market interface{} = this.Market(symbol)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "currency": GetValue(currency, "id"),
                "size": this.CurrencyToPrecision(code, amount),
                "symbol": GetValue(market, "id"),
                "isIsolated": true,
            }
        
            response:= (<-this.PrivatePostMarginRepay(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "success": true,
            //         "code": "200",
            //         "msg": "success",
            //         "retry": false,
            //         "data": {
            //             "orderNo": "5da6dba0f943c0c81f5d5db5",
            //             "actualSize": 10
            //         }
            //     }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseMarginLoan(data, currency)
            return nil
        
            }()
            return ch
        }
func  (this *kucoin) ParseMarginLoan(info interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "orderNo": "5da6dba0f943c0c81f5d5db5",
    //         "actualSize": 10
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var timestamp interface{} = this.Milliseconds()
    var currencyId interface{} = this.SafeString(info, "currency")
    return map[string]interface{} {
        "id": this.SafeString(info, "orderNo"),
        "currency": this.SafeCurrencyCode(currencyId, currency),
        "amount": this.SafeNumber(info, "actualSize"),
        "symbol": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "info": info,
    }
}
/**
 * @method
 * @name kucoin#fetchDepositWithdrawFees
 * @description fetch deposit and withdraw fees - *IMPORTANT* use fetchDepositWithdrawFee to get more in-depth info
 * @see https://docs.kucoin.com/#get-currencies
 * @param {string[]|undefined} codes list of unified currency codes
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func  (this *kucoin) FetchDepositWithdrawFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    codes := GetArg(optionalArgs, 0, nil)
            _ = codes
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes49998 := (<-this.LoadMarkets())
            PanicOnError(retRes49998)
        
            response:= (<-this.PublicGetCurrencies(params))
            PanicOnError(response)
            //
            //  [
            //      {
            //        "currency": "CSP",
            //        "name": "CSP",
            //        "fullName": "Caspian",
            //        "precision": 8,
            //        "confirms": 12,
            //        "contractAddress": "0xa6446d655a0c34bc4f05042ee88170d056cbaf45",
            //        "withdrawalMinSize": "2000",
            //        "withdrawalMinFee": "1000",
            //        "isWithdrawEnabled": true,
            //        "isDepositEnabled": true,
            //        "isMarginEnabled": false,
            //        "isDebitEnabled": false
            //      },
            //  ]
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseDepositWithdrawFees(data, codes, "currency")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name kucoin#setLeverage
 * @description set the level of leverage for a market
 * @see https://www.kucoin.com/docs/rest/margin-trading/margin-trading-v3-/modify-leverage-multiplier
 * @param {int } [leverage] New leverage multiplier. Must be greater than 1 and up to two decimal places, and cannot be less than the user's current debt leverage or greater than the system's maximum leverage
 * @param {string} [symbol] unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} response from the exchange
 */
func  (this *kucoin) SetLeverage(leverage interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes50348 := (<-this.LoadMarkets())
            PanicOnError(retRes50348)
            var market interface{} = nil
            var marketType interface{} = nil
            marketTypeparamsVariable := this.HandleMarketTypeAndParams("setLeverage", nil, params);
            marketType = GetValue(marketTypeparamsVariable,0);
            params = GetValue(marketTypeparamsVariable,1)
            if IsTrue(IsTrue((!IsEqual(symbol, nil))) || IsTrue(!IsEqual(marketType, "spot"))) {
                market = this.Market(symbol)
                if IsTrue(GetValue(market, "contract")) {
                    panic(NotSupported(Add(this.Id, " setLeverage currently supports only spot margin")))
                }
            }
            var marginMode interface{} = nil
            marginModeparamsVariable := this.HandleMarginModeAndParams("setLeverage", params);
            marginMode = GetValue(marginModeparamsVariable,0);
            params = GetValue(marginModeparamsVariable,1)
            if IsTrue(IsEqual(marginMode, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " setLeverage requires a marginMode parameter")))
            }
            var request interface{} = map[string]interface{} {}
            if IsTrue(IsTrue(IsEqual(marginMode, "isolated")) && IsTrue(IsEqual(symbol, nil))) {
                panic(ArgumentsRequired(Add(this.Id, " setLeverage requires a symbol parameter for isolated margin")))
            }
            if IsTrue(!IsEqual(symbol, nil)) {
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            AddElementToObject(request, "leverage", ToString(leverage))
            AddElementToObject(request, "isIsolated", (IsEqual(marginMode, "isolated")))
        
                retRes505815 :=  (<-this.PrivatePostPositionUpdateUserLeverage(this.Extend(request, params)))
                PanicOnError(retRes505815)
                ch <- retRes505815
                return nil
        
            }()
            return ch
        }
func  (this *kucoin) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // the v2 URL is https://openapi-v2.kucoin.com/api/v1/endpoint
    //                                ↑                 ↑
    //                                ↑                 ↑
    //
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var versions interface{} = this.SafeDict(this.Options, "versions", map[string]interface{} {})
    var apiVersions interface{} = this.SafeDict(versions, api, map[string]interface{} {})
    var methodVersions interface{} = this.SafeDict(apiVersions, method, map[string]interface{} {})
    var defaultVersion interface{} = this.SafeString(methodVersions, path, GetValue(this.Options, "version"))
    var version interface{} = this.SafeString(params, "version", defaultVersion)
    params = this.Omit(params, "version")
    var endpoint interface{} = Add(Add(Add("/api/", version), "/"), this.ImplodeParams(path, params))
    if IsTrue(IsEqual(api, "webExchange")) {
        endpoint = Add("/", this.ImplodeParams(path, params))
    }
    if IsTrue(IsEqual(api, "earn")) {
        endpoint = Add("/api/v1/", this.ImplodeParams(path, params))
    }
    var query interface{} = this.Omit(params, this.ExtractParams(path))
    var endpart interface{} = ""
    headers = Ternary(IsTrue((!IsEqual(headers, nil))), headers, map[string]interface{} {})
    var url interface{} = GetValue(GetValue(this.Urls, "api"), api)
    if !IsTrue(this.IsEmpty(query)) {
        if IsTrue(IsTrue((IsTrue((IsEqual(method, "GET"))) || IsTrue((IsEqual(method, "DELETE"))))) && IsTrue((!IsEqual(path, "orders/multi-cancel")))) {
            endpoint = Add(endpoint, Add("?", this.Rawencode(query)))
        } else {
            body = this.Json(query)
            endpart = body
            AddElementToObject(headers, "Content-Type", "application/json")
        }
    }
    url = Add(url, endpoint)
    var isFuturePrivate interface{} =     (IsEqual(api, "futuresPrivate"))
    var isPrivate interface{} =     (IsEqual(api, "private"))
    var isBroker interface{} =     (IsEqual(api, "broker"))
    var isEarn interface{} =     (IsEqual(api, "earn"))
    if IsTrue(IsTrue(IsTrue(IsTrue(isPrivate) || IsTrue(isFuturePrivate)) || IsTrue(isBroker)) || IsTrue(isEarn)) {
        this.CheckRequiredCredentials()
        var timestamp interface{} = ToString(this.Nonce())
        headers = this.Extend(map[string]interface{} {
            "KC-API-KEY-VERSION": "2",
            "KC-API-KEY": this.ApiKey,
            "KC-API-TIMESTAMP": timestamp,
        }, headers)
        var apiKeyVersion interface{} = this.SafeString(headers, "KC-API-KEY-VERSION")
        if IsTrue(IsEqual(apiKeyVersion, "2")) {
            var passphrase interface{} = this.Hmac(this.Encode(this.Password), this.Encode(this.Secret), sha256, "base64")
            AddElementToObject(headers, "KC-API-PASSPHRASE", passphrase)
        } else {
            AddElementToObject(headers, "KC-API-PASSPHRASE", this.Password)
        }
        var payload interface{} = Add(Add(Add(timestamp, method), endpoint), endpart)
        var signature interface{} = this.Hmac(this.Encode(payload), this.Encode(this.Secret), sha256, "base64")
        AddElementToObject(headers, "KC-API-SIGN", signature)
        var partner interface{} = this.SafeDict(this.Options, "partner", map[string]interface{} {})
        partner = Ternary(IsTrue(isFuturePrivate), this.SafeValue(partner, "future", partner), this.SafeValue(partner, "spot", partner))
        var partnerId interface{} = this.SafeString(partner, "id")
        var partnerSecret interface{} = this.SafeString2(partner, "secret", "key")
        if IsTrue(IsTrue((!IsEqual(partnerId, nil))) && IsTrue((!IsEqual(partnerSecret, nil)))) {
            var partnerPayload interface{} = Add(Add(timestamp, partnerId), this.ApiKey)
            var partnerSignature interface{} = this.Hmac(this.Encode(partnerPayload), this.Encode(partnerSecret), sha256, "base64")
            AddElementToObject(headers, "KC-API-PARTNER-SIGN", partnerSignature)
            AddElementToObject(headers, "KC-API-PARTNER", partnerId)
            AddElementToObject(headers, "KC-API-PARTNER-VERIFY", "true")
        }
        if IsTrue(isBroker) {
            var brokerName interface{} = this.SafeString(partner, "name")
            if IsTrue(!IsEqual(brokerName, nil)) {
                AddElementToObject(headers, "KC-BROKER-NAME", brokerName)
            }
        }
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *kucoin) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if !IsTrue(response) {
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), body, body)
        return nil
    }
    //
    // bad
    //     { "code": "400100", "msg": "validation.createOrder.clientOidIsRequired" }
    // good
    //     { code: '200000', data: { ... }}
    //
    var errorCode interface{} = this.SafeString(response, "code")
    var message interface{} = this.SafeString2(response, "msg", "data", "")
    var feedback interface{} = Add(Add(this.Id, " "), body)
    this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), message, feedback)
    this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), errorCode, feedback)
    this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), body, feedback)
    if IsTrue(IsTrue(!IsEqual(errorCode, "200000")) && IsTrue(!IsEqual(errorCode, "200"))) {
        panic(ExchangeError(feedback))
    }
    return nil
}


func (this *kucoin) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
