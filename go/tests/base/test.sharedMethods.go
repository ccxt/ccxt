package base
import "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


    func LogTemplate(exchange ccxt.IExchange, method interface{}, entry interface{}) interface{}  {
        // there are cases when exchange is undefined (eg. base tests)
        var id interface{} = Ternary(IsTrue((!IsEqual(exchange, nil))), exchange.GetId(), "undefined")
        var methodString interface{} = Ternary(IsTrue((!IsEqual(method, nil))), method, "undefined")
        var entryString interface{} = Ternary(IsTrue((!IsEqual(exchange, nil))), exchange.Json(entry), "")
        return Add(Add(Add(Add(Add(Add(" <<< ", id), " "), methodString), " ::: "), entryString), " >>> ")
    }
    func IsTemporaryFailure(e interface{}) interface{}  {
        return IsTrue((IsInstance(e, OperationFailed))) && IsTrue((!IsTrue((IsInstance(e, OnMaintenance)))))
    }
    func StringValue(value interface{}) interface{}  {
        var stringVal interface{} = nil
        if IsTrue(IsString(value)) {
            stringVal = value
        } else if IsTrue(IsEqual(value, nil)) {
            stringVal = "undefined"
        } else {
            stringVal = ToString(value)
        }
        return stringVal
    }
    func AssertType(exchange ccxt.IExchange, skippedProperties interface{}, entry interface{}, key interface{}, format interface{}) interface{}  {
        if IsTrue(InOp(skippedProperties, key)) {
            return nil
        }
        // because "typeof" string is not transpilable without === 'name', we list them manually at this moment
        var entryKeyVal interface{} = exchange.SafeValue(entry, key)
        var formatKeyVal interface{} = exchange.SafeValue(format, key)
        var same_string interface{} = IsTrue((IsString(entryKeyVal))) && IsTrue((IsString(formatKeyVal)))
        var same_numeric interface{} = IsTrue((IsNumber(entryKeyVal))) && IsTrue((IsNumber(formatKeyVal)))
        var same_boolean interface{} = IsTrue((IsTrue((IsEqual(entryKeyVal, true))) || IsTrue((IsEqual(entryKeyVal, false))))) && IsTrue((IsTrue((IsEqual(formatKeyVal, true))) || IsTrue((IsEqual(formatKeyVal, false)))))
        var same_array interface{} = IsTrue(IsArray(entryKeyVal)) && IsTrue(IsArray(formatKeyVal))
        var same_object interface{} = IsTrue((IsObject(entryKeyVal))) && IsTrue((IsObject(formatKeyVal)))
        var result interface{} = IsTrue(IsTrue(IsTrue(IsTrue(IsTrue((IsEqual(entryKeyVal, nil))) || IsTrue(same_string)) || IsTrue(same_numeric)) || IsTrue(same_boolean)) || IsTrue(same_array)) || IsTrue(same_object)
        return result
    }
    func AssertStructure(exchange ccxt.IExchange, skippedProperties interface{}, method interface{}, entry interface{}, format interface{}, optionalArgs ...interface{})  {
        emptyAllowedFor := GetArg(optionalArgs, 0, nil)
        _ = emptyAllowedFor
        deep := GetArg(optionalArgs, 1, false)
        _ = deep
        var logText interface{} = LogTemplate(exchange, method, entry)
        Assert(!IsEqual(entry, nil), Add("item is null/undefined", logText))
        // get all expected & predefined keys for this specific item and ensure thos ekeys exist in parsed structure
        if IsTrue(IsArray(format)) {
            Assert(IsArray(entry), Add("entry is not an array", logText))
            var realLength interface{} =         GetArrayLength(entry)
            var expectedLength interface{} =         GetArrayLength(format)
            Assert(IsEqual(realLength, expectedLength), Add(Add("entry length is not equal to expected length of ", ToString(expectedLength)), logText))
            for i := 0; IsLessThan(i, GetArrayLength(format)); i++ {
                var emptyAllowedForThisKey interface{} = IsTrue((IsEqual(emptyAllowedFor, nil))) || IsTrue(exchange.InArray(i, emptyAllowedFor))
                var value interface{} = GetValue(entry, i)
                if IsTrue(InOp(skippedProperties, i)) {
                    continue
                }
                // check when:
                // - it's not inside "allowe empty values" list
                // - it's not undefined
                if IsTrue(IsTrue(emptyAllowedForThisKey) && IsTrue((IsEqual(value, nil)))) {
                    continue
                }
                Assert(!IsEqual(value, nil), Add(Add(ToString(i), " index is expected to have a value"), logText))
                // because of other langs, this is needed for arrays
                var typeAssertion interface{} = AssertType(exchange, skippedProperties, entry, i, format)
                Assert(typeAssertion, Add(Add(ToString(i), " index does not have an expected type "), logText))
            }
        } else {
            Assert(IsObject(entry), Add("entry is not an object", logText))
            var keys interface{} = ObjectKeys(format)
            for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
                var key interface{} = GetValue(keys, i)
                if IsTrue(InOp(skippedProperties, key)) {
                    continue
                }
                Assert(InOp(entry, key), Add(Add(Add("\"", StringValue(key)), "\" key is missing from structure"), logText))
                if IsTrue(InOp(skippedProperties, key)) {
                    continue
                }
                var emptyAllowedForThisKey interface{} = IsTrue((IsEqual(emptyAllowedFor, nil))) || IsTrue(exchange.InArray(key, emptyAllowedFor))
                var value interface{} = GetValue(entry, key)
                // check when:
                // - it's not inside "allowe empty values" list
                // - it's not undefined
                if IsTrue(IsTrue(emptyAllowedForThisKey) && IsTrue((IsEqual(value, nil)))) {
                    continue
                }
                // if it was in needed keys, then it should have value.
                Assert(!IsEqual(value, nil), Add(Add(Add("\"", StringValue(key)), "\" key is expected to have a value"), logText))
                // add exclusion for info key, as it can be any type
                if IsTrue(!IsEqual(key, "info")) {
                    var typeAssertion interface{} = AssertType(exchange, skippedProperties, entry, key, format)
                    Assert(typeAssertion, Add(Add(Add("\"", StringValue(key)), "\" key is neither undefined, neither of expected type"), logText))
                    if IsTrue(deep) {
                        if IsTrue(IsObject(value)) {
                            AssertStructure(exchange, skippedProperties, method, value, GetValue(format, key), emptyAllowedFor, deep)
                        }
                    }
                }
            }
        }
    }
    func AssertTimestamp(exchange ccxt.IExchange, skippedProperties interface{}, method interface{}, entry interface{}, optionalArgs ...interface{})  {
        nowToCheck := GetArg(optionalArgs, 0, nil)
        _ = nowToCheck
        keyNameOrIndex := GetArg(optionalArgs, 1, "timestamp")
        _ = keyNameOrIndex
        var logText interface{} = LogTemplate(exchange, method, entry)
        var skipValue interface{} = exchange.SafeValue(skippedProperties, keyNameOrIndex)
        if IsTrue(!IsEqual(skipValue, nil)) {
            return  // skipped
        }
        var isDateTimeObject interface{} = IsString(keyNameOrIndex)
        if IsTrue(isDateTimeObject) {
            Assert((InOp(entry, keyNameOrIndex)), Add(Add(Add("timestamp key \"", keyNameOrIndex), "\" is missing from structure"), logText))
        } else {
            // if index was provided (mostly from fetchOHLCV) then we check if it exists, as mandatory
            Assert(!IsTrue((IsEqual(GetValue(entry, keyNameOrIndex), nil))), Add(Add(Add("timestamp index ", StringValue(keyNameOrIndex)), " is undefined"), logText))
        }
        var ts interface{} = GetValue(entry, keyNameOrIndex)
        if IsTrue(!IsEqual(ts, nil)) {
            Assert(IsNumber(ts), Add("timestamp is not numeric", logText))
            Assert(IsInt(ts), Add("timestamp should be an integer", logText))
            var minTs interface{} = 1230940800000 // 03 Jan 2009 - first block
            var maxTs interface{} = 2147483648000 // 19 Jan 2038 - max int
            Assert(IsGreaterThan(ts, minTs), Add(Add(Add("timestamp is impossible to be before ", ToString(minTs)), " (03.01.2009)"), logText)) // 03 Jan 2009 - first block
            Assert(IsLessThan(ts, maxTs), Add(Add(Add("timestamp more than ", ToString(maxTs)), " (19.01.2038)"), logText)) // 19 Jan 2038 - int32 overflows // 7258118400000  -> Jan 1 2200
            if IsTrue(!IsEqual(nowToCheck, nil)) {
                var maxMsOffset interface{} = 60000 // 1 min
                Assert(IsLessThan(ts, Add(nowToCheck, maxMsOffset)), Add(Add(Add(Add(Add("returned item timestamp (", exchange.Iso8601(ts)), ") is ahead of the current time ("), exchange.Iso8601(nowToCheck)), ")"), logText))
            }
        }
    }
    func AssertTimestampAndDatetime(exchange ccxt.IExchange, skippedProperties interface{}, method interface{}, entry interface{}, optionalArgs ...interface{})  {
        nowToCheck := GetArg(optionalArgs, 0, nil)
        _ = nowToCheck
        keyNameOrIndex := GetArg(optionalArgs, 1, "timestamp")
        _ = keyNameOrIndex
        var logText interface{} = LogTemplate(exchange, method, entry)
        var skipValue interface{} = exchange.SafeValue(skippedProperties, keyNameOrIndex)
        if IsTrue(!IsEqual(skipValue, nil)) {
            return
        }
        AssertTimestamp(exchange, skippedProperties, method, entry, nowToCheck, keyNameOrIndex)
        var isDateTimeObject interface{} = IsString(keyNameOrIndex)
        // only in case if the entry is a dictionary, thus it must have 'timestamp' & 'datetime' string keys
        if IsTrue(isDateTimeObject) {
            // we also test 'datetime' here because it's certain sibling of 'timestamp'
            Assert((InOp(entry, "datetime")), Add("\"datetime\" key is missing from structure", logText))
            var dt interface{} = GetValue(entry, "datetime")
            if IsTrue(!IsEqual(dt, nil)) {
                Assert(IsString(dt), Add("\"datetime\" key does not have a string value", logText))
                // there are exceptional cases, like getting microsecond-targeted string '2022-08-08T22:03:19.014680Z', so parsed unified timestamp, which carries only 13 digits (millisecond precision) can not be stringified back to microsecond accuracy, causing the bellow Assertion to fail
                //    Assert (dt === exchange.Getiso8601() (entry['timestamp']))
                // so, we have to compare with millisecond accururacy
                var dtParsed interface{} = exchange.Parse8601(dt)
                Assert(IsEqual(exchange.Iso8601(dtParsed), exchange.Iso8601(GetValue(entry, "timestamp"))), Add("datetime is not iso8601 of timestamp", logText))
            }
        }
    }
    func AssertCurrencyCode(exchange ccxt.IExchange, skippedProperties interface{}, method interface{}, entry interface{}, actualCode interface{}, optionalArgs ...interface{})  {
        expectedCode := GetArg(optionalArgs, 0, nil)
        _ = expectedCode
        if IsTrue(IsTrue((InOp(skippedProperties, "currency"))) || IsTrue((InOp(skippedProperties, "currencyIdAndCode")))) {
            return
        }
        var logText interface{} = LogTemplate(exchange, method, entry)
        if IsTrue(!IsEqual(actualCode, nil)) {
            Assert(IsString(actualCode), Add("currency code should be either undefined or a string", logText))
            Assert((InOp(exchange.GetCurrencies(), actualCode)), Add(Add(Add("currency code (\"", actualCode), "\") should be present in exchange.currencies"), logText))
            if IsTrue(!IsEqual(expectedCode, nil)) {
                Assert(IsEqual(actualCode, expectedCode), Add(Add(Add(Add(Add("currency code in response (\"", StringValue(actualCode)), "\") should be equal to expected code (\""), StringValue(expectedCode)), "\")"), logText))
            }
        }
    }
    func AssertValidCurrencyIdAndCode(exchange ccxt.IExchange, skippedProperties interface{}, method interface{}, entry interface{}, currencyId interface{}, currencyCode interface{})  {
        // this is exclusive exceptional key name to be used in `skip-tests.json`, to skip check for currency id and code
        if IsTrue(IsTrue((InOp(skippedProperties, "currency"))) || IsTrue((InOp(skippedProperties, "currencyIdAndCode")))) {
            return
        }
        var logText interface{} = LogTemplate(exchange, method, entry)
        var undefinedValues interface{} = IsTrue(IsEqual(currencyId, nil)) && IsTrue(IsEqual(currencyCode, nil))
        var definedValues interface{} = IsTrue(!IsEqual(currencyId, nil)) && IsTrue(!IsEqual(currencyCode, nil))
        Assert(IsTrue(undefinedValues) || IsTrue(definedValues), Add("currencyId and currencyCode should be either both defined or both undefined", logText))
        if IsTrue(definedValues) {
            // check by code
            var currencyByCode interface{} = exchange.Currency(currencyCode)
            Assert(IsEqual(GetValue(currencyByCode, "id"), currencyId), Add(Add(Add(Add(Add("currencyId \"", StringValue(currencyId)), "\" does not match currency of code: \""), StringValue(currencyCode)), "\""), logText))
            // check by id
            var currencyById interface{} = exchange.SafeCurrency(currencyId)
            Assert(IsEqual(GetValue(currencyById, "code"), currencyCode), Add(Add(Add(Add("currencyCode ", StringValue(currencyCode)), " does not match currency of id: "), StringValue(currencyId)), logText))
        }
    }
    func AssertSymbol(exchange ccxt.IExchange, skippedProperties interface{}, method interface{}, entry interface{}, key interface{}, optionalArgs ...interface{})  {
        expectedSymbol := GetArg(optionalArgs, 0, nil)
        _ = expectedSymbol
        if IsTrue(InOp(skippedProperties, key)) {
            return
        }
        var logText interface{} = LogTemplate(exchange, method, entry)
        var actualSymbol interface{} = exchange.SafeString(entry, key)
        if IsTrue(!IsEqual(actualSymbol, nil)) {
            Assert(IsString(actualSymbol), Add("symbol should be either undefined or a string", logText))
        }
        if IsTrue(!IsEqual(expectedSymbol, nil)) {
            Assert(IsEqual(actualSymbol, expectedSymbol), Add(Add(Add(Add(Add("symbol in response (\"", StringValue(actualSymbol)), "\") should be equal to expected symbol (\""), StringValue(expectedSymbol)), "\")"), logText))
        }
    }
    func AssertSymbolInMarkets(exchange ccxt.IExchange, skippedProperties interface{}, method interface{}, symbol interface{})  {
        var logText interface{} = LogTemplate(exchange, method, map[string]interface{} {})
        Assert((InOp(exchange.GetMarkets(), symbol)), Add("symbol should be present in exchange.symbols", logText))
    }
    func AssertGreater(exchange ccxt.IExchange, skippedProperties interface{}, method interface{}, entry interface{}, key interface{}, compareTo interface{})  {
        if IsTrue(InOp(skippedProperties, key)) {
            return
        }
        var logText interface{} = LogTemplate(exchange, method, entry)
        var value interface{} = exchange.SafeString(entry, key)
        if IsTrue(!IsEqual(value, nil)) {
            Assert(ccxt.Precise.StringGt(value, compareTo), Add(Add(Add(Add(Add(StringValue(key), " key (with a value of "), StringValue(value)), ") was expected to be > "), StringValue(compareTo)), logText))
        }
    }
    func AssertGreaterOrEqual(exchange ccxt.IExchange, skippedProperties interface{}, method interface{}, entry interface{}, key interface{}, compareTo interface{})  {
        if IsTrue(InOp(skippedProperties, key)) {
            return
        }
        var logText interface{} = LogTemplate(exchange, method, entry)
        var value interface{} = exchange.SafeString(entry, key)
        if IsTrue(IsTrue(!IsEqual(value, nil)) && IsTrue(!IsEqual(compareTo, nil))) {
            Assert(ccxt.Precise.StringGe(value, compareTo), Add(Add(Add(Add(Add(StringValue(key), " key (with a value of "), StringValue(value)), ") was expected to be >= "), StringValue(compareTo)), logText))
        }
    }
    func AssertLess(exchange ccxt.IExchange, skippedProperties interface{}, method interface{}, entry interface{}, key interface{}, compareTo interface{})  {
        if IsTrue(InOp(skippedProperties, key)) {
            return
        }
        var logText interface{} = LogTemplate(exchange, method, entry)
        var value interface{} = exchange.SafeString(entry, key)
        if IsTrue(IsTrue(!IsEqual(value, nil)) && IsTrue(!IsEqual(compareTo, nil))) {
            Assert(ccxt.Precise.StringLt(value, compareTo), Add(Add(Add(Add(Add(StringValue(key), " key (with a value of "), StringValue(value)), ") was expected to be < "), StringValue(compareTo)), logText))
        }
    }
    func AssertLessOrEqual(exchange ccxt.IExchange, skippedProperties interface{}, method interface{}, entry interface{}, key interface{}, compareTo interface{})  {
        if IsTrue(InOp(skippedProperties, key)) {
            return
        }
        var logText interface{} = LogTemplate(exchange, method, entry)
        var value interface{} = exchange.SafeString(entry, key)
        if IsTrue(IsTrue(!IsEqual(value, nil)) && IsTrue(!IsEqual(compareTo, nil))) {
            Assert(ccxt.Precise.StringLe(value, compareTo), Add(Add(Add(Add(Add(StringValue(key), " key (with a value of "), StringValue(value)), ") was expected to be <= "), StringValue(compareTo)), logText))
        }
    }
    func AssertEqual(exchange ccxt.IExchange, skippedProperties interface{}, method interface{}, entry interface{}, key interface{}, compareTo interface{})  {
        if IsTrue(InOp(skippedProperties, key)) {
            return
        }
        var logText interface{} = LogTemplate(exchange, method, entry)
        var value interface{} = exchange.SafeString(entry, key)
        if IsTrue(IsTrue(!IsEqual(value, nil)) && IsTrue(!IsEqual(compareTo, nil))) {
            Assert(ccxt.Precise.StringEq(value, compareTo), Add(Add(Add(Add(Add(StringValue(key), " key (with a value of "), StringValue(value)), ") was expected to be equal to "), StringValue(compareTo)), logText))
        }
    }
    func AssertNonEqual(exchange ccxt.IExchange, skippedProperties interface{}, method interface{}, entry interface{}, key interface{}, compareTo interface{})  {
        if IsTrue(InOp(skippedProperties, key)) {
            return
        }
        var logText interface{} = LogTemplate(exchange, method, entry)
        var value interface{} = exchange.SafeString(entry, key)
        if IsTrue(!IsEqual(value, nil)) {
            Assert(!IsTrue(ccxt.Precise.StringEq(value, compareTo)), Add(Add(Add(Add(Add(StringValue(key), " key (with a value of "), StringValue(value)), ") was expected not to be equal to "), StringValue(compareTo)), logText))
        }
    }
    func AssertInArray(exchange ccxt.IExchange, skippedProperties interface{}, method interface{}, entry interface{}, key interface{}, expectedArray interface{})  {
        if IsTrue(InOp(skippedProperties, key)) {
            return
        }
        var logText interface{} = LogTemplate(exchange, method, entry)
        var value interface{} = exchange.SafeValue(entry, key)
        // todo: remove undefined check
        if IsTrue(!IsEqual(value, nil)) {
            var stingifiedArrayValue interface{} = exchange.Json(expectedArray) // don't use expectedArray.join (','), as it bugs in other languages, if values are bool, undefined or etc..
            Assert(exchange.InArray(value, expectedArray), Add(Add(Add(Add(Add(Add(Add("\"", StringValue(key)), "\" key (value \""), StringValue(value)), "\") is not from the expected list : ["), stingifiedArrayValue), "]"), logText))
        }
    }
    func AssertFeeStructure(exchange ccxt.IExchange, skippedProperties interface{}, method interface{}, entry interface{}, key interface{})  {
        var logText interface{} = LogTemplate(exchange, method, entry)
        var keyString interface{} = StringValue(key)
        if IsTrue(IsInt(key)) {
            key = key
            Assert(IsArray(entry), Add("fee container is expected to be an array", logText))
            Assert(IsLessThan(key, GetArrayLength(entry)), Add(Add(Add("fee key ", keyString), " was expected to be present in entry"), logText))
        } else {
            Assert(IsObject(entry), Add("fee container is expected to be an object", logText))
            Assert(InOp(entry, key), Add(Add(Add("fee key \"", key), "\" was expected to be present in entry"), logText))
        }
        var feeObject interface{} = exchange.SafeValue(entry, key)
        // todo: remove undefined check to make stricter
        if IsTrue(!IsEqual(feeObject, nil)) {
            Assert(InOp(feeObject, "cost"), Add(Add(keyString, " fee object should contain \"cost\" key"), logText))
            if IsTrue(IsEqual(GetValue(feeObject, "cost"), nil)) {
                return  // todo: remove undefined check to make stricter
            }
            Assert(IsNumber(GetValue(feeObject, "cost")), Add(Add(keyString, " \"cost\" must be numeric type"), logText))
            // AssertGreaterOrEqual (exchange, skippedProperties, method, feeObject, 'cost', '0'); // fee might be negative in the case of a rebate or reward
            Assert(InOp(feeObject, "currency"), Add(Add(Add("\"", keyString), "\" fee object should contain \"currency\" key"), logText))
            AssertCurrencyCode(exchange, skippedProperties, method, entry, GetValue(feeObject, "currency"))
        }
    }
    func AssertTimestampOrder(exchange ccxt.IExchange, method interface{}, codeOrSymbol interface{}, items interface{}, optionalArgs ...interface{})  {
        ascending := GetArg(optionalArgs, 0, true)
        _ = ascending
        for i := 0; IsLessThan(i, GetArrayLength(items)); i++ {
            if IsTrue(IsGreaterThan(i, 0)) {
                var currentTs interface{} = GetValue(GetValue(items, Subtract(i, 1)), "timestamp")
                var nextTs interface{} = GetValue(GetValue(items, i), "timestamp")
                if IsTrue(IsTrue(!IsEqual(currentTs, nil)) && IsTrue(!IsEqual(nextTs, nil))) {
                    var ascendingOrDescending interface{} = Ternary(IsTrue(ascending), "ascending", "descending")
                    var comparison interface{} = Ternary(IsTrue(ascending), (IsLessThanOrEqual(currentTs, nextTs)), (IsGreaterThanOrEqual(currentTs, nextTs)))
                    Assert(comparison, Add(Add(Add(Add(Add(Add(Add(Add(Add(Add(Add(Add(exchange.GetId(), " "), method), " "), StringValue(codeOrSymbol)), " must return a "), ascendingOrDescending), " sorted array of items by timestamp, but "), ToString(currentTs)), " is opposite with its next "), ToString(nextTs)), " "), exchange.Json(items)))
                }
            }
        }
    }
    func AssertInteger(exchange ccxt.IExchange, skippedProperties interface{}, method interface{}, entry interface{}, key interface{})  {
        if IsTrue(InOp(skippedProperties, key)) {
            return
        }
        var logText interface{} = LogTemplate(exchange, method, entry)
        if IsTrue(!IsEqual(entry, nil)) {
            var value interface{} = exchange.SafeValue(entry, key)
            if IsTrue(!IsEqual(value, nil)) {
                var isInteger interface{} = IsInt(value)
                Assert(isInteger, Add(Add(Add(Add(Add("\"", StringValue(key)), "\" key (value \""), StringValue(value)), "\") is not an integer"), logText))
            }
        }
    }
    func CheckPrecisionAccuracy(exchange ccxt.IExchange, skippedProperties interface{}, method interface{}, entry interface{}, key interface{})  {
        if IsTrue(InOp(skippedProperties, key)) {
            return
        }
        if IsTrue(exchange.IsTickPrecision()) {
            // TICK_SIZE should be above zero
            AssertGreater(exchange, skippedProperties, method, entry, key, "0")
            // the below array of integers are inexistent tick-sizes (theoretically technically possible, but not in real-world cases), so their existence in our case indicates to incorrectly implemented tick-sizes, which might mistakenly be implemented with DECIMAL_PLACES, so we throw error
            var decimalNumbers interface{} = []interface{}{"2", "3", "4", "6", "7", "8", "9", "11", "12", "13", "14", "15", "16"}
            for i := 0; IsLessThan(i, GetArrayLength(decimalNumbers)); i++ {
                var num interface{} = GetValue(decimalNumbers, i)
                var numStr interface{} = num
                AssertNonEqual(exchange, skippedProperties, method, entry, key, numStr)
            }
        } else {
            // todo: significant-digits return doubles from `this.parseNumber`, so for now can't Assert against integer atm
            // AssertInteger (exchange, skippedProperties, method, entry, key); // should be integer
            AssertLessOrEqual(exchange, skippedProperties, method, entry, key, "18") // should be under 18 decimals
            AssertGreaterOrEqual(exchange, skippedProperties, method, entry, key, "-8") // in real-world cases, there would not be less than that
        }
    }
    func FetchBestBidAsk(exchange ccxt.IExchange, method interface{}, symbol interface{}) <- chan interface{} {
                ch := make(chan interface{})
                go func() interface{} {
                    defer close(ch)
                    defer ReturnPanicError(ch)
                        var logText interface{} = LogTemplate(exchange, method, map[string]interface{} {})
                // find out best bid/ask price
                var bestBid interface{} = nil
                var bestAsk interface{} = nil
                var usedMethod interface{} = nil
                if IsTrue(GetValue(exchange.GetHas(), "fetchOrderBook")) {
                    usedMethod = "fetchOrderBook"
            
                    orderbook:= (<-exchange.FetchOrderBook(symbol))
                    PanicOnError(orderbook)
                    var bids interface{} = exchange.SafeList(orderbook, "bids")
                    var asks interface{} = exchange.SafeList(orderbook, "asks")
                    var bestBidArray interface{} = exchange.SafeList(bids, 0)
                    var bestAskArray interface{} = exchange.SafeList(asks, 0)
                    bestBid = exchange.SafeNumber(bestBidArray, 0)
                    bestAsk = exchange.SafeNumber(bestAskArray, 0)
                } else if IsTrue(GetValue(exchange.GetHas(), "fetchBidsAsks")) {
                    usedMethod = "fetchBidsAsks"
            
                    tickers:= (<-exchange.FetchBidsAsks([]interface{}{symbol}))
                    PanicOnError(tickers)
                    var ticker interface{} = exchange.SafeDict(tickers, symbol)
                    bestBid = exchange.SafeNumber(ticker, "bid")
                    bestAsk = exchange.SafeNumber(ticker, "ask")
                } else if IsTrue(GetValue(exchange.GetHas(), "fetchTicker")) {
                    usedMethod = "fetchTicker"
            
                    ticker:= (<-exchange.FetchTicker(symbol))
                    PanicOnError(ticker)
                    bestBid = exchange.SafeNumber(ticker, "bid")
                    bestAsk = exchange.SafeNumber(ticker, "ask")
                } else if IsTrue(GetValue(exchange.GetHas(), "fetchTickers")) {
                    usedMethod = "fetchTickers"
            
                    tickers:= (<-exchange.FetchTickers([]interface{}{symbol}))
                    PanicOnError(tickers)
                    var ticker interface{} = exchange.SafeDict(tickers, symbol)
                    bestBid = exchange.SafeNumber(ticker, "bid")
                    bestAsk = exchange.SafeNumber(ticker, "ask")
                }
                //
                Assert(IsTrue(!IsEqual(bestBid, nil)) && IsTrue(!IsEqual(bestAsk, nil)), Add(Add(Add(Add(Add(Add(Add(Add(logText, " "), exchange.GetId()), " could not get best bid/ask for "), symbol), " using "), usedMethod), " while testing "), method))
            
                ch <- []interface{}{bestBid, bestAsk}
                return nil
            
                }()
                return ch
            }
    func FetchOrder(exchange ccxt.IExchange, symbol interface{}, orderId interface{}, skippedProperties interface{}) <- chan interface{} {
                ch := make(chan interface{})
                go func() interface{} {
                    defer close(ch)
                    defer ReturnPanicError(ch)
                        var fetchedOrder interface{} = nil
                var originalId interface{} = orderId
                // set 'since' to 5 minute ago for optimal results
                var sinceTime interface{} = Subtract(exchange.Milliseconds(), Multiply(Multiply(1000, 60), 5))
                // iterate
                var methods_singular interface{} = []interface{}{"fetchOrder", "fetchOpenOrder", "fetchClosedOrder", "fetchCanceledOrder"}
                for i := 0; IsLessThan(i, GetArrayLength(methods_singular)); i++ {
                    var singularFetchName interface{} = GetValue(methods_singular, i)
                    if IsTrue(GetValue(exchange.GetHas(), singularFetchName)) {
            
                        currentOrder:= (<-callDynamically(singularFetchName, originalId, symbol))
                        PanicOnError(currentOrder)
                        // if there is an id inside the order, it means the order was fetched successfully
                        if IsTrue(IsEqual(GetValue(currentOrder, "id"), originalId)) {
                            fetchedOrder = currentOrder
                            break
                        }
                    }
                }
                //
                // search through plural methods
                if IsTrue(IsEqual(fetchedOrder, nil)) {
                    var methods_plural interface{} = []interface{}{"fetchOrders", "fetchOpenOrders", "fetchClosedOrders", "fetchCanceledOrders"}
                    for i := 0; IsLessThan(i, GetArrayLength(methods_plural)); i++ {
                        var pluralFetchName interface{} = GetValue(methods_plural, i)
                        if IsTrue(GetValue(exchange.GetHas(), pluralFetchName)) {
            
                            orders:= (<-callDynamically(pluralFetchName, symbol, sinceTime))
                            PanicOnError(orders)
                            var found interface{} = false
                            for j := 0; IsLessThan(j, GetArrayLength(orders)); j++ {
                                var currentOrder interface{} = GetValue(orders, j)
                                if IsTrue(IsEqual(GetValue(currentOrder, "id"), originalId)) {
                                    fetchedOrder = currentOrder
                                    found = true
                                    break
                                }
                            }
                            if IsTrue(found) {
                                break
                            }
                        }
                    }
                }
            
                ch <- fetchedOrder
                return nil
            
                }()
                return ch
            }
    func AssertOrderState(exchange ccxt.IExchange, skippedProperties interface{}, method interface{}, order interface{}, AssertedStatus interface{}, strictCheck interface{})  {
        // note, `strictCheck` is `true` only from "fetchOrder" cases
        var logText interface{} = LogTemplate(exchange, method, order)
        var msg interface{} = Add(Add(Add("order should be ", AssertedStatus), ", but it was not Asserted"), logText)
        var filled interface{} = exchange.SafeString(order, "filled")
        var amount interface{} = exchange.SafeString(order, "amount")
        // shorthand variables
        var statusUndefined interface{} =     (IsEqual(GetValue(order, "status"), nil))
        var statusOpen interface{} =     (IsEqual(GetValue(order, "status"), "open"))
        var statusClosed interface{} =     (IsEqual(GetValue(order, "status"), "closed"))
        var statusClanceled interface{} =     (IsEqual(GetValue(order, "status"), "canceled"))
        var filledDefined interface{} =     (!IsEqual(filled, nil))
        var amountDefined interface{} =     (!IsEqual(amount, nil))
        var condition interface{} = nil
        //
        // ### OPEN STATUS
        //
        // if strict check, then 'status' must be 'open' and filled amount should be less then whole order amount
        var strictOpen interface{} = IsTrue(statusOpen) && IsTrue((IsTrue(IsTrue(filledDefined) && IsTrue(amountDefined)) && IsTrue(IsLessThan(filled, amount))))
        // if non-strict check, then accept & ignore undefined values
        var nonstrictOpen interface{} = IsTrue((IsTrue(statusOpen) || IsTrue(statusUndefined))) && IsTrue((IsTrue((!IsTrue(filledDefined) || !IsTrue(amountDefined))) || IsTrue(ccxt.Precise.StringLt(filled, amount))))
        // check
        if IsTrue(IsEqual(AssertedStatus, "open")) {
            condition = Ternary(IsTrue(strictCheck), strictOpen, nonstrictOpen)
            Assert(condition, msg)
            return
        }
        //
        // ### CLOSED STATUS
        //
        // if strict check, then 'status' must be 'closed' and filled amount should be equal to the whole order amount
        var closedStrict interface{} = IsTrue(statusClosed) && IsTrue((IsTrue(IsTrue(filledDefined) && IsTrue(amountDefined)) && IsTrue(ccxt.Precise.StringEq(filled, amount))))
        // if non-strict check, then accept & ignore undefined values
        var closedNonStrict interface{} = IsTrue((IsTrue(statusClosed) || IsTrue(statusUndefined))) && IsTrue((IsTrue((!IsTrue(filledDefined) || !IsTrue(amountDefined))) || IsTrue(ccxt.Precise.StringEq(filled, amount))))
        // check
        if IsTrue(IsEqual(AssertedStatus, "closed")) {
            condition = Ternary(IsTrue(strictCheck), closedStrict, closedNonStrict)
            Assert(condition, msg)
            return
        }
        //
        // ### CANCELED STATUS
        //
        // if strict check, then 'status' must be 'canceled' and filled amount should be less then whole order amount
        var canceledStrict interface{} = IsTrue(statusClanceled) && IsTrue((IsTrue(IsTrue(filledDefined) && IsTrue(amountDefined)) && IsTrue(ccxt.Precise.StringLt(filled, amount))))
        // if non-strict check, then accept & ignore undefined values
        var canceledNonStrict interface{} = IsTrue((IsTrue(statusClanceled) || IsTrue(statusUndefined))) && IsTrue((IsTrue((!IsTrue(filledDefined) || !IsTrue(amountDefined))) || IsTrue(ccxt.Precise.StringLt(filled, amount))))
        // check
        if IsTrue(IsEqual(AssertedStatus, "canceled")) {
            condition = Ternary(IsTrue(strictCheck), canceledStrict, canceledNonStrict)
            Assert(condition, msg)
            return
        }
        //
        // ### CLOSED_or_CANCELED STATUS
        //
        if IsTrue(IsEqual(AssertedStatus, "closed_or_canceled")) {
            condition = Ternary(IsTrue(strictCheck), (IsTrue(closedStrict) || IsTrue(canceledStrict)), (IsTrue(closedNonStrict) || IsTrue(canceledNonStrict)))
            Assert(condition, msg)
            return
        }
    }
    func RemoveProxyOptions(exchange ccxt.IExchange, skippedProperties interface{}) interface{}  {
        var proxyUrl interface{} = exchange.CheckProxyUrlSettings()
        httpProxyhttpsProxysocksProxyVariable := exchange.CheckProxySettings();
        httpProxy := GetValue(httpProxyhttpsProxysocksProxyVariable,0);
        httpsProxy := GetValue(httpProxyhttpsProxysocksProxyVariable,1);
        socksProxy := GetValue(httpProxyhttpsProxysocksProxyVariable,2)
        // because of bug in transpiled, about `.proxyUrl` being transpiled into `.proxy_url`, we have to use this workaround
        exchange.SetProperty(exchange, "proxyUrl", nil)
        exchange.SetProperty(exchange, "proxy_url", nil)
        exchange.SetProperty(exchange, "httpProxy", nil)
        exchange.SetProperty(exchange, "http_proxy", nil)
        exchange.SetProperty(exchange, "httpsProxy", nil)
        exchange.SetProperty(exchange, "https_proxy", nil)
        exchange.SetProperty(exchange, "socksProxy", nil)
        exchange.SetProperty(exchange, "socks_proxy", nil)
        return []interface{}{proxyUrl, httpProxy, httpsProxy, socksProxy}
    }
    func SetProxyOptions(exchange ccxt.IExchange, skippedProperties interface{}, proxyUrl interface{}, httpProxy interface{}, httpsProxy interface{}, socksProxy interface{})  {
        exchange.SetProxyUrl(proxyUrl)
        exchange.SetHttpProxy(httpProxy)
        exchange.SetHttpsProxy(httpsProxy)
        exchange.SetSocksProxy(socksProxy)
    }
    func AssertNonEmtpyArray(exchange ccxt.IExchange, skippedProperties interface{}, method interface{}, entry interface{}, optionalArgs ...interface{})  {
        hint := GetArg(optionalArgs, 0, nil)
        _ = hint
        var logText interface{} = LogTemplate(exchange, method, entry)
        if IsTrue(!IsEqual(hint, nil)) {
            logText = Add(Add(logText, " "), hint)
        }
        Assert(IsArray(entry), Add("response is expected to be an array", logText))
        if !IsTrue((InOp(skippedProperties, "emptyResponse"))) {
            return
        }
        Assert(IsGreaterThan(GetArrayLength(entry), 0), Add(Add("response is expected to be a non-empty array", logText), " (add \"emptyResponse\" in skip-tests.json to skip this check)"))
    }
    func AssertRoundMinuteTimestamp(exchange ccxt.IExchange, skippedProperties interface{}, method interface{}, entry interface{}, key interface{})  {
        if IsTrue(InOp(skippedProperties, key)) {
            return
        }
        var logText interface{} = LogTemplate(exchange, method, entry)
        var ts interface{} = exchange.SafeString(entry, key)
        Assert(IsEqual(ccxt.Precise.StringMod(ts, "60000"), "0"), Add("timestamp should be a multiple of 60 seconds (1 minute)", logText))
    }
    func DeepEqual(a interface{}, b interface{}) interface{}  {
        return IsEqual(JsonStringify(a), JsonStringify(b))
    }
    func AssertDeepEqual(exchange ccxt.IExchange, skippedProperties interface{}, method interface{}, a interface{}, b interface{})  {
        var logText interface{} = LogTemplate(exchange, method, map[string]interface{} {})
        Assert(DeepEqual(a, b), Add(Add(Add(Add("two dicts do not match: ", JsonStringify(a)), " != "), JsonStringify(b)), logText))
    }
