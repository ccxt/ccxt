package base

import "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type testMainClass struct {
	IdTests                    bool        `default:"false"`
	RequestTestsFailed         bool        `default:"false"`
	ResponseTestsFailed        bool        `default:"false"`
	RequestTests               bool        `default:"false"`
	WsTests                    bool        `default:"false"`
	ResponseTests              bool        `default:"false"`
	Info                       bool        `default:"false"`
	Verbose                    bool        `default:"false"`
	Debug                      bool        `default:"false"`
	PrivateTest                bool        `default:"false"`
	PrivateTestOnly            bool        `default:"false"`
	LoadKeys                   bool        `default:"false"`
	Sandbox                    bool        `default:"false"`
	OnlySpecificTests          interface{} `default:"[]interface{}{}"`
	SkippedSettingsForExchange interface{} `default:"map[string]interface{} {}"`
	SkippedMethods             interface{} `default:"map[string]interface{} {}"`
	CheckedPublicTests         interface{} `default:"map[string]interface{} {}"`
	TestFiles                  interface{} `default:"map[string]interface{} {}"`
	PublicTests                interface{} `default:"map[string]interface{} {}"`
	Ext                        string      `default:""`
	Lang                       string      `default:""`
	ProxyTestFileName          interface{} `default:"proxies"`
}

func NewTestMainClass() *testMainClass {
	p := &testMainClass{}
	setDefaults(p)
	return p
}

func (this *testMainClass) ParseCliArgsAndProps() {
	this.ResponseTests = IsTrue(GetCliArgValue("--responseTests")) || IsTrue(GetCliArgValue("--response"))
	this.IdTests = GetCliArgValue("--idTests")
	this.RequestTests = IsTrue(GetCliArgValue("--requestTests")) || IsTrue(GetCliArgValue("--request"))
	this.Info = GetCliArgValue("--info")
	this.Verbose = GetCliArgValue("--verbose")
	this.Debug = GetCliArgValue("--debug")
	this.PrivateTest = GetCliArgValue("--private")
	this.PrivateTestOnly = GetCliArgValue("--privateOnly")
	this.Sandbox = GetCliArgValue("--sandbox")
	this.LoadKeys = GetCliArgValue("--loadKeys")
	this.WsTests = GetCliArgValue("--ws")
	this.Lang = GetLang()
	this.Ext = GetExt()
}
func (this *testMainClass) Init(exchangeId interface{}, symbolArgv interface{}, methodArgv interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		this.ParseCliArgsAndProps()
		if IsTrue(IsTrue(this.RequestTests) && IsTrue(this.ResponseTests)) {

			retRes9212 := (<-this.RunStaticRequestTests(exchangeId, symbolArgv))
			PanicOnError(retRes9212)

			retRes9312 := (<-this.RunStaticResponseTests(exchangeId, symbolArgv))
			PanicOnError(retRes9312)

			ch <- true
			return nil
		}
		if IsTrue(this.ResponseTests) {

			retRes9712 := (<-this.RunStaticResponseTests(exchangeId, symbolArgv))
			PanicOnError(retRes9712)

			ch <- true
			return nil
		}
		if IsTrue(this.RequestTests) {

			retRes10112 := (<-this.RunStaticRequestTests(exchangeId, symbolArgv))
			PanicOnError(retRes10112) // symbol here is the testname

			ch <- true
			return nil
		}
		if IsTrue(this.IdTests) {

			retRes10512 := (<-this.RunBrokerIdTests())
			PanicOnError(retRes10512)

			ch <- true
			return nil
		}
		var newLine interface{} = "\n"
		Dump(Add(Add(Add(Add(newLine, ""), newLine), ""), "[INFO] TESTING "), this.Ext, map[string]interface{}{
			"exchange": exchangeId,
			"symbol":   symbolArgv,
			"method":   methodArgv,
			"isWs":     this.WsTests,
			"useProxy": GetCliArgValue("--useProxy"),
		}, newLine)
		var exchangeArgs interface{} = map[string]interface{}{
			"verbose":         this.Verbose,
			"debug":           this.Debug,
			"enableRateLimit": true,
			"timeout":         30000,
		}
		var exchange ccxt.ICoreExchange = InitExchange(exchangeId, exchangeArgs, this.WsTests)
		if IsTrue(exchange.GetAlias()) {
			ExitScript(0)
		}

		retRes1208 := (<-this.ImportFiles(exchange))
		PanicOnError(retRes1208)
		Assert(IsGreaterThan(GetArrayLength(ObjectKeys(this.TestFiles)), 0), "Test files were not loaded") // ensure test files are found & filled
		this.ExpandSettings(exchange)
		this.CheckIfSpecificTestIsChosen(methodArgv)

		retRes1248 := (<-this.StartTest(exchange, symbolArgv))
		PanicOnError(retRes1248)
		ExitScript(0) // needed to be explicitly finished for WS tests

		ch <- true // required for c#
		return nil

	}()
	return ch
}
func (this *testMainClass) CheckIfSpecificTestIsChosen(methodArgv interface{}) {
	if IsTrue(!IsEqual(methodArgv, nil)) {
		var testFileNames interface{} = ObjectKeys(this.TestFiles)
		var possibleMethodNames interface{} = Split(methodArgv, ",") // i.e. `test.ts binance fetchBalance,fetchDeposits`
		if IsTrue(IsGreaterThanOrEqual(GetArrayLength(possibleMethodNames), 1)) {
			for i := 0; IsLessThan(i, GetArrayLength(testFileNames)); i++ {
				var testFileName interface{} = GetValue(testFileNames, i)
				for j := 0; IsLessThan(j, GetArrayLength(possibleMethodNames)); j++ {
					var methodName interface{} = GetValue(possibleMethodNames, j)
					methodName = Replace(methodName, "()", "")
					if IsTrue(IsEqual(testFileName, methodName)) {
						AppendToArray(&this.OnlySpecificTests, testFileName)
					}
				}
			}
		}
	}
}
func (this *testMainClass) ImportFiles(exchange ccxt.ICoreExchange) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		var properties interface{} = ObjectKeys(exchange.GetHas())
		AppendToArray(&properties, "loadMarkets")
		if IsTrue(IsSync()) {
			this.TestFiles = GetTestFilesSync(properties, this.WsTests)
		} else {

			this.TestFiles = (<-GetTestFiles(properties, this.WsTests))
			PanicOnError(this.TestFiles)
		}

		ch <- true
		return nil

	}()
	return ch
}
func (this *testMainClass) LoadCredentialsFromEnv(exchange ccxt.ICoreExchange) {
	var exchangeId interface{} = exchange.GetId()
	var reqCreds interface{} = GetExchangeProp(exchange, Add("re", "quiredCredentials")) // dont glue the r-e-q-u-i-r-e phrase, because leads to messed up transpilation
	var objkeys interface{} = ObjectKeys(reqCreds)
	for i := 0; IsLessThan(i, GetArrayLength(objkeys)); i++ {
		var credential interface{} = GetValue(objkeys, i)
		var isRequired interface{} = GetValue(reqCreds, credential)
		if IsTrue(IsTrue(isRequired) && IsTrue(IsEqual(GetExchangeProp(exchange, credential), nil))) {
			var fullKey interface{} = Add(Add(exchangeId, "_"), credential)
			var credentialEnvName interface{} = ToUpper(fullKey) // example: KRAKEN_APIKEY
			var envVars interface{} = GetEnvVars()
			var credentialValue interface{} = Ternary(IsTrue((InOp(envVars, credentialEnvName))), GetValue(envVars, credentialEnvName), nil)
			if IsTrue(credentialValue) {
				SetExchangeProp(exchange, credential, credentialValue)
			}
		}
	}
}
func (this *testMainClass) ExpandSettings(exchange ccxt.ICoreExchange) {
	var exchangeId interface{} = exchange.GetId()
	var keysGlobal interface{} = Add(GetRootDir(), "keys.json")
	var keysLocal interface{} = Add(GetRootDir(), "keys.local.json")
	var keysGlobalExists interface{} = IoFileExists(keysGlobal)
	var keysLocalExists interface{} = IoFileExists(keysLocal)
	var globalSettings interface{} = map[string]interface{}{}
	if IsTrue(keysGlobalExists) {
		globalSettings = IoFileRead(keysGlobal)
	}
	var localSettings interface{} = map[string]interface{}{}
	if IsTrue(keysLocalExists) {
		localSettings = IoFileRead(keysLocal)
	}
	var allSettings interface{} = exchange.DeepExtend(globalSettings, localSettings)
	var exchangeSettings interface{} = exchange.SafeValue(allSettings, exchangeId, map[string]interface{}{})
	if IsTrue(exchangeSettings) {
		var settingKeys interface{} = ObjectKeys(exchangeSettings)
		for i := 0; IsLessThan(i, GetArrayLength(settingKeys)); i++ {
			var key interface{} = GetValue(settingKeys, i)
			if IsTrue(GetValue(exchangeSettings, key)) {
				var finalValue interface{} = nil
				if IsTrue(IsObject(GetValue(exchangeSettings, key))) {
					var existing interface{} = GetExchangeProp(exchange, key, map[string]interface{}{})
					finalValue = exchange.DeepExtend(existing, GetValue(exchangeSettings, key))
				} else {
					finalValue = GetValue(exchangeSettings, key)
				}
				SetExchangeProp(exchange, key, finalValue)
			}
		}
	}
	// credentials
	if IsTrue(this.LoadKeys) {
		this.LoadCredentialsFromEnv(exchange)
	}
	// skipped tests
	var skippedFile interface{} = Add(GetRootDir(), "skip-tests.json")
	var skippedSettings interface{} = IoFileRead(skippedFile)
	this.SkippedSettingsForExchange = exchange.SafeValue(skippedSettings, exchangeId, map[string]interface{}{})
	var skippedSettingsForExchange interface{} = this.SkippedSettingsForExchange
	// others
	var timeout interface{} = exchange.SafeValue(skippedSettingsForExchange, "timeout")
	if IsTrue(!IsEqual(timeout, nil)) {
		exchange.SetTimeout(exchange.ParseToInt(timeout))
	}
	if IsTrue(GetCliArgValue("--useProxy")) {
		exchange.SetHttpProxy(exchange.SafeString(skippedSettingsForExchange, "httpProxy"))
		exchange.SetHttpsProxy(exchange.SafeString(skippedSettingsForExchange, "httpsProxy"))
		exchange.SetWsProxy(exchange.SafeString(skippedSettingsForExchange, "wsProxy"))
		exchange.SetWssProxy(exchange.SafeString(skippedSettingsForExchange, "wssProxy"))
	}
	this.SkippedMethods = exchange.SafeValue(skippedSettingsForExchange, "skipMethods", map[string]interface{}{})
	this.CheckedPublicTests = map[string]interface{}{}
}
func (this *testMainClass) AddPadding(message interface{}, size interface{}) interface{} {
	// has to be transpilable
	var res interface{} = ""
	var messageLength interface{} = GetLength(message)                        // avoid php transpilation issue
	var missingSpace interface{} = Subtract(Subtract(size, messageLength), 0) // - 0 is added just to trick transpile to treat the .length as a string for php
	if IsTrue(IsGreaterThan(missingSpace, 0)) {
		for i := 0; IsLessThan(i, missingSpace); i++ {
			res = Add(res, " ")
		}
	}
	return Add(message, res)
}
func (this *testMainClass) TestMethod(methodName interface{}, exchange ccxt.ICoreExchange, args interface{}, isPublic interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		// todo: temporary skip for c#
		if IsTrue(IsTrue(IsGreaterThanOrEqual(GetIndexOf(methodName, "OrderBook"), 0)) && IsTrue(IsEqual(this.Ext, "cs"))) {
			AddElementToObject(exchange.GetOptions(), "checksum", false)
		}
		// todo: temporary skip for php
		if IsTrue(IsTrue(IsGreaterThanOrEqual(GetIndexOf(methodName, "OrderBook"), 0)) && IsTrue(IsEqual(this.Ext, "php"))) {

			ch <- true
			return nil
		}
		var skippedPropertiesForMethod interface{} = this.GetSkips(exchange, methodName)
		var isLoadMarkets interface{} = (IsEqual(methodName, "loadMarkets"))
		var isFetchCurrencies interface{} = (IsEqual(methodName, "fetchCurrencies"))
		var isProxyTest interface{} = (IsEqual(methodName, this.ProxyTestFileName))
		var isFeatureTest interface{} = (IsEqual(methodName, "features"))
		// if this is a private test, and the implementation was already tested in public, then no need to re-test it in private test (exception is fetchCurrencies, because our approach in base exchange)
		if IsTrue(IsTrue(!IsTrue(isPublic) && IsTrue((InOp(this.CheckedPublicTests, methodName)))) && !IsTrue(isFetchCurrencies)) {

			ch <- true
			return nil
		}
		var skipMessage interface{} = nil
		var supportedByExchange interface{} = IsTrue((InOp(exchange.GetHas(), methodName))) && IsTrue(GetValue(exchange.GetHas(), methodName))
		if IsTrue(!IsTrue(isLoadMarkets) && IsTrue((IsTrue(IsGreaterThan(GetArrayLength(this.OnlySpecificTests), 0)) && !IsTrue(exchange.InArray(methodName, this.OnlySpecificTests))))) {
			skipMessage = "[INFO] IGNORED_TEST"
		} else if IsTrue(IsTrue(IsTrue(!IsTrue(isLoadMarkets) && !IsTrue(supportedByExchange)) && !IsTrue(isProxyTest)) && !IsTrue(isFeatureTest)) {
			skipMessage = "[INFO] UNSUPPORTED_TEST" // keep it aligned with the longest message
		} else if IsTrue(IsString(skippedPropertiesForMethod)) {
			skipMessage = "[INFO] SKIPPED_TEST"
		} else if !IsTrue((InOp(this.TestFiles, methodName))) {
			skipMessage = "[INFO] UNIMPLEMENTED_TEST"
		}
		// exceptionally for `loadMarkets` call, we call it before it's even checked for "skip" as we need it to be called anyway (but can skip "test.loadMarket" for it)
		if IsTrue(isLoadMarkets) {

			retRes27812 := (<-exchange.LoadMarkets(true))
			PanicOnError(retRes27812)
		}
		var name interface{} = exchange.GetId()
		if IsTrue(skipMessage) {
			if IsTrue(this.Info) {
				Dump(this.AddPadding(skipMessage, 25), name, methodName)
			}

			ch <- true
			return nil
		}
		if IsTrue(this.Info) {
			var argsStringified interface{} = Add(Add("(", exchange.Json(args)), ")") // args.join() breaks when we provide a list of symbols or multidimensional array; "args.toString()" breaks bcz of "array to string conversion"
			Dump(this.AddPadding("[INFO] TESTING", 25), name, methodName, argsStringified)
		}
		if IsTrue(IsSync()) {
			CallMethodSync(this.TestFiles, methodName, exchange, skippedPropertiesForMethod, args)
		} else {

			retRes29412 := (<-CallMethod(this.TestFiles, methodName, exchange, skippedPropertiesForMethod, args))
			PanicOnError(retRes29412)
		}
		if IsTrue(this.Info) {
			Dump(this.AddPadding("[INFO] TESTING DONE", 25), name, methodName)
		}
		// add to the list of successed tests
		if IsTrue(isPublic) {
			AddElementToObject(this.CheckedPublicTests, methodName, true)
		}

		ch <- true
		return nil

	}()
	return ch
}
func (this *testMainClass) GetSkips(exchange ccxt.ICoreExchange, methodName interface{}) interface{} {
	var finalSkips interface{} = map[string]interface{}{}
	// check the exact method (i.e. `fetchTrades`) and language-specific (i.e. `fetchTrades.php`)
	var methodNames interface{} = []interface{}{methodName, Add(Add(methodName, "."), this.Ext)}
	for i := 0; IsLessThan(i, GetArrayLength(methodNames)); i++ {
		var mName interface{} = GetValue(methodNames, i)
		if IsTrue(InOp(this.SkippedMethods, mName)) {
			// if whole method is skipped, by assigning a string to it, i.e. "fetchOrders":"blabla"
			if IsTrue(IsString(GetValue(this.SkippedMethods, mName))) {
				return GetValue(this.SkippedMethods, mName)
			} else {
				finalSkips = exchange.DeepExtend(finalSkips, GetValue(this.SkippedMethods, mName))
			}
		}
	}
	// get "object-specific" skips
	var objectSkips interface{} = map[string]interface{}{
		"orderBook":          []interface{}{"fetchOrderBook", "fetchOrderBooks", "fetchL2OrderBook", "watchOrderBook", "watchOrderBookForSymbols"},
		"ticker":             []interface{}{"fetchTicker", "fetchTickers", "watchTicker", "watchTickers"},
		"trade":              []interface{}{"fetchTrades", "watchTrades", "watchTradesForSymbols"},
		"ohlcv":              []interface{}{"fetchOHLCV", "watchOHLCV", "watchOHLCVForSymbols"},
		"ledger":             []interface{}{"fetchLedger", "fetchLedgerEntry"},
		"depositWithdraw":    []interface{}{"fetchDepositsWithdrawals", "fetchDeposits", "fetchWithdrawals"},
		"depositWithdrawFee": []interface{}{"fetchDepositWithdrawFee", "fetchDepositWithdrawFees"},
	}
	var objectNames interface{} = ObjectKeys(objectSkips)
	for i := 0; IsLessThan(i, GetArrayLength(objectNames)); i++ {
		var objectName interface{} = GetValue(objectNames, i)
		var objectMethods interface{} = GetValue(objectSkips, objectName)
		if IsTrue(exchange.InArray(methodName, objectMethods)) {
			// if whole object is skipped, by assigning a string to it, i.e. "orderBook":"blabla"
			if IsTrue(IsTrue((InOp(this.SkippedMethods, objectName))) && IsTrue((IsString(GetValue(this.SkippedMethods, objectName))))) {
				return GetValue(this.SkippedMethods, objectName)
			}
			var extraSkips interface{} = exchange.SafeDict(this.SkippedMethods, objectName, map[string]interface{}{})
			finalSkips = exchange.DeepExtend(finalSkips, extraSkips)
		}
	}
	// extend related skips
	// - if 'timestamp' is skipped, we should do so for 'datetime' too
	// - if 'bid' is skipped, skip 'ask' too
	if IsTrue(IsTrue((InOp(finalSkips, "timestamp"))) && !IsTrue((InOp(finalSkips, "datetime")))) {
		AddElementToObject(finalSkips, "datetime", GetValue(finalSkips, "timestamp"))
	}
	if IsTrue(IsTrue((InOp(finalSkips, "bid"))) && !IsTrue((InOp(finalSkips, "ask")))) {
		AddElementToObject(finalSkips, "ask", GetValue(finalSkips, "bid"))
	}
	if IsTrue(IsTrue((InOp(finalSkips, "baseVolume"))) && !IsTrue((InOp(finalSkips, "quoteVolume")))) {
		AddElementToObject(finalSkips, "quoteVolume", GetValue(finalSkips, "baseVolume"))
	}
	return finalSkips
}
func (this *testMainClass) TestSafe(methodName interface{}, exchange ccxt.ICoreExchange, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		// `testSafe` method does not throw an exception, instead mutes it. The reason we
		// mute the thrown exceptions here is because we don't want to stop the whole
		// tests queue if any single test-method fails. Instead, they are echoed with
		// formatted message "[TEST_FAILURE] ..." and that output is then regex-matched by
		// run-tests.js, so the exceptions are still printed out to console from there.
		args := GetArg(optionalArgs, 0, []interface{}{})
		_ = args
		isPublic := GetArg(optionalArgs, 1, false)
		_ = isPublic
		var maxRetries interface{} = 3
		var argsStringified interface{} = exchange.Json(args) // args.join() breaks when we provide a list of symbols or multidimensional array; "args.toString()" breaks bcz of "array to string conversion"
		for i := 0; IsLessThan(i, maxRetries); i++ {

			{
				func(this *testMainClass) (ret_ interface{}) {
					defer func() {
						if ex := recover(); ex != nil {
							if ex == "break" {
								return
							}
							ret_ = func(this *testMainClass) interface{} {
								// catch block:
								var e interface{} = GetRootException(ex)
								var isLoadMarkets interface{} = (IsEqual(methodName, "loadMarkets"))
								var isAuthError interface{} = (IsInstance(e, AuthenticationError))
								var isNotSupported interface{} = (IsInstance(e, NotSupported))
								var isOperationFailed interface{} = (IsInstance(e, OperationFailed)) // includes "DDoSProtection", "RateLimitExceeded", "RequestTimeout", "ExchangeNotAvailable", "OperationFailed", "InvalidNonce", ...
								if IsTrue(isOperationFailed) {
									// if last retry was gone with same `tempFailure` error, then let's eventually return false
									if IsTrue(IsEqual(i, Subtract(maxRetries, 1))) {
										var isOnMaintenance interface{} = (IsInstance(e, OnMaintenance))
										var isExchangeNotAvailable interface{} = (IsInstance(e, ExchangeNotAvailable))
										var shouldFail interface{} = nil
										var retSuccess interface{} = nil
										if IsTrue(isLoadMarkets) {
											// if "loadMarkets" does not succeed, we must return "false" to caller method, to stop tests continual
											retSuccess = false
											// we might not break exchange tests, if exchange is on maintenance at this moment
											if IsTrue(isOnMaintenance) {
												shouldFail = false
											} else {
												shouldFail = true
											}
										} else {
											// for any other method tests:
											if IsTrue(IsTrue(isExchangeNotAvailable) && !IsTrue(isOnMaintenance)) {
												// break exchange tests if "ExchangeNotAvailable" exception is thrown, but it's not maintenance
												shouldFail = true
												retSuccess = false
											} else {
												// in all other cases of OperationFailed, show Warning, but don't mark test as failed
												shouldFail = false
												retSuccess = true
											}
										}
										// output the message
										var failType interface{} = Ternary(IsTrue(shouldFail), "[TEST_FAILURE]", "[TEST_WARNING]")
										Dump(failType, "Method could not be tested due to a repeated Network/Availability issues", " | ", exchange.GetId(), methodName, argsStringified, ExceptionMessage(e))

										ch <- retSuccess
										return nil
									} else {
										// wait and retry again
										// (increase wait time on every retry)

										retRes41524 := (<-exchange.Sleep(Multiply((Add(i, 1)), 1000)))
										PanicOnError(retRes41524)
									}
								} else {
									// if it's loadMarkets, then fail test, because it's mandatory for tests
									if IsTrue(isLoadMarkets) {
										Dump("[TEST_FAILURE]", "Exchange can not load markets", ExceptionMessage(e), exchange.GetId(), methodName, argsStringified)

										ch <- false
										return nil
									}
									// if the specific arguments to the test method throws "NotSupported" exception
									// then let's don't fail the test
									if IsTrue(isNotSupported) {
										if IsTrue(this.Info) {
											Dump("[INFO] NOT_SUPPORTED", ExceptionMessage(e), exchange.GetId(), methodName, argsStringified)
										}

										ch <- true
										return nil
									}
									// If public test faces authentication error, we don't break (see comments under `testSafe` method)
									if IsTrue(IsTrue(isPublic) && IsTrue(isAuthError)) {
										if IsTrue(this.Info) {
											Dump("[INFO]", "Authentication problem for public method", ExceptionMessage(e), exchange.GetId(), methodName, argsStringified)
										}

										ch <- true
										return nil
									} else {
										Dump("[TEST_FAILURE]", ExceptionMessage(e), exchange.GetId(), methodName, argsStringified)

										ch <- false
										return nil
									}
								}
								return nil
							}(this)
						}
					}()
					// try block:

					retRes36916 := (<-this.TestMethod(methodName, exchange, args, isPublic))
					PanicOnError(retRes36916)

					ch <- true
					return nil

				}(this)

			}
		}

		ch <- true
		return nil

	}()
	return ch
}
func (this *testMainClass) RunPublicTests(exchange ccxt.ICoreExchange, symbol interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		var tests interface{} = map[string]interface{}{
			"features":        []interface{}{},
			"fetchCurrencies": []interface{}{},
			"fetchTicker":     []interface{}{symbol},
			"fetchTickers":    []interface{}{symbol},
			"fetchLastPrices": []interface{}{symbol},
			"fetchOHLCV":      []interface{}{symbol},
			"fetchTrades":     []interface{}{symbol},
			"fetchOrderBook":  []interface{}{symbol},
			"fetchOrderBooks": []interface{}{},
			"fetchBidsAsks":   []interface{}{},
			"fetchStatus":     []interface{}{},
			"fetchTime":       []interface{}{},
		}
		if IsTrue(this.WsTests) {
			tests = map[string]interface{}{
				"watchOHLCV":               []interface{}{symbol},
				"watchOHLCVForSymbols":     []interface{}{symbol},
				"watchTicker":              []interface{}{symbol},
				"watchTickers":             []interface{}{symbol},
				"watchBidsAsks":            []interface{}{symbol},
				"watchOrderBook":           []interface{}{symbol},
				"watchOrderBookForSymbols": []interface{}{[]interface{}{symbol}},
				"watchTrades":              []interface{}{symbol},
				"watchTradesForSymbols":    []interface{}{[]interface{}{symbol}},
			}
		}
		var market interface{} = exchange.Market(symbol)
		var isSpot interface{} = GetValue(market, "spot")
		if !IsTrue(this.WsTests) {
			if IsTrue(isSpot) {
				AddElementToObject(tests, "fetchCurrencies", []interface{}{})
			} else {
				AddElementToObject(tests, "fetchFundingRates", []interface{}{symbol})
				AddElementToObject(tests, "fetchFundingRate", []interface{}{symbol})
				AddElementToObject(tests, "fetchFundingRateHistory", []interface{}{symbol})
				AddElementToObject(tests, "fetchIndexOHLCV", []interface{}{symbol})
				AddElementToObject(tests, "fetchMarkOHLCV", []interface{}{symbol})
				AddElementToObject(tests, "fetchPremiumIndexOHLCV", []interface{}{symbol})
			}
		}
		this.PublicTests = tests

		retRes4988 := (<-this.RunTests(exchange, tests, true))
		PanicOnError(retRes4988)

		ch <- true
		return nil

	}()
	return ch
}
func (this *testMainClass) RunTests(exchange ccxt.ICoreExchange, tests interface{}, isPublicTest interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		var testNames interface{} = ObjectKeys(tests)
		var promises interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(testNames)); i++ {
			var testName interface{} = GetValue(testNames, i)
			var testArgs interface{} = GetValue(tests, testName)
			AppendToArray(&promises, this.TestSafe(testName, exchange, testArgs, isPublicTest))
		}
		// todo - not yet ready in other langs too
		// promises.push (testThrottle ());

		results := (<-promiseAll(promises))
		PanicOnError(results)
		// now count which test-methods retuned `false` from "testSafe" and dump that info below
		var failedMethods interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(testNames)); i++ {
			var testName interface{} = GetValue(testNames, i)
			var testReturnedValue interface{} = GetValue(results, i)
			if !IsTrue(testReturnedValue) {
				AppendToArray(&failedMethods, testName)
			}
		}
		var testPrefixString interface{} = Ternary(IsTrue(isPublicTest), "PUBLIC_TESTS", "PRIVATE_TESTS")
		if IsTrue(GetArrayLength(failedMethods)) {
			var errorsString interface{} = Join(failedMethods, ", ")
			Dump("[TEST_FAILURE]", exchange.GetId(), testPrefixString, Add("Failed methods : ", errorsString))
		}
		if IsTrue(this.Info) {
			Dump(this.AddPadding(Add(Add(Add("[INFO] END ", testPrefixString), " "), exchange.GetId()), 25))
		}

		ch <- true
		return nil

	}()
	return ch
}
func (this *testMainClass) LoadExchange(exchange ccxt.ICoreExchange) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)

		result := (<-this.TestSafe("loadMarkets", exchange, []interface{}{}, true))
		PanicOnError(result)
		if !IsTrue(result) {

			ch <- false
			return nil
		}
		var exchangeSymbolsLength interface{} = GetArrayLength(exchange.GetSymbols())
		Dump("[INFO:MAIN] Exchange loaded", exchangeSymbolsLength, "symbols")

		ch <- true
		return nil

	}()
	return ch
}
func (this *testMainClass) GetTestSymbol(exchange ccxt.ICoreExchange, isSpot interface{}, symbols interface{}) interface{} {
	var symbol interface{} = nil
	var preferredSpotSymbol interface{} = exchange.SafeString(this.SkippedSettingsForExchange, "preferredSpotSymbol")
	var preferredSwapSymbol interface{} = exchange.SafeString(this.SkippedSettingsForExchange, "preferredSwapSymbol")
	if IsTrue(IsTrue(isSpot) && IsTrue(preferredSpotSymbol)) {
		return preferredSpotSymbol
	} else if IsTrue(!IsTrue(isSpot) && IsTrue(preferredSwapSymbol)) {
		return preferredSwapSymbol
	}
	for i := 0; IsLessThan(i, GetArrayLength(symbols)); i++ {
		var s interface{} = GetValue(symbols, i)
		var market interface{} = exchange.SafeValue(exchange.GetMarkets(), s)
		if IsTrue(!IsEqual(market, nil)) {
			var active interface{} = exchange.SafeValue(market, "active")
			if IsTrue(IsTrue(active) || IsTrue((IsEqual(active, nil)))) {
				symbol = s
				break
			}
		}
	}
	return symbol
}
func (this *testMainClass) GetExchangeCode(exchange ccxt.ICoreExchange, optionalArgs ...interface{}) interface{} {
	codes := GetArg(optionalArgs, 0, nil)
	_ = codes
	if IsTrue(IsEqual(codes, nil)) {
		codes = []interface{}{"BTC", "ETH", "XRP", "LTC", "BCH", "EOS", "BNB", "BSV", "USDT"}
	}
	var code interface{} = GetValue(codes, 0)
	for i := 0; IsLessThan(i, GetArrayLength(codes)); i++ {
		if IsTrue(InOp(exchange.GetCurrencies(), GetValue(codes, i))) {
			return GetValue(codes, i)
		}
	}
	return code
}
func (this *testMainClass) GetMarketsFromExchange(exchange ccxt.ICoreExchange, optionalArgs ...interface{}) interface{} {
	spot := GetArg(optionalArgs, 0, true)
	_ = spot
	var res interface{} = map[string]interface{}{}
	var markets interface{} = exchange.GetMarkets()
	var keys interface{} = ObjectKeys(markets)
	for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
		var key interface{} = GetValue(keys, i)
		var market interface{} = GetValue(markets, key)
		if IsTrue(IsTrue(spot) && IsTrue(GetValue(market, "spot"))) {
			AddElementToObject(res, GetValue(market, "symbol"), market)
		} else if IsTrue(!IsTrue(spot) && !IsTrue(GetValue(market, "spot"))) {
			AddElementToObject(res, GetValue(market, "symbol"), market)
		}
	}
	return res
}
func (this *testMainClass) GetValidSymbol(exchange ccxt.ICoreExchange, optionalArgs ...interface{}) interface{} {
	spot := GetArg(optionalArgs, 0, true)
	_ = spot
	var currentTypeMarkets interface{} = this.GetMarketsFromExchange(exchange, spot)
	var codes interface{} = []interface{}{"BTC", "ETH", "XRP", "LTC", "BNB", "DASH", "DOGE", "ETC", "TRX", "USDT", "USDC", "USD", "EUR", "TUSD", "CNY", "JPY", "BRL"}
	var spotSymbols interface{} = []interface{}{"BTC/USDT", "BTC/USDC", "BTC/USD", "BTC/CNY", "BTC/EUR", "BTC/AUD", "BTC/BRL", "BTC/JPY", "ETH/USDT", "ETH/USDC", "ETH/USD", "ETH/CNY", "ETH/EUR", "ETH/AUD", "ETH/BRL", "ETH/JPY", "EUR/USDT", "EUR/USD", "EUR/USDC", "USDT/EUR", "USD/EUR", "USDC/EUR", "BTC/ETH", "ETH/BTC"}
	var swapSymbols interface{} = []interface{}{"BTC/USDT:USDT", "BTC/USDC:USDC", "BTC/USD:USD", "ETH/USDT:USDT", "ETH/USDC:USDC", "ETH/USD:USD", "BTC/USD:BTC", "ETH/USD:ETH"}
	var targetSymbols interface{} = Ternary(IsTrue(spot), spotSymbols, swapSymbols)
	var symbol interface{} = this.GetTestSymbol(exchange, spot, targetSymbols)
	// if symbols wasn't found from above hardcoded list, then try to locate any symbol which has our target hardcoded 'base' code
	if IsTrue(IsEqual(symbol, nil)) {
		for i := 0; IsLessThan(i, GetArrayLength(codes)); i++ {
			var currentCode interface{} = GetValue(codes, i)
			var marketsArrayForCurrentCode interface{} = exchange.FilterBy(currentTypeMarkets, "base", currentCode)
			var indexedMkts interface{} = exchange.IndexBy(marketsArrayForCurrentCode, "symbol")
			var symbolsArrayForCurrentCode interface{} = ObjectKeys(indexedMkts)
			var symbolsLength interface{} = GetArrayLength(symbolsArrayForCurrentCode)
			if IsTrue(symbolsLength) {
				symbol = this.GetTestSymbol(exchange, spot, symbolsArrayForCurrentCode)
				break
			}
		}
	}
	// if there wasn't found any symbol with our hardcoded 'base' code, then just try to find symbols that are 'active'
	if IsTrue(IsEqual(symbol, nil)) {
		var activeMarkets interface{} = exchange.FilterBy(currentTypeMarkets, "active", true)
		var activeSymbols interface{} = []interface{}{}
		for i := 0; IsLessThan(i, GetArrayLength(activeMarkets)); i++ {
			AppendToArray(&activeSymbols, GetValue(GetValue(activeMarkets, i), "symbol"))
		}
		symbol = this.GetTestSymbol(exchange, spot, activeSymbols)
	}
	if IsTrue(IsEqual(symbol, nil)) {
		var values interface{} = ObjectValues(currentTypeMarkets)
		var valuesLength interface{} = GetArrayLength(values)
		if IsTrue(IsGreaterThan(valuesLength, 0)) {
			var first interface{} = GetValue(values, 0)
			if IsTrue(!IsEqual(first, nil)) {
				symbol = GetValue(first, "symbol")
			}
		}
	}
	return symbol
}
func (this *testMainClass) TestExchange(exchange ccxt.ICoreExchange, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		providedSymbol := GetArg(optionalArgs, 0, nil)
		_ = providedSymbol
		var spotSymbol interface{} = nil
		var swapSymbol interface{} = nil
		if IsTrue(!IsEqual(providedSymbol, nil)) {
			var market interface{} = exchange.Market(providedSymbol)
			if IsTrue(GetValue(market, "spot")) {
				spotSymbol = providedSymbol
			} else {
				swapSymbol = providedSymbol
			}
		} else {
			if IsTrue(GetValue(exchange.GetHas(), "spot")) {
				spotSymbol = this.GetValidSymbol(exchange, true)
			}
			if IsTrue(GetValue(exchange.GetHas(), "swap")) {
				swapSymbol = this.GetValidSymbol(exchange, false)
			}
		}
		if IsTrue(!IsEqual(spotSymbol, nil)) {
			Dump("[INFO:MAIN] Selected SPOT SYMBOL:", spotSymbol)
		}
		if IsTrue(!IsEqual(swapSymbol, nil)) {
			Dump("[INFO:MAIN] Selected SWAP SYMBOL:", swapSymbol)
		}
		if !IsTrue(this.PrivateTestOnly) {
			// note, spot & swap tests should run sequentially, because of conflicting `exchange.options['defaultType']` setting
			if IsTrue(IsTrue(GetValue(exchange.GetHas(), "spot")) && IsTrue(!IsEqual(spotSymbol, nil))) {
				if IsTrue(this.Info) {
					Dump("[INFO] ### SPOT TESTS ###")
				}
				AddElementToObject(exchange.GetOptions(), "defaultType", "spot")

				retRes72616 := (<-this.RunPublicTests(exchange, spotSymbol))
				PanicOnError(retRes72616)
			}
			if IsTrue(IsTrue(GetValue(exchange.GetHas(), "swap")) && IsTrue(!IsEqual(swapSymbol, nil))) {
				if IsTrue(this.Info) {
					Dump("[INFO] ### SWAP TESTS ###")
				}
				AddElementToObject(exchange.GetOptions(), "defaultType", "swap")

				retRes73316 := (<-this.RunPublicTests(exchange, swapSymbol))
				PanicOnError(retRes73316)
			}
		}
		if IsTrue(IsTrue(this.PrivateTest) || IsTrue(this.PrivateTestOnly)) {
			if IsTrue(IsTrue(GetValue(exchange.GetHas(), "spot")) && IsTrue(!IsEqual(spotSymbol, nil))) {
				AddElementToObject(exchange.GetOptions(), "defaultType", "spot")

				retRes73916 := (<-this.RunPrivateTests(exchange, spotSymbol))
				PanicOnError(retRes73916)
			}
			if IsTrue(IsTrue(GetValue(exchange.GetHas(), "swap")) && IsTrue(!IsEqual(swapSymbol, nil))) {
				AddElementToObject(exchange.GetOptions(), "defaultType", "swap")

				retRes74316 := (<-this.RunPrivateTests(exchange, swapSymbol))
				PanicOnError(retRes74316)
			}
		}

		ch <- true
		return nil

	}()
	return ch
}
func (this *testMainClass) RunPrivateTests(exchange ccxt.ICoreExchange, symbol interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		if !IsTrue(exchange.CheckRequiredCredentials(false)) {
			Dump("[INFO] Skipping private tests", "Keys not found")

			ch <- true
			return nil
		}
		var code interface{} = this.GetExchangeCode(exchange)
		// if (exchange.GetdeepExtendedTest()) {
		//     await test ('InvalidNonce', exchange, symbol);
		//     await test ('OrderNotFound', exchange, symbol);
		//     await test ('InvalidOrder', exchange, symbol);
		//     await test ('InsufficientFunds', exchange, symbol, balance); // danger zone - won't execute with non-empty balance
		// }
		var tests interface{} = map[string]interface{}{
			"signIn":                         []interface{}{},
			"fetchBalance":                   []interface{}{},
			"fetchAccounts":                  []interface{}{},
			"fetchTransactionFees":           []interface{}{},
			"fetchTradingFees":               []interface{}{},
			"fetchStatus":                    []interface{}{},
			"fetchOrders":                    []interface{}{symbol},
			"fetchOpenOrders":                []interface{}{symbol},
			"fetchClosedOrders":              []interface{}{symbol},
			"fetchMyTrades":                  []interface{}{symbol},
			"fetchLeverageTiers":             []interface{}{[]interface{}{symbol}},
			"fetchLedger":                    []interface{}{code},
			"fetchTransactions":              []interface{}{code},
			"fetchDeposits":                  []interface{}{code},
			"fetchWithdrawals":               []interface{}{code},
			"fetchBorrowInterest":            []interface{}{code, symbol},
			"cancelAllOrders":                []interface{}{symbol},
			"fetchCanceledOrders":            []interface{}{symbol},
			"fetchMarginModes":               []interface{}{symbol},
			"fetchPosition":                  []interface{}{symbol},
			"fetchDeposit":                   []interface{}{code},
			"createDepositAddress":           []interface{}{code},
			"fetchDepositAddress":            []interface{}{code},
			"fetchDepositAddresses":          []interface{}{code},
			"fetchDepositAddressesByNetwork": []interface{}{code},
			"fetchBorrowRateHistory":         []interface{}{code},
			"fetchLedgerEntry":               []interface{}{code},
		}
		if IsTrue(GetCliArgValue("--fundedTests")) {
			AddElementToObject(tests, "createOrder", []interface{}{symbol})
		}
		if IsTrue(this.WsTests) {
			tests = map[string]interface{}{
				"watchBalance":   []interface{}{code},
				"watchMyTrades":  []interface{}{symbol},
				"watchOrders":    []interface{}{symbol},
				"watchPosition":  []interface{}{symbol},
				"watchPositions": []interface{}{symbol},
			}
		}
		var market interface{} = exchange.Market(symbol)
		var isSpot interface{} = GetValue(market, "spot")
		if !IsTrue(this.WsTests) {
			if IsTrue(isSpot) {
				AddElementToObject(tests, "fetchCurrencies", []interface{}{})
			} else {
				// derivatives only
				AddElementToObject(tests, "fetchPositions", []interface{}{symbol}) // this test fetches all positions for 1 symbol
				AddElementToObject(tests, "fetchPosition", []interface{}{symbol})
				AddElementToObject(tests, "fetchPositionRisk", []interface{}{symbol})
				AddElementToObject(tests, "setPositionMode", []interface{}{symbol})
				AddElementToObject(tests, "setMarginMode", []interface{}{symbol})
				AddElementToObject(tests, "fetchOpenInterestHistory", []interface{}{symbol})
				AddElementToObject(tests, "fetchFundingRateHistory", []interface{}{symbol})
				AddElementToObject(tests, "fetchFundingHistory", []interface{}{symbol})
			}
		}
		// const combinedTests = exchange.GetdeepExtend() (this.publicTests, privateTests);

		retRes8378 := (<-this.RunTests(exchange, tests, false))
		PanicOnError(retRes8378)

		ch <- true // required in c#
		return nil

	}()
	return ch
}
func (this *testMainClass) TestProxies(exchange ccxt.ICoreExchange) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		// these tests should be synchronously executed, because of conflicting nature of proxy settings
		var proxyTestName interface{} = this.ProxyTestFileName
		// todo: temporary skip for sync py
		if IsTrue(IsTrue(IsEqual(this.Ext, "py")) && IsTrue(IsSync())) {

			ch <- true
			return nil
		}
		// try proxy several times
		var maxRetries interface{} = 3
		var exception interface{} = nil
		for j := 0; IsLessThan(j, maxRetries); j++ {

			{
				func(this *testMainClass) (ret_ interface{}) {
					defer func() {
						if e := recover(); e != nil {
							if e == "break" {
								return
							}
							ret_ = func(this *testMainClass) interface{} {
								// catch block:
								exception = e

								retRes85716 := (<-exchange.Sleep(Multiply(j, 1000)))
								PanicOnError(retRes85716)
								return nil
							}(this)
						}
					}()
					// try block:

					retRes85316 := (<-this.TestMethod(proxyTestName, exchange, []interface{}{}, true))
					PanicOnError(retRes85316)

					ch <- true // if successfull, then end the test
					return nil

				}(this)

			}
		}
		// if exception was set, then throw it
		if IsTrue(!IsEqual(exception, nil)) {
			var errorMessage interface{} = Add(Add(Add("[TEST_FAILURE] Failed ", proxyTestName), " : "), ExceptionMessage(exception))
			// temporary comment the below, because c# transpilation failure
			// throw new Exchange Error (errorMessage.toString ());
			Dump(Add("[TEST_WARNING]", errorMessage))
		}

		ch <- true
		return nil

	}()
	return ch
}
func (this *testMainClass) CheckConstructor(exchange ccxt.ICoreExchange) {
	// todo: this might be moved in base tests later
	if IsTrue(IsEqual(exchange.GetId(), "binance")) {
		Assert(IsTrue(IsEqual(exchange.GetHostname(), nil)) || IsTrue(IsEqual(exchange.GetHostname(), "")), "binance.com hostname should be empty")
		Assert(IsEqual(GetValue(GetValue(exchange.GetUrls(), "api"), "public"), "https://api.binance.com/api/v3"), Add("https://api.binance.com/api/v3 does not match: ", GetValue(GetValue(exchange.GetUrls(), "api"), "public")))
		Assert((InOp(GetValue(GetValue(exchange.GetApi(), "sapi"), "get"), "lending/union/account")), Add("SAPI should contain the endpoint lending/union/account, ", JsonStringify(GetValue(GetValue(exchange.GetApi(), "sapi"), "get"))))
	} else if IsTrue(IsEqual(exchange.GetId(), "binanceus")) {
		Assert(IsEqual(exchange.GetHostname(), "binance.us"), Add("binance.us hostname does not match ", exchange.GetHostname()))
		Assert(IsEqual(GetValue(GetValue(exchange.GetUrls(), "api"), "public"), "https://api.binance.us/api/v3"), Add("https://api.binance.us/api/v3 does not match: ", GetValue(GetValue(exchange.GetUrls(), "api"), "public")))
	}
}
func (this *testMainClass) TestReturnResponseHeaders(exchange ccxt.ICoreExchange) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		if IsTrue(!IsEqual(exchange.GetId(), "binance")) {

			ch <- false // this test is only for binance exchange for now
			return nil
		}
		exchange.SetReturnResponseHeaders(true)

		ticker := (<-exchange.FetchTicker("BTC/USDT"))
		PanicOnError(ticker)
		var info interface{} = GetValue(ticker, "info")
		var headers interface{} = GetValue(info, "responseHeaders")
		var headersKeys interface{} = ObjectKeys(headers)
		Assert(IsGreaterThan(GetArrayLength(headersKeys), 0), "Response headers should not be empty")
		var headerValues interface{} = ObjectValues(headers)
		Assert(IsGreaterThan(GetArrayLength(headerValues), 0), "Response headers values should not be empty")
		exchange.SetReturnResponseHeaders(false)

		ch <- true
		return nil

	}()
	return ch
}
func (this *testMainClass) StartTest(exchange ccxt.ICoreExchange, symbol interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		// we do not need to test aliases
		if IsTrue(exchange.GetAlias()) {

			ch <- true
			return nil
		}
		this.CheckConstructor(exchange)
		// await this.testReturnResponseHeaders (exchange);
		if IsTrue(IsTrue(this.Sandbox) || IsTrue(GetExchangeProp(exchange, "sandbox"))) {
			exchange.SetSandboxMode(true)
		}

		{
			func(this *testMainClass) (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func(this *testMainClass) interface{} {
							// catch block:
							if !IsTrue(IsSync()) {

								retRes92816 := (<-Close(exchange))
								PanicOnError(retRes92816)
							}
							panic(e)

						}(this)
					}
				}()
				// try block:

				result := (<-this.LoadExchange(exchange))
				PanicOnError(result)
				if !IsTrue(result) {
					if !IsTrue(IsSync()) {

						retRes91420 := (<-Close(exchange))
						PanicOnError(retRes91420)
					}

					ch <- true
					return nil
				}
				// if (exchange.Setid(== 'binance') {)
				//     // we test proxies functionality just for one random exchange on each build, because proxy functionality is not exchange-specific, instead it's all done from base methods, so just one working sample would mean it works for all ccxt exchanges
				//     // await this.testProxies (exchange);
				// }

				retRes92212 := (<-this.TestExchange(exchange, symbol))
				PanicOnError(retRes92212)
				if !IsTrue(IsSync()) {

					retRes92416 := (<-Close(exchange))
					PanicOnError(retRes92416)
				}
				return nil
			}(this)

		}

		ch <- true // required in c#
		return nil

	}()
	return ch
}
func (this *testMainClass) AssertStaticError(cond interface{}, message interface{}, calculatedOutput interface{}, storedOutput interface{}, optionalArgs ...interface{}) {
	//  -----------------------------------------------------------------------------
	//  --- Init of static tests functions------------------------------------------
	//  -----------------------------------------------------------------------------
	key := GetArg(optionalArgs, 0, nil)
	_ = key
	var calculatedString interface{} = JsonStringify(calculatedOutput)
	var storedString interface{} = JsonStringify(storedOutput)
	var errorMessage interface{} = message
	if IsTrue(!IsEqual(key, nil)) {
		errorMessage = Add(Add("[", key), "]")
	}
	errorMessage = Add(errorMessage, Add(Add(Add(" computed: ", storedString), " stored: "), calculatedString))
	Assert(cond, errorMessage)
}
func (this *testMainClass) LoadMarketsFromFile(id interface{}) interface{} {
	// load markets from file
	// to make this test as fast as possible
	// and basically independent from the exchange
	// so we can run it offline
	var filename interface{} = Add(Add(Add(GetRootDir(), "./ts/src/test/static/markets/"), id), ".json")
	var content interface{} = IoFileRead(filename)
	return content
}
func (this *testMainClass) LoadCurrenciesFromFile(id interface{}) interface{} {
	var filename interface{} = Add(Add(Add(GetRootDir(), "./ts/src/test/static/currencies/"), id), ".json")
	var content interface{} = IoFileRead(filename)
	return content
}
func (this *testMainClass) LoadStaticData(folder interface{}, optionalArgs ...interface{}) interface{} {
	targetExchange := GetArg(optionalArgs, 0, nil)
	_ = targetExchange
	var result interface{} = map[string]interface{}{}
	if IsTrue(targetExchange) {
		// read a single exchange
		var path interface{} = Add(Add(folder, targetExchange), ".json")
		if !IsTrue(IoFileExists(path)) {
			Dump(Add("[WARN] tests not found: ", path))
			return nil
		}
		AddElementToObject(result, targetExchange, IoFileRead(path))
		return result
	}
	var files interface{} = IoDirRead(folder)
	for i := 0; IsLessThan(i, GetArrayLength(files)); i++ {
		var file interface{} = GetValue(files, i)
		var exchangeName interface{} = Replace(file, ".json", "")
		var content interface{} = IoFileRead(Add(folder, file))
		AddElementToObject(result, exchangeName, content)
	}
	return result
}
func (this *testMainClass) RemoveHostnamefromUrl(url interface{}) interface{} {
	if IsTrue(IsEqual(url, nil)) {
		return nil
	}
	var urlParts interface{} = Split(url, "/")
	var res interface{} = ""
	for i := 0; IsLessThan(i, GetArrayLength(urlParts)); i++ {
		if IsTrue(IsGreaterThan(i, 2)) {
			var current interface{} = GetValue(urlParts, i)
			if IsTrue(IsGreaterThan(GetIndexOf(current, "?"), OpNeg(1))) {
				// handle urls like this: /v1/account/accounts?AccessK
				var currentParts interface{} = Split(current, "?")
				res = Add(res, "/")
				res = Add(res, GetValue(currentParts, 0))
				break
			}
			res = Add(res, "/")
			res = Add(res, current)
		}
	}
	return res
}
func (this *testMainClass) UrlencodedToDict(url interface{}) interface{} {
	var result interface{} = map[string]interface{}{}
	var parts interface{} = Split(url, "&")
	for i := 0; IsLessThan(i, GetArrayLength(parts)); i++ {
		var part interface{} = GetValue(parts, i)
		var keyValue interface{} = Split(part, "=")
		var keysLength interface{} = GetArrayLength(keyValue)
		if IsTrue(!IsEqual(keysLength, 2)) {
			continue
		}
		var key interface{} = GetValue(keyValue, 0)
		var value interface{} = GetValue(keyValue, 1)
		if IsTrue(IsTrue((!IsEqual(value, nil))) && IsTrue((IsTrue((StartsWith(value, "["))) || IsTrue((StartsWith(value, "{")))))) {
			// some exchanges might return something like this: timestamp=1699382693405&batchOrders=[{\"symbol\":\"LTCUSDT\",\"side\":\"BUY\",\"newClientOrderI
			value = JsonParse(value)
		}
		AddElementToObject(result, key, value)
	}
	return result
}
func (this *testMainClass) AssertNewAndStoredOutputInner(exchange ccxt.ICoreExchange, skipKeys interface{}, newOutput interface{}, storedOutput interface{}, optionalArgs ...interface{}) interface{} {
	strictTypeCheck := GetArg(optionalArgs, 0, true)
	_ = strictTypeCheck
	assertingKey := GetArg(optionalArgs, 1, nil)
	_ = assertingKey
	if IsTrue(IsTrue(IsNullValue(newOutput)) && IsTrue(IsNullValue(storedOutput))) {
		return true
	}
	if IsTrue(!IsTrue(newOutput) && !IsTrue(storedOutput)) {
		return true
	}
	if IsTrue(IsTrue((IsObject(storedOutput))) && IsTrue((IsObject(newOutput)))) {
		var storedOutputKeys interface{} = ObjectKeys(storedOutput)
		var newOutputKeys interface{} = ObjectKeys(newOutput)
		var storedKeysLength interface{} = GetArrayLength(storedOutputKeys)
		var newKeysLength interface{} = GetArrayLength(newOutputKeys)
		this.AssertStaticError(IsEqual(storedKeysLength, newKeysLength), "output length mismatch", storedOutput, newOutput)
		// iterate over the keys
		for i := 0; IsLessThan(i, GetArrayLength(storedOutputKeys)); i++ {
			var key interface{} = GetValue(storedOutputKeys, i)
			if IsTrue(exchange.InArray(key, skipKeys)) {
				continue
			}
			if !IsTrue((exchange.InArray(key, newOutputKeys))) {
				this.AssertStaticError(false, Add("output key missing: ", key), storedOutput, newOutput)
			}
			var storedValue interface{} = GetValue(storedOutput, key)
			var newValue interface{} = GetValue(newOutput, key)
			this.AssertNewAndStoredOutput(exchange, skipKeys, newValue, storedValue, strictTypeCheck, key)
		}
	} else if IsTrue(IsTrue(IsArray(storedOutput)) && IsTrue((IsArray(newOutput)))) {
		var storedArrayLength interface{} = GetArrayLength(storedOutput)
		var newArrayLength interface{} = GetArrayLength(newOutput)
		this.AssertStaticError(IsEqual(storedArrayLength, newArrayLength), "output length mismatch", storedOutput, newOutput)
		for i := 0; IsLessThan(i, GetArrayLength(storedOutput)); i++ {
			var storedItem interface{} = GetValue(storedOutput, i)
			var newItem interface{} = GetValue(newOutput, i)
			this.AssertNewAndStoredOutput(exchange, skipKeys, newItem, storedItem, strictTypeCheck)
		}
	} else {
		// built-in types like strings, numbers, booleans
		var sanitizedNewOutput interface{} = Ternary(IsTrue((IsNullValue(newOutput))), nil, newOutput) // we store undefined as nulls in the json file so we need to convert it back
		var sanitizedStoredOutput interface{} = Ternary(IsTrue((IsNullValue(storedOutput))), nil, storedOutput)
		var newOutputString interface{} = Ternary(IsTrue(sanitizedNewOutput), ToString(sanitizedNewOutput), "undefined")
		var storedOutputString interface{} = Ternary(IsTrue(sanitizedStoredOutput), ToString(sanitizedStoredOutput), "undefined")
		var messageError interface{} = Add(Add(Add("output value mismatch:", newOutputString), " != "), storedOutputString)
		if IsTrue(IsTrue(strictTypeCheck) && IsTrue((!IsEqual(this.Lang, "C#")))) {
			// upon building the request we want strict type check to make sure all the types are correct
			// when comparing the response we want to allow some flexibility, because a 50.0 can be equal to 50 after saving it to the json file
			this.AssertStaticError(IsEqual(sanitizedNewOutput, sanitizedStoredOutput), messageError, storedOutput, newOutput, assertingKey)
		} else {
			var isComputedBool interface{} = (IsBool(sanitizedNewOutput))
			var isStoredBool interface{} = (IsBool(sanitizedStoredOutput))
			var isComputedString interface{} = (IsString(sanitizedNewOutput))
			var isStoredString interface{} = (IsString(sanitizedStoredOutput))
			var isComputedUndefined interface{} = (IsEqual(sanitizedNewOutput, nil))
			var isStoredUndefined interface{} = (IsEqual(sanitizedStoredOutput, nil))
			var shouldBeSame interface{} = IsTrue(IsTrue((IsEqual(isComputedBool, isStoredBool))) && IsTrue((IsEqual(isComputedString, isStoredString)))) && IsTrue((IsEqual(isComputedUndefined, isStoredUndefined)))
			this.AssertStaticError(shouldBeSame, "output type mismatch", storedOutput, newOutput, assertingKey)
			var isBoolean interface{} = IsTrue(isComputedBool) || IsTrue(isStoredBool)
			var isString interface{} = IsTrue(isComputedString) || IsTrue(isStoredString)
			var isUndefined interface{} = IsTrue(isComputedUndefined) || IsTrue(isStoredUndefined) // undefined is a perfetly valid value
			if IsTrue(IsTrue(IsTrue(isBoolean) || IsTrue(isString)) || IsTrue(isUndefined)) {
				if IsTrue(IsTrue((IsEqual(this.Lang, "C#"))) || IsTrue((IsEqual(this.Lang, "GO")))) {
					// tmp c# number comparsion
					var isNumber interface{} = false

					{
						func(this *testMainClass) (ret_ interface{}) {
							defer func() {
								if e := recover(); e != nil {
									if e == "break" {
										return
									}
									ret_ = func(this *testMainClass) interface{} {
										// catch block:
										// if we can't parse it to number, then it's not a number
										isNumber = false
										return nil
									}(this)
								}
							}()
							// try block:
							exchange.ParseToNumeric(sanitizedNewOutput)
							isNumber = true
							return nil
						}(this)

					}
					if IsTrue(isNumber) {
						this.AssertStaticError(IsEqual(exchange.ParseToNumeric(sanitizedNewOutput), exchange.ParseToNumeric(sanitizedStoredOutput)), messageError, storedOutput, newOutput, assertingKey)
						return true
					} else {
						this.AssertStaticError(IsEqual(ConvertAscii(newOutputString), ConvertAscii(storedOutputString)), messageError, storedOutput, newOutput, assertingKey)
						return true
					}
				} else {
					this.AssertStaticError(IsEqual(ConvertAscii(newOutputString), ConvertAscii(storedOutputString)), messageError, storedOutput, newOutput, assertingKey)
					return true
				}
			} else {
				if IsTrue(IsEqual(this.Lang, "C#")) {
					var stringifiedNewOutput interface{} = exchange.NumberToString(sanitizedNewOutput)
					var stringifiedStoredOutput interface{} = exchange.NumberToString(sanitizedStoredOutput)
					this.AssertStaticError(IsEqual(ToString(stringifiedNewOutput), ToString(stringifiedStoredOutput)), messageError, storedOutput, newOutput, assertingKey)
				} else {
					var numericNewOutput interface{} = exchange.ParseToNumeric(newOutputString)
					var numericStoredOutput interface{} = exchange.ParseToNumeric(storedOutputString)
					this.AssertStaticError(IsEqual(numericNewOutput, numericStoredOutput), messageError, storedOutput, newOutput, assertingKey)
				}
			}
		}
	}
	return true // c# requ
}
func (this *testMainClass) AssertNewAndStoredOutput(exchange ccxt.ICoreExchange, skipKeys interface{}, newOutput interface{}, storedOutput interface{}, optionalArgs ...interface{}) interface{} {
	strictTypeCheck := GetArg(optionalArgs, 0, true)
	_ = strictTypeCheck
	assertingKey := GetArg(optionalArgs, 1, nil)
	_ = assertingKey
	var res interface{} = true

	{
		func(this *testMainClass) (ret_ interface{}) {
			defer func() {
				if e := recover(); e != nil {
					if e == "break" {
						return
					}
					ret_ = func(this *testMainClass) interface{} {
						// catch block:
						if IsTrue(this.Info) {
							var errorMessage interface{} = Add(Add(Add(Add(this.VarToString(newOutput), "(calculated)"), " != "), this.VarToString(storedOutput)), "(stored)")
							Dump(Add("[TEST_FAILURE_DETAIL]", errorMessage))
						}
						panic(e)

					}(this)
				}
			}()
			// try block:
			res = this.AssertNewAndStoredOutputInner(exchange, skipKeys, newOutput, storedOutput, strictTypeCheck, assertingKey)
			return nil
		}(this)

	}
	return res
}
func (this *testMainClass) VarToString(optionalArgs ...interface{}) interface{} {
	obj := GetArg(optionalArgs, 0, nil)
	_ = obj
	var newString interface{} = nil
	if IsTrue(IsEqual(obj, nil)) {
		newString = "undefined"
	} else if IsTrue(IsNullValue(obj)) {
		newString = "null"
	} else {
		newString = JsonStringify(obj)
	}
	return newString
}
func (this *testMainClass) AssertStaticRequestOutput(exchange ccxt.ICoreExchange, typeVar interface{}, skipKeys interface{}, storedUrl interface{}, requestUrl interface{}, storedOutput interface{}, newOutput interface{}) interface{} {
	if IsTrue(!IsEqual(storedUrl, requestUrl)) {
		// remove the host part from the url
		var firstPath interface{} = this.RemoveHostnamefromUrl(storedUrl)
		var secondPath interface{} = this.RemoveHostnamefromUrl(requestUrl)
		this.AssertStaticError(IsEqual(firstPath, secondPath), "url mismatch", firstPath, secondPath)
	}
	// body (aka storedOutput and newOutput) is not defined and information is in the url
	// example: "https://open-api.bingx.com/openApi/spot/v1/trade/order?quoteOrderQty=5&side=BUY&symbol=LTC-USDT&timestamp=1698777135343&type=MARKET&signature=d55a7e4f7f9dbe56c4004c9f3ab340869d3cb004e2f0b5b861e5fbd1762fd9a0
	if IsTrue(IsTrue((IsEqual(storedOutput, nil))) && IsTrue((IsEqual(newOutput, nil)))) {
		if IsTrue(IsTrue((!IsEqual(storedUrl, nil))) && IsTrue((!IsEqual(requestUrl, nil)))) {
			var storedUrlParts interface{} = Split(storedUrl, "?")
			var newUrlParts interface{} = Split(requestUrl, "?")
			var storedUrlQuery interface{} = exchange.SafeValue(storedUrlParts, 1)
			var newUrlQuery interface{} = exchange.SafeValue(newUrlParts, 1)
			if IsTrue(IsTrue((IsEqual(storedUrlQuery, nil))) && IsTrue((IsEqual(newUrlQuery, nil)))) {
				// might be a get request without any query parameters
				// example: https://api.gateio.ws/api/v4/delivery/usdt/positions
				return true
			}
			var storedUrlParams interface{} = this.UrlencodedToDict(storedUrlQuery)
			var newUrlParams interface{} = this.UrlencodedToDict(newUrlQuery)
			this.AssertNewAndStoredOutput(exchange, skipKeys, newUrlParams, storedUrlParams)
			return true
		}
	}
	if IsTrue(IsTrue(IsTrue(IsEqual(typeVar, "json")) && IsTrue((!IsEqual(storedOutput, nil)))) && IsTrue((!IsEqual(newOutput, nil)))) {
		if IsTrue(IsString(storedOutput)) {
			storedOutput = JsonParse(storedOutput)
		}
		if IsTrue(IsString(newOutput)) {
			newOutput = JsonParse(newOutput)
		}
	} else if IsTrue(IsTrue(IsTrue(IsEqual(typeVar, "urlencoded")) && IsTrue((!IsEqual(storedOutput, nil)))) && IsTrue((!IsEqual(newOutput, nil)))) {
		storedOutput = this.UrlencodedToDict(storedOutput)
		newOutput = this.UrlencodedToDict(newOutput)
	} else if IsTrue(IsEqual(typeVar, "both")) {
		if IsTrue(IsTrue(StartsWith(storedOutput, "{")) || IsTrue(StartsWith(storedOutput, "["))) {
			storedOutput = JsonParse(storedOutput)
			newOutput = JsonParse(newOutput)
		} else {
			storedOutput = this.UrlencodedToDict(storedOutput)
			newOutput = this.UrlencodedToDict(newOutput)
		}
	}
	this.AssertNewAndStoredOutput(exchange, skipKeys, newOutput, storedOutput)
	return true
}
func (this *testMainClass) AssertStaticResponseOutput(exchange ccxt.ICoreExchange, skipKeys interface{}, computedResult interface{}, storedResult interface{}) {
	this.AssertNewAndStoredOutput(exchange, skipKeys, computedResult, storedResult, false)
}
func (this *testMainClass) SanitizeDataInput(input interface{}) interface{} {
	// remove nulls and replace with unefined instead
	if IsTrue(IsEqual(input, nil)) {
		return nil
	}
	var newInput interface{} = []interface{}{}
	for i := 0; IsLessThan(i, GetArrayLength(input)); i++ {
		var current interface{} = GetValue(input, i)
		if IsTrue(IsNullValue(current)) {
			AppendToArray(&newInput, nil)
		} else {
			AppendToArray(&newInput, current)
		}
	}
	return newInput
}
func (this *testMainClass) TestRequestStatically(exchange ccxt.ICoreExchange, method interface{}, data interface{}, typeVar interface{}, skipKeys interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		var output interface{} = nil
		var requestUrl interface{} = nil
		if IsTrue(this.Info) {
			Dump("[INFO] STATIC REQUEST TEST:", method, ":", GetValue(data, "description"))
		}

		{
			func(this *testMainClass) (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func(this *testMainClass) interface{} {
							// catch block:
							if !IsTrue((IsInstance(e, InvalidProxySettings))) {
								panic(e)
							}
							output = exchange.GetLast_request_body()
							requestUrl = exchange.GetLast_request_url()
							return nil
						}(this)
					}
				}()
				// try block:
				if !IsTrue(IsSync()) {

					retRes123516 := (<-CallExchangeMethodDynamically(exchange, method, this.SanitizeDataInput(GetValue(data, "input"))))
					PanicOnError(retRes123516)
				} else {
					CallExchangeMethodDynamicallySync(exchange, method, this.SanitizeDataInput(GetValue(data, "input")))
				}
				return nil
			}(this)

		}

		{
			func(this *testMainClass) (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func(this *testMainClass) interface{} {
							// catch block:
							this.RequestTestsFailed = true
							var errorMessage interface{} = Add(Add(Add(Add(Add(Add(Add(Add(Add(Add(Add(Add("[", this.Lang), "][STATIC_REQUEST]"), "["), exchange.GetId()), "]"), "["), method), "]"), "["), GetValue(data, "description")), "]"), ExceptionMessage(e))
							Dump(Add("[TEST_FAILURE]", errorMessage))
							return nil
						}(this)
					}
				}()
				// try block:
				var callOutput interface{} = exchange.SafeValue(data, "output")
				this.AssertStaticRequestOutput(exchange, typeVar, skipKeys, GetValue(data, "url"), requestUrl, callOutput, output)
				return nil
			}(this)

		}

		ch <- true
		return nil

	}()
	return ch
}
func (this *testMainClass) TestResponseStatically(exchange ccxt.ICoreExchange, method interface{}, skipKeys interface{}, data interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		var expectedResult interface{} = exchange.SafeValue(data, "parsedResponse")
		var mockedExchange ccxt.ICoreExchange = SetFetchResponse(exchange, GetValue(data, "httpResponse"))
		if IsTrue(this.Info) {
			Dump("[INFO] STATIC RESPONSE TEST:", method, ":", GetValue(data, "description"))
		}

		{
			func(this *testMainClass) (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func(this *testMainClass) interface{} {
							// catch block:
							this.ResponseTestsFailed = true
							var errorMessage interface{} = Add(Add(Add(Add(Add(Add(Add(Add(Add(Add(Add(Add("[", this.Lang), "][STATIC_RESPONSE]"), "["), exchange.GetId()), "]"), "["), method), "]"), "["), GetValue(data, "description")), "]"), ExceptionMessage(e))
							Dump(Add("[TEST_FAILURE]", errorMessage))
							return nil
						}(this)
					}
				}()
				// try block:
				if !IsTrue(IsSync()) {

					unifiedResult := (<-CallExchangeMethodDynamically(exchange, method, this.SanitizeDataInput(GetValue(data, "input"))))
					PanicOnError(unifiedResult)
					this.AssertStaticResponseOutput(mockedExchange, skipKeys, unifiedResult, expectedResult)
				} else {
					var unifiedResultSync interface{} = CallExchangeMethodDynamicallySync(exchange, method, this.SanitizeDataInput(GetValue(data, "input")))
					this.AssertStaticResponseOutput(mockedExchange, skipKeys, unifiedResultSync, expectedResult)
				}
				return nil
			}(this)

		}
		SetFetchResponse(exchange, nil) // reset state

		ch <- true
		return nil

	}()
	return ch
}
func (this *testMainClass) InitOfflineExchange(exchangeName interface{}) ccxt.ICoreExchange {
	var markets interface{} = this.LoadMarketsFromFile(exchangeName)
	var currencies interface{} = this.LoadCurrenciesFromFile(exchangeName)
	// we add "proxy" 2 times to intentionally trigger InvalidProxySettings
	var exchange ccxt.ICoreExchange = InitExchange(exchangeName, map[string]interface{}{
		"markets":         markets,
		"currencies":      currencies,
		"enableRateLimit": false,
		"rateLimit":       1,
		"httpProxy":       "http://fake:8080",
		"httpsProxy":      "http://fake:8080",
		"apiKey":          "key",
		"secret":          "secretsecret",
		"password":        "password",
		"walletAddress":   "wallet",
		"privateKey":      "0xff3bdd43534543d421f05aec535965b5050ad6ac15345435345435453495e771",
		"uid":             "uid",
		"token":           "token",
		"login":           "login",
		"accountId":       "12345",
		"accounts": []interface{}{map[string]interface{}{
			"id":   "myAccount",
			"code": "USDT",
		}, map[string]interface{}{
			"id":   "myAccount",
			"code": "USDC",
		}},
		"options": map[string]interface{}{
			"enableUnifiedAccount": true,
			"enableUnifiedMargin":  false,
			"accessToken":          "token",
			"expires":              999999999999999,
			"leverageBrackets":     map[string]interface{}{},
		},
	})
	exchange.SetCurrencies(currencies)
	// not working in python if assigned  in the config dict
	return exchange
}
func (this *testMainClass) TestExchangeRequestStatically(exchangeName interface{}, exchangeData interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		// instantiate the exchange and make sure that we sink the requests to avoid an actual request
		testName := GetArg(optionalArgs, 0, nil)
		_ = testName
		var exchange ccxt.ICoreExchange = this.InitOfflineExchange(exchangeName)
		var globalOptions interface{} = exchange.SafeDict(exchangeData, "options", map[string]interface{}{})
		// read apiKey/secret from the test file
		var apiKey interface{} = exchange.SafeString(exchangeData, "apiKey")
		if IsTrue(apiKey) {
			// c# to string requirement
			exchange.SetApiKey(ToString(apiKey))
		}
		var secret interface{} = exchange.SafeString(exchangeData, "secret")
		if IsTrue(secret) {
			// c# to string requirement
			exchange.SetSecret(ToString(secret))
		}
		var privateKey interface{} = exchange.SafeString(exchangeData, "privateKey")
		if IsTrue(privateKey) {
			// c# to string requirement
			exchange.SetPrivateKey(ToString(privateKey))
		}
		var walletAddress interface{} = exchange.SafeString(exchangeData, "walletAddress")
		if IsTrue(walletAddress) {
			// c# to string requirement
			exchange.SetWalletAddress(ToString(walletAddress))
		}
		var accounts interface{} = exchange.SafeList(exchangeData, "accounts")
		if IsTrue(accounts) {
			exchange.SetAccounts(accounts)
		}
		// exchange.Setoptions(exchange.GetdeepExtend() (exchange.Getoptions(), globalOptions); // custom options to be used in the tests)
		exchange.ExtendExchangeOptions(globalOptions)
		var methods interface{} = exchange.SafeValue(exchangeData, "methods", map[string]interface{}{})
		var methodsNames interface{} = ObjectKeys(methods)
		for i := 0; IsLessThan(i, GetArrayLength(methodsNames)); i++ {
			var method interface{} = GetValue(methodsNames, i)
			var results interface{} = GetValue(methods, method)
			for j := 0; IsLessThan(j, GetArrayLength(results)); j++ {
				var result interface{} = GetValue(results, j)
				var oldExchangeOptions interface{} = exchange.GetOptions() // snapshot options;
				var testExchangeOptions interface{} = exchange.SafeValue(result, "options", map[string]interface{}{})
				// exchange.Setoptions(exchange.GetdeepExtend() (oldExchangeOptions, testExchangeOptions); // custom options to be used in the tests)
				exchange.ExtendExchangeOptions(exchange.DeepExtend(oldExchangeOptions, testExchangeOptions))
				var description interface{} = exchange.SafeValue(result, "description")
				if IsTrue(IsTrue((!IsEqual(testName, nil))) && IsTrue((!IsEqual(testName, description)))) {
					continue
				}
				var isDisabled interface{} = exchange.SafeBool(result, "disabled", false)
				if IsTrue(isDisabled) {
					continue
				}
				var disabledString interface{} = exchange.SafeString(result, "disabled", "")
				if IsTrue(!IsEqual(disabledString, "")) {
					continue
				}
				var isDisabledCSharp interface{} = exchange.SafeBool(result, "disabledCS", false)
				if IsTrue(IsTrue(isDisabledCSharp) && IsTrue((IsEqual(this.Lang, "C#")))) {
					continue
				}
				var isDisabledGo interface{} = exchange.SafeBool(result, "disabledGO", false)
				if IsTrue(IsTrue(isDisabledGo) && IsTrue((IsEqual(this.Lang, "GO")))) {
					continue
				}
				var typeVar interface{} = exchange.SafeString(exchangeData, "outputType")
				var skipKeys interface{} = exchange.SafeValue(exchangeData, "skipKeys", []interface{}{})

				retRes135916 := (<-this.TestRequestStatically(exchange, method, result, typeVar, skipKeys))
				PanicOnError(retRes135916)
				// reset options
				exchange.SetOptions(exchange.ConvertToSafeDictionary(exchange.DeepExtend(oldExchangeOptions, map[string]interface{}{})))
			}
		}
		if !IsTrue(IsSync()) {

			retRes136612 := (<-Close(exchange))
			PanicOnError(retRes136612)
		}

		ch <- true // in c# methods that will be used with promiseAll need to return something
		return nil

	}()
	return ch
}
func (this *testMainClass) TestExchangeResponseStatically(exchangeName interface{}, exchangeData interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		testName := GetArg(optionalArgs, 0, nil)
		_ = testName
		var exchange ccxt.ICoreExchange = this.InitOfflineExchange(exchangeName)
		// read apiKey/secret from the test file
		var apiKey interface{} = exchange.SafeString(exchangeData, "apiKey")
		if IsTrue(apiKey) {
			// c# to string requirement
			exchange.SetApiKey(ToString(apiKey))
		}
		var secret interface{} = exchange.SafeString(exchangeData, "secret")
		if IsTrue(secret) {
			// c# to string requirement
			exchange.SetSecret(ToString(secret))
		}
		var privateKey interface{} = exchange.SafeString(exchangeData, "privateKey")
		if IsTrue(privateKey) {
			// c# to string requirement
			exchange.SetPrivateKey(ToString(privateKey))
		}
		var walletAddress interface{} = exchange.SafeString(exchangeData, "walletAddress")
		if IsTrue(walletAddress) {
			// c# to string requirement
			exchange.SetWalletAddress(ToString(walletAddress))
		}
		var methods interface{} = exchange.SafeValue(exchangeData, "methods", map[string]interface{}{})
		var options interface{} = exchange.SafeValue(exchangeData, "options", map[string]interface{}{})
		// exchange.Setoptions(exchange.GetdeepExtend() (exchange.Getoptions(), options); // custom options to be used in the tests)
		exchange.ExtendExchangeOptions(options)
		var methodsNames interface{} = ObjectKeys(methods)
		for i := 0; IsLessThan(i, GetArrayLength(methodsNames)); i++ {
			var method interface{} = GetValue(methodsNames, i)
			var results interface{} = GetValue(methods, method)
			for j := 0; IsLessThan(j, GetArrayLength(results)); j++ {
				var result interface{} = GetValue(results, j)
				var description interface{} = exchange.SafeValue(result, "description")
				var oldExchangeOptions interface{} = exchange.GetOptions() // snapshot options;
				var testExchangeOptions interface{} = exchange.SafeValue(result, "options", map[string]interface{}{})
				// exchange.Setoptions(exchange.GetdeepExtend() (oldExchangeOptions, testExchangeOptions); // custom options to be used in the tests)
				exchange.ExtendExchangeOptions(exchange.DeepExtend(oldExchangeOptions, testExchangeOptions))
				var isDisabled interface{} = exchange.SafeBool(result, "disabled", false)
				if IsTrue(isDisabled) {
					continue
				}
				var isDisabledCSharp interface{} = exchange.SafeBool(result, "disabledCS", false)
				if IsTrue(IsTrue(isDisabledCSharp) && IsTrue((IsEqual(this.Lang, "C#")))) {
					continue
				}
				var isDisabledPHP interface{} = exchange.SafeBool(result, "disabledPHP", false)
				if IsTrue(IsTrue(isDisabledPHP) && IsTrue((IsEqual(this.Lang, "PHP")))) {
					continue
				}
				if IsTrue(IsTrue((!IsEqual(testName, nil))) && IsTrue((!IsEqual(testName, description)))) {
					continue
				}
				var isDisabledGO interface{} = exchange.SafeBool(result, "disabledGO", false)
				if IsTrue(IsTrue(isDisabledGO) && IsTrue((IsEqual(this.Lang, "GO")))) {
					continue
				}
				var skipKeys interface{} = exchange.SafeValue(exchangeData, "skipKeys", []interface{}{})

				retRes143016 := (<-this.TestResponseStatically(exchange, method, skipKeys, result))
				PanicOnError(retRes143016)
				// reset options
				// exchange.Setoptions(exchange.GetdeepExtend() (oldExchangeOptions, {});)
				exchange.ExtendExchangeOptions(exchange.DeepExtend(oldExchangeOptions, map[string]interface{}{}))
			}
		}
		if !IsTrue(IsSync()) {

			retRes143712 := (<-Close(exchange))
			PanicOnError(retRes143712)
		}

		ch <- true // in c# methods that will be used with promiseAll need to return something
		return nil

	}()
	return ch
}
func (this *testMainClass) GetNumberOfTestsFromExchange(exchange ccxt.ICoreExchange, exchangeData interface{}, optionalArgs ...interface{}) interface{} {
	testName := GetArg(optionalArgs, 0, nil)
	_ = testName
	if IsTrue(!IsEqual(testName, nil)) {
		return 1
	}
	var sum interface{} = 0
	var methods interface{} = GetValue(exchangeData, "methods")
	var methodsNames interface{} = ObjectKeys(methods)
	for i := 0; IsLessThan(i, GetArrayLength(methodsNames)); i++ {
		var method interface{} = GetValue(methodsNames, i)
		var results interface{} = GetValue(methods, method)
		var resultsLength interface{} = GetArrayLength(results)
		sum = exchange.Sum(sum, resultsLength)
	}
	return sum
}
func (this *testMainClass) CheckIfExchangeIsDisabled(exchangeName interface{}, exchangeData interface{}) interface{} {
	var exchange ccxt.ICoreExchange = InitExchange("Exchange", map[string]interface{}{})
	var isDisabledPy interface{} = exchange.SafeBool(exchangeData, "disabledPy", false)
	if IsTrue(IsTrue(isDisabledPy) && IsTrue((IsEqual(this.Lang, "PY")))) {
		Dump(Add(Add("[TEST_WARNING] Exchange ", exchangeName), " is disabled in python"))
		return true
	}
	var isDisabledPHP interface{} = exchange.SafeBool(exchangeData, "disabledPHP", false)
	if IsTrue(IsTrue(isDisabledPHP) && IsTrue((IsEqual(this.Lang, "PHP")))) {
		Dump(Add(Add("[TEST_WARNING] Exchange ", exchangeName), " is disabled in php"))
		return true
	}
	var isDisabledCSharp interface{} = exchange.SafeBool(exchangeData, "disabledCS", false)
	if IsTrue(IsTrue(isDisabledCSharp) && IsTrue((IsEqual(this.Lang, "C#")))) {
		Dump(Add(Add("[TEST_WARNING] Exchange ", exchangeName), " is disabled in c#"))
		return true
	}
	var isDisabledGO interface{} = exchange.SafeBool(exchangeData, "disabledGO", false)
	if IsTrue(IsTrue(isDisabledGO) && IsTrue((IsEqual(this.Lang, "GO")))) {
		Dump(Add(Add("[TEST_WARNING] Exchange ", exchangeName), " is disabled in go"))
		return true
	}
	return false
}
func (this *testMainClass) RunStaticRequestTests(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		targetExchange := GetArg(optionalArgs, 0, nil)
		_ = targetExchange
		testName := GetArg(optionalArgs, 1, nil)
		_ = testName

		retRes14848 := (<-this.RunStaticTests("request", targetExchange, testName))
		PanicOnError(retRes14848)

		ch <- true
		return nil

	}()
	return ch
}
func (this *testMainClass) RunStaticTests(typeVar interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		targetExchange := GetArg(optionalArgs, 0, nil)
		_ = targetExchange
		testName := GetArg(optionalArgs, 1, nil)
		_ = testName
		var folder interface{} = Add(Add(Add(GetRootDir(), "./ts/src/test/static/"), typeVar), "/")
		var staticData interface{} = this.LoadStaticData(folder, targetExchange)
		if IsTrue(IsEqual(staticData, nil)) {

			ch <- true
			return nil
		}
		var exchanges interface{} = ObjectKeys(staticData)
		var exchange ccxt.ICoreExchange = InitExchange("Exchange", map[string]interface{}{}) // tmp to do the calculations until we have the ast-transpiler transpiling this code
		var promises interface{} = []interface{}{}
		var sum interface{} = 0
		if IsTrue(targetExchange) {
			Dump(Add("[INFO:MAIN] Exchange to test: ", targetExchange))
		}
		if IsTrue(testName) {
			Dump(Add("[INFO:MAIN] Testing only: ", testName))
		}
		for i := 0; IsLessThan(i, GetArrayLength(exchanges)); i++ {
			var exchangeName interface{} = GetValue(exchanges, i)
			var exchangeData interface{} = GetValue(staticData, exchangeName)
			var disabled interface{} = this.CheckIfExchangeIsDisabled(exchangeName, exchangeData)
			if IsTrue(disabled) {
				continue
			}
			var numberOfTests interface{} = this.GetNumberOfTestsFromExchange(exchange, exchangeData, testName)
			sum = exchange.Sum(sum, numberOfTests)
			if IsTrue(IsEqual(typeVar, "request")) {
				AppendToArray(&promises, this.TestExchangeRequestStatically(exchangeName, exchangeData, testName))
			} else {
				AppendToArray(&promises, this.TestExchangeResponseStatically(exchangeName, exchangeData, testName))
			}
		}

		{
			func(this *testMainClass) (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func(this *testMainClass) interface{} {
							// catch block:
							if IsTrue(IsEqual(typeVar, "request")) {
								this.RequestTestsFailed = true
							} else {
								this.ResponseTestsFailed = true
							}
							var errorMessage interface{} = Add(Add(Add("[", this.Lang), "][STATIC_REQUEST]"), ExceptionMessage(e))
							Dump(Add("[TEST_FAILURE]", errorMessage))
							return nil
						}(this)
					}
				}()
				// try block:

				retRes152012 := (<-promiseAll(promises))
				PanicOnError(retRes152012)
				return nil
			}(this)

		}
		if IsTrue(IsTrue(this.RequestTestsFailed) || IsTrue(this.ResponseTestsFailed)) {
			ExitScript(1)
		} else {
			var prefix interface{} = Ternary(IsTrue((IsSync())), "[SYNC]", "")
			var successMessage interface{} = Add(Add(Add(Add(Add(Add(Add(Add("[", this.Lang), "]"), prefix), "[TEST_SUCCESS] "), ToString(sum)), " static "), typeVar), " tests passed.")
			Dump(Add("[INFO]", successMessage))
		}

		ch <- true // required in c#
		return nil

	}()
	return ch
}
func (this *testMainClass) RunStaticResponseTests(optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		//  -----------------------------------------------------------------------------
		//  --- Init of mockResponses tests functions------------------------------------
		//  -----------------------------------------------------------------------------
		exchangeName := GetArg(optionalArgs, 0, nil)
		_ = exchangeName
		test := GetArg(optionalArgs, 1, nil)
		_ = test

		retRes15448 := (<-this.RunStaticTests("response", exchangeName, test))
		PanicOnError(retRes15448)

		ch <- true
		return nil

	}()
	return ch
}
func (this *testMainClass) RunBrokerIdTests() <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		//  -----------------------------------------------------------------------------
		//  --- Init of brokerId tests functions-----------------------------------------
		//  -----------------------------------------------------------------------------
		var promises interface{} = []interface{}{this.TestBinance(), this.TestOkx(), this.TestCryptocom(), this.TestBybit(), this.TestKucoin(), this.TestKucoinfutures(), this.TestBitget(), this.TestMexc(), this.TestHtx(), this.TestWoo(), this.TestBitmart(), this.TestCoinex(), this.TestBingx(), this.TestPhemex(), this.TestBlofin(), this.TestCoinbaseinternational(), this.TestCoinbaseAdvanced(), this.TestWoofiPro(), this.TestOxfun(), this.TestXT(), this.TestParadex(), this.TestHashkey(), this.TestCoincatch(), this.TestDefx(), this.TestCryptomus(), this.TestDerive(), this.TestModeTrade()}

		retRes15828 := (<-promiseAll(promises))
		PanicOnError(retRes15828)
		var successMessage interface{} = Add(Add("[", this.Lang), "][TEST_SUCCESS] brokerId tests passed.")
		Dump(Add("[INFO]", successMessage))
		ExitScript(0)

		ch <- true
		return nil

	}()
	return ch
}
func (this *testMainClass) TestBinance() <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		var exchange ccxt.ICoreExchange = this.InitOfflineExchange("binance")
		var spotId interface{} = "x-TKT5PX2F"
		var swapId interface{} = "x-cvBPrNm9"
		var inverseSwapId interface{} = "x-xcKtGhcu"
		var spotOrderRequest interface{} = nil

		{
			func(this *testMainClass) (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func(this *testMainClass) interface{} {
							// catch block:
							spotOrderRequest = this.UrlencodedToDict(exchange.GetLast_request_body())
							return nil
						}(this)
					}
				}()
				// try block:

				retRes159612 := (<-exchange.CreateOrder("BTC/USDT", "limit", "buy", 1, 20000))
				PanicOnError(retRes159612)
				return nil
			}(this)

		}
		var clientOrderId interface{} = GetValue(spotOrderRequest, "newClientOrderId")
		var spotIdString interface{} = ToString(spotId)
		Assert(StartsWith(clientOrderId, spotIdString), Add(Add(Add("binance - spot clientOrderId: ", clientOrderId), " does not start with spotId"), spotIdString))
		var swapOrderRequest interface{} = nil

		{
			func(this *testMainClass) (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func(this *testMainClass) interface{} {
							// catch block:
							swapOrderRequest = this.UrlencodedToDict(exchange.GetLast_request_body())
							return nil
						}(this)
					}
				}()
				// try block:

				retRes160612 := (<-exchange.CreateOrder("BTC/USDT:USDT", "limit", "buy", 1, 20000))
				PanicOnError(retRes160612)
				return nil
			}(this)

		}
		var swapInverseOrderRequest interface{} = nil

		{
			func(this *testMainClass) (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func(this *testMainClass) interface{} {
							// catch block:
							swapInverseOrderRequest = this.UrlencodedToDict(exchange.GetLast_request_body())
							return nil
						}(this)
					}
				}()
				// try block:

				retRes161212 := (<-exchange.CreateOrder("BTC/USD:BTC", "limit", "buy", 1, 20000))
				PanicOnError(retRes161212)
				return nil
			}(this)

		}
		// linear swap
		var clientOrderIdSwap interface{} = GetValue(swapOrderRequest, "newClientOrderId")
		var swapIdString interface{} = ToString(swapId)
		Assert(StartsWith(clientOrderIdSwap, swapIdString), Add(Add(Add("binance - swap clientOrderId: ", clientOrderIdSwap), " does not start with swapId"), swapIdString))
		// inverse swap
		var clientOrderIdInverse interface{} = GetValue(swapInverseOrderRequest, "newClientOrderId")
		Assert(StartsWith(clientOrderIdInverse, inverseSwapId), Add(Add(Add("binance - swap clientOrderIdInverse: ", clientOrderIdInverse), " does not start with swapId"), inverseSwapId))
		var createOrdersRequest interface{} = nil

		{
			func(this *testMainClass) (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func(this *testMainClass) interface{} {
							// catch block:
							createOrdersRequest = this.UrlencodedToDict(exchange.GetLast_request_body())
							return nil
						}(this)
					}
				}()
				// try block:
				var orders interface{} = []interface{}{map[string]interface{}{
					"symbol": "BTC/USDT:USDT",
					"type":   "limit",
					"side":   "sell",
					"amount": 1,
					"price":  100000,
				}, map[string]interface{}{
					"symbol": "BTC/USDT:USDT",
					"type":   "market",
					"side":   "buy",
					"amount": 1,
				}}

				retRes164012 := (<-exchange.CreateOrders(orders))
				PanicOnError(retRes164012)
				return nil
			}(this)

		}
		var batchOrders interface{} = GetValue(createOrdersRequest, "batchOrders")
		for i := 0; IsLessThan(i, GetArrayLength(batchOrders)); i++ {
			var current interface{} = GetValue(batchOrders, i)
			var currentClientOrderId interface{} = GetValue(current, "newClientOrderId")
			Assert(StartsWith(currentClientOrderId, swapIdString), Add(Add(Add("binance createOrders - clientOrderId: ", currentClientOrderId), " does not start with swapId"), swapIdString))
		}
		if !IsTrue(IsSync()) {

			retRes165112 := (<-Close(exchange))
			PanicOnError(retRes165112)
		}

		ch <- true
		return nil

	}()
	return ch
}
func (this *testMainClass) TestOkx() <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		var exchange ccxt.ICoreExchange = this.InitOfflineExchange("okx")
		var id interface{} = "6b9ad766b55dBCDE"
		var spotOrderRequest interface{} = nil

		{
			func(this *testMainClass) (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func(this *testMainClass) interface{} {
							// catch block:
							spotOrderRequest = JsonParse(exchange.GetLast_request_body())
							return nil
						}(this)
					}
				}()
				// try block:

				retRes166112 := (<-exchange.CreateOrder("BTC/USDT", "limit", "buy", 1, 20000))
				PanicOnError(retRes166112)
				return nil
			}(this)

		}
		var clientOrderId interface{} = GetValue(GetValue(spotOrderRequest, 0), "clOrdId") // returns order inside array
		var idString interface{} = ToString(id)
		Assert(StartsWith(clientOrderId, idString), Add(Add(Add("okx - spot clientOrderId: ", clientOrderId), " does not start with id: "), idString))
		var spotTag interface{} = GetValue(GetValue(spotOrderRequest, 0), "tag")
		Assert(IsEqual(spotTag, id), Add(Add(Add("okx - id: ", id), " different from spot tag: "), spotTag))
		var swapOrderRequest interface{} = nil

		{
			func(this *testMainClass) (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func(this *testMainClass) interface{} {
							// catch block:
							swapOrderRequest = JsonParse(exchange.GetLast_request_body())
							return nil
						}(this)
					}
				}()
				// try block:

				retRes167212 := (<-exchange.CreateOrder("BTC/USDT:USDT", "limit", "buy", 1, 20000))
				PanicOnError(retRes167212)
				return nil
			}(this)

		}
		var clientOrderIdSwap interface{} = GetValue(GetValue(swapOrderRequest, 0), "clOrdId")
		Assert(StartsWith(clientOrderIdSwap, idString), Add(Add(Add("okx - swap clientOrderId: ", clientOrderIdSwap), " does not start with id: "), idString))
		var swapTag interface{} = GetValue(GetValue(swapOrderRequest, 0), "tag")
		Assert(IsEqual(swapTag, id), Add(Add(Add("okx - id: ", id), " different from swap tag: "), swapTag))
		if !IsTrue(IsSync()) {

			retRes168112 := (<-Close(exchange))
			PanicOnError(retRes168112)
		}

		ch <- true
		return nil

	}()
	return ch
}
func (this *testMainClass) TestCryptocom() <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		var exchange ccxt.ICoreExchange = this.InitOfflineExchange("cryptocom")
		var id interface{} = "CCXT"

		retRes16898 := (<-exchange.LoadMarkets())
		PanicOnError(retRes16898)
		var request interface{} = nil

		{
			func(this *testMainClass) (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func(this *testMainClass) interface{} {
							// catch block:
							request = JsonParse(exchange.GetLast_request_body())
							return nil
						}(this)
					}
				}()
				// try block:

				retRes169212 := (<-exchange.CreateOrder("BTC/USDT", "limit", "buy", 1, 20000))
				PanicOnError(retRes169212)
				return nil
			}(this)

		}
		var brokerId interface{} = GetValue(GetValue(request, "params"), "broker_id")
		Assert(IsEqual(brokerId, id), Add(Add(Add("cryptocom - id: ", id), " different from  broker_id: "), brokerId))
		if !IsTrue(IsSync()) {

			retRes169912 := (<-Close(exchange))
			PanicOnError(retRes169912)
		}

		ch <- true
		return nil

	}()
	return ch
}
func (this *testMainClass) TestBybit() <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		var exchange ccxt.ICoreExchange = this.InitOfflineExchange("bybit")
		var reqHeaders interface{} = nil
		var id interface{} = "CCXT"
		Assert(IsEqual(GetValue(exchange.GetOptions(), "brokerId"), id), "id not in options")

		{
			func(this *testMainClass) (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func(this *testMainClass) interface{} {
							// catch block:
							// we expect an error here, we're only interested in the headers
							reqHeaders = exchange.GetLast_request_headers()
							return nil
						}(this)
					}
				}()
				// try block:

				retRes171012 := (<-exchange.CreateOrder("BTC/USDT", "limit", "buy", 1, 20000))
				PanicOnError(retRes171012)
				return nil
			}(this)

		}
		Assert(IsEqual(GetValue(reqHeaders, "Referer"), id), Add(Add("bybit - id: ", id), " not in headers."))
		if !IsTrue(IsSync()) {

			retRes171712 := (<-Close(exchange))
			PanicOnError(retRes171712)
		}

		ch <- true
		return nil

	}()
	return ch
}
func (this *testMainClass) TestKucoin() <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		var exchange ccxt.ICoreExchange = this.InitOfflineExchange("kucoin")
		var reqHeaders interface{} = nil
		var spotId interface{} = GetValue(GetValue(GetValue(exchange.GetOptions(), "partner"), "spot"), "id")
		var spotKey interface{} = GetValue(GetValue(GetValue(exchange.GetOptions(), "partner"), "spot"), "key")
		Assert(IsEqual(spotId, "ccxt"), Add(Add("kucoin - id: ", spotId), " not in options"))
		Assert(IsEqual(spotKey, "9e58cc35-5b5e-4133-92ec-166e3f077cb8"), Add(Add("kucoin - key: ", spotKey), " not in options."))

		{
			func(this *testMainClass) (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func(this *testMainClass) interface{} {
							// catch block:
							// we expect an error here, we're only interested in the headers
							reqHeaders = exchange.GetLast_request_headers()
							return nil
						}(this)
					}
				}()
				// try block:

				retRes173012 := (<-exchange.CreateOrder("BTC/USDT", "limit", "buy", 1, 20000))
				PanicOnError(retRes173012)
				return nil
			}(this)

		}
		var id interface{} = "ccxt"
		Assert(IsEqual(GetValue(reqHeaders, "KC-API-PARTNER"), id), Add(Add("kucoin - id: ", id), " not in headers."))
		if !IsTrue(IsSync()) {

			retRes173812 := (<-Close(exchange))
			PanicOnError(retRes173812)
		}

		ch <- true
		return nil

	}()
	return ch
}
func (this *testMainClass) TestKucoinfutures() <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		var exchange ccxt.ICoreExchange = this.InitOfflineExchange("kucoinfutures")
		var reqHeaders interface{} = nil
		var id interface{} = "ccxtfutures"
		var futureId interface{} = GetValue(GetValue(GetValue(exchange.GetOptions(), "partner"), "future"), "id")
		var futureKey interface{} = GetValue(GetValue(GetValue(exchange.GetOptions(), "partner"), "future"), "key")
		Assert(IsEqual(futureId, id), Add(Add("kucoinfutures - id: ", futureId), " not in options."))
		Assert(IsEqual(futureKey, "1b327198-f30c-4f14-a0ac-918871282f15"), Add(Add("kucoinfutures - key: ", futureKey), " not in options."))

		{
			func(this *testMainClass) (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func(this *testMainClass) interface{} {
							// catch block:
							reqHeaders = exchange.GetLast_request_headers()
							return nil
						}(this)
					}
				}()
				// try block:

				retRes175212 := (<-exchange.CreateOrder("BTC/USDT:USDT", "limit", "buy", 1, 20000))
				PanicOnError(retRes175212)
				return nil
			}(this)

		}
		Assert(IsEqual(GetValue(reqHeaders, "KC-API-PARTNER"), id), Add(Add("kucoinfutures - id: ", id), " not in headers."))
		if !IsTrue(IsSync()) {

			retRes175812 := (<-Close(exchange))
			PanicOnError(retRes175812)
		}

		ch <- true
		return nil

	}()
	return ch
}
func (this *testMainClass) TestBitget() <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		var exchange ccxt.ICoreExchange = this.InitOfflineExchange("bitget")
		var reqHeaders interface{} = nil
		var id interface{} = "p4sve"
		Assert(IsEqual(GetValue(exchange.GetOptions(), "broker"), id), Add(Add("bitget - id: ", id), " not in options"))

		{
			func(this *testMainClass) (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func(this *testMainClass) interface{} {
							// catch block:
							reqHeaders = exchange.GetLast_request_headers()
							return nil
						}(this)
					}
				}()
				// try block:

				retRes176912 := (<-exchange.CreateOrder("BTC/USDT", "limit", "buy", 1, 20000))
				PanicOnError(retRes176912)
				return nil
			}(this)

		}
		Assert(IsEqual(GetValue(reqHeaders, "X-CHANNEL-API-CODE"), id), Add(Add("bitget - id: ", id), " not in headers."))
		if !IsTrue(IsSync()) {

			retRes177512 := (<-Close(exchange))
			PanicOnError(retRes177512)
		}

		ch <- true
		return nil

	}()
	return ch
}
func (this *testMainClass) TestMexc() <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		var exchange ccxt.ICoreExchange = this.InitOfflineExchange("mexc")
		var reqHeaders interface{} = nil
		var id interface{} = "CCXT"
		Assert(IsEqual(GetValue(exchange.GetOptions(), "broker"), id), Add(Add("mexc - id: ", id), " not in options"))

		retRes17858 := (<-exchange.LoadMarkets())
		PanicOnError(retRes17858)

		{
			func(this *testMainClass) (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func(this *testMainClass) interface{} {
							// catch block:
							reqHeaders = exchange.GetLast_request_headers()
							return nil
						}(this)
					}
				}()
				// try block:

				retRes178712 := (<-exchange.CreateOrder("BTC/USDT", "limit", "buy", 1, 20000))
				PanicOnError(retRes178712)
				return nil
			}(this)

		}
		Assert(IsEqual(GetValue(reqHeaders, "source"), id), Add(Add("mexc - id: ", id), " not in headers."))
		if !IsTrue(IsSync()) {

			retRes179312 := (<-Close(exchange))
			PanicOnError(retRes179312)
		}

		ch <- true
		return nil

	}()
	return ch
}
func (this *testMainClass) TestHtx() <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		var exchange ccxt.ICoreExchange = this.InitOfflineExchange("htx")
		// spot test
		var id interface{} = "AA03022abc"
		var spotOrderRequest interface{} = nil

		{
			func(this *testMainClass) (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func(this *testMainClass) interface{} {
							// catch block:
							spotOrderRequest = JsonParse(exchange.GetLast_request_body())
							return nil
						}(this)
					}
				}()
				// try block:

				retRes180412 := (<-exchange.CreateOrder("BTC/USDT", "limit", "buy", 1, 20000))
				PanicOnError(retRes180412)
				return nil
			}(this)

		}
		var clientOrderId interface{} = GetValue(spotOrderRequest, "client-order-id")
		var idString interface{} = ToString(id)
		Assert(StartsWith(clientOrderId, idString), Add(Add(Add("htx - spot clientOrderId ", clientOrderId), " does not start with id: "), idString))
		// swap test
		var swapOrderRequest interface{} = nil

		{
			func(this *testMainClass) (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func(this *testMainClass) interface{} {
							// catch block:
							swapOrderRequest = JsonParse(exchange.GetLast_request_body())
							return nil
						}(this)
					}
				}()
				// try block:

				retRes181412 := (<-exchange.CreateOrder("BTC/USDT:USDT", "limit", "buy", 1, 20000))
				PanicOnError(retRes181412)
				return nil
			}(this)

		}
		var swapInverseOrderRequest interface{} = nil

		{
			func(this *testMainClass) (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func(this *testMainClass) interface{} {
							// catch block:
							swapInverseOrderRequest = JsonParse(exchange.GetLast_request_body())
							return nil
						}(this)
					}
				}()
				// try block:

				retRes182012 := (<-exchange.CreateOrder("BTC/USD:BTC", "limit", "buy", 1, 20000))
				PanicOnError(retRes182012)
				return nil
			}(this)

		}
		var clientOrderIdSwap interface{} = GetValue(swapOrderRequest, "channel_code")
		Assert(StartsWith(clientOrderIdSwap, idString), Add(Add(Add("htx - swap channel_code ", clientOrderIdSwap), " does not start with id: "), idString))
		var clientOrderIdInverse interface{} = GetValue(swapInverseOrderRequest, "channel_code")
		Assert(StartsWith(clientOrderIdInverse, idString), Add(Add(Add("htx - swap inverse channel_code ", clientOrderIdInverse), " does not start with id: "), idString))
		if !IsTrue(IsSync()) {

			retRes182912 := (<-Close(exchange))
			PanicOnError(retRes182912)
		}

		ch <- true
		return nil

	}()
	return ch
}
func (this *testMainClass) TestWoo() <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		var exchange ccxt.ICoreExchange = this.InitOfflineExchange("woo")
		// spot test
		var id interface{} = "bc830de7-50f3-460b-9ee0-f430f83f9dad"
		var spotOrderRequest interface{} = nil

		{
			func(this *testMainClass) (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func(this *testMainClass) interface{} {
							// catch block:
							spotOrderRequest = JsonParse(exchange.GetLast_request_body())
							return nil
						}(this)
					}
				}()
				// try block:

				retRes184012 := (<-exchange.CreateOrder("BTC/USDT", "limit", "buy", 1, 20000))
				PanicOnError(retRes184012)
				return nil
			}(this)

		}
		var brokerId interface{} = GetValue(spotOrderRequest, "broker_id")
		var idString interface{} = ToString(id)
		Assert(StartsWith(brokerId, idString), Add(Add(Add("woo - broker_id: ", brokerId), " does not start with id: "), idString))
		// swap test
		var stopOrderRequest interface{} = nil

		{
			func(this *testMainClass) (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func(this *testMainClass) interface{} {
							// catch block:
							stopOrderRequest = JsonParse(exchange.GetLast_request_body())
							return nil
						}(this)
					}
				}()
				// try block:

				retRes185012 := (<-exchange.CreateOrder("BTC/USDT:USDT", "limit", "buy", 1, 20000, map[string]interface{}{
					"stopPrice": 30000,
				}))
				PanicOnError(retRes185012)
				return nil
			}(this)

		}
		var clientOrderIdStop interface{} = GetValue(stopOrderRequest, "brokerId")
		Assert(StartsWith(clientOrderIdStop, idString), Add(Add(Add("woo - brokerId: ", clientOrderIdStop), " does not start with id: "), idString))
		if !IsTrue(IsSync()) {

			retRes185712 := (<-Close(exchange))
			PanicOnError(retRes185712)
		}

		ch <- true
		return nil

	}()
	return ch
}
func (this *testMainClass) TestBitmart() <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		var exchange ccxt.ICoreExchange = this.InitOfflineExchange("bitmart")
		var reqHeaders interface{} = nil
		var id interface{} = "CCXTxBitmart000"
		Assert(IsEqual(GetValue(exchange.GetOptions(), "brokerId"), id), Add(Add("bitmart - id: ", id), " not in options"))

		retRes18678 := (<-exchange.LoadMarkets())
		PanicOnError(retRes18678)

		{
			func(this *testMainClass) (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func(this *testMainClass) interface{} {
							// catch block:
							reqHeaders = exchange.GetLast_request_headers()
							return nil
						}(this)
					}
				}()
				// try block:

				retRes186912 := (<-exchange.CreateOrder("BTC/USDT", "limit", "buy", 1, 20000))
				PanicOnError(retRes186912)
				return nil
			}(this)

		}
		Assert(IsEqual(GetValue(reqHeaders, "X-BM-BROKER-ID"), id), Add(Add("bitmart - id: ", id), " not in headers"))
		if !IsTrue(IsSync()) {

			retRes187512 := (<-Close(exchange))
			PanicOnError(retRes187512)
		}

		ch <- true
		return nil

	}()
	return ch
}
func (this *testMainClass) TestCoinex() <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		var exchange ccxt.ICoreExchange = this.InitOfflineExchange("coinex")
		var id interface{} = "x-167673045"
		Assert(IsEqual(GetValue(exchange.GetOptions(), "brokerId"), id), Add(Add("coinex - id: ", id), " not in options"))
		var spotOrderRequest interface{} = nil

		{
			func(this *testMainClass) (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func(this *testMainClass) interface{} {
							// catch block:
							spotOrderRequest = JsonParse(exchange.GetLast_request_body())
							return nil
						}(this)
					}
				}()
				// try block:

				retRes188612 := (<-exchange.CreateOrder("BTC/USDT", "limit", "buy", 1, 20000))
				PanicOnError(retRes188612)
				return nil
			}(this)

		}
		var clientOrderId interface{} = GetValue(spotOrderRequest, "client_id")
		var idString interface{} = ToString(id)
		Assert(StartsWith(clientOrderId, idString), Add(Add(Add("coinex - clientOrderId: ", clientOrderId), " does not start with id: "), idString))
		if !IsTrue(IsSync()) {

			retRes189412 := (<-Close(exchange))
			PanicOnError(retRes189412)
		}

		ch <- true
		return nil

	}()
	return ch
}
func (this *testMainClass) TestBingx() <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		var exchange ccxt.ICoreExchange = this.InitOfflineExchange("bingx")
		var reqHeaders interface{} = nil
		var id interface{} = "CCXT"
		Assert(IsEqual(GetValue(exchange.GetOptions(), "broker"), id), Add(Add("bingx - id: ", id), " not in options"))

		{
			func(this *testMainClass) (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func(this *testMainClass) interface{} {
							// catch block:
							// we expect an error here, we're only interested in the headers
							reqHeaders = exchange.GetLast_request_headers()
							return nil
						}(this)
					}
				}()
				// try block:

				retRes190512 := (<-exchange.CreateOrder("BTC/USDT", "limit", "buy", 1, 20000))
				PanicOnError(retRes190512)
				return nil
			}(this)

		}
		Assert(IsEqual(GetValue(reqHeaders, "X-SOURCE-KEY"), id), Add(Add("bingx - id: ", id), " not in headers."))
		if !IsTrue(IsSync()) {

			retRes191212 := (<-Close(exchange))
			PanicOnError(retRes191212)
		}

		ch <- true
		return nil

	}()
	return ch
}
func (this *testMainClass) TestPhemex() <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		var exchange ccxt.ICoreExchange = this.InitOfflineExchange("phemex")
		var id interface{} = "CCXT123456"
		var request interface{} = nil

		{
			func(this *testMainClass) (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func(this *testMainClass) interface{} {
							// catch block:
							request = JsonParse(exchange.GetLast_request_body())
							return nil
						}(this)
					}
				}()
				// try block:

				retRes192212 := (<-exchange.CreateOrder("BTC/USDT", "limit", "buy", 1, 20000))
				PanicOnError(retRes192212)
				return nil
			}(this)

		}
		var clientOrderId interface{} = GetValue(request, "clOrdID")
		var idString interface{} = ToString(id)
		Assert(StartsWith(clientOrderId, idString), Add(Add(Add("phemex - clOrdID: ", clientOrderId), " does not start with id: "), idString))
		if !IsTrue(IsSync()) {

			retRes193012 := (<-Close(exchange))
			PanicOnError(retRes193012)
		}

		ch <- true
		return nil

	}()
	return ch
}
func (this *testMainClass) TestBlofin() <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		var exchange ccxt.ICoreExchange = this.InitOfflineExchange("blofin")
		var id interface{} = "ec6dd3a7dd982d0b"
		var request interface{} = nil

		{
			func(this *testMainClass) (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func(this *testMainClass) interface{} {
							// catch block:
							request = JsonParse(exchange.GetLast_request_body())
							return nil
						}(this)
					}
				}()
				// try block:

				retRes194012 := (<-exchange.CreateOrder("LTC/USDT:USDT", "market", "buy", 1))
				PanicOnError(retRes194012)
				return nil
			}(this)

		}
		var brokerId interface{} = GetValue(request, "brokerId")
		var idString interface{} = ToString(id)
		Assert(StartsWith(brokerId, idString), Add(Add(Add("blofin - brokerId: ", brokerId), " does not start with id: "), idString))
		if !IsTrue(IsSync()) {

			retRes194812 := (<-Close(exchange))
			PanicOnError(retRes194812)
		}

		ch <- true
		return nil

	}()
	return ch
}

//	async testHyperliquid () {
//	    const exchange = this.initOfflineExchange ('hyperliquid');
//	    const id = '1';
//	    let request = undefined;
//	    try {
//	        await exchange.GetcreateOrder() ('SOL/USDC:USDC', 'limit', 'buy', 1, 100);
//	    } catch (e) {
//	        request = jsonParse (exchange.Getlast_request_body());
//	    }
//	    const brokerId = (request['action']['brokerCode']).toString ();
//	    assert (brokerId === id, 'hyperliquid - brokerId: ' + brokerId + ' does not start with id: ' + id);
//	    if (!isSync ()) {
//	        await close (exchange);
//	    }
//	    return true;
//	}
func (this *testMainClass) TestCoinbaseinternational() <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		var exchange ccxt.ICoreExchange = this.InitOfflineExchange("coinbaseinternational")
		AddElementToObject(exchange.GetOptions(), "portfolio", "random")
		var id interface{} = "nfqkvdjp"
		Assert(IsEqual(GetValue(exchange.GetOptions(), "brokerId"), id), "id not in options")
		var request interface{} = nil

		{
			func(this *testMainClass) (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func(this *testMainClass) interface{} {
							// catch block:
							request = JsonParse(exchange.GetLast_request_body())
							return nil
						}(this)
					}
				}()
				// try block:

				retRes197712 := (<-exchange.CreateOrder("BTC/USDC:USDC", "limit", "buy", 1, 20000))
				PanicOnError(retRes197712)
				return nil
			}(this)

		}
		var clientOrderId interface{} = GetValue(request, "client_order_id")
		Assert(StartsWith(clientOrderId, ToString(id)), "clientOrderId does not start with id")
		if !IsTrue(IsSync()) {

			retRes198412 := (<-Close(exchange))
			PanicOnError(retRes198412)
		}

		ch <- true
		return nil

	}()
	return ch
}
func (this *testMainClass) TestCoinbaseAdvanced() <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		var exchange ccxt.ICoreExchange = this.InitOfflineExchange("coinbase")
		var id interface{} = "ccxt"
		Assert(IsEqual(GetValue(exchange.GetOptions(), "brokerId"), id), "id not in options")
		var request interface{} = nil

		{
			func(this *testMainClass) (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func(this *testMainClass) interface{} {
							// catch block:
							request = JsonParse(exchange.GetLast_request_body())
							return nil
						}(this)
					}
				}()
				// try block:

				retRes199512 := (<-exchange.CreateOrder("BTC/USDC", "limit", "buy", 1, 20000))
				PanicOnError(retRes199512)
				return nil
			}(this)

		}
		var clientOrderId interface{} = GetValue(request, "client_order_id")
		Assert(StartsWith(clientOrderId, ToString(id)), "clientOrderId does not start with id")
		if !IsTrue(IsSync()) {

			retRes200212 := (<-Close(exchange))
			PanicOnError(retRes200212)
		}

		ch <- true
		return nil

	}()
	return ch
}
func (this *testMainClass) TestWoofiPro() <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		var exchange ccxt.ICoreExchange = this.InitOfflineExchange("woofipro")
		exchange.SetSecret("secretsecretsecretsecretsecretsecretsecrets")
		var id interface{} = "CCXT"

		retRes20118 := (<-exchange.LoadMarkets())
		PanicOnError(retRes20118)
		var request interface{} = nil

		{
			func(this *testMainClass) (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func(this *testMainClass) interface{} {
							// catch block:
							request = JsonParse(exchange.GetLast_request_body())
							return nil
						}(this)
					}
				}()
				// try block:

				retRes201412 := (<-exchange.CreateOrder("BTC/USDC:USDC", "limit", "buy", 1, 20000))
				PanicOnError(retRes201412)
				return nil
			}(this)

		}
		var brokerId interface{} = GetValue(request, "order_tag")
		Assert(IsEqual(brokerId, id), Add(Add(Add("woofipro - id: ", id), " different from  broker_id: "), brokerId))
		if !IsTrue(IsSync()) {

			retRes202112 := (<-Close(exchange))
			PanicOnError(retRes202112)
		}

		ch <- true
		return nil

	}()
	return ch
}
func (this *testMainClass) TestOxfun() <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		var exchange ccxt.ICoreExchange = this.InitOfflineExchange("oxfun")
		exchange.SetSecret("secretsecretsecretsecretsecretsecretsecrets")
		var id interface{} = 1000

		retRes20308 := (<-exchange.LoadMarkets())
		PanicOnError(retRes20308)
		var request interface{} = nil

		{
			func(this *testMainClass) (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func(this *testMainClass) interface{} {
							// catch block:
							request = JsonParse(exchange.GetLast_request_body())
							return nil
						}(this)
					}
				}()
				// try block:

				retRes203312 := (<-exchange.CreateOrder("BTC/USD:OX", "limit", "buy", 1, 20000))
				PanicOnError(retRes203312)
				return nil
			}(this)

		}
		var orders interface{} = GetValue(request, "orders")
		var first interface{} = GetValue(orders, 0)
		var brokerId interface{} = GetValue(first, "source")
		Assert(IsEqual(brokerId, id), Add(Add(Add("oxfun - id: ", ToString(id)), " different from  broker_id: "), ToString(brokerId)))

		ch <- true
		return nil

	}()
	return ch
}
func (this *testMainClass) TestXT() <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		var exchange ccxt.ICoreExchange = this.InitOfflineExchange("xt")
		var id interface{} = "CCXT"
		var spotOrderRequest interface{} = nil

		{
			func(this *testMainClass) (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func(this *testMainClass) interface{} {
							// catch block:
							spotOrderRequest = JsonParse(exchange.GetLast_request_body())
							return nil
						}(this)
					}
				}()
				// try block:

				retRes204912 := (<-exchange.CreateOrder("BTC/USDT", "limit", "buy", 1, 20000))
				PanicOnError(retRes204912)
				return nil
			}(this)

		}
		var spotMedia interface{} = GetValue(spotOrderRequest, "media")
		Assert(IsEqual(spotMedia, id), Add(Add(Add("xt - id: ", id), " different from swap tag: "), spotMedia))
		var swapOrderRequest interface{} = nil

		{
			func(this *testMainClass) (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func(this *testMainClass) interface{} {
							// catch block:
							swapOrderRequest = JsonParse(exchange.GetLast_request_body())
							return nil
						}(this)
					}
				}()
				// try block:

				retRes205712 := (<-exchange.CreateOrder("BTC/USDT:USDT", "limit", "buy", 1, 20000))
				PanicOnError(retRes205712)
				return nil
			}(this)

		}
		var swapMedia interface{} = GetValue(swapOrderRequest, "clientMedia")
		Assert(IsEqual(swapMedia, id), Add(Add(Add("xt - id: ", id), " different from swap tag: "), swapMedia))
		if !IsTrue(IsSync()) {

			retRes206412 := (<-Close(exchange))
			PanicOnError(retRes206412)
		}

		ch <- true
		return nil

	}()
	return ch
}
func (this *testMainClass) TestParadex() <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		var exchange ccxt.ICoreExchange = this.InitOfflineExchange("paradex")
		exchange.SetWalletAddress("0xc751489d24a33172541ea451bc253d7a9e98c781")
		exchange.SetPrivateKey("c33b1eb4b53108bf52e10f636d8c1236c04c33a712357ba3543ab45f48a5cb0b")
		AddElementToObject(exchange.GetOptions(), "authToken", "token")
		AddElementToObject(exchange.GetOptions(), "systemConfig", map[string]interface{}{
			"starknet_gateway_url":         "https://potc-testnet-sepolia.starknet.io",
			"starknet_fullnode_rpc_url":    "https://pathfinder.api.testnet.paradex.trade/rpc/v0_7",
			"starknet_chain_id":            "PRIVATE_SN_POTC_SEPOLIA",
			"block_explorer_url":           "https://voyager.testnet.paradex.trade/",
			"paraclear_address":            "0x286003f7c7bfc3f94e8f0af48b48302e7aee2fb13c23b141479ba00832ef2c6",
			"paraclear_decimals":           8,
			"paraclear_account_proxy_hash": "0x3530cc4759d78042f1b543bf797f5f3d647cde0388c33734cf91b7f7b9314a9",
			"paraclear_account_hash":       "0x41cb0280ebadaa75f996d8d92c6f265f6d040bb3ba442e5f86a554f1765244e",
			"oracle_address":               "0x2c6a867917ef858d6b193a0ff9e62b46d0dc760366920d631715d58baeaca1f",
			"bridged_tokens": []interface{}{map[string]interface{}{
				"name":              "TEST USDC",
				"symbol":            "USDC",
				"decimals":          6,
				"l1_token_address":  "0x29A873159D5e14AcBd63913D4A7E2df04570c666",
				"l1_bridge_address": "0x8586e05adc0C35aa11609023d4Ae6075Cb813b4C",
				"l2_token_address":  "0x6f373b346561036d98ea10fb3e60d2f459c872b1933b50b21fe6ef4fda3b75e",
				"l2_bridge_address": "0x46e9237f5408b5f899e72125dd69bd55485a287aaf24663d3ebe00d237fc7ef",
			}},
			"l1_core_contract_address": "0x582CC5d9b509391232cd544cDF9da036e55833Af",
			"l1_operator_address":      "0x11bACdFbBcd3Febe5e8CEAa75E0Ef6444d9B45FB",
			"l1_chain_id":              "11155111",
			"liquidation_fee":          "0.2",
		})
		var reqHeaders interface{} = nil
		var id interface{} = "CCXT"
		Assert(IsEqual(GetValue(exchange.GetOptions(), "broker"), id), Add(Add("paradex - id: ", id), " not in options"))

		retRes20798 := (<-exchange.LoadMarkets())
		PanicOnError(retRes20798)

		{
			func(this *testMainClass) (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func(this *testMainClass) interface{} {
							// catch block:
							reqHeaders = exchange.GetLast_request_headers()
							return nil
						}(this)
					}
				}()
				// try block:

				retRes208112 := (<-exchange.CreateOrder("BTC/USD:USDC", "limit", "buy", 1, 20000))
				PanicOnError(retRes208112)
				return nil
			}(this)

		}
		Assert(IsEqual(GetValue(reqHeaders, "PARADEX-PARTNER"), id), Add(Add("paradex - id: ", id), " not in headers"))
		if !IsTrue(IsSync()) {

			retRes208712 := (<-Close(exchange))
			PanicOnError(retRes208712)
		}

		ch <- true
		return nil

	}()
	return ch
}
func (this *testMainClass) TestHashkey() <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		var exchange ccxt.ICoreExchange = this.InitOfflineExchange("hashkey")
		var reqHeaders interface{} = nil
		var id interface{} = "10000700011"

		{
			func(this *testMainClass) (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func(this *testMainClass) interface{} {
							// catch block:
							// we expect an error here, we're only interested in the headers
							reqHeaders = exchange.GetLast_request_headers()
							return nil
						}(this)
					}
				}()
				// try block:

				retRes209712 := (<-exchange.CreateOrder("BTC/USDT", "limit", "buy", 1, 20000))
				PanicOnError(retRes209712)
				return nil
			}(this)

		}
		Assert(IsEqual(GetValue(reqHeaders, "INPUT-SOURCE"), id), Add(Add("hashkey - id: ", id), " not in headers."))
		if !IsTrue(IsSync()) {

			retRes210412 := (<-Close(exchange))
			PanicOnError(retRes210412)
		}

		ch <- true
		return nil

	}()
	return ch
}
func (this *testMainClass) TestCoincatch() <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		var exchange ccxt.ICoreExchange = this.InitOfflineExchange("coincatch")
		var reqHeaders interface{} = nil
		var id interface{} = "47cfy"

		{
			func(this *testMainClass) (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func(this *testMainClass) interface{} {
							// catch block:
							// we expect an error here, we're only interested in the headers
							reqHeaders = exchange.GetLast_request_headers()
							return nil
						}(this)
					}
				}()
				// try block:

				retRes211412 := (<-exchange.CreateOrder("BTC/USDT", "limit", "buy", 1, 20000))
				PanicOnError(retRes211412)
				return nil
			}(this)

		}
		Assert(IsEqual(GetValue(reqHeaders, "X-CHANNEL-API-CODE"), id), Add(Add("coincatch - id: ", id), " not in headers."))
		if !IsTrue(IsSync()) {

			retRes212112 := (<-Close(exchange))
			PanicOnError(retRes212112)
		}

		ch <- true
		return nil

	}()
	return ch
}
func (this *testMainClass) TestDefx() <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		var exchange ccxt.ICoreExchange = this.InitOfflineExchange("defx")
		var reqHeaders interface{} = nil

		{
			func(this *testMainClass) (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func(this *testMainClass) interface{} {
							// catch block:
							// we expect an error here, we're only interested in the headers
							reqHeaders = exchange.GetLast_request_headers()
							return nil
						}(this)
					}
				}()
				// try block:

				retRes213112 := (<-exchange.CreateOrder("DOGE/USDC:USDC", "limit", "buy", 100, 1))
				PanicOnError(retRes213112)
				return nil
			}(this)

		}
		var id interface{} = "ccxt"
		Assert(IsEqual(GetValue(reqHeaders, "X-DEFX-SOURCE"), id), Add(Add("defx - id: ", id), " not in headers."))
		if !IsTrue(IsSync()) {

			retRes213912 := (<-Close(exchange))
			PanicOnError(retRes213912)
		}

		ch <- true
		return nil

	}()
	return ch
}
func (this *testMainClass) TestCryptomus() <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		var exchange ccxt.ICoreExchange = this.InitOfflineExchange("cryptomus")
		var request interface{} = nil

		{
			func(this *testMainClass) (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func(this *testMainClass) interface{} {
							// catch block:
							request = JsonParse(exchange.GetLast_request_body())
							return nil
						}(this)
					}
				}()
				// try block:

				retRes214812 := (<-exchange.CreateOrder("BTC/USDT", "limit", "sell", 1, 20000))
				PanicOnError(retRes214812)
				return nil
			}(this)

		}
		var tag interface{} = "ccxt"
		Assert(IsEqual(GetValue(request, "tag"), tag), Add(Add("cryptomus - tag: ", tag), " not in request."))
		if !IsTrue(IsSync()) {

			retRes215512 := (<-Close(exchange))
			PanicOnError(retRes215512)
		}

		ch <- true
		return nil

	}()
	return ch
}
func (this *testMainClass) TestDerive() <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		var exchange ccxt.ICoreExchange = this.InitOfflineExchange("derive")
		var id interface{} = "0x0ad42b8e602c2d3d475ae52d678cf63d84ab2749"
		Assert(IsEqual(GetValue(exchange.GetOptions(), "id"), id), Add(Add("derive - id: ", id), " not in options"))
		var request interface{} = nil

		{
			func(this *testMainClass) (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func(this *testMainClass) interface{} {
							// catch block:
							request = JsonParse(exchange.GetLast_request_body())
							return nil
						}(this)
					}
				}()
				// try block:
				var params interface{} = map[string]interface{}{
					"subaccount_id":       1234,
					"max_fee":             10,
					"deriveWalletAddress": "0x0ad42b8e602c2d3d475ae52d678cf63d84ab2749",
				}
				exchange.SetWalletAddress("0x0ad42b8e602c2d3d475ae52d678cf63d84ab2749")
				exchange.SetPrivateKey("0x7b77bb7b20e92bbb85f2a22b330b896959229a5790e35f2f290922de3fb22ad5")

				retRes217312 := (<-exchange.CreateOrder("LBTC/USDC", "limit", "sell", 0.01, 3000, params))
				PanicOnError(retRes217312)
				return nil
			}(this)

		}
		Assert(IsEqual(GetValue(request, "referral_code"), id), Add(Add("derive - referral_code: ", id), " not in request."))
		if !IsTrue(IsSync()) {

			retRes217912 := (<-Close(exchange))
			PanicOnError(retRes217912)
		}

		ch <- true
		return nil

	}()
	return ch
}
func (this *testMainClass) TestModeTrade() <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		var exchange ccxt.ICoreExchange = this.InitOfflineExchange("modetrade")
		exchange.SetSecret("secretsecretsecretsecretsecretsecretsecrets")
		var id interface{} = "CCXTMODE"

		retRes21888 := (<-exchange.LoadMarkets())
		PanicOnError(retRes21888)
		var request interface{} = nil

		{
			func(this *testMainClass) (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func(this *testMainClass) interface{} {
							// catch block:
							request = JsonParse(exchange.GetLast_request_body())
							return nil
						}(this)
					}
				}()
				// try block:

				retRes219112 := (<-exchange.CreateOrder("BTC/USDC:USDC", "limit", "buy", 1, 20000))
				PanicOnError(retRes219112)
				return nil
			}(this)

		}
		var brokerId interface{} = GetValue(request, "order_tag")
		Assert(IsEqual(brokerId, id), Add(Add(Add("modetrade - id: ", id), " different from  broker_id: "), brokerId))
		if !IsTrue(IsSync()) {

			retRes219812 := (<-Close(exchange))
			PanicOnError(retRes219812)
		}

		ch <- true
		return nil

	}()
	return ch
}
