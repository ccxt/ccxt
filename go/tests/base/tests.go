package base
import "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type testMainClass struct {
    IdTests bool `default:"false"`
    RequestTestsFailed bool `default:"false"`
    ResponseTestsFailed bool `default:"false"`
    RequestTests bool `default:"false"`
    WsTests bool `default:"false"`
    ResponseTests bool `default:"false"`
    Info bool `default:"false"`
    Verbose bool `default:"false"`
    Debug bool `default:"false"`
    PrivateTest bool `default:"false"`
    PrivateTestOnly bool `default:"false"`
    LoadKeys bool `default:"false"`
    Sandbox bool `default:"false"`
    OnlySpecificTests interface{}  `default:"[]interface{}{}"`
    SkippedSettingsForExchange interface{} `default:"map[string]interface{} {}"`
    SkippedMethods interface{} `default:"map[string]interface{} {}"`
    CheckedPublicTests interface{} `default:"map[string]interface{} {}"`
    TestFiles interface{} `default:"map[string]interface{} {}"`
    PublicTests interface{} `default:"map[string]interface{} {}"`
    Ext string `default:""`
    Lang string `default:""`
    ProxyTestFileName interface{} `default:"proxies"`
}

func NewTestMainClass() testMainClass {
   p := testMainClass{}
   setDefaults(&p)
   return p
}

func  (this *testMainClass) ParseCliArgsAndProps()  {
    this.ResponseTests = IsTrue(GetCliArgValue("--responseTests")) || IsTrue(GetCliArgValue("--response"))
    this.IdTests = GetCliArgValue("--idTests")
    this.RequestTests = IsTrue(GetCliArgValue("--requestTests")) || IsTrue(GetCliArgValue("--request"))
    this.Info = GetCliArgValue("--info")
    this.Verbose = GetCliArgValue("--verbose")
    this.Debug = GetCliArgValue("--debug")
    this.PrivateTest = GetCliArgValue("--private")
    this.PrivateTestOnly = GetCliArgValue("--privateOnly")
    this.Sandbox = GetCliArgValue("--sandbox")
    this.LoadKeys = GetCliArgValue("--loadKeys")
    this.WsTests = GetCliArgValue("--ws")
    this.Lang = GetLang()
    this.Ext = GetExt()
}
func  (this *testMainClass) Init(exchangeId interface{}, symbolArgv interface{}, methodArgv interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    this.ParseCliArgsAndProps()
            if IsTrue(IsTrue(this.RequestTests) && IsTrue(this.ResponseTests)) {
        
                retRes9212 := (<-this.RunStaticRequestTests(exchangeId, symbolArgv))
                PanicOnError(retRes9212)
        
                retRes9312 := (<-this.RunStaticResponseTests(exchangeId, symbolArgv))
                PanicOnError(retRes9312)
        
                ch <- true
                return nil
            }
            if IsTrue(this.ResponseTests) {
        
                retRes9712 := (<-this.RunStaticResponseTests(exchangeId, symbolArgv))
                PanicOnError(retRes9712)
        
                ch <- true
                return nil
            }
            if IsTrue(this.RequestTests) {
        
                retRes10112 := (<-this.RunStaticRequestTests(exchangeId, symbolArgv))
                PanicOnError(retRes10112) // symbol here is the testname
        
                ch <- true
                return nil
            }
            if IsTrue(this.IdTests) {
        
                retRes10512 := (<-this.RunBrokerIdTests())
                PanicOnError(retRes10512)
        
                ch <- true
                return nil
            }
            var newLine interface{} = "\n"
            Dump(Add(Add(Add(Add(newLine, ""), newLine), ""), "[INFO] TESTING "), this.Ext, map[string]interface{} {
                "exchange": exchangeId,
                "symbol": symbolArgv,
                "method": methodArgv,
                "isWs": this.WsTests,
                "useProxy": GetCliArgValue("--useProxy"),
            }, newLine)
            var exchangeArgs interface{} = map[string]interface{} {
                "verbose": this.Verbose,
                "debug": this.Debug,
                "enableRateLimit": true,
                "timeout": 30000,
            }
            var exchange ccxt.IExchange = InitExchange(exchangeId, exchangeArgs, this.WsTests)
            if IsTrue(exchange.GetAlias()) {
                ExitScript(0)
            }
        
            retRes1208 := (<-this.ImportFiles(exchange))
            PanicOnError(retRes1208)
            Assert(IsGreaterThan(GetArrayLength(ObjectKeys(this.TestFiles)), 0), "Test files were not loaded") // ensure test files are found & filled
            this.ExpandSettings(exchange)
            this.CheckIfSpecificTestIsChosen(methodArgv)
        
            retRes1248 := (<-this.StartTest(exchange, symbolArgv))
            PanicOnError(retRes1248)
            ExitScript(0) // needed to be explicitly finished for WS tests
        
            ch <- true  // required for c#
            return nil
        
            }()
            return ch
        }
func  (this *testMainClass) CheckIfSpecificTestIsChosen(methodArgv interface{})  {
    if IsTrue(!IsEqual(methodArgv, nil)) {
        var testFileNames interface{} = ObjectKeys(this.TestFiles)
        var possibleMethodNames interface{} = Split(methodArgv, ",") // i.e. `test.ts binance fetchBalance,fetchDeposits`
        if IsTrue(IsGreaterThanOrEqual(GetArrayLength(possibleMethodNames), 1)) {
            for i := 0; IsLessThan(i, GetArrayLength(testFileNames)); i++ {
                var testFileName interface{} = GetValue(testFileNames, i)
                for j := 0; IsLessThan(j, GetArrayLength(possibleMethodNames)); j++ {
                    var methodName interface{} = GetValue(possibleMethodNames, j)
                    methodName = Replace(methodName, "()", "")
                    if IsTrue(IsEqual(testFileName, methodName)) {
                        AppendToArray(&this.OnlySpecificTests,testFileName)
                    }
                }
            }
        }
    }
}
func  (this *testMainClass) ImportFiles(exchange ccxt.IExchange) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    var properties interface{} = ObjectKeys(exchange.GetHas())
            AppendToArray(&properties,"loadMarkets")
            if IsTrue(IsSync()) {
                this.TestFiles = GetTestFilesSync(properties, this.WsTests)
            } else {
                
        this.TestFiles = (<-GetTestFiles(properties, this.WsTests))
                PanicOnError(this.TestFiles)
            }
        
            ch <- true
            return nil
        
            }()
            return ch
        }
func  (this *testMainClass) LoadCredentialsFromEnv(exchange ccxt.IExchange)  {
    var exchangeId interface{} = exchange.GetId()
    var reqCreds interface{} = GetExchangeProp(exchange, Add("re", "quiredCredentials")) // dont glue the r-e-q-u-i-r-e phrase, because leads to messed up transpilation
    var objkeys interface{} = ObjectKeys(reqCreds)
    for i := 0; IsLessThan(i, GetArrayLength(objkeys)); i++ {
        var credential interface{} = GetValue(objkeys, i)
        var isRequired interface{} = GetValue(reqCreds, credential)
        if IsTrue(IsTrue(isRequired) && IsTrue(IsEqual(GetExchangeProp(exchange, credential), nil))) {
            var fullKey interface{} = Add(Add(exchangeId, "_"), credential)
            var credentialEnvName interface{} = ToUpper(fullKey) // example: KRAKEN_APIKEY
            var envVars interface{} = GetEnvVars()
            var credentialValue interface{} = Ternary(IsTrue((InOp(envVars, credentialEnvName))), GetValue(envVars, credentialEnvName), nil)
            if IsTrue(credentialValue) {
                SetExchangeProp(exchange, credential, credentialValue)
            }
        }
    }
}
func  (this *testMainClass) ExpandSettings(exchange ccxt.IExchange)  {
    var exchangeId interface{} = exchange.GetId()
    var keysGlobal interface{} = Add(GetRootDir(), "keys.json")
    var keysLocal interface{} = Add(GetRootDir(), "keys.local.json")
    var keysGlobalExists interface{} = IoFileExists(keysGlobal)
    var keysLocalExists interface{} = IoFileExists(keysLocal)
    var globalSettings interface{} = map[string]interface{} {}
    if IsTrue(keysGlobalExists) {
        globalSettings = IoFileRead(keysGlobal)
    }
    var localSettings interface{} = map[string]interface{} {}
    if IsTrue(keysLocalExists) {
        localSettings = IoFileRead(keysLocal)
    }
    var allSettings interface{} = exchange.DeepExtend(globalSettings, localSettings)
    var exchangeSettings interface{} = exchange.SafeValue(allSettings, exchangeId, map[string]interface{} {})
    if IsTrue(exchangeSettings) {
        var settingKeys interface{} = ObjectKeys(exchangeSettings)
        for i := 0; IsLessThan(i, GetArrayLength(settingKeys)); i++ {
            var key interface{} = GetValue(settingKeys, i)
            if IsTrue(GetValue(exchangeSettings, key)) {
                var finalValue interface{} = nil
                if IsTrue(IsObject(GetValue(exchangeSettings, key))) {
                    var existing interface{} = GetExchangeProp(exchange, key, map[string]interface{} {})
                    finalValue = exchange.DeepExtend(existing, GetValue(exchangeSettings, key))
                } else {
                    finalValue = GetValue(exchangeSettings, key)
                }
                SetExchangeProp(exchange, key, finalValue)
            }
        }
    }
    // credentials
    if IsTrue(this.LoadKeys) {
        this.LoadCredentialsFromEnv(exchange)
    }
    // skipped tests
    var skippedFile interface{} = Add(GetRootDir(), "skip-tests.json")
    var skippedSettings interface{} = IoFileRead(skippedFile)
    this.SkippedSettingsForExchange = exchange.SafeValue(skippedSettings, exchangeId, map[string]interface{} {})
    var skippedSettingsForExchange interface{} = this.SkippedSettingsForExchange
    // others
    var timeout interface{} = exchange.SafeValue(skippedSettingsForExchange, "timeout")
    if IsTrue(!IsEqual(timeout, nil)) {
        exchange.SetTimeout(exchange.ParseToInt(timeout))
    }
    if IsTrue(GetCliArgValue("--useProxy")) {
        exchange.SetHttpProxy(exchange.SafeString(skippedSettingsForExchange, "httpProxy"))
        exchange.SetHttpsProxy(exchange.SafeString(skippedSettingsForExchange, "httpsProxy"))
        exchange.SetWsProxy(exchange.SafeString(skippedSettingsForExchange, "wsProxy"))
        exchange.SetWssProxy(exchange.SafeString(skippedSettingsForExchange, "wssProxy"))
    }
    this.SkippedMethods = exchange.SafeValue(skippedSettingsForExchange, "skipMethods", map[string]interface{} {})
    this.CheckedPublicTests = map[string]interface{} {}
}
func  (this *testMainClass) AddPadding(message interface{}, size interface{}) interface{}  {
    // has to be transpilable
    var res interface{} = ""
    var messageLength interface{} =     GetLength(message) // avoid php transpilation issue
    var missingSpace interface{} = Subtract(Subtract(size, messageLength), 0) // - 0 is added just to trick transpile to treat the .length as a string for php
    if IsTrue(IsGreaterThan(missingSpace, 0)) {
        for i := 0; IsLessThan(i, missingSpace); i++ {
            res = Add(res, " ")
        }
    }
    return Add(message, res)
}
func  (this *testMainClass) TestMethod(methodName interface{}, exchange ccxt.IExchange, args interface{}, isPublic interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    // todo: temporary skip for c#
            if IsTrue(IsTrue(IsGreaterThanOrEqual(GetIndexOf(methodName, "OrderBook"), 0)) && IsTrue(IsEqual(this.Ext, "cs"))) {
                AddElementToObject(exchange.GetOptions(), "checksum", false)
            }
            // todo: temporary skip for php
            if IsTrue(IsTrue(IsGreaterThanOrEqual(GetIndexOf(methodName, "OrderBook"), 0)) && IsTrue(IsEqual(this.Ext, "php"))) {
        
                ch <- true
                return nil
            }
            var skippedPropertiesForMethod interface{} = this.GetSkips(exchange, methodName)
            var isLoadMarkets interface{} =     (IsEqual(methodName, "loadMarkets"))
            var isFetchCurrencies interface{} =     (IsEqual(methodName, "fetchCurrencies"))
            var isProxyTest interface{} =     (IsEqual(methodName, this.ProxyTestFileName))
            var isFeatureTest interface{} =     (IsEqual(methodName, "features"))
            // if this is a private test, and the implementation was already tested in public, then no need to re-test it in private test (exception is fetchCurrencies, because our approach in base exchange)
            if IsTrue(IsTrue(!IsTrue(isPublic) && IsTrue((InOp(this.CheckedPublicTests, methodName)))) && !IsTrue(isFetchCurrencies)) {
        
                ch <- true
                return nil
            }
            var skipMessage interface{} = nil
            var supportedByExchange interface{} = IsTrue((InOp(exchange.GetHas(), methodName))) && IsTrue(GetValue(exchange.GetHas(), methodName))
            if IsTrue(!IsTrue(isLoadMarkets) && IsTrue((IsTrue(IsGreaterThan(GetArrayLength(this.OnlySpecificTests), 0)) && !IsTrue(exchange.InArray(methodName, this.OnlySpecificTests))))) {
                skipMessage = "[INFO] IGNORED_TEST"
            } else if IsTrue(IsTrue(IsTrue(!IsTrue(isLoadMarkets) && !IsTrue(supportedByExchange)) && !IsTrue(isProxyTest)) && !IsTrue(isFeatureTest)) {
                skipMessage = "[INFO] UNSUPPORTED_TEST" // keep it aligned with the longest message
            } else if IsTrue(IsString(skippedPropertiesForMethod)) {
                skipMessage = "[INFO] SKIPPED_TEST"
            } else if !IsTrue((InOp(this.TestFiles, methodName))) {
                skipMessage = "[INFO] UNIMPLEMENTED_TEST"
            }
            // exceptionally for `loadMarkets` call, we call it before it's even checked for "skip" as we need it to be called anyway (but can skip "test.loadMarket" for it)
            if IsTrue(isLoadMarkets) {
        
                retRes27812 := (<-exchange.LoadMarkets(true))
                PanicOnError(retRes27812)
            }
            var name interface{} = exchange.GetId()
            if IsTrue(skipMessage) {
                if IsTrue(this.Info) {
                    Dump(this.AddPadding(skipMessage, 25), name, methodName)
                }
        
                ch <- true
                return nil
            }
            if IsTrue(this.Info) {
                var argsStringified interface{} = Add(Add("(", exchange.Json(args)), ")") // args.join() breaks when we provide a list of symbols or multidimensional array; "args.toString()" breaks bcz of "array to string conversion"
                Dump(this.AddPadding("[INFO] TESTING", 25), name, methodName, argsStringified)
            }
            if IsTrue(IsSync()) {
                CallMethodSync(this.TestFiles, methodName, exchange, skippedPropertiesForMethod, args)
            } else {
        
                retRes29412 := (<-CallMethod(this.TestFiles, methodName, exchange, skippedPropertiesForMethod, args))
                PanicOnError(retRes29412)
            }
            if IsTrue(this.Info) {
                Dump(this.AddPadding("[INFO] TESTING DONE", 25), name, methodName)
            }
            // add to the list of successed tests
            if IsTrue(isPublic) {
                AddElementToObject(this.CheckedPublicTests, methodName, true)
            }
        
            ch <- true
            return nil
        
            }()
            return ch
        }
func  (this *testMainClass) GetSkips(exchange ccxt.IExchange, methodName interface{}) interface{}  {
    var finalSkips interface{} = map[string]interface{} {}
    // check the exact method (i.e. `fetchTrades`) and language-specific (i.e. `fetchTrades.php`)
    var methodNames interface{} = []interface{}{methodName, Add(Add(methodName, "."), this.Ext)}
    for i := 0; IsLessThan(i, GetArrayLength(methodNames)); i++ {
        var mName interface{} = GetValue(methodNames, i)
        if IsTrue(InOp(this.SkippedMethods, mName)) {
            // if whole method is skipped, by assigning a string to it, i.e. "fetchOrders":"blabla"
            if IsTrue(IsString(GetValue(this.SkippedMethods, mName))) {
                return GetValue(this.SkippedMethods, mName)
            } else {
                finalSkips = exchange.DeepExtend(finalSkips, GetValue(this.SkippedMethods, mName))
            }
        }
    }
    // get "object-specific" skips
    var objectSkips interface{} = map[string]interface{} {
        "orderBook": []interface{}{"fetchOrderBook", "fetchOrderBooks", "fetchL2OrderBook", "watchOrderBook", "watchOrderBookForSymbols"},
        "ticker": []interface{}{"fetchTicker", "fetchTickers", "watchTicker", "watchTickers"},
        "trade": []interface{}{"fetchTrades", "watchTrades", "watchTradesForSymbols"},
        "ohlcv": []interface{}{"fetchOHLCV", "watchOHLCV", "watchOHLCVForSymbols"},
        "ledger": []interface{}{"fetchLedger", "fetchLedgerEntry"},
        "depositWithdraw": []interface{}{"fetchDepositsWithdrawals", "fetchDeposits", "fetchWithdrawals"},
        "depositWithdrawFee": []interface{}{"fetchDepositWithdrawFee", "fetchDepositWithdrawFees"},
    }
    var objectNames interface{} = ObjectKeys(objectSkips)
    for i := 0; IsLessThan(i, GetArrayLength(objectNames)); i++ {
        var objectName interface{} = GetValue(objectNames, i)
        var objectMethods interface{} = GetValue(objectSkips, objectName)
        if IsTrue(exchange.InArray(methodName, objectMethods)) {
            // if whole object is skipped, by assigning a string to it, i.e. "orderBook":"blabla"
            if IsTrue(IsTrue((InOp(this.SkippedMethods, objectName))) && IsTrue((IsString(GetValue(this.SkippedMethods, objectName))))) {
                return GetValue(this.SkippedMethods, objectName)
            }
            var extraSkips interface{} = exchange.SafeDict(this.SkippedMethods, objectName, map[string]interface{} {})
            finalSkips = exchange.DeepExtend(finalSkips, extraSkips)
        }
    }
    // extend related skips
    // - if 'timestamp' is skipped, we should do so for 'datetime' too
    // - if 'bid' is skipped, skip 'ask' too
    if IsTrue(IsTrue((InOp(finalSkips, "timestamp"))) && !IsTrue((InOp(finalSkips, "datetime")))) {
        AddElementToObject(finalSkips, "datetime", GetValue(finalSkips, "timestamp"))
    }
    if IsTrue(IsTrue((InOp(finalSkips, "bid"))) && !IsTrue((InOp(finalSkips, "ask")))) {
        AddElementToObject(finalSkips, "ask", GetValue(finalSkips, "bid"))
    }
    if IsTrue(IsTrue((InOp(finalSkips, "baseVolume"))) && !IsTrue((InOp(finalSkips, "quoteVolume")))) {
        AddElementToObject(finalSkips, "quoteVolume", GetValue(finalSkips, "baseVolume"))
    }
    return finalSkips
}
func  (this *testMainClass) TestSafe(methodName interface{}, exchange ccxt.IExchange, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    // `testSafe` method does not throw an exception, instead mutes it. The reason we
            // mute the thrown exceptions here is because we don't want to stop the whole
            // tests queue if any single test-method fails. Instead, they are echoed with
            // formatted message "[TEST_FAILURE] ..." and that output is then regex-matched by
            // run-tests.js, so the exceptions are still printed out to console from there.
            args := GetArg(optionalArgs, 0, []interface{}{})
            _ = args
            isPublic := GetArg(optionalArgs, 1, false)
            _ = isPublic
            var maxRetries interface{} = 3
            var argsStringified interface{} = exchange.Json(args) // args.join() breaks when we provide a list of symbols or multidimensional array; "args.toString()" breaks bcz of "array to string conversion"
            for i := 0; IsLessThan(i, maxRetries); i++ {
                
                {		ret__ := func(this *testMainClass) (ret_ interface{}) {
                		defer func() {
                			if e := recover(); e != nil {
                                if e == "break" {
                				    return
                			    }
                				ret_ = func(this *testMainClass) interface{} {
                					// catch block:
                                                var e interface{} = GetRootException(e)
                            var isLoadMarkets interface{} =             (IsEqual(methodName, "loadMarkets"))
                            var isAuthError interface{} =             (IsInstance(e, AuthenticationError))
                            var isNotSupported interface{} =             (IsInstance(e, NotSupported))
                            var isOperationFailed interface{} =             (IsInstance(e, OperationFailed)) // includes "DDoSProtection", "RateLimitExceeded", "RequestTimeout", "ExchangeNotAvailable", "OperationFailed", "InvalidNonce", ...
                            if IsTrue(isOperationFailed) {
                                // if last retry was gone with same `tempFailure` error, then let's eventually return false
                                if IsTrue(IsEqual(i, Subtract(maxRetries, 1))) {
                                    var isOnMaintenance interface{} =                     (IsInstance(e, OnMaintenance))
                                    var isExchangeNotAvailable interface{} =                     (IsInstance(e, ExchangeNotAvailable))
                                    var shouldFail interface{} = nil
                                    var retSuccess interface{} = nil
                                    if IsTrue(isLoadMarkets) {
                                        // if "loadMarkets" does not succeed, we must return "false" to caller method, to stop tests continual
                                        retSuccess = false
                                        // we might not break exchange tests, if exchange is on maintenance at this moment
                                        if IsTrue(isOnMaintenance) {
                                            shouldFail = false
                                        } else {
                                            shouldFail = true
                                        }
                                    } else {
                                        // for any other method tests:
                                        if IsTrue(IsTrue(isExchangeNotAvailable) && !IsTrue(isOnMaintenance)) {
                                            // break exchange tests if "ExchangeNotAvailable" exception is thrown, but it's not maintenance
                                            shouldFail = true
                                            retSuccess = false
                                        } else {
                                            // in all other cases of OperationFailed, show Warning, but don't mark test as failed
                                            shouldFail = false
                                            retSuccess = true
                                        }
                                    }
                                    // output the message
                                    var failType interface{} = Ternary(IsTrue(shouldFail), "[TEST_FAILURE]", "[TEST_WARNING]")
                                    Dump(failType, "Method could not be tested due to a repeated Network/Availability issues", " | ", exchange.GetId(), methodName, argsStringified, ExceptionMessage(e))
                
                                    ch <- retSuccess
                                    return nil
                                } else {
                                    // wait and retry again
                                    // (increase wait time on every retry)
                
                                    retRes41524 := (<-exchange.Sleep(Multiply((Add(i, 1)), 1000)))
                                    PanicOnError(retRes41524)
                                }
                            } else {
                                // if it's loadMarkets, then fail test, because it's mandatory for tests
                                if IsTrue(isLoadMarkets) {
                                    Dump("[TEST_FAILURE]", "Exchange can not load markets", ExceptionMessage(e), exchange.GetId(), methodName, argsStringified)
                
                                    ch <- false
                                    return nil
                                }
                                // if the specific arguments to the test method throws "NotSupported" exception
                                // then let's don't fail the test
                                if IsTrue(isNotSupported) {
                                    if IsTrue(this.Info) {
                                        Dump("[INFO] NOT_SUPPORTED", ExceptionMessage(e), exchange.GetId(), methodName, argsStringified)
                                    }
                
                                    ch <- true
                                    return nil
                                }
                                // If public test faces authentication error, we don't break (see comments under `testSafe` method)
                                if IsTrue(IsTrue(isPublic) && IsTrue(isAuthError)) {
                                    if IsTrue(this.Info) {
                                        Dump("[INFO]", "Authentication problem for public method", ExceptionMessage(e), exchange.GetId(), methodName, argsStringified)
                                    }
                
                                    ch <- true
                                    return nil
                                } else {
                                    Dump("[TEST_FAILURE]", ExceptionMessage(e), exchange.GetId(), methodName, argsStringified)
                
                                    ch <- false
                                    return nil
                                }
                            }
                                    return nil
                				}(this)
                			}
                		}()
                		// try block:
                        
                            retRes36916 := (<-this.TestMethod(methodName, exchange, args, isPublic))
                            PanicOnError(retRes36916)
                
                            ch <- true
                            return nil
                		return nil
                	}(this)
                	if ret__ != nil {
                		return ret__
                	}
                }
            }
        
            ch <- true
            return nil
        
            }()
            return ch
        }
func  (this *testMainClass) RunPublicTests(exchange ccxt.IExchange, symbol interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    var tests interface{} = map[string]interface{} {
                "features": []interface{}{},
                "fetchCurrencies": []interface{}{},
                "fetchTicker": []interface{}{symbol},
                "fetchTickers": []interface{}{symbol},
                "fetchLastPrices": []interface{}{symbol},
                "fetchOHLCV": []interface{}{symbol},
                "fetchTrades": []interface{}{symbol},
                "fetchOrderBook": []interface{}{symbol},
                "fetchL2OrderBook": []interface{}{symbol},
                "fetchOrderBooks": []interface{}{},
                "fetchBidsAsks": []interface{}{},
                "fetchStatus": []interface{}{},
                "fetchTime": []interface{}{},
            }
            if IsTrue(this.WsTests) {
                tests = map[string]interface{} {
                    "watchOHLCV": []interface{}{symbol},
                    "watchOHLCVForSymbols": []interface{}{symbol},
                    "watchTicker": []interface{}{symbol},
                    "watchTickers": []interface{}{symbol},
                    "watchBidsAsks": []interface{}{symbol},
                    "watchOrderBook": []interface{}{symbol},
                    "watchOrderBookForSymbols": []interface{}{[]interface{}{symbol}},
                    "watchTrades": []interface{}{symbol},
                    "watchTradesForSymbols": []interface{}{[]interface{}{symbol}},
                }
            }
            var market interface{} = exchange.Market(symbol)
            var isSpot interface{} = GetValue(market, "spot")
            if !IsTrue(this.WsTests) {
                if IsTrue(isSpot) {
                    AddElementToObject(tests, "fetchCurrencies", []interface{}{})
                } else {
                    AddElementToObject(tests, "fetchFundingRates", []interface{}{symbol})
                    AddElementToObject(tests, "fetchFundingRate", []interface{}{symbol})
                    AddElementToObject(tests, "fetchFundingRateHistory", []interface{}{symbol})
                    AddElementToObject(tests, "fetchIndexOHLCV", []interface{}{symbol})
                    AddElementToObject(tests, "fetchMarkOHLCV", []interface{}{symbol})
                    AddElementToObject(tests, "fetchPremiumIndexOHLCV", []interface{}{symbol})
                }
            }
            this.PublicTests = tests
        
            retRes4988 := (<-this.RunTests(exchange, tests, true))
            PanicOnError(retRes4988)
        
            ch <- true
            return nil
        
            }()
            return ch
        }
func  (this *testMainClass) RunTests(exchange ccxt.IExchange, tests interface{}, isPublicTest interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    var testNames interface{} = ObjectKeys(tests)
            var promises interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(testNames)); i++ {
                var testName interface{} = GetValue(testNames, i)
                var testArgs interface{} = GetValue(tests, testName)
                AppendToArray(&promises,this.TestSafe(testName, exchange, testArgs, isPublicTest))
            }
            // todo - not yet ready in other langs too
            // promises.push (testThrottle ());
        
            results:= (<-promiseAll(promises))
            PanicOnError(results)
            // now count which test-methods retuned `false` from "testSafe" and dump that info below
            var failedMethods interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(testNames)); i++ {
                var testName interface{} = GetValue(testNames, i)
                var testReturnedValue interface{} = GetValue(results, i)
                if !IsTrue(testReturnedValue) {
                    AppendToArray(&failedMethods,testName)
                }
            }
            var testPrefixString interface{} = Ternary(IsTrue(isPublicTest), "PUBLIC_TESTS", "PRIVATE_TESTS")
            if IsTrue(GetArrayLength(failedMethods)) {
                var errorsString interface{} = Join(failedMethods, ", ")
                Dump("[TEST_FAILURE]", exchange.GetId(), testPrefixString, Add("Failed methods : ", errorsString))
            }
            if IsTrue(this.Info) {
                Dump(this.AddPadding(Add(Add(Add("[INFO] END ", testPrefixString), " "), exchange.GetId()), 25))
            }
        
            ch <- true
            return nil
        
            }()
            return ch
        }
func  (this *testMainClass) LoadExchange(exchange ccxt.IExchange) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                
            result:= (<-this.TestSafe("loadMarkets", exchange, []interface{}{}, true))
            PanicOnError(result)
            if !IsTrue(result) {
        
                ch <- false
                return nil
            }
            var exchangeSymbolsLength interface{} =     GetArrayLength(exchange.GetSymbols())
            Dump("[INFO:MAIN] Exchange loaded", exchangeSymbolsLength, "symbols")
        
            ch <- true
            return nil
        
            }()
            return ch
        }
func  (this *testMainClass) GetTestSymbol(exchange ccxt.IExchange, isSpot interface{}, symbols interface{}) interface{}  {
    var symbol interface{} = nil
    var preferredSpotSymbol interface{} = exchange.SafeString(this.SkippedSettingsForExchange, "preferredSpotSymbol")
    var preferredSwapSymbol interface{} = exchange.SafeString(this.SkippedSettingsForExchange, "preferredSwapSymbol")
    if IsTrue(IsTrue(isSpot) && IsTrue(preferredSpotSymbol)) {
        return preferredSpotSymbol
    } else if IsTrue(!IsTrue(isSpot) && IsTrue(preferredSwapSymbol)) {
        return preferredSwapSymbol
    }
    for i := 0; IsLessThan(i, GetArrayLength(symbols)); i++ {
        var s interface{} = GetValue(symbols, i)
        var market interface{} = exchange.SafeValue(exchange.GetMarkets(), s)
        if IsTrue(!IsEqual(market, nil)) {
            var active interface{} = exchange.SafeValue(market, "active")
            if IsTrue(IsTrue(active) || IsTrue((IsEqual(active, nil)))) {
                symbol = s
                break
            }
        }
    }
    return symbol
}
func  (this *testMainClass) GetExchangeCode(exchange ccxt.IExchange, optionalArgs ...interface{}) interface{}  {
    codes := GetArg(optionalArgs, 0, nil)
    _ = codes
    if IsTrue(IsEqual(codes, nil)) {
        codes = []interface{}{"BTC", "ETH", "XRP", "LTC", "BCH", "EOS", "BNB", "BSV", "USDT"}
    }
    var code interface{} = GetValue(codes, 0)
    for i := 0; IsLessThan(i, GetArrayLength(codes)); i++ {
        if IsTrue(InOp(exchange.GetCurrencies(), GetValue(codes, i))) {
            return GetValue(codes, i)
        }
    }
    return code
}
func  (this *testMainClass) GetMarketsFromExchange(exchange ccxt.IExchange, optionalArgs ...interface{}) interface{}  {
    spot := GetArg(optionalArgs, 0, true)
    _ = spot
    var res interface{} = map[string]interface{} {}
    var markets interface{} = exchange.GetMarkets()
    var keys interface{} = ObjectKeys(markets)
    for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
        var key interface{} = GetValue(keys, i)
        var market interface{} = GetValue(markets, key)
        if IsTrue(IsTrue(spot) && IsTrue(GetValue(market, "spot"))) {
            AddElementToObject(res, GetValue(market, "symbol"), market)
        } else if IsTrue(!IsTrue(spot) && !IsTrue(GetValue(market, "spot"))) {
            AddElementToObject(res, GetValue(market, "symbol"), market)
        }
    }
    return res
}
func  (this *testMainClass) GetValidSymbol(exchange ccxt.IExchange, optionalArgs ...interface{}) interface{}  {
    spot := GetArg(optionalArgs, 0, true)
    _ = spot
    var currentTypeMarkets interface{} = this.GetMarketsFromExchange(exchange, spot)
    var codes interface{} = []interface{}{"BTC", "ETH", "XRP", "LTC", "BNB", "DASH", "DOGE", "ETC", "TRX", "USDT", "USDC", "USD", "EUR", "TUSD", "CNY", "JPY", "BRL"}
    var spotSymbols interface{} = []interface{}{"BTC/USDT", "BTC/USDC", "BTC/USD", "BTC/CNY", "BTC/EUR", "BTC/AUD", "BTC/BRL", "BTC/JPY", "ETH/USDT", "ETH/USDC", "ETH/USD", "ETH/CNY", "ETH/EUR", "ETH/AUD", "ETH/BRL", "ETH/JPY", "EUR/USDT", "EUR/USD", "EUR/USDC", "USDT/EUR", "USD/EUR", "USDC/EUR", "BTC/ETH", "ETH/BTC"}
    var swapSymbols interface{} = []interface{}{"BTC/USDT:USDT", "BTC/USDC:USDC", "BTC/USD:USD", "ETH/USDT:USDT", "ETH/USDC:USDC", "ETH/USD:USD", "BTC/USD:BTC", "ETH/USD:ETH"}
    var targetSymbols interface{} = Ternary(IsTrue(spot), spotSymbols, swapSymbols)
    var symbol interface{} = this.GetTestSymbol(exchange, spot, targetSymbols)
    // if symbols wasn't found from above hardcoded list, then try to locate any symbol which has our target hardcoded 'base' code
    if IsTrue(IsEqual(symbol, nil)) {
        for i := 0; IsLessThan(i, GetArrayLength(codes)); i++ {
            var currentCode interface{} = GetValue(codes, i)
            var marketsArrayForCurrentCode interface{} = exchange.FilterBy(currentTypeMarkets, "base", currentCode)
            var indexedMkts interface{} = exchange.IndexBy(marketsArrayForCurrentCode, "symbol")
            var symbolsArrayForCurrentCode interface{} = ObjectKeys(indexedMkts)
            var symbolsLength interface{} =             GetArrayLength(symbolsArrayForCurrentCode)
            if IsTrue(symbolsLength) {
                symbol = this.GetTestSymbol(exchange, spot, symbolsArrayForCurrentCode)
                break
            }
        }
    }
    // if there wasn't found any symbol with our hardcoded 'base' code, then just try to find symbols that are 'active'
    if IsTrue(IsEqual(symbol, nil)) {
        var activeMarkets interface{} = exchange.FilterBy(currentTypeMarkets, "active", true)
        var activeSymbols interface{} = []interface{}{}
        for i := 0; IsLessThan(i, GetArrayLength(activeMarkets)); i++ {
            AppendToArray(&activeSymbols,GetValue(GetValue(activeMarkets, i), "symbol"))
        }
        symbol = this.GetTestSymbol(exchange, spot, activeSymbols)
    }
    if IsTrue(IsEqual(symbol, nil)) {
        var values interface{} = ObjectValues(currentTypeMarkets)
        var valuesLength interface{} =         GetArrayLength(values)
        if IsTrue(IsGreaterThan(valuesLength, 0)) {
            var first interface{} = GetValue(values, 0)
            if IsTrue(!IsEqual(first, nil)) {
                symbol = GetValue(first, "symbol")
            }
        }
    }
    return symbol
}
func  (this *testMainClass) TestExchange(exchange ccxt.IExchange, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    providedSymbol := GetArg(optionalArgs, 0, nil)
            _ = providedSymbol
            var spotSymbol interface{} = nil
            var swapSymbol interface{} = nil
            if IsTrue(!IsEqual(providedSymbol, nil)) {
                var market interface{} = exchange.Market(providedSymbol)
                if IsTrue(GetValue(market, "spot")) {
                    spotSymbol = providedSymbol
                } else {
                    swapSymbol = providedSymbol
                }
            } else {
                if IsTrue(GetValue(exchange.GetHas(), "spot")) {
                    spotSymbol = this.GetValidSymbol(exchange, true)
                }
                if IsTrue(GetValue(exchange.GetHas(), "swap")) {
                    swapSymbol = this.GetValidSymbol(exchange, false)
                }
            }
            if IsTrue(!IsEqual(spotSymbol, nil)) {
                Dump("[INFO:MAIN] Selected SPOT SYMBOL:", spotSymbol)
            }
            if IsTrue(!IsEqual(swapSymbol, nil)) {
                Dump("[INFO:MAIN] Selected SWAP SYMBOL:", swapSymbol)
            }
            if !IsTrue(this.PrivateTestOnly) {
                // note, spot & swap tests should run sequentially, because of conflicting `exchange.options['defaultType']` setting
                if IsTrue(IsTrue(GetValue(exchange.GetHas(), "spot")) && IsTrue(!IsEqual(spotSymbol, nil))) {
                    if IsTrue(this.Info) {
                        Dump("[INFO] ### SPOT TESTS ###")
                    }
                    AddElementToObject(exchange.GetOptions(), "defaultType", "spot")
        
                    retRes72616 := (<-this.RunPublicTests(exchange, spotSymbol))
                    PanicOnError(retRes72616)
                }
                if IsTrue(IsTrue(GetValue(exchange.GetHas(), "swap")) && IsTrue(!IsEqual(swapSymbol, nil))) {
                    if IsTrue(this.Info) {
                        Dump("[INFO] ### SWAP TESTS ###")
                    }
                    AddElementToObject(exchange.GetOptions(), "defaultType", "swap")
        
                    retRes73316 := (<-this.RunPublicTests(exchange, swapSymbol))
                    PanicOnError(retRes73316)
                }
            }
            if IsTrue(IsTrue(this.PrivateTest) || IsTrue(this.PrivateTestOnly)) {
                if IsTrue(IsTrue(GetValue(exchange.GetHas(), "spot")) && IsTrue(!IsEqual(spotSymbol, nil))) {
                    AddElementToObject(exchange.GetOptions(), "defaultType", "spot")
        
                    retRes73916 := (<-this.RunPrivateTests(exchange, spotSymbol))
                    PanicOnError(retRes73916)
                }
                if IsTrue(IsTrue(GetValue(exchange.GetHas(), "swap")) && IsTrue(!IsEqual(swapSymbol, nil))) {
                    AddElementToObject(exchange.GetOptions(), "defaultType", "swap")
        
                    retRes74316 := (<-this.RunPrivateTests(exchange, swapSymbol))
                    PanicOnError(retRes74316)
                }
            }
        
            ch <- true
            return nil
        
            }()
            return ch
        }
func  (this *testMainClass) RunPrivateTests(exchange ccxt.IExchange, symbol interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    if !IsTrue(exchange.CheckRequiredCredentials(false)) {
                Dump("[INFO] Skipping private tests", "Keys not found")
        
                ch <- true
                return nil
            }
            var code interface{} = this.GetExchangeCode(exchange)
            // if (exchange.GetdeepExtendedTest()) {
            //     await test ('InvalidNonce', exchange, symbol);
            //     await test ('OrderNotFound', exchange, symbol);
            //     await test ('InvalidOrder', exchange, symbol);
            //     await test ('InsufficientFunds', exchange, symbol, balance); // danger zone - won't execute with non-empty balance
            // }
            var tests interface{} = map[string]interface{} {
                "signIn": []interface{}{},
                "fetchBalance": []interface{}{},
                "fetchAccounts": []interface{}{},
                "fetchTransactionFees": []interface{}{},
                "fetchTradingFees": []interface{}{},
                "fetchStatus": []interface{}{},
                "fetchOrders": []interface{}{symbol},
                "fetchOpenOrders": []interface{}{symbol},
                "fetchClosedOrders": []interface{}{symbol},
                "fetchMyTrades": []interface{}{symbol},
                "fetchLeverageTiers": []interface{}{[]interface{}{symbol}},
                "fetchLedger": []interface{}{code},
                "fetchTransactions": []interface{}{code},
                "fetchDeposits": []interface{}{code},
                "fetchWithdrawals": []interface{}{code},
                "fetchBorrowInterest": []interface{}{code, symbol},
                "cancelAllOrders": []interface{}{symbol},
                "fetchCanceledOrders": []interface{}{symbol},
                "fetchMarginModes": []interface{}{symbol},
                "fetchPosition": []interface{}{symbol},
                "fetchDeposit": []interface{}{code},
                "createDepositAddress": []interface{}{code},
                "fetchDepositAddress": []interface{}{code},
                "fetchDepositAddresses": []interface{}{code},
                "fetchDepositAddressesByNetwork": []interface{}{code},
                "fetchBorrowRateHistory": []interface{}{code},
                "fetchLedgerEntry": []interface{}{code},
            }
            if IsTrue(GetCliArgValue("--fundedTests")) {
                AddElementToObject(tests, "createOrder", []interface{}{symbol})
            }
            if IsTrue(this.WsTests) {
                tests = map[string]interface{} {
                    "watchBalance": []interface{}{code},
                    "watchMyTrades": []interface{}{symbol},
                    "watchOrders": []interface{}{symbol},
                    "watchPosition": []interface{}{symbol},
                    "watchPositions": []interface{}{symbol},
                }
            }
            var market interface{} = exchange.Market(symbol)
            var isSpot interface{} = GetValue(market, "spot")
            if !IsTrue(this.WsTests) {
                if IsTrue(isSpot) {
                    AddElementToObject(tests, "fetchCurrencies", []interface{}{})
                } else {
                    // derivatives only
                    AddElementToObject(tests, "fetchPositions", []interface{}{symbol}) // this test fetches all positions for 1 symbol
                    AddElementToObject(tests, "fetchPosition", []interface{}{symbol})
                    AddElementToObject(tests, "fetchPositionRisk", []interface{}{symbol})
                    AddElementToObject(tests, "setPositionMode", []interface{}{symbol})
                    AddElementToObject(tests, "setMarginMode", []interface{}{symbol})
                    AddElementToObject(tests, "fetchOpenInterestHistory", []interface{}{symbol})
                    AddElementToObject(tests, "fetchFundingRateHistory", []interface{}{symbol})
                    AddElementToObject(tests, "fetchFundingHistory", []interface{}{symbol})
                }
            }
            // const combinedTests = exchange.GetdeepExtend() (this.publicTests, privateTests);
        
            retRes8368 := (<-this.RunTests(exchange, tests, false))
            PanicOnError(retRes8368)
        
            ch <- true  // required in c#
            return nil
        
            }()
            return ch
        }
func  (this *testMainClass) TestProxies(exchange ccxt.IExchange) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    // these tests should be synchronously executed, because of conflicting nature of proxy settings
            var proxyTestName interface{} = this.ProxyTestFileName
            // todo: temporary skip for sync py
            if IsTrue(IsTrue(IsEqual(this.Ext, "py")) && IsTrue(IsSync())) {
        
                ch <- true
                return nil
            }
            // try proxy several times
            var maxRetries interface{} = 3
            var exception interface{} = nil
            for j := 0; IsLessThan(j, maxRetries); j++ {
                
                {		ret__ := func(this *testMainClass) (ret_ interface{}) {
                		defer func() {
                			if e := recover(); e != nil {
                                if e == "break" {
                				    return
                			    }
                				ret_ = func(this *testMainClass) interface{} {
                					// catch block:
                                                exception = e
                
                            retRes85616 := (<-exchange.Sleep(Multiply(j, 1000)))
                            PanicOnError(retRes85616)
                                    return nil
                				}(this)
                			}
                		}()
                		// try block:
                        
                            retRes85216 := (<-this.TestMethod(proxyTestName, exchange, []interface{}{}, true))
                            PanicOnError(retRes85216)
                
                            ch <- true  // if successfull, then end the test
                            return nil
                		return nil
                	}(this)
                	if ret__ != nil {
                		return ret__
                	}
                }
            }
            // if exception was set, then throw it
            if IsTrue(!IsEqual(exception, nil)) {
                var errorMessage interface{} = Add(Add(Add("[TEST_FAILURE] Failed ", proxyTestName), " : "), ExceptionMessage(exception))
                // temporary comment the below, because c# transpilation failure
                // throw new Exchange Error (errorMessage.toString ());
                Dump(Add("[TEST_WARNING]", errorMessage))
            }
        
            ch <- true
            return nil
        
            }()
            return ch
        }
func  (this *testMainClass) CheckConstructor(exchange ccxt.IExchange)  {
    // todo: this might be moved in base tests later
    if IsTrue(IsEqual(exchange.GetId(), "binance")) {
        Assert(IsEqual(exchange.GetHostname(), nil), "binance.com hostname should be empty")
        Assert(IsEqual(GetValue(GetValue(exchange.GetUrls(), "api"), "public"), "https://api.binance.com/api/v3"), Add("https://api.binance.com/api/v3 does not match: ", GetValue(GetValue(exchange.GetUrls(), "api"), "public")))
        Assert((InOp(GetValue(GetValue(exchange.GetApi(), "sapi"), "get"), "lending/union/account")), Add("SAPI should contain the endpoint lending/union/account, ", JsonStringify(GetValue(GetValue(exchange.GetApi(), "sapi"), "get"))))
    } else if IsTrue(IsEqual(exchange.GetId(), "binanceus")) {
        Assert(IsEqual(exchange.GetHostname(), "binance.us"), Add("binance.us hostname does not match ", exchange.GetHostname()))
        Assert(IsEqual(GetValue(GetValue(exchange.GetUrls(), "api"), "public"), "https://api.binance.us/api/v3"), Add("https://api.binance.us/api/v3 does not match: ", GetValue(GetValue(exchange.GetUrls(), "api"), "public")))
    }
}
func  (this *testMainClass) StartTest(exchange ccxt.IExchange, symbol interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    // we do not need to test aliases
            if IsTrue(exchange.GetAlias()) {
        
                ch <- true
                return nil
            }
            this.CheckConstructor(exchange)
            if IsTrue(IsTrue(this.Sandbox) || IsTrue(GetExchangeProp(exchange, "sandbox"))) {
                exchange.SetSandboxMode(true)
            }
            
            {		ret__ := func(this *testMainClass) (ret_ interface{}) {
            		defer func() {
            			if e := recover(); e != nil {
                            if e == "break" {
            				    return
            			    }
            				ret_ = func(this *testMainClass) interface{} {
            					// catch block:
                                        if !IsTrue(IsSync()) {
            
                        retRes91016 := (<-Close(exchange))
                        PanicOnError(retRes91016)
                    }
                    panic(e)
                                return nil
            				}(this)
            			}
            		}()
            		// try block:
                    
                    result:= (<-this.LoadExchange(exchange))
                    PanicOnError(result)
                    if !IsTrue(result) {
                        if !IsTrue(IsSync()) {
            
                            retRes89620 := (<-Close(exchange))
                            PanicOnError(retRes89620)
                        }
            
                        ch <- true
                        return nil
                    }
                    // if (exchange.Setid(== 'binance') {)
                    //     // we test proxies functionality just for one random exchange on each build, because proxy functionality is not exchange-specific, instead it's all done from base methods, so just one working sample would mean it works for all ccxt exchanges
                    //     // await this.testProxies (exchange);
                    // }
            
                    retRes90412 := (<-this.TestExchange(exchange, symbol))
                    PanicOnError(retRes90412)
                    if !IsTrue(IsSync()) {
            
                        retRes90616 := (<-Close(exchange))
                        PanicOnError(retRes90616)
                    }
            		return nil
            	}(this)
            	if ret__ != nil {
            		return ret__
            	}
            }
        
            ch <- true  // required in c#
            return nil
        
            }()
            return ch
        }
func  (this *testMainClass) AssertStaticError(cond interface{}, message interface{}, calculatedOutput interface{}, storedOutput interface{}, optionalArgs ...interface{})  {
    //  -----------------------------------------------------------------------------
    //  --- Init of static tests functions------------------------------------------
    //  -----------------------------------------------------------------------------
    key := GetArg(optionalArgs, 0, nil)
    _ = key
    var calculatedString interface{} = JsonStringify(calculatedOutput)
    var storedString interface{} = JsonStringify(storedOutput)
    var errorMessage interface{} = message
    if IsTrue(!IsEqual(key, nil)) {
        errorMessage = Add(Add("[", key), "]")
    }
    errorMessage = Add(errorMessage, Add(Add(Add(" computed: ", storedString), " stored: "), calculatedString))
    Assert(cond, errorMessage)
}
func  (this *testMainClass) LoadMarketsFromFile(id interface{}) interface{}  {
    // load markets from file
    // to make this test as fast as possible
    // and basically independent from the exchange
    // so we can run it offline
    var filename interface{} = Add(Add(Add(GetRootDir(), "./ts/src/test/static/markets/"), id), ".json")
    var content interface{} = IoFileRead(filename)
    return content
}
func  (this *testMainClass) LoadCurrenciesFromFile(id interface{}) interface{}  {
    var filename interface{} = Add(Add(Add(GetRootDir(), "./ts/src/test/static/currencies/"), id), ".json")
    var content interface{} = IoFileRead(filename)
    return content
}
func  (this *testMainClass) LoadStaticData(folder interface{}, optionalArgs ...interface{}) interface{}  {
    targetExchange := GetArg(optionalArgs, 0, nil)
    _ = targetExchange
    var result interface{} = map[string]interface{} {}
    if IsTrue(targetExchange) {
        // read a single exchange
        var path interface{} = Add(Add(folder, targetExchange), ".json")
        if !IsTrue(IoFileExists(path)) {
            Dump(Add("[WARN] tests not found: ", path))
            return nil
        }
        AddElementToObject(result, targetExchange, IoFileRead(path))
        return result
    }
    var files interface{} = IoDirRead(folder)
    for i := 0; IsLessThan(i, GetArrayLength(files)); i++ {
        var file interface{} = GetValue(files, i)
        var exchangeName interface{} = Replace(file, ".json", "")
        var content interface{} = IoFileRead(Add(folder, file))
        AddElementToObject(result, exchangeName, content)
    }
    return result
}
func  (this *testMainClass) RemoveHostnamefromUrl(url interface{}) interface{}  {
    if IsTrue(IsEqual(url, nil)) {
        return nil
    }
    var urlParts interface{} = Split(url, "/")
    var res interface{} = ""
    for i := 0; IsLessThan(i, GetArrayLength(urlParts)); i++ {
        if IsTrue(IsGreaterThan(i, 2)) {
            var current interface{} = GetValue(urlParts, i)
            if IsTrue(IsGreaterThan(GetIndexOf(current, "?"), OpNeg(1))) {
                // handle urls like this: /v1/account/accounts?AccessK
                var currentParts interface{} = Split(current, "?")
                res = Add(res, "/")
                res = Add(res, GetValue(currentParts, 0))
                break
            }
            res = Add(res, "/")
            res = Add(res, current)
        }
    }
    return res
}
func  (this *testMainClass) UrlencodedToDict(url interface{}) interface{}  {
    var result interface{} = map[string]interface{} {}
    var parts interface{} = Split(url, "&")
    for i := 0; IsLessThan(i, GetArrayLength(parts)); i++ {
        var part interface{} = GetValue(parts, i)
        var keyValue interface{} = Split(part, "=")
        var keysLength interface{} =         GetArrayLength(keyValue)
        if IsTrue(!IsEqual(keysLength, 2)) {
            continue
        }
        var key interface{} = GetValue(keyValue, 0)
        var value interface{} = GetValue(keyValue, 1)
        if IsTrue(IsTrue((!IsEqual(value, nil))) && IsTrue((IsTrue((StartsWith(value, "["))) || IsTrue((StartsWith(value, "{")))))) {
            // some exchanges might return something like this: timestamp=1699382693405&batchOrders=[{\"symbol\":\"LTCUSDT\",\"side\":\"BUY\",\"newClientOrderI
            value = JsonParse(value)
        }
        AddElementToObject(result, key, value)
    }
    return result
}
func  (this *testMainClass) AssertNewAndStoredOutputInner(exchange ccxt.IExchange, skipKeys interface{}, newOutput interface{}, storedOutput interface{}, optionalArgs ...interface{}) interface{}  {
    strictTypeCheck := GetArg(optionalArgs, 0, true)
    _ = strictTypeCheck
    assertingKey := GetArg(optionalArgs, 1, nil)
    _ = assertingKey
    if IsTrue(IsTrue(IsNullValue(newOutput)) && IsTrue(IsNullValue(storedOutput))) {
        return true
    }
    if IsTrue(!IsTrue(newOutput) && !IsTrue(storedOutput)) {
        return true
    }
    if IsTrue(IsTrue((IsObject(storedOutput))) && IsTrue((IsObject(newOutput)))) {
        var storedOutputKeys interface{} = ObjectKeys(storedOutput)
        var newOutputKeys interface{} = ObjectKeys(newOutput)
        var storedKeysLength interface{} =         GetArrayLength(storedOutputKeys)
        var newKeysLength interface{} =         GetArrayLength(newOutputKeys)
        this.AssertStaticError(IsEqual(storedKeysLength, newKeysLength), "output length mismatch", storedOutput, newOutput)
        // iterate over the keys
        for i := 0; IsLessThan(i, GetArrayLength(storedOutputKeys)); i++ {
            var key interface{} = GetValue(storedOutputKeys, i)
            if IsTrue(exchange.InArray(key, skipKeys)) {
                continue
            }
            if !IsTrue((exchange.InArray(key, newOutputKeys))) {
                this.AssertStaticError(false, Add("output key missing: ", key), storedOutput, newOutput)
            }
            var storedValue interface{} = GetValue(storedOutput, key)
            var newValue interface{} = GetValue(newOutput, key)
            this.AssertNewAndStoredOutput(exchange, skipKeys, newValue, storedValue, strictTypeCheck, key)
        }
    } else if IsTrue(IsTrue(IsArray(storedOutput)) && IsTrue((IsArray(newOutput)))) {
        var storedArrayLength interface{} =         GetArrayLength(storedOutput)
        var newArrayLength interface{} =         GetArrayLength(newOutput)
        this.AssertStaticError(IsEqual(storedArrayLength, newArrayLength), "output length mismatch", storedOutput, newOutput)
        for i := 0; IsLessThan(i, GetArrayLength(storedOutput)); i++ {
            var storedItem interface{} = GetValue(storedOutput, i)
            var newItem interface{} = GetValue(newOutput, i)
            this.AssertNewAndStoredOutput(exchange, skipKeys, newItem, storedItem, strictTypeCheck)
        }
    } else {
        // built-in types like strings, numbers, booleans
        var sanitizedNewOutput interface{} = Ternary(IsTrue((!IsTrue(newOutput))), nil, newOutput) // we store undefined as nulls in the json file so we need to convert it back
        var sanitizedStoredOutput interface{} = Ternary(IsTrue((!IsTrue(storedOutput))), nil, storedOutput)
        var newOutputString interface{} = Ternary(IsTrue(sanitizedNewOutput), ToString(sanitizedNewOutput), "undefined")
        var storedOutputString interface{} = Ternary(IsTrue(sanitizedStoredOutput), ToString(sanitizedStoredOutput), "undefined")
        var messageError interface{} = Add(Add(Add("output value mismatch:", newOutputString), " != "), storedOutputString)
        if IsTrue(IsTrue(strictTypeCheck) && IsTrue((!IsEqual(this.Lang, "C#")))) {
            // upon building the request we want strict type check to make sure all the types are correct
            // when comparing the response we want to allow some flexibility, because a 50.0 can be equal to 50 after saving it to the json file
            this.AssertStaticError(IsEqual(sanitizedNewOutput, sanitizedStoredOutput), messageError, storedOutput, newOutput, assertingKey)
        } else {
            var isComputedBool interface{} =             (IsBool(sanitizedNewOutput))
            var isStoredBool interface{} =             (IsBool(sanitizedStoredOutput))
            var isComputedString interface{} =             (IsString(sanitizedNewOutput))
            var isStoredString interface{} =             (IsString(sanitizedStoredOutput))
            var isComputedUndefined interface{} =             (IsEqual(sanitizedNewOutput, nil))
            var isStoredUndefined interface{} =             (IsEqual(sanitizedStoredOutput, nil))
            var shouldBeSame interface{} = IsTrue(IsTrue((IsEqual(isComputedBool, isStoredBool))) && IsTrue((IsEqual(isComputedString, isStoredString)))) && IsTrue((IsEqual(isComputedUndefined, isStoredUndefined)))
            this.AssertStaticError(shouldBeSame, "output type mismatch", storedOutput, newOutput, assertingKey)
            var isBoolean interface{} = IsTrue(isComputedBool) || IsTrue(isStoredBool)
            var isString interface{} = IsTrue(isComputedString) || IsTrue(isStoredString)
            var isUndefined interface{} = IsTrue(isComputedUndefined) || IsTrue(isStoredUndefined) // undefined is a perfetly valid value
            if IsTrue(IsTrue(IsTrue(isBoolean) || IsTrue(isString)) || IsTrue(isUndefined)) {
                if IsTrue(IsEqual(this.Lang, "C#")) {
                    // tmp c# number comparsion
                    var isNumber interface{} = false
                    
                    {		ret__ := func(this *testMainClass) (ret_ interface{}) {
                    		defer func() {
                    			if e := recover(); e != nil {
                                    if e == "break" {
                    				    return
                    			    }
                    				ret_ = func(this *testMainClass) interface{} {
                    					// catch block:
                                                                // if we can't parse it to number, then it's not a number
                                            isNumber = false
                                        return nil
                    				}(this)
                    			}
                    		}()
                    		// try block:
                                                    exchange.ParseToNumeric(sanitizedNewOutput)
                                            isNumber = true
                    		return nil
                    	}(this)
                    	if ret__ != nil {
                    		return ret__
                    	}
                    }
                    if IsTrue(isNumber) {
                        this.AssertStaticError(IsEqual(exchange.ParseToNumeric(sanitizedNewOutput), exchange.ParseToNumeric(sanitizedStoredOutput)), messageError, storedOutput, newOutput, assertingKey)
                        return true
                    } else {
                        this.AssertStaticError(IsEqual(ConvertAscii(newOutputString), ConvertAscii(storedOutputString)), messageError, storedOutput, newOutput, assertingKey)
                        return true
                    }
                } else {
                    this.AssertStaticError(IsEqual(ConvertAscii(newOutputString), ConvertAscii(storedOutputString)), messageError, storedOutput, newOutput, assertingKey)
                    return true
                }
            } else {
                if IsTrue(IsEqual(this.Lang, "C#")) {
                    var stringifiedNewOutput interface{} = exchange.NumberToString(sanitizedNewOutput)
                    var stringifiedStoredOutput interface{} = exchange.NumberToString(sanitizedStoredOutput)
                    this.AssertStaticError(IsEqual(ToString(stringifiedNewOutput), ToString(stringifiedStoredOutput)), messageError, storedOutput, newOutput, assertingKey)
                } else {
                    var numericNewOutput interface{} = exchange.ParseToNumeric(newOutputString)
                    var numericStoredOutput interface{} = exchange.ParseToNumeric(storedOutputString)
                    this.AssertStaticError(IsEqual(numericNewOutput, numericStoredOutput), messageError, storedOutput, newOutput, assertingKey)
                }
            }
        }
    }
    return true  // c# requ
}
func  (this *testMainClass) AssertNewAndStoredOutput(exchange ccxt.IExchange, skipKeys interface{}, newOutput interface{}, storedOutput interface{}, optionalArgs ...interface{}) interface{}  {
    strictTypeCheck := GetArg(optionalArgs, 0, true)
    _ = strictTypeCheck
    assertingKey := GetArg(optionalArgs, 1, nil)
    _ = assertingKey
    var res interface{} = true
    
    {		ret__ := func(this *testMainClass) (ret_ interface{}) {
    		defer func() {
    			if e := recover(); e != nil {
                    if e == "break" {
    				    return
    			    }
    				ret_ = func(this *testMainClass) interface{} {
    					// catch block:
                                if IsTrue(this.Info) {
                var errorMessage interface{} = Add(Add(Add(Add(this.VarToString(newOutput), "(calculated)"), " != "), this.VarToString(storedOutput)), "(stored)")
                Dump(Add("[TEST_FAILURE_DETAIL]", errorMessage))
            }
            panic(e)
                        return nil
    				}(this)
    			}
    		}()
    		// try block:
                    res = this.AssertNewAndStoredOutputInner(exchange, skipKeys, newOutput, storedOutput, strictTypeCheck, assertingKey)
    		return nil
    	}(this)
    	if ret__ != nil {
    		return ret__
    	}
    }
    return res
}
func  (this *testMainClass) VarToString(optionalArgs ...interface{}) interface{}  {
    obj := GetArg(optionalArgs, 0, nil)
    _ = obj
    var newString interface{} = nil
    if IsTrue(IsEqual(obj, nil)) {
        newString = "undefined"
    } else if IsTrue(IsNullValue(obj)) {
        newString = "null"
    } else {
        newString = JsonStringify(obj)
    }
    return newString
}
func  (this *testMainClass) AssertStaticRequestOutput(exchange ccxt.IExchange, typeVar interface{}, skipKeys interface{}, storedUrl interface{}, requestUrl interface{}, storedOutput interface{}, newOutput interface{}) interface{}  {
    if IsTrue(!IsEqual(storedUrl, requestUrl)) {
        // remove the host part from the url
        var firstPath interface{} = this.RemoveHostnamefromUrl(storedUrl)
        var secondPath interface{} = this.RemoveHostnamefromUrl(requestUrl)
        this.AssertStaticError(IsEqual(firstPath, secondPath), "url mismatch", firstPath, secondPath)
    }
    // body (aka storedOutput and newOutput) is not defined and information is in the url
    // example: "https://open-api.bingx.com/openApi/spot/v1/trade/order?quoteOrderQty=5&side=BUY&symbol=LTC-USDT&timestamp=1698777135343&type=MARKET&signature=d55a7e4f7f9dbe56c4004c9f3ab340869d3cb004e2f0b5b861e5fbd1762fd9a0
    if IsTrue(IsTrue((IsEqual(storedOutput, nil))) && IsTrue((IsEqual(newOutput, nil)))) {
        if IsTrue(IsTrue((!IsEqual(storedUrl, nil))) && IsTrue((!IsEqual(requestUrl, nil)))) {
            var storedUrlParts interface{} = Split(storedUrl, "?")
            var newUrlParts interface{} = Split(requestUrl, "?")
            var storedUrlQuery interface{} = exchange.SafeValue(storedUrlParts, 1)
            var newUrlQuery interface{} = exchange.SafeValue(newUrlParts, 1)
            if IsTrue(IsTrue((IsEqual(storedUrlQuery, nil))) && IsTrue((IsEqual(newUrlQuery, nil)))) {
                // might be a get request without any query parameters
                // example: https://api.gateio.ws/api/v4/delivery/usdt/positions
                return true
            }
            var storedUrlParams interface{} = this.UrlencodedToDict(storedUrlQuery)
            var newUrlParams interface{} = this.UrlencodedToDict(newUrlQuery)
            this.AssertNewAndStoredOutput(exchange, skipKeys, newUrlParams, storedUrlParams)
            return true
        }
    }
    if IsTrue(IsTrue(IsTrue(IsEqual(typeVar, "json")) && IsTrue((!IsEqual(storedOutput, nil)))) && IsTrue((!IsEqual(newOutput, nil)))) {
        if IsTrue(IsString(storedOutput)) {
            storedOutput = JsonParse(storedOutput)
        }
        if IsTrue(IsString(newOutput)) {
            newOutput = JsonParse(newOutput)
        }
    } else if IsTrue(IsTrue(IsTrue(IsEqual(typeVar, "urlencoded")) && IsTrue((!IsEqual(storedOutput, nil)))) && IsTrue((!IsEqual(newOutput, nil)))) {
        storedOutput = this.UrlencodedToDict(storedOutput)
        newOutput = this.UrlencodedToDict(newOutput)
    } else if IsTrue(IsEqual(typeVar, "both")) {
        if IsTrue(IsTrue(StartsWith(storedOutput, "{")) || IsTrue(StartsWith(storedOutput, "["))) {
            storedOutput = JsonParse(storedOutput)
            newOutput = JsonParse(newOutput)
        } else {
            storedOutput = this.UrlencodedToDict(storedOutput)
            newOutput = this.UrlencodedToDict(newOutput)
        }
    }
    this.AssertNewAndStoredOutput(exchange, skipKeys, newOutput, storedOutput)
    return true
}
func  (this *testMainClass) AssertStaticResponseOutput(exchange ccxt.IExchange, skipKeys interface{}, computedResult interface{}, storedResult interface{})  {
    this.AssertNewAndStoredOutput(exchange, skipKeys, computedResult, storedResult, false)
}
func  (this *testMainClass) SanitizeDataInput(input interface{}) interface{}  {
    // remove nulls and replace with unefined instead
    if IsTrue(IsEqual(input, nil)) {
        return nil
    }
    var newInput interface{} = []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(input)); i++ {
        var current interface{} = GetValue(input, i)
        if IsTrue(IsNullValue(current)) {
            AppendToArray(&newInput,nil)
        } else {
            AppendToArray(&newInput,current)
        }
    }
    return newInput
}
func  (this *testMainClass) TestRequestStatically(exchange ccxt.IExchange, method interface{}, data interface{}, typeVar interface{}, skipKeys interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    var output interface{} = nil
            var requestUrl interface{} = nil
            
            {		ret__ := func(this *testMainClass) (ret_ interface{}) {
            		defer func() {
            			if e := recover(); e != nil {
                            if e == "break" {
            				    return
            			    }
            				ret_ = func(this *testMainClass) interface{} {
            					// catch block:
                                        if !IsTrue((IsInstance(e, InvalidProxySettings))) {
                        panic(e)
                    }
                    output = exchange.GetLast_request_body()
                    requestUrl = exchange.GetLast_request_url()
                                return nil
            				}(this)
            			}
            		}()
            		// try block:
                            if !IsTrue(IsSync()) {
            
                        retRes121416 := (<-CallExchangeMethodDynamically(exchange, method, this.SanitizeDataInput(GetValue(data, "input"))))
                        PanicOnError(retRes121416)
                    } else {
                        CallExchangeMethodDynamicallySync(exchange, method, this.SanitizeDataInput(GetValue(data, "input")))
                    }
            		return nil
            	}(this)
            	if ret__ != nil {
            		return ret__
            	}
            }
            
            {		ret__ := func(this *testMainClass) (ret_ interface{}) {
            		defer func() {
            			if e := recover(); e != nil {
                            if e == "break" {
            				    return
            			    }
            				ret_ = func(this *testMainClass) interface{} {
            					// catch block:
                                        this.RequestTestsFailed = true
                    var errorMessage interface{} = Add(Add(Add(Add(Add(Add(Add(Add(Add(Add(Add(Add("[", this.Lang), "][STATIC_REQUEST]"), "["), exchange.GetId()), "]"), "["), method), "]"), "["), GetValue(data, "description")), "]"), ExceptionMessage(e))
                    Dump(Add("[TEST_FAILURE]", errorMessage))
                                return nil
            				}(this)
            			}
            		}()
            		// try block:
                            var callOutput interface{} = exchange.SafeValue(data, "output")
                    this.AssertStaticRequestOutput(exchange, typeVar, skipKeys, GetValue(data, "url"), requestUrl, callOutput, output)
            		return nil
            	}(this)
            	if ret__ != nil {
            		return ret__
            	}
            }
        
            ch <- true
            return nil
        
            }()
            return ch
        }
func  (this *testMainClass) TestResponseStatically(exchange ccxt.IExchange, method interface{}, skipKeys interface{}, data interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    var expectedResult interface{} = exchange.SafeValue(data, "parsedResponse")
            var mockedExchange ccxt.IExchange = SetFetchResponse(exchange, GetValue(data, "httpResponse"))
            
            {		ret__ := func(this *testMainClass) (ret_ interface{}) {
            		defer func() {
            			if e := recover(); e != nil {
                            if e == "break" {
            				    return
            			    }
            				ret_ = func(this *testMainClass) interface{} {
            					// catch block:
                                        this.ResponseTestsFailed = true
                    var errorMessage interface{} = Add(Add(Add(Add(Add(Add(Add(Add(Add(Add(Add(Add("[", this.Lang), "][STATIC_RESPONSE]"), "["), exchange.GetId()), "]"), "["), method), "]"), "["), GetValue(data, "description")), "]"), ExceptionMessage(e))
                    Dump(Add("[TEST_FAILURE]", errorMessage))
                                return nil
            				}(this)
            			}
            		}()
            		// try block:
                            if !IsTrue(IsSync()) {
            
                        unifiedResult:= (<-CallExchangeMethodDynamically(exchange, method, this.SanitizeDataInput(GetValue(data, "input"))))
                        PanicOnError(unifiedResult)
                        this.AssertStaticResponseOutput(mockedExchange, skipKeys, unifiedResult, expectedResult)
                    } else {
                        var unifiedResultSync interface{} = CallExchangeMethodDynamicallySync(exchange, method, this.SanitizeDataInput(GetValue(data, "input")))
                        this.AssertStaticResponseOutput(mockedExchange, skipKeys, unifiedResultSync, expectedResult)
                    }
            		return nil
            	}(this)
            	if ret__ != nil {
            		return ret__
            	}
            }
            SetFetchResponse(exchange, nil) // reset state
        
            ch <- true
            return nil
        
            }()
            return ch
        }
func  (this *testMainClass) InitOfflineExchange(exchangeName interface{}) ccxt.IExchange {
    var markets interface{} = this.LoadMarketsFromFile(exchangeName)
    var currencies interface{} = this.LoadCurrenciesFromFile(exchangeName)
    var exchange ccxt.IExchange = InitExchange(exchangeName, map[string]interface{} {
        "markets": markets,
        "currencies": currencies,
        "enableRateLimit": false,
        "rateLimit": 1,
        "httpProxy": "http://fake:8080",
        "httpsProxy": "http://fake:8080",
        "apiKey": "key",
        "secret": "secretsecret",
        "password": "password",
        "walletAddress": "wallet",
        "privateKey": "0xff3bdd43534543d421f05aec535965b5050ad6ac15345435345435453495e771",
        "uid": "uid",
        "token": "token",
        "login": "login",
        "accountId": "accountId",
        "accounts": []interface{}{map[string]interface{} {
    "id": "myAccount",
    "code": "USDT",
}, map[string]interface{} {
    "id": "myAccount",
    "code": "USDC",
}},
        "options": map[string]interface{} {
            "enableUnifiedAccount": true,
            "enableUnifiedMargin": false,
            "accessToken": "token",
            "expires": 999999999999999,
            "leverageBrackets": map[string]interface{} {},
        },
    })
    exchange.SetCurrencies(currencies)
    // not working in python if assigned  in the config dict
    return exchange
}
func  (this *testMainClass) TestExchangeRequestStatically(exchangeName interface{}, exchangeData interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    // instantiate the exchange and make sure that we sink the requests to avoid an actual request
            testName := GetArg(optionalArgs, 0, nil)
            _ = testName
            var exchange ccxt.IExchange = this.InitOfflineExchange(exchangeName)
            var globalOptions interface{} = exchange.SafeDict(exchangeData, "options", map[string]interface{} {})
            // read apiKey/secret from the test file
            var apiKey interface{} = exchange.SafeString(exchangeData, "apiKey")
            if IsTrue(apiKey) {
                // c# to string requirement
                exchange.SetApiKey(ToString(apiKey))
            }
            var secret interface{} = exchange.SafeString(exchangeData, "secret")
            if IsTrue(secret) {
                // c# to string requirement
                exchange.SetSecret(ToString(secret))
            }
            var privateKey interface{} = exchange.SafeString(exchangeData, "privateKey")
            if IsTrue(privateKey) {
                // c# to string requirement
                exchange.SetPrivateKey(ToString(privateKey))
            }
            var walletAddress interface{} = exchange.SafeString(exchangeData, "walletAddress")
            if IsTrue(walletAddress) {
                // c# to string requirement
                exchange.SetWalletAddress(ToString(walletAddress))
            }
            var accounts interface{} = exchange.SafeList(exchangeData, "accounts")
            if IsTrue(accounts) {
                exchange.SetAccounts(accounts)
            }
            // exchange.Setoptions(exchange.GetdeepExtend() (exchange.Getoptions(), globalOptions); // custom options to be used in the tests)
            exchange.ExtendExchangeOptions(globalOptions)
            var methods interface{} = exchange.SafeValue(exchangeData, "methods", map[string]interface{} {})
            var methodsNames interface{} = ObjectKeys(methods)
            for i := 0; IsLessThan(i, GetArrayLength(methodsNames)); i++ {
                var method interface{} = GetValue(methodsNames, i)
                var results interface{} = GetValue(methods, method)
                for j := 0; IsLessThan(j, GetArrayLength(results)); j++ {
                    var result interface{} = GetValue(results, j)
                    var oldExchangeOptions interface{} = exchange.GetOptions() // snapshot options;
                    var testExchangeOptions interface{} = exchange.SafeValue(result, "options", map[string]interface{} {})
                    // exchange.Setoptions(exchange.GetdeepExtend() (oldExchangeOptions, testExchangeOptions); // custom options to be used in the tests)
                    exchange.ExtendExchangeOptions(exchange.DeepExtend(oldExchangeOptions, testExchangeOptions))
                    var description interface{} = exchange.SafeValue(result, "description")
                    if IsTrue(IsTrue((!IsEqual(testName, nil))) && IsTrue((!IsEqual(testName, description)))) {
                        continue
                    }
                    var isDisabled interface{} = exchange.SafeBool(result, "disabled", false)
                    if IsTrue(isDisabled) {
                        continue
                    }
                    var disabledString interface{} = exchange.SafeString(result, "disabled", "")
                    if IsTrue(!IsEqual(disabledString, "")) {
                        continue
                    }
                    var isDisabledCSharp interface{} = exchange.SafeBool(result, "disabledCS", false)
                    if IsTrue(IsTrue(isDisabledCSharp) && IsTrue((IsEqual(this.Lang, "C#")))) {
                        continue
                    }
                    var isDisabledGo interface{} = exchange.SafeBool(result, "disabledGO", false)
                    if IsTrue(IsTrue(isDisabledGo) && IsTrue((IsEqual(this.Lang, "GO")))) {
                        continue
                    }
                    var typeVar interface{} = exchange.SafeString(exchangeData, "outputType")
                    var skipKeys interface{} = exchange.SafeValue(exchangeData, "skipKeys", []interface{}{})
        
                    retRes133416 := (<-this.TestRequestStatically(exchange, method, result, typeVar, skipKeys))
                    PanicOnError(retRes133416)
                    // reset options
                    // exchange.Setoptions(exchange.GetdeepExtend() (oldExchangeOptions, {});)
                    exchange.ExtendExchangeOptions(exchange.DeepExtend(oldExchangeOptions, map[string]interface{} {}))
                }
            }
            if !IsTrue(IsSync()) {
        
                retRes134112 := (<-Close(exchange))
                PanicOnError(retRes134112)
            }
        
            ch <- true  // in c# methods that will be used with promiseAll need to return something
            return nil
        
            }()
            return ch
        }
func  (this *testMainClass) TestExchangeResponseStatically(exchangeName interface{}, exchangeData interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    testName := GetArg(optionalArgs, 0, nil)
            _ = testName
            var exchange ccxt.IExchange = this.InitOfflineExchange(exchangeName)
            // read apiKey/secret from the test file
            var apiKey interface{} = exchange.SafeString(exchangeData, "apiKey")
            if IsTrue(apiKey) {
                // c# to string requirement
                exchange.SetApiKey(ToString(apiKey))
            }
            var secret interface{} = exchange.SafeString(exchangeData, "secret")
            if IsTrue(secret) {
                // c# to string requirement
                exchange.SetSecret(ToString(secret))
            }
            var privateKey interface{} = exchange.SafeString(exchangeData, "privateKey")
            if IsTrue(privateKey) {
                // c# to string requirement
                exchange.SetPrivateKey(ToString(privateKey))
            }
            var walletAddress interface{} = exchange.SafeString(exchangeData, "walletAddress")
            if IsTrue(walletAddress) {
                // c# to string requirement
                exchange.SetWalletAddress(ToString(walletAddress))
            }
            var methods interface{} = exchange.SafeValue(exchangeData, "methods", map[string]interface{} {})
            var options interface{} = exchange.SafeValue(exchangeData, "options", map[string]interface{} {})
            // exchange.Setoptions(exchange.GetdeepExtend() (exchange.Getoptions(), options); // custom options to be used in the tests)
            exchange.ExtendExchangeOptions(options)
            var methodsNames interface{} = ObjectKeys(methods)
            for i := 0; IsLessThan(i, GetArrayLength(methodsNames)); i++ {
                var method interface{} = GetValue(methodsNames, i)
                var results interface{} = GetValue(methods, method)
                for j := 0; IsLessThan(j, GetArrayLength(results)); j++ {
                    var result interface{} = GetValue(results, j)
                    var description interface{} = exchange.SafeValue(result, "description")
                    var oldExchangeOptions interface{} = exchange.GetOptions() // snapshot options;
                    var testExchangeOptions interface{} = exchange.SafeValue(result, "options", map[string]interface{} {})
                    // exchange.Setoptions(exchange.GetdeepExtend() (oldExchangeOptions, testExchangeOptions); // custom options to be used in the tests)
                    exchange.ExtendExchangeOptions(exchange.DeepExtend(oldExchangeOptions, testExchangeOptions))
                    var isDisabled interface{} = exchange.SafeBool(result, "disabled", false)
                    if IsTrue(isDisabled) {
                        continue
                    }
                    var isDisabledCSharp interface{} = exchange.SafeBool(result, "disabledCS", false)
                    if IsTrue(IsTrue(isDisabledCSharp) && IsTrue((IsEqual(this.Lang, "C#")))) {
                        continue
                    }
                    var isDisabledPHP interface{} = exchange.SafeBool(result, "disabledPHP", false)
                    if IsTrue(IsTrue(isDisabledPHP) && IsTrue((IsEqual(this.Lang, "PHP")))) {
                        continue
                    }
                    if IsTrue(IsTrue((!IsEqual(testName, nil))) && IsTrue((!IsEqual(testName, description)))) {
                        continue
                    }
                    var isDisabledGO interface{} = exchange.SafeBool(result, "disabledGO", false)
                    if IsTrue(IsTrue(isDisabledGO) && IsTrue((IsEqual(this.Lang, "GO")))) {
                        continue
                    }
                    var skipKeys interface{} = exchange.SafeValue(exchangeData, "skipKeys", []interface{}{})
        
                    retRes140516 := (<-this.TestResponseStatically(exchange, method, skipKeys, result))
                    PanicOnError(retRes140516)
                    // reset options
                    // exchange.Setoptions(exchange.GetdeepExtend() (oldExchangeOptions, {});)
                    exchange.ExtendExchangeOptions(exchange.DeepExtend(oldExchangeOptions, map[string]interface{} {}))
                }
            }
            if !IsTrue(IsSync()) {
        
                retRes141212 := (<-Close(exchange))
                PanicOnError(retRes141212)
            }
        
            ch <- true  // in c# methods that will be used with promiseAll need to return something
            return nil
        
            }()
            return ch
        }
func  (this *testMainClass) GetNumberOfTestsFromExchange(exchange ccxt.IExchange, exchangeData interface{}, optionalArgs ...interface{}) interface{}  {
    testName := GetArg(optionalArgs, 0, nil)
    _ = testName
    if IsTrue(!IsEqual(testName, nil)) {
        return 1
    }
    var sum interface{} = 0
    var methods interface{} = GetValue(exchangeData, "methods")
    var methodsNames interface{} = ObjectKeys(methods)
    for i := 0; IsLessThan(i, GetArrayLength(methodsNames)); i++ {
        var method interface{} = GetValue(methodsNames, i)
        var results interface{} = GetValue(methods, method)
        var resultsLength interface{} =         GetArrayLength(results)
        sum = exchange.Sum(sum, resultsLength)
    }
    return sum
}
func  (this *testMainClass) RunStaticRequestTests(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    targetExchange := GetArg(optionalArgs, 0, nil)
            _ = targetExchange
            testName := GetArg(optionalArgs, 1, nil)
            _ = testName
        
            retRes14348 := (<-this.RunStaticTests("request", targetExchange, testName))
            PanicOnError(retRes14348)
        
            ch <- true
            return nil
        
            }()
            return ch
        }
func  (this *testMainClass) RunStaticTests(typeVar interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    targetExchange := GetArg(optionalArgs, 0, nil)
            _ = targetExchange
            testName := GetArg(optionalArgs, 1, nil)
            _ = testName
            var folder interface{} = Add(Add(Add(GetRootDir(), "./ts/src/test/static/"), typeVar), "/")
            var staticData interface{} = this.LoadStaticData(folder, targetExchange)
            if IsTrue(IsEqual(staticData, nil)) {
        
                ch <- true
                return nil
            }
            var exchanges interface{} = ObjectKeys(staticData)
            var exchange ccxt.IExchange = InitExchange("Exchange", map[string]interface{} {}) // tmp to do the calculations until we have the ast-transpiler transpiling this code
            var promises interface{} = []interface{}{}
            var sum interface{} = 0
            if IsTrue(targetExchange) {
                Dump(Add("[INFO:MAIN] Exchange to test: ", targetExchange))
            }
            if IsTrue(testName) {
                Dump(Add("[INFO:MAIN] Testing only: ", testName))
            }
            for i := 0; IsLessThan(i, GetArrayLength(exchanges)); i++ {
                var exchangeName interface{} = GetValue(exchanges, i)
                var exchangeData interface{} = GetValue(staticData, exchangeName)
                var numberOfTests interface{} = this.GetNumberOfTestsFromExchange(exchange, exchangeData, testName)
                sum = exchange.Sum(sum, numberOfTests)
                if IsTrue(IsEqual(typeVar, "request")) {
                    AppendToArray(&promises,this.TestExchangeRequestStatically(exchangeName, exchangeData, testName))
                } else {
                    AppendToArray(&promises,this.TestExchangeResponseStatically(exchangeName, exchangeData, testName))
                }
            }
            
            {		ret__ := func(this *testMainClass) (ret_ interface{}) {
            		defer func() {
            			if e := recover(); e != nil {
                            if e == "break" {
            				    return
            			    }
            				ret_ = func(this *testMainClass) interface{} {
            					// catch block:
                                        if IsTrue(IsEqual(typeVar, "request")) {
                        this.RequestTestsFailed = true
                    } else {
                        this.ResponseTestsFailed = true
                    }
                    var errorMessage interface{} = Add(Add(Add("[", this.Lang), "][STATIC_REQUEST]"), ExceptionMessage(e))
                    Dump(Add("[TEST_FAILURE]", errorMessage))
                                return nil
            				}(this)
            			}
            		}()
            		// try block:
                    
                    retRes146612 := (<-promiseAll(promises))
                    PanicOnError(retRes146612)
            		return nil
            	}(this)
            	if ret__ != nil {
            		return ret__
            	}
            }
            if IsTrue(IsTrue(this.RequestTestsFailed) || IsTrue(this.ResponseTestsFailed)) {
                ExitScript(1)
            } else {
                var prefix interface{} = Ternary(IsTrue((IsSync())), "[SYNC]", "")
                var successMessage interface{} = Add(Add(Add(Add(Add(Add(Add(Add("[", this.Lang), "]"), prefix), "[TEST_SUCCESS] "), ToString(sum)), " static "), typeVar), " tests passed.")
                Dump(Add("[INFO]", successMessage))
            }
        
            ch <- true  // required in c#
            return nil
        
            }()
            return ch
        }
func  (this *testMainClass) RunStaticResponseTests(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    //  -----------------------------------------------------------------------------
            //  --- Init of mockResponses tests functions------------------------------------
            //  -----------------------------------------------------------------------------
            exchangeName := GetArg(optionalArgs, 0, nil)
            _ = exchangeName
            test := GetArg(optionalArgs, 1, nil)
            _ = test
        
            retRes14908 := (<-this.RunStaticTests("response", exchangeName, test))
            PanicOnError(retRes14908)
        
            ch <- true
            return nil
        
            }()
            return ch
        }
func  (this *testMainClass) RunBrokerIdTests() <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                //  -----------------------------------------------------------------------------
        //  --- Init of brokerId tests functions-----------------------------------------
        //  -----------------------------------------------------------------------------
        var promises interface{} = []interface{}{this.TestBinance(), this.TestOkx(), this.TestCryptocom(), this.TestBybit(), this.TestKucoin(), this.TestKucoinfutures(), this.TestBitget(), this.TestMexc(), this.TestHtx(), this.TestWoo(), this.TestBitmart(), this.TestCoinex(), this.TestBingx(), this.TestPhemex(), this.TestBlofin(), this.TestHyperliquid(), this.TestCoinbaseinternational(), this.TestCoinbaseAdvanced(), this.TestWoofiPro(), this.TestOxfun(), this.TestXT(), this.TestVertex(), this.TestParadex(), this.TestHashkey(), this.TestCoincatch(), this.TestDefx()}
        
        retRes15268 := (<-promiseAll(promises))
        PanicOnError(retRes15268)
        var successMessage interface{} = Add(Add("[", this.Lang), "][TEST_SUCCESS] brokerId tests passed.")
        Dump(Add("[INFO]", successMessage))
        ExitScript(0)
        
        ch <- true
        return nil
        
            }()
            return ch
        }
func  (this *testMainClass) TestBinance() <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                var exchange ccxt.IExchange = this.InitOfflineExchange("binance")
        var spotId interface{} = "x-R4BD3S82"
        var spotOrderRequest interface{} = nil
        
        {		ret__ := func(this *testMainClass) (ret_ interface{}) {
        		defer func() {
        			if e := recover(); e != nil {
                        if e == "break" {
        				    return
        			    }
        				ret_ = func(this *testMainClass) interface{} {
        					// catch block:
                                spotOrderRequest = this.UrlencodedToDict(exchange.GetLast_request_body())
                            return nil
        				}(this)
        			}
        		}()
        		// try block:
                
            retRes153812 := (<-exchange.CreateOrder("BTC/USDT", "limit", "buy", 1, 20000))
            PanicOnError(retRes153812)
        		return nil
        	}(this)
        	if ret__ != nil {
        		return ret__
        	}
        }
        var clientOrderId interface{} = GetValue(spotOrderRequest, "newClientOrderId")
        var spotIdString interface{} = ToString(spotId)
        Assert(StartsWith(clientOrderId, spotIdString), Add(Add(Add("binance - spot clientOrderId: ", clientOrderId), " does not start with spotId"), spotIdString))
        var swapId interface{} = "x-xcKtGhcu"
        var swapOrderRequest interface{} = nil
        
        {		ret__ := func(this *testMainClass) (ret_ interface{}) {
        		defer func() {
        			if e := recover(); e != nil {
                        if e == "break" {
        				    return
        			    }
        				ret_ = func(this *testMainClass) interface{} {
        					// catch block:
                                swapOrderRequest = this.UrlencodedToDict(exchange.GetLast_request_body())
                            return nil
        				}(this)
        			}
        		}()
        		// try block:
                
            retRes154812 := (<-exchange.CreateOrder("BTC/USDT:USDT", "limit", "buy", 1, 20000))
            PanicOnError(retRes154812)
        		return nil
        	}(this)
        	if ret__ != nil {
        		return ret__
        	}
        }
        var swapInverseOrderRequest interface{} = nil
        
        {		ret__ := func(this *testMainClass) (ret_ interface{}) {
        		defer func() {
        			if e := recover(); e != nil {
                        if e == "break" {
        				    return
        			    }
        				ret_ = func(this *testMainClass) interface{} {
        					// catch block:
                                swapInverseOrderRequest = this.UrlencodedToDict(exchange.GetLast_request_body())
                            return nil
        				}(this)
        			}
        		}()
        		// try block:
                
            retRes155412 := (<-exchange.CreateOrder("BTC/USD:BTC", "limit", "buy", 1, 20000))
            PanicOnError(retRes155412)
        		return nil
        	}(this)
        	if ret__ != nil {
        		return ret__
        	}
        }
        var clientOrderIdSwap interface{} = GetValue(swapOrderRequest, "newClientOrderId")
        var swapIdString interface{} = ToString(swapId)
        Assert(StartsWith(clientOrderIdSwap, swapIdString), Add(Add(Add("binance - swap clientOrderId: ", clientOrderIdSwap), " does not start with swapId"), swapIdString))
        var clientOrderIdInverse interface{} = GetValue(swapInverseOrderRequest, "newClientOrderId")
        Assert(StartsWith(clientOrderIdInverse, swapIdString), Add(Add(Add("binance - swap clientOrderIdInverse: ", clientOrderIdInverse), " does not start with swapId"), swapIdString))
        if !IsTrue(IsSync()) {
        
            retRes156412 := (<-Close(exchange))
            PanicOnError(retRes156412)
        }
        
        ch <- true
        return nil
        
            }()
            return ch
        }
func  (this *testMainClass) TestOkx() <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                var exchange ccxt.IExchange = this.InitOfflineExchange("okx")
        var id interface{} = "e847386590ce4dBC"
        var spotOrderRequest interface{} = nil
        
        {		ret__ := func(this *testMainClass) (ret_ interface{}) {
        		defer func() {
        			if e := recover(); e != nil {
                        if e == "break" {
        				    return
        			    }
        				ret_ = func(this *testMainClass) interface{} {
        					// catch block:
                                spotOrderRequest = JsonParse(exchange.GetLast_request_body())
                            return nil
        				}(this)
        			}
        		}()
        		// try block:
                
            retRes157412 := (<-exchange.CreateOrder("BTC/USDT", "limit", "buy", 1, 20000))
            PanicOnError(retRes157412)
        		return nil
        	}(this)
        	if ret__ != nil {
        		return ret__
        	}
        }
        var clientOrderId interface{} = GetValue(GetValue(spotOrderRequest, 0), "clOrdId") // returns order inside array
        var idString interface{} = ToString(id)
        Assert(StartsWith(clientOrderId, idString), Add(Add(Add("okx - spot clientOrderId: ", clientOrderId), " does not start with id: "), idString))
        var spotTag interface{} = GetValue(GetValue(spotOrderRequest, 0), "tag")
        Assert(IsEqual(spotTag, id), Add(Add(Add("okx - id: ", id), " different from spot tag: "), spotTag))
        var swapOrderRequest interface{} = nil
        
        {		ret__ := func(this *testMainClass) (ret_ interface{}) {
        		defer func() {
        			if e := recover(); e != nil {
                        if e == "break" {
        				    return
        			    }
        				ret_ = func(this *testMainClass) interface{} {
        					// catch block:
                                swapOrderRequest = JsonParse(exchange.GetLast_request_body())
                            return nil
        				}(this)
        			}
        		}()
        		// try block:
                
            retRes158512 := (<-exchange.CreateOrder("BTC/USDT:USDT", "limit", "buy", 1, 20000))
            PanicOnError(retRes158512)
        		return nil
        	}(this)
        	if ret__ != nil {
        		return ret__
        	}
        }
        var clientOrderIdSwap interface{} = GetValue(GetValue(swapOrderRequest, 0), "clOrdId")
        Assert(StartsWith(clientOrderIdSwap, idString), Add(Add(Add("okx - swap clientOrderId: ", clientOrderIdSwap), " does not start with id: "), idString))
        var swapTag interface{} = GetValue(GetValue(swapOrderRequest, 0), "tag")
        Assert(IsEqual(swapTag, id), Add(Add(Add("okx - id: ", id), " different from swap tag: "), swapTag))
        if !IsTrue(IsSync()) {
        
            retRes159412 := (<-Close(exchange))
            PanicOnError(retRes159412)
        }
        
        ch <- true
        return nil
        
            }()
            return ch
        }
func  (this *testMainClass) TestCryptocom() <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                var exchange ccxt.IExchange = this.InitOfflineExchange("cryptocom")
        var id interface{} = "CCXT"
        
        retRes16028 := (<-exchange.LoadMarkets())
        PanicOnError(retRes16028)
        var request interface{} = nil
        
        {		ret__ := func(this *testMainClass) (ret_ interface{}) {
        		defer func() {
        			if e := recover(); e != nil {
                        if e == "break" {
        				    return
        			    }
        				ret_ = func(this *testMainClass) interface{} {
        					// catch block:
                                request = JsonParse(exchange.GetLast_request_body())
                            return nil
        				}(this)
        			}
        		}()
        		// try block:
                
            retRes160512 := (<-exchange.CreateOrder("BTC/USDT", "limit", "buy", 1, 20000))
            PanicOnError(retRes160512)
        		return nil
        	}(this)
        	if ret__ != nil {
        		return ret__
        	}
        }
        var brokerId interface{} = GetValue(GetValue(request, "params"), "broker_id")
        Assert(IsEqual(brokerId, id), Add(Add(Add("cryptocom - id: ", id), " different from  broker_id: "), brokerId))
        if !IsTrue(IsSync()) {
        
            retRes161212 := (<-Close(exchange))
            PanicOnError(retRes161212)
        }
        
        ch <- true
        return nil
        
            }()
            return ch
        }
func  (this *testMainClass) TestBybit() <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                var exchange ccxt.IExchange = this.InitOfflineExchange("bybit")
        var reqHeaders interface{} = nil
        var id interface{} = "CCXT"
        Assert(IsEqual(GetValue(exchange.GetOptions(), "brokerId"), id), "id not in options")
        
        {		ret__ := func(this *testMainClass) (ret_ interface{}) {
        		defer func() {
        			if e := recover(); e != nil {
                        if e == "break" {
        				    return
        			    }
        				ret_ = func(this *testMainClass) interface{} {
        					// catch block:
                                // we expect an error here, we're only interested in the headers
            reqHeaders = exchange.GetLast_request_headers()
                            return nil
        				}(this)
        			}
        		}()
        		// try block:
                
            retRes162312 := (<-exchange.CreateOrder("BTC/USDT", "limit", "buy", 1, 20000))
            PanicOnError(retRes162312)
        		return nil
        	}(this)
        	if ret__ != nil {
        		return ret__
        	}
        }
        Assert(IsEqual(GetValue(reqHeaders, "Referer"), id), Add(Add("bybit - id: ", id), " not in headers."))
        if !IsTrue(IsSync()) {
        
            retRes163012 := (<-Close(exchange))
            PanicOnError(retRes163012)
        }
        
        ch <- true
        return nil
        
            }()
            return ch
        }
func  (this *testMainClass) TestKucoin() <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                var exchange ccxt.IExchange = this.InitOfflineExchange("kucoin")
        var reqHeaders interface{} = nil
        var spotId interface{} = GetValue(GetValue(GetValue(exchange.GetOptions(), "partner"), "spot"), "id")
        var spotKey interface{} = GetValue(GetValue(GetValue(exchange.GetOptions(), "partner"), "spot"), "key")
        Assert(IsEqual(spotId, "ccxt"), Add(Add("kucoin - id: ", spotId), " not in options"))
        Assert(IsEqual(spotKey, "9e58cc35-5b5e-4133-92ec-166e3f077cb8"), Add(Add("kucoin - key: ", spotKey), " not in options."))
        
        {		ret__ := func(this *testMainClass) (ret_ interface{}) {
        		defer func() {
        			if e := recover(); e != nil {
                        if e == "break" {
        				    return
        			    }
        				ret_ = func(this *testMainClass) interface{} {
        					// catch block:
                                // we expect an error here, we're only interested in the headers
            reqHeaders = exchange.GetLast_request_headers()
                            return nil
        				}(this)
        			}
        		}()
        		// try block:
                
            retRes164312 := (<-exchange.CreateOrder("BTC/USDT", "limit", "buy", 1, 20000))
            PanicOnError(retRes164312)
        		return nil
        	}(this)
        	if ret__ != nil {
        		return ret__
        	}
        }
        var id interface{} = "ccxt"
        Assert(IsEqual(GetValue(reqHeaders, "KC-API-PARTNER"), id), Add(Add("kucoin - id: ", id), " not in headers."))
        if !IsTrue(IsSync()) {
        
            retRes165112 := (<-Close(exchange))
            PanicOnError(retRes165112)
        }
        
        ch <- true
        return nil
        
            }()
            return ch
        }
func  (this *testMainClass) TestKucoinfutures() <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                var exchange ccxt.IExchange = this.InitOfflineExchange("kucoinfutures")
        var reqHeaders interface{} = nil
        var id interface{} = "ccxtfutures"
        var futureId interface{} = GetValue(GetValue(GetValue(exchange.GetOptions(), "partner"), "future"), "id")
        var futureKey interface{} = GetValue(GetValue(GetValue(exchange.GetOptions(), "partner"), "future"), "key")
        Assert(IsEqual(futureId, id), Add(Add("kucoinfutures - id: ", futureId), " not in options."))
        Assert(IsEqual(futureKey, "1b327198-f30c-4f14-a0ac-918871282f15"), Add(Add("kucoinfutures - key: ", futureKey), " not in options."))
        
        {		ret__ := func(this *testMainClass) (ret_ interface{}) {
        		defer func() {
        			if e := recover(); e != nil {
                        if e == "break" {
        				    return
        			    }
        				ret_ = func(this *testMainClass) interface{} {
        					// catch block:
                                reqHeaders = exchange.GetLast_request_headers()
                            return nil
        				}(this)
        			}
        		}()
        		// try block:
                
            retRes166512 := (<-exchange.CreateOrder("BTC/USDT:USDT", "limit", "buy", 1, 20000))
            PanicOnError(retRes166512)
        		return nil
        	}(this)
        	if ret__ != nil {
        		return ret__
        	}
        }
        Assert(IsEqual(GetValue(reqHeaders, "KC-API-PARTNER"), id), Add(Add("kucoinfutures - id: ", id), " not in headers."))
        if !IsTrue(IsSync()) {
        
            retRes167112 := (<-Close(exchange))
            PanicOnError(retRes167112)
        }
        
        ch <- true
        return nil
        
            }()
            return ch
        }
func  (this *testMainClass) TestBitget() <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                var exchange ccxt.IExchange = this.InitOfflineExchange("bitget")
        var reqHeaders interface{} = nil
        var id interface{} = "p4sve"
        Assert(IsEqual(GetValue(exchange.GetOptions(), "broker"), id), Add(Add("bitget - id: ", id), " not in options"))
        
        {		ret__ := func(this *testMainClass) (ret_ interface{}) {
        		defer func() {
        			if e := recover(); e != nil {
                        if e == "break" {
        				    return
        			    }
        				ret_ = func(this *testMainClass) interface{} {
        					// catch block:
                                reqHeaders = exchange.GetLast_request_headers()
                            return nil
        				}(this)
        			}
        		}()
        		// try block:
                
            retRes168212 := (<-exchange.CreateOrder("BTC/USDT", "limit", "buy", 1, 20000))
            PanicOnError(retRes168212)
        		return nil
        	}(this)
        	if ret__ != nil {
        		return ret__
        	}
        }
        Assert(IsEqual(GetValue(reqHeaders, "X-CHANNEL-API-CODE"), id), Add(Add("bitget - id: ", id), " not in headers."))
        if !IsTrue(IsSync()) {
        
            retRes168812 := (<-Close(exchange))
            PanicOnError(retRes168812)
        }
        
        ch <- true
        return nil
        
            }()
            return ch
        }
func  (this *testMainClass) TestMexc() <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                var exchange ccxt.IExchange = this.InitOfflineExchange("mexc")
        var reqHeaders interface{} = nil
        var id interface{} = "CCXT"
        Assert(IsEqual(GetValue(exchange.GetOptions(), "broker"), id), Add(Add("mexc - id: ", id), " not in options"))
        
        retRes16988 := (<-exchange.LoadMarkets())
        PanicOnError(retRes16988)
        
        {		ret__ := func(this *testMainClass) (ret_ interface{}) {
        		defer func() {
        			if e := recover(); e != nil {
                        if e == "break" {
        				    return
        			    }
        				ret_ = func(this *testMainClass) interface{} {
        					// catch block:
                                reqHeaders = exchange.GetLast_request_headers()
                            return nil
        				}(this)
        			}
        		}()
        		// try block:
                
            retRes170012 := (<-exchange.CreateOrder("BTC/USDT", "limit", "buy", 1, 20000))
            PanicOnError(retRes170012)
        		return nil
        	}(this)
        	if ret__ != nil {
        		return ret__
        	}
        }
        Assert(IsEqual(GetValue(reqHeaders, "source"), id), Add(Add("mexc - id: ", id), " not in headers."))
        if !IsTrue(IsSync()) {
        
            retRes170612 := (<-Close(exchange))
            PanicOnError(retRes170612)
        }
        
        ch <- true
        return nil
        
            }()
            return ch
        }
func  (this *testMainClass) TestHtx() <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                var exchange ccxt.IExchange = this.InitOfflineExchange("htx")
        // spot test
        var id interface{} = "AA03022abc"
        var spotOrderRequest interface{} = nil
        
        {		ret__ := func(this *testMainClass) (ret_ interface{}) {
        		defer func() {
        			if e := recover(); e != nil {
                        if e == "break" {
        				    return
        			    }
        				ret_ = func(this *testMainClass) interface{} {
        					// catch block:
                                spotOrderRequest = JsonParse(exchange.GetLast_request_body())
                            return nil
        				}(this)
        			}
        		}()
        		// try block:
                
            retRes171712 := (<-exchange.CreateOrder("BTC/USDT", "limit", "buy", 1, 20000))
            PanicOnError(retRes171712)
        		return nil
        	}(this)
        	if ret__ != nil {
        		return ret__
        	}
        }
        var clientOrderId interface{} = GetValue(spotOrderRequest, "client-order-id")
        var idString interface{} = ToString(id)
        Assert(StartsWith(clientOrderId, idString), Add(Add(Add("htx - spot clientOrderId ", clientOrderId), " does not start with id: "), idString))
        // swap test
        var swapOrderRequest interface{} = nil
        
        {		ret__ := func(this *testMainClass) (ret_ interface{}) {
        		defer func() {
        			if e := recover(); e != nil {
                        if e == "break" {
        				    return
        			    }
        				ret_ = func(this *testMainClass) interface{} {
        					// catch block:
                                swapOrderRequest = JsonParse(exchange.GetLast_request_body())
                            return nil
        				}(this)
        			}
        		}()
        		// try block:
                
            retRes172712 := (<-exchange.CreateOrder("BTC/USDT:USDT", "limit", "buy", 1, 20000))
            PanicOnError(retRes172712)
        		return nil
        	}(this)
        	if ret__ != nil {
        		return ret__
        	}
        }
        var swapInverseOrderRequest interface{} = nil
        
        {		ret__ := func(this *testMainClass) (ret_ interface{}) {
        		defer func() {
        			if e := recover(); e != nil {
                        if e == "break" {
        				    return
        			    }
        				ret_ = func(this *testMainClass) interface{} {
        					// catch block:
                                swapInverseOrderRequest = JsonParse(exchange.GetLast_request_body())
                            return nil
        				}(this)
        			}
        		}()
        		// try block:
                
            retRes173312 := (<-exchange.CreateOrder("BTC/USD:BTC", "limit", "buy", 1, 20000))
            PanicOnError(retRes173312)
        		return nil
        	}(this)
        	if ret__ != nil {
        		return ret__
        	}
        }
        var clientOrderIdSwap interface{} = GetValue(swapOrderRequest, "channel_code")
        Assert(StartsWith(clientOrderIdSwap, idString), Add(Add(Add("htx - swap channel_code ", clientOrderIdSwap), " does not start with id: "), idString))
        var clientOrderIdInverse interface{} = GetValue(swapInverseOrderRequest, "channel_code")
        Assert(StartsWith(clientOrderIdInverse, idString), Add(Add(Add("htx - swap inverse channel_code ", clientOrderIdInverse), " does not start with id: "), idString))
        if !IsTrue(IsSync()) {
        
            retRes174212 := (<-Close(exchange))
            PanicOnError(retRes174212)
        }
        
        ch <- true
        return nil
        
            }()
            return ch
        }
func  (this *testMainClass) TestWoo() <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                var exchange ccxt.IExchange = this.InitOfflineExchange("woo")
        // spot test
        var id interface{} = "bc830de7-50f3-460b-9ee0-f430f83f9dad"
        var spotOrderRequest interface{} = nil
        
        {		ret__ := func(this *testMainClass) (ret_ interface{}) {
        		defer func() {
        			if e := recover(); e != nil {
                        if e == "break" {
        				    return
        			    }
        				ret_ = func(this *testMainClass) interface{} {
        					// catch block:
                                spotOrderRequest = this.UrlencodedToDict(exchange.GetLast_request_body())
                            return nil
        				}(this)
        			}
        		}()
        		// try block:
                
            retRes175312 := (<-exchange.CreateOrder("BTC/USDT", "limit", "buy", 1, 20000))
            PanicOnError(retRes175312)
        		return nil
        	}(this)
        	if ret__ != nil {
        		return ret__
        	}
        }
        var brokerId interface{} = GetValue(spotOrderRequest, "broker_id")
        var idString interface{} = ToString(id)
        Assert(StartsWith(brokerId, idString), Add(Add(Add("woo - broker_id: ", brokerId), " does not start with id: "), idString))
        // swap test
        var stopOrderRequest interface{} = nil
        
        {		ret__ := func(this *testMainClass) (ret_ interface{}) {
        		defer func() {
        			if e := recover(); e != nil {
                        if e == "break" {
        				    return
        			    }
        				ret_ = func(this *testMainClass) interface{} {
        					// catch block:
                                stopOrderRequest = JsonParse(exchange.GetLast_request_body())
                            return nil
        				}(this)
        			}
        		}()
        		// try block:
                
            retRes176312 := (<-exchange.CreateOrder("BTC/USDT:USDT", "limit", "buy", 1, 20000, map[string]interface{} {
                "stopPrice": 30000,
            }))
            PanicOnError(retRes176312)
        		return nil
        	}(this)
        	if ret__ != nil {
        		return ret__
        	}
        }
        var clientOrderIdStop interface{} = GetValue(stopOrderRequest, "brokerId")
        Assert(StartsWith(clientOrderIdStop, idString), Add(Add(Add("woo - brokerId: ", clientOrderIdStop), " does not start with id: "), idString))
        if !IsTrue(IsSync()) {
        
            retRes177012 := (<-Close(exchange))
            PanicOnError(retRes177012)
        }
        
        ch <- true
        return nil
        
            }()
            return ch
        }
func  (this *testMainClass) TestBitmart() <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                var exchange ccxt.IExchange = this.InitOfflineExchange("bitmart")
        var reqHeaders interface{} = nil
        var id interface{} = "CCXTxBitmart000"
        Assert(IsEqual(GetValue(exchange.GetOptions(), "brokerId"), id), Add(Add("bitmart - id: ", id), " not in options"))
        
        retRes17808 := (<-exchange.LoadMarkets())
        PanicOnError(retRes17808)
        
        {		ret__ := func(this *testMainClass) (ret_ interface{}) {
        		defer func() {
        			if e := recover(); e != nil {
                        if e == "break" {
        				    return
        			    }
        				ret_ = func(this *testMainClass) interface{} {
        					// catch block:
                                reqHeaders = exchange.GetLast_request_headers()
                            return nil
        				}(this)
        			}
        		}()
        		// try block:
                
            retRes178212 := (<-exchange.CreateOrder("BTC/USDT", "limit", "buy", 1, 20000))
            PanicOnError(retRes178212)
        		return nil
        	}(this)
        	if ret__ != nil {
        		return ret__
        	}
        }
        Assert(IsEqual(GetValue(reqHeaders, "X-BM-BROKER-ID"), id), Add(Add("bitmart - id: ", id), " not in headers"))
        if !IsTrue(IsSync()) {
        
            retRes178812 := (<-Close(exchange))
            PanicOnError(retRes178812)
        }
        
        ch <- true
        return nil
        
            }()
            return ch
        }
func  (this *testMainClass) TestCoinex() <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                var exchange ccxt.IExchange = this.InitOfflineExchange("coinex")
        var id interface{} = "x-167673045"
        Assert(IsEqual(GetValue(exchange.GetOptions(), "brokerId"), id), Add(Add("coinex - id: ", id), " not in options"))
        var spotOrderRequest interface{} = nil
        
        {		ret__ := func(this *testMainClass) (ret_ interface{}) {
        		defer func() {
        			if e := recover(); e != nil {
                        if e == "break" {
        				    return
        			    }
        				ret_ = func(this *testMainClass) interface{} {
        					// catch block:
                                spotOrderRequest = JsonParse(exchange.GetLast_request_body())
                            return nil
        				}(this)
        			}
        		}()
        		// try block:
                
            retRes179912 := (<-exchange.CreateOrder("BTC/USDT", "limit", "buy", 1, 20000))
            PanicOnError(retRes179912)
        		return nil
        	}(this)
        	if ret__ != nil {
        		return ret__
        	}
        }
        var clientOrderId interface{} = GetValue(spotOrderRequest, "client_id")
        var idString interface{} = ToString(id)
        Assert(StartsWith(clientOrderId, idString), Add(Add(Add("coinex - clientOrderId: ", clientOrderId), " does not start with id: "), idString))
        if !IsTrue(IsSync()) {
        
            retRes180712 := (<-Close(exchange))
            PanicOnError(retRes180712)
        }
        
        ch <- true
        return nil
        
            }()
            return ch
        }
func  (this *testMainClass) TestBingx() <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                var exchange ccxt.IExchange = this.InitOfflineExchange("bingx")
        var reqHeaders interface{} = nil
        var id interface{} = "CCXT"
        Assert(IsEqual(GetValue(exchange.GetOptions(), "broker"), id), Add(Add("bingx - id: ", id), " not in options"))
        
        {		ret__ := func(this *testMainClass) (ret_ interface{}) {
        		defer func() {
        			if e := recover(); e != nil {
                        if e == "break" {
        				    return
        			    }
        				ret_ = func(this *testMainClass) interface{} {
        					// catch block:
                                // we expect an error here, we're only interested in the headers
            reqHeaders = exchange.GetLast_request_headers()
                            return nil
        				}(this)
        			}
        		}()
        		// try block:
                
            retRes181812 := (<-exchange.CreateOrder("BTC/USDT", "limit", "buy", 1, 20000))
            PanicOnError(retRes181812)
        		return nil
        	}(this)
        	if ret__ != nil {
        		return ret__
        	}
        }
        Assert(IsEqual(GetValue(reqHeaders, "X-SOURCE-KEY"), id), Add(Add("bingx - id: ", id), " not in headers."))
        if !IsTrue(IsSync()) {
        
            retRes182512 := (<-Close(exchange))
            PanicOnError(retRes182512)
        }
        
        ch <- true
        return nil
        
            }()
            return ch
        }
func  (this *testMainClass) TestPhemex() <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                var exchange ccxt.IExchange = this.InitOfflineExchange("phemex")
        var id interface{} = "CCXT123456"
        var request interface{} = nil
        
        {		ret__ := func(this *testMainClass) (ret_ interface{}) {
        		defer func() {
        			if e := recover(); e != nil {
                        if e == "break" {
        				    return
        			    }
        				ret_ = func(this *testMainClass) interface{} {
        					// catch block:
                                request = JsonParse(exchange.GetLast_request_body())
                            return nil
        				}(this)
        			}
        		}()
        		// try block:
                
            retRes183512 := (<-exchange.CreateOrder("BTC/USDT", "limit", "buy", 1, 20000))
            PanicOnError(retRes183512)
        		return nil
        	}(this)
        	if ret__ != nil {
        		return ret__
        	}
        }
        var clientOrderId interface{} = GetValue(request, "clOrdID")
        var idString interface{} = ToString(id)
        Assert(StartsWith(clientOrderId, idString), Add(Add(Add("phemex - clOrdID: ", clientOrderId), " does not start with id: "), idString))
        if !IsTrue(IsSync()) {
        
            retRes184312 := (<-Close(exchange))
            PanicOnError(retRes184312)
        }
        
        ch <- true
        return nil
        
            }()
            return ch
        }
func  (this *testMainClass) TestBlofin() <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                var exchange ccxt.IExchange = this.InitOfflineExchange("blofin")
        var id interface{} = "ec6dd3a7dd982d0b"
        var request interface{} = nil
        
        {		ret__ := func(this *testMainClass) (ret_ interface{}) {
        		defer func() {
        			if e := recover(); e != nil {
                        if e == "break" {
        				    return
        			    }
        				ret_ = func(this *testMainClass) interface{} {
        					// catch block:
                                request = JsonParse(exchange.GetLast_request_body())
                            return nil
        				}(this)
        			}
        		}()
        		// try block:
                
            retRes185312 := (<-exchange.CreateOrder("LTC/USDT:USDT", "market", "buy", 1))
            PanicOnError(retRes185312)
        		return nil
        	}(this)
        	if ret__ != nil {
        		return ret__
        	}
        }
        var brokerId interface{} = GetValue(request, "brokerId")
        var idString interface{} = ToString(id)
        Assert(StartsWith(brokerId, idString), Add(Add(Add("blofin - brokerId: ", brokerId), " does not start with id: "), idString))
        if !IsTrue(IsSync()) {
        
            retRes186112 := (<-Close(exchange))
            PanicOnError(retRes186112)
        }
        
        ch <- true
        return nil
        
            }()
            return ch
        }
func  (this *testMainClass) TestHyperliquid() <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                var exchange ccxt.IExchange = this.InitOfflineExchange("hyperliquid")
        var id interface{} = "1"
        var request interface{} = nil
        
        {		ret__ := func(this *testMainClass) (ret_ interface{}) {
        		defer func() {
        			if e := recover(); e != nil {
                        if e == "break" {
        				    return
        			    }
        				ret_ = func(this *testMainClass) interface{} {
        					// catch block:
                                request = JsonParse(exchange.GetLast_request_body())
                            return nil
        				}(this)
        			}
        		}()
        		// try block:
                
            retRes187112 := (<-exchange.CreateOrder("SOL/USDC:USDC", "limit", "buy", 1, 100))
            PanicOnError(retRes187112)
        		return nil
        	}(this)
        	if ret__ != nil {
        		return ret__
        	}
        }
        var brokerId interface{} = ToString((GetValue(GetValue(request, "action"), "brokerCode")))
        Assert(IsEqual(brokerId, id), Add(Add(Add("hyperliquid - brokerId: ", brokerId), " does not start with id: "), id))
        if !IsTrue(IsSync()) {
        
            retRes187812 := (<-Close(exchange))
            PanicOnError(retRes187812)
        }
        
        ch <- true
        return nil
        
            }()
            return ch
        }
func  (this *testMainClass) TestCoinbaseinternational() <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                var exchange ccxt.IExchange = this.InitOfflineExchange("coinbaseinternational")
        AddElementToObject(exchange.GetOptions(), "portfolio", "random")
        var id interface{} = "nfqkvdjp"
        Assert(IsEqual(GetValue(exchange.GetOptions(), "brokerId"), id), "id not in options")
        var request interface{} = nil
        
        {		ret__ := func(this *testMainClass) (ret_ interface{}) {
        		defer func() {
        			if e := recover(); e != nil {
                        if e == "break" {
        				    return
        			    }
        				ret_ = func(this *testMainClass) interface{} {
        					// catch block:
                                request = JsonParse(exchange.GetLast_request_body())
                            return nil
        				}(this)
        			}
        		}()
        		// try block:
                
            retRes189012 := (<-exchange.CreateOrder("BTC/USDC:USDC", "limit", "buy", 1, 20000))
            PanicOnError(retRes189012)
        		return nil
        	}(this)
        	if ret__ != nil {
        		return ret__
        	}
        }
        var clientOrderId interface{} = GetValue(request, "client_order_id")
        Assert(StartsWith(clientOrderId, ToString(id)), "clientOrderId does not start with id")
        if !IsTrue(IsSync()) {
        
            retRes189712 := (<-Close(exchange))
            PanicOnError(retRes189712)
        }
        
        ch <- true
        return nil
        
            }()
            return ch
        }
func  (this *testMainClass) TestCoinbaseAdvanced() <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                var exchange ccxt.IExchange = this.InitOfflineExchange("coinbase")
        var id interface{} = "ccxt"
        Assert(IsEqual(GetValue(exchange.GetOptions(), "brokerId"), id), "id not in options")
        var request interface{} = nil
        
        {		ret__ := func(this *testMainClass) (ret_ interface{}) {
        		defer func() {
        			if e := recover(); e != nil {
                        if e == "break" {
        				    return
        			    }
        				ret_ = func(this *testMainClass) interface{} {
        					// catch block:
                                request = JsonParse(exchange.GetLast_request_body())
                            return nil
        				}(this)
        			}
        		}()
        		// try block:
                
            retRes190812 := (<-exchange.CreateOrder("BTC/USDC", "limit", "buy", 1, 20000))
            PanicOnError(retRes190812)
        		return nil
        	}(this)
        	if ret__ != nil {
        		return ret__
        	}
        }
        var clientOrderId interface{} = GetValue(request, "client_order_id")
        Assert(StartsWith(clientOrderId, ToString(id)), "clientOrderId does not start with id")
        if !IsTrue(IsSync()) {
        
            retRes191512 := (<-Close(exchange))
            PanicOnError(retRes191512)
        }
        
        ch <- true
        return nil
        
            }()
            return ch
        }
func  (this *testMainClass) TestWoofiPro() <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                var exchange ccxt.IExchange = this.InitOfflineExchange("woofipro")
        exchange.SetSecret("secretsecretsecretsecretsecretsecretsecrets")
        var id interface{} = "CCXT"
        
        retRes19248 := (<-exchange.LoadMarkets())
        PanicOnError(retRes19248)
        var request interface{} = nil
        
        {		ret__ := func(this *testMainClass) (ret_ interface{}) {
        		defer func() {
        			if e := recover(); e != nil {
                        if e == "break" {
        				    return
        			    }
        				ret_ = func(this *testMainClass) interface{} {
        					// catch block:
                                request = JsonParse(exchange.GetLast_request_body())
                            return nil
        				}(this)
        			}
        		}()
        		// try block:
                
            retRes192712 := (<-exchange.CreateOrder("BTC/USDC:USDC", "limit", "buy", 1, 20000))
            PanicOnError(retRes192712)
        		return nil
        	}(this)
        	if ret__ != nil {
        		return ret__
        	}
        }
        var brokerId interface{} = GetValue(request, "order_tag")
        Assert(IsEqual(brokerId, id), Add(Add(Add("woofipro - id: ", id), " different from  broker_id: "), brokerId))
        if !IsTrue(IsSync()) {
        
            retRes193412 := (<-Close(exchange))
            PanicOnError(retRes193412)
        }
        
        ch <- true
        return nil
        
            }()
            return ch
        }
func  (this *testMainClass) TestOxfun() <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                var exchange ccxt.IExchange = this.InitOfflineExchange("oxfun")
        exchange.SetSecret("secretsecretsecretsecretsecretsecretsecrets")
        var id interface{} = 1000
        
        retRes19438 := (<-exchange.LoadMarkets())
        PanicOnError(retRes19438)
        var request interface{} = nil
        
        {		ret__ := func(this *testMainClass) (ret_ interface{}) {
        		defer func() {
        			if e := recover(); e != nil {
                        if e == "break" {
        				    return
        			    }
        				ret_ = func(this *testMainClass) interface{} {
        					// catch block:
                                request = JsonParse(exchange.GetLast_request_body())
                            return nil
        				}(this)
        			}
        		}()
        		// try block:
                
            retRes194612 := (<-exchange.CreateOrder("BTC/USD:OX", "limit", "buy", 1, 20000))
            PanicOnError(retRes194612)
        		return nil
        	}(this)
        	if ret__ != nil {
        		return ret__
        	}
        }
        var orders interface{} = GetValue(request, "orders")
        var first interface{} = GetValue(orders, 0)
        var brokerId interface{} = GetValue(first, "source")
        Assert(IsEqual(brokerId, id), Add(Add(Add("oxfun - id: ", ToString(id)), " different from  broker_id: "), ToString(brokerId)))
        
        ch <- true
        return nil
        
            }()
            return ch
        }
func  (this *testMainClass) TestXT() <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                var exchange ccxt.IExchange = this.InitOfflineExchange("xt")
        var id interface{} = "CCXT"
        var spotOrderRequest interface{} = nil
        
        {		ret__ := func(this *testMainClass) (ret_ interface{}) {
        		defer func() {
        			if e := recover(); e != nil {
                        if e == "break" {
        				    return
        			    }
        				ret_ = func(this *testMainClass) interface{} {
        					// catch block:
                                spotOrderRequest = JsonParse(exchange.GetLast_request_body())
                            return nil
        				}(this)
        			}
        		}()
        		// try block:
                
            retRes196212 := (<-exchange.CreateOrder("BTC/USDT", "limit", "buy", 1, 20000))
            PanicOnError(retRes196212)
        		return nil
        	}(this)
        	if ret__ != nil {
        		return ret__
        	}
        }
        var spotMedia interface{} = GetValue(spotOrderRequest, "media")
        Assert(IsEqual(spotMedia, id), Add(Add(Add("xt - id: ", id), " different from swap tag: "), spotMedia))
        var swapOrderRequest interface{} = nil
        
        {		ret__ := func(this *testMainClass) (ret_ interface{}) {
        		defer func() {
        			if e := recover(); e != nil {
                        if e == "break" {
        				    return
        			    }
        				ret_ = func(this *testMainClass) interface{} {
        					// catch block:
                                swapOrderRequest = JsonParse(exchange.GetLast_request_body())
                            return nil
        				}(this)
        			}
        		}()
        		// try block:
                
            retRes197012 := (<-exchange.CreateOrder("BTC/USDT:USDT", "limit", "buy", 1, 20000))
            PanicOnError(retRes197012)
        		return nil
        	}(this)
        	if ret__ != nil {
        		return ret__
        	}
        }
        var swapMedia interface{} = GetValue(swapOrderRequest, "clientMedia")
        Assert(IsEqual(swapMedia, id), Add(Add(Add("xt - id: ", id), " different from swap tag: "), swapMedia))
        if !IsTrue(IsSync()) {
        
            retRes197712 := (<-Close(exchange))
            PanicOnError(retRes197712)
        }
        
        ch <- true
        return nil
        
            }()
            return ch
        }
func  (this *testMainClass) TestVertex() <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                var exchange ccxt.IExchange = this.InitOfflineExchange("vertex")
        exchange.SetWalletAddress("0xc751489d24a33172541ea451bc253d7a9e98c781")
        exchange.SetPrivateKey("c33b1eb4b53108bf52e10f636d8c1236c04c33a712357ba3543ab45f48a5cb0b")
        AddElementToObject(exchange.GetOptions(), "v1contracts", map[string]interface{} {
            "chain_id": "42161",
            "endpoint_addr": "0xbbee07b3e8121227afcfe1e2b82772246226128e",
            "book_addrs": []interface{}{"0x0000000000000000000000000000000000000000", "0x70e5911371472e406f1291c621d1c8f207764d73", "0xf03f457a30e598d5020164a339727ef40f2b8fbc", "0x1c6281a78aa0ed88949c319cba5f0f0de2ce8353", "0xfe653438a1a4a7f56e727509c341d60a7b54fa91", "0xb6304e9a6ca241376a5fc9294daa8fca65ddcdcd", "0x01ec802ae0ab1b2cc4f028b9fe6eb954aef06ed1", "0x0000000000000000000000000000000000000000", "0x9c52d5c4df5a68955ad088a781b4ab364a861e9e", "0x0000000000000000000000000000000000000000", "0x2a3bcda1bb3ef649f3571c96c597c3d2b25edc79", "0x0000000000000000000000000000000000000000", "0x0492ff9807f82856781488015ef7aa5526c0edd6", "0x0000000000000000000000000000000000000000", "0xea884c82418ebc21cd080b8f40ecc4d06a6a6883", "0x0000000000000000000000000000000000000000", "0x5ecf68f983253a818ca8c17a56a4f2fb48d6ec6b", "0x0000000000000000000000000000000000000000", "0xba3f57a977f099905531f7c2f294aad7b56ed254", "0x0000000000000000000000000000000000000000", "0x0ac8c26d207d0c6aabb3644fea18f530c4d6fc8e", "0x0000000000000000000000000000000000000000", "0x8bd80ad7630b3864bed66cf28f548143ea43dc3b", "0x0000000000000000000000000000000000000000", "0x045391227fc4b2cdd27b95f066864225afc9314e", "0x0000000000000000000000000000000000000000", "0x7d512bef2e6cfd7e7f5f6b2f8027e3728eb7b6c3", "0x0000000000000000000000000000000000000000", "0x678a6c5003b56b5e9a81559e9a0df880407c796f", "0x0000000000000000000000000000000000000000", "0x14b5a17208fa98843cc602b3f74e31c95ded3567", "0xe442a89a07b3888ab10579fbb2824aeceff3a282", "0x0000000000000000000000000000000000000000", "0x0000000000000000000000000000000000000000", "0xac28ac205275d7c2d6877bea8657cebe04fd9ae9", "0x0000000000000000000000000000000000000000", "0xed811409bfea901e75cb19ba347c08a154e860c9", "0x0000000000000000000000000000000000000000", "0x0f7afcb1612b305626cff84f84e4169ba2d0f12c", "0x0000000000000000000000000000000000000000", "0xe4b8d903db2ce2d3891ef04cfc3ac56330c1b0c3", "0x5f44362bad629846b7455ad9d36bbc3759a3ef62", "0x0000000000000000000000000000000000000000", "0x0000000000000000000000000000000000000000", "0xa64e04ed4b223a71e524dc7ebb7f28e422ccfdde", "0x0000000000000000000000000000000000000000", "0x2ee573caab73c1d8cf0ca6bd3589b67de79628a4", "0x0000000000000000000000000000000000000000", "0x01bb96883a8a478d4410387d4aaf11067edc2c74", "0x0000000000000000000000000000000000000000", "0xe7ed0c559d905436a867cddf07e06921d572363c", "0x0000000000000000000000000000000000000000", "0xa94f9e3433c92a5cd1925494811a67b1943557d9", "0x0000000000000000000000000000000000000000", "0xa63de7f89ba1270b85f3dcc193ff1a1390a7c7c7", "0x0000000000000000000000000000000000000000", "0xc8b0b37dffe3a711a076dc86dd617cc203f36121", "0x0000000000000000000000000000000000000000", "0x646df48947ff785fe609969ff634e7be9d1c34cd", "0x0000000000000000000000000000000000000000", "0x42582b404b0bec4a266631a0e178840b107a0c69", "0x0000000000000000000000000000000000000000", "0x36a94bc3edb1b629d1413091e22dc65fa050f17f", "0x0000000000000000000000000000000000000000", "0xb398d00b5a336f0ad33cfb352fd7646171cec442", "0x0000000000000000000000000000000000000000", "0xb4bc3b00de98e1c0498699379f6607b1f00bd5a1", "0x0000000000000000000000000000000000000000", "0xfe8b7baf68952bac2c04f386223d2013c1b4c601", "0x0000000000000000000000000000000000000000", "0x9c8764ec71f175c97c6c2fd558eb6546fcdbea32", "0x0000000000000000000000000000000000000000", "0x94d31188982c8eccf243e555b22dc57de1dba4e1", "0x0000000000000000000000000000000000000000", "0x407c5e2fadd7555be927c028bc358daa907c797a", "0x0000000000000000000000000000000000000000", "0x7e97da2dbbbdd7fb313cf9dc0581ac7cec999c70", "0x0000000000000000000000000000000000000000", "0x7f8d2662f64dd468c423805f98a6579ad59b28fa", "0x0000000000000000000000000000000000000000", "0x3398adf63fed17cbadd6080a1fb771e6a2a55958", "0x0000000000000000000000000000000000000000", "0xba8910a1d7ab62129729047d453091a1e6356170", "0x0000000000000000000000000000000000000000", "0xdc054bce222fe725da0f17abcef38253bd8bb745", "0x0000000000000000000000000000000000000000", "0xca21693467d0a5ea9e10a5a7c5044b9b3837e694", "0x0000000000000000000000000000000000000000", "0xe0b02de2139256dbae55cf350094b882fbe629ea", "0x0000000000000000000000000000000000000000", "0x02c38368a6f53858aab5a3a8d91d73eb59edf9b9", "0x0000000000000000000000000000000000000000", "0x0000000000000000000000000000000000000000", "0x0000000000000000000000000000000000000000", "0x0000000000000000000000000000000000000000", "0x0000000000000000000000000000000000000000", "0xfe8c4778843c3cb047ffe7c0c0154a724c05cab9", "0x0000000000000000000000000000000000000000", "0xe2e88862d9b7379e21c82fc4aec8d71bddbcdb4b", "0x0000000000000000000000000000000000000000", "0xbbaff9e73b30f9cea5c01481f12de75050947fd6", "0x0000000000000000000000000000000000000000", "0xa20f6f381fe0fec5a1035d37ebf8890726377ab9", "0x0000000000000000000000000000000000000000", "0xbad68032d012bf35d3a2a177b242e86684027ed0", "0x0000000000000000000000000000000000000000", "0x0e61ca37f0c67e8a8794e45e264970a2a23a513c", "0x0000000000000000000000000000000000000000", "0xa77b7048e378c5270b15918449ededf87c3a3db3", "0x0000000000000000000000000000000000000000", "0x15afca1e6f02b556fa6551021b3493a1e4a7f44f"},
        })
        var id interface{} = 5930043274845996
        
        retRes19888 := (<-exchange.LoadMarkets())
        PanicOnError(retRes19888)
        var request interface{} = nil
        
        {		ret__ := func(this *testMainClass) (ret_ interface{}) {
        		defer func() {
        			if e := recover(); e != nil {
                        if e == "break" {
        				    return
        			    }
        				ret_ = func(this *testMainClass) interface{} {
        					// catch block:
                                request = JsonParse(exchange.GetLast_request_body())
                            return nil
        				}(this)
        			}
        		}()
        		// try block:
                
            retRes199112 := (<-exchange.CreateOrder("BTC/USDC:USDC", "limit", "buy", 1, 20000))
            PanicOnError(retRes199112)
        		return nil
        	}(this)
        	if ret__ != nil {
        		return ret__
        	}
        }
        var order interface{} = GetValue(request, "place_order")
        var brokerId interface{} = GetValue(order, "id")
        Assert(IsEqual(brokerId, id), Add(Add(Add("vertex - id: ", ToString(id)), " different from  broker_id: "), ToString(brokerId)))
        if !IsTrue(IsSync()) {
        
            retRes199912 := (<-Close(exchange))
            PanicOnError(retRes199912)
        }
        
        ch <- true
        return nil
        
            }()
            return ch
        }
func  (this *testMainClass) TestParadex() <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                var exchange ccxt.IExchange = this.InitOfflineExchange("paradex")
        exchange.SetWalletAddress("0xc751489d24a33172541ea451bc253d7a9e98c781")
        exchange.SetPrivateKey("c33b1eb4b53108bf52e10f636d8c1236c04c33a712357ba3543ab45f48a5cb0b")
        AddElementToObject(exchange.GetOptions(), "authToken", "token")
        AddElementToObject(exchange.GetOptions(), "systemConfig", map[string]interface{} {
            "starknet_gateway_url": "https://potc-testnet-sepolia.starknet.io",
            "starknet_fullnode_rpc_url": "https://pathfinder.api.testnet.paradex.trade/rpc/v0_7",
            "starknet_chain_id": "PRIVATE_SN_POTC_SEPOLIA",
            "block_explorer_url": "https://voyager.testnet.paradex.trade/",
            "paraclear_address": "0x286003f7c7bfc3f94e8f0af48b48302e7aee2fb13c23b141479ba00832ef2c6",
            "paraclear_decimals": 8,
            "paraclear_account_proxy_hash": "0x3530cc4759d78042f1b543bf797f5f3d647cde0388c33734cf91b7f7b9314a9",
            "paraclear_account_hash": "0x41cb0280ebadaa75f996d8d92c6f265f6d040bb3ba442e5f86a554f1765244e",
            "oracle_address": "0x2c6a867917ef858d6b193a0ff9e62b46d0dc760366920d631715d58baeaca1f",
            "bridged_tokens": []interface{}{map[string]interface{} {
            "name": "TEST USDC",
            "symbol": "USDC",
            "decimals": 6,
            "l1_token_address": "0x29A873159D5e14AcBd63913D4A7E2df04570c666",
            "l1_bridge_address": "0x8586e05adc0C35aa11609023d4Ae6075Cb813b4C",
            "l2_token_address": "0x6f373b346561036d98ea10fb3e60d2f459c872b1933b50b21fe6ef4fda3b75e",
            "l2_bridge_address": "0x46e9237f5408b5f899e72125dd69bd55485a287aaf24663d3ebe00d237fc7ef",
        }},
            "l1_core_contract_address": "0x582CC5d9b509391232cd544cDF9da036e55833Af",
            "l1_operator_address": "0x11bACdFbBcd3Febe5e8CEAa75E0Ef6444d9B45FB",
            "l1_chain_id": "11155111",
            "liquidation_fee": "0.2",
        })
        var reqHeaders interface{} = nil
        var id interface{} = "CCXT"
        Assert(IsEqual(GetValue(exchange.GetOptions(), "broker"), id), Add(Add("paradex - id: ", id), " not in options"))
        
        retRes20148 := (<-exchange.LoadMarkets())
        PanicOnError(retRes20148)
        
        {		ret__ := func(this *testMainClass) (ret_ interface{}) {
        		defer func() {
        			if e := recover(); e != nil {
                        if e == "break" {
        				    return
        			    }
        				ret_ = func(this *testMainClass) interface{} {
        					// catch block:
                                reqHeaders = exchange.GetLast_request_headers()
                            return nil
        				}(this)
        			}
        		}()
        		// try block:
                
            retRes201612 := (<-exchange.CreateOrder("BTC/USD:USDC", "limit", "buy", 1, 20000))
            PanicOnError(retRes201612)
        		return nil
        	}(this)
        	if ret__ != nil {
        		return ret__
        	}
        }
        Assert(IsEqual(GetValue(reqHeaders, "PARADEX-PARTNER"), id), Add(Add("paradex - id: ", id), " not in headers"))
        if !IsTrue(IsSync()) {
        
            retRes202212 := (<-Close(exchange))
            PanicOnError(retRes202212)
        }
        
        ch <- true
        return nil
        
            }()
            return ch
        }
func  (this *testMainClass) TestHashkey() <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                var exchange ccxt.IExchange = this.InitOfflineExchange("hashkey")
        var reqHeaders interface{} = nil
        var id interface{} = "10000700011"
        
        {		ret__ := func(this *testMainClass) (ret_ interface{}) {
        		defer func() {
        			if e := recover(); e != nil {
                        if e == "break" {
        				    return
        			    }
        				ret_ = func(this *testMainClass) interface{} {
        					// catch block:
                                // we expect an error here, we're only interested in the headers
            reqHeaders = exchange.GetLast_request_headers()
                            return nil
        				}(this)
        			}
        		}()
        		// try block:
                
            retRes203212 := (<-exchange.CreateOrder("BTC/USDT", "limit", "buy", 1, 20000))
            PanicOnError(retRes203212)
        		return nil
        	}(this)
        	if ret__ != nil {
        		return ret__
        	}
        }
        Assert(IsEqual(GetValue(reqHeaders, "INPUT-SOURCE"), id), Add(Add("hashkey - id: ", id), " not in headers."))
        if !IsTrue(IsSync()) {
        
            retRes203912 := (<-Close(exchange))
            PanicOnError(retRes203912)
        }
        
        ch <- true
        return nil
        
            }()
            return ch
        }
func  (this *testMainClass) TestCoincatch() <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                var exchange ccxt.IExchange = this.InitOfflineExchange("coincatch")
        var reqHeaders interface{} = nil
        var id interface{} = "47cfy"
        
        {		ret__ := func(this *testMainClass) (ret_ interface{}) {
        		defer func() {
        			if e := recover(); e != nil {
                        if e == "break" {
        				    return
        			    }
        				ret_ = func(this *testMainClass) interface{} {
        					// catch block:
                                // we expect an error here, we're only interested in the headers
            reqHeaders = exchange.GetLast_request_headers()
                            return nil
        				}(this)
        			}
        		}()
        		// try block:
                
            retRes204912 := (<-exchange.CreateOrder("BTC/USDT", "limit", "buy", 1, 20000))
            PanicOnError(retRes204912)
        		return nil
        	}(this)
        	if ret__ != nil {
        		return ret__
        	}
        }
        Assert(IsEqual(GetValue(reqHeaders, "X-CHANNEL-API-CODE"), id), Add(Add("coincatch - id: ", id), " not in headers."))
        if !IsTrue(IsSync()) {
        
            retRes205612 := (<-Close(exchange))
            PanicOnError(retRes205612)
        }
        
        ch <- true
        return nil
        
            }()
            return ch
        }
func  (this *testMainClass) TestDefx() <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                var exchange ccxt.IExchange = this.InitOfflineExchange("defx")
        var reqHeaders interface{} = nil
        
        {		ret__ := func(this *testMainClass) (ret_ interface{}) {
        		defer func() {
        			if e := recover(); e != nil {
                        if e == "break" {
        				    return
        			    }
        				ret_ = func(this *testMainClass) interface{} {
        					// catch block:
                                // we expect an error here, we're only interested in the headers
            reqHeaders = exchange.GetLast_request_headers()
                            return nil
        				}(this)
        			}
        		}()
        		// try block:
                
            retRes206612 := (<-exchange.CreateOrder("DOGE/USDC:USDC", "limit", "buy", 100, 1))
            PanicOnError(retRes206612)
        		return nil
        	}(this)
        	if ret__ != nil {
        		return ret__
        	}
        }
        var id interface{} = "ccxt"
        Assert(IsEqual(GetValue(reqHeaders, "X-DEFX-SOURCE"), id), Add(Add("defx - id: ", id), " not in headers."))
        if !IsTrue(IsSync()) {
        
            retRes207412 := (<-Close(exchange))
            PanicOnError(retRes207412)
        }
        
        ch <- true
        return nil
        
            }()
            return ch
        }
