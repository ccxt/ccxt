package base

import "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

func TestFetchCurrencies(exchange ccxt.ICoreExchange, skippedProperties interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		var method interface{} = "fetchCurrencies"

		currencies := (<-exchange.FetchCurrencies())
		PanicOnError(currencies)
		// todo: try to invent something to avoid undefined undefined, i.e. maybe move into private and force it to have a value
		var numInactiveCurrencies interface{} = 0
		var maxInactiveCurrenciesPercentage interface{} = exchange.SafeInteger(skippedProperties, "maxInactiveCurrenciesPercentage", 50) // no more than X% currencies should be inactive
		var requiredActiveCurrencies interface{} = []interface{}{"BTC", "ETH", "USDT", "USDC"}
		var features interface{} = exchange.GetFeatures()
		var featuresSpot interface{} = exchange.SafeDict(features, "spot", map[string]interface{}{})
		var fetchCurrencies interface{} = exchange.SafeDict(featuresSpot, "fetchCurrencies", map[string]interface{}{})
		var isFetchCurrenciesPrivate interface{} = exchange.SafeValue(fetchCurrencies, "private", false)
		if !IsTrue(isFetchCurrenciesPrivate) {
			var values interface{} = ObjectValues(currencies)
			AssertNonEmtpyArray(exchange, skippedProperties, method, values)
			var currenciesLength interface{} = GetArrayLength(values)
			// ensure exchange returns enough length of currencies
			var skipAmount interface{} = (InOp(skippedProperties, "amountOfCurrencies"))
			Assert(IsTrue(skipAmount) || IsTrue(IsGreaterThan(currenciesLength, 5)), Add(Add(Add(Add(exchange.GetId(), " "), method), " must return at least several currencies, but it returned "), ToString(currenciesLength)))
			// allow skipped exchanges
			var skipActive interface{} = (InOp(skippedProperties, "activeCurrenciesQuota"))
			var skipMajorCurrencyCheck interface{} = (InOp(skippedProperties, "activeMajorCurrencies"))
			// loop
			for i := 0; IsLessThan(i, currenciesLength); i++ {
				var currency interface{} = GetValue(values, i)
				TestCurrency(exchange, skippedProperties, method, currency)
				// detailed check for deposit/withdraw
				var active interface{} = exchange.SafeBool(currency, "active")
				if IsTrue(IsEqual(active, false)) {
					numInactiveCurrencies = Add(numInactiveCurrencies, 1)
				}
				// ensure that major currencies are active and enabled for deposit and withdrawal
				var code interface{} = exchange.SafeString(currency, "code", nil)
				var withdraw interface{} = exchange.SafeBool(currency, "withdraw")
				var deposit interface{} = exchange.SafeBool(currency, "deposit")
				if IsTrue(exchange.InArray(code, requiredActiveCurrencies)) {
					Assert(IsTrue(skipMajorCurrencyCheck) || IsTrue((IsTrue(withdraw) && IsTrue(deposit))), Add(Add("Major currency ", code), " should have withdraw and deposit flags enabled"))
				}
			}
			// check at least X% of currencies are active
			var inactiveCurrenciesPercentage interface{} = Multiply((Divide(numInactiveCurrencies, currenciesLength)), 100)
			Assert(IsTrue(skipActive) || IsTrue((IsLessThan(inactiveCurrenciesPercentage, maxInactiveCurrenciesPercentage))), Add(Add(Add(Add("Percentage of inactive currencies is too high at ", ToString(inactiveCurrenciesPercentage)), "% that is more than the allowed maximum of "), ToString(maxInactiveCurrenciesPercentage)), "%"))
			DetectCurrencyConflicts(exchange, currencies)
		}

		ch <- true
		return nil

	}()
	return ch
}
func DetectCurrencyConflicts(exchange ccxt.ICoreExchange, currencyValues interface{}) interface{} {
	// detect if there are currencies with different ids for the same code
	var ids interface{} = map[string]interface{}{}
	var keys interface{} = ObjectKeys(currencyValues)
	for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
		var key interface{} = GetValue(keys, i)
		var currency interface{} = GetValue(currencyValues, key)
		var code interface{} = GetValue(currency, "code")
		if !IsTrue((InOp(ids, code))) {
			AddElementToObject(ids, code, GetValue(currency, "id"))
		} else {
			var isDifferent interface{} = !IsEqual(GetValue(ids, code), GetValue(currency, "id"))
			Assert(!IsTrue(isDifferent), Add(Add(Add(Add(Add(Add(exchange.GetId(), " fetchCurrencies() has different ids for the same code: "), code), " "), GetValue(ids, code)), " "), GetValue(currency, "id")))
		}
	}
	return true
}
