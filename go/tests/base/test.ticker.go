package base
import "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


    func TestTicker(exchange ccxt.ICoreExchange, skippedProperties interface{}, method interface{}, entry interface{}, symbol interface{})  {
        var format interface{} = map[string]interface{} {
            "info": map[string]interface{} {},
            "symbol": "ETH/BTC",
            "timestamp": 1502962946216,
            "datetime": "2017-09-01T00:00:00",
            "high": exchange.ParseNumber("1.234"),
            "low": exchange.ParseNumber("1.234"),
            "bid": exchange.ParseNumber("1.234"),
            "bidVolume": exchange.ParseNumber("1.234"),
            "ask": exchange.ParseNumber("1.234"),
            "askVolume": exchange.ParseNumber("1.234"),
            "vwap": exchange.ParseNumber("1.234"),
            "open": exchange.ParseNumber("1.234"),
            "close": exchange.ParseNumber("1.234"),
            "last": exchange.ParseNumber("1.234"),
            "previousClose": exchange.ParseNumber("1.234"),
            "change": exchange.ParseNumber("1.234"),
            "percentage": exchange.ParseNumber("1.234"),
            "average": exchange.ParseNumber("1.234"),
            "baseVolume": exchange.ParseNumber("1.234"),
            "quoteVolume": exchange.ParseNumber("1.234"),
        }
        // todo: atm, many exchanges fail, so temporarily decrease stict mode
        var emptyAllowedFor interface{} = []interface{}{"timestamp", "datetime", "open", "high", "low", "close", "last", "baseVolume", "quoteVolume", "previousClose", "bidVolume", "askVolume", "vwap", "change", "percentage", "average"}
        // trick csharp-transpiler for string
        if !IsTrue((Contains(ToString(method),"BidsAsks"))) {
            AppendToArray(&emptyAllowedFor, "bid")
            AppendToArray(&emptyAllowedFor, "ask")
        }
        AssertStructure(exchange, skippedProperties, method, entry, format, emptyAllowedFor)
        AssertTimestampAndDatetime(exchange, skippedProperties, method, entry)
        var logText interface{} = LogTemplate(exchange, method, entry)
        // check market
        var market interface{} = nil
        var symbolForMarket interface{} = Ternary(IsTrue((!IsEqual(symbol, nil))), symbol, exchange.SafeString(entry, "symbol"))
        if IsTrue(IsTrue(!IsEqual(symbolForMarket, nil)) && IsTrue((InOp(exchange.GetMarkets(), symbolForMarket)))) {
            market = exchange.Market(symbolForMarket)
        }
        // temp todo: skip inactive markets for now, as they sometimes have weird values and causing issues:
        if !IsTrue((InOp(skippedProperties, "checkInactiveMarkets"))) {
            if IsTrue(IsTrue(!IsEqual(market, nil)) && IsTrue(IsEqual(GetValue(market, "active"), false))) {
                return
            }
        }
        // only check "above zero" values if exchange is not supposed to have exotic index markets
        var isStandardMarket interface{} =     (IsTrue(!IsEqual(market, nil)) && IsTrue(exchange.InArray(GetValue(market, "type"), []interface{}{"spot", "swap", "future", "option"})))
        var valuesShouldBePositive interface{} = isStandardMarket // || (market === undefined) atm, no check for index markets
        if IsTrue(IsTrue(valuesShouldBePositive) && !IsTrue((InOp(skippedProperties, "positiveValues")))) {
            AssertGreater(exchange, skippedProperties, method, entry, "open", "0")
            AssertGreater(exchange, skippedProperties, method, entry, "high", "0")
            AssertGreater(exchange, skippedProperties, method, entry, "low", "0")
            AssertGreater(exchange, skippedProperties, method, entry, "close", "0")
            AssertGreater(exchange, skippedProperties, method, entry, "ask", "0")
            AssertGreater(exchange, skippedProperties, method, entry, "bid", "0")
            AssertGreater(exchange, skippedProperties, method, entry, "average", "0")
            AssertGreaterOrEqual(exchange, skippedProperties, method, entry, "vwap", "0")
        }
        // volume can not be negative
        AssertGreaterOrEqual(exchange, skippedProperties, method, entry, "askVolume", "0")
        AssertGreaterOrEqual(exchange, skippedProperties, method, entry, "bidVolume", "0")
        AssertGreaterOrEqual(exchange, skippedProperties, method, entry, "baseVolume", "0")
        AssertGreaterOrEqual(exchange, skippedProperties, method, entry, "quoteVolume", "0")
        //
        // close price
        //
        var lastString interface{} = exchange.SafeString(entry, "last")
        var closeString interface{} = exchange.SafeString(entry, "close")
        Assert(IsTrue((IsTrue((IsEqual(closeString, nil))) && IsTrue((IsEqual(lastString, nil))))) || IsTrue(ccxt.Precise.StringEq(lastString, closeString)), Add("`last` != `close`", logText))
        var openPrice interface{} = exchange.SafeString(entry, "open")
        //
        // base & quote volumes
        //
        var baseVolume interface{} = exchange.OmitZero(exchange.SafeString(entry, "baseVolume"))
        var quoteVolume interface{} = exchange.OmitZero(exchange.SafeString(entry, "quoteVolume"))
        var high interface{} = exchange.OmitZero(exchange.SafeString(entry, "high"))
        var low interface{} = exchange.OmitZero(exchange.SafeString(entry, "low"))
        var open interface{} = exchange.OmitZero(exchange.SafeString(entry, "open"))
        var close interface{} = exchange.OmitZero(exchange.SafeString(entry, "close"))
        if !IsTrue((InOp(skippedProperties, "compareQuoteVolumeBaseVolume"))) {
            // Assert (baseVolumeDefined === quoteVolumeDefined, 'baseVolume or quoteVolume should be either both defined or both undefined' + logText); // No, exchanges might not report both values
            if IsTrue(IsTrue(IsTrue(IsTrue((!IsEqual(baseVolume, nil))) && IsTrue((!IsEqual(quoteVolume, nil)))) && IsTrue((!IsEqual(high, nil)))) && IsTrue((!IsEqual(low, nil)))) {
                var baseLow interface{} = ccxt.Precise.StringMul(baseVolume, low)
                var baseHigh interface{} = ccxt.Precise.StringMul(baseVolume, high)
                // to avoid abnormal long precision issues (like https://discord.com/channels/690203284119617602/1338828283902689280/1338846071278927912 )
                var mPrecision interface{} = exchange.SafeDict(market, "precision")
                var amountPrecision interface{} = exchange.SafeString(mPrecision, "amount")
                var tolerance interface{} = "1.0001"
                if IsTrue(!IsEqual(amountPrecision, nil)) {
                    baseLow = ccxt.Precise.StringMul(ccxt.Precise.StringSub(baseVolume, amountPrecision), low)
                    baseHigh = ccxt.Precise.StringMul(ccxt.Precise.StringAdd(baseVolume, amountPrecision), high)
                } else {
                    // if nothing found, as an exclusion, just add 0.001%
                    baseLow = ccxt.Precise.StringMul(ccxt.Precise.StringDiv(baseVolume, tolerance), low)
                    baseHigh = ccxt.Precise.StringMul(ccxt.Precise.StringMul(baseVolume, tolerance), high)
                }
                // because of exchange engines might not rounding numbers propertly, we add some tolerance of calculated 24hr high/low
                baseLow = ccxt.Precise.StringDiv(baseLow, tolerance)
                baseHigh = ccxt.Precise.StringMul(baseHigh, tolerance)
                Assert(ccxt.Precise.StringGe(quoteVolume, baseLow), Add("quoteVolume should be => baseVolume * low", logText))
                Assert(ccxt.Precise.StringLe(quoteVolume, baseHigh), Add("quoteVolume should be <= baseVolume * high", logText))
            }
        }
        // open and close should be between High & Low
        if IsTrue(IsTrue(IsTrue(!IsEqual(high, nil)) && IsTrue(!IsEqual(low, nil))) && !IsTrue((InOp(skippedProperties, "compareOHLC")))) {
            if IsTrue(!IsEqual(open, nil)) {
                Assert(ccxt.Precise.StringGe(open, low), Add("open should be >= low", logText))
                Assert(ccxt.Precise.StringLe(open, high), Add("open should be <= high", logText))
            }
            if IsTrue(!IsEqual(close, nil)) {
                Assert(ccxt.Precise.StringGe(close, low), Add("close should be >= low", logText))
                Assert(ccxt.Precise.StringLe(close, high), Add("close should be <= high", logText))
            }
        }
        //
        // vwap
        //
        var vwap interface{} = exchange.SafeString(entry, "vwap")
        if IsTrue(!IsEqual(vwap, nil)) {
            // todo
            // Assert (high !== undefined, 'vwap is defined, but high is not' + logText);
            // Assert (low !== undefined, 'vwap is defined, but low is not' + logText);
            // Assert (vwap >= low && vwap <= high)
            // todo: calc compare
            Assert(!IsTrue(valuesShouldBePositive) || IsTrue(ccxt.Precise.StringGe(vwap, "0")), Add("vwap is not greater than zero", logText))
            if IsTrue(!IsEqual(baseVolume, nil)) {
                Assert(!IsEqual(quoteVolume, nil), Add("baseVolume & vwap is defined, but quoteVolume is not", logText))
            }
            if IsTrue(!IsEqual(quoteVolume, nil)) {
                Assert(!IsEqual(baseVolume, nil), Add("quoteVolume & vwap is defined, but baseVolume is not", logText))
            }
        }
        var askString interface{} = exchange.SafeString(entry, "ask")
        var bidString interface{} = exchange.SafeString(entry, "bid")
        if IsTrue(IsTrue(IsTrue((!IsEqual(askString, nil))) && IsTrue((!IsEqual(bidString, nil)))) && !IsTrue((InOp(skippedProperties, "spread")))) {
            AssertGreater(exchange, skippedProperties, method, entry, "ask", exchange.SafeString(entry, "bid"))
        }
        var percentage interface{} = exchange.SafeString(entry, "percentage")
        var change interface{} = exchange.SafeString(entry, "change")
        if !IsTrue((InOp(skippedProperties, "maxIncrease"))) {
            //
            // percentage
            //
            var maxIncrease interface{} = "100" // for testing purposes, if "increased" value is more than 100x, tests should break as implementation might be wrong. however, if something rarest event happens and some coin really had that huge increase, the tests will shortly recover in few hours, as new 24-hour cycle would stabilize tests)
            if IsTrue(!IsEqual(percentage, nil)) {
                // - should be above -100 and below MAX
                Assert(ccxt.Precise.StringGe(percentage, "-100"), Add("percentage should be above -100% ", logText))
                Assert(ccxt.Precise.StringLe(percentage, ccxt.Precise.StringMul("+100", maxIncrease)), Add(Add(Add("percentage should be below ", maxIncrease), "00% "), logText))
            }
            //
            // change
            //
            var approxValue interface{} = exchange.SafeStringN(entry, []interface{}{"open", "close", "average", "bid", "ask", "vwap", "previousClose"})
            if IsTrue(!IsEqual(change, nil)) {
                // - should be between -price & +price*100
                Assert(ccxt.Precise.StringGe(change, ccxt.Precise.StringNeg(approxValue)), Add("change should be above -price ", logText))
                Assert(ccxt.Precise.StringLe(change, ccxt.Precise.StringMul(approxValue, maxIncrease)), Add(Add(Add("change should be below ", maxIncrease), "x price "), logText))
            }
        }
        //
        // ensure all expected values are defined
        //
        if IsTrue(!IsEqual(lastString, nil)) {
            if IsTrue(!IsEqual(percentage, nil)) {
                // if one knows 'last' and 'percentage' values, then 'change', 'open' and 'average' values should be determinable.
                Assert(IsTrue(!IsEqual(openPrice, nil)) && IsTrue(!IsEqual(change, nil)), Add("open & change should be defined if last & percentage are defined", logText)) // todo : add average price too
            } else if IsTrue(!IsEqual(change, nil)) {
                // if one knows 'last' and 'change' values, then 'percentage', 'open' and 'average' values should be determinable.
                Assert(IsTrue(!IsEqual(openPrice, nil)) && IsTrue(!IsEqual(percentage, nil)), Add("open & percentage should be defined if last & change are defined", logText)) // todo : add average price too
            }
        } else if IsTrue(!IsEqual(openPrice, nil)) {
            if IsTrue(!IsEqual(percentage, nil)) {
                // if one knows 'open' and 'percentage' values, then 'last', 'change' and 'average' values should be determinable.
                Assert(IsTrue(!IsEqual(lastString, nil)) && IsTrue(!IsEqual(change, nil)), Add("last & change should be defined if open & percentage are defined", logText)) // todo : add average price too
            } else if IsTrue(!IsEqual(change, nil)) {
                // if one knows 'open' and 'change' values, then 'last', 'percentage' and 'average' values should be determinable.
                Assert(IsTrue(!IsEqual(lastString, nil)) && IsTrue(!IsEqual(percentage, nil)), Add("last & percentage should be defined if open & change are defined", logText)) // todo : add average price too
            }
        }
        //
        // todo: rethink about this
        // else {
        //    Assert ((askString === undefined) && (bidString === undefined), 'ask & bid should be both defined or both undefined' + logText);
        // }
        AssertSymbol(exchange, skippedProperties, method, entry, "symbol", symbol)
    }
