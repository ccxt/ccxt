package base
import ccxt "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

func HelperTestHandleMarketTypeAndParams()  {
    exchange := ccxt.NewExchange().(*ccxt.Exchange); exchange.DerivedExchange = exchange; exchange.InitParent(map[string]interface{} {
        "id": "sampleexchange",
        "options": map[string]interface{} {
            "defaultType": "valueFromOptions",
            "fetchX": map[string]interface{} {
                "defaultType": "valueFromMethodOptions",
            },
        },
    }, map[string]interface{}{}, exchange)
    var initialParams map[string]interface{} = map[string]interface{} {
        "defaultType": "valueFromParam",
    }
    var market interface{} = exchange.SafeMarket("TEST1/TEST2")
    ccxt.AddElementToObject(market, "type", "spot")
    //
    // ########### test different variations ###########
    //
    // case #1, should prevail: param
    //
    marketType1params1Variable := exchange.HandleMarketTypeAndParams("fetchX", market, initialParams, "valueDefault");
    marketType1 := ccxt.GetValue(marketType1params1Variable,0);
    params1 := ccxt.GetValue(marketType1params1Variable,1)
    Assert(ccxt.InOp(initialParams, "defaultType"))
    Assert(!ccxt.IsTrue((ccxt.InOp(params1, "defaultType"))))
    Assert(ccxt.IsEqual(marketType1, "valueFromParam"))
    //
    // case #2, should prevail: market.type
    //
    marketType2params2Variable := exchange.HandleMarketTypeAndParams("fetchX", market, map[string]interface{} {}, "valueDefault");
    marketType2 := ccxt.GetValue(marketType2params2Variable,0);
    params2 := ccxt.GetValue(marketType2params2Variable,1)
    Assert(ccxt.IsEqual(marketType2, "spot"))
    //
    // case #3, should prevail: valueDefault
    //
    marketType3params3Variable := exchange.HandleMarketTypeAndParams("fetchX", nil, map[string]interface{} {}, "valueDefault");
    marketType3 := ccxt.GetValue(marketType3params3Variable,0);
    params3 := ccxt.GetValue(marketType3params3Variable,1)
    Assert(ccxt.IsEqual(marketType3, "valueDefault"))
    //
    // case #4, should prevail: method options
    //
    marketType4params4Variable := exchange.HandleMarketTypeAndParams("fetchX", nil, map[string]interface{} {});
    marketType4 := ccxt.GetValue(marketType4params4Variable,0);
    params4 := ccxt.GetValue(marketType4params4Variable,1)
    Assert(ccxt.IsEqual(marketType4, "valueFromMethodOptions"))
    //
    // case #5, should prevail: options
    //
    marketType5params5Variable := exchange.HandleMarketTypeAndParams("fetchY", nil, map[string]interface{} {}, nil);
    marketType5 := ccxt.GetValue(marketType5params5Variable,0);
    params5 := ccxt.GetValue(marketType5params5Variable,1)
    Assert(ccxt.IsEqual(marketType5, "valueFromOptions"))
    //
    // case #6, should prevail: spot (because hardcoded in base)
    //
    ccxt.AddElementToObject(exchange.Options, "defaultType", nil)
    marketType6params6Variable := exchange.HandleMarketTypeAndParams("fetchY", nil, map[string]interface{} {}, nil);
    marketType6 := ccxt.GetValue(marketType6params6Variable,0);
    params6 := ccxt.GetValue(marketType6params6Variable,1)
    Assert(ccxt.IsEqual(marketType6, "spot"))
    // fake assertion to avoid unused vars
    Assert(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(ccxt.IsTrue(!ccxt.IsEqual(params1, nil)) || ccxt.IsTrue(!ccxt.IsEqual(params2, nil))) || ccxt.IsTrue(!ccxt.IsEqual(params3, nil))) || ccxt.IsTrue(!ccxt.IsEqual(params4, nil))) || ccxt.IsTrue(!ccxt.IsEqual(params5, nil))) || ccxt.IsTrue(!ccxt.IsEqual(params6, nil)))
}
func HelperTestHandleNetworkRequest()  {
    exchange := ccxt.NewExchange().(*ccxt.Exchange); exchange.DerivedExchange = exchange; exchange.InitParent(map[string]interface{} {
        "id": "sampleexchange",
        "options": map[string]interface{} {
            "networks": map[string]interface{} {
                "XYZ": "Xyz",
            },
        },
    }, map[string]interface{}{}, exchange)
    exchange.Currencies = exchange.CreateSafeDictionary() // todo: initialize in C# base files
    var currencyCode interface{} = "ETH" // todo: in future with complex cases
    // no-case
    request1params1Variable := exchange.HandleRequestNetwork(map[string]interface{} {
    "network": "XYZ",
}, map[string]interface{} {}, "chain_id", currencyCode, false);
    request1 := ccxt.GetValue(request1params1Variable,0);
    params1 := ccxt.GetValue(request1params1Variable,1)
    Assert(!ccxt.IsTrue((ccxt.InOp(params1, "network"))))
    Assert(ccxt.InOp(request1, "chain_id"))
    Assert(ccxt.IsEqual(ccxt.GetValue(request1, "chain_id"), "Xyz"))
}
func TestHandleMethods()  {
    HelperTestHandleMarketTypeAndParams()
    HelperTestHandleNetworkRequest()
}