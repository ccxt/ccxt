package base

import "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

func TestWatchPositions(exchange ccxt.ICoreExchange, skippedProperties interface{}, symbol interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		var method interface{} = "watchPositions"
		var now interface{} = exchange.Milliseconds()
		var ends interface{} = Add(now, 15000)
		for IsLessThan(now, ends) {
			var response interface{} = nil
			var success interface{} = true

			{
				func() (ret_ interface{}) {
					defer func() {
						if e := recover(); e != nil {
							if e == "break" {
								return
							}
							ret_ = func() interface{} {
								// catch block:
								if !IsTrue(IsTemporaryFailure(e)) {
									panic(e)
								}
								now = exchange.Milliseconds()
								// continue;
								success = false
								return nil
							}()
						}
					}()
					// try block:

					response = (UnWrapType(<-exchange.WatchPositions([]interface{}{symbol})))
					PanicOnError(response)
					return nil
				}()

			}
			if IsTrue(IsEqual(success, true)) {
				AssertNonEmtpyArray(exchange, skippedProperties, method, response, symbol)
				now = exchange.Milliseconds()
				for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
					TestPosition(exchange, skippedProperties, method, GetValue(response, i), nil, now)
				}
				AssertTimestampOrder(exchange, method, symbol, response)
			}
			//
			// Test with specific symbol
			//
			var positionsForSymbols interface{} = nil
			var success2 interface{} = true

			{
				func() (ret_ interface{}) {
					defer func() {
						if e := recover(); e != nil {
							if e == "break" {
								return
							}
							ret_ = func() interface{} {
								// catch block:
								if !IsTrue(IsTemporaryFailure(e)) {
									panic(e)
								}
								now = exchange.Milliseconds()
								// continue;
								success2 = false
								return nil
							}()
						}
					}()
					// try block:

					positionsForSymbols = (UnWrapType(<-exchange.WatchPositions([]interface{}{symbol})))
					PanicOnError(positionsForSymbols)
					return nil
				}()

			}
			if IsTrue(IsEqual(success2, true)) {
				Assert(IsArray(positionsForSymbols), Add(Add(Add(Add(exchange.GetId(), " "), method), " must return an array, returned "), exchange.Json(positionsForSymbols)))
				// max theoretical 4 positions: two for one-way-mode and two for two-way mode
				Assert(IsLessThanOrEqual(GetArrayLength(positionsForSymbols), 4), Add(Add(Add(Add(exchange.GetId(), " "), method), " positions length for particular symbol should be less than 4, returned "), exchange.Json(positionsForSymbols)))
				now = exchange.Milliseconds()
				for i := 0; IsLessThan(i, GetArrayLength(positionsForSymbols)); i++ {
					TestPosition(exchange, skippedProperties, method, GetValue(positionsForSymbols, i), symbol, now)
				}
				AssertTimestampOrder(exchange, method, symbol, positionsForSymbols)
			}
		}

		ch <- true
		return nil

	}()
	return ch
}
