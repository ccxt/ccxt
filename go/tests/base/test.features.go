package base
import "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


    func TestFeatures(exchange ccxt.IExchange, skippedProperties interface{}) <- chan interface{} {
                ch := make(chan interface{})
                go func() interface{} {
                    defer close(ch)
                    defer ReturnPanicError(ch)
                        var marketTypes interface{} = []interface{}{"spot", "swap", "future", "option"}
                var subTypes interface{} = []interface{}{"linear", "inverse"}
                var features interface{} = exchange.GetFeatures()
                var keys interface{} = ObjectKeys(features)
                for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
                    AssertInArray(exchange, skippedProperties, "features", keys, i, marketTypes)
                    var marketType interface{} = GetValue(keys, i)
                    var value interface{} = GetValue(features, marketType)
                    // Assert (value !== undefined, 'exchange.features["' + marketType + '"] is undefined, that key should be either absent or have a value');
                    if IsTrue(IsEqual(value, nil)) {
                        continue
                    }
                    if IsTrue(IsEqual(marketType, "spot")) {
                        TestFeaturesInner(exchange, skippedProperties, value)
                    } else {
                        var subKeys interface{} = ObjectKeys(value)
                        for j := 0; IsLessThan(j, GetArrayLength(subKeys)); j++ {
                            var subKey interface{} = GetValue(subKeys, j)
                            AssertInArray(exchange, skippedProperties, "features", subKeys, j, subTypes)
                            var subValue interface{} = GetValue(value, subKey)
                            // sometimes it might not be available for exchange, eg. future>inverse)
                            if IsTrue(!IsEqual(subValue, nil)) {
                                TestFeaturesInner(exchange, skippedProperties, subValue)
                            }
                        }
                    }
                }
            
                ch <- true
                return nil
            
                }()
                return ch
            }
    func TestFeaturesInner(exchange ccxt.IExchange, skippedProperties interface{}, featureObj interface{})  {
        var format interface{} = map[string]interface{} {
            "sandbox": false,
            "createOrder": map[string]interface{} {
                "marginMode": false,
                "triggerPrice": false,
                "triggerPriceType": map[string]interface{} {
                    "mark": false,
                    "last": false,
                    "index": false,
                },
                "stopLossPrice": false,
                "takeProfitPrice": false,
                "attachedStopLossTakeProfit": map[string]interface{} {
                    "triggerPriceType": map[string]interface{} {
                        "last": false,
                        "mark": false,
                        "index": false,
                    },
                    "price": false,
                },
                "timeInForce": map[string]interface{} {
                    "GTC": false,
                    "IOC": false,
                    "FOK": false,
                    "PO": false,
                    "GTD": false,
                },
                "hedged": false,
                "trailing": false,
            },
            "createOrders": map[string]interface{} {
                "max": 5,
            },
            "fetchMyTrades": map[string]interface{} {
                "marginMode": false,
                "daysBack": 0,
                "limit": 0,
                "untilDays": 0,
                "symbolRequired": false,
            },
            "fetchOrder": map[string]interface{} {
                "marginMode": false,
                "trigger": false,
                "trailing": false,
                "symbolRequired": false,
            },
            "fetchOpenOrders": map[string]interface{} {
                "marginMode": false,
                "limit": 0,
                "trigger": false,
                "trailing": false,
                "symbolRequired": false,
            },
            "fetchOrders": map[string]interface{} {
                "marginMode": false,
                "limit": 0,
                "daysBack": 0,
                "untilDays": 0,
                "trigger": false,
                "trailing": false,
                "symbolRequired": false,
            },
            "fetchClosedOrders": map[string]interface{} {
                "marginMode": false,
                "limit": 0,
                "daysBack": 0,
                "daysBackCanceled": 0,
                "untilDays": 0,
                "trigger": false,
                "trailing": false,
                "symbolRequired": false,
            },
            "fetchOHLCV": map[string]interface{} {
                "limit": 0,
            },
        }
        var featureKeys interface{} = ObjectKeys(featureObj)
        var allMethods interface{} = ObjectKeys(exchange.GetHas())
        for i := 0; IsLessThan(i, GetArrayLength(featureKeys)); i++ {
            AssertInArray(exchange, skippedProperties, "features", featureKeys, i, allMethods)
            AssertStructure(exchange, skippedProperties, "features", featureObj, format, nil, true) // deep structure check
        }
    }
