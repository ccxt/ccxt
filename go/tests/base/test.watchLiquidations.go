package base
import "github.com/ccxt/ccxt/go/v4"
import "fmt"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


    func TestWatchLiquidations(exchange ccxt.ICoreExchange, skippedProperties interface{}, symbol interface{}) <- chan interface{} {
                ch := make(chan interface{})
                go func() interface{} {
                    defer close(ch)
                    defer ReturnPanicError(ch)
                        // log (symbol.green, 'watching trades...')
                var method interface{} = "watchLiquidations"
                // we have to skip some exchanges here due to the frequency of trading
                var skippedExchanges interface{} = []interface{}{}
                if IsTrue(exchange.InArray(exchange.GetId(), skippedExchanges)) {
                    fmt.Println(exchange.GetId(), Add(method, "() test skipped"))
            
                    ch <- false
                    return nil
                }
                if !IsTrue(GetValue(exchange.GetHas(), method)) {
                    fmt.Println(exchange.GetId(), "does not support", Add(method, "() method"))
            
                    ch <- false
                    return nil
                }
                var response interface{} = nil
                var now interface{} = DateNow()
                var ends interface{} = Add(now, 10000)
                for IsLessThan(now, ends) {
                    
                        {
                             func() (ret_ interface{}) {
                    		    defer func() {
                                    if e := recover(); e != nil {
                                        if e == "break" {
                                            return
                                        }
                                        ret_ = func() interface{} {
                                            // catch block:
                                                        if !IsTrue((IsInstance(e, NetworkError))) {
                                    panic(e)
                                }
                                now = DateNow()
                                            return nil
                                        }()
                                    }
                                }()
                    		    // try block:
                                            
                        response = (<-callDynamically(method, symbol))
                                    PanicOnError(response)
                                now = DateNow()
                                var isArray interface{} = IsArray(response)
                                Assert(isArray, "response must be an array")
                                fmt.Println(exchange.Iso8601(now), exchange.GetId(), symbol, method, GetArrayLength(ObjectValues(response)), "liquidations")
                                // log.noLocate (asTable (response))
                                for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
                                    TestLiquidation(exchange, skippedProperties, method, GetValue(response, i), symbol)
                                }
                    		    return nil
                    	    }()
                        
                            }
                }
            
                ch <- response
                return nil
            
                }()
                return ch
            }
