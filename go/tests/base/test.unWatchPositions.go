package base

import "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

func CreateOrderAfterDelay(exchange ccxt.ICoreExchange) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)

		retRes54 := (<-exchange.Sleep(3000))
		PanicOnError(retRes54)

		retRes64 := (<-exchange.CreateOrder("BTC/USDT:USDT", "market", "buy", 0.001))
		PanicOnError(retRes64)
		return nil
	}()
	return ch
}
func TestUnWatchPositions(exchange ccxt.ICoreExchange, skippedProperties interface{}, symbol interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		var method interface{} = "unWatchPositions"
		exchange.SetSandboxMode(true)
		// First, we need to subscribe to positions to test the unsubscribe functionality
		var positionsSubscription interface{} = nil

		{
			func() (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func() interface{} {
							// catch block:
							if !IsTrue(IsTemporaryFailure(e)) {
								panic(e)
							}

							// If we can't subscribe, we can't test unsubscribe, so skip this test
							ch <- false
							return nil

						}()
					}
				}()
				// try block:
				// First call uses snapshot

				positionsSubscription = (UnWrapType(<-exchange.WatchPositions()))
				PanicOnError(positionsSubscription)
				// trigger a position update
				exchange.Spawn(CreateOrderAfterDelay, exchange)
				// Second call uses subscription

				positionsSubscription = (UnWrapType(<-exchange.WatchPositions()))
				PanicOnError(positionsSubscription)
				return nil
			}()

		}
		// Verify that we have a subscription
		Assert(IsArray(positionsSubscription), Add(Add(Add(exchange.GetId(), " "), method), " requires a valid positions subscription to test unsubscribe"))
		// Assert unWatchPositions for one symbol is not supported
		var errorResponse interface{} = nil

		{
			func() (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func() interface{} {
							// catch block:
							errorResponse = e
							return nil
						}()
					}
				}()
				// try block:

				errorResponse = (<-exchange.UnWatchPositions([]interface{}{symbol}))
				PanicOnError(errorResponse)
				return nil
			}()

		}
		Assert(!IsEqual(errorResponse, nil), Add(Add(Add(Add(exchange.GetId(), " "), method), " must throw an error when unwatching a specific symbol, returned "), exchange.Json(errorResponse)))
		// Test unwatching all positions (without specific symbols)
		var responseAll interface{} = nil

		{
			func() (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func() interface{} {
							// catch block:
							if !IsTrue(IsTemporaryFailure(e)) {
								panic(e)
							}
							panic(e)

						}()
					}
				}()
				// try block:

				responseAll = (<-exchange.UnWatchPositions())
				PanicOnError(responseAll)
				return nil
			}()

		}
		// Verify the response for unwatching all positions
		Assert(!IsEqual(responseAll, nil), Add(Add(Add(Add(exchange.GetId(), " "), method), " must return a response when unwatching all positions, returned "), exchange.Json(responseAll)))
		// Test that we can resubscribe after unwatching (to ensure cleanup was proper)
		var resubscribeResponse interface{} = nil

		{
			func() (ret_ interface{}) {
				defer func() {
					if e := recover(); e != nil {
						if e == "break" {
							return
						}
						ret_ = func() interface{} {
							// catch block:
							if !IsTrue(IsTemporaryFailure(e)) {
								panic(e)
							}
							panic(Error(Add(Add(Add(exchange.GetId(), " "), method), " failed to resubscribe after unwatch, indicating potential cleanup issues")))

						}()
					}
				}()
				// try block:

				resubscribeResponse = (UnWrapType(<-exchange.WatchPositions()))
				PanicOnError(resubscribeResponse)
				exchange.Spawn(CreateOrderAfterDelay, exchange)

				resubscribeResponse = (UnWrapType(<-exchange.WatchPositions()))
				PanicOnError(resubscribeResponse)
				return nil
			}()

		}
		// Verify resubscription works
		Assert(IsArray(resubscribeResponse), Add(Add(Add(Add(exchange.GetId(), " "), method), " must allow resubscription after unwatch, returned "), exchange.Json(resubscribeResponse)))

		ch <- true
		return nil

	}()
	return ch
}
