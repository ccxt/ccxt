package base

import "github.com/ccxt/ccxt/go/v4"

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

func TestWatchBidsAsks(exchange ccxt.ICoreExchange, skippedProperties interface{}, symbol interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		var withoutSymbol interface{} = TestWatchBidsAsksHelper(exchange, skippedProperties, nil)
		var withSymbol interface{} = TestWatchBidsAsksHelper(exchange, skippedProperties, []interface{}{symbol})

		retRes114 := (<-promiseAll([]interface{}{withSymbol, withoutSymbol}))
		PanicOnError(retRes114)
		return nil
	}()
	return ch
}
func TestWatchBidsAsksHelper(exchange ccxt.ICoreExchange, skippedProperties interface{}, argSymbols interface{}, optionalArgs ...interface{}) <-chan interface{} {
	ch := make(chan interface{})
	go func() interface{} {
		defer close(ch)
		defer ReturnPanicError(ch)
		argParams := GetArg(optionalArgs, 0, map[string]interface{}{})
		_ = argParams
		var method interface{} = "watchBidsAsks"
		var now interface{} = exchange.Milliseconds()
		var ends interface{} = Add(now, 15000)
		for IsLessThan(now, ends) {
			var success interface{} = true
			var shouldReturn interface{} = false
			var response interface{} = nil

			{
				func() (ret_ interface{}) {
					defer func() {
						if e := recover(); e != nil {
							if e == "break" {
								return
							}
							ret_ = func() interface{} {
								// catch block:
								// for some exchanges, multi symbol methods might require symbols array to be present, so
								// so, if method throws "arguments-required" exception, we don't fail test, but just skip silently,
								// because tests will make a second call of this method with symbols array
								if IsTrue(IsTrue((IsInstance(e, ArgumentsRequired))) && IsTrue((IsTrue(IsEqual(argSymbols, nil)) || IsTrue(IsEqual(GetArrayLength(argSymbols), 0))))) {
									// todo: provide random symbols to try
									// return false;
									shouldReturn = true
								} else if !IsTrue(IsTemporaryFailure(e)) {
									panic(e)
								}
								now = exchange.Milliseconds()
								// continue;
								success = false
								return nil
							}()
						}
					}()
					// try block:

					response = (UnWrapType(<-exchange.WatchBidsAsks(argSymbols, argParams)))
					PanicOnError(response)
					return nil
				}()

			}
			if IsTrue(shouldReturn) {

				ch <- false
				return nil
			}
			if IsTrue(IsEqual(success, true)) {
				Assert(IsObject(response), Add(Add(Add(Add(Add(Add(exchange.GetId(), " "), method), " "), exchange.Json(argSymbols)), " must return an object. "), exchange.Json(response)))
				var values interface{} = ObjectValues(response)
				var checkedSymbol interface{} = nil
				if IsTrue(IsTrue(!IsEqual(argSymbols, nil)) && IsTrue(IsEqual(GetArrayLength(argSymbols), 1))) {
					checkedSymbol = GetValue(argSymbols, 0)
				}
				AssertNonEmtpyArray(exchange, skippedProperties, method, values, checkedSymbol)
				for i := 0; IsLessThan(i, GetArrayLength(values)); i++ {
					var ticker interface{} = GetValue(values, i)
					TestTicker(exchange, skippedProperties, method, ticker, checkedSymbol)
				}
				now = exchange.Milliseconds()
				now = exchange.Milliseconds()
			}
		}

		ch <- true
		return nil

	}()
	return ch
}
