package cache

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

// ----------------------------------------------------------------------------

func TestWsCache()  {
    arrayCache := NewArrayCache(3)
    arrayCache.Append(map[string]interface{} {
        "symbol": "BTC/USDT",
        "data": 1,
    })
    arrayCache.Append(map[string]interface{} {
        "symbol": "BTC/USDT",
        "data": 2,
    })
    arrayCache.Append(map[string]interface{} {
        "symbol": "BTC/USDT",
        "data": 3,
    })
    arrayCache.Append(map[string]interface{} {
        "symbol": "BTC/USDT",
        "data": 4,
    })
    Assert(Equals(arrayCache, []interface{}{map[string]interface{} {
    "symbol": "BTC/USDT",
    "data": 2,
}, map[string]interface{} {
    "symbol": "BTC/USDT",
    "data": 3,
}, map[string]interface{} {
    "symbol": "BTC/USDT",
    "data": 4,
}}))
    arrayCache.Append(map[string]interface{} {
        "symbol": "BTC/USDT",
        "data": 5,
    })
    arrayCache.Append(map[string]interface{} {
        "symbol": "BTC/USDT",
        "data": 6,
    })
    arrayCache.Append(map[string]interface{} {
        "symbol": "BTC/USDT",
        "data": 7,
    })
    arrayCache.Append(map[string]interface{} {
        "symbol": "BTC/USDT",
        "data": 8,
    })
    Assert(Equals(arrayCache, []interface{}{map[string]interface{} {
    "symbol": "BTC/USDT",
    "data": 6,
}, map[string]interface{} {
    "symbol": "BTC/USDT",
    "data": 7,
}, map[string]interface{} {
    "symbol": "BTC/USDT",
    "data": 8,
}}))
    arrayCache.Clear()
    arrayCache.Append(map[string]interface{} {
        "symbol": "BTC/USDT",
        "data": 1,
    })
    Assert(Equals(arrayCache, []interface{}{map[string]interface{} {
    "symbol": "BTC/USDT",
    "data": 1,
}}))
    
// ----------------------------------------------------------------------------

    arraycache2 := NewArrayCache(1)
    arraycache2.Append(map[string]interface{} {
        "symbol": "BTC/USDT",
        "data": 1,
    })
    arraycache2.Append(map[string]interface{} {
        "symbol": "BTC/USDT",
        "data": 2,
    })
    Assert(Equals(arraycache2, []interface{}{map[string]interface{} {
    "symbol": "BTC/USDT",
    "data": 2,
}}))
    
// ----------------------------------------------------------------------------

    timestampCache := NewArrayCacheByTimestamp()
    var ohlcv1 interface{} = []interface{}{100, 1, 2, 3}
    var ohlcv2 interface{} = []interface{}{200, 5, 6, 7}
    timestampCache.Append(ohlcv1)
    timestampCache.Append(ohlcv2)
    Assert(Equals(timestampCache, []interface{}{ohlcv1, ohlcv2}))
    var modify2 interface{} = []interface{}{200, 10, 11, 12}
    timestampCache.Append(modify2)
    Assert(Equals(timestampCache, []interface{}{ohlcv1, modify2}))
    
// ----------------------------------------------------------------------------

    cacheSymbolId := NewArrayCacheBySymbolById()
    var object1 interface{} = map[string]interface{} {
        "symbol": "BTC/USDT",
        "id": "abcdef",
        "i": 1,
    }
    var object2 interface{} = map[string]interface{} {
        "symbol": "ETH/USDT",
        "id": "qwerty",
        "i": 2,
    }
    var object3 interface{} = map[string]interface{} {
        "symbol": "BTC/USDT",
        "id": "abcdef",
        "i": 3,
    }
    cacheSymbolId.Append(object1)
    cacheSymbolId.Append(object2)
    cacheSymbolId.Append(object3) // should update index 0
    Assert(Equals(cacheSymbolId, []interface{}{object2, object3}))
    
// ----------------------------------------------------------------------------

    cacheSymbolId5 := NewArrayCacheBySymbolById(5)
    for i := 1; IsLessThan(i, 11); i++ {
        cacheSymbolId5.Append(map[string]interface{} {
            "symbol": "BTC/USDT",
            "id": ToString(i),
            "i": i,
        })
    }
    Assert(Equals(cacheSymbolId5, []interface{}{map[string]interface{} {
    "symbol": "BTC/USDT",
    "id": "6",
    "i": 6,
}, map[string]interface{} {
    "symbol": "BTC/USDT",
    "id": "7",
    "i": 7,
}, map[string]interface{} {
    "symbol": "BTC/USDT",
    "id": "8",
    "i": 8,
}, map[string]interface{} {
    "symbol": "BTC/USDT",
    "id": "9",
    "i": 9,
}, map[string]interface{} {
    "symbol": "BTC/USDT",
    "id": "10",
    "i": 10,
}}))
    for i := 1; IsLessThan(i, 11); i++ {
        cacheSymbolId5.Append(map[string]interface{} {
            "symbol": "BTC/USDT",
            "id": ToString(i),
            "i": Add(i, 10),
        })
    }
    Assert(Equals(cacheSymbolId5, []interface{}{map[string]interface{} {
    "symbol": "BTC/USDT",
    "id": "6",
    "i": 16,
}, map[string]interface{} {
    "symbol": "BTC/USDT",
    "id": "7",
    "i": 17,
}, map[string]interface{} {
    "symbol": "BTC/USDT",
    "id": "8",
    "i": 18,
}, map[string]interface{} {
    "symbol": "BTC/USDT",
    "id": "9",
    "i": 19,
}, map[string]interface{} {
    "symbol": "BTC/USDT",
    "id": "10",
    "i": 20,
}}))
    var middle interface{} = map[string]interface{} {
        "symbol": "BTC/USDT",
        "id": "8",
        "i": 28,
    }
    cacheSymbolId5.Append(middle)
    Assert(Equals(cacheSymbolId5, []interface{}{map[string]interface{} {
    "symbol": "BTC/USDT",
    "id": "6",
    "i": 16,
}, map[string]interface{} {
    "symbol": "BTC/USDT",
    "id": "7",
    "i": 17,
}, map[string]interface{} {
    "symbol": "BTC/USDT",
    "id": "9",
    "i": 19,
}, map[string]interface{} {
    "symbol": "BTC/USDT",
    "id": "10",
    "i": 20,
}, map[string]interface{} {
    "symbol": "BTC/USDT",
    "id": "8",
    "i": 28,
}}))
    var otherMiddle interface{} = map[string]interface{} {
        "symbol": "BTC/USDT",
        "id": "7",
        "i": 27,
    }
    cacheSymbolId5.Append(otherMiddle)
    Assert(Equals(cacheSymbolId5, []interface{}{map[string]interface{} {
    "symbol": "BTC/USDT",
    "id": "6",
    "i": 16,
}, map[string]interface{} {
    "symbol": "BTC/USDT",
    "id": "9",
    "i": 19,
}, map[string]interface{} {
    "symbol": "BTC/USDT",
    "id": "10",
    "i": 20,
}, map[string]interface{} {
    "symbol": "BTC/USDT",
    "id": "8",
    "i": 28,
}, map[string]interface{} {
    "symbol": "BTC/USDT",
    "id": "7",
    "i": 27,
}}))
    for i := 30; IsLessThan(i, 33); i++ {
        cacheSymbolId5.Append(map[string]interface{} {
            "symbol": "BTC/USDT",
            "id": ToString(i),
            "i": Add(i, 10),
        })
    }
    Assert(Equals(cacheSymbolId5, []interface{}{map[string]interface{} {
    "symbol": "BTC/USDT",
    "id": "8",
    "i": 28,
}, map[string]interface{} {
    "symbol": "BTC/USDT",
    "id": "7",
    "i": 27,
}, map[string]interface{} {
    "symbol": "BTC/USDT",
    "id": "30",
    "i": 40,
}, map[string]interface{} {
    "symbol": "BTC/USDT",
    "id": "31",
    "i": 41,
}, map[string]interface{} {
    "symbol": "BTC/USDT",
    "id": "32",
    "i": 42,
}}))
    var first interface{} = map[string]interface{} {
        "symbol": "BTC/USDT",
        "id": "8",
        "i": 38,
    }
    cacheSymbolId5.Append(first)
    Assert(Equals(cacheSymbolId5, []interface{}{map[string]interface{} {
    "symbol": "BTC/USDT",
    "id": "7",
    "i": 27,
}, map[string]interface{} {
    "symbol": "BTC/USDT",
    "id": "30",
    "i": 40,
}, map[string]interface{} {
    "symbol": "BTC/USDT",
    "id": "31",
    "i": 41,
}, map[string]interface{} {
    "symbol": "BTC/USDT",
    "id": "32",
    "i": 42,
}, map[string]interface{} {
    "symbol": "BTC/USDT",
    "id": "8",
    "i": 38,
}}))
    var another interface{} = map[string]interface{} {
        "symbol": "BTC/USDT",
        "id": "30",
        "i": 50,
    }
    cacheSymbolId5.Append(another)
    Assert(Equals(cacheSymbolId5, []interface{}{map[string]interface{} {
    "symbol": "BTC/USDT",
    "id": "7",
    "i": 27,
}, map[string]interface{} {
    "symbol": "BTC/USDT",
    "id": "31",
    "i": 41,
}, map[string]interface{} {
    "symbol": "BTC/USDT",
    "id": "32",
    "i": 42,
}, map[string]interface{} {
    "symbol": "BTC/USDT",
    "id": "8",
    "i": 38,
}, map[string]interface{} {
    "symbol": "BTC/USDT",
    "id": "30",
    "i": 50,
}}))
    
// ----------------------------------------------------------------------------

    // test ArrayCacheBySymbolById limit with symbol set
    var symbol interface{} = "BTC/USDT"
    cacheSymbolId2 := NewArrayCacheBySymbolById()
    var initialLength interface{} = 5
    for i := 0; IsLessThan(i, initialLength); i++ {
        cacheSymbolId2.Append(map[string]interface{} {
            "symbol": symbol,
            "id": ToString(i),
            "i": i,
        })
    }
    var limited interface{} = cacheSymbolId2.GetLimit(symbol, nil)
    Assert(IsEqual(initialLength, limited))
    
// ----------------------------------------------------------------------------

    cacheSymbolId3 := NewArrayCacheBySymbolById()
    var appendItemsLength interface{} = 3
    for i := 0; IsLessThan(i, appendItemsLength); i++ {
        cacheSymbolId3.Append(map[string]interface{} {
            "symbol": symbol,
            "id": ToString(i),
            "i": i,
        })
    }
    var outsideLimit interface{} = 5
    limited = cacheSymbolId3.GetLimit(symbol, outsideLimit)
    Assert(IsEqual(appendItemsLength, limited))
    outsideLimit = 2 // if limit < newsUpdate that should be returned
    limited = cacheSymbolId3.GetLimit(symbol, outsideLimit)
    Assert(IsEqual(outsideLimit, limited))
    
// ----------------------------------------------------------------------------

    // test ArrayCacheBySymbolById limit with symbol undefined
    symbol = "BTC/USDT"
    cacheSymbolId4 := NewArrayCacheBySymbolById()
    initialLength = 5
    for i := 0; IsLessThan(i, initialLength); i++ {
        cacheSymbolId4.Append(map[string]interface{} {
            "symbol": symbol,
            "id": ToString(i),
            "i": i,
        })
    }
    limited = cacheSymbolId4.GetLimit(nil, nil)
    Assert(IsEqual(initialLength, limited))
    
// ----------------------------------------------------------------------------

    cacheSymbolId6 := NewArrayCacheBySymbolById()
    appendItemsLength = 3
    for i := 0; IsLessThan(i, appendItemsLength); i++ {
        cacheSymbolId6.Append(map[string]interface{} {
            "symbol": symbol,
            "id": ToString(i),
            "i": i,
        })
    }
    outsideLimit = 5
    limited = cacheSymbolId6.GetLimit(symbol, outsideLimit)
    Assert(IsEqual(appendItemsLength, limited))
    outsideLimit = 2 // if limit < newsUpdate that should be returned
    limited = cacheSymbolId6.GetLimit(symbol, outsideLimit)
    Assert(IsEqual(outsideLimit, limited))
    
// ----------------------------------------------------------------------------

    // test ArrayCacheBySymbolById, same order should not increase the limit
    cacheSymbolId7 := NewArrayCacheBySymbolById()
    symbol = "BTC/USDT"
    var otherSymbol interface{} = "ETH/USDT"
    cacheSymbolId7.Append(map[string]interface{} {
        "symbol": symbol,
        "id": "singleId",
        "i": 3,
    })
    cacheSymbolId7.Append(map[string]interface{} {
        "symbol": symbol,
        "id": "singleId",
        "i": 3,
    })
    cacheSymbolId7.Append(map[string]interface{} {
        "symbol": otherSymbol,
        "id": "singleId",
        "i": 3,
    })
    outsideLimit = 5
    limited = cacheSymbolId7.GetLimit(symbol, outsideLimit)
    var limited2 interface{} = cacheSymbolId7.GetLimit(nil, outsideLimit)
    Assert(IsEqual(limited, 1))
    Assert(IsEqual(limited2, 2))
    
// ----------------------------------------------------------------------------

    // test testLimitArrayCacheByTimestamp limit
    timestampCache2 := NewArrayCacheByTimestamp()
    initialLength = 5
    for i := 0; IsLessThan(i, initialLength); i++ {
        timestampCache2.Append([]interface{}{Multiply(i, 10), Multiply(i, 10), Multiply(i, 10), Multiply(i, 10)})
    }
    limited = timestampCache2.GetLimit(nil, nil)
    Assert(IsEqual(initialLength, limited))
    appendItemsLength = 3
    for i := 0; IsLessThan(i, appendItemsLength); i++ {
        timestampCache2.Append([]interface{}{Multiply(i, 4), Multiply(i, 4), Multiply(i, 4), Multiply(i, 4)})
    }
    outsideLimit = 5
    limited = timestampCache2.GetLimit(nil, outsideLimit)
    Assert(IsEqual(appendItemsLength, limited))
    outsideLimit = 2 // if limit < newsUpdate that should be returned
    limited = timestampCache2.GetLimit(nil, outsideLimit)
    Assert(IsEqual(outsideLimit, limited))
    
// ----------------------------------------------------------------------------

    // test ArrayCacheBySymbolById, watch all orders, same symbol and order id gets updated
    cacheSymbolId8 := NewArrayCacheBySymbolById()
    symbol = "BTC/USDT"
    outsideLimit = 5
    cacheSymbolId8.Append(map[string]interface{} {
        "symbol": symbol,
        "id": "oneId",
        "i": 3,
    }) // create first order
    cacheSymbolId8.GetLimit(nil, outsideLimit) // watch all orders
    cacheSymbolId8.Append(map[string]interface{} {
        "symbol": symbol,
        "id": "oneId",
        "i": 4,
    }) // first order is closed
    cacheSymbolId8.GetLimit(nil, outsideLimit) // watch all orders
    cacheSymbolId8.Append(map[string]interface{} {
        "symbol": symbol,
        "id": "twoId",
        "i": 5,
    }) // create second order
    cacheSymbolId8.GetLimit(nil, outsideLimit) // watch all orders
    cacheSymbolId8.Append(map[string]interface{} {
        "symbol": symbol,
        "id": "twoId",
        "i": 6,
    }) // second order is closed
    limited = cacheSymbolId8.GetLimit(nil, outsideLimit) // watch all orders
    Assert(IsEqual(limited, 1)) // one new update
    
// ----------------------------------------------------------------------------

    // test ArrayCacheBySymbolById, watch all orders, and watchOrders (symbol) work independently
    cacheSymbolId9 := NewArrayCacheBySymbolById()
    symbol = "BTC/USDT"
    var symbol2 interface{} = "ETH/USDT"
    outsideLimit = 5
    cacheSymbolId9.Append(map[string]interface{} {
        "symbol": symbol,
        "id": "one",
        "i": 1,
    }) // create first order
    cacheSymbolId9.Append(map[string]interface{} {
        "symbol": symbol2,
        "id": "two",
        "i": 1,
    }) // create second order
    Assert(IsEqual(cacheSymbolId9.GetLimit(nil, outsideLimit), 2)) // watch all orders
    Assert(IsEqual(cacheSymbolId9.GetLimit(symbol, outsideLimit), 1)) // watch by symbol
    cacheSymbolId9.Append(map[string]interface{} {
        "symbol": symbol,
        "id": "one",
        "i": 2,
    }) // update first order
    cacheSymbolId9.Append(map[string]interface{} {
        "symbol": symbol2,
        "id": "two",
        "i": 2,
    }) // update second order
    Assert(IsEqual(cacheSymbolId9.GetLimit(symbol, outsideLimit), 1)) // watch by symbol
    Assert(IsEqual(cacheSymbolId9.GetLimit(nil, outsideLimit), 2)) // watch all orders
    cacheSymbolId9.Append(map[string]interface{} {
        "symbol": symbol2,
        "id": "two",
        "i": 3,
    }) // update second order
    cacheSymbolId9.Append(map[string]interface{} {
        "symbol": symbol2,
        "id": "three",
        "i": 3,
    }) // create third order
    Assert(IsEqual(cacheSymbolId9.GetLimit(nil, outsideLimit), 2)) // watch all orders
    
// ----------------------------------------------------------------------------

    // test ArrayCacheBySymbolBySide, watch all positions, same symbol and side id gets updated
    cacheSymbolSide := NewArrayCacheBySymbolBySide()
    symbol = "BTC/USDT"
    outsideLimit = 5
    cacheSymbolSide.Append(map[string]interface{} {
        "symbol": symbol,
        "side": "short",
        "contracts": 1,
    }) // create first position
    cacheSymbolSide.Append(map[string]interface{} {
        "symbol": symbol,
        "side": "short",
        "contracts": 0,
    }) // first position is closed
    Assert(IsEqual(cacheSymbolSide.GetLimit(symbol, outsideLimit), 1)) // limit position
    cacheSymbolSide.Append(map[string]interface{} {
        "symbol": symbol,
        "side": "short",
        "contracts": 1,
    }) // create first position
    Assert(IsEqual(cacheSymbolSide.GetLimit(symbol, outsideLimit), 1)) // watch all positions
    
// ----------------------------------------------------------------------------

    // test ArrayCacheBySymbolBySide, watch all positions, same symbol and side id gets updated
    cacheSymbolSide2 := NewArrayCacheBySymbolBySide()
    symbol = "BTC/USDT"
    outsideLimit = 5
    cacheSymbolSide2.Append(map[string]interface{} {
        "symbol": symbol,
        "side": "short",
        "contracts": 1,
    }) // create first position
    Assert(IsEqual(cacheSymbolSide2.GetLimit(nil, outsideLimit), 1)) // watch all positions
    cacheSymbolSide2.Append(map[string]interface{} {
        "symbol": symbol,
        "side": "short",
        "contracts": 0,
    }) // first position is closed
    Assert(IsEqual(cacheSymbolSide2.GetLimit(nil, outsideLimit), 1)) // watch all positions
    cacheSymbolSide2.Append(map[string]interface{} {
        "symbol": symbol,
        "side": "long",
        "contracts": 3,
    }) // create second position
    Assert(IsEqual(cacheSymbolSide2.GetLimit(nil, outsideLimit), 1)) // watch all positions
    cacheSymbolSide2.Append(map[string]interface{} {
        "symbol": symbol,
        "side": "long",
        "contracts": 2,
    }) // second position is reduced
    cacheSymbolSide2.Append(map[string]interface{} {
        "symbol": symbol,
        "side": "long",
        "contracts": 1,
    }) // second position is reduced
    Assert(IsEqual(cacheSymbolSide2.GetLimit(nil, outsideLimit), 1)) // watch all orders
    
// ----------------------------------------------------------------------------

    // test ArrayCacheBySymbolBySide, watchPositions, and watchPosition (symbol) work independently
    cacheSymbolSide3 := NewArrayCacheBySymbolBySide()
    symbol = "BTC/USDT"
    symbol2 = "ETH/USDT"
    cacheSymbolSide3.Append(map[string]interface{} {
        "symbol": symbol,
        "side": "short",
        "contracts": 1,
    }) // create first position
    cacheSymbolSide3.Append(map[string]interface{} {
        "symbol": symbol2,
        "side": "long",
        "contracts": 1,
    }) // create second position
    Assert(IsEqual(cacheSymbolSide3.GetLimit(nil, outsideLimit), 2)) // watch all positions
    Assert(IsEqual(cacheSymbolSide3.GetLimit(symbol, outsideLimit), 1)) // watch by symbol
    cacheSymbolSide3.Append(map[string]interface{} {
        "symbol": symbol,
        "side": "short",
        "contracts": 2,
    }) // update first position
    cacheSymbolSide3.Append(map[string]interface{} {
        "symbol": symbol2,
        "side": "long",
        "contracts": 2,
    }) // update second position
    Assert(IsEqual(cacheSymbolSide3.GetLimit(symbol, outsideLimit), 1)) // watch by symbol
    Assert(IsEqual(cacheSymbolSide3.GetLimit(nil, outsideLimit), 2)) // watch all positions
    cacheSymbolSide3.Append(map[string]interface{} {
        "symbol": symbol2,
        "side": "long",
        "contracts": 3,
    }) // update second position
    Assert(IsEqual(cacheSymbolSide3.GetLimit(nil, outsideLimit), 1)) // watch all positions
    
// ----------------------------------------------------------------------------

    // test ArrayCacheBySymbolBySide, watchPositions does not override
    cacheSymbolSide4 := NewArrayCacheBySymbolBySide()
    symbol = "BTC/USDT"
    symbol2 = "ETH/USDT"
    var symbol3 interface{} = "XRP/USDT"
    cacheSymbolSide4.Append(map[string]interface{} {
        "symbol": symbol,
        "side": "long",
        "contracts": 1,
    }) // create first position
    cacheSymbolSide4.Append(map[string]interface{} {
        "symbol": symbol2,
        "side": "long",
        "contracts": 2,
    }) // create second position
    cacheSymbolSide4.Append(map[string]interface{} {
        "symbol": symbol3,
        "side": "long",
        "contracts": 3,
    }) // create short position
    Assert(IsEqual(GetValue(GetValue(cacheSymbolSide4.ToArray(), 0), "symbol"), symbol))
    Assert(IsEqual(GetValue(GetValue(cacheSymbolSide4.ToArray(), 1), "symbol"), symbol2))
    cacheSymbolSide4.Append(map[string]interface{} {
        "symbol": symbol2,
        "side": "long",
        "contracts": 4,
    }) // update first position
    Assert(IsTrue(IsEqual(GetValue(GetValue(cacheSymbolSide4.ToArray(), 0), "contracts"), 1)) && IsTrue(IsEqual(GetValue(GetValue(cacheSymbolSide4.ToArray(), 0), "symbol"), symbol)))
    Assert(IsTrue(IsEqual(GetValue(GetValue(cacheSymbolSide4.ToArray(), 1), "contracts"), 3)) && IsTrue(IsEqual(GetValue(GetValue(cacheSymbolSide4.ToArray(), 1), "symbol"), symbol3)))
    Assert(IsTrue(IsEqual(GetValue(GetValue(cacheSymbolSide4.ToArray(), 2), "contracts"), 4)) && IsTrue(IsEqual(GetValue(GetValue(cacheSymbolSide4.ToArray(), 2), "symbol"), symbol2)))
    var arrayLength interface{} =     GetArrayLength(cacheSymbolSide4.ToArray())
    Assert(IsEqual(arrayLength, 3))
}