package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type btcalpha struct {
    Exchange

}

func NewBtcalphaCore() btcalpha {
   p := btcalpha{}
   setDefaults(&p)
   return p
}

func  (this *btcalpha) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "btcalpha",
        "name": "BTC-Alpha",
        "countries": []interface{}{"US"},
        "version": "v1",
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": false,
            "swap": false,
            "future": false,
            "option": false,
            "addMargin": false,
            "cancelOrder": true,
            "closeAllPositions": false,
            "closePosition": false,
            "createDepositAddress": false,
            "createOrder": true,
            "createReduceOnlyOrder": false,
            "createStopLimitOrder": false,
            "createStopMarketOrder": false,
            "createStopOrder": false,
            "fetchBalance": true,
            "fetchBorrowRateHistories": false,
            "fetchBorrowRateHistory": false,
            "fetchClosedOrders": true,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchDeposit": false,
            "fetchDepositAddress": false,
            "fetchDepositAddresses": false,
            "fetchDepositAddressesByNetwork": false,
            "fetchDeposits": true,
            "fetchFundingHistory": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchIndexOHLCV": false,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchL2OrderBook": true,
            "fetchLeverage": false,
            "fetchMarginMode": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrders": true,
            "fetchPosition": false,
            "fetchPositionHistory": false,
            "fetchPositionMode": false,
            "fetchPositions": false,
            "fetchPositionsForSymbol": false,
            "fetchPositionsHistory": false,
            "fetchPositionsRisk": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTrades": true,
            "fetchTradingFee": false,
            "fetchTradingFees": false,
            "fetchTransfer": false,
            "fetchTransfers": false,
            "fetchWithdrawal": false,
            "fetchWithdrawals": true,
            "reduceMargin": false,
            "setLeverage": false,
            "setMarginMode": false,
            "setPositionMode": false,
            "transfer": false,
            "withdraw": false,
        },
        "timeframes": map[string]interface{} {
            "5m": "5",
            "15m": "15",
            "30m": "30",
            "1h": "60",
            "4h": "240",
            "1d": "D",
        },
        "urls": map[string]interface{} {
            "logo": "https://github.com/user-attachments/assets/dce49f3a-61e5-4ba0-a2fe-41d192fd0e5d",
            "api": map[string]interface{} {
                "rest": "https://btc-alpha.com/api",
            },
            "www": "https://btc-alpha.com",
            "doc": "https://btc-alpha.github.io/api-docs",
            "fees": "https://btc-alpha.com/fees/",
            "referral": "https://btc-alpha.com/?r=123788",
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": []interface{}{"currencies/", "pairs/", "orderbook/{pair_name}", "exchanges/", "charts/{pair}/{type}/chart/", "ticker/"},
            },
            "private": map[string]interface{} {
                "get": []interface{}{"wallets/", "orders/own/", "order/{id}/", "exchanges/own/", "deposits/", "withdraws/"},
                "post": []interface{}{"order/", "order-cancel/"},
            },
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "maker": this.ParseNumber("0.002"),
                "taker": this.ParseNumber("0.002"),
            },
            "funding": map[string]interface{} {
                "withdraw": map[string]interface{} {},
            },
        },
        "commonCurrencies": map[string]interface{} {
            "CBC": "Cashbery",
        },
        "features": map[string]interface{} {
            "spot": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": false,
                    "triggerPriceType": nil,
                    "triggerDirection": false,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": false,
                        "FOK": false,
                        "PO": false,
                        "GTD": false,
                    },
                    "hedged": false,
                    "leverage": false,
                    "marketBuyRequiresPrice": false,
                    "marketBuyByCost": false,
                    "selfTradePrevention": false,
                    "trailing": false,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": nil,
                    "untilDays": nil,
                    "symbolRequired": false,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 2000,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 2000,
                    "daysBack": nil,
                    "untilDays": nil,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchClosedOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 2000,
                    "daysBack": nil,
                    "daysBackCanceled": nil,
                    "untilDays": nil,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOHLCV": map[string]interface{} {
                    "max": 720,
                },
            },
            "swap": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "precisionMode": TICK_SIZE,
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {},
            "broad": map[string]interface{} {
                "Out of balance": InsufficientFunds,
            },
        },
    })
}
/**
 * @method
 * @name btcalpha#fetchMarkets
 * @description retrieves data on all markets for btcalpha
 * @see https://btc-alpha.github.io/api-docs/#list-all-currencies
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *btcalpha) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetPairs(params))
            PanicOnError(response)
        
                //
            //    [
            //        {
            //            "name": "1INCH_USDT",
            //            "currency1": "1INCH",
            //            "currency2": "USDT",
            //            "price_precision": 4,
            //            "amount_precision": 2,
            //            "minimum_order_size": "0.01000000",
            //            "maximum_order_size": "900000.00000000",
            //            "minimum_order_value": "10.00000000",
            //            "liquidity_type": 10
            //        },
            //    ]
            //
        ch <- this.ParseMarkets(response)
            return nil
        
            }()
            return ch
        }
func  (this *btcalpha) ParseMarket(market interface{}) interface{}  {
    var id interface{} = this.SafeString(market, "name")
    var baseId interface{} = this.SafeString(market, "currency1")
    var quoteId interface{} = this.SafeString(market, "currency2")
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    var pricePrecision interface{} = this.SafeString(market, "price_precision")
    var priceLimit interface{} = this.ParsePrecision(pricePrecision)
    var amountLimit interface{} = this.SafeString(market, "minimum_order_size")
    return map[string]interface{} {
        "id": id,
        "symbol": Add(Add(base, "/"), quote),
        "base": base,
        "quote": quote,
        "settle": nil,
        "baseId": baseId,
        "quoteId": quoteId,
        "settleId": nil,
        "type": "spot",
        "spot": true,
        "margin": false,
        "swap": false,
        "future": false,
        "option": false,
        "active": true,
        "contract": false,
        "linear": nil,
        "inverse": nil,
        "contractSize": nil,
        "expiry": nil,
        "expiryDatetime": nil,
        "strike": nil,
        "optionType": nil,
        "precision": map[string]interface{} {
            "amount": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "amount_precision"))),
            "price": this.ParseNumber(this.ParsePrecision((pricePrecision))),
        },
        "limits": map[string]interface{} {
            "leverage": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "amount": map[string]interface{} {
                "min": this.ParseNumber(amountLimit),
                "max": this.SafeNumber(market, "maximum_order_size"),
            },
            "price": map[string]interface{} {
                "min": this.ParseNumber(priceLimit),
                "max": nil,
            },
            "cost": map[string]interface{} {
                "min": this.ParseNumber(Precise.StringMul(priceLimit, amountLimit)),
                "max": nil,
            },
        },
        "created": nil,
        "info": market,
    }
}
/**
 * @method
 * @name btcalpha#fetchTickers
 * @see https://btc-alpha.github.io/api-docs/#tickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *btcalpha) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes275822 := (<-this.LoadMarkets())
            PanicOnError(retRes275822)
        
            response:= (<-this.PublicGetTicker(params))
            PanicOnError(response)
        
                //
            //    [
            //        {
            //            "timestamp": "1674658.445272",
            //            "pair": "BTC_USDT",
            //            "last": "22476.85",
            //            "diff": "458.96",
            //            "vol": "6660.847784",
            //            "high": "23106.08",
            //            "low": "22348.29",
            //            "buy": "22508.46",
            //            "sell": "22521.11"
            //        },
            //        ...
            //    ]
            //
        ch <- this.ParseTickers(response, symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btcalpha#fetchTicker
 * @see https://btc-alpha.github.io/api-docs/#tickers
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *btcalpha) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes904945 := (<-this.LoadMarkets())
            PanicOnError(retRes904945)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "pair": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetTicker(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //    {
            //        "timestamp": "1674658.445272",
            //        "pair": "BTC_USDT",
            //        "last": "22476.85",
            //        "diff": "458.96",
            //        "vol": "6660.847784",
            //        "high": "23106.08",
            //        "low": "22348.29",
            //        "buy": "22508.46",
            //        "sell": "22521.11"
            //    }
            //
        ch <- this.ParseTicker(response, market)
            return nil
        
            }()
            return ch
        }
func  (this *btcalpha) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "timestamp": "1674658.445272",
    //        "pair": "BTC_USDT",
    //        "last": "22476.85",
    //        "diff": "458.96",
    //        "vol": "6660.847784",
    //        "high": "23106.08",
    //        "low": "22348.29",
    //        "buy": "22508.46",
    //        "sell": "22521.11"
    //    }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestampStr interface{} = this.SafeString(ticker, "timestamp")
    var timestamp interface{} = ParseInt(Precise.StringMul(timestampStr, "1000000"))
    var marketId interface{} = this.SafeString(ticker, "pair")
    market = this.SafeMarket(marketId, market, "_")
    var last interface{} = this.SafeString(ticker, "last")
    return this.SafeTicker(map[string]interface{} {
        "info": ticker,
        "symbol": GetValue(market, "symbol"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeString(ticker, "high"),
        "low": this.SafeString(ticker, "low"),
        "bid": this.SafeString(ticker, "buy"),
        "bidVolume": nil,
        "ask": this.SafeString(ticker, "sell"),
        "askVolume": nil,
        "vwap": nil,
        "open": nil,
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": this.SafeString(ticker, "diff"),
        "percentage": nil,
        "average": nil,
        "baseVolume": nil,
        "quoteVolume": this.SafeString(ticker, "vol"),
    }, market)
}
/**
 * @method
 * @name btcalpha#fetchOrderBook
 * @see https://btc-alpha.github.io/api-docs/#get-orderbook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *btcalpha) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes966268 := (<-this.LoadMarkets())
            PanicOnError(retRes966268)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "pair_name": GetValue(market, "id"),
            }
            if IsTrue(limit) {
                AddElementToObject(request, "limit_sell", limit)
                AddElementToObject(request, "limit_buy", limit)
            }
        
            response:= (<-this.PublicGetOrderbookPairName(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseOrderBook(response, GetValue(market, "symbol"), nil, "buy", "sell", "price", "amount")
            return nil
        
            }()
            return ch
        }
func  (this *btcalpha) ParseBidsAsks(bidasks interface{}, optionalArgs ...interface{}) interface{}  {
    priceKey := GetArg(optionalArgs, 0, 0)
    _ = priceKey
    amountKey := GetArg(optionalArgs, 1, 1)
    _ = amountKey
    countOrIdKey := GetArg(optionalArgs, 2, 2)
    _ = countOrIdKey
    var result interface{} = []interface{}{}
    for i := 0; IsLessThan(i, GetArrayLength(bidasks)); i++ {
        var bidask interface{} = GetValue(bidasks, i)
        if IsTrue(bidask) {
            AppendToArray(&result,this.ParseBidAsk(bidask, priceKey, amountKey))
        }
    }
    return result
}
func  (this *btcalpha) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTrades (public)
    //
    //      {
    //          "id": "202203440",
    //          "timestamp": "1637856276.264215",
    //          "pair": "AAVE_USDT",
    //          "price": "320.79900000",
    //          "amount": "0.05000000",
    //          "type": "buy"
    //      }
    //
    // fetchMyTrades (private)
    //
    //      {
    //          "id": "202203440",
    //          "timestamp": "1637856276.264215",
    //          "pair": "AAVE_USDT",
    //          "price": "320.79900000",
    //          "amount": "0.05000000",
    //          "type": "buy",
    //          "my_side": "buy"
    //      }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(trade, "pair")
    market = this.SafeMarket(marketId, market, "_")
    var timestampRaw interface{} = this.SafeString(trade, "timestamp")
    var timestamp interface{} = this.ParseToInt(Precise.StringMul(timestampRaw, "1000000"))
    var priceString interface{} = this.SafeString(trade, "price")
    var amountString interface{} = this.SafeString(trade, "amount")
    var id interface{} = this.SafeString(trade, "id")
    var side interface{} = this.SafeString2(trade, "my_side", "type")
    return this.SafeTrade(map[string]interface{} {
        "id": id,
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": GetValue(market, "symbol"),
        "order": id,
        "type": "limit",
        "side": side,
        "takerOrMaker": nil,
        "price": priceString,
        "amount": amountString,
        "cost": nil,
        "fee": nil,
    }, market)
}
/**
 * @method
 * @name btcalpha#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://btc-alpha.github.io/api-docs/#list-all-exchanges
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *btcalpha) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes580991 := (<-this.LoadMarkets())
            PanicOnError(retRes580991)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "pair", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            trades:= (<-this.PublicGetExchanges(this.Extend(request, params)))
            PanicOnError(trades)
        
            ch <- this.ParseTrades(trades, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btcalpha#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://btc-alpha.github.io/api-docs/#list-own-deposits
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *btcalpha) FetchDeposits(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes53470 := (<-this.LoadMarkets())
            PanicOnError(retRes53470)
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
            }
        
            response:= (<-this.PrivateGetDeposits(params))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "timestamp": 1485363039.18359,
            //             "id": 317,
            //             "currency": "BTC",
            //             "amount": 530.00000000
            //         }
            //     ]
            //
        ch <- this.ParseTransactions(response, currency, since, limit, map[string]interface{} {
                "type": "deposit",
            })
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btcalpha#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @see https://btc-alpha.github.io/api-docs/#list-own-made-withdraws
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawals structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *btcalpha) FetchWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes439881 := (<-this.LoadMarkets())
            PanicOnError(retRes439881)
            var currency interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "currency_id", GetValue(currency, "id"))
            }
        
            response:= (<-this.PrivateGetWithdraws(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "id": 403,
            //             "timestamp": 1485363466.868539,
            //             "currency": "BTC",
            //             "amount": 0.53000000,
            //             "status": 20
            //         }
            //     ]
            //
        ch <- this.ParseTransactions(response, currency, since, limit, map[string]interface{} {
                "type": "withdrawal",
            })
            return nil
        
            }()
            return ch
        }
func  (this *btcalpha) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //  deposit
    //      {
    //          "timestamp": 1485363039.18359,
    //          "id": 317,
    //          "currency": "BTC",
    //          "amount": 530.00000000
    //      }
    //
    //  withdrawal
    //      {
    //          "id": 403,
    //          "timestamp": 1485363466.868539,
    //          "currency": "BTC",
    //          "amount": 0.53000000,
    //          "status": 20
    //      }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var timestamp interface{} = this.SafeTimestamp(transaction, "timestamp")
    var currencyId interface{} = this.SafeString(transaction, "currency")
    var statusId interface{} = this.SafeString(transaction, "status")
    return map[string]interface{} {
        "id": this.SafeString(transaction, "id"),
        "info": transaction,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "network": nil,
        "address": nil,
        "addressTo": nil,
        "addressFrom": nil,
        "tag": nil,
        "tagTo": nil,
        "tagFrom": nil,
        "currency": this.SafeCurrencyCode(currencyId, currency),
        "amount": this.SafeNumber(transaction, "amount"),
        "txid": nil,
        "type": nil,
        "status": this.ParseTransactionStatus(statusId),
        "comment": nil,
        "internal": nil,
        "fee": nil,
        "updated": nil,
    }
}
func  (this *btcalpha) ParseTransactionStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "10": "pending",
        "20": "pending",
        "30": "ok",
        "40": "failed",
        "50": "canceled",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *btcalpha) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "time":1591296000,
    //         "open":0.024746,
    //         "close":0.024728,
    //         "low":0.024728,
    //         "high":0.024753,
    //         "volume":16.624
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.SafeTimestamp(ohlcv, "time"), this.SafeNumber(ohlcv, "open"), this.SafeNumber(ohlcv, "high"), this.SafeNumber(ohlcv, "low"), this.SafeNumber(ohlcv, "close"), this.SafeNumber(ohlcv, "volume")}
}
/**
 * @method
 * @name btcalpha#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://btc-alpha.github.io/api-docs/#charts
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *btcalpha) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "5m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes775497 := (<-this.LoadMarkets())
            PanicOnError(retRes775497)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "pair": GetValue(market, "id"),
                "type": this.SafeString(this.Timeframes, timeframe, timeframe),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "since", this.ParseToInt(Divide(since, 1000)))
            }
        
            response:= (<-this.PublicGetChartsPairTypeChart(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         {"time":1591296000,"open":0.024746,"close":0.024728,"low":0.024728,"high":0.024753,"volume":16.624},
            //         {"time":1591295700,"open":0.024718,"close":0.02475,"low":0.024711,"high":0.02475,"volume":31.645},
            //         {"time":1591295400,"open":0.024721,"close":0.024717,"low":0.024711,"high":0.02473,"volume":65.071}
            //     ]
            //
        ch <- this.ParseOHLCVs(response, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *btcalpha) ParseBalance(response interface{}) interface{}  {
    var result interface{} = map[string]interface{} {
        "info": response,
    }
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        var balance interface{} = GetValue(response, i)
        var currencyId interface{} = this.SafeString(balance, "currency")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        AddElementToObject(account, "used", this.SafeString(balance, "reserve"))
        AddElementToObject(account, "total", this.SafeString(balance, "balance"))
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name btcalpha#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://btc-alpha.github.io/api-docs/#list-own-wallets
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *btcalpha) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes646392 := (<-this.LoadMarkets())
            PanicOnError(retRes646392)
        
            response:= (<-this.PrivateGetWallets(params))
            PanicOnError(response)
        
            ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
func  (this *btcalpha) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "1": "open",
        "2": "canceled",
        "3": "closed",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *btcalpha) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchClosedOrders / fetchOrder
    //     {
    //       "id": "923763073",
    //       "date": "1635451090368",
    //       "type": "sell",
    //       "pair": "XRP_USDT",
    //       "price": "1.00000000",
    //       "amount": "0.00000000",
    //       "status": "3",
    //       "amount_filled": "10.00000000",
    //       "amount_original": "10.0"
    //       "trades": [],
    //     }
    //
    // createOrder
    //     {
    //       "success": true,
    //       "date": "1635451754.497541",
    //       "type": "sell",
    //       "oid": "923776755",
    //       "price": "1.0",
    //       "amount": "10.0",
    //       "amount_filled": "0.0",
    //       "amount_original": "10.0",
    //       "trades": []
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(order, "pair")
    market = this.SafeMarket(marketId, market, "_")
    var symbol interface{} = GetValue(market, "symbol")
    var success interface{} = this.SafeBool(order, "success", false)
    var timestamp interface{} = nil
    if IsTrue(success) {
        timestamp = this.SafeTimestamp(order, "date")
    } else {
        timestamp = this.SafeInteger(order, "date")
    }
    var price interface{} = this.SafeString(order, "price")
    var remaining interface{} = this.SafeString(order, "amount")
    var filled interface{} = this.SafeString(order, "amount_filled")
    var amount interface{} = this.SafeString(order, "amount_original")
    var status interface{} = this.ParseOrderStatus(this.SafeString(order, "status"))
    var id interface{} = this.SafeStringN(order, []interface{}{"oid", "id", "order"})
    var trades interface{} = this.SafeValue(order, "trades")
    var side interface{} = this.SafeString2(order, "my_side", "type")
    return this.SafeOrder(map[string]interface{} {
        "id": id,
        "clientOrderId": nil,
        "datetime": this.Iso8601(timestamp),
        "timestamp": timestamp,
        "status": status,
        "symbol": symbol,
        "type": "limit",
        "timeInForce": nil,
        "postOnly": nil,
        "side": side,
        "price": price,
        "triggerPrice": nil,
        "cost": nil,
        "amount": amount,
        "filled": filled,
        "remaining": remaining,
        "trades": trades,
        "fee": nil,
        "info": order,
        "lastTradeTimestamp": nil,
        "average": nil,
    }, market)
}
/**
 * @method
 * @name btcalpha#createOrder
 * @see https://btc-alpha.github.io/api-docs/#create-order
 * @description create a trade order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *btcalpha) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(typeVar, "market")) {
                panic(InvalidOrder(Add(this.Id, " only limits orders are supported")))
            }
        
            retRes683238 := (<-this.LoadMarkets())
            PanicOnError(retRes683238)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "pair": GetValue(market, "id"),
                "type": side,
                "amount": amount,
                "price": this.PriceToPrecision(symbol, price),
            }
        
            response:= (<-this.PrivatePostOrder(this.Extend(request, params)))
            PanicOnError(response)
            if !IsTrue(GetValue(response, "success")) {
                panic(InvalidOrder(Add(Add(this.Id, " "), this.Json(response))))
            }
            var order interface{} = this.ParseOrder(response, market)
            var orderAmount interface{} = ToString(GetValue(order, "amount"))
            amount = Ternary(IsTrue(Precise.StringGt(orderAmount, "0")), GetValue(order, "amount"), amount)
            AddElementToObject(order, "amount", this.ParseNumber(amount))
        
            ch <- order
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btcalpha#cancelOrder
 * @see https://btc-alpha.github.io/api-docs/#cancel-order
 * @description cancels an open order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *btcalpha) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "order": id,
            }
        
            response:= (<-this.PrivatePostOrderCancel(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //    {
            //        "order": 63568
            //    }
            //
        ch <- this.ParseOrder(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btcalpha#fetchOrder
 * @see https://btc-alpha.github.io/api-docs/#retrieve-single-order
 * @description fetches information on an order made by the user
 * @param {string} id the order id
 * @param {string} symbol not used by btcalpha fetchOrder
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *btcalpha) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes572828 := (<-this.LoadMarkets())
            PanicOnError(retRes572828)
            var request interface{} = map[string]interface{} {
                "id": id,
            }
        
            order:= (<-this.PrivateGetOrderId(this.Extend(request, params)))
            PanicOnError(order)
        
            ch <- this.ParseOrder(order)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btcalpha#fetchOrders
 * @see https://btc-alpha.github.io/api-docs/#list-own-orders
 * @description fetches information on multiple orders made by the user
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *btcalpha) FetchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes972085 := (<-this.LoadMarkets())
            PanicOnError(retRes972085)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "pair", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            orders:= (<-this.PrivateGetOrdersOwn(this.Extend(request, params)))
            PanicOnError(orders)
        
            ch <- this.ParseOrders(orders, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btcalpha#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://btc-alpha.github.io/api-docs/#list-own-orders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *btcalpha) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "status": "1",
            }
        
                retRes504073 :=  (<-this.FetchOrders(symbol, since, limit, this.Extend(request, params)))
                PanicOnError(retRes504073)
                ch <- retRes504073
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btcalpha#fetchClosedOrders
 * @description fetches information on multiple closed orders made by the user
 * @see https://btc-alpha.github.io/api-docs/#list-own-orders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *btcalpha) FetchClosedOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "status": "3",
            }
        
                retRes490246 :=  (<-this.FetchOrders(symbol, since, limit, this.Extend(request, params)))
                PanicOnError(retRes490246)
                ch <- retRes490246
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name btcalpha#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://btc-alpha.github.io/api-docs/#list-own-exchanges
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *btcalpha) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes276044 := (<-this.LoadMarkets())
            PanicOnError(retRes276044)
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbol, nil)) {
                var market interface{} = this.Market(symbol)
                AddElementToObject(request, "pair", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            trades:= (<-this.PrivateGetExchangesOwn(this.Extend(request, params)))
            PanicOnError(trades)
        
            ch <- this.ParseTrades(trades, nil, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *btcalpha) Nonce() interface{}  {
    return this.Milliseconds()
}
func  (this *btcalpha) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var query interface{} = this.Urlencode(this.Keysort(this.Omit(params, this.ExtractParams(path))))
    var url interface{} = Add(GetValue(GetValue(this.Urls, "api"), "rest"), "/")
    if IsTrue(!IsEqual(path, "charts/{pair}/{type}/chart/")) {
        url = Add(url, "v1/")
    }
    url = Add(url, this.ImplodeParams(path, params))
    headers = map[string]interface{} {
        "Accept": "application/json",
    }
    if IsTrue(IsEqual(api, "public")) {
        if IsTrue(GetArrayLength(query)) {
            url = Add(url, Add("?", query))
        }
    } else {
        this.CheckRequiredCredentials()
        var payload interface{} = this.ApiKey
        if IsTrue(IsEqual(method, "POST")) {
            AddElementToObject(headers, "Content-Type", "application/x-www-form-urlencoded")
            body = query
            payload = Add(payload, body)
        } else if IsTrue(GetArrayLength(query)) {
            url = Add(url, Add("?", query))
        }
        AddElementToObject(headers, "X-KEY", this.ApiKey)
        AddElementToObject(headers, "X-SIGN", this.Hmac(this.Encode(payload), this.Encode(this.Secret), sha256))
        AddElementToObject(headers, "X-NONCE", ToString(this.Nonce()))
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *btcalpha) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsEqual(response, nil)) {
        return nil  // fallback to default error handler
    }
    //
    //     {"date":1570599531.4814300537,"error":"Out of balance -9.99243661 BTC"}
    //
    var error interface{} = this.SafeString(response, "error")
    if IsTrue(!IsEqual(error, nil)) {
        var feedback interface{} = Add(Add(this.Id, " "), body)
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), error, feedback)
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), error, feedback)
        panic(ExchangeError(feedback))
    }
    return nil
}


func (this *btcalpha) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
