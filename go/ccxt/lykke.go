package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type lykke struct {
    Exchange

}

func NewLykkeCore() lykke {
   p := lykke{}
   setDefaults(&p)
   return p
}

func  (this *lykke) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "lykke",
        "name": "Lykke",
        "countries": []interface{}{"UK"},
        "version": "2",
        "rateLimit": 200,
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": false,
            "swap": false,
            "future": false,
            "option": false,
            "cancelAllOrders": true,
            "cancelOrder": true,
            "createOrder": true,
            "createStopLimitOrder": false,
            "createStopMarketOrder": false,
            "createStopOrder": false,
            "editOrder": false,
            "fetchBalance": true,
            "fetchBorrowRateHistories": false,
            "fetchBorrowRateHistory": false,
            "fetchClosedOrders": true,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchCurrencies": true,
            "fetchDepositAddress": true,
            "fetchDepositAddresses": false,
            "fetchDepositAddressesByNetwork": false,
            "fetchDeposits": false,
            "fetchDepositsWithdrawals": true,
            "fetchFundingHistory": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchIndexOHLCV": false,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchMarginMode": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMyTrades": true,
            "fetchOHLCV": nil,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrders": false,
            "fetchOrderTrades": false,
            "fetchPosition": false,
            "fetchPositionHistory": false,
            "fetchPositionMode": false,
            "fetchPositions": false,
            "fetchPositionsForSymbol": false,
            "fetchPositionsHistory": false,
            "fetchPositionsRisk": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTime": false,
            "fetchTrades": true,
            "fetchTradingFee": false,
            "fetchTradingFees": false,
            "fetchTransactionFees": false,
            "fetchTransactions": "emulated",
            "fetchWithdrawals": false,
            "setLeverage": false,
            "setMarginMode": false,
            "withdraw": true,
        },
        "requiredCredentials": map[string]interface{} {
            "apiKey": true,
            "secret": false,
        },
        "urls": map[string]interface{} {
            "logo": "https://user-images.githubusercontent.com/1294454/155840500-1ea4fdf0-47c0-4daa-9597-c6c1cd51b9ec.jpg",
            "api": map[string]interface{} {
                "public": "https://hft-apiv2.lykke.com/api",
                "private": "https://hft-apiv2.lykke.com/api",
            },
            "www": "https://www.lykke.com",
            "doc": []interface{}{"https://hft-apiv2.lykke.com/swagger/ui/index.html", "https://lykkecity.github.io/Trading-API"},
            "fees": "https://support.lykke.com/hc/en-us/articles/115002141125-What-are-the-fees-and-charges-",
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": map[string]interface{} {
                    "assetpairs": 2.5,
                    "assetpairs/{id}": 2.5,
                    "assets": 2.5,
                    "assets/{id}": 2.5,
                    "isalive": 2.5,
                    "orderbooks": 2.5,
                    "tickers": 2.5,
                    "prices": 2.5,
                    "trades/public/{assetPairId}": 2.5,
                },
            },
            "private": map[string]interface{} {
                "get": map[string]interface{} {
                    "balance": 2.5,
                    "trades": 2.5,
                    "trades/order/{orderId}": 2.5,
                    "orders/active": 1,
                    "orders/closed": 1,
                    "orders/{orderId}": 1,
                    "operations": 2.5,
                    "operations/deposits/addresses": 2.5,
                    "operations/deposits/addresses/{assetId}": 2.5,
                },
                "post": map[string]interface{} {
                    "orders/limit": 1,
                    "orders/market": 1,
                    "orders/bulk": 1,
                    "operations/withdrawals": 2.5,
                    "operations/deposits/addresses": 2.5,
                },
                "delete": map[string]interface{} {
                    "orders": 1,
                    "orders/{orderId}": 1,
                },
            },
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "tierBased": false,
                "percentage": true,
                "maker": 0,
                "taker": 0,
            },
        },
        "precisionMode": TICK_SIZE,
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "1001": ExchangeError,
                "1100": ExchangeError,
                "1101": ExchangeError,
                "2000": BadRequest,
                "2001": InsufficientFunds,
                "2202": DuplicateOrderId,
                "2003": ExchangeError,
                "2004": NotSupported,
                "2005": ExchangeError,
                "2006": InsufficientFunds,
                "2007": InsufficientFunds,
                "2008": InsufficientFunds,
                "2009": ExchangeError,
                "2010": InsufficientFunds,
                "2011": InvalidOrder,
                "2012": InvalidOrder,
                "2013": InvalidOrder,
                "2014": InvalidOrder,
                "2015": InvalidOrder,
                "2016": InvalidOrder,
                "2017": InvalidOrder,
                "2018": InvalidOrder,
                "2019": InvalidOrder,
                "2020": InvalidOrder,
                "2021": InvalidOrder,
                "2022": InvalidOrder,
                "2023": ExchangeError,
            },
            "broad": map[string]interface{} {},
        },
        "commonCurrencies": map[string]interface{} {},
        "features": map[string]interface{} {
            "spot": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": false,
                    "triggerPriceType": nil,
                    "triggerDirection": false,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": false,
                        "FOK": false,
                        "PO": false,
                        "GTD": false,
                    },
                    "hedged": false,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyByCost": false,
                    "marketBuyRequiresPrice": false,
                    "selfTradePrevention": false,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": 1000,
                    "daysBack": 100000,
                    "untilDays": 100000,
                    "symbolRequired": false,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 1000,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOrders": nil,
                "fetchClosedOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 1000,
                    "daysBack": nil,
                    "daysBackCanceled": nil,
                    "untilDays": nil,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOHLCV": nil,
            },
            "swap": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
    })
}
/**
 * @method
 * @name lykke#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see https://lykkecity.github.io/Trading-API/#get-all-assets
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func  (this *lykke) FetchCurrencies(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetAssets(params))
            PanicOnError(response)
            var currencies interface{} = this.SafeValue(response, "payload", []interface{}{})
            //
            //     {
            //         "payload":[
            //             {
            //                 "assetId":"115a60c2-0da1-40f9-a7f2-41da723b9075",
            //                 "name":"Monaco Token",
            //                 "symbol":"MCO",
            //                 "accuracy":6,
            //                 "multiplierPower":8,
            //                 "assetAddress":"",
            //                 "blockchainIntegrationLayerId":"",
            //                 "blockchain":"ethereum",
            //                 "type":"erc20Token",
            //                 "isTradable":true,
            //                 "isTrusted":true,
            //                 "kycNeeded":false,
            //                 "blockchainWithdrawal":true,
            //                 "cashoutMinimalAmount":0.1,
            //                 "lowVolumeAmount":null,
            //                 "lykkeEntityId":"LYKKE NL",
            //                 "siriusAssetId":0,
            //                 "siriusBlockchainId":null,
            //                 "blockchainIntegrationType":"none",
            //                 "blockchainDepositEnabled":false,
            //                 "isDisabled":false
            //             }
            //         ],
            //         "error":null
            //     }
            //
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(currencies)); i++ {
                var currency interface{} = GetValue(currencies, i)
                var id interface{} = this.SafeString(currency, "assetId")
                var code interface{} = this.SafeString(currency, "symbol")
                var name interface{} = this.SafeString(currency, "name")
                var rawType interface{} = this.SafeString(currency, "type")
                var typeVar interface{} = Ternary(IsTrue((IsEqual(rawType, "erc20Token"))), "crypto", "other")
                var deposit interface{} = this.SafeValue(currency, "blockchainDepositEnabled")
                var withdraw interface{} = this.SafeValue(currency, "blockchainWithdrawal")
                var isDisabled interface{} = this.SafeValue(currency, "isDisabled")
                var active interface{} =         !IsTrue(isDisabled)
                AddElementToObject(result, code, map[string]interface{} {
            "id": id,
            "code": code,
            "info": currency,
            "type": typeVar,
            "name": name,
            "active": active,
            "deposit": deposit,
            "withdraw": withdraw,
            "fee": nil,
            "precision": this.ParseNumber(this.ParsePrecision(this.SafeString(currency, "accuracy"))),
            "limits": map[string]interface{} {
                "withdraw": map[string]interface{} {
                    "min": this.SafeValue(currency, "cashoutMinimalAmount"),
                    "max": nil,
                },
                "amount": map[string]interface{} {
                    "min": this.SafeValue(currency, "lowVolumeAmount"),
                    "max": nil,
                },
            },
            "networks": map[string]interface{} {},
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name lykke#fetchMarkets
 * @description retrieves data on all markets for lykke
 * @see https://lykkecity.github.io/Trading-API/#get-asset-by-id
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *lykke) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetAssetpairs(params))
            PanicOnError(response)
            var markets interface{} = this.SafeValue(response, "payload", []interface{}{})
            //
            //     {
            //         "payload":[
            //             {
            //                 "assetPairId":"AAVEBTC",
            //                 "baseAssetId":"c9e55548-dae5-44fc-bebd-e72249cb19f3",
            //                 "quoteAssetId":"BTC",
            //                 "name":"AAVE/BTC",
            //                 "priceAccuracy":6,
            //                 "baseAssetAccuracy":6,
            //                 "quoteAssetAccuracy":8,
            //                 "minVolume":0.001,
            //                 "minOppositeVolume":0.0001
            //             }
            //         ],
            //         "error":null
            //     }
            //
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(markets)); i++ {
                var market interface{} = GetValue(markets, i)
                var id interface{} = this.SafeString(market, "assetPairId")
                var name interface{} = this.SafeString(market, "name")
                var baseAssetId interface{} = this.SafeString(market, "baseAssetId")
                var quoteAssetId interface{} = this.SafeString(market, "quoteAssetId")
                baseIdquoteIdVariable := Split(name, "/");
                baseId := GetValue(baseIdquoteIdVariable,0);
                quoteId := GetValue(baseIdquoteIdVariable,1)
                var base interface{} = this.SafeCurrencyCode(baseId)
                var quote interface{} = this.SafeCurrencyCode(quoteId)
                var symbol interface{} = Add(Add(base, "/"), quote)
                AppendToArray(&result,map[string]interface{} {
                    "id": id,
                    "symbol": symbol,
                    "base": base,
                    "quote": quote,
                    "baseId": baseAssetId,
                    "quoteId": quoteAssetId,
                    "settle": nil,
                    "settleId": nil,
                    "type": "spot",
                    "spot": true,
                    "margin": false,
                    "swap": false,
                    "future": false,
                    "option": false,
                    "contract": false,
                    "active": true,
                    "linear": nil,
                    "inverse": nil,
                    "contractSize": nil,
                    "expiry": nil,
                    "expiryDatetime": nil,
                    "strike": nil,
                    "optionType": nil,
                    "precision": map[string]interface{} {
                        "amount": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "baseAssetAccuracy"))),
                        "price": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "priceAccuracy"))),
                    },
                    "limits": map[string]interface{} {
                        "amount": map[string]interface{} {
                            "min": this.SafeNumber(market, "minVolume"),
                            "max": nil,
                        },
                        "price": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "cost": map[string]interface{} {
                            "min": this.SafeNumber(market, "minOppositeVolume"),
                            "max": nil,
                        },
                        "leverage": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                    },
                    "created": nil,
                    "info": market,
                })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *lykke) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTickers
    //
    //     publicGetTickers
    //
    //     {
    //         "assetPairId":"BTCUSD",
    //         "volumeBase":2.56905016,
    //         "volumeQuote":95653.8730,
    //         "priceChange":-0.0367945778541765034194707584,
    //         "lastPrice":36840.0,
    //         "high":38371.645,
    //         "low":35903.356,
    //         "timestamp":1643295740729
    //     }
    //
    // fetchTicker
    //
    //     publicGetTickers
    //
    //     {
    //         "assetPairId":"BTCUSD",
    //         "volumeBase":2.56905016,
    //         "volumeQuote":95653.8730,
    //         "priceChange":-0.0367945778541765034194707584,
    //         "lastPrice":36840.0,
    //         "high":38371.645,
    //         "low":35903.356,
    //         "timestamp":1643295740729
    //     }
    //
    //     publicGetPrices
    //
    //     {
    //         "assetPairId":"BTCUSD",
    //         "bid":36181.521,
    //         "ask":36244.492,
    //         "timestamp":1643305510990
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = nil // temporary bug in lykke api, returns unrealistic numbers
    var marketId interface{} = this.SafeString(ticker, "assetPairId")
    market = this.SafeMarket(marketId, market)
    var close interface{} = this.SafeString(ticker, "lastPrice")
    return this.SafeTicker(map[string]interface{} {
        "symbol": this.SafeString(market, "symbol"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeString(ticker, "high"),
        "low": this.SafeString(ticker, "low"),
        "bid": this.SafeString(ticker, "bid"),
        "bidVolume": nil,
        "ask": this.SafeString(ticker, "ask"),
        "askVolume": nil,
        "vwap": nil,
        "open": nil,
        "close": close,
        "last": close,
        "previousClose": nil,
        "change": this.SafeString(ticker, "priceChange"),
        "percentage": nil,
        "average": nil,
        "baseVolume": this.SafeString(ticker, "volumeBase"),
        "quoteVolume": this.SafeString(ticker, "volumeQuote"),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name lykke#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://lykkecity.github.io/Trading-API/#get-current-prices
 * @see https://lykkecity.github.io/Trading-API/#24hr-ticker-price-change-statistics
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *lykke) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes652930 := (<-this.LoadMarkets())
            PanicOnError(retRes652930)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "assetPairIds": GetValue(market, "id"),
            }
            // publicGetTickers or publicGetPrices
            var method interface{} = this.SafeString(this.Options, "fetchTickerMethod", "publicGetTickers")
            var response interface{} = nil
            if IsTrue(IsEqual(method, "publicGetPrices")) {
                
        response = (<-this.PublicGetPrices(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PublicGetTickers(this.Extend(request, params)))
                PanicOnError(response)
            }
            var ticker interface{} = this.SafeValue(response, "payload", []interface{}{})
        
                //
            // publicGetTickers
            //
            //     {
            //         "payload":[
            //             {
            //                 "assetPairId":"BTCUSD",
            //                 "volumeBase":0.78056880,
            //                 "volumeQuote":29782.5169,
            //                 "priceChange":0.0436602362590968619931324699,
            //                 "lastPrice":38626.885,
            //                 "high":38742.896,
            //                 "low":36872.498,
            //                 "timestamp":1643687822840
            //             }
            //         ],
            //         "error":null
            //     }
            //
            // publicGetPrices
            //
            //     {
            //         "payload":[
            //             {
            //                 "assetPairId":"BTCUSD",
            //                 "bid":38597.936,
            //                 "ask":38640.311,
            //                 "timestamp":1643688350847
            //             }
            //         ],
            //         "error":null
            //     }
            //
        ch <- this.ParseTicker(this.SafeValue(ticker, 0, map[string]interface{} {}), market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name lykke#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://lykkecity.github.io/Trading-API/#24hr-ticker-price-change-statistics
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *lykke) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes355579 := (<-this.LoadMarkets())
            PanicOnError(retRes355579)
        
            response:= (<-this.PublicGetTickers(params))
            PanicOnError(response)
            var tickers interface{} = this.SafeValue(response, "payload", []interface{}{})
        
                //
            //     {
            //         "payload":[
            //             {
            //                 "assetPairId":"BTCUSD",
            //                 "volumeBase":0.78056880,
            //                 "volumeQuote":29782.5169,
            //                 "priceChange":0.0436602362590968619931324699,
            //                 "lastPrice":38626.885,
            //                 "high":38742.896,
            //                 "low":36872.498,
            //                 "timestamp":1643687822840
            //             }
            //         ],
            //         "error":null
            //     }
            //
        ch <- this.ParseTickers(tickers, symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name lykke#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://lykkecity.github.io/Trading-API/#asset-pair-order-book-ticker
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *lykke) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes406735 := (<-this.LoadMarkets())
            PanicOnError(retRes406735)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "assetPairId": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "depth", limit) // default 0
            }
        
            response:= (<-this.PublicGetOrderbooks(this.Extend(request, params)))
            PanicOnError(response)
            var payload interface{} = this.SafeValue(response, "payload", []interface{}{})
            //
            //     {
            //         "payload":[
            //             {
            //                 "assetPairId": "BTCUSD",
            //                 "timestamp": "1643298038203",
            //                 "bids": [
            //                     {
            //                         "v":0.59034382,
            //                         "p":36665.329
            //                     }
            //                 ],
            //                 "asks": [
            //                     {
            //                         "v":-0.003,
            //                         "p":36729.686
            //                     }
            //                 ]
            //             }
            //         ],
            //         "error":null
            //     }
            //
            var orderbook interface{} = this.SafeValue(payload, 0, map[string]interface{} {})
            var timestamp interface{} = this.SafeInteger(orderbook, "timestamp")
        
            ch <- this.ParseOrderBook(orderbook, GetValue(market, "symbol"), timestamp, "bids", "asks", "p", "v")
            return nil
        
            }()
            return ch
        }
func  (this *lykke) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //  public fetchTrades
    //
    //     {
    //         "id":"71df1f0c-be4e-4d45-b809-c108fad5f2a8",
    //         "assetPairId":"BTCUSD",
    //         "timestamp":1643345958414,
    //         "volume":0.00010996,
    //         "price":37205.723,
    //         "side":"buy"
    //      }
    //
    //  private fetchMyTrades
    //         {
    //             "id":"813a3ffa-1c4b-45cb-b13f-1c077ea2748b",
    //             "timestamp":1644155923357,
    //             "assetPairId":"BCHEUR",
    //             "orderId":"1b367978-7e4f-454b-b870-64040d484443",
    //             "role":"Taker",
    //             "side":"sell",
    //             "price":280.569,
    //             "baseVolume":0.01,
    //             "quoteVolume":2.8056,
    //             "baseAssetId":"2a34d6a6-5839-40e5-836f-c1178fa09b89",
    //             "quoteAssetId":"EUR",
    //             "fee":null
    //         }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(trade, "assetPairId")
    market = this.SafeMarket(marketId, market)
    var symbol interface{} = GetValue(market, "symbol")
    var id interface{} = this.SafeString2(trade, "id", "id")
    var orderId interface{} = this.SafeString(trade, "orderId")
    var timestamp interface{} = this.SafeInteger(trade, "timestamp")
    var price interface{} = this.SafeString2(trade, "price", "price")
    var amount interface{} = this.SafeString2(trade, "volume", "amount")
    if IsTrue(IsEqual(amount, nil)) {
        amount = this.SafeString2(trade, "baseVolume", "amount")
    }
    var side interface{} = this.SafeStringLower(trade, "side")
    return this.SafeTrade(map[string]interface{} {
        "id": id,
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "type": nil,
        "order": orderId,
        "side": side,
        "takerOrMaker": nil,
        "price": price,
        "amount": amount,
        "cost": nil,
        "fee": nil,
    }, market)
}
/**
 * @method
 * @name lykke#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://lykkecity.github.io/Trading-API/#get-public-trades
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *lykke) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes340251 := (<-this.LoadMarkets())
            PanicOnError(retRes340251)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "assetPairId": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "take", limit)
            }
        
            response:= (<-this.PublicGetTradesPublicAssetPairId(this.Extend(request, params)))
            PanicOnError(response)
            var result interface{} = this.SafeValue(response, "payload", []interface{}{})
        
                //
            //     {
            //         "payload":[
            //             {
            //                 "id":"71df1f0c-be4e-4d45-b809-c108fad5f2a8",
            //                 "assetPairId":"BTCUSD",
            //                 "timestamp":1643345958414,
            //                 "volume":0.00010996,
            //                 "price":37205.723,
            //                 "side":"buy"
            //             }
            //         ],
            //         "error":null
            //     }
            //
        ch <- this.ParseTrades(result, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *lykke) ParseBalance(response interface{}) interface{}  {
    //
    //     [
    //         {
    //             "assetId":"2a34d6a6-5839-40e5-836f-c1178fa09b89",
    //             "available":0.1,
    //             "reserved":0.0,
    //             "timestamp":1644146723620
    //         }
    //     ]
    //
    var result interface{} = map[string]interface{} {
        "info": response,
    }
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        var balance interface{} = GetValue(response, i)
        var currencyId interface{} = this.SafeString(balance, "assetId")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        var total interface{} = this.SafeString(balance, "available")
        var used interface{} = this.SafeString(balance, "reserved")
        AddElementToObject(account, "total", total)
        AddElementToObject(account, "used", used)
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name lykke#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://lykkecity.github.io/Trading-API/#get-the-current-balance
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *lykke) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes207153 := (<-this.LoadMarkets())
            PanicOnError(retRes207153)
        
            response:= (<-this.PrivateGetBalance(params))
            PanicOnError(response)
            var payload interface{} = this.SafeValue(response, "payload", []interface{}{})
        
                //
            //     {
            //         "payload":[
            //             {
            //                 "assetId":"2a34d6a6-5839-40e5-836f-c1178fa09b89",
            //                 "available":0.1,
            //                 "reserved":0.0,
            //                 "timestamp":1644146723620
            //             }
            //         ],
            //         "error":null
            //     }
            //
        ch <- this.ParseBalance(payload)
            return nil
        
            }()
            return ch
        }
func  (this *lykke) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "Open": "open",
        "Pending": "open",
        "InOrderBook": "open",
        "Processing": "open",
        "Matched": "closed",
        "Cancelled": "canceled",
        "Rejected": "rejected",
        "Replaced": "canceled",
        "Placed": "open",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *lykke) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "id":"1b367978-7e4f-454b-b870-64040d484443",
    //         "timestamp":1644155923357,
    //         "lastTradeTimestamp":1644155923357,
    //         "status":"Matched",
    //         "assetPairId":"BCHEUR",
    //         "type":"Market",
    //         "side":"Sell",
    //         "price":280.569,
    //         "volume":0.01,
    //         "filledVolume":0.01,
    //         "remainingVolume":0.0,
    //         "cost":2.80569
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeString(order, "id")
    var status interface{} = this.ParseOrderStatus(this.SafeString(order, "status"))
    var marketId interface{} = this.SafeString(order, "assetPairId")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var typeVar interface{} = this.SafeStringLower(order, "type")
    var lastTradeTimestamp interface{} = this.SafeInteger(order, "lastTradeTimestamp")
    var timestamp interface{} = this.SafeInteger(order, "timestamp")
    var price interface{} = this.SafeString(order, "price")
    var side interface{} = this.SafeStringLower(order, "side")
    var amount interface{} = this.SafeString(order, "volume")
    var remaining interface{} = this.SafeString(order, "remainingVolume")
    var filled interface{} = this.SafeString(order, "filledVolume")
    var cost interface{} = this.SafeString(order, "cost")
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": id,
        "clientOrderId": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": lastTradeTimestamp,
        "symbol": symbol,
        "type": typeVar,
        "timeInForce": nil,
        "postOnly": nil,
        "side": side,
        "price": price,
        "triggerPrice": nil,
        "amount": amount,
        "cost": cost,
        "average": nil,
        "filled": filled,
        "remaining": remaining,
        "status": status,
        "fee": nil,
        "trades": nil,
    }, market)
}
/**
 * @method
 * @name lykke#createOrder
 * @description create a trade order
 * @see https://lykkecity.github.io/Trading-API/#place-a-limit-order
 * @see https://lykkecity.github.io/Trading-API/#place-a-market-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *lykke) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes889401 := (<-this.LoadMarkets())
            PanicOnError(retRes889401)
            var market interface{} = this.Market(symbol)
            var query interface{} = map[string]interface{} {
                "assetPairId": GetValue(market, "id"),
                "side": this.Capitalize(side),
                "volume": ParseFloat(this.AmountToPrecision(GetValue(market, "symbol"), amount)),
            }
            if IsTrue(IsEqual(typeVar, "limit")) {
                AddElementToObject(query, "price", ParseFloat(this.PriceToPrecision(GetValue(market, "symbol"), price)))
            }
            var result interface{} = nil
            if IsTrue(IsEqual(this.Capitalize(typeVar), "Market")) {
                
        result = (<-this.PrivatePostOrdersMarket(this.Extend(query, params)))
                PanicOnError(result)
            } else {
                
        result = (<-this.PrivatePostOrdersLimit(this.Extend(query, params)))
                PanicOnError(result)
            }
            //
            // market
            //
            //         {
            //             "payload":{
            //                 "orderId":"2b98ec26-8410-49b6-9f37-1fb2150e2299",
            //                 "price":280.699
            //             },
            //             "error":null
            //         }
            //
            // limit
            //
            //         {
            //             "payload":{
            //                 "orderId":"27be8802-30be-40ca-bf40-ec886b309c5b"
            //             },
            //             "error":null
            //         }
            //
            var payload interface{} = this.SafeValue(result, "payload")
            var id interface{} = this.SafeString(payload, "orderId")
            if IsTrue(IsEqual(typeVar, "market")) {
                price = this.SafeNumber(payload, "price")
            }
        
            ch <- this.SafeOrder(map[string]interface{} {
                "id": id,
                "info": result,
                "clientOrderId": nil,
                "timestamp": nil,
                "datetime": nil,
                "lastTradeTimestamp": nil,
                "symbol": GetValue(market, "symbol"),
                "type": typeVar,
                "side": side,
                "price": price,
                "amount": amount,
                "cost": nil,
                "average": nil,
                "filled": nil,
                "remaining": nil,
                "status": nil,
                "fee": nil,
                "trades": nil,
            }, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name lykke#cancelOrder
 * @description cancels an open order
 * @see https://lykkecity.github.io/Trading-API/#cancel-orders-by-id
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *lykke) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "orderId": id,
            }
            //
            //     {
            //         "payload":null,
            //         "error":null
            //     }
            //
        
            response:= (<-this.PrivateDeleteOrdersOrderId(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.SafeOrder(map[string]interface{} {
                "info": response,
            })
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name lykke#cancelAllOrders
 * @description cancel all open orders
 * @see https://lykkecity.github.io/Trading-API/#mass-cancel-orders
 * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *lykke) CancelAllOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes560905 := (<-this.LoadMarkets())
            PanicOnError(retRes560905)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "assetPairId", GetValue(market, "id"))
            }
            //
            //     {
            //         "payload":null,
            //         "error":null
            //     }
            //
        
            response:= (<-this.PrivateDeleteOrders(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- []interface{}{this.SafeOrder(map[string]interface{} {
            "info": response,
        })}
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name lykke#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://lykkecity.github.io/Trading-API/#get-order-by-id
 * @param {string} id order id
 * @param {string} symbol not used by lykke fetchOrder
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *lykke) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes738908 := (<-this.LoadMarkets())
            PanicOnError(retRes738908)
            var request interface{} = map[string]interface{} {
                "orderId": id,
            }
        
            response:= (<-this.PrivateGetOrdersOrderId(this.Extend(request, params)))
            PanicOnError(response)
            var payload interface{} = this.SafeValue(response, "payload")
        
                //
            //     {
            //         "payload":{
            //             "id":"1b367978-7e4f-454b-b870-64040d484443",
            //             "timestamp":1644155923357,
            //             "lastTradeTimestamp":1644155923357,
            //             "status":"Matched",
            //             "assetPairId":"BCHEUR",
            //             "type":"Market",
            //             "side":"Sell",
            //             "price":280.569,
            //             "volume":0.01,
            //             "filledVolume":0.01,
            //             "remainingVolume":0.0,
            //             "cost":2.80569
            //         },
            //         "error":null
            //     }
            //
        ch <- this.ParseOrder(payload)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name lykke#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://lykkecity.github.io/Trading-API/#get-active-or-closed-orders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *lykke) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes809254 := (<-this.LoadMarkets())
            PanicOnError(retRes809254)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "take", limit)
            }
        
            response:= (<-this.PrivateGetOrdersActive(this.Extend(request, params)))
            PanicOnError(response)
            var payload interface{} = this.SafeValue(response, "payload")
        
                //
            //     {
            //         "payload":[
            //             {
            //                 "id":"b26f58f5-8542-4b4c-9815-91562b523cc3",
            //                 "timestamp":1644157177155,
            //                 "lastTradeTimestamp":null,
            //                 "status":"Placed",
            //                 "assetPairId":"BCHEUR",
            //                 "type":"Limit",
            //                 "side":"Sell",
            //                 "price":666.666,
            //                 "volume":0.01,
            //                 "filledVolume":0.00,
            //                 "remainingVolume":0.01,
            //                 "cost":0.00000
            //             }
            //         ],
            //         "error":null
            //     }
            //
        ch <- this.ParseOrders(payload, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name lykke#fetchClosedOrders
 * @description fetches information on multiple closed orders made by the user
 * @see https://lykkecity.github.io/Trading-API/#get-active-or-closed-orders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *lykke) FetchClosedOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes240424 := (<-this.LoadMarkets())
            PanicOnError(retRes240424)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "take", limit)
            }
        
            response:= (<-this.PrivateGetOrdersClosed(this.Extend(request, params)))
            PanicOnError(response)
            var payload interface{} = this.SafeValue(response, "payload")
        
                //
            //     {
            //         "payload":[
            //             {
            //                 "id":"1b367978-7e4f-454b-b870-64040d484443",
            //                 "timestamp":1644155923357,
            //                 "lastTradeTimestamp":1644155923357,
            //                 "status":"Matched",
            //                 "assetPairId":"BCHEUR",
            //                 "type":"Market",
            //                 "side":"Sell",
            //                 "price":280.569,
            //                 "volume":0.01,
            //                 "filledVolume":0.01,
            //                 "remainingVolume":0.0,
            //                 "cost":2.80569
            //             }
            //         ],
            //         "error":null
            //     }
            //
        ch <- this.ParseOrders(payload, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name lykke#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://lykkecity.github.io/Trading-API/#get-trade-history
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *lykke) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes558546 := (<-this.LoadMarkets())
            PanicOnError(retRes558546)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "take", limit) // How many maximum items have to be returned, max 1000 default 100.
            }
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "assetPairId", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "from", since)
            }
        
            response:= (<-this.PrivateGetTrades(this.Extend(request, params)))
            PanicOnError(response)
            var payload interface{} = this.SafeValue(response, "payload")
        
                //
            //     {
            //         "payload":[
            //             {
            //                 "id":"813a3ffa-1c4b-45cb-b13f-1c077ea2748b",
            //                 "timestamp":1644155923357,
            //                 "assetPairId":"BCHEUR",
            //                 "orderId":"1b367978-7e4f-454b-b870-64040d484443",
            //                 "role":"Taker",
            //                 "side":"sell",
            //                 "price":280.569,
            //                 "baseVolume":0.01,
            //                 "quoteVolume":2.8056,
            //                 "baseAssetId":"2a34d6a6-5839-40e5-836f-c1178fa09b89",
            //                 "quoteAssetId":"EUR",
            //                 "fee":null
            //             }
            //         ],
            //         "error":null
            //     }
            //
        ch <- this.ParseTrades(payload, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *lykke) ParseBidAsk(bidask interface{}, optionalArgs ...interface{}) interface{}  {
    priceKey := GetArg(optionalArgs, 0, 0)
    _ = priceKey
    amountKey := GetArg(optionalArgs, 1, 1)
    _ = amountKey
    countOrIdKey := GetArg(optionalArgs, 2, 2)
    _ = countOrIdKey
    var price interface{} = this.SafeString(bidask, priceKey)
    var amount interface{} = Precise.StringAbs(this.SafeString(bidask, amountKey))
    return []interface{}{this.ParseNumber(price), this.ParseNumber(amount)}
}
/**
 * @method
 * @name lykke#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account
 * @see https://lykkecity.github.io/Trading-API/#get-deposit-address-for-a-given-asset
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *lykke) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes338895 := (<-this.LoadMarkets())
            PanicOnError(retRes338895)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "assetId": this.SafeString(currency, "id"),
            }
        
            response:= (<-this.PrivateGetOperationsDepositsAddressesAssetId(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "assetId":"2a34d6a6-5839-40e5-836f-c1178fa09b89",
            //         "symbol":"BCH",
            //         "address":null,
            //         "baseAddress":null,
            //         "addressExtension":null,
            //         "state":"Active"
            //     }
            //
            var address interface{} = this.SafeString(response, "baseAddress")
            var tag interface{} = this.SafeString(response, "addressExtension")
            this.CheckAddress(address)
        
            ch <- map[string]interface{} {
                "info": response,
                "currency": code,
                "network": nil,
                "address": address,
                "tag": tag,
            }
            return nil
        
            }()
            return ch
        }
func  (this *lykke) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // withdraw
    //     "3035b1ad-2005-4587-a986-1f7966be78e0"
    //
    // fetchDepositsWithdrawals
    //     {
    //         "operationId":"787201c8-f1cc-45c0-aec1-fa06eeea426b",
    //         "assetId":"2a34d6a6-5839-40e5-836f-c1178fa09b89",
    //         "totalVolume":0.1,
    //         "fee":0.0,
    //         "type":"deposit",
    //         "timestamp":1644146723620
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var id interface{} = nil
    var assetId interface{} = nil
    var code interface{} = nil
    var amount interface{} = nil
    var fee interface{} = nil
    var typeVar interface{} = nil
    var timestamp interface{} = nil
    if IsTrue(IsString(transaction)) {
        id = transaction
    } else {
        id = this.SafeString(transaction, "operationId")
        assetId = this.SafeString(transaction, "assetId")
        code = this.SafeCurrencyCode(assetId, currency)
        amount = this.SafeNumber(transaction, "totalVolume")
        typeVar = this.SafeString(transaction, "type")
        timestamp = this.SafeInteger(transaction, "timestamp")
        var feeCost interface{} = this.SafeNumber(transaction, "fee")
        fee = map[string]interface{} {
            "currency": code,
            "cost": feeCost,
        }
    }
    return map[string]interface{} {
        "info": transaction,
        "id": id,
        "txid": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "network": nil,
        "addressFrom": nil,
        "address": nil,
        "addressTo": nil,
        "tagFrom": nil,
        "tag": nil,
        "tagTo": nil,
        "type": typeVar,
        "amount": amount,
        "currency": code,
        "status": nil,
        "updated": nil,
        "internal": nil,
        "comment": nil,
        "fee": fee,
    }
}
/**
 * @method
 * @name lykke#fetchDepositsWithdrawals
 * @description fetch history of deposits and withdrawals
 * @see https://lykkecity.github.io/Trading-API/#get-the-history-of-withdrawals-and-deposits
 * @param {string} [code] unified currency code for the currency of the deposit/withdrawals, default is undefined
 * @param {int} [since] timestamp in ms of the earliest deposit/withdrawal, default is undefined
 * @param {int} [limit] max number of deposit/withdrawals to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *lykke) FetchDepositsWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes478360 := (<-this.LoadMarkets())
            PanicOnError(retRes478360)
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "take", limit)
            }
        
            response:= (<-this.PrivateGetOperations(this.Extend(request, params)))
            PanicOnError(response)
            var payload interface{} = this.SafeValue(response, "payload", []interface{}{})
            //
            //     {
            //         "payload":[
            //             {
            //                 "operationId":"787201c8-f1cc-45c0-aec1-fa06eeea426b",
            //                 "assetId":"2a34d6a6-5839-40e5-836f-c1178fa09b89",
            //                 "totalVolume":0.1,
            //                 "fee":0.0,
            //                 "type":"deposit",
            //                 "timestamp":1644146723620
            //             }
            //         ],
            //         "error":null
            //     }
            //
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
            }
        
            ch <- this.ParseTransactions(payload, currency, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name lykke#withdraw
 * @description make a withdrawal
 * @see https://lykkecity.github.io/Trading-API/#withdrawal
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *lykke) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes831249 := (<-this.LoadMarkets())
            PanicOnError(retRes831249)
            this.CheckAddress(address)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "assetId": GetValue(currency, "id"),
                "volume": ParseFloat(this.CurrencyToPrecision(code, amount)),
                "destinationAddress": address,
            }
            if IsTrue(!IsEqual(tag, nil)) {
                AddElementToObject(request, "destinationAddressExtension", tag)
            }
        
            response:= (<-this.PrivatePostOperationsWithdrawals(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     "3035b1ad-2005-4587-a986-1f7966be78e0"
            //
        ch <- this.ParseTransaction(response, currency)
            return nil
        
            }()
            return ch
        }
func  (this *lykke) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var url interface{} = Add(Add(GetValue(GetValue(this.Urls, "api"), api), "/"), this.ImplodeParams(path, params))
    var query interface{} = this.Omit(params, this.ExtractParams(path))
    headers = map[string]interface{} {
        "Accept": "application/json",
        "Content-Type": "application/json",
    }
    if IsTrue(IsEqual(api, "public")) {
        if IsTrue(GetArrayLength(ObjectKeys(query))) {
            url = Add(url, Add("?", this.Urlencode(query)))
        }
    } else if IsTrue(IsEqual(api, "private")) {
        if IsTrue(IsTrue((IsEqual(method, "GET"))) || IsTrue((IsEqual(method, "DELETE")))) {
            if IsTrue(GetArrayLength(ObjectKeys(query))) {
                url = Add(url, Add("?", this.Urlencode(query)))
            }
        }
        this.CheckRequiredCredentials()
        AddElementToObject(headers, "Authorization", Add("Bearer ", this.ApiKey))
        if IsTrue(IsEqual(method, "POST")) {
            if IsTrue(GetArrayLength(ObjectKeys(params))) {
                body = this.Json(params)
            }
        }
        if IsTrue(IsEqual(path, "operations/withdrawals")) {
            AddElementToObject(headers, "X-Request-ID", this.Uuid())
        }
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *lykke) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsEqual(response, nil)) {
        return nil
    }
    var error interface{} = this.SafeValue(response, "error", map[string]interface{} {})
    var errorCode interface{} = this.SafeString(error, "code")
    if IsTrue(IsTrue((!IsEqual(errorCode, nil))) && IsTrue((!IsEqual(errorCode, "0")))) {
        var feedback interface{} = Add(Add(this.Id, " "), body)
        var message interface{} = this.SafeString(error, "message")
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), errorCode, feedback)
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), message, feedback)
        panic(ExchangeError(feedback))
    }
    return nil
}


func (this *lykke) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
