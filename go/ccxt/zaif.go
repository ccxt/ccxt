package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type zaif struct {
    Exchange

}

func NewZaifCore() zaif {
   p := zaif{}
   setDefaults(&p)
   return p
}

func  (this *zaif) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "zaif",
        "name": "Zaif",
        "countries": []interface{}{"JP"},
        "rateLimit": 100,
        "version": "1",
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": nil,
            "swap": false,
            "future": false,
            "option": false,
            "cancelOrder": true,
            "createMarketOrder": false,
            "createOrder": true,
            "fetchBalance": true,
            "fetchClosedOrders": true,
            "fetchFundingHistory": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchIndexOHLCV": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrders": true,
            "fetchOrderBook": true,
            "fetchPremiumIndexOHLCV": false,
            "fetchTicker": true,
            "fetchTrades": true,
            "fetchTradingFee": false,
            "fetchTradingFees": false,
            "withdraw": true,
        },
        "urls": map[string]interface{} {
            "logo": "https://user-images.githubusercontent.com/1294454/27766927-39ca2ada-5eeb-11e7-972f-1b4199518ca6.jpg",
            "api": map[string]interface{} {
                "rest": "https://api.zaif.jp",
            },
            "www": "https://zaif.jp",
            "doc": []interface{}{"https://techbureau-api-document.readthedocs.io/ja/latest/index.html", "https://corp.zaif.jp/api-docs", "https://corp.zaif.jp/api-docs/api_links", "https://www.npmjs.com/package/zaif.jp", "https://github.com/you21979/node-zaif"},
            "fees": "https://zaif.jp/fee?lang=en",
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "percentage": true,
                "taker": this.ParseNumber("0.001"),
                "maker": this.ParseNumber("0"),
            },
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": map[string]interface{} {
                    "depth/{pair}": 1,
                    "currencies/{pair}": 1,
                    "currencies/all": 1,
                    "currency_pairs/{pair}": 1,
                    "currency_pairs/all": 1,
                    "last_price/{pair}": 1,
                    "ticker/{pair}": 1,
                    "trades/{pair}": 1,
                },
            },
            "private": map[string]interface{} {
                "post": map[string]interface{} {
                    "active_orders": 5,
                    "cancel_order": 5,
                    "deposit_history": 5,
                    "get_id_info": 5,
                    "get_info": 10,
                    "get_info2": 5,
                    "get_personal_info": 5,
                    "trade": 5,
                    "trade_history": 50,
                    "withdraw": 5,
                    "withdraw_history": 5,
                },
            },
            "ecapi": map[string]interface{} {
                "post": map[string]interface{} {
                    "createInvoice": 1,
                    "getInvoice": 1,
                    "getInvoiceIdsByOrderNumber": 1,
                    "cancelInvoice": 1,
                },
            },
            "tlapi": map[string]interface{} {
                "post": map[string]interface{} {
                    "get_positions": 66,
                    "position_history": 66,
                    "active_positions": 5,
                    "create_position": 33,
                    "change_position": 33,
                    "cancel_position": 33,
                },
            },
            "fapi": map[string]interface{} {
                "get": map[string]interface{} {
                    "groups/{group_id}": 1,
                    "last_price/{group_id}/{pair}": 1,
                    "ticker/{group_id}/{pair}": 1,
                    "trades/{group_id}/{pair}": 1,
                    "depth/{group_id}/{pair}": 1,
                },
            },
        },
        "options": map[string]interface{} {},
        "features": map[string]interface{} {
            "spot": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": true,
                    "triggerPrice": true,
                    "triggerDirection": false,
                    "triggerPriceType": nil,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": false,
                        "FOK": false,
                        "PO": false,
                        "GTD": false,
                    },
                    "hedged": false,
                    "trailing": false,
                    "leverage": true,
                    "marketBuyByCost": false,
                    "marketBuyRequiresPrice": false,
                    "selfTradePrevention": false,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": nil,
                "fetchOrder": nil,
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": true,
                    "limit": nil,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOrders": nil,
                "fetchClosedOrders": map[string]interface{} {
                    "marginMode": true,
                    "limit": 1000,
                    "daysBack": 100000,
                    "daysBackCanceled": 1,
                    "untilDays": 100000,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOHLCV": nil,
            },
            "swap": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "precisionMode": TICK_SIZE,
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "unsupported currency_pair": BadRequest,
            },
            "broad": map[string]interface{} {},
        },
    })
}
/**
 * @method
 * @name zaif#fetchMarkets
 * @see https://zaif-api-document.readthedocs.io/ja/latest/PublicAPI.html#id12
 * @description retrieves data on all markets for zaif
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *zaif) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            markets:= (<-this.PublicGetCurrencyPairsAll(params))
            PanicOnError(markets)
        
                //
            //     [
            //         {
            //             "aux_unit_point": 0,
            //             "item_japanese": "\u30d3\u30c3\u30c8\u30b3\u30a4\u30f3",
            //             "aux_unit_step": 5.0,
            //             "description": "\u30d3\u30c3\u30c8\u30b3\u30a4\u30f3\u30fb\u65e5\u672c\u5186\u306e\u53d6\u5f15\u3092\u884c\u3046\u3053\u3068\u304c\u3067\u304d\u307e\u3059",
            //             "item_unit_min": 0.001,
            //             "event_number": 0,
            //             "currency_pair": "btc_jpy",
            //             "is_token": false,
            //             "aux_unit_min": 5.0,
            //             "aux_japanese": "\u65e5\u672c\u5186",
            //             "id": 1,
            //             "item_unit_step": 0.0001,
            //             "name": "BTC/JPY",
            //             "seq": 0,
            //             "title": "BTC/JPY"
            //         }
            //     ]
            //
        ch <- this.ParseMarkets(markets)
            return nil
        
            }()
            return ch
        }
func  (this *zaif) ParseMarket(market interface{}) interface{}  {
    var id interface{} = this.SafeString(market, "currency_pair")
    var name interface{} = this.SafeString(market, "name")
    baseIdquoteIdVariable := Split(name, "/");
    baseId := GetValue(baseIdquoteIdVariable,0);
    quoteId := GetValue(baseIdquoteIdVariable,1)
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    var symbol interface{} = Add(Add(base, "/"), quote)
    return map[string]interface{} {
        "id": id,
        "symbol": symbol,
        "base": base,
        "quote": quote,
        "settle": nil,
        "baseId": baseId,
        "quoteId": quoteId,
        "settleId": nil,
        "type": "spot",
        "spot": true,
        "margin": nil,
        "swap": false,
        "future": false,
        "option": false,
        "active": nil,
        "contract": false,
        "linear": nil,
        "inverse": nil,
        "contractSize": nil,
        "expiry": nil,
        "expiryDatetime": nil,
        "strike": nil,
        "optionType": nil,
        "precision": map[string]interface{} {
            "amount": this.SafeNumber(market, "item_unit_step"),
            "price": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "aux_unit_point"))),
        },
        "limits": map[string]interface{} {
            "leverage": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "amount": map[string]interface{} {
                "min": this.SafeNumber(market, "item_unit_min"),
                "max": nil,
            },
            "price": map[string]interface{} {
                "min": this.SafeNumber(market, "aux_unit_min"),
                "max": nil,
            },
            "cost": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
        },
        "created": nil,
        "info": market,
    }
}
func  (this *zaif) ParseBalance(response interface{}) interface{}  {
    var balances interface{} = this.SafeValue(response, "return", map[string]interface{} {})
    var deposit interface{} = this.SafeValue(balances, "deposit")
    var result interface{} = map[string]interface{} {
        "info": response,
        "timestamp": nil,
        "datetime": nil,
    }
    var funds interface{} = this.SafeValue(balances, "funds", map[string]interface{} {})
    var currencyIds interface{} = ObjectKeys(funds)
    for i := 0; IsLessThan(i, GetArrayLength(currencyIds)); i++ {
        var currencyId interface{} = GetValue(currencyIds, i)
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var balance interface{} = this.SafeString(funds, currencyId)
        var account interface{} = this.Account()
        AddElementToObject(account, "free", balance)
        AddElementToObject(account, "total", balance)
        if IsTrue(!IsEqual(deposit, nil)) {
            if IsTrue(InOp(deposit, currencyId)) {
                AddElementToObject(account, "total", this.SafeString(deposit, currencyId))
            }
        }
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name zaif#fetchBalance
 * @see https://zaif-api-document.readthedocs.io/ja/latest/TradingAPI.html#id10
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *zaif) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes720397 := (<-this.LoadMarkets())
            PanicOnError(retRes720397)
        
            response:= (<-this.PrivatePostGetInfo(params))
            PanicOnError(response)
        
            ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name zaif#fetchOrderBook
 * @see https://zaif-api-document.readthedocs.io/ja/latest/PublicAPI.html#id34
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *zaif) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes713398 := (<-this.LoadMarkets())
            PanicOnError(retRes713398)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "pair": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetDepthPair(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseOrderBook(response, GetValue(market, "symbol"))
            return nil
        
            }()
            return ch
        }
func  (this *zaif) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // {
    //     "last": 9e-08,
    //     "high": 1e-07,
    //     "low": 9e-08,
    //     "vwap": 0.0,
    //     "volume": 135250.0,
    //     "bid": 9e-08,
    //     "ask": 1e-07
    // }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var symbol interface{} = this.SafeSymbol(nil, market)
    var vwap interface{} = this.SafeString(ticker, "vwap")
    var baseVolume interface{} = this.SafeString(ticker, "volume")
    var quoteVolume interface{} = Precise.StringMul(baseVolume, vwap)
    var last interface{} = this.SafeString(ticker, "last")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": nil,
        "datetime": nil,
        "high": this.SafeString(ticker, "high"),
        "low": this.SafeString(ticker, "low"),
        "bid": this.SafeString(ticker, "bid"),
        "bidVolume": nil,
        "ask": this.SafeString(ticker, "ask"),
        "askVolume": nil,
        "vwap": vwap,
        "open": nil,
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": nil,
        "percentage": nil,
        "average": nil,
        "baseVolume": baseVolume,
        "quoteVolume": quoteVolume,
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name zaif#fetchTicker
 * @see https://zaif-api-document.readthedocs.io/ja/latest/PublicAPI.html#id22
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *zaif) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes976683 := (<-this.LoadMarkets())
            PanicOnError(retRes976683)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "pair": GetValue(market, "id"),
            }
        
            ticker:= (<-this.PublicGetTickerPair(this.Extend(request, params)))
            PanicOnError(ticker)
        
                //
            // {
            //     "last": 9e-08,
            //     "high": 1e-07,
            //     "low": 9e-08,
            //     "vwap": 0.0,
            //     "volume": 135250.0,
            //     "bid": 9e-08,
            //     "ask": 1e-07
            // }
            //
        ch <- this.ParseTicker(ticker, market)
            return nil
        
            }()
            return ch
        }
func  (this *zaif) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTrades (public)
    //
    //      {
    //          "date": 1648559414,
    //          "price": 5880375.0,
    //          "amount": 0.017,
    //          "tid": 176126557,
    //          "currency_pair": "btc_jpy",
    //          "trade_type": "ask"
    //      }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var side interface{} = this.SafeString(trade, "trade_type")
    side = Ternary(IsTrue((IsEqual(side, "bid"))), "buy", "sell")
    var timestamp interface{} = this.SafeTimestamp(trade, "date")
    var id interface{} = this.SafeString2(trade, "id", "tid")
    var priceString interface{} = this.SafeString(trade, "price")
    var amountString interface{} = this.SafeString(trade, "amount")
    var marketId interface{} = this.SafeString(trade, "currency_pair")
    var symbol interface{} = this.SafeSymbol(marketId, market, "_")
    return this.SafeTrade(map[string]interface{} {
        "id": id,
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "type": nil,
        "side": side,
        "order": nil,
        "takerOrMaker": nil,
        "price": priceString,
        "amount": amountString,
        "cost": nil,
        "fee": nil,
    }, market)
}
/**
 * @method
 * @name zaif#fetchTrades
 * @see https://zaif-api-document.readthedocs.io/ja/latest/PublicAPI.html#id28
 * @description get the list of most recent trades for a particular symbol
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *zaif) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes272950 := (<-this.LoadMarkets())
            PanicOnError(retRes272950)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "pair": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetTradesPair(this.Extend(request, params)))
            PanicOnError(response)
            //
            //      [
            //          {
            //              "date": 1648559414,
            //              "price": 5880375.0,
            //              "amount": 0.017,
            //              "tid": 176126557,
            //              "currency_pair": "btc_jpy",
            //              "trade_type": "ask"
            //          }, ...
            //      ]
            //
            var numTrades interface{} =     GetArrayLength(response)
            if IsTrue(IsEqual(numTrades, 1)) {
                var firstTrade interface{} = GetValue(response, 0)
                if !IsTrue(GetArrayLength(ObjectKeys(firstTrade))) {
                    response = []interface{}{}
                }
            }
        
            ch <- this.ParseTrades(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name zaif#createOrder
 * @see https://zaif-api-document.readthedocs.io/ja/latest/MarginTradingAPI.html#id23
 * @description create a trade order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type must be 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *zaif) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes210177 := (<-this.LoadMarkets())
            PanicOnError(retRes210177)
            if IsTrue(!IsEqual(typeVar, "limit")) {
                panic(ExchangeError(Add(this.Id, " createOrder() allows limit orders only")))
            }
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "currency_pair": GetValue(market, "id"),
                "action": Ternary(IsTrue((IsEqual(side, "buy"))), "bid", "ask"),
                "amount": amount,
                "price": price,
            }
        
            response:= (<-this.PrivatePostTrade(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.SafeOrder(map[string]interface{} {
                "info": response,
                "id": ToString(GetValue(GetValue(response, "return"), "order_id")),
            }, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name zaif#cancelOrder
 * @see https://zaif-api-document.readthedocs.io/ja/latest/TradingAPI.html#id37
 * @description cancels an open order
 * @param {string} id order id
 * @param {string} symbol not used by zaif cancelOrder ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *zaif) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "order_id": id,
            }
        
            response:= (<-this.PrivatePostCancelOrder(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "success": 1,
            //        "return": {
            //            "order_id": 184,
            //            "funds": {
            //                "jpy": 15320,
            //                "btc": 1.392,
            //                "mona": 2600,
            //                "kaori": 0.1
            //            }
            //        }
            //    }
            //
            var data interface{} = this.SafeDict(response, "return")
        
            ch <- this.ParseOrder(data)
            return nil
        
            }()
            return ch
        }
func  (this *zaif) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "currency_pair": "btc_jpy",
    //         "action": "ask",
    //         "amount": 0.03,
    //         "price": 56000,
    //         "timestamp": 1402021125,
    //         "comment" : "demo"
    //     }
    //
    // cancelOrder
    //
    //    {
    //        "order_id": 184,
    //        "funds": {
    //            "jpy": 15320,
    //            "btc": 1.392,
    //            "mona": 2600,
    //            "kaori": 0.1
    //        }
    //    }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var side interface{} = this.SafeString(order, "action")
    side = Ternary(IsTrue((IsEqual(side, "bid"))), "buy", "sell")
    var timestamp interface{} = this.SafeTimestamp(order, "timestamp")
    var marketId interface{} = this.SafeString(order, "currency_pair")
    var symbol interface{} = this.SafeSymbol(marketId, market, "_")
    var price interface{} = this.SafeString(order, "price")
    var amount interface{} = this.SafeString(order, "amount")
    var id interface{} = this.SafeString2(order, "id", "order_id")
    return this.SafeOrder(map[string]interface{} {
        "id": id,
        "clientOrderId": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "status": "open",
        "symbol": symbol,
        "type": "limit",
        "timeInForce": nil,
        "postOnly": nil,
        "side": side,
        "price": price,
        "triggerPrice": nil,
        "cost": nil,
        "amount": amount,
        "filled": nil,
        "remaining": nil,
        "trades": nil,
        "fee": nil,
        "info": order,
        "average": nil,
    }, market)
}
/**
 * @method
 * @name zaif#fetchOpenOrders
 * @see https://zaif-api-document.readthedocs.io/ja/latest/MarginTradingAPI.html#id28
 * @description fetch all unfilled currently open orders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *zaif) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes584092 := (<-this.LoadMarkets())
            PanicOnError(retRes584092)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "currency_pair", GetValue(market, "id"))
            }
        
            response:= (<-this.PrivatePostActiveOrders(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseOrders(GetValue(response, "return"), market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name zaif#fetchClosedOrders
 * @see https://zaif-api-document.readthedocs.io/ja/latest/TradingAPI.html#id24
 * @description fetches information on multiple closed orders made by the user
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *zaif) FetchClosedOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes16298 := (<-this.LoadMarkets())
            PanicOnError(retRes16298)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "currency_pair", GetValue(market, "id"))
            }
        
            response:= (<-this.PrivatePostTradeHistory(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseOrders(GetValue(response, "return"), market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name zaif#withdraw
 * @see https://zaif-api-document.readthedocs.io/ja/latest/TradingAPI.html#id41
 * @description make a withdrawal
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *zaif) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params);
            tag = GetValue(tagparamsVariable,0);
            params = GetValue(tagparamsVariable,1)
            this.CheckAddress(address)
        
            retRes664347 := (<-this.LoadMarkets())
            PanicOnError(retRes664347)
            var currency interface{} = this.Currency(code)
            if IsTrue(IsEqual(code, "JPY")) {
                panic(ExchangeError(Add(Add(Add(this.Id, " withdraw() does not allow "), code), " withdrawals")))
            }
            var request interface{} = map[string]interface{} {
                "currency": GetValue(currency, "id"),
                "amount": amount,
                "address": address,
            }
            if IsTrue(!IsEqual(tag, nil)) {
                AddElementToObject(request, "message", tag)
            }
        
            result:= (<-this.PrivatePostWithdraw(this.Extend(request, params)))
            PanicOnError(result)
            //
            //     {
            //         "success": 1,
            //         "return": {
            //             "id": 23634,
            //             "fee": 0.001,
            //             "txid":,
            //             "funds": {
            //                 "jpy": 15320,
            //                 "btc": 1.392,
            //                 "xem": 100.2,
            //                 "mona": 2600
            //             }
            //         }
            //     }
            //
            var returnData interface{} = this.SafeDict(result, "return")
        
            ch <- this.ParseTransaction(returnData, currency)
            return nil
        
            }()
            return ch
        }
func  (this *zaif) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "id": 23634,
    //         "fee": 0.001,
    //         "txid":,
    //         "funds": {
    //             "jpy": 15320,
    //             "btc": 1.392,
    //             "xem": 100.2,
    //             "mona": 2600
    //         }
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    currency = this.SafeCurrency(nil, currency)
    var fee interface{} = nil
    var feeCost interface{} = this.SafeValue(transaction, "fee")
    if IsTrue(!IsEqual(feeCost, nil)) {
        fee = map[string]interface{} {
            "cost": feeCost,
            "currency": GetValue(currency, "code"),
        }
    }
    return map[string]interface{} {
        "id": this.SafeString(transaction, "id"),
        "txid": this.SafeString(transaction, "txid"),
        "timestamp": nil,
        "datetime": nil,
        "network": nil,
        "addressFrom": nil,
        "address": nil,
        "addressTo": nil,
        "amount": nil,
        "type": nil,
        "currency": GetValue(currency, "code"),
        "status": nil,
        "updated": nil,
        "tagFrom": nil,
        "tag": nil,
        "tagTo": nil,
        "comment": nil,
        "internal": nil,
        "fee": fee,
        "info": transaction,
    }
}
func  (this *zaif) CustomNonce() interface{}  {
    var num interface{} = this.NumberToString(Divide(this.Milliseconds(), 1000))
    var nonce interface{} = ParseFloat(num)
    return toFixed(nonce, 8)
}
func  (this *zaif) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var url interface{} = Add(GetValue(GetValue(this.Urls, "api"), "rest"), "/")
    if IsTrue(IsEqual(api, "public")) {
        url = Add(url, Add(Add(Add("api/", this.Version), "/"), this.ImplodeParams(path, params)))
    } else if IsTrue(IsEqual(api, "fapi")) {
        url = Add(url, Add(Add(Add("fapi/", this.Version), "/"), this.ImplodeParams(path, params)))
    } else {
        this.CheckRequiredCredentials()
        if IsTrue(IsEqual(api, "ecapi")) {
            url = Add(url, "ecapi")
        } else if IsTrue(IsEqual(api, "tlapi")) {
            url = Add(url, "tlapi")
        } else {
            url = Add(url, "tapi")
        }
        var nonce interface{} = this.CustomNonce()
        body = this.Urlencode(this.Extend(map[string]interface{} {
            "method": path,
            "nonce": nonce,
        }, params))
        headers = map[string]interface{} {
            "Content-Type": "application/x-www-form-urlencoded",
            "Key": this.ApiKey,
            "Sign": this.Hmac(this.Encode(body), this.Encode(this.Secret), sha512),
        }
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *zaif) HandleErrors(httpCode interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsEqual(response, nil)) {
        return nil
    }
    //
    //     {"error": "unsupported currency_pair"}
    //
    var feedback interface{} = Add(Add(this.Id, " "), body)
    var error interface{} = this.SafeString(response, "error")
    if IsTrue(!IsEqual(error, nil)) {
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), error, feedback)
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), error, feedback)
        panic(ExchangeError(feedback))
    }
    var success interface{} = this.SafeBool(response, "success", true)
    if !IsTrue(success) {
        panic(ExchangeError(feedback))
    }
    return nil
}


func (this *zaif) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
