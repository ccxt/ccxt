package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type p2b struct {
    Exchange

}

func NewP2bCore() p2b {
   p := p2b{}
   setDefaults(&p)
   return p
}

func  (this *p2b) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "p2b",
        "name": "p2b",
        "countries": []interface{}{"LT"},
        "rateLimit": 100,
        "version": "v2",
        "pro": true,
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": false,
            "swap": false,
            "future": false,
            "option": false,
            "addMargin": false,
            "cancelAllOrders": false,
            "cancelOrder": true,
            "cancelOrders": false,
            "closeAllPositions": false,
            "closePosition": false,
            "createDepositAddress": false,
            "createMarketOrder": false,
            "createOrder": true,
            "createOrders": false,
            "createPostOnlyOrder": false,
            "createReduceOnlyOrder": false,
            "createStopLimitOrder": false,
            "createStopMarketOrder": false,
            "createStopOrder": false,
            "fetchAccounts": false,
            "fetchBalance": true,
            "fetchBorrowInterest": false,
            "fetchBorrowRateHistory": false,
            "fetchClosedOrders": true,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchDeposit": false,
            "fetchDepositAddress": false,
            "fetchDepositAddresses": false,
            "fetchDepositAddressesByNetwork": false,
            "fetchDeposits": false,
            "fetchDepositsWithdrawals": false,
            "fetchFundingHistory": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchIndexOHLCV": false,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchLedger": false,
            "fetchLedgerEntry": false,
            "fetchLeverageTiers": false,
            "fetchMarketLeverageTiers": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenInterest": false,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrders": true,
            "fetchOrderBook": true,
            "fetchOrderBooks": false,
            "fetchOrders": false,
            "fetchOrderTrades": true,
            "fetchPosition": false,
            "fetchPositionHistory": false,
            "fetchPositionMode": false,
            "fetchPositions": false,
            "fetchPositionsForSymbol": false,
            "fetchPositionsHistory": false,
            "fetchPositionsRisk": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTrades": true,
            "fetchTradingLimits": false,
            "fetchTransactionFee": false,
            "fetchTransactionFees": false,
            "fetchTransactions": false,
            "fetchTransfers": false,
            "fetchWithdrawAddresses": false,
            "fetchWithdrawal": false,
            "fetchWithdrawals": false,
            "reduceMargin": false,
            "setLeverage": false,
            "setMargin": false,
            "setMarginMode": false,
            "setPositionMode": false,
            "signIn": false,
            "transfer": false,
            "withdraw": false,
        },
        "timeframes": map[string]interface{} {
            "1m": "1m",
            "1h": "1h",
            "1d": "1d",
        },
        "urls": map[string]interface{} {
            "extension": ".json",
            "referral": "https://p2pb2b.com?referral=ee784c53",
            "logo": "https://github.com/ccxt/ccxt/assets/43336371/8da13a80-1f0a-49be-bb90-ff8b25164755",
            "api": map[string]interface{} {
                "public": "https://api.p2pb2b.com/api/v2/public",
                "private": "https://api.p2pb2b.com/api/v2",
            },
            "www": "https://p2pb2b.com/",
            "doc": "https://github.com/P2B-team/p2b-api-docs/blob/master/api-doc.md",
            "fees": "https://p2pb2b.com/fee-schedule/",
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": map[string]interface{} {
                    "markets": 1,
                    "market": 1,
                    "tickers": 1,
                    "ticker": 1,
                    "book": 1,
                    "history": 1,
                    "depth/result": 1,
                    "market/kline": 1,
                },
            },
            "private": map[string]interface{} {
                "post": map[string]interface{} {
                    "account/balances": 1,
                    "account/balance": 1,
                    "order/new": 1,
                    "order/cancel": 1,
                    "orders": 1,
                    "account/market_order_history": 1,
                    "account/market_deal_history": 1,
                    "account/order": 1,
                    "account/order_history": 1,
                    "account/executed_history": 1,
                },
            },
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "tierBased": true,
                "percentage": true,
                "taker": []interface{}{[]interface{}{this.ParseNumber("0"), this.ParseNumber("0.2")}, []interface{}{this.ParseNumber("1"), this.ParseNumber("0.19")}, []interface{}{this.ParseNumber("5"), this.ParseNumber("0.18")}, []interface{}{this.ParseNumber("10"), this.ParseNumber("0.17")}, []interface{}{this.ParseNumber("25"), this.ParseNumber("0.16")}, []interface{}{this.ParseNumber("75"), this.ParseNumber("0.15")}, []interface{}{this.ParseNumber("100"), this.ParseNumber("0.14")}, []interface{}{this.ParseNumber("150"), this.ParseNumber("0.13")}, []interface{}{this.ParseNumber("300"), this.ParseNumber("0.12")}, []interface{}{this.ParseNumber("450"), this.ParseNumber("0.11")}, []interface{}{this.ParseNumber("500"), this.ParseNumber("0.1")}},
                "maker": []interface{}{[]interface{}{this.ParseNumber("0"), this.ParseNumber("0.2")}, []interface{}{this.ParseNumber("1"), this.ParseNumber("0.18")}, []interface{}{this.ParseNumber("5"), this.ParseNumber("0.16")}, []interface{}{this.ParseNumber("10"), this.ParseNumber("0.14")}, []interface{}{this.ParseNumber("25"), this.ParseNumber("0.12")}, []interface{}{this.ParseNumber("75"), this.ParseNumber("0.1")}, []interface{}{this.ParseNumber("100"), this.ParseNumber("0.08")}, []interface{}{this.ParseNumber("150"), this.ParseNumber("0.06")}, []interface{}{this.ParseNumber("300"), this.ParseNumber("0.04")}, []interface{}{this.ParseNumber("450"), this.ParseNumber("0.02")}, []interface{}{this.ParseNumber("500"), this.ParseNumber("0.01")}},
            },
        },
        "features": map[string]interface{} {
            "spot": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": false,
                    "triggerDirection": false,
                    "triggerPriceType": nil,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": true,
                        "FOK": true,
                        "PO": true,
                        "GTD": false,
                    },
                    "hedged": false,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyByCost": false,
                    "marketBuyRequiresPrice": false,
                    "selfTradePrevention": false,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": 100000,
                    "untilDays": 1,
                    "symbolRequired": true,
                },
                "fetchOrder": nil,
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchOrders": nil,
                "fetchClosedOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": 100000,
                    "daysBackCanceled": Divide(1, 12),
                    "untilDays": 1,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOHLCV": map[string]interface{} {
                    "limit": 500,
                },
            },
            "swap": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "commonCurrencies": map[string]interface{} {},
        "precisionMode": TICK_SIZE,
        "exceptions": map[string]interface{} {
            "1001": AuthenticationError,
            "1002": AuthenticationError,
            "1003": AuthenticationError,
            "1004": AuthenticationError,
            "1005": AuthenticationError,
            "1006": AuthenticationError,
            "1007": AuthenticationError,
            "1008": AuthenticationError,
            "1009": AuthenticationError,
            "1010": AuthenticationError,
            "1011": AuthenticationError,
            "1012": AuthenticationError,
            "1013": AuthenticationError,
            "1014": AuthenticationError,
            "1015": AuthenticationError,
            "1016": AuthenticationError,
            "2010": BadRequest,
            "2020": BadRequest,
            "2021": BadRequest,
            "2030": BadRequest,
            "2040": InsufficientFunds,
            "2050": BadRequest,
            "2051": BadRequest,
            "2052": BadRequest,
            "2060": BadRequest,
            "2061": BadRequest,
            "2062": BadRequest,
            "2070": BadRequest,
            "3001": BadRequest,
            "3020": BadRequest,
            "3030": BadRequest,
            "3040": BadRequest,
            "3050": BadRequest,
            "3060": BadRequest,
            "3070": BadRequest,
            "3080": BadRequest,
            "3090": BadRequest,
            "3100": BadRequest,
            "3110": BadRequest,
            "4001": ExchangeNotAvailable,
            "6010": InsufficientFunds,
        },
        "options": map[string]interface{} {},
    })
}
/**
 * @method
 * @name p2b#fetchMarkets
 * @description retrieves data on all markets for bigone
 * @see https://github.com/P2B-team/p2b-api-docs/blob/master/api-doc.md#markets
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *p2b) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetMarkets(params))
            PanicOnError(response)
            //
            //    {
            //        "success": true,
            //        "errorCode": "",
            //        "message": "",
            //        "result": [
            //            {
            //                "name": "ETH_BTC",
            //                "stock": "ETH",
            //                "money": "BTC",
            //                "precision": {
            //                    "money": "6",
            //                    "stock": "4",
            //                    "fee": "4"
            //                },
            //                "limits": {
            //                    "min_amount": "0.001",
            //                    "max_amount": "100000",
            //                    "step_size": "0.0001",
            //                    "min_price": "0.00001",
            //                    "max_price": "922327",
            //                    "tick_size": "0.00001",
            //                    "min_total": "0.0001"
            //                }
            //            },
            //            ...
            //        ]
            //    }
            //
            var markets interface{} = this.SafeValue(response, "result", []interface{}{})
        
            ch <- this.ParseMarkets(markets)
            return nil
        
            }()
            return ch
        }
func  (this *p2b) ParseMarket(market interface{}) interface{}  {
    var marketId interface{} = this.SafeString(market, "name")
    var baseId interface{} = this.SafeString(market, "stock")
    var quoteId interface{} = this.SafeString(market, "money")
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    var limits interface{} = this.SafeValue(market, "limits")
    var maxAmount interface{} = this.SafeString(limits, "max_amount")
    var maxPrice interface{} = this.SafeString(limits, "max_price")
    return map[string]interface{} {
        "id": marketId,
        "symbol": Add(Add(base, "/"), quote),
        "base": base,
        "quote": quote,
        "settle": nil,
        "baseId": baseId,
        "quoteId": quoteId,
        "settleId": nil,
        "type": "spot",
        "spot": true,
        "margin": false,
        "swap": false,
        "future": false,
        "option": false,
        "active": true,
        "contract": false,
        "linear": nil,
        "inverse": nil,
        "contractSize": nil,
        "expiry": nil,
        "expiryDatetime": nil,
        "strike": nil,
        "optionType": nil,
        "precision": map[string]interface{} {
            "amount": this.SafeNumber(limits, "step_size"),
            "price": this.SafeNumber(limits, "tick_size"),
        },
        "limits": map[string]interface{} {
            "leverage": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "amount": map[string]interface{} {
                "min": this.SafeNumber(limits, "min_amount"),
                "max": this.ParseNumber(this.OmitZero(maxAmount)),
            },
            "price": map[string]interface{} {
                "min": this.SafeNumber(limits, "min_price"),
                "max": this.ParseNumber(this.OmitZero(maxPrice)),
            },
            "cost": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
        },
        "created": nil,
        "info": market,
    }
}
/**
 * @method
 * @name p2b#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://futures-docs.poloniex.com/#get-real-time-ticker-of-all-symbols
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *p2b) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes948773 := (<-this.LoadMarkets())
            PanicOnError(retRes948773)
        
            response:= (<-this.PublicGetTickers(params))
            PanicOnError(response)
            //
            //    {
            //        success: true,
            //        errorCode: '',
            //        message: '',
            //        result: {
            //            KNOLIX_BTC: {
            //                at: '1699252631',
            //                ticker: {
            //                    bid: '0.0000332',
            //                    ask: '0.0000333',
            //                    low: '0.0000301',
            //                    high: '0.0000338',
            //                    last: '0.0000333',
            //                    vol: '15.66',
            //                    deal: '0.000501828',
            //                    change: '10.63'
            //                }
            //            },
            //            ...
            //        },
            //        cache_time: '1699252631.103631',
            //        current_time: '1699252644.487566'
            //    }
            //
            var result interface{} = this.SafeValue(response, "result", map[string]interface{} {})
        
            ch <- this.ParseTickers(result, symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name p2b#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://github.com/P2B-team/p2b-api-docs/blob/master/api-doc.md#ticker
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *p2b) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes209858 := (<-this.LoadMarkets())
            PanicOnError(retRes209858)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetTicker(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        success: true,
            //        errorCode: '',
            //        message: '',
            //        result: {
            //            bid: '0.342',
            //            ask: '0.3421',
            //            open: '0.3317',
            //            high: '0.3499',
            //            low: '0.3311',
            //            last: '0.3421',
            //            volume: '17855383.1',
            //            deal: '6107478.3423',
            //            change: '3.13'
            //        },
            //        cache_time: '1699252953.832795',
            //        current_time: '1699252958.859391'
            //    }
            //
            var result interface{} = this.SafeValue(response, "result", map[string]interface{} {})
            var timestamp interface{} = this.SafeIntegerProduct(response, "cache_time", 1000)
        
            ch <- this.Extend(map[string]interface{} {
                "timestamp": timestamp,
                "datetime": this.Iso8601(timestamp),
            }, this.ParseTicker(result, market))
            return nil
        
            }()
            return ch
        }
func  (this *p2b) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // parseTickers
    //
    //    {
    //        at: '1699252631',
    //        ticker: {
    //            bid: '0.0000332',
    //            ask: '0.0000333',
    //            low: '0.0000301',
    //            high: '0.0000338',
    //            last: '0.0000333',
    //            vol: '15.66',
    //            deal: '0.000501828',
    //            change: '10.63'
    //        }
    //    }
    //
    // parseTicker
    //
    //    {
    //        bid: '0.342',
    //        ask: '0.3421',
    //        open: '0.3317',
    //        high: '0.3499',
    //        low: '0.3311',
    //        last: '0.3421',
    //        volume: '17855383.1',
    //        deal: '6107478.3423',
    //        change: '3.13'
    //    }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeIntegerProduct(ticker, "at", 1000)
    if IsTrue(InOp(ticker, "ticker")) {
        ticker = this.SafeValue(ticker, "ticker")
    }
    var last interface{} = this.SafeString(ticker, "last")
    return this.SafeTicker(map[string]interface{} {
        "symbol": this.SafeString(market, "symbol"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeString(ticker, "high"),
        "low": this.SafeString(ticker, "low"),
        "bid": this.SafeString(ticker, "bid"),
        "bidVolume": nil,
        "ask": this.SafeString(ticker, "ask"),
        "askVolume": nil,
        "vwap": nil,
        "open": this.SafeString(ticker, "open"),
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": nil,
        "percentage": this.SafeString(ticker, "change"),
        "average": nil,
        "baseVolume": this.SafeString2(ticker, "vol", "volume"),
        "quoteVolume": this.SafeString(ticker, "deal"),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name p2b#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://github.com/P2B-team/p2b-api-docs/blob/master/api-doc.md#depth-result
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 *
 * EXCHANGE SPECIFIC PARAMETERS
 * @param {string} [params.interval] 0 (default), 0.00000001, 0.0000001, 0.000001, 0.00001, 0.0001, 0.001, 0.01, 0.1, 1
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *p2b) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes871454 := (<-this.LoadMarkets())
            PanicOnError(retRes871454)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.PublicGetDepthResult(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "success": true,
            //        "errorCode": "",
            //        "message": "",
            //        "result": {
            //            "asks": [
            //                [
            //                    "4.53",     // Price
            //                    "523.95"    // Amount
            //                ],
            //                ...
            //            ],
            //            "bids": [
            //                [
            //                    "4.51",
            //                    "244.75"
            //                ],
            //                ...
            //            ]
            //        },
            //        "cache_time": 1698733470.469175,
            //        "current_time": 1698733470.469274
            //    }
            //
            var result interface{} = this.SafeValue(response, "result", map[string]interface{} {})
            var timestamp interface{} = this.SafeIntegerProduct(response, "current_time", 1000)
        
            ch <- this.ParseOrderBook(result, GetValue(market, "symbol"), timestamp, "bids", "asks", 0, 1)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name p2b#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://github.com/P2B-team/p2b-api-docs/blob/master/api-doc.md#history
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] 1-100, default=50
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} params.lastId order id
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *p2b) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes670114 := (<-this.LoadMarkets())
            PanicOnError(retRes670114)
            var lastId interface{} = this.SafeInteger(params, "lastId")
            if IsTrue(IsEqual(lastId, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchTrades () requires an extra parameter params[\"lastId\"]")))
            }
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
                "lastId": lastId,
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.PublicGetHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        success: true,
            //        errorCode: '',
            //        message: '',
            //        result: [
            //            {
            //                id: '7495738622',
            //                type: 'sell',
            //                time: '1699255565.445418',
            //                amount: '252.6',
            //                price: '0.3422'
            //            },
            //            ...
            //        ],
            //        cache_time: '1699255571.413633',
            //        current_time: '1699255571.413828'
            //    }
            //
            var result interface{} = this.SafeList(response, "result", []interface{}{})
        
            ch <- this.ParseTrades(result, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *p2b) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTrades
    //
    //    {
    //        id: '7495738622',
    //        type: 'sell',
    //        time: '1699255565.445418',
    //        amount: '252.6',
    //        price: '0.3422'
    //    }
    //
    // fetchMyTrades
    //
    //    {
    //        "deal_id": 7450617292,              // Deal id
    //        "deal_time": 1698506956.66224,      // Deal execution time
    //        "deal_order_id": 171955225751,      // Deal order id
    //        "opposite_order_id": 171955110512,  // Opposite order id
    //        "side": "sell",                     // Deal side
    //        "price": "0.05231",                 // Deal price
    //        "amount": "0.002",                  // Deal amount
    //        "deal": "0.00010462",               // Total (price * amount)
    //        "deal_fee": "0.000000188316",       // Deal fee
    //        "role": "taker",                    // Role. Taker or maker
    //        "isSelfTrade": false                // is self trade
    //    }
    //
    // fetchOrderTrades
    //
    //    {
    //        "id": 7429883128,             // Deal id
    //        "time": 1698237535.41196,     // Deal execution time
    //        "fee": "0.01755848704",       // Deal fee
    //        "price": "34293.92",          // Deal price
    //        "amount": "0.00032",          // Deal amount
    //        "dealOrderId": 171366551416,  // Deal order id
    //        "role": 1,                    // Deal role (1 - maker, 2 - taker)
    //        "deal": "10.9740544"          // Total (price * amount)
    //    }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeIntegerProduct2(trade, "time", "deal_time", 1000)
    var takerOrMaker interface{} = this.SafeString(trade, "role")
    if IsTrue(IsEqual(takerOrMaker, "1")) {
        takerOrMaker = "maker"
    } else if IsTrue(IsEqual(takerOrMaker, "2")) {
        takerOrMaker = "taker"
    }
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "id": this.SafeString2(trade, "id", "deal_id"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": this.SafeString(market, "symbol"),
        "order": this.SafeString2(trade, "dealOrderId", "deal_order_id"),
        "type": nil,
        "side": this.SafeString2(trade, "type", "side"),
        "takerOrMaker": takerOrMaker,
        "price": this.SafeString(trade, "price"),
        "amount": this.SafeString(trade, "amount"),
        "cost": this.SafeString(trade, "deal"),
        "fee": map[string]interface{} {
            "currency": GetValue(market, "quote"),
            "cost": this.SafeString2(trade, "fee", "deal_fee"),
        },
    }, market)
}
/**
 * @method
 * @name p2b#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://github.com/P2B-team/p2b-api-docs/blob/master/api-doc.md#kline
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe 1m, 1h, or 1d
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] 1-500, default=50
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.offset] default=0, with this value the last candles are returned
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *p2b) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes61182 := (<-this.LoadMarkets())
            PanicOnError(retRes61182)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
                "interval": timeframe,
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.PublicGetMarketKline(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        success: true,
            //        errorCode: '',
            //        message: '',
            //        result: [
            //            [
            //                1699253400,       // Kline open time
            //                '0.3429',         // Open price
            //                '0.3427',         // Close price
            //                '0.3429',         // Highest price
            //                '0.3427',         // Lowest price
            //                '1900.4',         // Volume for stock currency
            //                '651.46278',      // Volume for money currency
            //                'ADA_USDT'        // Market name
            //            ],
            //            ...
            //        ],
            //        cache_time: '1699256375.030292',
            //        current_time: '1699256375.030494'
            //    }
            //
            var result interface{} = this.SafeList(response, "result", []interface{}{})
        
            ch <- this.ParseOHLCVs(result, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *p2b) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    [
    //        1699253400,       // Kline open time
    //        '0.3429',         // Open price
    //        '0.3427',         // Close price
    //        '0.3429',         // Highest price
    //        '0.3427',         // Lowest price
    //        '1900.4',         // Volume for stock currency
    //        '651.46278',      // Volume for money currency
    //        'ADA_USDT'        // Market name
    //    ],
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.SafeIntegerProduct(ohlcv, 0, 1000), this.SafeNumber(ohlcv, 1), this.SafeNumber(ohlcv, 3), this.SafeNumber(ohlcv, 4), this.SafeNumber(ohlcv, 2), this.SafeNumber(ohlcv, 5)}
}
/**
 * @method
 * @name p2b#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://github.com/P2B-team/p2b-api-docs/blob/master/api-doc.md#all-balances
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *p2b) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes961156 := (<-this.LoadMarkets())
            PanicOnError(retRes961156)
        
            response:= (<-this.PrivatePostAccountBalances(params))
            PanicOnError(response)
            //
            //    {
            //        "success": true,
            //        "errorCode": "",
            //        "message": "",
            //        "result": {
            //            "USDT": {
            //              "available": "71.81328046",
            //              "freeze": "10.46103091"
            //            },
            //            "BTC": {
            //              "available": "0.00135674",
            //              "freeze": "0.00020003"
            //            }
            //        }
            //    }
            //
            var result interface{} = this.SafeValue(response, "result", map[string]interface{} {})
        
            ch <- this.ParseBalance(result)
            return nil
        
            }()
            return ch
        }
func  (this *p2b) ParseBalance(response interface{}) interface{}  {
    //
    //    {
    //        "USDT": {
    //            "available": "71.81328046",
    //            "freeze": "10.46103091"
    //        },
    //        "BTC": {
    //            "available": "0.00135674",
    //            "freeze": "0.00020003"
    //        }
    //    }
    //
    var result interface{} = map[string]interface{} {
        "info": response,
    }
    var keys interface{} = ObjectKeys(response)
    for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
        var currencyId interface{} = GetValue(keys, i)
        var balance interface{} = GetValue(response, currencyId)
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var used interface{} = this.SafeString(balance, "freeze")
        var available interface{} = this.SafeString(balance, "available")
        var account interface{} = map[string]interface{} {
            "free": available,
            "used": used,
        }
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name p2b#createOrder
 * @description create a trade order
 * @see https://github.com/P2B-team/p2b-api-docs/blob/master/api-doc.md#create-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type must be 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} price the price at which the order is to be fulfilled, in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *p2b) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes696280 := (<-this.LoadMarkets())
            PanicOnError(retRes696280)
            if IsTrue(IsEqual(typeVar, "market")) {
                panic(BadRequest(Add(this.Id, " createOrder () can only accept orders with type \"limit\"")))
            }
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
                "side": side,
                "amount": this.AmountToPrecision(symbol, amount),
                "price": this.PriceToPrecision(symbol, price),
            }
        
            response:= (<-this.PrivatePostOrderNew(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "success": true,
            //        "errorCode": "",
            //        "message": "",
            //        "result": {
            //            "orderId": 171906478744,          // Order id
            //            "market": "ETH_BTC",              // Market name
            //            "price": "0.04348",               // Price
            //            "side": "buy",                    // Side
            //            "type": "limit",                  // Order type
            //            "timestamp": 1698484861.746517,   // Order creation time
            //            "dealMoney": "0",                 // Filled total
            //            "dealStock": "0",                 // Filled amount
            //            "amount": "0.0277",               // Original amount
            //            "takerFee": "0.002",              // taker fee
            //            "makerFee": "0.002",              // maker fee
            //            "left": "0.0277",                 // Unfilled amount
            //            "dealFee": "0"                    // Filled fee
            //        }
            //    }
            //
            var result interface{} = this.SafeDict(response, "result")
        
            ch <- this.ParseOrder(result, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name p2b#cancelOrder
 * @description cancels an open order
 * @see https://github.com/P2B-team/p2b-api-docs/blob/master/api-doc.md#cancel-order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *p2b) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " cancelOrder() requires a symbol argument")))
            }
        
            retRes836110 := (<-this.LoadMarkets())
            PanicOnError(retRes836110)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
                "orderId": id,
            }
        
            response:= (<-this.PrivatePostOrderCancel(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "success": true,
            //        "errorCode": "",
            //        "message": "",
            //        "result": {
            //            "orderId": 171906478744,
            //            "market": "ETH_BTC",
            //            "price": "0.04348",
            //            "side": "buy",
            //            "type": "limit",
            //            "timestamp": 1698484861.746517,
            //            "dealMoney": "0",
            //            "dealStock": "0",
            //            "amount": "0.0277",
            //            "takerFee": "0.002",
            //            "makerFee": "0.002",
            //            "left": "0.0277",
            //            "dealFee": "0"
            //        }
            //    }
            //
            var result interface{} = this.SafeDict(response, "result")
        
            ch <- this.ParseOrder(result)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name p2b#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://github.com/P2B-team/p2b-api-docs/blob/master/api-doc.md#open-orders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 *
 * EXCHANGE SPECIFIC PARAMETERS
 * @param {int} [params.offset] 0-10000, default=0
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *p2b) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchOpenOrders () requires the symbol argument")))
            }
        
            retRes146270 := (<-this.LoadMarkets())
            PanicOnError(retRes146270)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.PrivatePostOrders(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "success": true,
            //        "errorCode": "",
            //        "message": "",
            //        "result": [
            //            {
            //                "orderId": 171913325964,
            //                "market": "ETH_BTC",
            //                "price": "0.06534",
            //                "side": "sell",
            //                "type": "limit",
            //                "timestamp": 1698487986.836821,
            //                "dealMoney": "0",
            //                "dealStock": "0",
            //                "amount": "0.0018",
            //                "takerFee": "0.0018",
            //                "makerFee": "0.0016",
            //                "left": "0.0018",
            //                "dealFee": "0"
            //            },
            //            ...
            //        ]
            //    }
            //
            var result interface{} = this.SafeList(response, "result", []interface{}{})
        
            ch <- this.ParseOrders(result, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name p2b#fetchOrderTrades
 * @description fetch all the trades made from a single order
 * @see https://github.com/P2B-team/p2b-api-docs/blob/master/api-doc.md#deals-by-order-id
 * @param {string} id order id
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] 1-100, default=50
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 *
 * EXCHANGE SPECIFIC PARAMETERS
 * @param {int} [params.offset] 0-10000, default=0
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *p2b) FetchOrderTrades(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes83421 := (<-this.LoadMarkets())
            PanicOnError(retRes83421)
            var market interface{} = this.SafeMarket(symbol)
            var request interface{} = map[string]interface{} {
                "orderId": id,
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.PrivatePostAccountOrder(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "success": true,
            //        "errorCode": "",
            //        "message": "",
            //        "result": {
            //            "offset": 0,
            //            "limit": 50,
            //            "records": [
            //                {
            //                    "id": 7429883128,             // Deal id
            //                    "time": 1698237535.41196,     // Deal execution time
            //                    "fee": "0.01755848704",       // Deal fee
            //                    "price": "34293.92",          // Deal price
            //                    "amount": "0.00032",          // Deal amount
            //                    "dealOrderId": 171366551416,  // Deal order id
            //                    "role": 1,                    // Deal role (1 - maker, 2 - taker)
            //                    "deal": "10.9740544"          // Total (price * amount)
            //                }
            //            ]
            //        }
            //    }
            //
            var result interface{} = this.SafeValue(response, "result", map[string]interface{} {})
            var records interface{} = this.SafeList(result, "records", []interface{}{})
        
            ch <- this.ParseTrades(records, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name p2b#fetchMyTrades
 * @description fetch all trades made by the user, only the transaction records in the past 3 month can be queried, the time between since and params["until"] cannot be longer than 24 hours
 * @see https://github.com/P2B-team/p2b-api-docs/blob/master/api-doc.md#deals-history-by-market
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for, default = params["until"] - 86400000
 * @param {int} [limit] 1-100, default=50
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch orders for, default = current timestamp or since + 86400000
 *
 * EXCHANGE SPECIFIC PARAMETERS
 * @param {int} [params.offset] 0-10000, default=0
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *p2b) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchMyTrades() requires a symbol argument")))
            }
        
            retRes497507 := (<-this.LoadMarkets())
            PanicOnError(retRes497507)
            var until interface{} = this.SafeInteger(params, "until")
            params = this.Omit(params, "until")
            if IsTrue(IsEqual(until, nil)) {
                if IsTrue(IsEqual(since, nil)) {
                    until = this.Milliseconds()
                } else {
                    until = Add(since, 86400000)
                }
            }
            if IsTrue(IsEqual(since, nil)) {
                since = Subtract(until, 86400000)
            }
            if IsTrue(IsGreaterThan((Subtract(until, since)), 86400000)) {
                panic(BadRequest(Add(this.Id, " fetchMyTrades () the time between since and params[\"until\"] cannot be greater than 24 hours")))
            }
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market": GetValue(market, "id"),
                "startTime": this.ParseToInt(Divide(since, 1000)),
                "endTime": this.ParseToInt(Divide(until, 1000)),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.PrivatePostAccountMarketDealHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "success": true,
            //        "errorCode": "",
            //        "message": "",
            //        "result": {
            //            "total": 2,                                 // Total records in the queried range
            //            "deals": [
            //                {
            //                    "deal_id": 7450617292,              // Deal id
            //                    "deal_time": 1698506956.66224,      // Deal execution time
            //                    "deal_order_id": 171955225751,      // Deal order id
            //                    "opposite_order_id": 171955110512,  // Opposite order id
            //                    "side": "sell",                     // Deal side
            //                    "price": "0.05231",                 // Deal price
            //                    "amount": "0.002",                  // Deal amount
            //                    "deal": "0.00010462",               // Total (price * amount)
            //                    "deal_fee": "0.000000188316",       // Deal fee
            //                    "role": "taker",                    // Role. Taker or maker
            //                    "isSelfTrade": false                // is self trade
            //                },
            //                ...
            //            ]
            //        }
            //    }
            //
            var result interface{} = this.SafeValue(response, "result", map[string]interface{} {})
            var deals interface{} = this.SafeList(result, "deals", []interface{}{})
        
            ch <- this.ParseTrades(deals, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name p2b#fetchClosedOrders
 * @description fetches information on multiple closed orders made by the user, the time between since and params["untnil"] cannot be longer than 24 hours
 * @see https://github.com/P2B-team/p2b-api-docs/blob/master/api-doc.md#orders-history-by-market
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for, default = params["until"] - 86400000
 * @param {int} [limit] 1-100, default=50
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch orders for, default = current timestamp or since + 86400000
 *
 * EXCHANGE SPECIFIC PARAMETERS
 * @param {int} [params.offset] 0-10000, default=0
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *p2b) FetchClosedOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes360120 := (<-this.LoadMarkets())
            PanicOnError(retRes360120)
            var until interface{} = this.SafeInteger(params, "until")
            params = this.Omit(params, "until")
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
            }
            if IsTrue(IsEqual(until, nil)) {
                if IsTrue(IsEqual(since, nil)) {
                    until = this.Milliseconds()
                } else {
                    until = Add(since, 86400000)
                }
            }
            if IsTrue(IsEqual(since, nil)) {
                since = Subtract(until, 86400000)
            }
            if IsTrue(IsGreaterThan((Subtract(until, since)), 86400000)) {
                panic(BadRequest(Add(this.Id, " fetchClosedOrders () the time between since and params[\"until\"] cannot be greater than 24 hours")))
            }
            var request interface{} = map[string]interface{} {
                "startTime": this.ParseToInt(Divide(since, 1000)),
                "endTime": this.ParseToInt(Divide(until, 1000)),
            }
            if IsTrue(!IsEqual(market, nil)) {
                AddElementToObject(request, "market", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.PrivatePostAccountOrderHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "success": true,
            //        "errorCode": "",
            //        "message": "",
            //        "result": {
            //            "LTC_USDT": [
            //                {
            //                    "id": 173985944395,
            //                    "amount": "0.1",
            //                    "price": "73",
            //                    "type": "limit",
            //                    "side": "sell",
            //                    "ctime": 1699436194.390845,
            //                    "ftime": 1699436194.390847,
            //                    "market": "LTC_USDT",
            //                    "takerFee": "0.002",
            //                    "makerFee": "0.002",
            //                    "dealFee": "0.01474",
            //                    "dealStock": "0.1",
            //                    "dealMoney": "7.37"
            //                }
            //            ]
            //        }
            //    }
            //
            var result interface{} = this.SafeValue(response, "result")
            var orders interface{} = []interface{}{}
            var keys interface{} = ObjectKeys(result)
            for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
                var marketId interface{} = GetValue(keys, i)
                var marketOrders interface{} = GetValue(result, marketId)
                var parsedOrders interface{} = this.ParseOrders(marketOrders, market, since, limit)
                orders = this.ArrayConcat(orders, parsedOrders)
            }
        
            ch <- orders
            return nil
        
            }()
            return ch
        }
func  (this *p2b) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // cancelOrder, fetchOpenOrders, createOrder
    //
    //    {
    //        "orderId": 171906478744,
    //        "market": "ETH_BTC",
    //        "price": "0.04348",
    //        "side": "buy",
    //        "type": "limit",
    //        "timestamp": 1698484861.746517,
    //        "dealMoney": "0",
    //        "dealStock": "0",
    //        "amount": "0.0277",
    //        "takerFee": "0.002",
    //        "makerFee": "0.002",
    //        "left": "0.0277",
    //        "dealFee": "0"
    //    }
    //
    // fetchClosedOrders
    //
    //    {
    //        "id": 171366547790,           // Order id
    //        "amount": "0.00032",          // Original amount
    //        "price": "34293.92",          // Order price
    //        "type": "limit",              // Order type
    //        "side": "sell",               // Order side
    //        "ctime": 1698237533.497241,   // Order creation time
    //        "ftime": 1698237535.41196,    // Order fill time
    //        "market": "BTC_USDT",         // Market name
    //        "takerFee": "0.0018",         // Taker fee
    //        "makerFee": "0.0016",         // Market fee
    //        "dealFee": "0.01755848704",   // Deal fee
    //        "dealStock": "0.00032",       // Filled amount
    //        "dealMoney": "10.9740544"     // Filled total
    //    }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeIntegerProduct2(order, "timestamp", "ctime", 1000)
    var marketId interface{} = this.SafeString(order, "market")
    market = this.SafeMarket(marketId, market)
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": this.SafeString2(order, "id", "orderId"),
        "clientOrderId": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "symbol": GetValue(market, "symbol"),
        "type": this.SafeString(order, "type"),
        "timeInForce": nil,
        "postOnly": nil,
        "side": this.SafeString(order, "side"),
        "price": this.SafeString(order, "price"),
        "triggerPrice": nil,
        "amount": this.SafeString(order, "amount"),
        "cost": nil,
        "average": nil,
        "filled": this.SafeString(order, "dealStock"),
        "remaining": this.SafeString(order, "left"),
        "status": nil,
        "fee": map[string]interface{} {
            "currency": GetValue(market, "quote"),
            "cost": this.SafeString(order, "dealFee"),
        },
        "trades": nil,
    }, market)
}
func  (this *p2b) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var url interface{} = Add(Add(GetValue(GetValue(this.Urls, "api"), api), "/"), this.ImplodeParams(path, params))
    params = this.Omit(params, this.ExtractParams(path))
    if IsTrue(IsEqual(method, "GET")) {
        if IsTrue(GetArrayLength(ObjectKeys(params))) {
            url = Add(url, Add("?", this.Urlencode(params)))
        }
    }
    if IsTrue(IsEqual(api, "private")) {
        AddElementToObject(params, "request", Add("/api/v2/", path))
        AddElementToObject(params, "nonce", ToString(this.Nonce()))
        var payload interface{} = this.StringToBase64(this.Json(params)) // Body json encoded in base64
        headers = map[string]interface{} {
            "Content-Type": "application/json",
            "X-TXC-APIKEY": this.ApiKey,
            "X-TXC-PAYLOAD": payload,
            "X-TXC-SIGNATURE": this.Hmac(this.Encode(payload), this.Encode(this.Secret), sha512),
        }
        body = this.Json(params)
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *p2b) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsEqual(response, nil)) {
        return nil
    }
    if IsTrue(IsEqual(code, 400)) {
        var error interface{} = this.SafeValue(response, "error")
        var errorCode interface{} = this.SafeString(error, "code")
        var feedback interface{} = Add(Add(this.Id, " "), this.Json(response))
        this.ThrowExactlyMatchedException(this.Exceptions, errorCode, feedback)
    }
    return nil
}


func (this *p2b) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
