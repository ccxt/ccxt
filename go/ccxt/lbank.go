package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type lbank struct {
    Exchange

}

func NewLbankCore() lbank {
   p := lbank{}
   setDefaults(&p)
   return p
}

func  (this *lbank) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "lbank",
        "name": "LBank",
        "countries": []interface{}{"CN"},
        "version": "v2",
        "rateLimit": 20,
        "pro": true,
        "has": map[string]interface{} {
            "CORS": false,
            "spot": true,
            "margin": false,
            "swap": nil,
            "future": false,
            "option": false,
            "addMargin": false,
            "cancelAllOrders": true,
            "cancelOrder": true,
            "createMarketBuyOrderWithCost": true,
            "createMarketOrderWithCost": false,
            "createMarketSellOrderWithCost": false,
            "createOrder": true,
            "createReduceOnlyOrder": false,
            "createStopLimitOrder": false,
            "createStopMarketOrder": false,
            "createStopOrder": false,
            "fetchBalance": true,
            "fetchBorrowRateHistories": false,
            "fetchBorrowRateHistory": false,
            "fetchClosedOrders": false,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchDepositAddress": true,
            "fetchDepositAddresses": false,
            "fetchDepositAddressesByNetwork": false,
            "fetchDepositWithdrawFee": "emulated",
            "fetchDepositWithdrawFees": true,
            "fetchFundingHistory": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": true,
            "fetchIndexOHLCV": false,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchIsolatedPositions": false,
            "fetchLeverage": false,
            "fetchLeverageTiers": false,
            "fetchMarginMode": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrders": true,
            "fetchPosition": false,
            "fetchPositionMode": false,
            "fetchPositions": false,
            "fetchPositionsRisk": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTime": true,
            "fetchTrades": true,
            "fetchTradingFees": true,
            "fetchTransactionFees": true,
            "reduceMargin": false,
            "setLeverage": false,
            "setMarginMode": false,
            "setPositionMode": false,
            "withdraw": true,
        },
        "timeframes": map[string]interface{} {
            "1m": "minute1",
            "5m": "minute5",
            "15m": "minute15",
            "30m": "minute30",
            "1h": "hour1",
            "2h": "hour2",
            "4h": "hour4",
            "6h": "hour6",
            "8h": "hour8",
            "12h": "hour12",
            "1d": "day1",
            "1w": "week1",
        },
        "urls": map[string]interface{} {
            "logo": "https://user-images.githubusercontent.com/1294454/38063602-9605e28a-3302-11e8-81be-64b1e53c4cfb.jpg",
            "api": map[string]interface{} {
                "rest": "https://api.lbank.info",
                "contract": "https://lbkperp.lbank.com",
            },
            "api2": "https://api.lbkex.com",
            "www": "https://www.lbank.com",
            "doc": "https://www.lbank.com/en-US/docs/index.html",
            "fees": "https://support.lbank.site/hc/en-gb/articles/900000535703-Trading-Fees-From-14-00-on-April-7-2020-UTC-8-",
            "referral": "https://www.lbank.com/login/?icode=7QCY",
        },
        "api": map[string]interface{} {
            "spot": map[string]interface{} {
                "public": map[string]interface{} {
                    "get": map[string]interface{} {
                        "currencyPairs": 2.5,
                        "accuracy": 2.5,
                        "usdToCny": 2.5,
                        "withdrawConfigs": 2.5,
                        "timestamp": 2.5,
                        "ticker/24hr": 2.5,
                        "ticker": 2.5,
                        "depth": 2.5,
                        "incrDepth": 2.5,
                        "trades": 2.5,
                        "kline": 2.5,
                        "supplement/system_ping": 2.5,
                        "supplement/incrDepth": 2.5,
                        "supplement/trades": 2.5,
                        "supplement/ticker/price": 2.5,
                        "supplement/ticker/bookTicker": 2.5,
                    },
                    "post": map[string]interface{} {
                        "supplement/system_status": 2.5,
                    },
                },
                "private": map[string]interface{} {
                    "post": map[string]interface{} {
                        "user_info": 2.5,
                        "subscribe/get_key": 2.5,
                        "subscribe/refresh_key": 2.5,
                        "subscribe/destroy_key": 2.5,
                        "get_deposit_address": 2.5,
                        "deposit_history": 2.5,
                        "create_order": 1,
                        "batch_create_order": 1,
                        "cancel_order": 1,
                        "cancel_clientOrders": 1,
                        "orders_info": 2.5,
                        "orders_info_history": 2.5,
                        "order_transaction_detail": 2.5,
                        "transaction_history": 2.5,
                        "orders_info_no_deal": 2.5,
                        "withdraw": 2.5,
                        "withdrawCancel": 2.5,
                        "withdraws": 2.5,
                        "supplement/user_info": 2.5,
                        "supplement/withdraw": 2.5,
                        "supplement/deposit_history": 2.5,
                        "supplement/withdraws": 2.5,
                        "supplement/get_deposit_address": 2.5,
                        "supplement/asset_detail": 2.5,
                        "supplement/customer_trade_fee": 2.5,
                        "supplement/api_Restrictions": 2.5,
                        "supplement/system_ping": 2.5,
                        "supplement/create_order_test": 1,
                        "supplement/create_order": 1,
                        "supplement/cancel_order": 1,
                        "supplement/cancel_order_by_symbol": 1,
                        "supplement/orders_info": 2.5,
                        "supplement/orders_info_no_deal": 2.5,
                        "supplement/orders_info_history": 2.5,
                        "supplement/user_info_account": 2.5,
                        "supplement/transaction_history": 2.5,
                    },
                },
            },
            "contract": map[string]interface{} {
                "public": map[string]interface{} {
                    "get": map[string]interface{} {
                        "cfd/openApi/v1/pub/getTime": 2.5,
                        "cfd/openApi/v1/pub/instrument": 2.5,
                        "cfd/openApi/v1/pub/marketData": 2.5,
                        "cfd/openApi/v1/pub/marketOrder": 2.5,
                    },
                },
            },
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "maker": this.ParseNumber("0.001"),
                "taker": this.ParseNumber("0.001"),
            },
            "funding": map[string]interface{} {
                "withdraw": map[string]interface{} {},
            },
        },
        "commonCurrencies": map[string]interface{} {
            "HIT": "Hiver",
            "VET_ERC20": "VEN",
            "PNT": "Penta",
        },
        "precisionMode": TICK_SIZE,
        "options": map[string]interface{} {
            "cacheSecretAsPem": true,
            "createMarketBuyOrderRequiresPrice": true,
            "fetchTrades": map[string]interface{} {
                "method": "spotPublicGetTrades",
            },
            "fetchTransactionFees": map[string]interface{} {
                "method": "fetchPrivateTransactionFees",
            },
            "fetchDepositWithdrawFees": map[string]interface{} {
                "method": "fetchPrivateDepositWithdrawFees",
            },
            "fetchDepositAddress": map[string]interface{} {
                "method": "fetchDepositAddressDefault",
            },
            "createOrder": map[string]interface{} {
                "method": "spotPrivatePostSupplementCreateOrder",
            },
            "fetchOrder": map[string]interface{} {
                "method": "fetchOrderSupplement",
            },
            "fetchBalance": map[string]interface{} {
                "method": "spotPrivatePostSupplementUserInfo",
            },
            "networks": map[string]interface{} {
                "ERC20": "erc20",
                "ETH": "erc20",
                "TRC20": "trc20",
                "TRX": "trc20",
                "OMNI": "omni",
                "ASA": "asa",
                "BEP20": "bep20(bsc)",
                "BSC": "bep20(bsc)",
                "HT": "heco",
                "BNB": "bep2",
                "BTC": "btc",
                "DOGE": "dogecoin",
                "MATIC": "matic",
                "POLYGON": "matic",
                "OEC": "oec",
                "BTCTRON": "btctron",
                "XRP": "xrp",
            },
            "inverse-networks": map[string]interface{} {
                "erc20": "ERC20",
                "trc20": "TRC20",
                "omni": "OMNI",
                "asa": "ASA",
                "bep20(bsc)": "BSC",
                "bep20": "BSC",
                "heco": "HT",
                "bep2": "BNB",
                "btc": "BTC",
                "dogecoin": "DOGE",
                "matic": "MATIC",
                "oec": "OEC",
                "btctron": "BTCTRON",
                "xrp": "XRP",
            },
            "defaultNetworks": map[string]interface{} {
                "USDT": "TRC20",
            },
        },
        "features": map[string]interface{} {
            "default": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": false,
                    "triggerPriceType": nil,
                    "triggerDirection": false,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": true,
                        "FOK": true,
                        "PO": false,
                        "GTD": false,
                    },
                    "hedged": false,
                    "selfTradePrevention": false,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyByCost": true,
                    "marketBuyRequiresPrice": false,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": 100000,
                    "untilDays": 2,
                    "symbolRequired": true,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 200,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 200,
                    "daysBack": nil,
                    "untilDays": nil,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchClosedOrders": nil,
                "fetchOHLCV": map[string]interface{} {
                    "limit": 2000,
                },
            },
            "spot": map[string]interface{} {
                "extends": "default",
            },
            "swap": map[string]interface{} {
                "linear": map[string]interface{} {
                    "extends": "default",
                },
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
    })
}
/**
 * @method
 * @name lbank#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @see https://www.lbank.com/en-US/docs/index.html#get-timestamp
 * @see https://www.lbank.com/en-US/docs/contract.html#get-the-current-time
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func  (this *lbank) FetchTime(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchTime", nil, params);
            typeVar = GetValue(typeVarparamsVariable,0);
            params = GetValue(typeVarparamsVariable,1)
            var response interface{} = nil
            if IsTrue(IsEqual(typeVar, "swap")) {
                
        response = (<-this.ContractPublicGetCfdOpenApiV1PubGetTime(params))
                PanicOnError(response)
            } else {
                
        response = (<-this.SpotPublicGetTimestamp(params))
                PanicOnError(response)
            }
        
                //
            // spot
            //
            //     {
            //         "result": "true",
            //         "data": 1691789627950,
            //         "error_code": 0,
            //         "ts": 1691789627950
            //     }
            //
            // swap
            //
            //     {
            //         "data": 1691789627950,
            //         "error_code": 0,
            //         "msg": "Success",
            //         "result": "true",
            //         "success": true
            //     }
            //
        ch <- this.SafeInteger(response, "data")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name lbank#fetchMarkets
 * @description retrieves data on all markets for lbank
 * @see https://www.lbank.com/en-US/docs/index.html#trading-pairs
 * @see https://www.lbank.com/en-US/docs/contract.html#query-contract-information-list
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *lbank) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var marketsPromises interface{} = []interface{}{this.FetchSpotMarkets(params), this.FetchSwapMarkets(params)}
        
            resolvedMarkets:= (<-promiseAll(marketsPromises))
            PanicOnError(resolvedMarkets)
        
            ch <- this.ArrayConcat(GetValue(resolvedMarkets, 0), GetValue(resolvedMarkets, 1))
            return nil
        
            }()
            return ch
        }
func  (this *lbank) FetchSpotMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.SpotPublicGetAccuracy(params))
            PanicOnError(response)
            //
            //     {
            //         "result": "true",
            //         "data": [
            //             {
            //                 "symbol": "btc_usdt",
            //                 "quantityAccuracy": "4",
            //                 "minTranQua": "0.0001",
            //                 "priceAccuracy": "2"
            //             },
            //         ],
            //         "error_code": 0,
            //         "ts": 1691560288484
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", []interface{}{})
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
                var market interface{} = GetValue(data, i)
                var marketId interface{} = this.SafeString(market, "symbol")
                var parts interface{} = Split(marketId, "_")
                var baseId interface{} = GetValue(parts, 0)
                var quoteId interface{} = GetValue(parts, 1)
                var base interface{} = this.SafeCurrencyCode(baseId)
                var quote interface{} = this.SafeCurrencyCode(quoteId)
                var symbol interface{} = Add(Add(base, "/"), quote)
                AppendToArray(&result,map[string]interface{} {
                    "id": marketId,
                    "symbol": symbol,
                    "base": base,
                    "quote": quote,
                    "baseId": baseId,
                    "quoteId": quoteId,
                    "settle": nil,
                    "settleId": nil,
                    "type": "spot",
                    "spot": true,
                    "margin": false,
                    "swap": false,
                    "future": false,
                    "option": false,
                    "active": true,
                    "contract": false,
                    "linear": nil,
                    "inverse": nil,
                    "contractSize": nil,
                    "expiry": nil,
                    "expiryDatetime": nil,
                    "strike": nil,
                    "optionType": nil,
                    "precision": map[string]interface{} {
                        "amount": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "quantityAccuracy"))),
                        "price": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "priceAccuracy"))),
                    },
                    "limits": map[string]interface{} {
                        "leverage": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "amount": map[string]interface{} {
                            "min": this.SafeNumber(market, "minTranQua"),
                            "max": nil,
                        },
                        "price": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "cost": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                    },
                    "created": nil,
                    "info": market,
                })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *lbank) FetchSwapMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "productGroup": "SwapU",
            }
        
            response:= (<-this.ContractPublicGetCfdOpenApiV1PubInstrument(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "data": [
            //             {
            //                 "priceLimitUpperValue": 0.2,
            //                 "symbol": "BTCUSDT",
            //                 "volumeTick": 0.0001,
            //                 "indexPrice": "29707.70200000",
            //                 "minOrderVolume": "0.0001",
            //                 "priceTick": 0.1,
            //                 "maxOrderVolume": "30.0",
            //                 "baseCurrency": "BTC",
            //                 "volumeMultiple": 1.0,
            //                 "exchangeID": "Exchange",
            //                 "priceCurrency": "USDT",
            //                 "priceLimitLowerValue": 0.2,
            //                 "clearCurrency": "USDT",
            //                 "symbolName": "BTCUSDT",
            //                 "defaultLeverage": 20.0,
            //                 "minOrderCost": "5.0"
            //             },
            //         ],
            //         "error_code": 0,
            //         "msg": "Success",
            //         "result": "true",
            //         "success": true
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", []interface{}{})
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
                var market interface{} = GetValue(data, i)
                var marketId interface{} = this.SafeString(market, "symbol")
                var baseId interface{} = this.SafeString(market, "baseCurrency")
                var settleId interface{} = this.SafeString(market, "clearCurrency")
                var quoteId interface{} = settleId
                var base interface{} = this.SafeCurrencyCode(baseId)
                var quote interface{} = this.SafeCurrencyCode(quoteId)
                var settle interface{} = this.SafeCurrencyCode(settleId)
                var symbol interface{} = Add(Add(Add(Add(base, "/"), quote), ":"), settle)
                AppendToArray(&result,map[string]interface{} {
                    "id": marketId,
                    "symbol": symbol,
                    "base": base,
                    "quote": quote,
                    "settle": settle,
                    "baseId": baseId,
                    "quoteId": quoteId,
                    "settleId": settleId,
                    "type": "swap",
                    "spot": false,
                    "margin": false,
                    "swap": true,
                    "future": false,
                    "option": false,
                    "active": true,
                    "contract": true,
                    "linear": true,
                    "inverse": nil,
                    "contractSize": this.SafeNumber(market, "volumeMultiple"),
                    "expiry": nil,
                    "expiryDatetime": nil,
                    "strike": nil,
                    "optionType": nil,
                    "precision": map[string]interface{} {
                        "amount": this.SafeNumber(market, "volumeTick"),
                        "price": this.SafeNumber(market, "priceTick"),
                    },
                    "limits": map[string]interface{} {
                        "leverage": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "amount": map[string]interface{} {
                            "min": this.SafeNumber(market, "minOrderVolume"),
                            "max": this.SafeNumber(market, "maxOrderVolume"),
                        },
                        "price": map[string]interface{} {
                            "min": this.SafeNumber(market, "priceLimitLowerValue"),
                            "max": this.SafeNumber(market, "priceLimitUpperValue"),
                        },
                        "cost": map[string]interface{} {
                            "min": this.SafeNumber(market, "minOrderCost"),
                            "max": nil,
                        },
                    },
                    "created": nil,
                    "info": market,
                })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *lbank) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // spot: fetchTicker, fetchTickers
    //
    //     {
    //         "symbol": "btc_usdt",
    //         "ticker": {
    //             "high": "29695.57",
    //             "vol": "6890.2789",
    //             "low": "29110",
    //             "change": "0.58",
    //             "turnover": "202769821.06",
    //             "latest": "29405.98"
    //         },
    //         "timestamp": :1692064274908
    //     }
    //
    // swap: fetchTickers
    //
    //     {
    //         "prePositionFeeRate": "0.000053",
    //         "volume": "2435.459",
    //         "symbol": "BTCUSDT",
    //         "highestPrice": "29446.5",
    //         "lowestPrice": "29362.9",
    //         "openPrice": "29419.5",
    //         "markedPrice": "29385.1",
    //         "turnover": "36345526.2438402",
    //         "lastPrice": "29387.0"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger(ticker, "timestamp")
    var marketId interface{} = this.SafeString(ticker, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var tickerData interface{} = this.SafeValue(ticker, "ticker", map[string]interface{} {})
    market = this.SafeMarket(marketId, market)
    var data interface{} = Ternary(IsTrue((GetValue(market, "contract"))), ticker, tickerData)
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeString2(data, "high", "highestPrice"),
        "low": this.SafeString2(data, "low", "lowestPrice"),
        "bid": nil,
        "bidVolume": nil,
        "ask": nil,
        "askVolume": nil,
        "vwap": nil,
        "open": this.SafeString(data, "openPrice"),
        "close": nil,
        "last": this.SafeString2(data, "latest", "lastPrice"),
        "previousClose": nil,
        "change": nil,
        "percentage": this.SafeString(data, "change"),
        "average": nil,
        "baseVolume": this.SafeString2(data, "vol", "volume"),
        "quoteVolume": this.SafeString(data, "turnover"),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name lbank#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://www.lbank.com/en-US/docs/index.html#query-current-market-data-new
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *lbank) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes269966 := (<-this.LoadMarkets())
            PanicOnError(retRes269966)
            var market interface{} = this.Market(symbol)
            if IsTrue(GetValue(market, "swap")) {
        
                responseForSwap:= (<-this.FetchTickers([]interface{}{GetValue(market, "symbol")}, params))
                PanicOnError(responseForSwap)
        
                ch <- this.SafeValue(responseForSwap, GetValue(market, "symbol"))
                return nil
            }
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.SpotPublicGetTicker24hr(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "result": "true",
            //         "data": [
            //             {
            //                 "symbol": "btc_usdt",
            //                 "ticker": {
            //                     "high": "29695.57",
            //                     "vol": "6890.2789",
            //                     "low": "29110",
            //                     "change": "0.58",
            //                     "turnover": "202769821.06",
            //                     "latest": "29405.98"
            //                 },
            //                 "timestamp": :1692064274908
            //             }
            //         ],
            //         "error_code": 0,
            //         "ts": :1692064276872
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", []interface{}{})
            var first interface{} = this.SafeDict(data, 0, map[string]interface{} {})
        
            ch <- this.ParseTicker(first, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name lbank#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://www.lbank.com/en-US/docs/index.html#query-current-market-data-new
 * @see https://www.lbank.com/en-US/docs/contract.html#query-contract-market-list
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *lbank) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes32381 := (<-this.LoadMarkets())
            PanicOnError(retRes32381)
            var market interface{} = nil
            if IsTrue(!IsEqual(symbols, nil)) {
                symbols = this.MarketSymbols(symbols)
                var symbolsLength interface{} =         GetArrayLength(symbols)
                if IsTrue(IsGreaterThan(symbolsLength, 0)) {
                    market = this.Market(GetValue(symbols, 0))
                }
            }
            var request interface{} = map[string]interface{} {}
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchTickers", market, params);
            typeVar = GetValue(typeVarparamsVariable,0);
            params = GetValue(typeVarparamsVariable,1)
            var response interface{} = nil
            if IsTrue(IsEqual(typeVar, "swap")) {
                AddElementToObject(request, "productGroup", "SwapU")
                
        response = (<-this.ContractPublicGetCfdOpenApiV1PubMarketData(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                AddElementToObject(request, "symbol", "all")
                
        response = (<-this.SpotPublicGetTicker24hr(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            // spot
            //
            //     {
            //         "result": "true",
            //         "data": [
            //             {
            //                 "symbol": "btc_usdt",
            //                 "ticker": {
            //                     "high": "29695.57",
            //                     "vol": "6890.2789",
            //                     "low": "29110",
            //                     "change": "0.58",
            //                     "turnover": "202769821.06",
            //                     "latest": "29405.98"
            //                 },
            //                 "timestamp": :1692064274908
            //             }
            //         ],
            //         "error_code": 0,
            //         "ts": :1692064276872
            //     }
            //
            // swap
            //
            //     {
            //         "data": [
            //             {
            //                 "prePositionFeeRate": "0.000053",
            //                 "volume": "2435.459",
            //                 "symbol": "BTCUSDT",
            //                 "highestPrice": "29446.5",
            //                 "lowestPrice": "29362.9",
            //                 "openPrice": "29419.5",
            //                 "markedPrice": "29385.1",
            //                 "turnover": "36345526.2438402",
            //                 "lastPrice": "29387.0"
            //             },
            //         ],
            //         "error_code": 0,
            //         "msg": "Success",
            //         "result": "true",
            //         "success": true
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTickers(data, symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name lbank#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://www.lbank.com/en-US/docs/index.html#query-market-depth
 * @see https://www.lbank.com/en-US/docs/contract.html#get-handicap
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *lbank) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes860121 := (<-this.LoadMarkets())
            PanicOnError(retRes860121)
            var market interface{} = this.Market(symbol)
            if IsTrue(IsEqual(limit, nil)) {
                limit = 60
            }
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var typeVar interface{} = nil
            typeVarparamsVariable := this.HandleMarketTypeAndParams("fetchOrderBook", market, params);
            typeVar = GetValue(typeVarparamsVariable,0);
            params = GetValue(typeVarparamsVariable,1)
            var response interface{} = nil
            if IsTrue(IsEqual(typeVar, "swap")) {
                AddElementToObject(request, "depth", limit)
                
        response = (<-this.ContractPublicGetCfdOpenApiV1PubMarketOrder(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                AddElementToObject(request, "size", limit)
                
        response = (<-this.SpotPublicGetDepth(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            // spot
            //
            //     {
            //         "result": "true",
            //         "data": {
            //             "asks": [
            //                 ["29243.37", "2.8783"],
            //                 ["29243.39", "2.2842"],
            //                 ["29243.4", "0.0337"]
            //             ],
            //             "bids": [
            //                 ["29243.36", "1.5258"],
            //                 ["29243.34", "0.8218"],
            //                 ["29243.28", "1.285"]
            //             ],
            //             "timestamp": :1692157328820
            //         },
            //         "error_code": 0,
            //         "ts": :1692157328820
            //     }
            //
            // swap
            //
            //     {
            //         "data": {
            //             "symbol": "BTCUSDT",
            //             "asks": [
            //                 {
            //                     "volume": "14.6535",
            //                     "price": "29234.2",
            //                     "orders": "1"
            //                 },
            //             ],
            //             "bids": [
            //                 {
            //                     "volume": "13.4899",
            //                     "price": "29234.1",
            //                     "orders": "4"
            //                 },
            //             ]
            //         },
            //         "error_code": 0,
            //         "msg": "Success",
            //         "result": "true",
            //         "success": true
            //     }
            //
            var orderbook interface{} = this.SafeValue(response, "data", map[string]interface{} {})
            var timestamp interface{} = this.Milliseconds()
            if IsTrue(GetValue(market, "swap")) {
        
                ch <- this.ParseOrderBook(orderbook, GetValue(market, "symbol"), timestamp, "bids", "asks", "price", "volume")
                return nil
            }
        
            ch <- this.ParseOrderBook(orderbook, GetValue(market, "symbol"), timestamp)
            return nil
        
            }()
            return ch
        }
func  (this *lbank) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTrades (old) spotPublicGetTrades
    //
    //      {
    //          "date_ms":1647021989789,
    //          "amount":0.0028,
    //          "price":38804.2,
    //          "type":"buy",
    //          "tid":"52d5616ee35c43019edddebe59b3e094"
    //      }
    //
    //
    // fetchTrades (new) spotPublicGetTradesSupplement
    //
    //      {
    //          "quoteQty":1675.048485,
    //          "price":0.127545,
    //          "qty":13133,
    //          "id":"3589541dc22e4357b227283650f714e2",
    //          "time":1648058297110,
    //          "isBuyerMaker":false
    //      }
    //
    // fetchMyTrades (private)
    //
    //      {
    //          "orderUuid":"38b4e7a4-14f6-45fd-aba1-1a37024124a0",
    //          "tradeFeeRate":0.0010000000,
    //          "dealTime":1648500944496,
    //          "dealQuantity":30.00000000000000000000,
    //          "tradeFee":0.00453300000000000000,
    //          "txUuid":"11f3850cc6214ea3b495adad3a032794",
    //          "dealPrice":0.15111300000000000000,
    //          "dealVolumePrice":4.53339000000000000000,
    //          "tradeType":"sell_market"
    //      }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger2(trade, "date_ms", "time")
    if IsTrue(IsEqual(timestamp, nil)) {
        timestamp = this.SafeInteger(trade, "dealTime")
    }
    var amountString interface{} = this.SafeString2(trade, "amount", "qty")
    if IsTrue(IsEqual(amountString, nil)) {
        amountString = this.SafeString(trade, "dealQuantity")
    }
    var priceString interface{} = this.SafeString(trade, "price")
    if IsTrue(IsEqual(priceString, nil)) {
        priceString = this.SafeString(trade, "dealPrice")
    }
    var costString interface{} = this.SafeString(trade, "quoteQty")
    if IsTrue(IsEqual(costString, nil)) {
        costString = this.SafeString(trade, "dealVolumePrice")
    }
    var side interface{} = this.SafeString2(trade, "tradeType", "type")
    var typeVar interface{} = nil
    var takerOrMaker interface{} = nil
    if IsTrue(!IsEqual(side, nil)) {
        var parts interface{} = Split(side, "_")
        side = this.SafeString(parts, 0)
        var typePart interface{} = this.SafeString(parts, 1)
        typeVar = "limit"
        takerOrMaker = "taker"
        if IsTrue(!IsEqual(typePart, nil)) {
            if IsTrue(IsEqual(typePart, "market")) {
                typeVar = "market"
            } else if IsTrue(IsEqual(typePart, "maker")) {
                takerOrMaker = "maker"
            }
        }
    }
    var id interface{} = this.SafeString2(trade, "tid", "id")
    if IsTrue(IsEqual(id, nil)) {
        id = this.SafeString(trade, "txUuid")
    }
    var order interface{} = this.SafeString(trade, "orderUuid")
    var symbol interface{} = this.SafeSymbol(nil, market)
    var fee interface{} = nil
    var feeCost interface{} = this.SafeString(trade, "tradeFee")
    if IsTrue(!IsEqual(feeCost, nil)) {
        fee = map[string]interface{} {
            "cost": feeCost,
            "currency": Ternary(IsTrue((IsEqual(side, "buy"))), GetValue(market, "base"), GetValue(market, "quote")),
            "rate": this.SafeString(trade, "tradeFeeRate"),
        }
    }
    return this.SafeTrade(map[string]interface{} {
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "id": id,
        "order": order,
        "type": typeVar,
        "takerOrMaker": takerOrMaker,
        "side": side,
        "price": priceString,
        "amount": amountString,
        "cost": costString,
        "fee": fee,
        "info": trade,
    }, market)
}
/**
 * @method
 * @name lbank#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://www.lbank.com/en-US/docs/index.html#query-historical-transactions
 * @see https://www.lbank.com/en-US/docs/index.html#recent-transactions-list
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *lbank) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes428423 := (<-this.LoadMarkets())
            PanicOnError(retRes428423)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "time", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "size", mathMin(limit, 600))
            } else {
                AddElementToObject(request, "size", 600) // max
            }
            var options interface{} = this.SafeValue(this.Options, "fetchTrades", map[string]interface{} {})
            var defaultMethod interface{} = this.SafeString(options, "method", "spotPublicGetTrades")
            var method interface{} = this.SafeString(params, "method", defaultMethod)
            params = this.Omit(params, "method")
            var response interface{} = nil
            if IsTrue(IsEqual(method, "spotPublicGetSupplementTrades")) {
                
        response = (<-this.SpotPublicGetSupplementTrades(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.SpotPublicGetTrades(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            //      {
            //          "result":"true",
            //          "data": [
            //              {
            //                  "date_ms":1647021989789,
            //                  "amount":0.0028,
            //                  "price":38804.2,
            //                  "type":"buy",
            //                  "tid":"52d5616ee35c43019edddebe59b3e094"
            //               }
            //           ],
            //           "error_code":0,
            //           "ts":1647021999308
            //      }
            //
            var trades interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTrades(trades, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *lbank) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //   [
    //     1482311500, // timestamp
    //     5423.23,    // open
    //     5472.80,    // high
    //     5516.09,    // low
    //     5462,       // close
    //     234.3250    // volume
    //   ],
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.SafeTimestamp(ohlcv, 0), this.SafeNumber(ohlcv, 1), this.SafeNumber(ohlcv, 2), this.SafeNumber(ohlcv, 3), this.SafeNumber(ohlcv, 4), this.SafeNumber(ohlcv, 5)}
}
/**
 * @method
 * @name lbank#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://www.lbank.com/en-US/docs/index.html#query-k-bar-data
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *lbank) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    // endpoint doesnt work
            timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes309798 := (<-this.LoadMarkets())
            PanicOnError(retRes309798)
            var market interface{} = this.Market(symbol)
            if IsTrue(IsEqual(limit, nil)) {
                limit = 100
            } else {
                limit = mathMin(limit, 2000)
            }
            if IsTrue(IsEqual(since, nil)) {
                var duration interface{} = this.ParseTimeframe(timeframe)
                since = Subtract(this.Milliseconds(), (Multiply(Multiply(duration, 1000), limit)))
            }
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "type": this.SafeString(this.Timeframes, timeframe, timeframe),
                "time": this.ParseToInt(Divide(since, 1000)),
                "size": mathMin(Add(limit, 1), 2000),
            }
        
            response:= (<-this.SpotPublicGetKline(this.Extend(request, params)))
            PanicOnError(response)
            var ohlcvs interface{} = this.SafeList(response, "data", []interface{}{})
        
                //
            //
            // [
            //   [
            //     1482311500,
            //     5423.23,
            //     5472.80,
            //     5516.09,
            //     5462,
            //     234.3250
            //   ],
            //   [
            //     1482311400,
            //     5432.52,
            //     5459.87,
            //     5414.30,
            //     5428.23,
            //     213.7329
            //   ]
            // ]
            //
        ch <- this.ParseOHLCVs(ohlcvs, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *lbank) ParseBalance(response interface{}) interface{}  {
    //
    // spotPrivatePostUserInfo
    //
    //      {
    //          "toBtc": {
    //              "egc:": "0",
    //              "iog": "0",
    //              "ksm": "0",
    //              },
    //          "freeze": {
    //              "egc": "0",
    //              "iog": "0",
    //              "ksm": "0" ,
    //              },
    //          "asset": {
    //              "egc": "0",
    //              "iog": "0",
    //              "ksm": "0",
    //              },
    //          "free": {
    //              "egc": "0",
    //              "iog": "0",
    //              "ksm": "0",
    //              }
    //      }
    //
    // spotPrivatePostSupplementUserInfoAccount
    //
    //      {
    //          "balances":[
    //              {
    //                  "asset":"lbk",
    //                  "free":"0",
    //                  "locked":"0"
    //              }, ...
    //          ]
    //      }
    //
    // spotPrivatePostSupplementUserInfo
    //
    //      [
    //          {
    //              "usableAmt":"31.45130723",
    //              "assetAmt":"31.45130723",
    //              "networkList":[
    //                  {
    //                      "isDefault":true,
    //                      "withdrawFeeRate":"",
    //                      "name":"bep20(bsc)",
    //                      "withdrawMin":30,
    //                      "minLimit":0.0001,
    //                      "minDeposit":0.0001,
    //                      "feeAssetCode":"doge",
    //                      "withdrawFee":"30",
    //                      "type":1,
    //                      "coin":"doge",
    //                      "network":"bsc"
    //                  },
    //                  {
    //                      "isDefault":false,
    //                      "withdrawFeeRate":"",
    //                      "name":"dogecoin",
    //                      "withdrawMin":10,
    //                      "minLimit":0.0001,
    //                      "minDeposit":10,
    //                      "feeAssetCode":"doge",
    //                      "withdrawFee":"10",
    //                      "type":1,
    //                      "coin":"doge",
    //                      "network":"dogecoin"
    //                  }
    //              ],
    //              "freezeAmt":"0",
    //              "coin":"doge"
    //          }, ...
    //      ]
    //
    var timestamp interface{} = this.SafeInteger(response, "ts")
    var result interface{} = map[string]interface{} {
        "info": response,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
    }
    var data interface{} = this.SafeValue(response, "data")
    // from spotPrivatePostUserInfo
    var toBtc interface{} = this.SafeValue(data, "toBtc")
    if IsTrue(!IsEqual(toBtc, nil)) {
        var used interface{} = this.SafeValue(data, "freeze", map[string]interface{} {})
        var free interface{} = this.SafeValue(data, "free", map[string]interface{} {})
        var currencies interface{} = ObjectKeys(free)
        for i := 0; IsLessThan(i, GetArrayLength(currencies)); i++ {
            var currencyId interface{} = GetValue(currencies, i)
            var code interface{} = this.SafeCurrencyCode(currencyId)
            var account interface{} = this.Account()
            AddElementToObject(account, "used", this.SafeString(used, currencyId))
            AddElementToObject(account, "free", this.SafeString(free, currencyId))
            AddElementToObject(result, code, account)
        }
        return this.SafeBalance(result)
    }
    // from spotPrivatePostSupplementUserInfoAccount
    var balances interface{} = this.SafeValue(data, "balances")
    if IsTrue(!IsEqual(balances, nil)) {
        for i := 0; IsLessThan(i, GetArrayLength(balances)); i++ {
            var item interface{} = GetValue(balances, i)
            var currencyId interface{} = this.SafeString(item, "asset")
            var codeInner interface{} = this.SafeCurrencyCode(currencyId)
            var account interface{} = this.Account()
            AddElementToObject(account, "free", this.SafeString(item, "free"))
            AddElementToObject(account, "used", this.SafeString(item, "locked"))
            AddElementToObject(result, codeInner, account)
        }
        return this.SafeBalance(result)
    }
    // from spotPrivatePostSupplementUserInfo
    var isArray interface{} = IsArray(data)
    if IsTrue(IsEqual(isArray, true)) {
        for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
            var item interface{} = GetValue(data, i)
            var currencyId interface{} = this.SafeString(item, "coin")
            var codeInner interface{} = this.SafeCurrencyCode(currencyId)
            var account interface{} = this.Account()
            AddElementToObject(account, "free", this.SafeString(item, "usableAmt"))
            AddElementToObject(account, "used", this.SafeString(item, "freezeAmt"))
            AddElementToObject(result, codeInner, account)
        }
        return this.SafeBalance(result)
    }
    return nil
}
func  (this *lbank) ParseFundingRate(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    // {
    //     "symbol": "BTCUSDT",
    //     "highestPrice": "69495.5",
    //     "underlyingPrice": "68455.904",
    //     "lowestPrice": "68182.1",
    //     "openPrice": "68762.4",
    //     "positionFeeRate": "0.0001",
    //     "volume": "33534.2858",
    //     "markedPrice": "68434.1",
    //     "turnover": "1200636218.210558",
    //     "positionFeeTime": "28800",
    //     "lastPrice": "68427.3",
    //     "nextFeeTime": "1730736000000",
    //     "fundingRate": "0.0001",
    // }
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(ticker, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var markPrice interface{} = this.SafeNumber(ticker, "markedPrice")
    var indexPrice interface{} = this.SafeNumber(ticker, "underlyingPrice")
    var fundingRate interface{} = this.SafeNumber(ticker, "fundingRate")
    var fundingTime interface{} = this.SafeInteger(ticker, "nextFeeTime")
    var positionFeeTime interface{} = this.SafeInteger(ticker, "positionFeeTime")
    var intervalString interface{} = nil
    if IsTrue(!IsEqual(positionFeeTime, nil)) {
        var interval interface{} = this.ParseToInt(Divide(Divide(positionFeeTime, 60), 60))
        intervalString = Add(ToString(interval), "h")
    }
    return map[string]interface{} {
        "info": ticker,
        "symbol": symbol,
        "markPrice": markPrice,
        "indexPrice": indexPrice,
        "fundingRate": fundingRate,
        "fundingTimestamp": fundingTime,
        "fundingDatetime": this.Iso8601(fundingTime),
        "timestamp": nil,
        "datetime": nil,
        "nextFundingRate": nil,
        "nextFundingTimestamp": nil,
        "nextFundingDatetime": nil,
        "previousFundingRate": nil,
        "previousFundingTimestamp": nil,
        "previousFundingDatetime": nil,
        "interval": intervalString,
    }
}
/**
 * @method
 * @name lbank#fetchFundingRate
 * @description fetch the current funding rate
 * @see https://www.lbank.com/en-US/docs/contract.html#query-contract-market-list
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
 */
func  (this *lbank) FetchFundingRate(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes88150 := (<-this.LoadMarkets())
            PanicOnError(retRes88150)
            var market interface{} = this.Market(symbol)
        
            responseForSwap:= (<-this.FetchFundingRates([]interface{}{GetValue(market, "symbol")}, params))
            PanicOnError(responseForSwap)
        
            ch <- this.SafeValue(responseForSwap, GetValue(market, "symbol"))
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name lbank#fetchFundingRates
 * @description fetch the funding rate for multiple markets
 * @see https://www.lbank.com/en-US/docs/contract.html#query-contract-market-list
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rates-structure}, indexed by market symbols
 */
func  (this *lbank) FetchFundingRates(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes623508 := (<-this.LoadMarkets())
            PanicOnError(retRes623508)
            symbols = this.MarketSymbols(symbols)
            var request interface{} = map[string]interface{} {
                "productGroup": "SwapU",
            }
        
            response:= (<-this.ContractPublicGetCfdOpenApiV1PubMarketData(this.Extend(request, params)))
            PanicOnError(response)
            // {
            //     "data": [
            //         {
            //             "symbol": "BTCUSDT",
            //             "highestPrice": "69495.5",
            //             "underlyingPrice": "68455.904",
            //             "lowestPrice": "68182.1",
            //             "openPrice": "68762.4",
            //             "positionFeeRate": "0.0001",
            //             "volume": "33534.2858",
            //             "markedPrice": "68434.1",
            //             "turnover": "1200636218.210558",
            //             "positionFeeTime": "28800",
            //             "lastPrice": "68427.3",
            //             "nextFeeTime": "1730736000000",
            //             "fundingRate": "0.0001",
            //         }
            //     ],
            //     "error_code": "0",
            //     "msg": "Success",
            //     "result": "true",
            //     "success": True,
            // }
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseFundingRates(data, symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name lbank#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://www.lbank.com/en-US/docs/index.html#asset-information
 * @see https://www.lbank.com/en-US/docs/index.html#account-information
 * @see https://www.lbank.com/en-US/docs/index.html#get-all-coins-information
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *lbank) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes408646 := (<-this.LoadMarkets())
            PanicOnError(retRes408646)
            var options interface{} = this.SafeValue(this.Options, "fetchBalance", map[string]interface{} {})
            var defaultMethod interface{} = this.SafeString(options, "method", "spotPrivatePostSupplementUserInfo")
            var method interface{} = this.SafeString(params, "method", defaultMethod)
            var response interface{} = nil
            if IsTrue(IsEqual(method, "spotPrivatePostSupplementUserInfoAccount")) {
                
        response = (<-this.SpotPrivatePostSupplementUserInfoAccount())
                PanicOnError(response)
            } else if IsTrue(IsEqual(method, "spotPrivatePostUserInfo")) {
                
        response = (<-this.SpotPrivatePostUserInfo())
                PanicOnError(response)
            } else {
                
        response = (<-this.SpotPrivatePostSupplementUserInfo())
                PanicOnError(response)
            }
        
                //
            //    {
            //        "result": "true",
            //        "data": [
            //            {
            //                "usableAmt": "14.36",
            //                "assetAmt": "14.36",
            //                "networkList": [
            //                    {
            //                        "isDefault": false,
            //                        "withdrawFeeRate": "",
            //                        "name": "erc20",
            //                        "withdrawMin": 30,
            //                        "minLimit": 0.0001,
            //                        "minDeposit": 20,
            //                        "feeAssetCode": "usdt",
            //                        "withdrawFee": "30",
            //                        "type": 1,
            //                        "coin": "usdt",
            //                        "network": "eth"
            //                    },
            //                    ...
            //                ],
            //                "freezeAmt": "0",
            //                "coin": "ada"
            //            }
            //        ],
            //        "code": 0
            //    }
            //
        ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
func  (this *lbank) ParseTradingFee(fee interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //      {
    //          "symbol":"skt_usdt",
    //          "makerCommission":"0.10",
    //          "takerCommission":"0.10"
    //      }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(fee, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId)
    return map[string]interface{} {
        "info": fee,
        "symbol": symbol,
        "maker": this.SafeNumber(fee, "makerCommission"),
        "taker": this.SafeNumber(fee, "takerCommission"),
        "percentage": nil,
        "tierBased": nil,
    }
}
/**
 * @method
 * @name lbank#fetchTradingFee
 * @description fetch the trading fees for a market
 * @see https://www.lbank.com/en-US/docs/index.html#transaction-fee-rate-query
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func  (this *lbank) FetchTradingFee(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var market interface{} = this.Market(symbol)
        
            result:= (<-this.FetchTradingFees(this.Extend(params, map[string]interface{} {
            "category": GetValue(market, "id"),
        })))
            PanicOnError(result)
        
            ch <- this.SafeDict(result, symbol)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name lbank#fetchTradingFees
 * @description fetch the trading fees for multiple markets
 * @see https://www.lbank.com/en-US/docs/index.html#transaction-fee-rate-query
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
 */
func  (this *lbank) FetchTradingFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes219638 := (<-this.LoadMarkets())
            PanicOnError(retRes219638)
            var request interface{} = map[string]interface{} {}
        
            response:= (<-this.SpotPrivatePostSupplementCustomerTradeFee(this.Extend(request, params)))
            PanicOnError(response)
            var fees interface{} = this.SafeValue(response, "data", []interface{}{})
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(fees)); i++ {
                var fee interface{} = this.ParseTradingFee(GetValue(fees, i))
                var symbol interface{} = GetValue(fee, "symbol")
                AddElementToObject(result, symbol, fee)
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name lbank#createMarketBuyOrderWithCost
 * @description create a market buy order by providing the symbol and cost
 * @see https://www.lbank.com/en-US/docs/index.html#place-order
 * @see https://www.lbank.com/en-US/docs/index.html#place-an-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {float} cost how much you want to trade in units of the quote currency
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *lbank) CreateMarketBuyOrderWithCost(symbol interface{}, cost interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes460393 := (<-this.LoadMarkets())
            PanicOnError(retRes460393)
            var market interface{} = this.Market(symbol)
            if !IsTrue(GetValue(market, "spot")) {
                panic(NotSupported(Add(this.Id, " createMarketBuyOrderWithCost() supports spot orders only")))
            }
            AddElementToObject(params, "createMarketBuyOrderRequiresPrice", false)
        
                retRes930271 :=  (<-this.CreateOrder(symbol, "market", "buy", cost, nil, params))
                PanicOnError(retRes930271)
                ch <- retRes930271
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name lbank#createOrder
 * @description create a trade order
 * @see https://www.lbank.com/en-US/docs/index.html#place-order
 * @see https://www.lbank.com/en-US/docs/index.html#place-an-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *lbank) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes670881 := (<-this.LoadMarkets())
            PanicOnError(retRes670881)
            var market interface{} = this.Market(symbol)
            var clientOrderId interface{} = this.SafeString2(params, "custom_id", "clientOrderId")
            var postOnly interface{} = this.SafeBool(params, "postOnly", false)
            var timeInForce interface{} = this.SafeStringUpper(params, "timeInForce")
            params = this.Omit(params, []interface{}{"custom_id", "clientOrderId", "timeInForce", "postOnly"})
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var ioc interface{} =     (IsEqual(timeInForce, "IOC"))
            var fok interface{} =     (IsEqual(timeInForce, "FOK"))
            var maker interface{} =     (IsTrue(postOnly) || IsTrue((IsEqual(timeInForce, "PO"))))
            if IsTrue(IsTrue((IsEqual(typeVar, "market"))) && IsTrue((IsTrue(IsTrue(ioc) || IsTrue(fok)) || IsTrue(maker)))) {
                panic(InvalidOrder(Add(this.Id, " createOrder () does not allow market FOK, IOC, or postOnly orders. Only limit IOC, FOK, and postOnly orders are allowed")))
            }
            if IsTrue(IsEqual(typeVar, "limit")) {
                AddElementToObject(request, "type", side)
                AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
                AddElementToObject(request, "amount", this.AmountToPrecision(symbol, amount))
                if IsTrue(ioc) {
                    AddElementToObject(request, "type", Add(Add(side, "_"), "ioc"))
                } else if IsTrue(fok) {
                    AddElementToObject(request, "type", Add(Add(side, "_"), "fok"))
                } else if IsTrue(maker) {
                    AddElementToObject(request, "type", Add(Add(side, "_"), "maker"))
                }
            } else if IsTrue(IsEqual(typeVar, "market")) {
                if IsTrue(IsEqual(side, "sell")) {
                    AddElementToObject(request, "type", Add(Add(side, "_"), "market"))
                    AddElementToObject(request, "amount", this.AmountToPrecision(symbol, amount))
                } else if IsTrue(IsEqual(side, "buy")) {
                    AddElementToObject(request, "type", Add(Add(side, "_"), "market"))
                    var quoteAmount interface{} = nil
                    var createMarketBuyOrderRequiresPrice interface{} = true
                    createMarketBuyOrderRequiresPriceparamsVariable := this.HandleOptionAndParams(params, "createOrder", "createMarketBuyOrderRequiresPrice", true);
                    createMarketBuyOrderRequiresPrice = GetValue(createMarketBuyOrderRequiresPriceparamsVariable,0);
                    params = GetValue(createMarketBuyOrderRequiresPriceparamsVariable,1)
                    var cost interface{} = this.SafeNumber(params, "cost")
                    params = this.Omit(params, "cost")
                    if IsTrue(!IsEqual(cost, nil)) {
                        quoteAmount = this.CostToPrecision(symbol, cost)
                    } else if IsTrue(createMarketBuyOrderRequiresPrice) {
                        if IsTrue(IsEqual(price, nil)) {
                            panic(InvalidOrder(Add(this.Id, " createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend in the amount argument")))
                        } else {
                            var amountString interface{} = this.NumberToString(amount)
                            var priceString interface{} = this.NumberToString(price)
                            var costRequest interface{} = Precise.StringMul(amountString, priceString)
                            quoteAmount = this.CostToPrecision(symbol, costRequest)
                        }
                    } else {
                        quoteAmount = this.CostToPrecision(symbol, amount)
                    }
                    // market buys require filling the price param instead of the amount param, for market buys the price is treated as the cost by lbank
                    AddElementToObject(request, "price", quoteAmount)
                }
            }
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                AddElementToObject(request, "custom_id", clientOrderId)
            }
            var options interface{} = this.SafeValue(this.Options, "createOrder", map[string]interface{} {})
            var defaultMethod interface{} = this.SafeString(options, "method", "spotPrivatePostSupplementCreateOrder")
            var method interface{} = this.SafeString(params, "method", defaultMethod)
            params = this.Omit(params, "method")
            var response interface{} = nil
            if IsTrue(IsEqual(method, "spotPrivatePostCreateOrder")) {
                
        response = (<-this.SpotPrivatePostCreateOrder(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.SpotPrivatePostSupplementCreateOrder(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            //      {
            //          "result":true,
            //          "data":{
            //              "symbol":"doge_usdt",
            //              "order_id":"0cf8a3de-4597-4296-af45-be7abaa06b07"
            //              },
            //          "error_code":0,
            //          "ts":1648162321043
            //      }
            //
            var result interface{} = this.SafeValue(response, "data", map[string]interface{} {})
        
            ch <- this.SafeOrder(map[string]interface{} {
                "id": this.SafeString(result, "order_id"),
                "info": result,
            }, market)
            return nil
        
            }()
            return ch
        }
func  (this *lbank) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "-1": "canceled",
        "0": "open",
        "1": "open",
        "2": "closed",
        "3": "canceled",
        "4": "closed",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *lbank) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchOrderSupplement (private)
    //
    //      {
    //          "cummulativeQuoteQty":0,
    //          "symbol":"doge_usdt",
    //          "executedQty":0,
    //          "orderId":"53d2d53e-70fb-4398-b722-f48571a5f61e",
    //          "origQty":1E+2,
    //          "price":0.05,
    //          "clientOrderId":null,
    //          "origQuoteOrderQty":5,
    //          "updateTime":1648163406000,
    //          "time":1648163139387,
    //          "type":"buy_maker",
    //          "status":-1
    //      }
    //
    //
    // fetchOrderDefault (private)
    //
    //      {
    //          "symbol":"shib_usdt",
    //          "amount":1,
    //          "create_time":1649367863356,
    //          "price":0.0000246103,
    //          "avg_price":0.00002466180000000104,
    //          "type":"buy_market",
    //          "order_id":"abe8b92d-86d9-4d6d-b71e-d14f5fb53ddf",
    //          "custom_id": "007",                                 // field only present if user creates it at order time
    //          "deal_amount":40548.54065802,
    //          "status":2
    //      }
    //
    // fetchOpenOrders (private)
    //
    //      {
    //          "cummulativeQuoteQty":0,
    //          "symbol":"doge_usdt",
    //          "executedQty":0,
    //          "orderId":"73878edf-008d-4e4c-8041-df1f1b2cd8bb",
    //          "origQty":100,
    //          "price":0.05,
    //          "origQuoteOrderQty":5,
    //          "updateTime":1648501762000,
    //          "time":1648501762353,
    //          "type":"buy",
    //          "status":0
    //      }
    //
    // fetchOrders (private)
    //
    //      {
    //          "cummulativeQuoteQty":0,
    //          "symbol":"doge_usdt",
    //          "executedQty":0,
    //          "orderId":"2cadc7cc-b5f6-486b-a5b4-d6ac49a9c186",
    //          "origQty":100,
    //          "price":0.05,
    //          "origQuoteOrderQty":5,
    //          "updateTime":1648501384000,
    //          "time":1648501363889,
    //          "type":"buy",
    //          "status":-1
    //      }
    //
    // cancelOrder
    //
    //    {
    //        "executedQty":0.0,
    //        "price":0.05,
    //        "origQty":100.0,
    //        "tradeType":"buy",
    //        "status":0
    //    }
    //
    // cancelAllOrders
    //
    //    {
    //        "executedQty":0.00000000000000000000,
    //        "orderId":"293ef71b-3e67-4962-af93-aa06990a045f",
    //        "price":0.05000000000000000000,
    //        "origQty":100.00000000000000000000,
    //        "tradeType":"buy",
    //        "status":0
    //    }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeString2(order, "orderId", "order_id")
    var clientOrderId interface{} = this.SafeString2(order, "clientOrderId", "custom_id")
    var timestamp interface{} = this.SafeInteger2(order, "time", "create_time")
    var rawStatus interface{} = this.SafeString(order, "status")
    var marketId interface{} = this.SafeString(order, "symbol")
    market = this.SafeMarket(marketId, market)
    var timeInForce interface{} = nil
    var postOnly interface{} = false
    var typeVar interface{} = "limit"
    var rawType interface{} = this.SafeString2(order, "type", "tradeType") // buy, sell, buy_market, sell_market, buy_maker,sell_maker,buy_ioc,sell_ioc, buy_fok, sell_fok
    var parts interface{} = Split(rawType, "_")
    var side interface{} = this.SafeString(parts, 0)
    var typePart interface{} = this.SafeString(parts, 1) // market, maker, ioc, fok or undefined (limit)
    if IsTrue(IsEqual(typePart, "market")) {
        typeVar = "market"
    }
    if IsTrue(IsEqual(typePart, "maker")) {
        postOnly = true
        timeInForce = "PO"
    }
    if IsTrue(IsEqual(typePart, "ioc")) {
        timeInForce = "IOC"
    }
    if IsTrue(IsEqual(typePart, "fok")) {
        timeInForce = "FOK"
    }
    var price interface{} = this.SafeString(order, "price")
    var costString interface{} = this.SafeString(order, "cummulativeQuoteQty")
    var amountString interface{} = nil
    if IsTrue(!IsEqual(rawType, "buy_market")) {
        amountString = this.SafeString2(order, "origQty", "amount")
    }
    var filledString interface{} = this.SafeString2(order, "executedQty", "deal_amount")
    return this.SafeOrder(map[string]interface{} {
        "id": id,
        "clientOrderId": clientOrderId,
        "datetime": this.Iso8601(timestamp),
        "timestamp": timestamp,
        "lastTradeTimestamp": nil,
        "status": this.ParseOrderStatus(rawStatus),
        "symbol": GetValue(market, "symbol"),
        "type": typeVar,
        "timeInForce": timeInForce,
        "postOnly": postOnly,
        "side": side,
        "price": price,
        "triggerPrice": nil,
        "cost": costString,
        "amount": amountString,
        "filled": filledString,
        "remaining": nil,
        "trades": nil,
        "fee": nil,
        "info": order,
        "average": nil,
    }, market)
}
/**
 * @method
 * @name lbank#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://www.lbank.com/en-US/docs/index.html#query-order
 * @see https://www.lbank.com/en-US/docs/index.html#query-order-new
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *lbank) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes612824 := (<-this.LoadMarkets())
            PanicOnError(retRes612824)
            var method interface{} = this.SafeString(params, "method")
            if IsTrue(IsEqual(method, nil)) {
                var options interface{} = this.SafeValue(this.Options, "fetchOrder", map[string]interface{} {})
                method = this.SafeString(options, "method", "fetchOrderSupplement")
            }
            if IsTrue(IsEqual(method, "fetchOrderSupplement")) {
        
                    retRes170178 :=  (<-this.FetchOrderSupplement(id, symbol, params))
                    PanicOnError(retRes170178)
                    ch <- retRes170178
                    return nil
            }
        
                retRes722105 :=  (<-this.FetchOrderDefault(id, symbol, params))
                PanicOnError(retRes722105)
                ch <- retRes722105
                return nil
        
            }()
            return ch
        }
func  (this *lbank) FetchOrderSupplement(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchOrder() requires a symbol argument")))
            }
        
            retRes683416 := (<-this.LoadMarkets())
            PanicOnError(retRes683416)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "orderId": id,
            }
        
            response:= (<-this.SpotPrivatePostSupplementOrdersInfo(this.Extend(request, params)))
            PanicOnError(response)
            //
            //      {
            //          "result":true,
            //          "data":{
            //              "cummulativeQuoteQty":0,
            //              "symbol":"doge_usdt",
            //              "executedQty":0,
            //              "orderId":"53d2d53e-70fb-4398-b722-f48571a5f61e",
            //              "origQty":1E+2,
            //              "price":0.05,
            //              "clientOrderId":null,
            //              "origQuoteOrderQty":5,
            //              "updateTime":1648163406000,
            //              "time":1648163139387,
            //              "type":"buy_maker",
            //              "status":-1
            //              },
            //          "error_code":0,
            //          "ts":1648164471827
            //      }
            //
            var result interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseOrder(result)
            return nil
        
            }()
            return ch
        }
func  (this *lbank) FetchOrderDefault(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    // Id can be a list of ids delimited by a comma
            symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchOrder() requires a symbol argument")))
            }
        
            retRes808722 := (<-this.LoadMarkets())
            PanicOnError(retRes808722)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "order_id": id,
            }
        
            response:= (<-this.SpotPrivatePostOrdersInfo(this.Extend(request, params)))
            PanicOnError(response)
            //
            //      {
            //          "result":true,
            //          "data":[
            //              {
            //                  "symbol":"doge_usdt",
            //                  "amount":18,
            //                  "create_time":1647455223186,
            //                  "price":0,
            //                  "avg_price":0.113344,
            //                  "type":"sell_market",
            //                  "order_id":"d4ca1ddd-40d9-42c1-9717-5de435865bec",
            //                  "deal_amount":18,
            //                  "status":2
            //                }
            //            ],
            //          "error_code":0,
            //          "ts":1647455270776
            //      }
            //
            var result interface{} = this.SafeValue(response, "data", []interface{}{})
            var numOrders interface{} =     GetArrayLength(result)
            if IsTrue(IsEqual(numOrders, 1)) {
        
                ch <- this.ParseOrder(GetValue(result, 0))
                return nil
            } else {
                panic(BadRequest(Add(this.Id, " fetchOrder() can only fetch one order at a time")))
            }
                return nil
            }()
            return ch
        }
/**
 * @method
 * @name lbank#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://www.lbank.com/en-US/docs/index.html#past-transaction-details
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trade structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *lbank) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchMyTrades() requires a symbol argument")))
            }
        
            retRes602306 := (<-this.LoadMarkets())
            PanicOnError(retRes602306)
            var market interface{} = this.Market(symbol)
            since = this.SafeValue(params, "start_date", since)
            params = this.Omit(params, "start_date")
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "size", limit)
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_date", this.Ymd(since, "-")) // max query 2 days ago
                AddElementToObject(request, "end_date", this.Ymd(Add(since, 86400000), "-")) // will cover 2 days
            }
        
            response:= (<-this.SpotPrivatePostTransactionHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //      {
            //          "result":true,
            //          "data":[
            //              {
            //                  "orderUuid":"38b4e7a4-14f6-45fd-aba1-1a37024124a0",
            //                  "tradeFeeRate":0.0010000000,
            //                  "dealTime":1648500944496,
            //                  "dealQuantity":30.00000000000000000000,
            //                  "tradeFee":0.00453300000000000000,
            //                  "txUuid":"11f3850cc6214ea3b495adad3a032794",
            //                  "dealPrice":0.15111300000000000000,
            //                  "dealVolumePrice":4.53339000000000000000,
            //                  "tradeType":"sell_market"
            //              }
            //          ],
            //          "error_code":0,
            //          "ts":1648509742164
            //      }
            //
            var trades interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTrades(trades, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name lbank#fetchOrders
 * @description fetches information on multiple orders made by the user
 * @see https://www.lbank.com/en-US/docs/index.html#query-all-orders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *lbank) FetchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    // default query is for canceled and completely filled orders
            // does not return open orders unless specified explicitly
            symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchOrders() requires a symbol argument")))
            }
        
            retRes608236 := (<-this.LoadMarkets())
            PanicOnError(retRes608236)
            var market interface{} = this.Market(symbol)
            if IsTrue(IsEqual(limit, nil)) {
                limit = 100
            }
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "current_page": 1,
                "page_length": limit,
            }
        
            response:= (<-this.SpotPrivatePostSupplementOrdersInfoHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //      {
            //          "result":true,
            //          "data":{
            //              "total":1,
            //              "page_length":100,
            //              "orders":[
            //                  {
            //                      "cummulativeQuoteQty":0,
            //                      "symbol":"doge_usdt",
            //                      "executedQty":0,
            //                      "orderId":"2cadc7cc-b5f6-486b-a5b4-d6ac49a9c186",
            //                      "origQty":100,
            //                      "price":0.05,
            //                      "origQuoteOrderQty":5,
            //                      "updateTime":1648501384000,
            //                      "time":1648501363889,
            //                      "type":"buy",
            //                      "status":-1
            //                  }, ...
            //              ],
            //              "current_page":1
            //          },
            //          "error_code":0,
            //          "ts":1648505706348
            //      }
            //
            var result interface{} = this.SafeValue(response, "data", map[string]interface{} {})
            var orders interface{} = this.SafeList(result, "orders", []interface{}{})
        
            ch <- this.ParseOrders(orders, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name lbank#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://www.lbank.com/en-US/docs/index.html#current-pending-order
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of open order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *lbank) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchOpenOrders() requires a symbol argument")))
            }
        
            retRes126796 := (<-this.LoadMarkets())
            PanicOnError(retRes126796)
            var market interface{} = this.Market(symbol)
            if IsTrue(IsEqual(limit, nil)) {
                limit = 100
            }
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "current_page": 1,
                "page_length": limit,
            }
        
            response:= (<-this.SpotPrivatePostSupplementOrdersInfoNoDeal(this.Extend(request, params)))
            PanicOnError(response)
            //
            //      {
            //          "result":true,
            //          "data":{
            //              "total":1,
            //              "page_length":100,
            //              "orders":[
            //                  {
            //                      "cummulativeQuoteQty":0,
            //                      "symbol":"doge_usdt",
            //                      "executedQty":0,
            //                      "orderId":"73878edf-008d-4e4c-8041-df1f1b2cd8bb",
            //                      "origQty":100,
            //                      "price":0.05,
            //                      "origQuoteOrderQty":5,
            //                      "updateTime":1648501762000,
            //                      "time":1648501762353,
            //                      "type":"buy",
            //                      "status":0
            //                  }, ...
            //             ],
            //             "current_page":1
            //         },
            //         "error_code":0,
            //         "ts":1648506110196
            //     }
            //
            var result interface{} = this.SafeValue(response, "data", map[string]interface{} {})
            var orders interface{} = this.SafeList(result, "orders", []interface{}{})
        
            ch <- this.ParseOrders(orders, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name lbank#cancelOrder
 * @description cancels an open order
 * @see https://www.lbank.com/en-US/docs/index.html#cancel-order-new
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *lbank) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " cancelOrder() requires a symbol argument")))
            }
        
            retRes156057 := (<-this.LoadMarkets())
            PanicOnError(retRes156057)
            var clientOrderId interface{} = this.SafeString2(params, "origClientOrderId", "clientOrderId")
            params = this.Omit(params, []interface{}{"origClientOrderId", "clientOrderId"})
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "orderId": id,
            }
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                AddElementToObject(request, "origClientOrderId", clientOrderId)
            }
        
            response:= (<-this.SpotPrivatePostSupplementCancelOrder(this.Extend(request, params)))
            PanicOnError(response)
            //
            //   {
            //      "result":true,
            //      "data":{
            //          "executedQty":0.0,
            //          "price":0.05,
            //          "origQty":100.0,
            //          "tradeType":"buy",
            //          "status":0
            //      },
            //      "error_code":0,
            //      "ts":1648501286196
            //  }
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseOrder(data)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name lbank#cancelAllOrders
 * @description cancel all open orders in a market
 * @see https://www.lbank.com/en-US/docs/index.html#cancel-all-pending-orders-for-a-single-trading-pair
 * @param {string} symbol unified market symbol of the market to cancel orders in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *lbank) CancelAllOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " cancelAllOrders() requires a symbol argument")))
            }
        
            retRes298021 := (<-this.LoadMarkets())
            PanicOnError(retRes298021)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.SpotPrivatePostSupplementCancelOrderBySymbol(this.Extend(request, params)))
            PanicOnError(response)
            //
            //      {
            //          "result":"true",
            //          "data":[
            //              {
            //                  "executedQty":0.00000000000000000000,
            //                  "orderId":"293ef71b-3e67-4962-af93-aa06990a045f",
            //                  "price":0.05000000000000000000,
            //                  "origQty":100.00000000000000000000,
            //                  "tradeType":"buy",
            //                  "status":0
            //              },
            //          ],
            //          "error_code":0,
            //          "ts":1648506641469
            //      }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseOrders(data)
            return nil
        
            }()
            return ch
        }
func  (this *lbank) GetNetworkCodeForCurrency(currencyCode interface{}, params interface{}) interface{}  {
    var defaultNetworks interface{} = this.SafeValue(this.Options, "defaultNetworks")
    var defaultNetwork interface{} = this.SafeStringUpper(defaultNetworks, currencyCode)
    var networks interface{} = this.SafeValue(this.Options, "networks", map[string]interface{} {})
    var network interface{} = this.SafeStringUpper(params, "network", defaultNetwork) // this line allows the user to specify either ERC20 or ETH
    network = this.SafeString(networks, network, network) // handle ERC20>ETH alias
    return network
}
/**
 * @method
 * @name lbank#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account
 * @see https://www.lbank.com/en-US/docs/index.html#get-deposit-address
 * @see https://www.lbank.com/en-US/docs/index.html#the-user-obtains-the-deposit-address
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *lbank) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes623354 := (<-this.LoadMarkets())
            PanicOnError(retRes623354)
            var options interface{} = this.SafeValue(this.Options, "fetchDepositAddress", map[string]interface{} {})
            var defaultMethod interface{} = this.SafeString(options, "method", "fetchDepositAddressDefault")
            var method interface{} = this.SafeString(params, "method", defaultMethod)
            params = this.Omit(params, "method")
            var response interface{} = nil
            if IsTrue(IsEqual(method, "fetchDepositAddressSupplement")) {
                
        response = (<-this.FetchDepositAddressSupplement(code, params))
                PanicOnError(response)
            } else {
                
        response = (<-this.FetchDepositAddressDefault(code, params))
                PanicOnError(response)
            }
        
            ch <- response
            return nil
        
            }()
            return ch
        }
func  (this *lbank) FetchDepositAddressDefault(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes450483 := (<-this.LoadMarkets())
            PanicOnError(retRes450483)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "assetCode": GetValue(currency, "id"),
            }
            var network interface{} = this.GetNetworkCodeForCurrency(code, params)
            if IsTrue(!IsEqual(network, nil)) {
                AddElementToObject(request, "netWork", network) // ... yes, really lol
                params = this.Omit(params, "network")
            }
        
            response:= (<-this.SpotPrivatePostGetDepositAddress(this.Extend(request, params)))
            PanicOnError(response)
            //
            //      {
            //          "result":true,
            //          "data":{
            //              "assetCode":"usdt",
            //              "address":"0xc85689d37ca650bf2f2161364cdedee21eb6ca53",
            //              "memo":null,
            //              "netWork":"bep20(bsc)"
            //              },
            //          "error_code":0,
            //          "ts":1648075865103
            //      }
            //
            var result interface{} = this.SafeValue(response, "data")
            var address interface{} = this.SafeString(result, "address")
            var tag interface{} = this.SafeString(result, "memo")
            var networkId interface{} = this.SafeString(result, "netWork")
            var inverseNetworks interface{} = this.SafeValue(this.Options, "inverse-networks", map[string]interface{} {})
            var networkCode interface{} = this.SafeStringUpper(inverseNetworks, networkId, networkId)
        
            ch <- map[string]interface{} {
                "info": response,
                "currency": code,
                "network": networkCode,
                "address": address,
                "tag": tag,
            }
            return nil
        
            }()
            return ch
        }
func  (this *lbank) FetchDepositAddressSupplement(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    // returns the address for whatever the default network is...
            params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes833476 := (<-this.LoadMarkets())
            PanicOnError(retRes833476)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "coin": GetValue(currency, "id"),
            }
            var networks interface{} = this.SafeValue(this.Options, "networks")
            var network interface{} = this.SafeStringUpper(params, "network")
            network = this.SafeString(networks, network, network)
            if IsTrue(!IsEqual(network, nil)) {
                AddElementToObject(request, "networkName", network)
                params = this.Omit(params, "network")
            }
        
            response:= (<-this.SpotPrivatePostSupplementGetDepositAddress(this.Extend(request, params)))
            PanicOnError(response)
            //
            //      {
            //          "result":true,
            //          "data":{
            //              "address":"TDxtabCC8iQwaxUUrPcE4WL2jArGAfvQ5A",
            //              "memo":null,
            //              "coin":"usdt"
            //              },
            //          "error_code":0,
            //          "ts":1648073818880
            //     }
            //
            var result interface{} = this.SafeValue(response, "data")
            var address interface{} = this.SafeString(result, "address")
            var tag interface{} = this.SafeString(result, "memo")
            var inverseNetworks interface{} = this.SafeValue(this.Options, "inverse-networks", map[string]interface{} {})
            var networkCode interface{} = this.SafeStringUpper(inverseNetworks, network, network)
        
            ch <- map[string]interface{} {
                "info": response,
                "currency": code,
                "network": networkCode,
                "address": address,
                "tag": tag,
            }
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name lbank#withdraw
 * @description make a withdrawal
 * @see https://www.lbank.com/en-US/docs/index.html#withdrawal
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *lbank) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params);
            tag = GetValue(tagparamsVariable,0);
            params = GetValue(tagparamsVariable,1)
            this.CheckAddress(address)
        
            retRes27543 := (<-this.LoadMarkets())
            PanicOnError(retRes27543)
            var fee interface{} = this.SafeString(params, "fee")
            params = this.Omit(params, "fee")
            // The relevant coin network fee can be found by calling fetchDepositWithdrawFees (), note: if no network param is supplied then the default network will be used, this can also be found in fetchDepositWithdrawFees ().
            this.CheckRequiredArgument("withdraw", fee, "fee")
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "address": address,
                "coin": GetValue(currency, "id"),
                "amount": amount,
                "fee": fee,
            }
            if IsTrue(!IsEqual(tag, nil)) {
                AddElementToObject(request, "memo", tag)
            }
            var network interface{} = this.SafeStringUpper2(params, "network", "networkName")
            params = this.Omit(params, []interface{}{"network", "networkName"})
            var networks interface{} = this.SafeValue(this.Options, "networks")
            var networkId interface{} = this.SafeString(networks, network, network)
            if IsTrue(!IsEqual(networkId, nil)) {
                AddElementToObject(request, "networkName", networkId)
            }
        
            response:= (<-this.SpotPrivatePostSupplementWithdraw(this.Extend(request, params)))
            PanicOnError(response)
            //
            //      {
            //          "result":true,
            //          "data": {
            //              "fee":10.00000000000000000000,
            //              "withdrawId":1900376
            //              },
            //          "error_code":0,
            //          "ts":1648992501414
            //      }
            //
            var result interface{} = this.SafeValue(response, "data", map[string]interface{} {})
        
            ch <- map[string]interface{} {
                "info": result,
                "id": this.SafeString(result, "withdrawId"),
            }
            return nil
        
            }()
            return ch
        }
func  (this *lbank) ParseTransactionStatus(status interface{}, typeVar interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "deposit": map[string]interface{} {
            "1": "pending",
            "2": "ok",
            "3": "failed",
            "4": "canceled",
            "5": "transfer",
        },
        "withdrawal": map[string]interface{} {
            "1": "pending",
            "2": "canceled",
            "3": "failed",
            "4": "ok",
        },
    }
    return this.SafeString(this.SafeValue(statuses, typeVar, map[string]interface{} {}), status, status)
}
func  (this *lbank) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchDeposits (private)
    //
    //      {
    //          "insertTime":1649012310000,
    //          "amount":9.00000000000000000000,
    //          "address":"TYASr5UV6HEcXatwdFQfmLVUqQQQMUxHLS",
    //          "networkName":"trc20",
    //          "txId":"081e4e9351dd0274922168da5f2d14ea6c495b1c3b440244f4a6dd9fe196bf2b",
    //          "coin":"usdt",
    //          "status":"2"
    //      }
    //
    //
    // fetchWithdrawals (private)
    //
    //      {
    //          "amount":2.00000000000000000000,
    //          "address":"TBjrW5JHDyPZjFc5nrRMhRWUDaJmhGhmD6",
    //          "fee":1.00000000000000000000,
    //          "networkName":"trc20",
    //          "coid":"usdt",
    //          "transferType":"",
    //          "txId":"47eeee2763ad49b8817524dacfa7d092fb58f8b0ab7e5d25473314df1a793c3d",
    //          "id":1902194,
    //          "applyTime":1649014002000,
    //          "status":"4"
    //      }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var id interface{} = this.SafeString(transaction, "id")
    var typeVar interface{} = nil
    if IsTrue(IsEqual(id, nil)) {
        typeVar = "deposit"
    } else {
        typeVar = "withdrawal"
    }
    var txid interface{} = this.SafeString(transaction, "txId")
    var timestamp interface{} = this.SafeInteger2(transaction, "insertTime", "applyTime")
    var networks interface{} = this.SafeValue(this.Options, "inverse-networks", map[string]interface{} {})
    var networkId interface{} = this.SafeString(transaction, "networkName")
    var network interface{} = this.SafeString(networks, networkId, networkId)
    var address interface{} = this.SafeString(transaction, "address")
    var addressFrom interface{} = nil
    var addressTo interface{} = nil
    if IsTrue(IsEqual(typeVar, "deposit")) {
        addressFrom = address
    } else {
        addressTo = address
    }
    var amount interface{} = this.SafeNumber(transaction, "amount")
    var currencyId interface{} = this.SafeString2(transaction, "coin", "coid")
    var code interface{} = this.SafeCurrencyCode(currencyId, currency)
    var status interface{} = this.ParseTransactionStatus(this.SafeString(transaction, "status"), typeVar)
    var fee interface{} = nil
    var feeCost interface{} = this.SafeNumber(transaction, "fee")
    if IsTrue(!IsEqual(feeCost, nil)) {
        fee = map[string]interface{} {
            "cost": feeCost,
            "currency": code,
        }
    }
    return map[string]interface{} {
        "info": transaction,
        "id": id,
        "txid": txid,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "network": network,
        "address": address,
        "addressTo": addressTo,
        "addressFrom": addressFrom,
        "tag": nil,
        "tagTo": nil,
        "tagFrom": nil,
        "type": typeVar,
        "amount": amount,
        "currency": code,
        "status": status,
        "updated": nil,
        "comment": nil,
        "internal": (IsEqual(status, "transfer")),
        "fee": fee,
    }
}
/**
 * @method
 * @name lbank#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://www.lbank.com/en-US/docs/index.html#get-recharge-history
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *lbank) FetchDeposits(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes357253 := (<-this.LoadMarkets())
            PanicOnError(retRes357253)
            var request interface{} = map[string]interface{} {}
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "coin", GetValue(currency, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
        
            response:= (<-this.SpotPrivatePostSupplementDepositHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //      {
            //          "result":true,
            //          "data": {
            //              "total":1,
            //              "depositOrders": [
            //                  {
            //                      "insertTime":1649012310000,
            //                      "amount":9.00000000000000000000,
            //                      "address":"TYASr5UV6HEcXatwdFQfmLVUqQQQMUxHLS",
            //                      "networkName":"trc20",
            //                      "txId":"081e4e9351dd0274922168da5f2d14ea6c495b1c3b440244f4a6dd9fe196bf2b",
            //                      "coin":"usdt",
            //                      "status":"2"
            //                  },
            //              ],
            //              "page_length":20,
            //              "current_page":1
            //          },
            //          "error_code":0,
            //          "ts":1649719721758
            //      }
            //
            var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
            var deposits interface{} = this.SafeList(data, "depositOrders", []interface{}{})
        
            ch <- this.ParseTransactions(deposits, currency, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name lbank#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @see https://www.lbank.com/en-US/docs/index.html#get-withdrawal-history
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawals structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *lbank) FetchWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes478987 := (<-this.LoadMarkets())
            PanicOnError(retRes478987)
            var request interface{} = map[string]interface{} {}
            var currency interface{} = nil
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "coin", GetValue(currency, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startTime", since)
            }
        
            response:= (<-this.SpotPrivatePostSupplementWithdraws(this.Extend(request, params)))
            PanicOnError(response)
            //
            //      {
            //          "result":true,
            //          "data": {
            //              "total":1,
            //              "withdraws": [
            //                  {
            //                      "amount":2.00000000000000000000,
            //                      "address":"TBjrW5JHDyPZjFc5nrRMhRWUDaJmhGhmD6",
            //                      "fee":1.00000000000000000000,
            //                      "networkName":"trc20",
            //                      "coid":"usdt",
            //                      "transferType":"",
            //                      "txId":"47eeee2763ad49b8817524dacfa7d092fb58f8b0ab7e5d25473314df1a793c3d",
            //                      "id":1902194,
            //                      "applyTime":1649014002000,
            //                      "status":"4"
            //                  },
            //              ],
            //              "page_length":20,
            //              "current_page":1
            //          },
            //          "error_code":0,
            //          "ts":1649720362362
            //      }
            //
            var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
            var withdraws interface{} = this.SafeList(data, "withdraws", []interface{}{})
        
            ch <- this.ParseTransactions(withdraws, currency, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name lbank#fetchTransactionFees
 * @deprecated
 * @description please use fetchDepositWithdrawFees instead
 * @param {string[]|undefined} codes not used by lbank fetchTransactionFees ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func  (this *lbank) FetchTransactionFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    // private only returns information for currencies with non-zero balance
            codes := GetArg(optionalArgs, 0, nil)
            _ = codes
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes271440 := (<-this.LoadMarkets())
            PanicOnError(retRes271440)
            var isAuthorized interface{} = this.CheckRequiredCredentials(false)
            var result interface{} = nil
            if IsTrue(IsEqual(isAuthorized, true)) {
                var options interface{} = this.SafeValue(this.Options, "fetchTransactionFees", map[string]interface{} {})
                var defaultMethod interface{} = this.SafeString(options, "method", "fetchPrivateTransactionFees")
                var method interface{} = this.SafeString(params, "method", defaultMethod)
                params = this.Omit(params, "method")
                if IsTrue(IsEqual(method, "fetchPublicTransactionFees")) {
                    
        result = (<-this.FetchPublicTransactionFees(params))
                    PanicOnError(result)
                } else {
                    
        result = (<-this.FetchPrivateTransactionFees(params))
                    PanicOnError(result)
                }
            } else {
                
        result = (<-this.FetchPublicTransactionFees(params))
                PanicOnError(result)
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *lbank) FetchPrivateTransactionFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    // complete response
            // incl. for coins which undefined in public method
            params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes557089 := (<-this.LoadMarkets())
            PanicOnError(retRes557089)
        
            response:= (<-this.SpotPrivatePostSupplementUserInfo())
            PanicOnError(response)
            //
            //    {
            //        "result": "true",
            //        "data": [
            //            {
            //                "usableAmt": "14.36",
            //                "assetAmt": "14.36",
            //                "networkList": [
            //                    {
            //                        "isDefault": false,
            //                        "withdrawFeeRate": "",
            //                        "name": "erc20",
            //                        "withdrawMin": 30,
            //                        "minLimit": 0.0001,
            //                        "minDeposit": 20,
            //                        "feeAssetCode": "usdt",
            //                        "withdrawFee": "30",
            //                        "type": 1,
            //                        "coin": "usdt",
            //                        "network": "eth"
            //                    },
            //                    ...
            //                ],
            //                "freezeAmt": "0",
            //                "coin": "ada"
            //            }
            //        ],
            //        "code": 0
            //    }
            //
            var result interface{} = this.SafeValue(response, "data", []interface{}{})
            var withdrawFees interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(result)); i++ {
                var entry interface{} = GetValue(result, i)
                var currencyId interface{} = this.SafeString(entry, "coin")
                var code interface{} = this.SafeCurrencyCode(currencyId)
                var networkList interface{} = this.SafeValue(entry, "networkList", []interface{}{})
                AddElementToObject(withdrawFees, code, map[string]interface{} {})
                for j := 0; IsLessThan(j, GetArrayLength(networkList)); j++ {
                    var networkEntry interface{} = GetValue(networkList, j)
                    var networkId interface{} = this.SafeString(networkEntry, "name")
                    var networkCode interface{} = this.SafeString(GetValue(this.Options, "inverse-networks"), networkId, networkId)
                    var fee interface{} = this.SafeNumber(networkEntry, "withdrawFee")
                    if IsTrue(!IsEqual(fee, nil)) {
                        AddElementToObject(GetValue(withdrawFees, code), networkCode, fee)
                    }
                }
            }
        
            ch <- map[string]interface{} {
                "withdraw": withdrawFees,
                "deposit": map[string]interface{} {},
                "info": response,
            }
            return nil
        
            }()
            return ch
        }
func  (this *lbank) FetchPublicTransactionFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    // extremely incomplete response
            // vast majority fees undefined
            params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes441006 := (<-this.LoadMarkets())
            PanicOnError(retRes441006)
            var code interface{} = this.SafeString2(params, "coin", "assetCode")
            params = this.Omit(params, []interface{}{"coin", "assetCode"})
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(code, nil)) {
                var currency interface{} = this.Currency(code)
                AddElementToObject(request, "assetCode", GetValue(currency, "id"))
            }
        
            response:= (<-this.SpotPublicGetWithdrawConfigs(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "result": "true",
            //        "data": [
            //          {
            //            "amountScale": "4",
            //            "chain": "heco",
            //            "assetCode": "lbk",
            //            "min": "200",
            //            "transferAmtScale": "4",
            //            "canWithDraw": true,
            //            "fee": "100",
            //            "minTransfer": "0.0001",
            //            "type": "1"
            //          },
            //          ...
            //        ],
            //        "error_code": "0",
            //        "ts": "1663364435973"
            //    }
            //
            var result interface{} = this.SafeValue(response, "data", []interface{}{})
            var withdrawFees interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(result)); i++ {
                var item interface{} = GetValue(result, i)
                var canWithdraw interface{} = this.SafeValue(item, "canWithDraw")
                if IsTrue(IsEqual(canWithdraw, "true")) {
                    var currencyId interface{} = this.SafeString(item, "assetCode")
                    var codeInner interface{} = this.SafeCurrencyCode(currencyId)
                    var chain interface{} = this.SafeString(item, "chain")
                    var network interface{} = this.SafeString(GetValue(this.Options, "inverse-networks"), chain, chain)
                    if IsTrue(IsEqual(network, nil)) {
                        network = codeInner
                    }
                    var fee interface{} = this.SafeString(item, "fee")
                    if IsTrue(IsEqual(GetValue(withdrawFees, codeInner), nil)) {
                        AddElementToObject(withdrawFees, codeInner, map[string]interface{} {})
                    }
                    AddElementToObject(GetValue(withdrawFees, codeInner), network, this.ParseNumber(fee))
                }
            }
        
            ch <- map[string]interface{} {
                "withdraw": withdrawFees,
                "deposit": map[string]interface{} {},
                "info": response,
            }
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name lbank#fetchDepositWithdrawFees
 * @description when using private endpoint, only returns information for currencies with non-zero balance, use public method by specifying this.options['fetchDepositWithdrawFees']['method'] = 'fetchPublicDepositWithdrawFees'
 * @see https://www.lbank.com/en-US/docs/index.html#get-all-coins-information
 * @see https://www.lbank.com/en-US/docs/index.html#withdrawal-configurations
 * @param {string[]} [codes] array of unified currency codes
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func  (this *lbank) FetchDepositWithdrawFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    codes := GetArg(optionalArgs, 0, nil)
            _ = codes
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes639705 := (<-this.LoadMarkets())
            PanicOnError(retRes639705)
            var isAuthorized interface{} = this.CheckRequiredCredentials(false)
            var response interface{} = nil
            if IsTrue(IsEqual(isAuthorized, true)) {
                var options interface{} = this.SafeValue(this.Options, "fetchDepositWithdrawFees", map[string]interface{} {})
                var defaultMethod interface{} = this.SafeString(options, "method", "fetchPrivateDepositWithdrawFees")
                var method interface{} = this.SafeString(params, "method", defaultMethod)
                params = this.Omit(params, "method")
                if IsTrue(IsEqual(method, "fetchPublicDepositWithdrawFees")) {
                    
        response = (<-this.FetchPublicDepositWithdrawFees(codes, params))
                    PanicOnError(response)
                } else {
                    
        response = (<-this.FetchPrivateDepositWithdrawFees(codes, params))
                    PanicOnError(response)
                }
            } else {
                
        response = (<-this.FetchPublicDepositWithdrawFees(codes, params))
                PanicOnError(response)
            }
        
            ch <- response
            return nil
        
            }()
            return ch
        }
func  (this *lbank) FetchPrivateDepositWithdrawFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    // complete response
            // incl. for coins which undefined in public method
            codes := GetArg(optionalArgs, 0, nil)
            _ = codes
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes950992 := (<-this.LoadMarkets())
            PanicOnError(retRes950992)
        
            response:= (<-this.SpotPrivatePostSupplementUserInfo(params))
            PanicOnError(response)
            //
            //    {
            //        "result": "true",
            //        "data": [
            //            {
            //                "usableAmt": "14.36",
            //                "assetAmt": "14.36",
            //                "networkList": [
            //                    {
            //                        "isDefault": false,
            //                        "withdrawFeeRate": "",
            //                        "name": "erc20",
            //                        "withdrawMin": 30,
            //                        "minLimit": 0.0001,
            //                        "minDeposit": 20,
            //                        "feeAssetCode": "usdt",
            //                        "withdrawFee": "30",
            //                        "type": 1,
            //                        "coin": "usdt",
            //                        "network": "eth"
            //                    },
            //                    ...
            //                ],
            //                "freezeAmt": "0",
            //                "coin": "ada"
            //            }
            //        ],
            //        "code": 0
            //    }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseDepositWithdrawFees(data, codes, "coin")
            return nil
        
            }()
            return ch
        }
func  (this *lbank) FetchPublicDepositWithdrawFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    // extremely incomplete response
            // vast majority fees undefined
            codes := GetArg(optionalArgs, 0, nil)
            _ = codes
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes240967 := (<-this.LoadMarkets())
            PanicOnError(retRes240967)
            var request interface{} = map[string]interface{} {}
        
            response:= (<-this.SpotPublicGetWithdrawConfigs(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "result": "true",
            //        "data": [
            //            {
            //                "amountScale": "4",
            //                "chain": "heco",
            //                "assetCode": "lbk",
            //                "min": "200",
            //                "transferAmtScale": "4",
            //                "canWithDraw": true,
            //                "fee": "100",
            //                "minTransfer": "0.0001",
            //                "type": "1"
            //            },
            //            ...
            //        ],
            //        "error_code": "0",
            //        "ts": "1663364435973"
            //    }
            //
            var data interface{} = this.SafeValue(response, "data", []interface{}{})
        
            ch <- this.ParsePublicDepositWithdrawFees(data, codes)
            return nil
        
            }()
            return ch
        }
func  (this *lbank) ParsePublicDepositWithdrawFees(response interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    [
    //        {
    //            "amountScale": "4",
    //            "chain": "heco",
    //            "assetCode": "lbk",
    //            "min": "200",
    //            "transferAmtScale": "4",
    //            "canWithDraw": true,
    //            "fee": "100",
    //            "minTransfer": "0.0001",
    //            "type": "1"
    //        },
    //        ...
    //    ]
    //
    codes := GetArg(optionalArgs, 0, nil)
    _ = codes
    var result interface{} = map[string]interface{} {}
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        var fee interface{} = GetValue(response, i)
        var canWithdraw interface{} = this.SafeValue(fee, "canWithDraw")
        if IsTrue(IsEqual(canWithdraw, true)) {
            var currencyId interface{} = this.SafeString(fee, "assetCode")
            var code interface{} = this.SafeCurrencyCode(currencyId)
            if IsTrue(IsTrue(IsEqual(codes, nil)) || IsTrue(this.InArray(code, codes))) {
                var withdrawFee interface{} = this.SafeNumber(fee, "fee")
                if IsTrue(!IsEqual(withdrawFee, nil)) {
                    var resultValue interface{} = this.SafeValue(result, code)
                    if IsTrue(IsEqual(resultValue, nil)) {
                        AddElementToObject(result, code, this.DepositWithdrawFee([]interface{}{fee}))
                    } else {
                        var resultCodeInfo interface{} = GetValue(GetValue(result, code), "info")
                        AppendToArray(&resultCodeInfo,fee)
                    }
                    var chain interface{} = this.SafeString(fee, "chain")
                    var networkCode interface{} = this.SafeString(GetValue(this.Options, "inverse-networks"), chain, chain)
                    if IsTrue(!IsEqual(networkCode, nil)) {
                        AddElementToObject(GetValue(GetValue(result, code), "networks"), networkCode, map[string]interface{} {
    "withdraw": map[string]interface{} {
        "fee": withdrawFee,
        "percentage": nil,
    },
    "deposit": map[string]interface{} {
        "fee": nil,
        "percentage": nil,
    },
})
                    } else {
                        AddElementToObject(GetValue(result, code), "withdraw", map[string]interface{} {
    "fee": withdrawFee,
    "percentage": nil,
})
                    }
                }
            }
        }
    }
    return result
}
func  (this *lbank) ParseDepositWithdrawFee(fee interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // * only used for fetchPrivateDepositWithdrawFees
    //
    //    {
    //        "usableAmt": "14.36",
    //        "assetAmt": "14.36",
    //        "networkList": [
    //            {
    //                "isDefault": false,
    //                "withdrawFeeRate": "",
    //                "name": "erc20",
    //                "withdrawMin": 30,
    //                "minLimit": 0.0001,
    //                "minDeposit": 20,
    //                "feeAssetCode": "usdt",
    //                "withdrawFee": "30",
    //                "type": 1,
    //                "coin": "usdt",
    //                "network": "eth"
    //            },
    //            ...
    //        ],
    //        "freezeAmt": "0",
    //        "coin": "ada"
    //    }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var result interface{} = this.DepositWithdrawFee(fee)
    var networkList interface{} = this.SafeValue(fee, "networkList", []interface{}{})
    for j := 0; IsLessThan(j, GetArrayLength(networkList)); j++ {
        var networkEntry interface{} = GetValue(networkList, j)
        var networkId interface{} = this.SafeString(networkEntry, "name")
        var networkCode interface{} = this.SafeStringUpper(GetValue(this.Options, "inverse-networks"), networkId, networkId)
        var withdrawFee interface{} = this.SafeNumber(networkEntry, "withdrawFee")
        var isDefault interface{} = this.SafeValue(networkEntry, "isDefault")
        if IsTrue(!IsEqual(withdrawFee, nil)) {
            if IsTrue(isDefault) {
                AddElementToObject(result, "withdraw", map[string]interface{} {
    "fee": withdrawFee,
    "percentage": nil,
})
            }
            AddElementToObject(GetValue(result, "networks"), networkCode, map[string]interface{} {
    "withdraw": map[string]interface{} {
        "fee": withdrawFee,
        "percentage": nil,
    },
    "deposit": map[string]interface{} {
        "fee": nil,
        "percentage": nil,
    },
})
        }
    }
    return result
}
func  (this *lbank) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var query interface{} = this.Omit(params, this.ExtractParams(path))
    var url interface{} = Add(Add(Add(Add(GetValue(GetValue(this.Urls, "api"), "rest"), "/"), this.Version), "/"), this.ImplodeParams(path, params))
    // Every spot endpoint ends with ".do"
    if IsTrue(IsEqual(GetValue(api, 0), "spot")) {
        url = Add(url, ".do")
    } else {
        url = Add(Add(GetValue(GetValue(this.Urls, "api"), "contract"), "/"), this.ImplodeParams(path, params))
    }
    if IsTrue(IsEqual(GetValue(api, 1), "public")) {
        if IsTrue(GetArrayLength(ObjectKeys(query))) {
            url = Add(url, Add("?", this.Urlencode(this.Keysort(query))))
        }
    } else {
        this.CheckRequiredCredentials()
        var timestamp interface{} = ToString(this.Milliseconds())
        var echostr interface{} = Add(this.Uuid22(), this.Uuid16())
        query = this.Extend(map[string]interface{} {
            "api_key": this.ApiKey,
        }, query)
        var signatureMethod interface{} = nil
        if IsTrue(IsGreaterThan(GetLength(this.Secret), 32)) {
            signatureMethod = "RSA"
        } else {
            signatureMethod = "HmacSHA256"
        }
        var auth interface{} = this.Rawencode(this.Keysort(this.Extend(map[string]interface{} {
            "echostr": echostr,
            "signature_method": signatureMethod,
            "timestamp": timestamp,
        }, query)))
        var encoded interface{} = this.Encode(auth)
        var hash interface{} = this.Hash(encoded, md5)
        var uppercaseHash interface{} = ToUpper(hash)
        var sign interface{} = nil
        if IsTrue(IsEqual(signatureMethod, "RSA")) {
            var cacheSecretAsPem interface{} = this.SafeBool(this.Options, "cacheSecretAsPem", true)
            var pem interface{} = nil
            if IsTrue(cacheSecretAsPem) {
                pem = this.SafeValue(this.Options, "pem")
                if IsTrue(IsEqual(pem, nil)) {
                    pem = this.ConvertSecretToPem(this.Encode(this.Secret))
                    AddElementToObject(this.Options, "pem", pem)
                }
            } else {
                pem = this.ConvertSecretToPem(this.Encode(this.Secret))
            }
            sign = Rsa(uppercaseHash, pem, sha256)
        } else if IsTrue(IsEqual(signatureMethod, "HmacSHA256")) {
            sign = this.Hmac(this.Encode(uppercaseHash), this.Encode(this.Secret), sha256)
        }
        AddElementToObject(query, "sign", sign)
        body = this.Urlencode(this.Keysort(query))
        headers = map[string]interface{} {
            "Content-Type": "application/x-www-form-urlencoded",
            "timestamp": timestamp,
            "signature_method": signatureMethod,
            "echostr": echostr,
        }
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *lbank) ConvertSecretToPem(secret interface{}) interface{}  {
    var lineLength interface{} = 64
    var secretLength interface{} = Subtract(GetArrayLength(secret), 0)
    var numLines interface{} = this.ParseToInt(Divide(secretLength, lineLength))
    numLines = this.Sum(numLines, 1)
    var pem interface{} = "-----BEGIN PRIVATE KEY-----\n" // eslint-disable-line
    for i := 0; IsLessThan(i, numLines); i++ {
        var start interface{} = Multiply(i, lineLength)
        var end interface{} = this.Sum(start, lineLength)
        pem = Add(pem, Add(Slice(this.Secret, start, end), "\n")) // eslint-disable-line
    }
    return Add(pem, "-----END PRIVATE KEY-----")
}
func  (this *lbank) HandleErrors(httpCode interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsEqual(response, nil)) {
        return nil
    }
    var success interface{} = this.SafeValue(response, "result")
    if IsTrue(IsTrue(IsEqual(success, "false")) || !IsTrue(success)) {
        var errorCode interface{} = this.SafeString(response, "error_code")
        var message interface{} = this.SafeString(map[string]interface{} {
            "10000": "Internal error",
            "10001": "The required parameters can not be empty",
            "10002": "Validation failed",
            "10003": "Invalid parameter",
            "10004": "Request too frequent",
            "10005": "Secret key does not exist",
            "10006": "User does not exist",
            "10007": "Invalid signature",
            "10008": "Invalid Trading Pair",
            "10009": "Price and/or Amount are required for limit order",
            "10010": "Price and/or Amount must be less than minimum requirement",
            "10013": "The amount is too small",
            "10014": "Insufficient amount of money in the account",
            "10015": "Invalid order type",
            "10016": "Insufficient account balance",
            "10017": "Server Error",
            "10018": "Page size should be between 1 and 50",
            "10019": "Cancel NO more than 3 orders in one request",
            "10020": "Volume < 0.001",
            "10021": "Price < 0.01",
            "10022": "Invalid authorization",
            "10023": "Market Order is not supported yet",
            "10024": "User cannot trade on this pair",
            "10025": "Order has been filled",
            "10026": "Order has been cancelld",
            "10027": "Order is cancelling",
            "10028": "Wrong query time",
            "10029": "from is not in the query time",
            "10030": "from do not match the transaction type of inqury",
            "10031": "echostr length must be valid and length must be from 30 to 40",
            "10033": "Failed to create order",
            "10036": "customID duplicated",
            "10100": "Has no privilege to withdraw",
            "10101": "Invalid fee rate to withdraw",
            "10102": "Too little to withdraw",
            "10103": "Exceed daily limitation of withdraw",
            "10104": "Cancel was rejected",
            "10105": "Request has been cancelled",
            "10106": "None trade time",
            "10107": "Start price exception",
            "10108": "can not create order",
            "10109": "wallet address is not mapping",
            "10110": "transfer fee is not mapping",
            "10111": "mount > 0",
            "10112": "fee is too lower",
            "10113": "transfer fee is 0",
            "10600": "intercepted by replay attacks filter, check timestamp",
            "10601": "Interface closed unavailable",
            "10701": "invalid asset code",
            "10702": "not allowed deposit",
        }, errorCode, this.Json(response))
        var ErrorClass interface{} = this.SafeValue(map[string]interface{} {
            "10001": BadRequest,
            "10002": AuthenticationError,
            "10003": BadRequest,
            "10004": RateLimitExceeded,
            "10005": AuthenticationError,
            "10006": AuthenticationError,
            "10007": AuthenticationError,
            "10008": BadSymbol,
            "10009": InvalidOrder,
            "10010": InvalidOrder,
            "10013": InvalidOrder,
            "10014": InsufficientFunds,
            "10015": InvalidOrder,
            "10016": InsufficientFunds,
            "10017": ExchangeError,
            "10018": BadRequest,
            "10019": BadRequest,
            "10020": BadRequest,
            "10021": InvalidOrder,
            "10022": PermissionDenied,
            "10023": InvalidOrder,
            "10024": PermissionDenied,
            "10025": InvalidOrder,
            "10026": InvalidOrder,
            "10027": InvalidOrder,
            "10028": BadRequest,
            "10029": BadRequest,
            "10030": BadRequest,
            "10031": InvalidNonce,
            "10033": ExchangeError,
            "10036": DuplicateOrderId,
            "10100": PermissionDenied,
            "10101": BadRequest,
            "10102": InsufficientFunds,
            "10103": ExchangeError,
            "10104": ExchangeError,
            "10105": ExchangeError,
            "10106": BadRequest,
            "10107": BadRequest,
            "10108": ExchangeError,
            "10109": InvalidAddress,
            "10110": ExchangeError,
            "10111": BadRequest,
            "10112": BadRequest,
            "10113": BadRequest,
            "10600": BadRequest,
            "10601": ExchangeError,
            "10701": BadSymbol,
            "10702": PermissionDenied,
        }, errorCode, ExchangeError)
        throwDynamicException(ErrorClass, message);return nil;
    }
    return nil
}


func (this *lbank) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
