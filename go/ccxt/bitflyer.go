package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type bitflyer struct {
    Exchange

}

func NewBitflyerCore() bitflyer {
   p := bitflyer{}
   setDefaults(&p)
   return p
}

func  (this *bitflyer) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "bitflyer",
        "name": "bitFlyer",
        "countries": []interface{}{"JP"},
        "version": "v1",
        "rateLimit": 1000,
        "hostname": "bitflyer.com",
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": false,
            "swap": nil,
            "future": nil,
            "option": false,
            "cancelAllOrders": nil,
            "cancelOrder": true,
            "createOrder": true,
            "fetchBalance": true,
            "fetchClosedOrders": "emulated",
            "fetchDeposits": true,
            "fetchFundingRate": true,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchMarginMode": false,
            "fetchMarkets": true,
            "fetchMyTrades": true,
            "fetchOpenOrders": "emulated",
            "fetchOrder": "emulated",
            "fetchOrderBook": true,
            "fetchOrders": true,
            "fetchPositionMode": false,
            "fetchPositions": true,
            "fetchTicker": true,
            "fetchTrades": true,
            "fetchTradingFee": true,
            "fetchTradingFees": false,
            "fetchTransfer": false,
            "fetchTransfers": false,
            "fetchWithdrawals": true,
            "transfer": false,
            "withdraw": true,
        },
        "urls": map[string]interface{} {
            "logo": "https://github.com/user-attachments/assets/d0217747-e54d-4533-8416-0d553dca74bb",
            "api": map[string]interface{} {
                "rest": "https://api.{hostname}",
            },
            "www": "https://bitflyer.com",
            "doc": "https://lightning.bitflyer.com/docs?lang=en",
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": []interface{}{"getmarkets/usa", "getmarkets/eu", "getmarkets", "getboard", "getticker", "getexecutions", "gethealth", "getboardstate", "getchats", "getfundingrate"},
            },
            "private": map[string]interface{} {
                "get": []interface{}{"getpermissions", "getbalance", "getbalancehistory", "getcollateral", "getcollateralhistory", "getcollateralaccounts", "getaddresses", "getcoinins", "getcoinouts", "getbankaccounts", "getdeposits", "getwithdrawals", "getchildorders", "getparentorders", "getparentorder", "getexecutions", "getpositions", "gettradingcommission"},
                "post": []interface{}{"sendcoin", "withdraw", "sendchildorder", "cancelchildorder", "sendparentorder", "cancelparentorder", "cancelallchildorders"},
            },
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "maker": this.ParseNumber("0.002"),
                "taker": this.ParseNumber("0.002"),
            },
        },
        "precisionMode": TICK_SIZE,
        "features": map[string]interface{} {
            "spot": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": false,
                    "triggerPriceType": nil,
                    "triggerDirection": false,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": true,
                        "FOK": true,
                        "PO": true,
                        "GTD": true,
                    },
                    "hedged": false,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyRequiresPrice": false,
                    "marketBuyByCost": false,
                    "selfTradePrevention": false,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": nil,
                    "untilDays": nil,
                    "symbolRequired": true,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": nil,
                    "untilDays": nil,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchClosedOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": nil,
                    "daysBackCanceled": nil,
                    "untilDays": nil,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchOHLCV": nil,
            },
            "swap": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "-2": OnMaintenance,
            },
        },
    })
}
func  (this *bitflyer) ParseExpiryDate(expiry interface{}) interface{}  {
    var day interface{} = Slice(expiry, 0, 2)
    var monthName interface{} = Slice(expiry, 2, 5)
    var year interface{} = Slice(expiry, 5, 9)
    var months interface{} = map[string]interface{} {
        "JAN": "01",
        "FEB": "02",
        "MAR": "03",
        "APR": "04",
        "MAY": "05",
        "JUN": "06",
        "JUL": "07",
        "AUG": "08",
        "SEP": "09",
        "OCT": "10",
        "NOV": "11",
        "DEC": "12",
    }
    var month interface{} = this.SafeString(months, monthName)
    return this.Parse8601(Add(Add(Add(Add(Add(year, "-"), month), "-"), day), "T00:00:00Z"))
}
func  (this *bitflyer) SafeMarket(optionalArgs ...interface{}) interface{}  {
    // Bitflyer has a different type of conflict in markets, because
    // some of their ids (ETH/BTC and BTC/JPY) are duplicated in US, EU and JP.
    // Since they're the same we just need to return one
    marketId := GetArg(optionalArgs, 0, nil)
    _ = marketId
    market := GetArg(optionalArgs, 1, nil)
    _ = market
    delimiter := GetArg(optionalArgs, 2, nil)
    _ = delimiter
    marketType := GetArg(optionalArgs, 3, nil)
    _ = marketType
    return this.Exchange.SafeMarket(marketId, market, delimiter, "spot")
}
/**
 * @method
 * @name bitflyer#fetchMarkets
 * @description retrieves data on all markets for bitflyer
 * @see https://lightning.bitflyer.com/docs?lang=en#market-list
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *bitflyer) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            jp_markets:= (<-this.PublicGetGetmarkets(params))
            PanicOnError(jp_markets)
            //
            //     [
            //         // spot
            //         { "product_code": "BTC_JPY", "market_type": "Spot" },
            //         { "product_code": "BCH_BTC", "market_type": "Spot" },
            //         // forex swap
            //         { "product_code": "FX_BTC_JPY", "market_type": "FX" },
            //         // future
            //         {
            //             "product_code": "BTCJPY11FEB2022",
            //             "alias": "BTCJPY_MAT1WK",
            //             "market_type": "Futures",
            //         },
            //     ];
            //
        
            us_markets:= (<-this.PublicGetGetmarketsUsa(params))
            PanicOnError(us_markets)
            //
            //     [
            //         { "product_code": "BTC_USD", "market_type": "Spot" },
            //         { "product_code": "BTC_JPY", "market_type": "Spot" },
            //     ];
            //
        
            eu_markets:= (<-this.PublicGetGetmarketsEu(params))
            PanicOnError(eu_markets)
            //
            //     [
            //         { "product_code": "BTC_EUR", "market_type": "Spot" },
            //         { "product_code": "BTC_JPY", "market_type": "Spot" },
            //     ];
            //
            var markets interface{} = this.ArrayConcat(jp_markets, us_markets)
            markets = this.ArrayConcat(markets, eu_markets)
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(markets)); i++ {
                var market interface{} = GetValue(markets, i)
                var id interface{} = this.SafeString(market, "product_code")
                var currencies interface{} = Split(id, "_")
                var marketType interface{} = this.SafeString(market, "market_type")
                var swap interface{} =         (IsEqual(marketType, "FX"))
                var future interface{} =         (IsEqual(marketType, "Futures"))
                var spot interface{} = !IsTrue(swap) && !IsTrue(future)
                var typeVar interface{} = "spot"
                var settle interface{} = nil
                var baseId interface{} = nil
                var quoteId interface{} = nil
                var expiry interface{} = nil
                if IsTrue(spot) {
                    baseId = this.SafeString(currencies, 0)
                    quoteId = this.SafeString(currencies, 1)
                } else if IsTrue(swap) {
                    typeVar = "swap"
                    baseId = this.SafeString(currencies, 1)
                    quoteId = this.SafeString(currencies, 2)
                } else if IsTrue(future) {
                    var alias interface{} = this.SafeString(market, "alias")
                    if IsTrue(IsEqual(alias, nil)) {
                        // no alias:
                        // { product_code: 'BTCJPY11MAR2022', market_type: 'Futures' }
                        // TODO this will break if there are products with 4 chars
                        baseId = Slice(id, 0, 3)
                        quoteId = Slice(id, 3, 6)
                        // last 9 chars are expiry date
                        var expiryDate interface{} = Slice(id, OpNeg(9), nil)
                        expiry = this.ParseExpiryDate(expiryDate)
                    } else {
                        var splitAlias interface{} = Split(alias, "_")
                        var currencyIds interface{} = this.SafeString(splitAlias, 0)
                        baseId = Slice(currencyIds, 0, OpNeg(3))
                        quoteId = Slice(currencyIds, OpNeg(3), nil)
                        var splitId interface{} = Split(id, currencyIds)
                        var expiryDate interface{} = this.SafeString(splitId, 1)
                        expiry = this.ParseExpiryDate(expiryDate)
                    }
                    typeVar = "future"
                }
                var base interface{} = this.SafeCurrencyCode(baseId)
                var quote interface{} = this.SafeCurrencyCode(quoteId)
                var symbol interface{} = Add(Add(base, "/"), quote)
                var taker interface{} = GetValue(GetValue(this.Fees, "trading"), "taker")
                var maker interface{} = GetValue(GetValue(this.Fees, "trading"), "maker")
                var contract interface{} = IsTrue(swap) || IsTrue(future)
                if IsTrue(contract) {
                    maker = 0
                    taker = 0
                    settle = "JPY"
                    symbol = Add(Add(symbol, ":"), settle)
                    if IsTrue(future) {
                        symbol = Add(Add(symbol, "-"), this.Yymmdd(expiry))
                    }
                }
                AppendToArray(&result,map[string]interface{} {
                    "id": id,
                    "symbol": symbol,
                    "base": base,
                    "quote": quote,
                    "settle": settle,
                    "baseId": baseId,
                    "quoteId": quoteId,
                    "settleId": nil,
                    "type": typeVar,
                    "spot": spot,
                    "margin": false,
                    "swap": swap,
                    "future": future,
                    "option": false,
                    "active": true,
                    "contract": contract,
                    "linear": Ternary(IsTrue(spot), nil, true),
                    "inverse": Ternary(IsTrue(spot), nil, false),
                    "taker": taker,
                    "maker": maker,
                    "contractSize": nil,
                    "expiry": expiry,
                    "expiryDatetime": this.Iso8601(expiry),
                    "strike": nil,
                    "optionType": nil,
                    "precision": map[string]interface{} {
                        "amount": nil,
                        "price": nil,
                    },
                    "limits": map[string]interface{} {
                        "leverage": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "amount": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "price": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "cost": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                    },
                    "created": nil,
                    "info": market,
                })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *bitflyer) ParseBalance(response interface{}) interface{}  {
    var result interface{} = map[string]interface{} {
        "info": response,
    }
    for i := 0; IsLessThan(i, GetArrayLength(response)); i++ {
        var balance interface{} = GetValue(response, i)
        var currencyId interface{} = this.SafeString(balance, "currency_code")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        AddElementToObject(account, "total", this.SafeString(balance, "amount"))
        AddElementToObject(account, "free", this.SafeString(balance, "available"))
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name bitflyer#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://lightning.bitflyer.com/docs?lang=en#get-account-asset-balance
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *bitflyer) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes139374 := (<-this.LoadMarkets())
            PanicOnError(retRes139374)
        
            response:= (<-this.PrivateGetGetbalance(params))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "currency_code": "JPY",
            //             "amount": 1024078,
            //             "available": 508000
            //         },
            //         {
            //             "currency_code": "BTC",
            //             "amount": 10.24,
            //             "available": 4.12
            //         },
            //         {
            //             "currency_code": "ETH",
            //             "amount": 20.48,
            //             "available": 16.38
            //         }
            //     ]
            //
        ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitflyer#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://lightning.bitflyer.com/docs?lang=en#order-book
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *bitflyer) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes443226 := (<-this.LoadMarkets())
            PanicOnError(retRes443226)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "product_code": GetValue(market, "id"),
            }
        
            orderbook:= (<-this.PublicGetGetboard(this.Extend(request, params)))
            PanicOnError(orderbook)
        
            ch <- this.ParseOrderBook(orderbook, GetValue(market, "symbol"), nil, "bids", "asks", "price", "size")
            return nil
        
            }()
            return ch
        }
func  (this *bitflyer) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var symbol interface{} = this.SafeSymbol(nil, market)
    var timestamp interface{} = this.Parse8601(this.SafeString(ticker, "timestamp"))
    var last interface{} = this.SafeString(ticker, "ltp")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": nil,
        "low": nil,
        "bid": this.SafeString(ticker, "best_bid"),
        "bidVolume": nil,
        "ask": this.SafeString(ticker, "best_ask"),
        "askVolume": nil,
        "vwap": nil,
        "open": nil,
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": nil,
        "percentage": nil,
        "average": nil,
        "baseVolume": this.SafeString(ticker, "volume_by_product"),
        "quoteVolume": nil,
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name bitflyer#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://lightning.bitflyer.com/docs?lang=en#ticker
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *bitflyer) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes77592 := (<-this.LoadMarkets())
            PanicOnError(retRes77592)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "product_code": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetGetticker(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseTicker(response, market)
            return nil
        
            }()
            return ch
        }
func  (this *bitflyer) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTrades (public) v1
    //
    //      {
    //          "id":2278466664,
    //          "side":"SELL",
    //          "price":56810.7,
    //          "size":0.08798,
    //          "exec_date":"2021-11-19T11:46:39.323",
    //          "buy_child_order_acceptance_id":"JRF20211119-114209-236525",
    //          "sell_child_order_acceptance_id":"JRF20211119-114639-236919"
    //      }
    //
    // fetchMyTrades
    //
    //      {
    //          "id": 37233,
    //          "side": "BUY",
    //          "price": 33470,
    //          "size": 0.01,
    //          "exec_date": "2015-07-07T09:57:40.397",
    //          "child_order_id": "JOR20150707-060559-021935",
    //          "child_order_acceptance_id": "JRF20150707-060559-396699"
    //          "commission": 0,
    //      },
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var side interface{} = this.SafeStringLower(trade, "side")
    if IsTrue(!IsEqual(side, nil)) {
        if IsTrue(IsLessThan(GetLength(side), 1)) {
            side = nil
        }
    }
    var order interface{} = nil
    if IsTrue(!IsEqual(side, nil)) {
        var idInner interface{} = Add(side, "_child_order_acceptance_id")
        if IsTrue(InOp(trade, idInner)) {
            order = GetValue(trade, idInner)
        }
    }
    if IsTrue(IsEqual(order, nil)) {
        order = this.SafeString(trade, "child_order_acceptance_id")
    }
    var timestamp interface{} = this.Parse8601(this.SafeString(trade, "exec_date"))
    var priceString interface{} = this.SafeString(trade, "price")
    var amountString interface{} = this.SafeString(trade, "size")
    var id interface{} = this.SafeString(trade, "id")
    market = this.SafeMarket(nil, market)
    return this.SafeTrade(map[string]interface{} {
        "id": id,
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": GetValue(market, "symbol"),
        "order": order,
        "type": nil,
        "side": side,
        "takerOrMaker": nil,
        "price": priceString,
        "amount": amountString,
        "cost": nil,
        "fee": nil,
    }, market)
}
/**
 * @method
 * @name bitflyer#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://lightning.bitflyer.com/docs?lang=en#list-executions
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *bitflyer) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes963918 := (<-this.LoadMarkets())
            PanicOnError(retRes963918)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "product_code": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "count", limit)
            }
        
            response:= (<-this.PublicGetGetexecutions(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //    [
            //     {
            //       "id": 39287,
            //       "side": "BUY",
            //       "price": 31690,
            //       "size": 27.04,
            //       "exec_date": "2015-07-08T02:43:34.823",
            //       "buy_child_order_acceptance_id": "JRF20150707-200203-452209",
            //       "sell_child_order_acceptance_id": "JRF20150708-024334-060234"
            //     },
            //    ]
            //
        ch <- this.ParseTrades(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitflyer#fetchTradingFee
 * @description fetch the trading fees for a market
 * @see https://lightning.bitflyer.com/docs?lang=en#get-trading-commission
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func  (this *bitflyer) FetchTradingFee(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes740468 := (<-this.LoadMarkets())
            PanicOnError(retRes740468)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "product_code": GetValue(market, "id"),
            }
        
            response:= (<-this.PrivateGetGettradingcommission(this.Extend(request, params)))
            PanicOnError(response)
            //
            //   {
            //       commission_rate: '0.0020'
            //   }
            //
            var fee interface{} = this.SafeNumber(response, "commission_rate")
        
            ch <- map[string]interface{} {
                "info": response,
                "symbol": GetValue(market, "symbol"),
                "maker": fee,
                "taker": fee,
                "percentage": nil,
                "tierBased": nil,
            }
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitflyer#createOrder
 * @description create a trade order
 * @see https://lightning.bitflyer.com/docs?lang=en#send-a-new-order
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bitflyer) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes990919 := (<-this.LoadMarkets())
            PanicOnError(retRes990919)
            var request interface{} = map[string]interface{} {
                "product_code": this.MarketId(symbol),
                "child_order_type": ToUpper(typeVar),
                "side": ToUpper(side),
                "price": price,
                "size": amount,
            }
        
            result:= (<-this.PrivatePostSendchildorder(this.Extend(request, params)))
            PanicOnError(result)
            // { "status": - 200, "error_message": "Insufficient funds", "data": null }
            var id interface{} = this.SafeString(result, "child_order_acceptance_id")
        
            ch <- this.SafeOrder(map[string]interface{} {
                "id": id,
                "info": result,
            })
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitflyer#cancelOrder
 * @description cancels an open order
 * @see https://lightning.bitflyer.com/docs?lang=en#cancel-order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bitflyer) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " cancelOrder() requires a symbol argument")))
            }
        
            retRes804299 := (<-this.LoadMarkets())
            PanicOnError(retRes804299)
            var request interface{} = map[string]interface{} {
                "product_code": this.MarketId(symbol),
                "child_order_acceptance_id": id,
            }
        
            response:= (<-this.PrivatePostCancelchildorder(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //    200 OK.
            //
        ch <- this.SafeOrder(map[string]interface{} {
                "info": response,
            })
            return nil
        
            }()
            return ch
        }
func  (this *bitflyer) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "ACTIVE": "open",
        "COMPLETED": "closed",
        "CANCELED": "canceled",
        "EXPIRED": "canceled",
        "REJECTED": "canceled",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *bitflyer) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.Parse8601(this.SafeString(order, "child_order_date"))
    var price interface{} = this.SafeString(order, "price")
    var amount interface{} = this.SafeString(order, "size")
    var filled interface{} = this.SafeString(order, "executed_size")
    var remaining interface{} = this.SafeString(order, "outstanding_size")
    var status interface{} = this.ParseOrderStatus(this.SafeString(order, "child_order_state"))
    var typeVar interface{} = this.SafeStringLower(order, "child_order_type")
    var side interface{} = this.SafeStringLower(order, "side")
    var marketId interface{} = this.SafeString(order, "product_code")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var fee interface{} = nil
    var feeCost interface{} = this.SafeNumber(order, "total_commission")
    if IsTrue(!IsEqual(feeCost, nil)) {
        fee = map[string]interface{} {
            "cost": feeCost,
            "currency": nil,
            "rate": nil,
        }
    }
    var id interface{} = this.SafeString(order, "child_order_acceptance_id")
    return this.SafeOrder(map[string]interface{} {
        "id": id,
        "clientOrderId": nil,
        "info": order,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "status": status,
        "symbol": symbol,
        "type": typeVar,
        "timeInForce": nil,
        "postOnly": nil,
        "side": side,
        "price": price,
        "triggerPrice": nil,
        "cost": nil,
        "amount": amount,
        "filled": filled,
        "remaining": remaining,
        "fee": fee,
        "average": nil,
        "trades": nil,
    }, market)
}
/**
 * @method
 * @name bitflyer#fetchOrders
 * @description fetches information on multiple orders made by the user
 * @see https://lightning.bitflyer.com/docs?lang=en#list-orders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bitflyer) FetchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, 100)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchOrders() requires a symbol argument")))
            }
        
            retRes358266 := (<-this.LoadMarkets())
            PanicOnError(retRes358266)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "product_code": GetValue(market, "id"),
                "count": limit,
            }
        
            response:= (<-this.PrivateGetGetchildorders(this.Extend(request, params)))
            PanicOnError(response)
            var orders interface{} = this.ParseOrders(response, market, since, limit)
            if IsTrue(!IsEqual(symbol, nil)) {
                orders = this.FilterBy(orders, "symbol", symbol)
            }
        
            ch <- orders
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitflyer#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://lightning.bitflyer.com/docs?lang=en#list-orders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bitflyer) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, 100)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "child_order_state": "ACTIVE",
            }
        
                retRes650919 :=  (<-this.FetchOrders(symbol, since, limit, this.Extend(request, params)))
                PanicOnError(retRes650919)
                ch <- retRes650919
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitflyer#fetchClosedOrders
 * @description fetches information on multiple closed orders made by the user
 * @see https://lightning.bitflyer.com/docs?lang=en#list-orders
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bitflyer) FetchClosedOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, 100)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "child_order_state": "COMPLETED",
            }
        
                retRes407045 :=  (<-this.FetchOrders(symbol, since, limit, this.Extend(request, params)))
                PanicOnError(retRes407045)
                ch <- retRes407045
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitflyer#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://lightning.bitflyer.com/docs?lang=en#list-orders
 * @param {string} id the order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *bitflyer) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchOrder() requires a symbol argument")))
            }
        
            orders:= (<-this.FetchOrders(symbol))
            PanicOnError(orders)
            var ordersById interface{} = this.IndexBy(orders, "id")
            if IsTrue(InOp(ordersById, id)) {
        
                ch <- GetValue(ordersById, id)
                return nil
            }
            panic(OrderNotFound(Add(Add(this.Id, " No order found with id "), id)))
        
            }()
            return ch
        }
/**
 * @method
 * @name bitflyer#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://lightning.bitflyer.com/docs?lang=en#list-executions
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *bitflyer) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchMyTrades() requires a symbol argument")))
            }
        
            retRes385540 := (<-this.LoadMarkets())
            PanicOnError(retRes385540)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "product_code": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "count", limit)
            }
        
            response:= (<-this.PrivateGetGetexecutions(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //    [
            //     {
            //       "id": 37233,
            //       "side": "BUY",
            //       "price": 33470,
            //       "size": 0.01,
            //       "exec_date": "2015-07-07T09:57:40.397",
            //       "child_order_id": "JOR20150707-060559-021935",
            //       "child_order_acceptance_id": "JRF20150707-060559-396699"
            //       "commission": 0,
            //     },
            //    ]
            //
        ch <- this.ParseTrades(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitflyer#fetchPositions
 * @description fetch all open positions
 * @see https://lightning.bitflyer.com/docs?lang=en#get-open-interest-summary
 * @param {string[]} symbols list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *bitflyer) FetchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbols, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchPositions() requires a `symbols` argument, exactly one symbol in an array")))
            }
        
            retRes696699 := (<-this.LoadMarkets())
            PanicOnError(retRes696699)
            var request interface{} = map[string]interface{} {
                "product_code": this.MarketIds(symbols),
            }
        
            response:= (<-this.PrivateGetGetpositions(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "product_code": "FX_BTC_JPY",
            //             "side": "BUY",
            //             "price": 36000,
            //             "size": 10,
            //             "commission": 0,
            //             "swap_point_accumulate": -35,
            //             "require_collateral": 120000,
            //             "open_date": "2015-11-03T10:04:45.011",
            //             "leverage": 3,
            //             "pnl": 965,
            //             "sfd": -0.5
            //         }
            //     ]
            //
            // todo unify parsePosition/parsePositions
        ch <- response
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitflyer#withdraw
 * @description make a withdrawal
 * @see https://lightning.bitflyer.com/docs?lang=en#withdrawing-funds
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *bitflyer) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            this.CheckAddress(address)
        
            retRes78808 := (<-this.LoadMarkets())
            PanicOnError(retRes78808)
            if IsTrue(IsTrue(IsTrue(!IsEqual(code, "JPY")) && IsTrue(!IsEqual(code, "USD"))) && IsTrue(!IsEqual(code, "EUR"))) {
                panic(ExchangeError(Add(Add(Add(this.Id, " allows withdrawing JPY, USD, EUR only, "), code), " is not supported")))
            }
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "currency_code": GetValue(currency, "id"),
                "amount": amount,
            }
        
            response:= (<-this.PrivatePostWithdraw(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "message_id": "69476620-5056-4003-bcbe-42658a2b041b"
            //     }
            //
        ch <- this.ParseTransaction(response, currency)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitflyer#fetchDeposits
 * @description fetch all deposits made to an account
 * @see https://lightning.bitflyer.com/docs?lang=en#get-crypto-assets-deposit-history
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of deposits structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *bitflyer) FetchDeposits(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes964033 := (<-this.LoadMarkets())
            PanicOnError(retRes964033)
            var currency interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "count", limit) // default 100
            }
        
            response:= (<-this.PrivateGetGetcoinins(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "id": 100,
            //             "order_id": "CDP20151227-024141-055555",
            //             "currency_code": "BTC",
            //             "amount": 0.00002,
            //             "address": "1WriteySQufKZ2pVuM1oMhPrTtTVFq35j",
            //             "tx_hash": "9f92ee65a176bb9545f7becb8706c50d07d4cee5ffca34d8be3ef11d411405ae",
            //             "status": "COMPLETED",
            //             "event_date": "2015-11-27T08:59:20.301"
            //         }
            //     ]
            //
        ch <- this.ParseTransactions(response, currency, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name bitflyer#fetchWithdrawals
 * @description fetch all withdrawals made from an account
 * @see https://lightning.bitflyer.com/docs?lang=en#get-crypto-assets-transaction-history
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of withdrawals structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *bitflyer) FetchWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes34805 := (<-this.LoadMarkets())
            PanicOnError(retRes34805)
            var currency interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "count", limit) // default 100
            }
        
            response:= (<-this.PrivateGetGetcoinouts(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "id": 500,
            //             "order_id": "CWD20151224-014040-077777",
            //             "currency_code": "BTC",
            //             "amount": 0.1234,
            //             "address": "1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa",
            //             "tx_hash": "724c07dfd4044abcb390b0412c3e707dd5c4f373f0a52b3bd295ce32b478c60a",
            //             "fee": 0.0005,
            //             "additional_fee": 0.0001,
            //             "status": "COMPLETED",
            //             "event_date": "2015-12-24T01:40:40.397"
            //         }
            //     ]
            //
        ch <- this.ParseTransactions(response, currency, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *bitflyer) ParseDepositStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "PENDING": "pending",
        "COMPLETED": "ok",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *bitflyer) ParseWithdrawalStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "PENDING": "pending",
        "COMPLETED": "ok",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *bitflyer) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchDeposits
    //
    //     {
    //         "id": 100,
    //         "order_id": "CDP20151227-024141-055555",
    //         "currency_code": "BTC",
    //         "amount": 0.00002,
    //         "address": "1WriteySQufKZ2pVuM1oMhPrTtTVFq35j",
    //         "tx_hash": "9f92ee65a176bb9545f7becb8706c50d07d4cee5ffca34d8be3ef11d411405ae",
    //         "status": "COMPLETED",
    //         "event_date": "2015-11-27T08:59:20.301"
    //     }
    //
    // fetchWithdrawals
    //
    //     {
    //         "id": 500,
    //         "order_id": "CWD20151224-014040-077777",
    //         "currency_code": "BTC",
    //         "amount": 0.1234,
    //         "address": "1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa",
    //         "tx_hash": "724c07dfd4044abcb390b0412c3e707dd5c4f373f0a52b3bd295ce32b478c60a",
    //         "fee": 0.0005,
    //         "additional_fee": 0.0001,
    //         "status": "COMPLETED",
    //         "event_date": "2015-12-24T01:40:40.397"
    //     }
    //
    // withdraw
    //
    //     {
    //         "message_id": "69476620-5056-4003-bcbe-42658a2b041b"
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var id interface{} = this.SafeString2(transaction, "id", "message_id")
    var address interface{} = this.SafeString(transaction, "address")
    var currencyId interface{} = this.SafeString(transaction, "currency_code")
    var code interface{} = this.SafeCurrencyCode(currencyId, currency)
    var timestamp interface{} = this.Parse8601(this.SafeString(transaction, "event_date"))
    var amount interface{} = this.SafeNumber(transaction, "amount")
    var txId interface{} = this.SafeString(transaction, "tx_hash")
    var rawStatus interface{} = this.SafeString(transaction, "status")
    var typeVar interface{} = nil
    var status interface{} = nil
    var fee interface{} = nil
    if IsTrue(InOp(transaction, "fee")) {
        typeVar = "withdrawal"
        status = this.ParseWithdrawalStatus(rawStatus)
        var feeCost interface{} = this.SafeString(transaction, "fee")
        var additionalFee interface{} = this.SafeString(transaction, "additional_fee")
        fee = map[string]interface{} {
            "currency": code,
            "cost": this.ParseNumber(Precise.StringAdd(feeCost, additionalFee)),
        }
    } else {
        typeVar = "deposit"
        status = this.ParseDepositStatus(rawStatus)
    }
    return map[string]interface{} {
        "info": transaction,
        "id": id,
        "txid": txId,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "network": nil,
        "address": address,
        "addressTo": address,
        "addressFrom": nil,
        "tag": nil,
        "tagTo": nil,
        "tagFrom": nil,
        "type": typeVar,
        "amount": amount,
        "currency": code,
        "status": status,
        "updated": nil,
        "comment": nil,
        "internal": nil,
        "fee": fee,
    }
}
/**
 * @method
 * @name bitflyer#fetchFundingRate
 * @description fetch the current funding rate
 * @see https://lightning.bitflyer.com/docs#funding-rate
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
 */
func  (this *bitflyer) FetchFundingRate(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes907515 := (<-this.LoadMarkets())
            PanicOnError(retRes907515)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "product_code": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetGetfundingrate(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //    {
            //        "current_funding_rate": -0.003750000000
            //        "next_funding_rate_settledate": "2024-04-15T13:00:00"
            //    }
            //
        ch <- this.ParseFundingRate(response, market)
            return nil
        
            }()
            return ch
        }
func  (this *bitflyer) ParseFundingRate(contract interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "current_funding_rate": -0.003750000000
    //        "next_funding_rate_settledate": "2024-04-15T13:00:00"
    //    }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var nextFundingDatetime interface{} = this.SafeString(contract, "next_funding_rate_settledate")
    var nextFundingTimestamp interface{} = this.Parse8601(nextFundingDatetime)
    return map[string]interface{} {
        "info": contract,
        "symbol": this.SafeString(market, "symbol"),
        "markPrice": nil,
        "indexPrice": nil,
        "interestRate": nil,
        "estimatedSettlePrice": nil,
        "timestamp": nil,
        "datetime": nil,
        "fundingRate": nil,
        "fundingTimestamp": nil,
        "fundingDatetime": nil,
        "nextFundingRate": this.SafeNumber(contract, "current_funding_rate"),
        "nextFundingTimestamp": nextFundingTimestamp,
        "nextFundingDatetime": this.Iso8601(nextFundingTimestamp),
        "previousFundingRate": nil,
        "previousFundingTimestamp": nil,
        "previousFundingDatetime": nil,
        "interval": nil,
    }
}
func  (this *bitflyer) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var request interface{} = Add(Add("/", this.Version), "/")
    if IsTrue(IsEqual(api, "private")) {
        request = Add(request, "me/")
    }
    request = Add(request, path)
    if IsTrue(IsEqual(method, "GET")) {
        if IsTrue(GetArrayLength(ObjectKeys(params))) {
            request = Add(request, Add("?", this.Urlencode(params)))
        }
    }
    var baseUrl interface{} = this.ImplodeHostname(GetValue(GetValue(this.Urls, "api"), "rest"))
    var url interface{} = Add(baseUrl, request)
    if IsTrue(IsEqual(api, "private")) {
        this.CheckRequiredCredentials()
        var nonce interface{} = ToString(this.Nonce())
        var auth interface{} = Join([]interface{}{nonce, method, request}, "")
        if IsTrue(GetArrayLength(ObjectKeys(params))) {
            if IsTrue(!IsEqual(method, "GET")) {
                body = this.Json(params)
                auth = Add(auth, body)
            }
        }
        headers = map[string]interface{} {
            "ACCESS-KEY": this.ApiKey,
            "ACCESS-TIMESTAMP": nonce,
            "ACCESS-SIGN": this.Hmac(this.Encode(auth), this.Encode(this.Secret), sha256),
            "Content-Type": "application/json",
        }
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *bitflyer) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsEqual(response, nil)) {
        return nil  // fallback to the default error handler
    }
    var feedback interface{} = Add(Add(this.Id, " "), body)
    // i.e. {"status":-2,"error_message":"Under maintenance","data":null}
    var errorMessage interface{} = this.SafeString(response, "error_message")
    var statusCode interface{} = this.SafeInteger(response, "status")
    if IsTrue(!IsEqual(errorMessage, nil)) {
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), statusCode, feedback)
        panic(ExchangeError(feedback))
    }
    return nil
}


func (this *bitflyer) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
