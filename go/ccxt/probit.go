package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type probit struct {
    Exchange

}

func NewProbitCore() probit {
   p := probit{}
   setDefaults(&p)
   return p
}

func  (this *probit) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "probit",
        "name": "ProBit",
        "countries": []interface{}{"SC", "KR"},
        "rateLimit": 50,
        "pro": true,
        "has": map[string]interface{} {
            "CORS": true,
            "spot": true,
            "margin": false,
            "swap": false,
            "future": false,
            "option": false,
            "addMargin": false,
            "cancelOrder": true,
            "createMarketBuyOrderWithCost": true,
            "createMarketOrder": true,
            "createMarketOrderWithCost": false,
            "createMarketSellOrderWithCost": false,
            "createOrder": true,
            "createReduceOnlyOrder": false,
            "createStopLimitOrder": false,
            "createStopMarketOrder": false,
            "createStopOrder": false,
            "fetchBalance": true,
            "fetchBorrowRateHistories": false,
            "fetchBorrowRateHistory": false,
            "fetchClosedOrders": true,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchCurrencies": true,
            "fetchDepositAddress": true,
            "fetchDepositAddresses": true,
            "fetchDepositAddressesByNetwork": false,
            "fetchDeposits": true,
            "fetchDepositsWithdrawals": true,
            "fetchFundingHistory": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchIndexOHLCV": false,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchLeverage": false,
            "fetchLeverageTiers": false,
            "fetchMarginMode": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchPosition": false,
            "fetchPositionHistory": false,
            "fetchPositionMode": false,
            "fetchPositions": false,
            "fetchPositionsForSymbol": false,
            "fetchPositionsHistory": false,
            "fetchPositionsRisk": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTime": true,
            "fetchTrades": true,
            "fetchTradingFee": false,
            "fetchTradingFees": false,
            "fetchTransactions": "emulated",
            "fetchTransfer": false,
            "fetchTransfers": false,
            "fetchWithdrawal": false,
            "fetchWithdrawals": true,
            "reduceMargin": false,
            "sandbox": false,
            "setLeverage": false,
            "setMarginMode": false,
            "setPositionMode": false,
            "signIn": true,
            "transfer": false,
            "withdraw": true,
        },
        "timeframes": map[string]interface{} {
            "1m": "1m",
            "3m": "3m",
            "5m": "5m",
            "10m": "10m",
            "15m": "15m",
            "30m": "30m",
            "1h": "1h",
            "4h": "4h",
            "6h": "6h",
            "12h": "12h",
            "1d": "1D",
            "1w": "1W",
            "1M": "1M",
        },
        "version": "v1",
        "urls": map[string]interface{} {
            "logo": "https://user-images.githubusercontent.com/51840849/79268032-c4379480-7ea2-11ea-80b3-dd96bb29fd0d.jpg",
            "api": map[string]interface{} {
                "accounts": "https://accounts.probit.com",
                "public": "https://api.probit.com/api/exchange",
                "private": "https://api.probit.com/api/exchange",
            },
            "www": "https://www.probit.com",
            "doc": []interface{}{"https://docs-en.probit.com", "https://docs-ko.probit.com"},
            "fees": "https://support.probit.com/hc/en-us/articles/360020968611-Trading-Fees",
            "referral": "https://www.probit.com/r/34608773",
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": map[string]interface{} {
                    "market": 1,
                    "currency": 1,
                    "currency_with_platform": 1,
                    "time": 1,
                    "ticker": 1,
                    "order_book": 1,
                    "trade": 1,
                    "candle": 1,
                },
            },
            "private": map[string]interface{} {
                "post": map[string]interface{} {
                    "new_order": 2,
                    "cancel_order": 1,
                    "withdrawal": 2,
                },
                "get": map[string]interface{} {
                    "balance": 1,
                    "order": 1,
                    "open_order": 1,
                    "order_history": 1,
                    "trade_history": 1,
                    "deposit_address": 1,
                    "transfer/payment": 1,
                },
            },
            "accounts": map[string]interface{} {
                "post": map[string]interface{} {
                    "token": 1,
                },
            },
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "tierBased": false,
                "percentage": true,
                "maker": this.ParseNumber("0.002"),
                "taker": this.ParseNumber("0.002"),
            },
        },
        "features": map[string]interface{} {
            "spot": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": false,
                    "triggerDirection": false,
                    "triggerPriceType": nil,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": true,
                        "FOK": true,
                        "PO": false,
                        "GTD": false,
                    },
                    "hedged": false,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyByCost": true,
                    "marketBuyRequiresPrice": false,
                    "selfTradePrevention": false,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": 1000,
                    "daysBack": 100000,
                    "untilDays": 100000,
                    "symbolRequired": false,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": nil,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOrders": nil,
                "fetchClosedOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 1000,
                    "daysBack": 100000,
                    "daysBackCanceled": 1,
                    "untilDays": 90,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOHLCV": map[string]interface{} {
                    "limit": 4000,
                },
            },
            "swap": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "UNAUTHORIZED": AuthenticationError,
                "INVALID_ARGUMENT": BadRequest,
                "TRADING_UNAVAILABLE": ExchangeNotAvailable,
                "NOT_ENOUGH_BALANCE": InsufficientFunds,
                "NOT_ALLOWED_COMBINATION": BadRequest,
                "INVALID_ORDER": InvalidOrder,
                "RATE_LIMIT_EXCEEDED": RateLimitExceeded,
                "MARKET_UNAVAILABLE": ExchangeNotAvailable,
                "INVALID_MARKET": BadSymbol,
                "MARKET_CLOSED": MarketClosed,
                "MARKET_NOT_FOUND": BadSymbol,
                "INVALID_CURRENCY": BadRequest,
                "TOO_MANY_OPEN_ORDERS": DDoSProtection,
                "DUPLICATE_ADDRESS": InvalidAddress,
                "invalid_grant": AuthenticationError,
            },
        },
        "requiredCredentials": map[string]interface{} {
            "apiKey": true,
            "secret": true,
        },
        "precisionMode": TICK_SIZE,
        "options": map[string]interface{} {
            "createMarketBuyOrderRequiresPrice": true,
            "timeInForce": map[string]interface{} {
                "limit": "gtc",
                "market": "ioc",
            },
            "networks": map[string]interface{} {
                "BEP20": "BSC",
                "ERC20": "ETH",
                "TRC20": "TRON",
            },
        },
        "commonCurrencies": map[string]interface{} {
            "BB": "Baby Bali",
            "CBC": "CryptoBharatCoin",
            "CTK": "Cryptyk",
            "CTT": "Castweet",
            "DKT": "DAKOTA",
            "EGC": "EcoG9coin",
            "EPS": "Epanus",
            "FX": "Fanzy",
            "GM": "GM Holding",
            "GOGOL": "GOL",
            "GOL": "Goldofir",
            "HUSL": "The Hustle App",
            "LAND": "Landbox",
            "SST": "SocialSwap",
            "TCT": "Top Coin Token",
            "TOR": "Torex",
            "UNI": "UNICORN Token",
            "UNISWAP": "UNI",
        },
    })
}
/**
 * @method
 * @name probit#fetchMarkets
 * @see https://docs-en.probit.com/reference/market
 * @description retrieves data on all markets for probit
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *probit) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetMarket(params))
            PanicOnError(response)
            //
            //     {
            //         "data":[
            //             {
            //                 "id":"MONA-USDT",
            //                 "base_currency_id":"MONA",
            //                 "quote_currency_id":"USDT",
            //                 "min_price":"0.001",
            //                 "max_price":"9999999999999999",
            //                 "price_increment":"0.001",
            //                 "min_quantity":"0.0001",
            //                 "max_quantity":"9999999999999999",
            //                 "quantity_precision":4,
            //                 "min_cost":"1",
            //                 "max_cost":"9999999999999999",
            //                 "cost_precision":8,
            //                 "taker_fee_rate":"0.2",
            //                 "maker_fee_rate":"0.2",
            //                 "show_in_ui":true,
            //                 "closed":false
            //             },
            //         ]
            //     }
            //
            var markets interface{} = this.SafeValue(response, "data", []interface{}{})
        
            ch <- this.ParseMarkets(markets)
            return nil
        
            }()
            return ch
        }
func  (this *probit) ParseMarket(market interface{}) interface{}  {
    var id interface{} = this.SafeString(market, "id")
    var baseId interface{} = this.SafeString(market, "base_currency_id")
    var quoteId interface{} = this.SafeString(market, "quote_currency_id")
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    var closed interface{} = this.SafeBool(market, "closed", false)
    var showInUI interface{} = this.SafeBool(market, "show_in_ui", true)
    var active interface{} = !IsTrue(closed) && IsTrue(showInUI)
    var takerFeeRate interface{} = this.SafeString(market, "taker_fee_rate")
    var taker interface{} = Precise.StringDiv(takerFeeRate, "100")
    var makerFeeRate interface{} = this.SafeString(market, "maker_fee_rate")
    var maker interface{} = Precise.StringDiv(makerFeeRate, "100")
    return map[string]interface{} {
        "id": id,
        "symbol": Add(Add(base, "/"), quote),
        "base": base,
        "quote": quote,
        "settle": nil,
        "baseId": baseId,
        "quoteId": quoteId,
        "settleId": nil,
        "type": "spot",
        "spot": true,
        "margin": false,
        "swap": false,
        "future": false,
        "option": false,
        "active": active,
        "contract": false,
        "linear": nil,
        "inverse": nil,
        "taker": this.ParseNumber(taker),
        "maker": this.ParseNumber(maker),
        "contractSize": nil,
        "expiry": nil,
        "expiryDatetime": nil,
        "strike": nil,
        "optionType": nil,
        "precision": map[string]interface{} {
            "amount": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "quantity_precision"))),
            "price": this.SafeNumber(market, "price_increment"),
            "cost": this.ParseNumber(this.ParsePrecision(this.SafeString(market, "cost_precision"))),
        },
        "limits": map[string]interface{} {
            "leverage": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "amount": map[string]interface{} {
                "min": this.SafeNumber(market, "min_quantity"),
                "max": this.SafeNumber(market, "max_quantity"),
            },
            "price": map[string]interface{} {
                "min": this.SafeNumber(market, "min_price"),
                "max": this.SafeNumber(market, "max_price"),
            },
            "cost": map[string]interface{} {
                "min": this.SafeNumber(market, "min_cost"),
                "max": this.SafeNumber(market, "max_cost"),
            },
        },
        "created": nil,
        "info": market,
    }
}
/**
 * @method
 * @name probit#fetchCurrencies
 * @see https://docs-en.probit.com/reference/currency
 * @description fetches all available currencies on an exchange
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func  (this *probit) FetchCurrencies(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetCurrencyWithPlatform(params))
            PanicOnError(response)
            //
            //     {
            //         "data":[
            //             {
            //                 "id":"USDT",
            //                 "display_name":{"ko-kr":"테더","en-us":"Tether"},
            //                 "show_in_ui":true,
            //                 "platform":[
            //                     {
            //                         "id":"ETH",
            //                         "priority":1,
            //                         "deposit":true,
            //                         "withdrawal":true,
            //                         "currency_id":"USDT",
            //                         "precision":6,
            //                         "min_confirmation_count":15,
            //                         "require_destination_tag":false,
            //                         "display_name":{"name":{"ko-kr":"ERC-20","en-us":"ERC-20"}},
            //                         "min_deposit_amount":"0",
            //                         "min_withdrawal_amount":"1",
            //                         "withdrawal_fee":[
            //                             {"amount":"0.01","priority":2,"currency_id":"ETH"},
            //                             {"amount":"1.5","priority":1,"currency_id":"USDT"},
            //                         ],
            //                         "deposit_fee":{},
            //                         "suspended_reason":"",
            //                         "deposit_suspended":false,
            //                         "withdrawal_suspended":false
            //                     },
            //                     {
            //                         "id":"OMNI",
            //                         "priority":2,
            //                         "deposit":true,
            //                         "withdrawal":true,
            //                         "currency_id":"USDT",
            //                         "precision":6,
            //                         "min_confirmation_count":3,
            //                         "require_destination_tag":false,
            //                         "display_name":{"name":{"ko-kr":"OMNI","en-us":"OMNI"}},
            //                         "min_deposit_amount":"0",
            //                         "min_withdrawal_amount":"5",
            //                         "withdrawal_fee":[{"amount":"5","priority":1,"currency_id":"USDT"}],
            //                         "deposit_fee":{},
            //                         "suspended_reason":"wallet_maintenance",
            //                         "deposit_suspended":false,
            //                         "withdrawal_suspended":false
            //                     }
            //                 ],
            //                 "stakeable":false,
            //                 "unstakeable":false,
            //                 "auto_stake":false,
            //                 "auto_stake_amount":"0"
            //             }
            //         ]
            //     }
            //
            var currencies interface{} = this.SafeValue(response, "data", []interface{}{})
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(currencies)); i++ {
                var currency interface{} = GetValue(currencies, i)
                var id interface{} = this.SafeString(currency, "id")
                var code interface{} = this.SafeCurrencyCode(id)
                var displayName interface{} = this.SafeValue(currency, "display_name")
                var name interface{} = this.SafeString(displayName, "en-us")
                var platforms interface{} = this.SafeValue(currency, "platform", []interface{}{})
                var platformsByPriority interface{} = this.SortBy(platforms, "priority")
                var platform interface{} = nil
                var networkList interface{} = map[string]interface{} {}
                for j := 0; IsLessThan(j, GetArrayLength(platformsByPriority)); j++ {
                    var network interface{} = GetValue(platformsByPriority, j)
                    var idInner interface{} = this.SafeString(network, "id")
                    var networkCode interface{} = this.NetworkIdToCode(idInner)
                    var currentDepositSuspended interface{} = this.SafeValue(network, "deposit_suspended")
                    var currentWithdrawalSuspended interface{} = this.SafeValue(network, "withdrawal_suspended")
                    var currentDeposit interface{} =             !IsTrue(currentDepositSuspended)
                    var currentWithdraw interface{} =             !IsTrue(currentWithdrawalSuspended)
                    var currentActive interface{} = IsTrue(currentDeposit) && IsTrue(currentWithdraw)
                    if IsTrue(currentActive) {
                        platform = network
                    }
                    var precision interface{} = this.ParsePrecision(this.SafeString(network, "precision"))
                    var withdrawFee interface{} = this.SafeValue(network, "withdrawal_fee", []interface{}{})
                    var networkFee interface{} = this.SafeValue(withdrawFee, 0, map[string]interface{} {})
                    for k := 0; IsLessThan(k, GetArrayLength(withdrawFee)); k++ {
                        var withdrawPlatform interface{} = GetValue(withdrawFee, k)
                        var feeCurrencyId interface{} = this.SafeString(withdrawPlatform, "currency_id")
                        if IsTrue(IsEqual(feeCurrencyId, id)) {
                            networkFee = withdrawPlatform
                            break
                        }
                    }
                    AddElementToObject(networkList, networkCode, map[string]interface{} {
            "id": idInner,
            "network": networkCode,
            "active": currentActive,
            "deposit": currentDeposit,
            "withdraw": currentWithdraw,
            "fee": this.SafeNumber(networkFee, "amount"),
            "precision": this.ParseNumber(precision),
            "limits": map[string]interface{} {
                "withdraw": map[string]interface{} {
                    "min": this.SafeNumber(network, "min_withdrawal_amount"),
                    "max": nil,
                },
                "deposit": map[string]interface{} {
                    "min": this.SafeNumber(network, "min_deposit_amount"),
                    "max": nil,
                },
            },
            "info": network,
        })
                }
                if IsTrue(IsEqual(platform, nil)) {
                    platform = this.SafeValue(platformsByPriority, 0, map[string]interface{} {})
                }
                var depositSuspended interface{} = this.SafeValue(platform, "deposit_suspended")
                var withdrawalSuspended interface{} = this.SafeValue(platform, "withdrawal_suspended")
                var deposit interface{} =         !IsTrue(depositSuspended)
                var withdraw interface{} =         !IsTrue(withdrawalSuspended)
                var active interface{} = IsTrue(deposit) && IsTrue(withdraw)
                var withdrawalFees interface{} = this.SafeValue(platform, "withdrawal_fee", map[string]interface{} {})
                var fees interface{} = []interface{}{}
                // sometimes the withdrawal fee is an empty object
                // [ { 'amount': '0.015', 'priority': 1, 'currency_id': 'ETH' }, {} ]
                for j := 0; IsLessThan(j, GetArrayLength(withdrawalFees)); j++ {
                    var withdrawalFeeInner interface{} = GetValue(withdrawalFees, j)
                    var amount interface{} = this.SafeNumber(withdrawalFeeInner, "amount")
                    var priority interface{} = this.SafeInteger(withdrawalFeeInner, "priority")
                    if IsTrue(IsTrue((!IsEqual(amount, nil))) && IsTrue((!IsEqual(priority, nil)))) {
                        AppendToArray(&fees,withdrawalFeeInner)
                    }
                }
                var withdrawalFeesByPriority interface{} = this.SortBy(fees, "priority")
                var withdrawalFee interface{} = this.SafeValue(withdrawalFeesByPriority, 0, map[string]interface{} {})
                var fee interface{} = this.SafeNumber(withdrawalFee, "amount")
                AddElementToObject(result, code, map[string]interface{} {
            "id": id,
            "code": code,
            "info": currency,
            "name": name,
            "active": active,
            "deposit": deposit,
            "withdraw": withdraw,
            "fee": fee,
            "precision": this.ParseNumber(this.ParsePrecision(this.SafeString(platform, "precision"))),
            "limits": map[string]interface{} {
                "amount": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
                "deposit": map[string]interface{} {
                    "min": this.SafeNumber(platform, "min_deposit_amount"),
                    "max": nil,
                },
                "withdraw": map[string]interface{} {
                    "min": this.SafeNumber(platform, "min_withdrawal_amount"),
                    "max": nil,
                },
            },
            "networks": networkList,
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *probit) ParseBalance(response interface{}) interface{}  {
    var result interface{} = map[string]interface{} {
        "info": response,
        "timestamp": nil,
        "datetime": nil,
    }
    var data interface{} = this.SafeValue(response, "data", []interface{}{})
    for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
        var balance interface{} = GetValue(data, i)
        var currencyId interface{} = this.SafeString(balance, "currency_id")
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        AddElementToObject(account, "total", this.SafeString(balance, "total"))
        AddElementToObject(account, "free", this.SafeString(balance, "available"))
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name probit#fetchBalance
 * @see https://docs-en.probit.com/reference/balance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *probit) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes42043 := (<-this.LoadMarkets())
            PanicOnError(retRes42043)
        
            response:= (<-this.PrivateGetBalance(params))
            PanicOnError(response)
        
                //
            //     {
            //         "data": [
            //             {
            //                 "currency_id":"XRP",
            //                 "total":"100",
            //                 "available":"0",
            //             }
            //         ]
            //     }
            //
        ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name probit#fetchOrderBook
 * @see https://docs-en.probit.com/reference/order_book
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *probit) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes389262 := (<-this.LoadMarkets())
            PanicOnError(retRes389262)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market_id": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetOrderBook(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         data: [
            //             { side: 'buy', price: '0.000031', quantity: '10' },
            //             { side: 'buy', price: '0.00356007', quantity: '4.92156877' },
            //             { side: 'sell', price: '0.1857', quantity: '0.17' },
            //         ]
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", []interface{}{})
            var dataBySide interface{} = this.GroupBy(data, "side")
        
            ch <- this.ParseOrderBook(dataBySide, GetValue(market, "symbol"), nil, "buy", "sell", "price", "quantity")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name probit#fetchTickers
 * @see https://docs-en.probit.com/reference/ticker
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *probit) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes563107 := (<-this.LoadMarkets())
            PanicOnError(retRes563107)
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbols, nil)) {
                var marketIds interface{} = this.MarketIds(symbols)
                AddElementToObject(request, "market_ids", Join(marketIds, ","))
            }
        
            response:= (<-this.PublicGetTicker(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "data":[
            //             {
            //                 "last":"0.022902",
            //                 "low":"0.021693",
            //                 "high":"0.024093",
            //                 "change":"-0.000047",
            //                 "base_volume":"15681.986",
            //                 "quote_volume":"360.514403624",
            //                 "market_id":"ETH-BTC",
            //                 "time":"2020-04-12T18:43:38.000Z"
            //             }
            //         ]
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTickers(data, symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name probit#fetchTicker
 * @see https://docs-en.probit.com/reference/ticker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *probit) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes372056 := (<-this.LoadMarkets())
            PanicOnError(retRes372056)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market_ids": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetTicker(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "data":[
            //             {
            //                 "last":"0.022902",
            //                 "low":"0.021693",
            //                 "high":"0.024093",
            //                 "change":"-0.000047",
            //                 "base_volume":"15681.986",
            //                 "quote_volume":"360.514403624",
            //                 "market_id":"ETH-BTC",
            //                 "time":"2020-04-12T18:43:38.000Z"
            //             }
            //         ]
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", []interface{}{})
            var ticker interface{} = this.SafeValue(data, 0)
            if IsTrue(IsEqual(ticker, nil)) {
                panic(BadResponse(Add(this.Id, " fetchTicker() returned an empty response")))
            }
        
            ch <- this.ParseTicker(ticker, market)
            return nil
        
            }()
            return ch
        }
func  (this *probit) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "last":"0.022902",
    //         "low":"0.021693",
    //         "high":"0.024093",
    //         "change":"-0.000047",
    //         "base_volume":"15681.986",
    //         "quote_volume":"360.514403624",
    //         "market_id":"ETH-BTC",
    //         "time":"2020-04-12T18:43:38.000Z"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.Parse8601(this.SafeString(ticker, "time"))
    var marketId interface{} = this.SafeString(ticker, "market_id")
    var symbol interface{} = this.SafeSymbol(marketId, market, "-")
    var close interface{} = this.SafeString(ticker, "last")
    var change interface{} = this.SafeString(ticker, "change")
    var baseVolume interface{} = this.SafeString(ticker, "base_volume")
    var quoteVolume interface{} = this.SafeString(ticker, "quote_volume")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeString(ticker, "high"),
        "low": this.SafeString(ticker, "low"),
        "bid": nil,
        "bidVolume": nil,
        "ask": nil,
        "askVolume": nil,
        "vwap": nil,
        "open": nil,
        "close": close,
        "last": close,
        "previousClose": nil,
        "change": change,
        "percentage": nil,
        "average": nil,
        "baseVolume": baseVolume,
        "quoteVolume": quoteVolume,
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name probit#fetchMyTrades
 * @see https://docs-en.probit.com/reference/trade
 * @description fetch all trades made by the user
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *probit) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes756575 := (<-this.LoadMarkets())
            PanicOnError(retRes756575)
            var market interface{} = nil
            var now interface{} = this.Milliseconds()
            var request interface{} = map[string]interface{} {
                "limit": 100,
                "start_time": this.Iso8601(Subtract(now, 31536000000)),
                "end_time": this.Iso8601(now),
            }
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "market_id", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_time", this.Iso8601(since))
                AddElementToObject(request, "end_time", this.Iso8601(mathMin(now, Add(since, 31536000000))))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.PrivateGetTradeHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "data": [
            //             {
            //                 "id":"BTC-USDT:183566",
            //                 "order_id":"17209376",
            //                 "side":"sell",
            //                 "fee_amount":"0.657396569175",
            //                 "fee_currency_id":"USDT",
            //                 "status":"settled",
            //                 "price":"6573.96569175",
            //                 "quantity":"0.1",
            //                 "cost":"657.396569175",
            //                 "time":"2018-08-10T06:06:46.000Z",
            //                 "market_id":"BTC-USDT"
            //             }
            //         ]
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTrades(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name probit#fetchTrades
 * @see https://docs-en.probit.com/reference/trade-1
 * @description get the list of most recent trades for a particular symbol
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *probit) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes450373 := (<-this.LoadMarkets())
            PanicOnError(retRes450373)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market_id": GetValue(market, "id"),
                "start_time": "1970-01-01T00:00:00.000Z",
                "end_time": this.Iso8601(this.Milliseconds()),
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_time", this.Iso8601(since))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", mathMin(limit, 1000))
            } else {
                AddElementToObject(request, "limit", 1000) // required to set any value
            }
        
            response:= (<-this.PublicGetTrade(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "data":[
            //             {
            //                 "id":"ETH-BTC:3331886",
            //                 "price":"0.022981",
            //                 "quantity":"12.337",
            //                 "time":"2020-04-12T20:55:42.371Z",
            //                 "side":"sell",
            //                 "tick_direction":"down"
            //             },
            //             {
            //                 "id":"ETH-BTC:3331885",
            //                 "price":"0.022982",
            //                 "quantity":"6.472",
            //                 "time":"2020-04-12T20:55:39.652Z",
            //                 "side":"sell",
            //                 "tick_direction":"down"
            //             }
            //         ]
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTrades(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *probit) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTrades (public)
    //
    //     {
    //         "id":"ETH-BTC:3331886",
    //         "price":"0.022981",
    //         "quantity":"12.337",
    //         "time":"2020-04-12T20:55:42.371Z",
    //         "side":"sell",
    //         "tick_direction":"down"
    //     }
    //
    // fetchMyTrades (private)
    //
    //     {
    //         "id":"BTC-USDT:183566",
    //         "order_id":"17209376",
    //         "side":"sell",
    //         "fee_amount":"0.657396569175",
    //         "fee_currency_id":"USDT",
    //         "status":"settled",
    //         "price":"6573.96569175",
    //         "quantity":"0.1",
    //         "cost":"657.396569175",
    //         "time":"2018-08-10T06:06:46.000Z",
    //         "market_id":"BTC-USDT"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.Parse8601(this.SafeString(trade, "time"))
    var id interface{} = this.SafeString(trade, "id")
    var marketId interface{} = nil
    if IsTrue(!IsEqual(id, nil)) {
        var parts interface{} = Split(id, ":")
        marketId = this.SafeString(parts, 0)
    }
    marketId = this.SafeString(trade, "market_id", marketId)
    var symbol interface{} = this.SafeSymbol(marketId, market, "-")
    var side interface{} = this.SafeString(trade, "side")
    var priceString interface{} = this.SafeString(trade, "price")
    var amountString interface{} = this.SafeString(trade, "quantity")
    var orderId interface{} = this.SafeString(trade, "order_id")
    var feeCostString interface{} = this.SafeString(trade, "fee_amount")
    var fee interface{} = nil
    if IsTrue(!IsEqual(feeCostString, nil)) {
        var feeCurrencyId interface{} = this.SafeString(trade, "fee_currency_id")
        var feeCurrencyCode interface{} = this.SafeCurrencyCode(feeCurrencyId)
        fee = map[string]interface{} {
            "cost": feeCostString,
            "currency": feeCurrencyCode,
        }
    }
    return this.SafeTrade(map[string]interface{} {
        "id": id,
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": symbol,
        "order": orderId,
        "type": nil,
        "side": side,
        "takerOrMaker": nil,
        "price": priceString,
        "amount": amountString,
        "cost": nil,
        "fee": fee,
    }, market)
}
/**
 * @method
 * @name probit#fetchTime
 * @see https://docs-en.probit.com/reference/time
 * @description fetches the current integer timestamp in milliseconds from the exchange server
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the exchange server
 */
func  (this *probit) FetchTime(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetTime(params))
            PanicOnError(response)
            //
            //     { "data":"2020-04-12T18:54:25.390Z" }
            //
            var timestamp interface{} = this.Parse8601(this.SafeString(response, "data"))
        
            ch <- timestamp
            return nil
        
            }()
            return ch
        }
func  (this *probit) NormalizeOHLCVTimestamp(timestamp interface{}, timeframe interface{}, optionalArgs ...interface{}) interface{}  {
    after := GetArg(optionalArgs, 0, false)
    _ = after
    var duration interface{} = this.ParseTimeframe(timeframe)
    if IsTrue(IsEqual(timeframe, "1M")) {
        var iso8601 interface{} = this.Iso8601(timestamp)
        var parts interface{} = Split(iso8601, "-")
        var year interface{} = this.SafeString(parts, 0)
        var month interface{} = this.SafeInteger(parts, 1)
        var monthString interface{} = nil
        if IsTrue(after) {
            monthString = ToString(this.Sum(month, 1))
        }
        if IsTrue(IsLessThan(month, 10)) {
            monthString = Add("0", ToString(month))
        }
        return Add(Add(Add(year, "-"), monthString), "-01T00:00:00.000Z")
    } else if IsTrue(IsEqual(timeframe, "1w")) {
        timestamp = this.ParseToInt(Divide(timestamp, 1000))
        var firstSunday interface{} = 259200 // 1970-01-04T00:00:00.000Z
        var difference interface{} = Subtract(timestamp, firstSunday)
        var numWeeks interface{} = MathFloor(Divide(difference, duration))
        var previousSunday interface{} = this.Sum(firstSunday, Multiply(numWeeks, duration))
        if IsTrue(after) {
            previousSunday = this.Sum(previousSunday, duration)
        }
        return this.Iso8601(Multiply(previousSunday, 1000))
    } else {
        timestamp = this.ParseToInt(Divide(timestamp, 1000))
        timestamp = Multiply(duration, this.ParseToInt(Divide(timestamp, duration)))
        if IsTrue(after) {
            timestamp = this.Sum(timestamp, duration)
        }
        return this.Iso8601(Multiply(timestamp, 1000))
    }
}
/**
 * @method
 * @name probit#fetchOHLCV
 * @see https://docs-en.probit.com/reference/candle
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.until] timestamp in ms of the earliest candle to fetch
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *probit) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes57873 := (<-this.LoadMarkets())
            PanicOnError(retRes57873)
            var market interface{} = this.Market(symbol)
            var interval interface{} = this.SafeString(this.Timeframes, timeframe, timeframe)
            limit = Ternary(IsTrue((IsEqual(limit, nil))), 100, limit)
            var requestLimit interface{} = this.Sum(limit, 1)
            requestLimit = mathMin(1000, requestLimit) // max 1000
            var request interface{} = map[string]interface{} {
                "market_ids": GetValue(market, "id"),
                "interval": interval,
                "sort": "asc",
                "limit": requestLimit,
            }
            var now interface{} = this.Milliseconds()
            var until interface{} = this.SafeInteger(params, "until")
            var durationMilliseconds interface{} = Multiply(this.ParseTimeframe(timeframe), 1000)
            var startTime interface{} = since
            var endTime interface{} = Ternary(IsTrue((!IsEqual(until, nil))), Subtract(until, durationMilliseconds), now)
            if IsTrue(IsEqual(since, nil)) {
                if IsTrue(IsEqual(limit, nil)) {
                    limit = requestLimit
                }
                var startLimit interface{} = Subtract(limit, 1)
                startTime = Subtract(endTime, Multiply(startLimit, durationMilliseconds))
            } else {
                if IsTrue(!IsEqual(limit, nil)) {
                    var endByLimit interface{} = this.Sum(since, Multiply(limit, durationMilliseconds))
                    endTime = mathMin(endTime, endByLimit)
                }
            }
            var startTimeNormalized interface{} = this.NormalizeOHLCVTimestamp(startTime, timeframe)
            var endTimeNormalized interface{} = this.NormalizeOHLCVTimestamp(endTime, timeframe, true)
            AddElementToObject(request, "start_time", startTimeNormalized)
            AddElementToObject(request, "end_time", endTimeNormalized)
        
            response:= (<-this.PublicGetCandle(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "data":[
            //             {
            //                 "market_id":"ETH-BTC",
            //                 "open":"0.02811",
            //                 "close":"0.02811",
            //                 "low":"0.02811",
            //                 "high":"0.02811",
            //                 "base_volume":"0.0005",
            //                 "quote_volume":"0.000014055",
            //                 "start_time":"2018-11-30T18:19:00.000Z",
            //                 "end_time":"2018-11-30T18:20:00.000Z"
            //             },
            //         ]
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseOHLCVs(data, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *probit) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "market_id":"ETH-BTC",
    //         "open":"0.02811",
    //         "close":"0.02811",
    //         "low":"0.02811",
    //         "high":"0.02811",
    //         "base_volume":"0.0005",
    //         "quote_volume":"0.000014055",
    //         "start_time":"2018-11-30T18:19:00.000Z",
    //         "end_time":"2018-11-30T18:20:00.000Z"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{this.Parse8601(this.SafeString(ohlcv, "start_time")), this.SafeNumber(ohlcv, "open"), this.SafeNumber(ohlcv, "high"), this.SafeNumber(ohlcv, "low"), this.SafeNumber(ohlcv, "close"), this.SafeNumber(ohlcv, "base_volume")}
}
/**
 * @method
 * @name probit#fetchOpenOrders
 * @see https://docs-en.probit.com/reference/open_order-1
 * @description fetch all unfilled currently open orders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *probit) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes498296 := (<-this.LoadMarkets())
            PanicOnError(retRes498296)
            since = this.Parse8601(since)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "market_id", GetValue(market, "id"))
            }
        
            response:= (<-this.PrivateGetOpenOrder(this.Extend(request, params)))
            PanicOnError(response)
            var data interface{} = this.SafeList(response, "data")
        
            ch <- this.ParseOrders(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name probit#fetchClosedOrders
 * @see https://docs-en.probit.com/reference/order
 * @description fetches information on multiple closed orders made by the user
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *probit) FetchClosedOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes585750 := (<-this.LoadMarkets())
            PanicOnError(retRes585750)
            var request interface{} = map[string]interface{} {
                "start_time": this.Iso8601(0),
                "end_time": this.Iso8601(this.Milliseconds()),
                "limit": 100,
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "market_id", GetValue(market, "id"))
            }
            if IsTrue(since) {
                AddElementToObject(request, "start_time", this.Iso8601(since))
            }
            if IsTrue(limit) {
                AddElementToObject(request, "limit", limit)
            }
        
            response:= (<-this.PrivateGetOrderHistory(this.Extend(request, params)))
            PanicOnError(response)
            var data interface{} = this.SafeList(response, "data")
        
            ch <- this.ParseOrders(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name probit#fetchOrder
 * @see https://docs-en.probit.com/reference/order-3
 * @description fetches information on an order made by the user
 * @param {string} id the order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *probit) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchOrder() requires a symbol argument")))
            }
        
            retRes830506 := (<-this.LoadMarkets())
            PanicOnError(retRes830506)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market_id": GetValue(market, "id"),
            }
            var clientOrderId interface{} = this.SafeString2(params, "clientOrderId", "client_order_id")
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                AddElementToObject(request, "client_order_id", clientOrderId)
            } else {
                AddElementToObject(request, "order_id", id)
            }
            var query interface{} = this.Omit(params, []interface{}{"clientOrderId", "client_order_id"})
        
            response:= (<-this.PrivateGetOrder(this.Extend(request, query)))
            PanicOnError(response)
            var data interface{} = this.SafeValue(response, "data", []interface{}{})
            var order interface{} = this.SafeDict(data, 0)
        
            ch <- this.ParseOrder(order, market)
            return nil
        
            }()
            return ch
        }
func  (this *probit) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "open": "open",
        "cancelled": "canceled",
        "filled": "closed",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *probit) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         id,
    //         user_id,
    //         market_id,
    //         "type": "orderType",
    //         "side": "side",
    //         quantity,
    //         limit_price,
    //         "time_in_force": "timeInForce",
    //         filled_cost,
    //         filled_quantity,
    //         open_quantity,
    //         cancelled_quantity,
    //         "status": "orderStatus",
    //         "time": "date",
    //         client_order_id,
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var status interface{} = this.ParseOrderStatus(this.SafeString(order, "status"))
    var id interface{} = this.SafeString(order, "id")
    var typeVar interface{} = this.SafeString(order, "type")
    var side interface{} = this.SafeString(order, "side")
    var marketId interface{} = this.SafeString(order, "market_id")
    var symbol interface{} = this.SafeSymbol(marketId, market, "-")
    var timestamp interface{} = this.Parse8601(this.SafeString(order, "time"))
    var price interface{} = this.SafeString(order, "limit_price")
    var filled interface{} = this.SafeString(order, "filled_quantity")
    var remaining interface{} = this.SafeString(order, "open_quantity")
    var canceledAmount interface{} = this.SafeString(order, "cancelled_quantity")
    if IsTrue(!IsEqual(canceledAmount, nil)) {
        remaining = Precise.StringAdd(remaining, canceledAmount)
    }
    var amount interface{} = this.SafeString(order, "quantity", Precise.StringAdd(filled, remaining))
    var cost interface{} = this.SafeString2(order, "filled_cost", "cost")
    if IsTrue(IsEqual(typeVar, "market")) {
        price = nil
    }
    var clientOrderId interface{} = this.SafeString(order, "client_order_id")
    var timeInForce interface{} = this.SafeStringUpper(order, "time_in_force")
    return this.SafeOrder(map[string]interface{} {
        "id": id,
        "info": order,
        "clientOrderId": clientOrderId,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "symbol": symbol,
        "type": typeVar,
        "timeInForce": timeInForce,
        "side": side,
        "status": status,
        "price": price,
        "triggerPrice": nil,
        "amount": amount,
        "filled": filled,
        "remaining": remaining,
        "average": nil,
        "cost": cost,
        "fee": nil,
        "trades": nil,
    }, market)
}
func  (this *probit) CostToPrecision(symbol interface{}, cost interface{}) interface{}  {
    return this.DecimalToPrecision(cost, TRUNCATE, GetValue(GetValue(GetValue(this.Markets, symbol), "precision"), "cost"), this.PrecisionMode)
}
/**
 * @method
 * @name probit#createOrder
 * @description create a trade order
 * @see https://docs-en.probit.com/reference/order-1
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much you want to trade in units of the base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {float} [params.cost] the quote quantity that can be used as an alternative for the amount for market buy orders
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *probit) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes639441 := (<-this.LoadMarkets())
            PanicOnError(retRes639441)
            var market interface{} = this.Market(symbol)
            var options interface{} = this.SafeValue(this.Options, "timeInForce")
            var defaultTimeInForce interface{} = this.SafeValue(options, typeVar)
            var timeInForce interface{} = this.SafeString2(params, "timeInForce", "time_in_force", defaultTimeInForce)
            var request interface{} = map[string]interface{} {
                "market_id": GetValue(market, "id"),
                "type": typeVar,
                "side": side,
                "time_in_force": timeInForce,
            }
            var clientOrderId interface{} = this.SafeString2(params, "clientOrderId", "client_order_id")
            if IsTrue(!IsEqual(clientOrderId, nil)) {
                AddElementToObject(request, "client_order_id", clientOrderId)
            }
            var quoteAmount interface{} = nil
            if IsTrue(IsEqual(typeVar, "limit")) {
                AddElementToObject(request, "limit_price", this.PriceToPrecision(symbol, price))
                AddElementToObject(request, "quantity", this.AmountToPrecision(symbol, amount))
            } else if IsTrue(IsEqual(typeVar, "market")) {
                // for market buy it requires the amount of quote currency to spend
                if IsTrue(IsEqual(side, "buy")) {
                    var createMarketBuyOrderRequiresPrice interface{} = true
                    createMarketBuyOrderRequiresPriceparamsVariable := this.HandleOptionAndParams(params, "createOrder", "createMarketBuyOrderRequiresPrice", true);
                    createMarketBuyOrderRequiresPrice = GetValue(createMarketBuyOrderRequiresPriceparamsVariable,0);
                    params = GetValue(createMarketBuyOrderRequiresPriceparamsVariable,1)
                    var cost interface{} = this.SafeString(params, "cost")
                    params = this.Omit(params, "cost")
                    if IsTrue(!IsEqual(cost, nil)) {
                        quoteAmount = this.CostToPrecision(symbol, cost)
                    } else if IsTrue(createMarketBuyOrderRequiresPrice) {
                        if IsTrue(IsEqual(price, nil)) {
                            panic(InvalidOrder(Add(this.Id, " createOrder() requires the price argument for market buy orders to calculate the total cost to spend (amount * price), alternatively set the createMarketBuyOrderRequiresPrice option or param to false and pass the cost to spend in the amount argument")))
                        } else {
                            var amountString interface{} = this.NumberToString(amount)
                            var priceString interface{} = this.NumberToString(price)
                            var costRequest interface{} = Precise.StringMul(amountString, priceString)
                            quoteAmount = this.CostToPrecision(symbol, costRequest)
                        }
                    } else {
                        quoteAmount = this.CostToPrecision(symbol, amount)
                    }
                    AddElementToObject(request, "cost", quoteAmount)
                } else {
                    AddElementToObject(request, "quantity", this.AmountToPrecision(symbol, amount))
                }
            }
            var query interface{} = this.Omit(params, []interface{}{"timeInForce", "time_in_force", "clientOrderId", "client_order_id"})
        
            response:= (<-this.PrivatePostNewOrder(this.Extend(request, query)))
            PanicOnError(response)
            //
            //     {
            //         "data": {
            //             id,
            //             user_id,
            //             market_id,
            //             "type": "orderType",
            //             "side": "side",
            //             quantity,
            //             limit_price,
            //             "time_in_force": "timeInForce",
            //             filled_cost,
            //             filled_quantity,
            //             open_quantity,
            //             cancelled_quantity,
            //             "status": "orderStatus",
            //             "time": "date",
            //             client_order_id,
            //         }
            //     }
            //
            var data interface{} = this.SafeValue(response, "data")
            var order interface{} = this.ParseOrder(data, market)
            // a workaround for incorrect huge amounts
            // returned by the exchange on market buys
            if IsTrue(IsTrue((IsEqual(typeVar, "market"))) && IsTrue((IsEqual(side, "buy")))) {
                AddElementToObject(order, "amount", nil)
                AddElementToObject(order, "cost", this.ParseNumber(quoteAmount))
                AddElementToObject(order, "remaining", nil)
            }
        
            ch <- order
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name probit#cancelOrder
 * @see https://docs-en.probit.com/reference/order-2
 * @description cancels an open order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *probit) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " cancelOrder() requires a symbol argument")))
            }
        
            retRes452262 := (<-this.LoadMarkets())
            PanicOnError(retRes452262)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "market_id": GetValue(market, "id"),
                "order_id": id,
            }
        
            response:= (<-this.PrivatePostCancelOrder(this.Extend(request, params)))
            PanicOnError(response)
            var data interface{} = this.SafeDict(response, "data")
        
            ch <- this.ParseOrder(data)
            return nil
        
            }()
            return ch
        }
func  (this *probit) ParseDepositAddress(depositAddress interface{}, optionalArgs ...interface{}) interface{}  {
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var address interface{} = this.SafeString(depositAddress, "address")
    var tag interface{} = this.SafeString(depositAddress, "destination_tag")
    var currencyId interface{} = this.SafeString(depositAddress, "currency_id")
    currency = this.SafeCurrency(currencyId, currency)
    var code interface{} = GetValue(currency, "code")
    var network interface{} = this.SafeString(depositAddress, "platform_id")
    this.CheckAddress(address)
    return map[string]interface{} {
        "info": depositAddress,
        "currency": code,
        "network": network,
        "address": address,
        "tag": tag,
    }
}
/**
 * @method
 * @name probit#fetchDepositAddress
 * @see https://docs-en.probit.com/reference/deposit_address
 * @description fetch the deposit address for a currency associated with this account
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *probit) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes496163 := (<-this.LoadMarkets())
            PanicOnError(retRes496163)
            var currency interface{} = this.Currency(code)
            var request interface{} = map[string]interface{} {
                "currency_id": GetValue(currency, "id"),
            }
            var networks interface{} = this.SafeValue(this.Options, "networks", map[string]interface{} {})
            var network interface{} = this.SafeStringUpper(params, "network") // this line allows the user to specify either ERC20 or ETH
            network = this.SafeString(networks, network, network) // handle ERC20>ETH alias
            if IsTrue(!IsEqual(network, nil)) {
                AddElementToObject(request, "platform_id", network)
                params = this.Omit(params, "platform_id")
            }
        
            response:= (<-this.PrivateGetDepositAddress(this.Extend(request, params)))
            PanicOnError(response)
            //
            // without 'platform_id'
            //     {
            //         "data":[
            //             {
            //                 "currency_id":"ETH",
            //                 "address":"0x12e2caf3c4051ba1146e612f532901a423a9898a",
            //                 "destination_tag":null
            //             }
            //         ]
            //     }
            //
            // with 'platform_id'
            //     {
            //         "data":[
            //             {
            //                 "platform_id":"TRON",
            //                 "address":"TDQLMxBTa6MzuoZ6deSGZkqET3Ek8v7uC6",
            //                 "destination_tag":null
            //             }
            //         ]
            //     }
            //
            var data interface{} = this.SafeValue(response, "data", []interface{}{})
            var firstAddress interface{} = this.SafeValue(data, 0)
            if IsTrue(IsEqual(firstAddress, nil)) {
                panic(InvalidAddress(Add(this.Id, " fetchDepositAddress() returned an empty response")))
            }
        
            ch <- this.ParseDepositAddress(firstAddress, currency)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name probit#fetchDepositAddresses
 * @see https://docs-en.probit.com/reference/deposit_address
 * @description fetch deposit addresses for multiple currencies and chain types
 * @param {string[]|undefined} codes list of unified currency codes, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [address structures]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *probit) FetchDepositAddresses(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    codes := GetArg(optionalArgs, 0, nil)
            _ = codes
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes66443 := (<-this.LoadMarkets())
            PanicOnError(retRes66443)
            var request interface{} = map[string]interface{} {}
            if IsTrue(codes) {
                var currencyIds interface{} = []interface{}{}
                for i := 0; IsLessThan(i, GetArrayLength(codes)); i++ {
                    var currency interface{} = this.Currency(GetValue(codes, i))
                    AppendToArray(&currencyIds,GetValue(currency, "id"))
                }
                AddElementToObject(request, "currency_id", Join(codes, ","))
            }
        
            response:= (<-this.PrivateGetDepositAddress(this.Extend(request, params)))
            PanicOnError(response)
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseDepositAddresses(data, codes)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name probit#withdraw
 * @see https://docs-en.probit.com/reference/withdrawal
 * @description make a withdrawal
 * @param {string} code unified currency code
 * @param {float} amount the amount to withdraw
 * @param {string} address the address to withdraw to
 * @param {string} tag
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *probit) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            tagparamsVariable := this.HandleWithdrawTagAndParams(tag, params);
            tag = GetValue(tagparamsVariable,0);
            params = GetValue(tagparamsVariable,1)
            // In order to use this method
            // you need to allow API withdrawal from the API Settings Page, and
            // and register the list of withdrawal addresses and destination tags on the API Settings page
            // you can only withdraw to the registered addresses using the API
            this.CheckAddress(address)
        
            retRes653609 := (<-this.LoadMarkets())
            PanicOnError(retRes653609)
            var currency interface{} = this.Currency(code)
            if IsTrue(IsEqual(tag, nil)) {
                tag = ""
            }
            var request interface{} = map[string]interface{} {
                "currency_id": GetValue(currency, "id"),
                "address": address,
                "destination_tag": tag,
                "amount": this.NumberToString(amount),
            }
            var networks interface{} = this.SafeValue(this.Options, "networks", map[string]interface{} {})
            var network interface{} = this.SafeStringUpper(params, "network") // this line allows the user to specify either ERC20 or ETH
            network = this.SafeString(networks, network, network) // handle ERC20>ETH alias
            if IsTrue(!IsEqual(network, nil)) {
                AddElementToObject(request, "platform_id", network)
                params = this.Omit(params, "network")
            }
        
            response:= (<-this.PrivatePostWithdrawal(this.Extend(request, params)))
            PanicOnError(response)
            var data interface{} = this.SafeDict(response, "data")
        
            ch <- this.ParseTransaction(data, currency)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name probit#fetchDeposits
 * @description fetch all deposits made to an account
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch deposits for
 * @param {int} [limit] the maximum number of transaction structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *probit) FetchDeposits(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "type": "deposit",
            }
        
            result:= (<-this.FetchTransactions(code, since, limit, this.Extend(request, params)))
            PanicOnError(result)
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name probit#fetchWithdrawals
 * @description fetch all withdrawals made to an account
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch withdrawals for
 * @param {int} [limit] the maximum number of transaction structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *probit) FetchWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "type": "withdrawal",
            }
        
            result:= (<-this.FetchTransactions(code, since, limit, this.Extend(request, params)))
            PanicOnError(result)
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name probit#fetchDepositsWithdrawals
 * @description fetch history of deposits and withdrawals
 * @see https://docs-en.probit.com/reference/transferpayment
 * @param {string} code unified currency code
 * @param {int} [since] the earliest time in ms to fetch transactions for
 * @param {int} [limit] the maximum number of transaction structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] the latest time in ms to fetch transactions for
 * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *probit) FetchDepositsWithdrawals(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    code := GetArg(optionalArgs, 0, nil)
            _ = code
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes351369 := (<-this.LoadMarkets())
            PanicOnError(retRes351369)
            var currency interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(code, nil)) {
                currency = this.Currency(code)
                AddElementToObject(request, "currency_id", GetValue(currency, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start_time", this.Iso8601(since))
            } else {
                AddElementToObject(request, "start_time", this.Iso8601(1))
            }
            var until interface{} = this.SafeInteger(params, "until")
            if IsTrue(!IsEqual(until, nil)) {
                AddElementToObject(request, "end_time", this.Iso8601(until))
                params = this.Omit(params, []interface{}{"until"})
            } else {
                AddElementToObject(request, "end_time", this.Iso8601(this.Milliseconds()))
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "limit", limit)
            } else {
                AddElementToObject(request, "limit", 100)
            }
        
            response:= (<-this.PrivateGetTransferPayment(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "data": [
            //             {
            //                 "id": "01211d4b-0e68-41d6-97cb-298bfe2cab67",
            //                 "type": "deposit",
            //                 "status": "done",
            //                 "amount": "0.01",
            //                 "address": "0x9e7430fc0bdd14745bd00a1b92ed25133a7c765f",
            //                 "time": "2023-06-14T12:03:11.000Z",
            //                 "hash": "0x0ff5bedc9e378f9529acc6b9840fa8c2ef00fd0275e0bac7fa0589a9b5d1712e",
            //                 "currency_id": "ETH",
            //                 "confirmations":0,
            //                 "fee": "0",
            //                 "destination_tag": null,
            //                 "platform_id": "ETH",
            //                 "fee_currency_id": "ETH",
            //                 "payment_service_name":null,
            //                 "payment_service_display_name":null,
            //                 "crypto":null
            //             }
            //         ]
            //     }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTransactions(data, currency, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *probit) ParseTransaction(transaction interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "id": "01211d4b-0e68-41d6-97cb-298bfe2cab67",
    //         "type": "deposit",
    //         "status": "done",
    //         "amount": "0.01",
    //         "address": "0x9e7430fc0bdd14745bd00a1b92ed25133a7c765f",
    //         "time": "2023-06-14T12:03:11.000Z",
    //         "hash": "0x0ff5bedc9e378f9529acc6b9840fa8c2ef00fd0275e0bac7fa0589a9b5d1712e",
    //         "currency_id": "ETH",
    //         "confirmations":0,
    //         "fee": "0",
    //         "destination_tag": null,
    //         "platform_id": "ETH",
    //         "fee_currency_id": "ETH",
    //         "payment_service_name":null,
    //         "payment_service_display_name":null,
    //         "crypto":null
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var id interface{} = this.SafeString(transaction, "id")
    var networkId interface{} = this.SafeString(transaction, "platform_id")
    var networkCode interface{} = this.NetworkIdToCode(networkId)
    var amount interface{} = this.SafeNumber(transaction, "amount")
    var address interface{} = this.SafeString(transaction, "address")
    var tag interface{} = this.SafeString(transaction, "destination_tag")
    var txid interface{} = this.SafeString(transaction, "hash")
    var timestamp interface{} = this.Parse8601(this.SafeString(transaction, "time"))
    var typeVar interface{} = this.SafeString(transaction, "type")
    var currencyId interface{} = this.SafeString(transaction, "currency_id")
    var code interface{} = this.SafeCurrencyCode(currencyId)
    var status interface{} = this.ParseTransactionStatus(this.SafeString(transaction, "status"))
    var feeCostString interface{} = this.SafeString(transaction, "fee")
    var fee interface{} = nil
    if IsTrue(IsTrue(!IsEqual(feeCostString, nil)) && IsTrue(!IsEqual(feeCostString, "0"))) {
        fee = map[string]interface{} {
            "currency": code,
            "cost": this.ParseNumber(feeCostString),
        }
    }
    return map[string]interface{} {
        "id": id,
        "currency": code,
        "amount": amount,
        "network": networkCode,
        "addressFrom": nil,
        "address": address,
        "addressTo": address,
        "tagFrom": nil,
        "tag": tag,
        "tagTo": tag,
        "status": status,
        "type": typeVar,
        "txid": txid,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "updated": nil,
        "internal": nil,
        "comment": nil,
        "fee": fee,
        "info": transaction,
    }
}
func  (this *probit) ParseTransactionStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "requested": "pending",
        "pending": "pending",
        "confirming": "pending",
        "confirmed": "pending",
        "applying": "pending",
        "done": "ok",
        "cancelled": "canceled",
        "cancelling": "canceled",
    }
    return this.SafeString(statuses, status, status)
}
/**
 * @method
 * @name probit#fetchDepositWithdrawFees
 * @see https://docs-en.probit.com/reference/currency
 * @description fetch deposit and withdraw fees
 * @param {string[]|undefined} codes list of unified currency codes
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [fees structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
 */
func  (this *probit) FetchDepositWithdrawFees(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    codes := GetArg(optionalArgs, 0, nil)
            _ = codes
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes546655 := (<-this.LoadMarkets())
            PanicOnError(retRes546655)
        
            response:= (<-this.PublicGetCurrencyWithPlatform(params))
            PanicOnError(response)
            //
            //  {
            //     "data": [
            //       {
            //       "id": "AFX",
            //       "display_name": {
            //       "ko-kr": "아프릭스",
            //       "en-us": "Afrix"
            //       },
            //       "show_in_ui": true,
            //       "platform": [
            //       {
            //       "id": "ZYN",
            //       "priority": 1,
            //       "deposit": true,
            //       "withdrawal": true,
            //       "currency_id": "AFX",
            //       "precision": 18,
            //       "min_confirmation_count": 60,
            //       "require_destination_tag": false,
            //       "allow_withdrawal_destination_tag": false,
            //       "display_name": {
            //       "name": {
            //       "ko-kr": "지네코인",
            //       "en-us": "Wethio"
            //       }
            //       },
            //       "min_deposit_amount": "0",
            //       "min_withdrawal_amount": "0",
            //       "withdrawal_fee": [
            //       {
            //       "currency_id": "ZYN",
            //       "amount": "0.5",
            //       "priority": 1
            //       }
            //       ],
            //       "deposit_fee": {},
            //       "suspended_reason": "",
            //       "deposit_suspended": false,
            //       "withdrawal_suspended": false,
            //       "platform_currency_display_name": {}
            //       }
            //       ],
            //       "internal_transfer": {
            //       "suspended_reason": null,
            //       "suspended": false
            //       },
            //       "stakeable": false,
            //       "unstakeable": false,
            //       "auto_stake": false,
            //       "auto_stake_amount": "0"
            //       },
            //     ]
            //  }
            //
            var data interface{} = this.SafeList(response, "data")
        
            ch <- this.ParseDepositWithdrawFees(data, codes, "id")
            return nil
        
            }()
            return ch
        }
func  (this *probit) ParseDepositWithdrawFee(fee interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // {
    //     "id": "USDT",
    //     "display_name": { "ko-kr": '테더', "en-us": "Tether" },
    //     "show_in_ui": true,
    //     "platform": [
    //       {
    //         "id": "ETH",
    //         "priority": "1",
    //         "deposit": true,
    //         "withdrawal": true,
    //         "currency_id": "USDT",
    //         "precision": "6",
    //         "min_confirmation_count": "15",
    //         "require_destination_tag": false,
    //         "allow_withdrawal_destination_tag": false,
    //         "display_name": [Object],
    //         "min_deposit_amount": "0",
    //         "min_withdrawal_amount": "1",
    //         "withdrawal_fee": [Array],
    //         "deposit_fee": {},
    //         "suspended_reason": '',
    //         "deposit_suspended": false,
    //         "withdrawal_suspended": false,
    //         "platform_currency_display_name": [Object]
    //       },
    //     ],
    //     "internal_transfer": { suspended_reason: null, suspended: false },
    //     "stakeable": false,
    //     "unstakeable": false,
    //     "auto_stake": false,
    //     "auto_stake_amount": "0"
    //   }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var depositWithdrawFee interface{} = this.DepositWithdrawFee(map[string]interface{} {})
    var platforms interface{} = this.SafeValue(fee, "platform", []interface{}{})
    var depositResult interface{} = map[string]interface{} {
        "fee": nil,
        "percentage": nil,
    }
    for i := 0; IsLessThan(i, GetArrayLength(platforms)); i++ {
        var network interface{} = GetValue(platforms, i)
        var networkId interface{} = this.SafeString(network, "id")
        var networkCode interface{} = this.NetworkIdToCode(networkId, GetValue(currency, "code"))
        var withdrawalFees interface{} = this.SafeValue(network, "withdrawal_fee", map[string]interface{} {})
        var withdrawFee interface{} = this.SafeNumber(GetValue(withdrawalFees, 0), "amount")
        if IsTrue(GetArrayLength(withdrawalFees)) {
            var withdrawResult interface{} = map[string]interface{} {
                "fee": withdrawFee,
                "percentage": Ternary(IsTrue((!IsEqual(withdrawFee, nil))), false, nil),
            }
            if IsTrue(IsEqual(i, 0)) {
                AddElementToObject(depositWithdrawFee, "withdraw", withdrawResult)
            }
            AddElementToObject(GetValue(depositWithdrawFee, "networks"), networkCode, map[string]interface{} {
    "withdraw": withdrawResult,
    "deposit": depositResult,
})
        }
    }
    AddElementToObject(depositWithdrawFee, "info", fee)
    return depositWithdrawFee
}
func  (this *probit) Nonce() interface{}  {
    return this.Milliseconds()
}
func  (this *probit) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var url interface{} = Add(GetValue(GetValue(this.Urls, "api"), api), "/")
    var query interface{} = this.Omit(params, this.ExtractParams(path))
    if IsTrue(IsEqual(api, "accounts")) {
        this.CheckRequiredCredentials()
        url = Add(url, this.ImplodeParams(path, params))
        var auth interface{} = Add(Add(this.ApiKey, ":"), this.Secret)
        var auth64 interface{} = this.StringToBase64(auth)
        headers = map[string]interface{} {
            "Authorization": Add("Basic ", auth64),
            "Content-Type": "application/json",
        }
        if IsTrue(GetArrayLength(ObjectKeys(query))) {
            body = this.Json(query)
        }
    } else {
        url = Add(url, Add(this.Version, "/"))
        if IsTrue(IsEqual(api, "public")) {
            url = Add(url, this.ImplodeParams(path, params))
            if IsTrue(GetArrayLength(ObjectKeys(query))) {
                url = Add(url, Add("?", this.Urlencode(query)))
            }
        } else if IsTrue(IsEqual(api, "private")) {
            var now interface{} = this.Milliseconds()
            this.CheckRequiredCredentials()
            var expires interface{} = this.SafeInteger(this.Options, "expires")
            if IsTrue(IsTrue((IsEqual(expires, nil))) || IsTrue((IsLessThan(expires, now)))) {
                panic(AuthenticationError(Add(this.Id, " access token expired, call signIn() method")))
            }
            var accessToken interface{} = this.SafeString(this.Options, "accessToken")
            headers = map[string]interface{} {
                "Authorization": Add("Bearer ", accessToken),
            }
            url = Add(url, this.ImplodeParams(path, params))
            if IsTrue(IsEqual(method, "GET")) {
                if IsTrue(GetArrayLength(ObjectKeys(query))) {
                    url = Add(url, Add("?", this.Urlencode(query)))
                }
            } else if IsTrue(GetArrayLength(ObjectKeys(query))) {
                body = this.Json(query)
                AddElementToObject(headers, "Content-Type", "application/json")
            }
        }
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
/**
 * @method
 * @name probit#signIn
 * @see https://docs-en.probit.com/reference/token
 * @description sign in, must be called prior to using other authenticated methods
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns response from exchange
 */
func  (this *probit) SignIn(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            this.CheckRequiredCredentials()
            var request interface{} = map[string]interface{} {
                "grant_type": "client_credentials",
            }
        
            response:= (<-this.AccountsPostToken(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "access_token": "0ttDv/2hTTn3bLi8GP1gKaneiEQ6+0hOBenPrxNQt2s=",
            //         "token_type": "bearer",
            //         "expires_in": 900
            //     }
            //
            var expiresIn interface{} = this.SafeInteger(response, "expires_in")
            var accessToken interface{} = this.SafeString(response, "access_token")
            AddElementToObject(this.Options, "accessToken", accessToken)
            AddElementToObject(this.Options, "expires", this.Sum(this.Milliseconds(), Multiply(expiresIn, 1000)))
        
            ch <- response
            return nil
        
            }()
            return ch
        }
func  (this *probit) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsEqual(response, nil)) {
        return nil  // fallback to default error handler
    }
    if IsTrue(InOp(response, "errorCode")) {
        var errorCode interface{} = this.SafeString(response, "errorCode")
        if IsTrue(!IsEqual(errorCode, nil)) {
            var errMessage interface{} = this.SafeString(response, "message", "")
            var details interface{} = this.SafeValue(response, "details")
            var feedback interface{} = Add(Add(Add(Add(Add(Add(this.Id, " "), errorCode), " "), errMessage), " "), this.Json(details))
            if IsTrue(InOp(this.Exceptions, "exact")) {
                this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), errorCode, feedback)
            }
            if IsTrue(InOp(this.Exceptions, "broad")) {
                this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), errMessage, feedback)
            }
            panic(ExchangeError(feedback))
        }
    }
    return nil
}


func (this *probit) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
