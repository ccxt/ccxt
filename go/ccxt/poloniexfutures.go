package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type poloniexfutures struct {
    Exchange

}

func NewPoloniexfuturesCore() poloniexfutures {
   p := poloniexfutures{}
   setDefaults(&p)
   return p
}

func  (this *poloniexfutures) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "poloniexfutures",
        "name": "Poloniex Futures",
        "countries": []interface{}{"US"},
        "rateLimit": 33.3,
        "certified": false,
        "pro": true,
        "version": "v1",
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": false,
            "margin": true,
            "swap": true,
            "future": false,
            "option": nil,
            "createOrder": true,
            "createStopOrder": true,
            "createTriggerOrder": true,
            "fetchBalance": true,
            "fetchClosedOrders": true,
            "fetchCurrencies": false,
            "fetchDepositAddress": false,
            "fetchDepositAddresses": false,
            "fetchDepositAddressesByNetwork": false,
            "fetchFundingInterval": true,
            "fetchFundingIntervals": false,
            "fetchFundingRate": true,
            "fetchFundingRateHistory": false,
            "fetchL3OrderBook": true,
            "fetchMarkets": true,
            "fetchMyTrades": true,
            "fetchOHLCV": true,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrdersByStatus": true,
            "fetchPositions": true,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTime": true,
            "fetchTrades": true,
            "setMarginMode": true,
        },
        "timeframes": map[string]interface{} {
            "1m": 1,
            "5m": 5,
            "15m": 15,
            "30m": 30,
            "1h": 60,
            "2h": 120,
            "4h": 480,
            "12h": 720,
            "1d": 1440,
            "1w": 10080,
        },
        "urls": map[string]interface{} {
            "logo": "https://user-images.githubusercontent.com/1294454/27766817-e9456312-5ee6-11e7-9b3c-b628ca5626a5.jpg",
            "api": map[string]interface{} {
                "public": "https://futures-api.poloniex.com",
                "private": "https://futures-api.poloniex.com",
            },
            "www": "https://www.poloniex.com",
            "doc": "https://api-docs.poloniex.com/futures/",
            "fees": "https://poloniex.com/fee-schedule",
            "referral": "https://poloniex.com/signup?c=UBFZJRPJ",
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": map[string]interface{} {
                    "contracts/active": 10,
                    "contracts/{symbol}": 10,
                    "ticker": 10,
                    "tickers": 10,
                    "level2/snapshot": 180.002,
                    "level2/depth": 180.002,
                    "level2/message/query": 180.002,
                    "level3/snapshot": 180.002,
                    "trade/history": 10,
                    "interest/query": 10,
                    "index/query": 10,
                    "mark-price/{symbol}/current": 10,
                    "premium/query": 10,
                    "funding-rate/{symbol}/current": 10,
                    "timestamp": 10,
                    "status": 10,
                    "kline/query": 10,
                },
                "post": map[string]interface{} {
                    "bullet-public": 10,
                },
            },
            "private": map[string]interface{} {
                "get": map[string]interface{} {
                    "account-overview": 1,
                    "transaction-history": 1,
                    "maxActiveOrders": 1,
                    "maxRiskLimit": 1,
                    "userFeeRate": 1,
                    "marginType/query": 1,
                    "orders": 1,
                    "stopOrders": 1,
                    "recentDoneOrders": 1,
                    "orders/{order-id}": 1,
                    "clientOrderId/{clientOid}": 1,
                    "fills": 1,
                    "openOrderStatistics": 1,
                    "position": 1.5,
                    "positions": 1.5,
                    "funding-history": 1,
                },
                "post": map[string]interface{} {
                    "orders": 1.5,
                    "batchOrders": 1.5,
                    "position/margin/auto-deposit-status": 1.5,
                    "position/margin/deposit-margin": 1.5,
                    "position/margin/withdraw-margin": 1.5,
                    "bullet-private": 1,
                    "marginType/change": 1,
                },
                "delete": map[string]interface{} {
                    "orders/{order-id}": 1.5,
                    "orders": 150.016,
                    "stopOrders": 150.016,
                },
            },
        },
        "precisionMode": TICK_SIZE,
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "tierBased": false,
                "percentage": true,
                "taker": this.ParseNumber("0.00075"),
                "maker": this.ParseNumber("0.0001"),
            },
            "funding": map[string]interface{} {
                "tierBased": false,
                "percentage": false,
                "withdraw": map[string]interface{} {},
                "deposit": map[string]interface{} {},
            },
        },
        "commonCurrencies": map[string]interface{} {},
        "requiredCredentials": map[string]interface{} {
            "apiKey": true,
            "secret": true,
            "password": true,
        },
        "options": map[string]interface{} {
            "networks": map[string]interface{} {
                "OMNI": "omni",
                "ERC20": "eth",
                "TRC20": "trx",
            },
            "versions": map[string]interface{} {
                "public": map[string]interface{} {
                    "GET": map[string]interface{} {
                        "ticker": "v2",
                        "tickers": "v2",
                        "level3/snapshot": "v2",
                    },
                },
            },
        },
        "features": map[string]interface{} {
            "default": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": true,
                    "triggerPriceType": map[string]interface{} {
                        "last": true,
                        "mark": true,
                        "index": true,
                    },
                    "triggerDirection": true,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": true,
                        "FOK": false,
                        "PO": true,
                        "GTD": false,
                    },
                    "hedged": false,
                    "leverage": true,
                    "marketBuyByCost": true,
                    "marketBuyRequiresPrice": false,
                    "selfTradePrevention": false,
                    "trailing": false,
                    "iceberg": true,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": nil,
                    "daysBack": 100000,
                    "untilDays": 7,
                    "symbolRequired": false,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": true,
                    "limit": nil,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOrders": nil,
                "fetchClosedOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": 100000,
                    "daysBackCanceled": 1,
                    "untilDays": 100000,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOHLCV": map[string]interface{} {
                    "limit": 200,
                },
            },
            "spot": nil,
            "swap": map[string]interface{} {
                "linear": map[string]interface{} {
                    "extends": "default",
                },
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "400": BadRequest,
                "401": AuthenticationError,
                "403": NotSupported,
                "404": NotSupported,
                "405": NotSupported,
                "415": BadRequest,
                "429": RateLimitExceeded,
                "500": ExchangeNotAvailable,
                "503": ExchangeNotAvailable,
                "400001": AuthenticationError,
                "400002": InvalidNonce,
                "400003": AuthenticationError,
                "400004": AuthenticationError,
                "400005": AuthenticationError,
                "400006": AuthenticationError,
                "400007": AuthenticationError,
                "404000": NotSupported,
                "400100": BadRequest,
                "411100": AccountSuspended,
                "500000": ExchangeNotAvailable,
            },
            "broad": map[string]interface{} {
                "Position does not exist": OrderNotFound,
            },
        },
    })
}
/**
 * @method
 * @name poloniexfutures#fetchMarkets
 * @description retrieves data on all markets for poloniexfutures
 * @see https://api-docs.poloniex.com/futures/api/symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *poloniexfutures) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetContractsActive(params))
            PanicOnError(response)
            //
            // {
            //  "code": "200000",
            //  "data": [
            //     {
            //       "symbol": "APTUSDTPERP",
            //       "takerFixFee": "0E-10",
            //       "nextFundingRateTime": "20145603",
            //       "makerFixFee": "0E-10",
            //       "type": "FFWCSX",
            //       "predictedFundingFeeRate": "0.000000",
            //       "turnoverOf24h": "386037.46704292",
            //       "initialMargin": "0.05",
            //       "isDeleverage": true,
            //       "createdAt": "1666681959000",
            //       "fundingBaseSymbol": ".APTINT8H",
            //       "lowPriceOf24h": "4.34499979019165",
            //       "lastTradePrice": "4.4090000000",
            //       "indexPriceTickSize": "0.001",
            //       "fairMethod": "FundingRate",
            //       "takerFeeRate": "0.00040",
            //       "order": "102",
            //       "updatedAt": "1671076377000",
            //       "displaySettleCurrency": "USDT",
            //       "indexPrice": "4.418",
            //       "multiplier": "1.0",
            //       "maxLeverage": "20",
            //       "fundingQuoteSymbol": ".USDTINT8H",
            //       "quoteCurrency": "USDT",
            //       "maxOrderQty": "1000000",
            //       "maxPrice": "1000000.0000000000",
            //       "maintainMargin": "0.025",
            //       "status": "Open",
            //       "displayNameMap": [Object],
            //       "openInterest": "2367",
            //       "highPriceOf24h": "4.763999938964844",
            //       "fundingFeeRate": "0.000000",
            //       "volumeOf24h": "83540.00000000",
            //       "riskStep": "500000",
            //       "isQuanto": true,
            //       "maxRiskLimit": "20000",
            //       "rootSymbol": "USDT",
            //       "baseCurrency": "APT",
            //       "firstOpenDate": "1666701000000",
            //       "tickSize": "0.001",
            //       "markMethod": "FairPrice",
            //       "indexSymbol": ".PAPTUSDT",
            //       "markPrice": "4.418",
            //       "minRiskLimit": "1000000",
            //       "settlementFixFee": "0E-10",
            //       "settlementSymbol": '',
            //       "priceChgPctOf24h": "-0.0704",
            //       "fundingRateSymbol": ".APTUSDTPERPFPI8H",
            //       "makerFeeRate": "0.00010",
            //       "isInverse": false,
            //       "lotSize": "1",
            //       "settleCurrency": "USDT",
            //       "settlementFeeRate": "0.0"
            //     },
            //   ]
            // }
            //
            var data interface{} = this.SafeValue(response, "data", []interface{}{})
        
            ch <- this.ParseMarkets(data)
            return nil
        
            }()
            return ch
        }
func  (this *poloniexfutures) ParseMarket(market interface{}) interface{}  {
    var id interface{} = this.SafeString(market, "symbol")
    var baseId interface{} = this.SafeString(market, "baseCurrency")
    var quoteId interface{} = this.SafeString(market, "quoteCurrency")
    var settleId interface{} = this.SafeString(market, "rootSymbol")
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    var settle interface{} = this.SafeCurrencyCode(settleId)
    var symbol interface{} = Add(Add(Add(Add(base, "/"), quote), ":"), settle)
    var inverse interface{} = this.SafeValue(market, "isInverse")
    var status interface{} = this.SafeString(market, "status")
    var multiplier interface{} = this.SafeString(market, "multiplier")
    var tickSize interface{} = this.SafeNumber(market, "indexPriceTickSize")
    var lotSize interface{} = this.SafeNumber(market, "lotSize")
    var limitAmountMax interface{} = this.SafeNumber(market, "maxOrderQty")
    var limitPriceMax interface{} = this.SafeNumber(market, "maxPrice")
    return map[string]interface{} {
        "id": id,
        "symbol": symbol,
        "base": base,
        "quote": quote,
        "settle": settle,
        "baseId": baseId,
        "quoteId": quoteId,
        "settleId": settleId,
        "type": "swap",
        "spot": false,
        "margin": false,
        "swap": true,
        "future": false,
        "option": false,
        "active": (IsEqual(status, "Open")),
        "contract": true,
        "linear": !IsTrue(inverse),
        "inverse": inverse,
        "taker": this.SafeNumber(market, "takerFeeRate"),
        "maker": this.SafeNumber(market, "makerFeeRate"),
        "contractSize": this.ParseNumber(Precise.StringAbs(multiplier)),
        "expiry": nil,
        "expiryDatetime": nil,
        "strike": nil,
        "optionType": nil,
        "precision": map[string]interface{} {
            "amount": lotSize,
            "price": tickSize,
        },
        "limits": map[string]interface{} {
            "leverage": map[string]interface{} {
                "min": this.ParseNumber("1"),
                "max": this.SafeNumber(market, "maxLeverage"),
            },
            "amount": map[string]interface{} {
                "min": lotSize,
                "max": limitAmountMax,
            },
            "price": map[string]interface{} {
                "min": tickSize,
                "max": limitPriceMax,
            },
            "cost": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
        },
        "created": this.SafeInteger(market, "firstOpenDate"),
        "info": market,
    }
}
func  (this *poloniexfutures) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "symbol": "BTCUSDTPERP",                   // Market of the symbol
    //        "sequence": 45,                            // Sequence number which is used to judge the continuity of the pushed messages
    //        "side": "sell",                            // Transaction side of the last traded taker order
    //        "price": 3600.00,                          // Filled price
    //        "size": 16,                                // Filled quantity
    //        "tradeId": "5c9dcf4170744d6f5a3d32fb",     // Order ID
    //        "bestBidSize": 795,                        // Best bid size
    //        "bestBidPrice": 3200.00,                   // Best bid
    //        "bestAskPrice": 3600.00,                   // Best ask size
    //        "bestAskSize": 284,                        // Best ask
    //        "ts": 1553846081210004941                  // Filled time - nanosecond
    //    }
    //
    //    {
    //        "volume": 30449670,            //24h Volume
    //        "turnover": 845169919063,      //24h Turnover
    //        "lastPrice": 3551,           //Last price
    //        "priceChgPct": 0.0043,         //24h Change
    //        "ts": 1547697294838004923      //Snapshot time (nanosecond)
    //    }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(ticker, "symbol")
    var symbol interface{} = this.SafeSymbol(marketId, market)
    var timestampString interface{} = this.SafeString(ticker, "ts")
    var multiplier interface{} = nil
    if IsTrue(IsEqual(GetLength(timestampString), 16)) {
        // 16 digits: https://app.travis-ci.com/github/ccxt/ccxt/builds/270587157#L5454
        multiplier = 0.001
    } else if IsTrue(IsEqual(GetLength(timestampString), 17)) {
        // 17 digits: https://app.travis-ci.com/github/ccxt/ccxt/builds/269959181#L4011
        multiplier = 0.0001
    } else if IsTrue(IsEqual(GetLength(timestampString), 18)) {
        multiplier = 0.00001
    } else {
        // 19 length default
        multiplier = 0.000001
    }
    var timestamp interface{} = this.SafeIntegerProduct(ticker, "ts", multiplier)
    var last interface{} = this.SafeString2(ticker, "price", "lastPrice")
    var percentage interface{} = Precise.StringMul(this.SafeString(ticker, "priceChgPct"), "100")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": nil,
        "low": nil,
        "bid": this.SafeString(ticker, "bestBidPrice"),
        "bidVolume": this.SafeString(ticker, "bestBidSize"),
        "ask": this.SafeString(ticker, "bestAskPrice"),
        "askVolume": this.SafeString(ticker, "bestAskSize"),
        "vwap": nil,
        "open": nil,
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": nil,
        "percentage": percentage,
        "average": nil,
        "baseVolume": this.SafeString2(ticker, "size", "volume"),
        "quoteVolume": this.SafeString(ticker, "turnover"),
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name poloniexfutures#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://api-docs.poloniex.com/futures/api/ticker#get-real-time-ticker-20
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *poloniexfutures) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes395698 := (<-this.LoadMarkets())
            PanicOnError(retRes395698)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetTicker(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            // {
            //     "code": "200000",
            //     "data": {
            //       "sequence": "11574719",
            //       "symbol": "BTCUSDTPERP",
            //       "side": "sell",
            //       "size": "1",
            //       "price": "16990.1",
            //       "bestBidSize": "3",
            //       "bestBidPrice": "16990.1",
            //       "bestAskPrice": "16991.0",
            //       "tradeId": "639c8a529fd7cf0001af4157",
            //       "bestAskSize": "505",
            //       "ts": "1671203410721232337"
            //     }
            // }
            //
        ch <- this.ParseTicker(this.SafeValue(response, "data", map[string]interface{} {}), market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniexfutures#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://api-docs.poloniex.com/futures/api/ticker#get-real-time-ticker-of-all-symbols
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *poloniexfutures) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes157860 := (<-this.LoadMarkets())
            PanicOnError(retRes157860)
        
            response:= (<-this.PublicGetTickers(params))
            PanicOnError(response)
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTickers(data, symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniexfuturesfutures#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://api-docs.poloniex.com/futures/api/orderbook#get-full-order-book---level-2
 * @see https://api-docs.poloniex.com/futures/api/orderbook#get-full-order-book--level-3
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *poloniexfutures) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes522695 := (<-this.LoadMarkets())
            PanicOnError(retRes522695)
            var level interface{} = this.SafeNumber(params, "level")
            params = this.Omit(params, "level")
            if IsTrue(IsTrue(IsTrue(!IsEqual(level, nil)) && IsTrue(!IsEqual(level, 2))) && IsTrue(!IsEqual(level, 3))) {
                panic(BadRequest(Add(this.Id, " fetchOrderBook() can only return level 2 & 3")))
            }
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            var response interface{} = nil
            if IsTrue(IsEqual(level, 3)) {
                
        response = (<-this.PublicGetLevel3Snapshot(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PublicGetLevel2Snapshot(this.Extend(request, params)))
                PanicOnError(response)
            }
            // L2
            //
            // {
            //     "code": "200000",
            //     "data": {
            //     "symbol": "BTCUSDTPERP",
            //     "sequence": 1669149851334,
            //     "asks": [
            //         [
            //             16952,
            //             12
            //         ],
            //     ],
            //     "bids": [
            //         [
            //             16951.9,
            //             13
            //         ],
            //     ],
            // }
            //
            // L3
            //
            // {
            //     "code": "200000",
            //     "data": {
            //     "symbol": "BTCUSDTPERP",
            //     "sequence": 1669149851334,
            //     "asks": [
            //         [
            //             "639c95388cba5100084eabce",
            //             "16952.0",
            //             "1",
            //             1671206200542484700
            //         ],
            //     ],
            //     "bids": [
            //         [
            //             "626659d83385c200072e690b",
            //             "17.0",
            //             "1000",
            //             1650874840161291000
            //         ],
            //     ],
            // }
            //
            var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
            var timestamp interface{} = this.SafeIntegerProduct(data, "ts", 0.000001)
            var orderbook interface{} = nil
            if IsTrue(IsEqual(level, 3)) {
                orderbook = this.ParseOrderBook(data, GetValue(market, "symbol"), timestamp, "bids", "asks", 1, 2)
            } else {
                orderbook = this.ParseOrderBook(data, GetValue(market, "symbol"), timestamp, "bids", "asks", 0, 1)
            }
            AddElementToObject(orderbook, "nonce", this.SafeInteger(data, "sequence"))
        
            ch <- orderbook
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniexfutures#fetchL3OrderBook
 * @description fetches level 3 information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://api-docs.poloniex.com/futures/api/orderbook#get-full-order-book--level-3
 * @param {string} symbol unified market symbol
 * @param {int} [limit] max number of orders to return, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order book structure]{@link https://docs.ccxt.com/#/?id=order-book-structure}
 */
func  (this *poloniexfutures) FetchL3OrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes332761 := (<-this.LoadMarkets())
            PanicOnError(retRes332761)
            var market interface{} = this.Market(symbol)
        
            ch <- this.FetchOrderBook(GetValue(market, "id"), nil, map[string]interface{} {
                "level": 3,
            })
            return nil
        
            }()
            return ch
        }
func  (this *poloniexfutures) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTrades (public)
    //
    //     {
    //         "sequence": 11827985,
    //         "side": "buy",
    //         "size": 101,
    //         "price": "16864.0000000000",
    //         "takerOrderId": "639c986f0ac2470007be75ee",
    //         "makerOrderId": "639c986fa69d280007b76111",
    //         "tradeId": "639c986f9fd7cf0001afd7ee",
    //         "ts": 1671207023485924400
    //     }
    //
    // fetchMyTrades
    //
    //   {
    //       "symbol": "BTCUSDTPERP",  //Ticker symbol of the contract
    //       "tradeId": "5ce24c1f0c19fc3c58edc47c",  //Trade ID
    //       "orderId": "5ce24c16b210233c36ee321d",  // Order ID
    //       "side": "sell",  //Transaction side
    //       "liquidity": "taker",  //Liquidity- taker or maker
    //       "price": "8302",  //Filled price
    //       "size": 10,  //Filled amount
    //       "value": "0.001204529",  //Order value
    //       "feeRate": "0.0005",  //Floating fees
    //       "fixFee": "0.00000006",  //Fixed fees
    //       "feeCurrency": "XBT",  //Charging currency
    //       "stop": "",  //A mark to the stop order type
    //       "fee": "0.0000012022",  //Transaction fee
    //       "orderType": "limit",  //Order type
    //       "tradeType": "trade",  //Trade type (trade, liquidation, ADL or settlement)
    //       "createdAt": 1558334496000,  //Time the order created
    //       "settleCurrency": "XBT", //settlement currency
    //       "tradeTime": 1558334496000000000 //trade time in nanosecond
    //   }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(trade, "symbol")
    market = this.SafeMarket(marketId, market, "-")
    var id interface{} = this.SafeString(trade, "tradeId")
    var orderId interface{} = this.SafeString(trade, "orderId")
    var takerOrMaker interface{} = this.SafeString(trade, "liquidity")
    var timestamp interface{} = this.SafeInteger(trade, "ts")
    if IsTrue(!IsEqual(timestamp, nil)) {
        timestamp = this.ParseToInt(Divide(timestamp, 1000000))
    } else {
        timestamp = this.SafeInteger(trade, "createdAt")
        // if it's a historical v1 trade, the exchange returns timestamp in seconds
        if IsTrue(IsTrue((InOp(trade, "dealValue"))) && IsTrue((!IsEqual(timestamp, nil)))) {
            timestamp = Multiply(timestamp, 1000)
        }
    }
    var priceString interface{} = this.SafeString(trade, "price")
    var amountString interface{} = this.SafeString(trade, "size")
    var side interface{} = this.SafeString(trade, "side")
    var fee interface{} = nil
    var feeCostString interface{} = this.SafeString(trade, "fee")
    if IsTrue(!IsEqual(feeCostString, nil)) {
        var feeCurrencyId interface{} = this.SafeString(trade, "feeCurrency")
        var feeCurrency interface{} = this.SafeCurrencyCode(feeCurrencyId)
        if IsTrue(IsEqual(feeCurrency, nil)) {
            feeCurrency = Ternary(IsTrue((IsEqual(side, "sell"))), GetValue(market, "quote"), GetValue(market, "base"))
        }
        fee = map[string]interface{} {
            "cost": feeCostString,
            "currency": feeCurrency,
            "rate": this.SafeString(trade, "feeRate"),
        }
    }
    var typeVar interface{} = this.SafeString(trade, "orderType")
    if IsTrue(IsEqual(typeVar, "match")) {
        typeVar = nil
    }
    var costString interface{} = this.SafeString(trade, "value")
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "id": id,
        "order": orderId,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": GetValue(market, "symbol"),
        "type": typeVar,
        "takerOrMaker": takerOrMaker,
        "side": side,
        "price": priceString,
        "amount": amountString,
        "cost": costString,
        "fee": fee,
    }, market)
}
/**
 * @method
 * @name poloniexfutures#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://api-docs.poloniex.com/futures/api/historical#transaction-history
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *poloniexfutures) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes167190 := (<-this.LoadMarkets())
            PanicOnError(retRes167190)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetTradeHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "code": "200000",
            //        "data": [
            //        {
            //          "sequence": 11827985,
            //          "side": "buy",
            //          "size": 101,
            //          "price": "16864.0000000000",
            //          "takerOrderId": "639c986f0ac2470007be75ee",
            //          "makerOrderId": "639c986fa69d280007b76111",
            //          "tradeId": "639c986f9fd7cf0001afd7ee",
            //          "ts": 1671207023485924400
            //        },
            //    }
            //
            var trades interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseTrades(trades, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniexfutures#fetchTime
 * @description fetches the current integer timestamp in milliseconds from the poloniexfutures server
 * @see https://api-docs.poloniex.com/futures/api/time#server-time
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int} the current integer timestamp in milliseconds from the poloniexfutures server
 */
func  (this *poloniexfutures) FetchTime(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.PublicGetTimestamp(params))
            PanicOnError(response)
        
                //
            // {
            //     "code":"200000",
            //     "msg":"success",
            //     "data":1546837113087
            // }
            //
        ch <- this.SafeInteger(response, "data")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniexfutures#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
 * @see https://api-docs.poloniex.com/futures/api/kline#get-k-line-data-of-contract
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *poloniexfutures) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes803696 := (<-this.LoadMarkets())
            PanicOnError(retRes803696)
            var market interface{} = this.Market(symbol)
            var marketId interface{} = GetValue(market, "id")
            var parsedTimeframe interface{} = this.SafeInteger(this.Timeframes, timeframe)
            var request interface{} = map[string]interface{} {
                "symbol": marketId,
            }
            if IsTrue(!IsEqual(parsedTimeframe, nil)) {
                AddElementToObject(request, "granularity", parsedTimeframe)
            } else {
                AddElementToObject(request, "granularity", timeframe)
            }
            var duration interface{} = Multiply(this.ParseTimeframe(timeframe), 1000)
            var endAt interface{} = this.Milliseconds()
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "from", since)
                if IsTrue(IsEqual(limit, nil)) {
                    limit = this.SafeInteger(this.Options, "fetchOHLCVLimit", 200)
                }
                endAt = this.Sum(since, Multiply(limit, duration))
                AddElementToObject(request, "to", endAt)
            } else if IsTrue(!IsEqual(limit, nil)) {
                since = Subtract(endAt, Multiply(limit, duration))
                AddElementToObject(request, "from", since)
            }
        
            response:= (<-this.PublicGetKlineQuery(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "code": "200000",
            //        "data": [
            //            [1636459200000, 4779.3, 4792.1, 4768.7, 4770.3, 78051],
            //            [1636460100000, 4770.25, 4778.55, 4757.55, 4777.25, 80164],
            //            [1636461000000, 4777.25, 4791.45, 4774.5, 4791.3, 51555]
            //        ]
            //    }
            //
            var data interface{} = this.SafeList(response, "data", []interface{}{})
        
            ch <- this.ParseOHLCVs(data, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *poloniexfutures) ParseBalance(response interface{}) interface{}  {
    var result interface{} = map[string]interface{} {
        "info": response,
        "timestamp": nil,
        "datetime": nil,
    }
    var data interface{} = this.SafeValue(response, "data")
    var currencyId interface{} = this.SafeString(data, "currency")
    var code interface{} = this.SafeCurrencyCode(currencyId)
    var account interface{} = this.Account()
    AddElementToObject(account, "free", this.SafeString(data, "availableBalance"))
    AddElementToObject(account, "total", this.SafeString(data, "accountEquity"))
    AddElementToObject(result, code, account)
    return this.SafeBalance(result)
}
/**
 * @method
 * @name poloniexfutures#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://api-docs.poloniex.com/futures/api/account#get-account-overview
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *poloniexfutures) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes373536 := (<-this.LoadMarkets())
            PanicOnError(retRes373536)
            var currencyId interface{} = this.SafeString(params, "currency")
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(currencyId, nil)) {
                var currency interface{} = this.Currency(currencyId)
                request = map[string]interface{} {
                    "currency": GetValue(currency, "id"),
                }
            }
        
            response:= (<-this.PrivateGetAccountOverview(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "code": "200000",
            //         "data": {
            //             "accountEquity": 0.00005,
            //             "unrealisedPNL": 0,
            //             "marginBalance": 0.00005,
            //             "positionMargin": 0,
            //             "orderMargin": 0,
            //             "frozenFunds": 0,
            //             "availableBalance": 0.00005,
            //             "currency": "XBT"
            //         }
            //     }
            //
        ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniexfutures#createOrder
 * @description Create an order on the exchange
 * @see https://api-docs.poloniex.com/futures/api/orders#place-an-order
 * @param {string} symbol Unified CCXT market symbol
 * @param {string} type 'limit' or 'market'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount the amount of currency to trade
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params]  extra parameters specific to the exchange API endpoint
 * @param {float} [params.leverage] Leverage size of the order
 * @param {float} [params.triggerPrice] The price at which a trigger order is triggered at
 * @param {bool} [params.reduceOnly] A mark to reduce the position size only. Set to false by default. Need to set the position size when reduceOnly is true.
 * @param {string} [params.timeInForce] GTC, GTT, IOC, or FOK, default is GTC, limit orders only
 * @param {string} [params.postOnly] Post only flag, invalid when timeInForce is IOC or FOK
 * @param {string} [params.clientOid] client order id, defaults to uuid if not passed
 * @param {string} [params.remark] remark for the order, length cannot exceed 100 utf8 characters
 * @param {string} [params.stop] 'up' or 'down', defaults to 'up' if side is sell and 'down' if side is buy, requires stopPrice
 * @param {string} [params.stopPriceType]  TP, IP or MP, defaults to TP
 * @param {bool} [params.closeOrder] set to true to close position
 * @param {bool} [params.forceHold] A mark to forcely hold the funds for an order, even though it's an order to reduce the position size. This helps the order stay on the order book and not get canceled when the position size changes. Set to false by default.
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *poloniexfutures) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes312646 := (<-this.LoadMarkets())
            PanicOnError(retRes312646)
            var market interface{} = this.Market(symbol)
            // required param, cannot be used twice
            var clientOrderId interface{} = this.SafeString2(params, "clientOid", "clientOrderId", this.Uuid())
            params = this.Omit(params, []interface{}{"clientOid", "clientOrderId"})
            if IsTrue(IsLessThan(amount, 1)) {
                panic(InvalidOrder(Add(this.Id, " createOrder() minimum contract order amount is 1")))
            }
            preciseAmount := ParseInt(this.AmountToPrecision(symbol, amount))
            var request interface{} = map[string]interface{} {
                "clientOid": clientOrderId,
                "side": side,
                "symbol": GetValue(market, "id"),
                "type": typeVar,
                "size": preciseAmount,
                "leverage": 1,
            }
            var triggerPrice interface{} = this.SafeValue2(params, "triggerPrice", "stopPrice")
            if IsTrue(triggerPrice) {
                AddElementToObject(request, "stop", Ternary(IsTrue((IsEqual(side, "buy"))), "up", "down"))
                var stopPriceType interface{} = this.SafeString(params, "stopPriceType", "TP")
                AddElementToObject(request, "stopPriceType", stopPriceType)
                AddElementToObject(request, "stopPrice", this.PriceToPrecision(symbol, triggerPrice))
            }
            var timeInForce interface{} = this.SafeStringUpper(params, "timeInForce")
            if IsTrue(IsEqual(typeVar, "limit")) {
                if IsTrue(IsEqual(price, nil)) {
                    panic(ArgumentsRequired(Add(this.Id, " createOrder() requires a price argument for limit orders")))
                } else {
                    AddElementToObject(request, "price", this.PriceToPrecision(symbol, price))
                }
                if IsTrue(!IsEqual(timeInForce, nil)) {
                    AddElementToObject(request, "timeInForce", timeInForce)
                }
            }
            var postOnly interface{} = this.SafeBool(params, "postOnly", false)
            var hidden interface{} = this.SafeValue(params, "hidden")
            if IsTrue(IsTrue(postOnly) && IsTrue((!IsEqual(hidden, nil)))) {
                panic(BadRequest(Add(this.Id, " createOrder() does not support the postOnly parameter together with a hidden parameter")))
            }
            var iceberg interface{} = this.SafeValue(params, "iceberg")
            if IsTrue(iceberg) {
                var visibleSize interface{} = this.SafeValue(params, "visibleSize")
                if IsTrue(IsEqual(visibleSize, nil)) {
                    panic(ArgumentsRequired(Add(this.Id, " createOrder() requires a visibleSize parameter for iceberg orders")))
                }
            }
            params = this.Omit(params, []interface{}{"timeInForce", "stopPrice", "triggerPrice"}) // Time in force only valid for limit orders, exchange error when gtc for market orders
        
            response:= (<-this.PrivatePostOrders(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "code": "200000",
            //        "data": {
            //            "orderId": "619717484f1d010001510cde",
            //        },
            //    }
            //
            var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
        
            ch <- this.SafeOrder(map[string]interface{} {
                "id": this.SafeString(data, "orderId"),
                "clientOrderId": nil,
                "timestamp": nil,
                "datetime": nil,
                "lastTradeTimestamp": nil,
                "symbol": nil,
                "type": nil,
                "side": nil,
                "price": nil,
                "amount": nil,
                "cost": nil,
                "average": nil,
                "filled": nil,
                "remaining": nil,
                "status": nil,
                "fee": nil,
                "trades": nil,
                "timeInForce": nil,
                "postOnly": nil,
                "triggerPrice": nil,
                "info": response,
            }, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniexfutures#cancelOrder
 * @description cancels an open order
 * @see https://api-docs.poloniex.com/futures/api/orders#cancel-an-order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *poloniexfutures) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes335572 := (<-this.LoadMarkets())
            PanicOnError(retRes335572)
            var request interface{} = map[string]interface{} {
                "order-id": id,
            }
        
            response:= (<-this.PrivateDeleteOrdersOrderId(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "code": "200000",
            //        "data": {
            //            "cancelledOrderIds": [
            //                "619714b8b6353000014c505a",
            //            ],
            //            "cancelFailedOrders": [
            //                {
            //                    "orderId": "63a9c5c2b9e7d70007eb0cd5",
            //                    "orderState": "2"
            //                }
            //            ],
            //        },
            //    }
            //
            var data interface{} = this.SafeValue(response, "data")
            var cancelledOrderIds interface{} = this.SafeValue(data, "cancelledOrderIds")
            var cancelledOrderIdsLength interface{} =     GetArrayLength(cancelledOrderIds)
            if IsTrue(IsEqual(cancelledOrderIdsLength, 0)) {
                panic(InvalidOrder(Add(this.Id, " cancelOrder() order already cancelled")))
            }
        
            ch <- this.ParseOrder(data)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniexfutures#fetchPositions
 * @description fetch all open positions
 * @see https://api-docs.poloniex.com/futures/api/positions#get-position-list
 * @param {string[]|undefined} symbols list of unified market symbols
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
 */
func  (this *poloniexfutures) FetchPositions(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes384638 := (<-this.LoadMarkets())
            PanicOnError(retRes384638)
        
            response:= (<-this.PrivateGetPositions(params))
            PanicOnError(response)
            //
            //    {
            //        "code": "200000",
            //        "data": [
            //            {
            //                "id": "615ba79f83a3410001cde321",
            //                "symbol": "ETHUSDTM",
            //                "autoDeposit": false,
            //                "maintMarginReq": 0.005,
            //                "riskLimit": 1000000,
            //                "realLeverage": 18.61,
            //                "crossMode": false,
            //                "delevPercentage": 0.86,
            //                "openingTimestamp": 1638563515618,
            //                "currentTimestamp": 1638576872774,
            //                "currentQty": 2,
            //                "currentCost": 83.64200000,
            //                "currentComm": 0.05018520,
            //                "unrealisedCost": 83.64200000,
            //                "realisedGrossCost": 0.00000000,
            //                "realisedCost": 0.05018520,
            //                "isOpen": true,
            //                "markPrice": 4225.01,
            //                "markValue": 84.50020000,
            //                "posCost": 83.64200000,
            //                "posCross": 0.0000000000,
            //                "posInit": 3.63660870,
            //                "posComm": 0.05236717,
            //                "posLoss": 0.00000000,
            //                "posMargin": 3.68897586,
            //                "posMaint": 0.50637594,
            //                "maintMargin": 4.54717586,
            //                "realisedGrossPnl": 0.00000000,
            //                "realisedPnl": -0.05018520,
            //                "unrealisedPnl": 0.85820000,
            //                "unrealisedPnlPcnt": 0.0103,
            //                "unrealisedRoePcnt": 0.2360,
            //                "avgEntryPrice": 4182.10,
            //                "liquidationPrice": 4023.00,
            //                "bankruptPrice": 4000.25,
            //                "settleCurrency": "USDT",
            //                "isInverse": false
            //            }
            //        ]
            //    }
            //
            var data interface{} = this.SafeList(response, "data")
        
            ch <- this.ParsePositions(data, symbols)
            return nil
        
            }()
            return ch
        }
func  (this *poloniexfutures) ParsePosition(position interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //    {
    //        "code": "200000",
    //        "data": [
    //            {
    //                "id": "615ba79f83a3410001cde321",         // Position ID
    //                "symbol": "ETHUSDTM",                     // Symbol
    //                "autoDeposit": false,                     // Auto deposit margin or not
    //                "maintMarginReq": 0.005,                  // Maintenance margin requirement
    //                "riskLimit": 1000000,                     // Risk limit
    //                "realLeverage": 25.92,                    // Leverage of the order
    //                "crossMode": false,                       // Cross mode or not
    //                "delevPercentage": 0.76,                  // ADL ranking percentile
    //                "openingTimestamp": 1638578546031,        // Open time
    //                "currentTimestamp": 1638578563580,        // Current timestamp
    //                "currentQty": 2,                          // Current postion quantity
    //                "currentCost": 83.787,                    // Current postion value
    //                "currentComm": 0.0167574,                 // Current commission
    //                "unrealisedCost": 83.787,                 // Unrealised value
    //                "realisedGrossCost": 0.0,                 // Accumulated realised gross profit value
    //                "realisedCost": 0.0167574,                // Current realised position value
    //                "isOpen": true,                           // Opened position or not
    //                "markPrice": 4183.38,                     // Mark price
    //                "markValue": 83.6676,                     // Mark value
    //                "posCost": 83.787,                        // Position value
    //                "posCross": 0.0,                          // added margin
    //                "posInit": 3.35148,                       // Leverage margin
    //                "posComm": 0.05228309,                    // Bankruptcy cost
    //                "posLoss": 0.0,                           // Funding fees paid out
    //                "posMargin": 3.40376309,                  // Position margin
    //                "posMaint": 0.50707892,                   // Maintenance margin
    //                "maintMargin": 3.28436309,                // Position margin
    //                "realisedGrossPnl": 0.0,                  // Accumulated realised gross profit value
    //                "realisedPnl": -0.0167574,                // Realised profit and loss
    //                "unrealisedPnl": -0.1194,                 // Unrealised profit and loss
    //                "unrealisedPnlPcnt": -0.0014,             // Profit-loss ratio of the position
    //                "unrealisedRoePcnt": -0.0356,             // Rate of return on investment
    //                "avgEntryPrice": 4189.35,                 // Average entry price
    //                "liquidationPrice": 4044.55,              // Liquidation price
    //                "bankruptPrice": 4021.75,                 // Bankruptcy price
    //                "settleCurrency": "USDT",                 // Currency used to clear and settle the trades
    //                "isInverse": false
    //            }
    //        ]
    //    }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var symbol interface{} = this.SafeString(position, "symbol")
    market = this.SafeMarket(symbol, market)
    var timestamp interface{} = this.SafeInteger(position, "currentTimestamp")
    var size interface{} = this.SafeString(position, "currentQty")
    var side interface{} = nil
    if IsTrue(Precise.StringGt(size, "0")) {
        side = "long"
    } else if IsTrue(Precise.StringLt(size, "0")) {
        side = "short"
    }
    var notional interface{} = Precise.StringAbs(this.SafeString(position, "posCost"))
    var initialMargin interface{} = this.SafeString(position, "posInit")
    var initialMarginPercentage interface{} = Precise.StringDiv(initialMargin, notional)
    // const marginRatio = Precise.stringDiv (maintenanceRate, collateral);
    var unrealisedPnl interface{} = this.SafeString(position, "unrealisedPnl")
    var crossMode interface{} = this.SafeValue(position, "crossMode")
    // currently crossMode is always set to false and only isolated positions are supported
    var marginMode interface{} = Ternary(IsTrue(crossMode), "cross", "isolated")
    return map[string]interface{} {
        "info": position,
        "id": nil,
        "symbol": this.SafeString(market, "symbol"),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "initialMargin": this.ParseNumber(initialMargin),
        "initialMarginPercentage": this.ParseNumber(initialMarginPercentage),
        "maintenanceMargin": this.SafeNumber(position, "posMaint"),
        "maintenanceMarginPercentage": this.SafeNumber(position, "maintMarginReq"),
        "entryPrice": this.SafeNumber(position, "avgEntryPrice"),
        "notional": this.ParseNumber(notional),
        "leverage": this.SafeNumber(position, "realLeverage"),
        "unrealizedPnl": this.ParseNumber(unrealisedPnl),
        "contracts": this.ParseNumber(Precise.StringAbs(size)),
        "contractSize": this.SafeValue(market, "contractSize"),
        "marginRatio": nil,
        "liquidationPrice": this.SafeNumber(position, "liquidationPrice"),
        "markPrice": this.SafeNumber(position, "markPrice"),
        "collateral": this.SafeNumber(position, "maintMargin"),
        "marginMode": marginMode,
        "side": side,
        "percentage": this.ParseNumber(Precise.StringDiv(unrealisedPnl, initialMargin)),
        "stopLossPrice": nil,
        "takeProfitPrice": nil,
    }
}
/**
 * @method
 * @name poloniexfutures#fetchFundingHistory
 * @description fetch the history of funding payments paid and received on this account
 * @see https://api-docs.poloniex.com/futures/api/funding-fees#get-funding-history
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch funding history for
 * @param {int} [limit] the maximum number of funding history structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding history structure]{@link https://docs.ccxt.com/#/?id=funding-history-structure}
 */
func  (this *poloniexfutures) FetchFundingHistory(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchFundingHistory() requires a symbol argument")))
            }
        
            retRes362507 := (<-this.LoadMarkets())
            PanicOnError(retRes362507)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startAt", since)
            }
            if IsTrue(!IsEqual(limit, nil)) {
                // * Since is ignored if limit is defined
                AddElementToObject(request, "maxCount", limit)
            }
        
            response:= (<-this.PrivateGetFundingHistory(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "code": "200000",
            //        "data": {
            //            "dataList": [
            //                {
            //                    "id": 239471298749817,
            //                    "symbol": "ETHUSDTM",
            //                    "timePoint": 1638532800000,
            //                    "fundingRate": 0.000100,
            //                    "markPrice": 4612.8300000000,
            //                    "positionQty": 12,
            //                    "positionCost": 553.5396000000,
            //                    "funding": -0.0553539600,
            //                    "settleCurrency": "USDT"
            //                },
            //                ...
            //            ],
            //            "hasMore": true
            //        }
            //    }
            //
            var data interface{} = this.SafeValue(response, "data")
            var dataList interface{} = this.SafeValue(data, "dataList", []interface{}{})
            var dataListLength interface{} =     GetArrayLength(dataList)
            var fees interface{} = []interface{}{}
            for i := 0; IsLessThan(i, dataListLength); i++ {
                var listItem interface{} = GetValue(dataList, i)
                var timestamp interface{} = this.SafeInteger(listItem, "timePoint")
                AppendToArray(&fees,map[string]interface{} {
                    "info": listItem,
                    "symbol": symbol,
                    "code": this.SafeCurrencyCode(this.SafeString(listItem, "settleCurrency")),
                    "timestamp": timestamp,
                    "datetime": this.Iso8601(timestamp),
                    "id": this.SafeNumber(listItem, "id"),
                    "amount": this.SafeNumber(listItem, "funding"),
                    "fundingRate": this.SafeNumber(listItem, "fundingRate"),
                    "markPrice": this.SafeNumber(listItem, "markPrice"),
                    "positionQty": this.SafeNumber(listItem, "positionQty"),
                    "positionCost": this.SafeNumber(listItem, "positionCost"),
                })
            }
        
            ch <- fees
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniexfutures#cancelAllOrders
 * @description cancel all open orders
 * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {object} [params.trigger] When true, all the trigger orders will be cancelled
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *poloniexfutures) CancelAllOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes871802 := (<-this.LoadMarkets())
            PanicOnError(retRes871802)
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbol, nil)) {
                AddElementToObject(request, "symbol", this.MarketId(symbol))
            }
            var trigger interface{} = this.SafeValue2(params, "stop", "trigger")
            params = this.Omit(params, []interface{}{"stop", "trigger"})
            var response interface{} = nil
            if IsTrue(trigger) {
                
        response = (<-this.PrivateDeleteStopOrders(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PrivateDeleteOrders(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            //   {
            //       "code": "200000",
            //       "data": {
            //           "cancelledOrderIds": [
            //                "619714b8b6353000014c505a",
            //           ],
            //       },
            //   }
            //
            var data interface{} = this.SafeValue(response, "data")
            var result interface{} = []interface{}{}
            var cancelledOrderIds interface{} = this.SafeValue(data, "cancelledOrderIds")
            var cancelledOrderIdsLength interface{} =     GetArrayLength(cancelledOrderIds)
            for i := 0; IsLessThan(i, cancelledOrderIdsLength); i++ {
                var cancelledOrderId interface{} = this.SafeString(cancelledOrderIds, i)
                AppendToArray(&result,this.SafeOrder(map[string]interface{} {
                    "id": cancelledOrderId,
                    "clientOrderId": nil,
                    "timestamp": nil,
                    "datetime": nil,
                    "lastTradeTimestamp": nil,
                    "symbol": nil,
                    "type": nil,
                    "side": nil,
                    "price": nil,
                    "amount": nil,
                    "cost": nil,
                    "average": nil,
                    "filled": nil,
                    "remaining": nil,
                    "status": nil,
                    "fee": nil,
                    "trades": nil,
                    "timeInForce": nil,
                    "postOnly": nil,
                    "triggerPrice": nil,
                    "info": response,
                }))
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniexfutures#fetchOrdersByStatus
 * @description fetches a list of orders placed on the exchange
 * @see https://api-docs.poloniex.com/futures/api/orders#get-order-listdeprecated
 * @see https://api-docs.poloniex.com/futures/api/orders#get-untriggered-stop-order-list
 * @param {string} status 'active' or 'closed', only 'active' is valid for stop orders
 * @param {string} symbol unified symbol for the market to retrieve orders from
 * @param {int} [since] timestamp in ms of the earliest order to retrieve
 * @param {int} [limit] The maximum number of orders to retrieve
 * @param {object} [params] exchange specific parameters
 * @param {bool} [params.stop] set to true to retrieve untriggered stop orders
 * @param {int} [params.until] End time in ms
 * @param {string} [params.side] buy or sell
 * @param {string} [params.type] limit or market
 * @returns An [array of order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *poloniexfutures) FetchOrdersByStatus(status interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes898912 := (<-this.LoadMarkets())
            PanicOnError(retRes898912)
            var trigger interface{} = this.SafeValue2(params, "stop", "trigger")
            var until interface{} = this.SafeInteger(params, "until")
            params = this.Omit(params, []interface{}{"trigger", "stop", "until"})
            if IsTrue(IsEqual(status, "closed")) {
                status = "done"
            }
            var request interface{} = map[string]interface{} {}
            if !IsTrue(trigger) {
                AddElementToObject(request, "status", Ternary(IsTrue((IsEqual(status, "open"))), "active", "done"))
            } else if IsTrue(!IsEqual(status, "open")) {
                panic(BadRequest(Add(this.Id, " fetchOrdersByStatus() can only fetch untriggered stop orders")))
            }
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startAt", since)
            }
            if IsTrue(!IsEqual(until, nil)) {
                AddElementToObject(request, "endAt", until)
            }
            var response interface{} = nil
            if IsTrue(trigger) {
                
        response = (<-this.PrivateGetStopOrders(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.PrivateGetOrders(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            //    {
            //        "code": "200000",
            //        "data": {
            //            "totalNum": 1,
            //            "totalPage": 1,
            //            "pageSize": 50,
            //            "currentPage": 1,
            //            "items": [
            //                {
            //                    "symbol": "ADAUSDTPERP",
            //                    "leverage": "1",
            //                    "hidden": false,
            //                    "forceHold": false,
            //                    "closeOrder": false,
            //                    "type": "limit",
            //                    "isActive": true,
            //                    "createdAt": 1678936920000,
            //                    "orderTime": 1678936920480905922,
            //                    "price": "0.3",
            //                    "iceberg": false,
            //                    "stopTriggered": false,
            //                    "id": "64128b582cc0710007a3c840",
            //                    "value": "3",
            //                    "timeInForce": "GTC",
            //                    "updatedAt": 1678936920000,
            //                    "side": "buy",
            //                    "stopPriceType": "",
            //                    "dealValue": "0",
            //                    "dealSize": 0,
            //                    "settleCurrency": "USDT",
            //                    "stp": "",
            //                    "filledValue": "0",
            //                    "postOnly": false,
            //                    "size": 1,
            //                    "stop": "",
            //                    "filledSize": 0,
            //                    "reduceOnly": false,
            //                    "marginType": 1,
            //                    "cancelExist": false,
            //                    "clientOid": "ba669f39-dfcc-4664-9801-a42d06e59c2e",
            //                    "status": "open"
            //                }
            //            ]
            //        }
            //    }
            //
            var responseData interface{} = this.SafeValue(response, "data", map[string]interface{} {})
            var orders interface{} = this.SafeValue(responseData, "items", []interface{}{})
            var ordersLength interface{} =     GetArrayLength(orders)
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, ordersLength); i++ {
                var order interface{} = GetValue(orders, i)
                var orderStatus interface{} = this.SafeString(order, "status")
                if IsTrue(IsEqual(status, orderStatus)) {
                    AppendToArray(&result,GetValue(orders, i))
                }
            }
        
            ch <- this.ParseOrders(result, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniexfutures#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @see https://api-docs.poloniex.com/futures/api/orders#get-order-listdeprecated
 * @see https://api-docs.poloniex.com/futures/api/orders#get-untriggered-stop-order-list
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] end time in ms
 * @param {string} [params.side] buy or sell
 * @param {string} [params.type] limit, or market
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *poloniexfutures) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
                retRes748830 :=  (<-this.FetchOrdersByStatus("open", symbol, since, limit, params))
                PanicOnError(retRes748830)
                ch <- retRes748830
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniexfutures#fetchClosedOrders
 * @description fetches information on multiple closed orders made by the user
 * @see https://api-docs.poloniex.com/futures/api/orders#get-order-listdeprecated
 * @see https://api-docs.poloniex.com/futures/api/orders#get-untriggered-stop-order-list
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int} [since] the earliest time in ms to fetch orders for
 * @param {int} [limit] the maximum number of order structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {int} [params.until] end time in ms
 * @param {string} [params.side] buy or sell
 * @param {string} [params.type] limit, or market
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *poloniexfutures) FetchClosedOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
                retRes765398 :=  (<-this.FetchOrdersByStatus("closed", symbol, since, limit, params))
                PanicOnError(retRes765398)
                ch <- retRes765398
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniexfutures#fetchOrder
 * @description fetches information on an order made by the user
 * @see https://api-docs.poloniex.com/futures/api/orders#get-details-of-a-single-order
 * @see https://api-docs.poloniex.com/futures/api/orders#get-single-order-by-clientoid
 * @param {string} id the order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *poloniexfutures) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes433028 := (<-this.LoadMarkets())
            PanicOnError(retRes433028)
            var request interface{} = map[string]interface{} {}
            var response interface{} = nil
            if IsTrue(IsEqual(id, nil)) {
                var clientOrderId interface{} = this.SafeString2(params, "clientOid", "clientOrderId")
                if IsTrue(IsEqual(clientOrderId, nil)) {
                    panic(InvalidOrder(Add(this.Id, " fetchOrder() requires parameter id or params.clientOid")))
                }
                AddElementToObject(request, "clientOid", clientOrderId)
                params = this.Omit(params, []interface{}{"clientOid", "clientOrderId"})
                
        response = (<-this.PrivateGetClientOrderIdClientOid(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                AddElementToObject(request, "order-id", id)
                
        response = (<-this.PrivateGetOrdersOrderId(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            //    {
            //        "code": "200000",
            //        "data": {
            //            "symbol": "ADAUSDTPERP",
            //            "leverage": "1",
            //            "hidden": false,
            //            "forceHold": false,
            //            "closeOrder": false,
            //            "type": "market",
            //            "isActive": false,
            //            "createdAt": 1678929587000,
            //            "orderTime": 1678929587248115582,
            //            "iceberg": false,
            //            "stopTriggered": false,
            //            "id": "64126eb38c6919000737dcdc",
            //            "value": "3.1783",
            //            "timeInForce": "GTC",
            //            "updatedAt": 1678929587000,
            //            "side": "buy",
            //            "stopPriceType": "",
            //            "dealValue": "3.1783",
            //            "dealSize": 1,
            //            "settleCurrency": "USDT",
            //            "trades": [
            //                {
            //                    "feePay": "0.00158915",
            //                    "tradeId": "64126eb36803eb0001ff99bc"
            //                }
            //            ],
            //            "endAt": 1678929587000,
            //            "stp": "",
            //            "filledValue": "3.1783",
            //            "postOnly": false,
            //            "size": 1,
            //            "stop": "",
            //            "filledSize": 1,
            //            "reduceOnly": false,
            //            "marginType": 1,
            //            "cancelExist": false,
            //            "clientOid": "d19e8fcb-2df4-44bc-afd4-67dd42048246",
            //            "status": "done"
            //        }
            //    }
            //
            var market interface{} = Ternary(IsTrue((!IsEqual(symbol, nil))), this.Market(symbol), nil)
            var responseData interface{} = this.SafeDict(response, "data")
        
            ch <- this.ParseOrder(responseData, market)
            return nil
        
            }()
            return ch
        }
func  (this *poloniexfutures) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // createOrder
    //
    //    {
    //        "code": "200000",
    //        "data": {
    //            "orderId": "619717484f1d010001510cde",
    //        },
    //    }
    //
    // fetchOrder
    //
    //    {
    //        "symbol": "ADAUSDTPERP",
    //        "leverage": "1",
    //        "hidden": false,
    //        "forceHold": false,
    //        "closeOrder": false,
    //        "type": "market",
    //        "isActive": false,
    //        "createdAt": 1678929587000,
    //        "orderTime": 1678929587248115582,
    //        "iceberg": false,
    //        "stopTriggered": false,
    //        "id": "64126eb38c6919000737dcdc",
    //        "value": "3.1783",
    //        "timeInForce": "GTC",
    //        "updatedAt": 1678929587000,
    //        "side": "buy",
    //        "stopPriceType": "",
    //        "dealValue": "3.1783",
    //        "dealSize": 1,
    //        "settleCurrency": "USDT",
    //        "trades": [
    //            {
    //                "feePay": "0.00158915",
    //                "tradeId": "64126eb36803eb0001ff99bc"
    //            }
    //        ],
    //        "endAt": 1678929587000,
    //        "stp": "",
    //        "filledValue": "3.1783",
    //        "postOnly": false,
    //        "size": 1,
    //        "stop": "",
    //        "filledSize": 1,
    //        "reduceOnly": false,
    //        "marginType": 1,
    //        "cancelExist": false,
    //        "clientOid": "d19e8fcb-2df4-44bc-afd4-67dd42048246",
    //        "status": "done"
    //    }
    //
    // cancelOrder
    //
    //    {
    //        "cancelledOrderIds": [
    //            "619714b8b6353000014c505a",
    //        ],
    //        "cancelFailedOrders": [
    //            {
    //                "orderId": "63a9c5c2b9e7d70007eb0cd5",
    //                "orderState": "2"
    //            }
    //        ],
    //    },
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var marketId interface{} = this.SafeString(order, "symbol")
    market = this.SafeMarket(marketId, market)
    var timestamp interface{} = this.SafeInteger(order, "createdAt")
    // price is zero for market order
    // omitZero is called in safeOrder2
    var feeCurrencyId interface{} = this.SafeString(order, "feeCurrency")
    var filled interface{} = this.SafeString(order, "dealSize")
    var rawCost interface{} = this.SafeString2(order, "dealFunds", "filledValue")
    var average interface{} = nil
    if IsTrue(Precise.StringGt(filled, "0")) {
        var contractSize interface{} = this.SafeString(market, "contractSize")
        if IsTrue(GetValue(market, "linear")) {
            average = Precise.StringDiv(rawCost, Precise.StringMul(contractSize, filled))
        } else {
            average = Precise.StringDiv(Precise.StringMul(contractSize, filled), rawCost)
        }
    }
    // precision reported by their api is 8 d.p.
    // const average = Precise.stringDiv (rawCost, Precise.stringMul (filled, market['contractSize']));
    // bool
    var isActive interface{} = this.SafeBool(order, "isActive", false)
    var cancelExist interface{} = this.SafeBool(order, "cancelExist", false)
    var status interface{} = Ternary(IsTrue(isActive), "open", "closed")
    var id interface{} = this.SafeString(order, "id")
    if IsTrue(InOp(order, "cancelledOrderIds")) {
        var cancelledOrderIds interface{} = this.SafeValue(order, "cancelledOrderIds")
        id = this.SafeString(cancelledOrderIds, 0)
    }
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": id,
        "clientOrderId": this.SafeString(order, "clientOid"),
        "symbol": this.SafeString(market, "symbol"),
        "type": this.SafeString(order, "type"),
        "timeInForce": this.SafeString(order, "timeInForce"),
        "postOnly": this.SafeValue(order, "postOnly"),
        "side": this.SafeString(order, "side"),
        "amount": this.SafeString(order, "size"),
        "price": this.SafeString(order, "price"),
        "triggerPrice": this.SafeString(order, "stopPrice"),
        "cost": this.SafeString(order, "dealValue"),
        "filled": filled,
        "remaining": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "fee": map[string]interface{} {
            "currency": this.SafeCurrencyCode(feeCurrencyId),
            "cost": this.SafeString(order, "fee"),
        },
        "status": Ternary(IsTrue(cancelExist), "canceled", status),
        "lastTradeTimestamp": nil,
        "average": average,
        "trades": nil,
    }, market)
}
/**
 * @method
 * @name poloniexfutures#fetchFundingRate
 * @description fetch the current funding rate
 * @see https://api-docs.poloniex.com/futures/api/futures-index#get-premium-index
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
 */
func  (this *poloniexfutures) FetchFundingRate(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes845771 := (<-this.LoadMarkets())
            PanicOnError(retRes845771)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetFundingRateSymbolCurrent(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "symbol": ".BTCUSDTPERPFPI8H",
            //        "granularity": 28800000,
            //        "timePoint": 1558000800000,
            //        "value": 0.00375,
            //        "predictedValue": 0.00375
            //    }
            //
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseFundingRate(data, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniexfutures#fetchFundingInterval
 * @description fetch the current funding rate interval
 * @see https://api-docs.poloniex.com/futures/api/futures-index#get-premium-index
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
 */
func  (this *poloniexfutures) FetchFundingInterval(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
                retRes170110 :=  (<-this.FetchFundingRate(symbol, params))
                PanicOnError(retRes170110)
                ch <- retRes170110
                return nil
        
            }()
            return ch
        }
func  (this *poloniexfutures) ParseFundingRate(data interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "symbol": ".ETHUSDTMFPI8H",
    //         "granularity": 28800000,
    //         "timePoint": 1637380800000,
    //         "value": 0.0001,
    //         "predictedValue": 0.0001,
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var fundingTimestamp interface{} = this.SafeInteger(data, "timePoint")
    var marketId interface{} = this.SafeString(data, "symbol")
    return map[string]interface{} {
        "info": data,
        "symbol": this.SafeSymbol(marketId, market, nil, "contract"),
        "markPrice": nil,
        "indexPrice": nil,
        "interestRate": nil,
        "estimatedSettlePrice": nil,
        "timestamp": nil,
        "datetime": nil,
        "fundingRate": this.SafeNumber(data, "value"),
        "fundingTimestamp": fundingTimestamp,
        "fundingDatetime": this.Iso8601(fundingTimestamp),
        "nextFundingRate": this.SafeNumber(data, "predictedValue"),
        "nextFundingTimestamp": nil,
        "nextFundingDatetime": nil,
        "previousFundingRate": nil,
        "previousFundingTimestamp": nil,
        "previousFundingDatetime": nil,
        "interval": this.ParseFundingInterval(this.SafeString(data, "granularity")),
    }
}
func  (this *poloniexfutures) ParseFundingInterval(interval interface{}) interface{}  {
    var intervals interface{} = map[string]interface{} {
        "3600000": "1h",
        "14400000": "4h",
        "28800000": "8h",
        "57600000": "16h",
        "86400000": "24h",
    }
    return this.SafeString(intervals, interval, interval)
}
/**
 * @method
 * @name poloniexfutures#fetchMyTrades
 * @description fetch all trades made by the user
 * @see https://api-docs.poloniex.com/futures/api/fills#get-fillsdeprecated
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @param {string} [params.orderIdFills] filles for a specific order (other parameters can be ignored if specified)
 * @param {string} [params.side] buy or sell
 * @param {string} [params.type]  limit, market, limit_stop or market_stop
 * @param {int} [params.endAt] end time (milisecond)
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *poloniexfutures) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes23006 := (<-this.LoadMarkets())
            PanicOnError(retRes23006)
            var request interface{} = map[string]interface{} {}
            var market interface{} = nil
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                AddElementToObject(request, "symbol", GetValue(market, "id"))
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "startAt", since)
            }
        
            response:= (<-this.PrivateGetFills(this.Extend(request, params)))
            PanicOnError(response)
            //
            //    {
            //        "code": "200000",
            //        "data": {
            //          "currentPage":1,
            //          "pageSize":1,
            //          "totalNum":251915,
            //          "totalPage":251915,
            //          "items":[
            //              {
            //                "symbol": "BTCUSDTPERP",  //Ticker symbol of the contract
            //                "tradeId": "5ce24c1f0c19fc3c58edc47c",  //Trade ID
            //                "orderId": "5ce24c16b210233c36ee321d",  // Order ID
            //                "side": "sell",  //Transaction side
            //                "liquidity": "taker",  //Liquidity- taker or maker
            //                "price": "8302",  //Filled price
            //                "size": 10,  //Filled amount
            //                "value": "0.001204529",  //Order value
            //                "feeRate": "0.0005",  //Floating fees
            //                "fixFee": "0.00000006",  //Fixed fees
            //                "feeCurrency": "XBT",  //Charging currency
            //                "stop": "",  //A mark to the stop order type
            //                "fee": "0.0000012022",  //Transaction fee
            //                "orderType": "limit",  //Order type
            //                "tradeType": "trade",  //Trade type (trade, liquidation, ADL or settlement)
            //                "createdAt": 1558334496000,  //Time the order created
            //                "settleCurrency": "XBT", //settlement currency
            //                "tradeTime": 1558334496000000000 //trade time in nanosecond
            //              }
            //          ]
            //        }
            //    }
            //
            var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
            var trades interface{} = this.SafeList(data, "items", []interface{}{})
        
            ch <- this.ParseTrades(trades, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name poloniexfutures#setMarginMode
 * @description set margin mode to 'cross' or 'isolated'
 * @see https://api-docs.poloniex.com/futures/api/margin-mode#change-margin-mode
 * @param {string} marginMode "0" (isolated) or "1" (cross)
 * @param {string} symbol unified market symbol
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} response from the exchange
 */
func  (this *poloniexfutures) SetMarginMode(marginMode interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " setMarginMode() requires a symbol argument")))
            }
            if IsTrue(IsTrue(IsTrue(IsTrue((!IsEqual(marginMode, "0"))) && IsTrue((!IsEqual(marginMode, "1")))) && IsTrue((!IsEqual(marginMode, "isolated")))) && IsTrue((!IsEqual(marginMode, "cross")))) {
                panic(ArgumentsRequired(Add(this.Id, " setMarginMode() marginMode must be 0/isolated or 1/cross")))
            }
        
            retRes692441 := (<-this.LoadMarkets())
            PanicOnError(retRes692441)
            if IsTrue(IsEqual(marginMode, "isolated")) {
                marginMode = "0"
            }
            if IsTrue(IsEqual(marginMode, "cross")) {
                marginMode = "1"
            }
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "symbol": GetValue(market, "id"),
                "marginType": this.ParseToInt(marginMode),
            }
        
                retRes744246 :=  (<-this.PrivatePostMarginTypeChange(request))
                PanicOnError(retRes744246)
                ch <- retRes744246
                return nil
        
            }()
            return ch
        }
func  (this *poloniexfutures) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var url interface{} = GetValue(GetValue(this.Urls, "api"), api)
    var versions interface{} = this.SafeValue(this.Options, "versions", map[string]interface{} {})
    var apiVersions interface{} = this.SafeValue(versions, api, map[string]interface{} {})
    var methodVersions interface{} = this.SafeValue(apiVersions, method, map[string]interface{} {})
    var defaultVersion interface{} = this.SafeString(methodVersions, path, this.Version)
    var version interface{} = this.SafeString(params, "version", defaultVersion)
    var tail interface{} = Add(Add(Add("/api/", version), "/"), this.ImplodeParams(path, params))
    url = Add(url, tail)
    var query interface{} = this.Omit(params, this.ExtractParams(path))
    var queryLength interface{} =     GetArrayLength(ObjectKeys(query))
    if IsTrue(IsEqual(api, "public")) {
        if IsTrue(queryLength) {
            url = Add(url, Add("?", this.Urlencode(query)))
        }
    } else {
        this.CheckRequiredCredentials()
        var endpoint interface{} = Add("/api/v1/", this.ImplodeParams(path, params))
        var bodyEncoded interface{} = this.Urlencode(query)
        if IsTrue(IsTrue(!IsEqual(method, "GET")) && IsTrue(!IsEqual(method, "HEAD"))) {
            body = query
        } else {
            if IsTrue(IsTrue(queryLength) && IsTrue(!IsEqual(bodyEncoded, ""))) {
                url = Add(url, Add("?", bodyEncoded))
                endpoint = Add(endpoint, Add("?", bodyEncoded))
            }
        }
        var now interface{} = ToString(this.Milliseconds())
        var endpart interface{} = ""
        if IsTrue(!IsEqual(body, nil)) {
            body = this.Json(query)
            endpart = body
        }
        var payload interface{} = Add(Add(Add(now, method), endpoint), endpart)
        var signature interface{} = this.Hmac(this.Encode(payload), this.Encode(this.Secret), sha256, "base64")
        headers = map[string]interface{} {
            "PF-API-SIGN": signature,
            "PF-API-TIMESTAMP": now,
            "PF-API-KEY": this.ApiKey,
            "PF-API-PASSPHRASE": this.Password,
        }
        AddElementToObject(headers, "Content-Type", "application/json")
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *poloniexfutures) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if !IsTrue(response) {
        this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), body, body)
        return nil
    }
    //
    // bad
    //     { "code": "400100", "msg": "validation.createOrder.clientOidIsRequired" }
    // good
    //     { code: "200000", data: { ... }}
    //
    var errorCode interface{} = this.SafeString(response, "code")
    var message interface{} = this.SafeString(response, "msg", "")
    var feedback interface{} = Add(Add(this.Id, " "), message)
    this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), message, feedback)
    this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), errorCode, feedback)
    this.ThrowBroadlyMatchedException(GetValue(this.Exceptions, "broad"), body, feedback)
    return nil
}


func (this *poloniexfutures) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
