package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type ellipx struct {
    Exchange

}

func NewEllipxCore() ellipx {
   p := ellipx{}
   setDefaults(&p)
   return p
}

func  (this *ellipx) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "ellipx",
        "name": "Ellipx",
        "countries": []interface{}{"PL"},
        "rateLimit": 200,
        "version": "v1",
        "certified": false,
        "pro": false,
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": false,
            "swap": false,
            "future": false,
            "option": false,
            "addMargin": false,
            "cancelAllOrders": false,
            "cancelAllOrdersAfter": false,
            "cancelOrder": true,
            "cancelOrders": false,
            "cancelWithdraw": false,
            "closePosition": false,
            "createConvertTrade": false,
            "createDepositAddress": false,
            "createMarketBuyOrderWithCost": false,
            "createMarketOrder": false,
            "createMarketOrderWithCost": false,
            "createMarketSellOrderWithCost": false,
            "createOrder": true,
            "createOrderWithTakeProfitAndStopLoss": false,
            "createReduceOnlyOrder": false,
            "createStopLimitOrder": false,
            "createStopLossOrder": false,
            "createStopMarketOrder": false,
            "createStopOrder": false,
            "createTakeProfitOrder": false,
            "createTrailingAmountOrder": false,
            "createTrailingPercentOrder": false,
            "createTriggerOrder": false,
            "fetchAccounts": false,
            "fetchBalance": true,
            "fetchCanceledAndClosedOrders": false,
            "fetchCanceledOrders": false,
            "fetchClosedOrder": false,
            "fetchClosedOrders": false,
            "fetchConvertCurrencies": false,
            "fetchConvertQuote": false,
            "fetchConvertTrade": false,
            "fetchConvertTradeHistory": false,
            "fetchCurrencies": true,
            "fetchDepositAddress": true,
            "fetchDeposits": false,
            "fetchDepositsWithdrawals": false,
            "fetchFundingHistory": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchIndexOHLCV": false,
            "fetchLedger": false,
            "fetchLeverage": false,
            "fetchLeverageTiers": false,
            "fetchMarginAdjustmentHistory": false,
            "fetchMarginMode": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMyTrades": false,
            "fetchOHLCV": true,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrder": false,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchOrders": true,
            "fetchOrderTrades": true,
            "fetchPosition": false,
            "fetchPositionHistory": false,
            "fetchPositionMode": false,
            "fetchPositions": false,
            "fetchPositionsForSymbol": false,
            "fetchPositionsHistory": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchStatus": false,
            "fetchTicker": true,
            "fetchTickers": false,
            "fetchTime": false,
            "fetchTrades": true,
            "fetchTradingFee": true,
            "fetchTradingFees": false,
            "fetchTransactions": false,
            "fetchTransfers": false,
            "fetchWithdrawals": false,
            "reduceMargin": false,
            "sandbox": false,
            "setLeverage": false,
            "setMargin": false,
            "setPositionMode": false,
            "transfer": false,
            "withdraw": true,
        },
        "timeframes": map[string]interface{} {
            "1m": "1m",
            "5m": "5m",
            "10m": "10m",
            "1h": "1h",
            "6h": "6h",
            "12h": "12h",
            "1d": "1d",
        },
        "urls": map[string]interface{} {
            "logo": "https://github.com/user-attachments/assets/e07c3f40-281c-4cdf-bacf-fa1c58218a2c",
            "api": map[string]interface{} {
                "public": "https://data.ellipx.com",
                "private": "https://app.ellipx.com/_rest",
                "_rest": "https://app.ellipx.com/_rest",
            },
            "www": "https://www.ellipx.com",
            "doc": "https://docs.google.com/document/d/1ZXzTQYffKE_EglTaKptxGQERRnunuLHEMmar7VC9syM",
            "fees": "https://www.ellipx.com/pages/pricing",
            "referral": "",
        },
        "api": map[string]interface{} {
            "_rest": map[string]interface{} {
                "get": map[string]interface{} {
                    "Market": 1,
                    "Market/{currencyPair}": 1,
                    "Crypto/Token/Info": 1,
                },
            },
            "public": map[string]interface{} {
                "get": map[string]interface{} {
                    "Market/{currencyPair}:getDepth": 1,
                    "Market/{currencyPair}:ticker": 1,
                    "Market/{currencyPair}:getTrades": 1,
                    "Market/{currencyPair}:getGraph": 1,
                    "CMC:summary": 1,
                    "CMC/{currencyPair}:ticker": 1,
                },
            },
            "private": map[string]interface{} {
                "get": map[string]interface{} {
                    "User/Wallet": 1,
                    "Market/{currencyPair}/Order": 1,
                    "Market/Order/{orderUuid}": 1,
                    "Market/{currencyPair}/Trade": 1,
                    "Market/TradeFee:query": 1,
                    "Unit/{currency}": 1,
                    "Crypto/Token/{currency}": 1,
                    "Crypto/Token/{currency}:chains": 1,
                },
                "post": map[string]interface{} {
                    "Market/{currencyPair}/Order": 1,
                    "Crypto/Address:fetch": 1,
                    "Crypto/Disbursement:withdraw": 1,
                },
                "delete": map[string]interface{} {
                    "Market/Order/{orderUuid}": 1,
                },
            },
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "tierBased": true,
                "feeSide": "get",
                "percentage": true,
                "maker": this.ParseNumber("0.0025"),
                "taker": this.ParseNumber("0.0030"),
                "tiers": map[string]interface{} {
                    "maker": []interface{}{[]interface{}{this.ParseNumber("0"), this.ParseNumber("0.0025")}, []interface{}{this.ParseNumber("10000"), this.ParseNumber("0.0020")}, []interface{}{this.ParseNumber("50000"), this.ParseNumber("0.0015")}, []interface{}{this.ParseNumber("100000"), this.ParseNumber("0.0010")}, []interface{}{this.ParseNumber("1000000"), this.ParseNumber("0.0008")}, []interface{}{this.ParseNumber("5000000"), this.ParseNumber("0.0003")}, []interface{}{this.ParseNumber("15000000"), this.ParseNumber("0.0000")}, []interface{}{this.ParseNumber("75000000"), this.ParseNumber("0.0000")}, []interface{}{this.ParseNumber("100000000"), this.ParseNumber("0.0000")}},
                    "taker": []interface{}{[]interface{}{this.ParseNumber("0"), this.ParseNumber("0.0030")}, []interface{}{this.ParseNumber("10000"), this.ParseNumber("0.0025")}, []interface{}{this.ParseNumber("50000"), this.ParseNumber("0.0020")}, []interface{}{this.ParseNumber("100000"), this.ParseNumber("0.0015")}, []interface{}{this.ParseNumber("1000000"), this.ParseNumber("0.0012")}, []interface{}{this.ParseNumber("5000000"), this.ParseNumber("0.0010")}, []interface{}{this.ParseNumber("15000000"), this.ParseNumber("0.0008")}, []interface{}{this.ParseNumber("75000000"), this.ParseNumber("0.0005")}, []interface{}{this.ParseNumber("100000000"), this.ParseNumber("0.0003")}},
                },
            },
            "stablecoin": map[string]interface{} {
                "tierBased": false,
                "percentage": true,
                "maker": this.ParseNumber("0.0000"),
                "taker": this.ParseNumber("0.000015"),
            },
        },
        "options": map[string]interface{} {
            "defaultType": "spot",
            "recvWindow": Multiply(5, 1000),
            "broker": "CCXT",
            "networks": map[string]interface{} {
                "Bitcoin": "Bitcoin",
                "Ethereum": "ERC20",
            },
            "defaultNetwork": "defaultNetwork",
            "defaultNetworkCodeReplacements": map[string]interface{} {
                "BTC": "Bitcoin",
                "ETH": "Ethereum",
            },
        },
        "features": map[string]interface{} {
            "spot": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": false,
                    "triggerPriceType": nil,
                    "triggerDirection": false,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": false,
                        "FOK": false,
                        "PO": false,
                        "GTD": false,
                    },
                    "hedged": false,
                    "selfTradePrevention": false,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyByCost": true,
                    "marketBuyRequiresPrice": false,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": nil,
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": false,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": nil,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": nil,
                    "daysBack": nil,
                    "untilDays": nil,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchClosedOrders": nil,
                "fetchOHLCV": map[string]interface{} {
                    "limit": 100,
                },
            },
            "swap": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "commonCurrencies": map[string]interface{} {},
        "exceptions": map[string]interface{} {
            "exact": map[string]interface{} {
                "400": BadRequest,
                "401": AuthenticationError,
                "403": PermissionDenied,
                "404": BadRequest,
                "429": DDoSProtection,
                "418": PermissionDenied,
                "500": ExchangeError,
                "504": ExchangeError,
            },
            "broad": map[string]interface{} {},
        },
        "precisionMode": TICK_SIZE,
    })
}
func  (this *ellipx) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    path = this.ImplodeParams(path, params)
    var url interface{} = Add(Add(GetValue(GetValue(this.Urls, "api"), api), "/"), path)
    if IsTrue(IsEqual(api, "private")) {
        this.CheckRequiredCredentials()
        var nonce interface{} = this.Uuid()
        var timestamp interface{} = ToString(this.Seconds())
        if IsTrue(IsEqual(method, "GET")) {
            body = ""
        } else {
            body = this.Json(params)
        }
        params = this.Extend(map[string]interface{} {
            "_key": this.ApiKey,
            "_time": timestamp,
            "_nonce": nonce,
        }, params)
        var query interface{} = this.Urlencode(params)
        var bodyHash interface{} = this.Hash(this.Encode(body), sha256)
        // Create sign string components
        var bodyHashBytes interface{} = this.Base16ToBinary(bodyHash)
        var nulByte interface{} = this.NumberToBE(0, 1)
        var components interface{} = []interface{}{this.Encode(method), nulByte, this.Encode(path), nulByte, this.Encode(query), nulByte, bodyHashBytes}
        // Join with null byte separator using encode
        var signString interface{} = this.BinaryConcatArray(components)
        var sec interface{} = this.Secret
        var remainder interface{} = this.CalculateMod(GetLength(sec), 4)
        var paddingLength interface{} = Ternary(IsTrue(remainder), Subtract(4, remainder), 0)
        var secretWithPadding interface{} = Replace(this.Secret, "-", "+")
        secretWithPadding = Replace(secretWithPadding, "_", "/")
        secretWithPadding = PadEnd(secretWithPadding, Add(GetLength(this.Secret), paddingLength), "=")
        var secretBytes interface{} = this.Base64ToBinary(secretWithPadding)
        var seed interface{} = this.ArraySlice(secretBytes, 0, 32) // Extract first 32 bytes as seed
        var signature interface{} = Eddsa(signString, seed, ed25519)
        AddElementToObject(params, "_sign", signature)
    }
    if IsTrue(GetArrayLength(ObjectKeys(params))) {
        url = Add(url, Add("?", this.Urlencode(params)))
    }
    if IsTrue(IsEqual(method, "GET")) {
        body = nil
    } else {
        headers = map[string]interface{} {
            "Content-Type": "application/json",
        }
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *ellipx) CalculateMod(a interface{}, b interface{}) interface{}  {
    // trick to fix php transpiling error
    return Mod(a, b)
}
/**
 * @method
 * @name ellipx#fetchMarkets
 * @description Fetches market information from the exchange.
 * @see https://docs.ccxt.com/en/latest/manual.html#markets
 * @see https://docs.google.com/document/d/1ZXzTQYffKE_EglTaKptxGQERRnunuLHEMmar7VC9syM/edit?tab=t.0#heading=h.1a1t05wpgfof
 * @param {object} [params] - Extra parameters specific to the exchange API endpoint
 * @returns {Promise<Market[]>} An array of market structures.
 */
func  (this *ellipx) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this._restGetMarket(params))
            PanicOnError(response)
            // {
            //     Market__: "mkt-lrnp2e-eaor-eobj-ua73-75j6sjxe",
            //     Primary_Unit__: "unit-aebkye-u35b-e5zm-zt22-2qvwhsqa",
            //     Secondary_Unit__: "unit-jcevlk-soxf-fepb-yjwm-b32q5bom",
            //     Primary_Step: null,
            //     Secondary_Step: null,
            //     Status: "active",
            //     Default_Scale: "5",
            //     Priority: "100",
            //     Created: {
            //       unix: "1728113809",
            //       us: "0",
            //       iso: "2024-10-05 07:36:49.000000",
            //       tz: "UTC",
            //       full: "1728113809000000",
            //       unixms: "1728113809000",
            //     },
            //     Start: {
            //       unix: "1728295200",
            //       us: "0",
            //       iso: "2024-10-07 10:00:00.000000",
            //       tz: "UTC",
            //       full: "1728295200000000",
            //       unixms: "1728295200000",
            //     },
            //     Key: "BTC_USDC",
            //     Primary: {
            //       Unit__: "unit-aebkye-u35b-e5zm-zt22-2qvwhsqa",
            //       Currency__: "BTC",
            //       Crypto_Token__: "crtok-c5v3mh-grfn-hl5d-lmel-fvggbf4i",
            //       Key: "BTC",
            //       Symbol: "BTC",
            //       Symbol_Position: "after",
            //       Name: "Bitcoin",
            //       Decimals: "8",
            //       Display_Decimals: "8",
            //       Legacy_Decimals: null,
            //       Type: "crypto_token",
            //       Visible: "Y",
            //       Created: {
            //         unix: "1495247415",
            //         us: "0",
            //         iso: "2017-05-20 02:30:15.000000",
            //         tz: "UTC",
            //         full: "1495247415000000",
            //         unixms: "1495247415000",
            //       },
            //     },
            //     Secondary: {
            //       Unit__: "unit-jcevlk-soxf-fepb-yjwm-b32q5bom",
            //       Currency__: null,
            //       Crypto_Token__: "crtok-ptabkh-ra4r-anbd-cqra-bqfbtnba",
            //       Key: "USDC",
            //       Symbol: null,
            //       Symbol_Position: "before",
            //       Name: "Circle USD",
            //       Decimals: "6",
            //       Display_Decimals: "6",
            //       Legacy_Decimals: null,
            //       Type: "crypto_token",
            //       Visible: "Y",
            //       Created: {
            //         unix: "1694859829",
            //         us: "0",
            //         iso: "2023-09-16 10:23:49.000000",
            //         tz: "UTC",
            //         full: "1694859829000000",
            //         unixms: "1694859829000",
            //       },
            //     },
            //   }
            var markets interface{} = this.SafeValue(response, "data", []interface{}{})
        
            ch <- this.ParseMarkets(markets)
            return nil
        
            }()
            return ch
        }
func  (this *ellipx) ParseMarket(market interface{}) interface{}  {
    var id interface{} = this.SafeString(market, "Key")
    var base interface{} = this.SafeString(GetValue(market, "Primary"), "Key")
    var quote interface{} = this.SafeString(GetValue(market, "Secondary"), "Key")
    var baseId interface{} = this.SafeString(GetValue(market, "Primary"), "Crypto_Token__")
    var quoteId interface{} = this.SafeString(GetValue(market, "Secondary"), "Crypto_Token__")
    var status interface{} = IsEqual(this.SafeString(market, "Status"), "active")
    var created interface{} = this.SafeTimestamp(GetValue(market, "Created"), "unix")
    var amountPrecision interface{} = this.ParseNumber(this.ParsePrecision(this.SafeString(GetValue(market, "Primary"), "Decimals")))
    var pricePrecision interface{} = this.ParseNumber(this.ParsePrecision(this.SafeString(GetValue(market, "Secondary"), "Decimals")))
    var fees interface{} = this.Fees // should use fetchTradingFees
    return this.SafeMarketStructure(map[string]interface{} {
        "id": id,
        "symbol": Add(Add(base, "/"), quote),
        "base": base,
        "quote": quote,
        "settle": nil,
        "baseId": baseId,
        "quoteId": quoteId,
        "settleId": nil,
        "type": "spot",
        "spot": true,
        "margin": false,
        "swap": false,
        "future": false,
        "option": false,
        "active": status,
        "contract": false,
        "linear": nil,
        "inverse": nil,
        "taker": GetValue(GetValue(fees, "trading"), "taker"),
        "maker": GetValue(GetValue(fees, "trading"), "maker"),
        "contractSize": nil,
        "expiry": nil,
        "expiryDatetime": nil,
        "strike": nil,
        "optionType": nil,
        "precision": map[string]interface{} {
            "amount": amountPrecision,
            "price": pricePrecision,
        },
        "limits": map[string]interface{} {
            "amount": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "price": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "cost": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
        },
        "info": market,
        "created": created,
    })
}
/**
 * @method
 * @name ellipx#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://docs.google.com/document/d/1ZXzTQYffKE_EglTaKptxGQERRnunuLHEMmar7VC9syM/edit?tab=t.0#heading=h.d2jylz4u6pmu
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *ellipx) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes544931 := (<-this.LoadMarkets())
            PanicOnError(retRes544931)
            var market interface{} = this.Market(symbol)
            var marketId interface{} = GetValue(market, "id")
            var request interface{} = map[string]interface{} {
                "currencyPair": marketId,
            }
        
            response:= (<-this.PublicGetMarketCurrencyPairTicker(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "data": {
            //             "market": "BTC_USDC",
            //             "ticker": {
            //                 "time": 1730814600,
            //                 "count": 2135,
            //                 "high": {
            //                     "v": "74766990000",
            //                     "e": 6,
            //                     "f": 74766.99
            //                 },
            //                 "low": {
            //                     "v": "68734020000",
            //                     "e": 6,
            //                     "f": 68734.02
            //                 },
            //                 "avg": {
            //                     "v": "72347941430",
            //                     "e": 6,
            //                     "f": 72347.94143
            //                 },
            //                 "vwap": {
            //                     "v": "73050064447",
            //                     "e": 6,
            //                     "f": 73050.064447
            //                 },
            //                 "vol": {
            //                     "v": "4885361",
            //                     "e": 8,
            //                     "f": 0.04885361
            //                 },
            //                 "secvol": {
            //                     "v": "3568759346",
            //                     "e": 6,
            //                     "f": 3568.759346
            //                 },
            //                 "open": {
            //                     "v": "68784020000",
            //                     "e": 6,
            //                     "f": 68784.02
            //                 },
            //                 "close": {
            //                     "v": "73955570000",
            //                     "e": 6,
            //                     "f": 73955.57
            //                 }
            //             }
            //         },
            //         "request_id": "cbf183e0-7a62-4674-838c-6693031fa240",
            //         "result": "success",
            //         "time": 0.015463566
            //     }
            //
            var ticker interface{} = this.SafeValue(GetValue(response, "data"), "ticker", map[string]interface{} {})
        
            ch <- this.ParseTicker(ticker, market)
            return nil
        
            }()
            return ch
        }
func  (this *ellipx) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeIntegerProduct(ticker, "time", 1000)
    var open interface{} = this.ParseAmount(this.SafeValue(ticker, "open"))
    var high interface{} = this.ParseAmount(this.SafeValue(ticker, "high"))
    var low interface{} = this.ParseAmount(this.SafeValue(ticker, "low"))
    var close interface{} = this.ParseAmount(this.SafeValue(ticker, "close"))
    var avg interface{} = this.ParseAmount(this.SafeValue(ticker, "avg"))
    var vwap interface{} = this.ParseAmount(this.SafeValue(ticker, "vwap"))
    var baseVolume interface{} = this.ParseAmount(this.SafeValue(ticker, "vol"))
    var quoteVolume interface{} = this.ParseAmount(this.SafeValue(ticker, "secvol"))
    // const count = this.safeInteger(ticker, 'count'); not used
    return this.SafeTicker(map[string]interface{} {
        "symbol": this.SafeSymbol(nil, market),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": high,
        "low": low,
        "bid": nil,
        "bidVolume": nil,
        "ask": nil,
        "askVolume": nil,
        "vwap": vwap,
        "open": open,
        "close": close,
        "last": close,
        "previousClose": nil,
        "change": nil,
        "percentage": nil,
        "average": avg,
        "baseVolume": baseVolume,
        "quoteVolume": quoteVolume,
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name ellipx#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://docs.google.com/document/d/1ZXzTQYffKE_EglTaKptxGQERRnunuLHEMmar7VC9syM/edit?tab=t.0#heading=h.bqmucewhkpdz
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return the exchange not supported yet.
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *ellipx) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes907704 := (<-this.LoadMarkets())
            PanicOnError(retRes907704)
            var market interface{} = this.Market(symbol)
            var marketId interface{} = GetValue(market, "id")
            var request interface{} = map[string]interface{} {
                "currencyPair": marketId,
            }
        
            response:= (<-this.PublicGetMarketCurrencyPairGetDepth(this.Extend(request, params)))
            PanicOnError(response)
            // {
            //     "data": {
            //         "asks": [
            //             {
            //                 "price": {
            //                     "v": "74941875231",
            //                     "e": 6,
            //                     "f": 74941.875231
            //                 },
            //                 "amount": {
            //                     "v": "149",
            //                     "e": 8,
            //                     "f": 0.00000149
            //                 }
            //             },
            //             {
            //                 "price": {
            //                     "v": "75063426037",
            //                     "e": 6,
            //                     "f": 75063.426037
            //                 },
            //                 "amount": {
            //                     "v": "335",
            //                     "e": 8,
            //                     "f": 0.00000335
            //                 }
            //             }
            //         ],
            //         "bids": [
            //             {
            //                 "price": {
            //                     "v": "64518711040",
            //                     "e": 6,
            //                     "f": 64518.71104
            //                 },
            //                 "amount": {
            //                     "v": "132",
            //                     "e": 8,
            //                     "f": 0.00000132
            //                 }
            //             },
            //             {
            //                 "price": {
            //                     "v": "64263569273",
            //                     "e": 6,
            //                     "f": 64263.569273
            //                 },
            //                 "amount": {
            //                     "v": "210",
            //                     "e": 8,
            //                     "f": 0.0000021
            //                 }
            //             }
            //         ],
            //         "market": "BTC_USDC"
            //     },
            //     "request_id": "71b7dffc-3120-4e46-a0bb-49ece5aea7e1",
            //     "result": "success",
            //     "time": 0.000074661
            // }
            var data interface{} = this.SafeValue(response, "data", map[string]interface{} {}) // exchange specific v e f params
            var timestamp interface{} = this.Milliseconds() // the exchange does not provide timestamp for this.
            var dataBidsLength interface{} =     GetArrayLength(GetValue(data, "bids"))
            var dataAsksLength interface{} =     GetArrayLength(GetValue(data, "asks"))
            for i := 0; IsLessThan(i, dataBidsLength); i++ {
                AddElementToObject(GetValue(GetValue(data, "bids"), i), "price", this.ParseAmount(GetValue(GetValue(GetValue(data, "bids"), i), "price")))
                AddElementToObject(GetValue(GetValue(data, "bids"), i), "amount", this.ParseAmount(GetValue(GetValue(GetValue(data, "bids"), i), "amount")))
            }
            for i := 0; IsLessThan(i, dataAsksLength); i++ {
                AddElementToObject(GetValue(GetValue(data, "asks"), i), "price", this.ParseAmount(GetValue(GetValue(GetValue(data, "asks"), i), "price")))
                AddElementToObject(GetValue(GetValue(data, "asks"), i), "amount", this.ParseAmount(GetValue(GetValue(GetValue(data, "asks"), i), "amount")))
            }
        
            ch <- this.ParseOrderBook(data, symbol, timestamp, "bids", "asks", "price", "amount")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ellipx#fetchOHLCV
 * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market, default will return the last 24h period.
 * @see https://docs.google.com/document/d/1ZXzTQYffKE_EglTaKptxGQERRnunuLHEMmar7VC9syM/edit?tab=t.0#heading=h.w65baeuhxwt8
 * @param {string} symbol unified symbol of the market to fetch OHLCV data for
 * @param {string} timeframe the length of time each candle represents
 * @param {int} [since] timestamp in ms of the earliest candle to fetch
 * @param {int} [limit] the maximum amount of candles to fetch
 * @param {object} [params] extra parameters specific to the API endpoint
 * @param {int} [params.until] timestamp in ms of the earliest candle to fetch
 * @returns {OHLCV[]} A list of candles ordered as timestamp, open, high, low, close, volume
 */
func  (this *ellipx) FetchOHLCV(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    timeframe := GetArg(optionalArgs, 0, "1m")
            _ = timeframe
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes54543 := (<-this.LoadMarkets())
            PanicOnError(retRes54543)
            var methodName interface{} = "fetchOHLCV"
            var paginate interface{} = false
            paginateparamsVariable := this.HandleOptionAndParams(params, methodName, "paginate");
            paginate = GetValue(paginateparamsVariable,0);
            params = GetValue(paginateparamsVariable,1)
            if IsTrue(paginate) {
        
                    retRes283275 :=  (<-this.FetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, params, 1000))
                    PanicOnError(retRes283275)
                    ch <- retRes283275
                    return nil
            }
            var market interface{} = this.Market(symbol)
            var marketId interface{} = GetValue(market, "id")
            var time_frame interface{} = this.SafeString(this.Timeframes, timeframe, nil)
            var request interface{} = map[string]interface{} {
                "currencyPair": marketId,
                "interval": time_frame,
            }
            if IsTrue(!IsEqual(since, nil)) {
                AddElementToObject(request, "start", MathFloor(Divide(since, 1000)))
            }
            var until interface{} = nil
            untilparamsVariable := this.HandleOptionAndParams(params, methodName, "until");
            until = GetValue(untilparamsVariable,0);
            params = GetValue(untilparamsVariable,1)
            if IsTrue(!IsEqual(until, nil)) {
                AddElementToObject(request, "end", until)
            }
            // {
            //     "data": {
            //         "market": "BTC_USDC",
            //         "real_end": 1730970780,
            //         "requested_end": 1730970784,
            //         "start": 1730884200,
            //         "stats": [
            //             {
            //                 "time": 1730884200,
            //                 "count": 48,
            //                 "high": {"v": "73898950000", "e": 6, "f": 73898.95},
            //                 "low": {"v": "73642930000", "e": 6, "f": 73642.93},
            //                 "open": {"v": "73830990000", "e": 6, "f": 73830.99},
            //                 "close": {"v": "73682510000", "e": 6, "f": 73682.51},
            //                 "vol": {"v": "88159", "e": 8, "f": 0.00088159}
            //             }
            //         ]
            //     }
            // }
            // No limit parameter supported by the API
        
            response:= (<-this.PublicGetMarketCurrencyPairGetGraph(this.Extend(request, params)))
            PanicOnError(response)
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var ohlcv interface{} = this.SafeList(data, "stats", []interface{}{})
        
            ch <- this.ParseOHLCVs(ohlcv, market, timeframe, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *ellipx) ParseOHLCV(ohlcv interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    return []interface{}{Multiply(this.SafeInteger(ohlcv, "time"), 1000), this.ParseNumber(this.ParseAmount(this.SafeDict(ohlcv, "open"))), this.ParseNumber(this.ParseAmount(this.SafeDict(ohlcv, "high"))), this.ParseNumber(this.ParseAmount(this.SafeDict(ohlcv, "low"))), this.ParseNumber(this.ParseAmount(this.SafeDict(ohlcv, "close"))), this.ParseNumber(this.ParseAmount(this.SafeDict(ohlcv, "vol")))}
}
/**
 * @method
 * @name ellipx#fetchCurrencies
 * @description fetches information on all currencies from the exchange, including deposit/withdrawal details and available chains
 * @see https://docs.google.com/document/d/1ZXzTQYffKE_EglTaKptxGQERRnunuLHEMmar7VC9syM/edit?tab=t.0#heading=h.x65f9s9j74jf
 * @param {object} [params] extra parameters specific to the ellipx API endpoint
 * @param {string} [params.Can_Deposit] filter currencies by deposit availability, Y for available
 * @param {number} [params.results_per_page] number of results per page, default 100
 * @param {string} [params._expand] additional fields to expand in response, default '/Crypto_Token,/Crypto_Chain'
 * @returns {Promise<Currencies>} An object of currency structures indexed by currency codes
 */
func  (this *ellipx) FetchCurrencies(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this._restGetCryptoTokenInfo(this.Extend(map[string]interface{} {
            "Can_Deposit": "Y",
            "results_per_page": 100,
            "_expand": "/Crypto_Token,/Crypto_Chain",
        }, params)))
            PanicOnError(response)
            var currencies interface{} = map[string]interface{} {}
            var data interface{} = this.SafeValue(response, "data", []interface{}{})
            for i := 0; IsLessThan(i, GetArrayLength(data)); i++ {
                var currency interface{} = this.ParseCurrency(GetValue(data, i))
                var code interface{} = this.SafeString(currency, "code")
                if IsTrue(!IsEqual(code, nil)) {
                    AddElementToObject(currencies, code, currency)
                }
            }
        
            ch <- currencies
            return nil
        
            }()
            return ch
        }
func  (this *ellipx) ParseCurrency(currency interface{}) interface{}  {
    var id interface{} = this.SafeString(currency, "Crypto_Token__")
    var token interface{} = this.SafeValue(currency, "Crypto_Token", map[string]interface{} {})
    var code interface{} = this.SafeCurrencyCode(this.SafeString(token, "Symbol"))
    var name interface{} = this.SafeString(token, "Name")
    var active interface{} = IsEqual(this.SafeString(currency, "Status"), "valid")
    var deposit interface{} = IsEqual(this.SafeString(currency, "Can_Deposit"), "Y")
    var withdraw interface{} = IsEqual(this.SafeString(currency, "Status"), "valid")
    var fee interface{} = nil
    if IsTrue(!IsEqual(GetValue(currency, "Withdraw_Fee"), nil)) {
        fee = this.ParseNumber(this.ParseAmount(GetValue(currency, "Withdraw_Fee")))
    }
    var precision interface{} = this.ParseNumber(this.ParsePrecision(this.SafeString(token, "Decimals")))
    var minDeposit interface{} = nil
    if IsTrue(!IsEqual(GetValue(currency, "Minimum_Deposit"), nil)) {
        minDeposit = this.ParseAmount(GetValue(currency, "Minimum_Deposit"))
    }
    var minWithdraw interface{} = nil
    if IsTrue(!IsEqual(GetValue(currency, "Minimum_Withdraw"), nil)) {
        minWithdraw = this.ParseAmount(GetValue(currency, "Minimum_Withdraw"))
    }
    var networkId interface{} = this.SafeString(currency, "Crypto_Chain__")
    var networkData interface{} = this.SafeValue(currency, "Crypto_Chain", map[string]interface{} {})
    var networkCode interface{} = this.SafeString(networkData, "Type", "default")
    var networks interface{} = map[string]interface{} {
        "string": nil,
        "info": Ternary(IsTrue(IsEqual(networkCode, "default")), map[string]interface{} {}, networkData),
        "id": IsTrue(IsTrue(networkId) || IsTrue(id)) || IsTrue(""),
        "network": networkCode,
        "active": active,
        "deposit": deposit,
        "withdraw": withdraw,
        "fee": fee,
        "precision": precision,
        "limits": map[string]interface{} {
            "deposit": map[string]interface{} {
                "min": minDeposit,
                "max": nil,
            },
            "withdraw": map[string]interface{} {
                "min": minWithdraw,
                "max": nil,
            },
        },
    }
    var result interface{} = map[string]interface{} {
        "info": currency,
        "id": id,
        "code": code,
        "name": name,
        "active": active,
        "deposit": deposit,
        "withdraw": withdraw,
        "fee": fee,
        "precision": precision,
        "type": nil,
        "limits": map[string]interface{} {
            "amount": map[string]interface{} {
                "min": nil,
                "max": nil,
            },
            "withdraw": map[string]interface{} {
                "min": minWithdraw,
                "max": nil,
            },
        },
        "networks": networks,
    }
    return result
}
/**
 * @method
 * @name ellipx#fetchTrades
 * @description fetches all completed trades for a particular market/symbol
 * @param {string} symbol unified market symbol (e.g. 'BTC/USDT')
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the EllipX API endpoint
 * @param {string} [params.before] get trades before the given trade ID
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *ellipx) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes57872 := (<-this.LoadMarkets())
            PanicOnError(retRes57872)
            var market interface{} = this.Market(symbol)
            var marketId interface{} = GetValue(market, "id")
            var request interface{} = map[string]interface{} {
                "currencyPair": marketId,
            }
            // endpoint support before trade id.
            // The actual endpoint URL will be: https://data.ellipx.com/Market/{currencyPair}:getTrades
            // {
            //     "id": "BTC_USDC:1731053859:914141972:0",
            //     "pair": [
            //         "BTC",
            //         "USDC"
            //     ],
            //     "bid": {
            //         "id": "mktor-swishf-uv6n-hrzj-63ye-bdqnk33q",
            //         "iss": "ellipx:beta",
            //         "uniq": "order:1731053859:914141972:0"
            //     },
            //     "ask": {
            //         "id": "mktor-p3ozvt-qurz-gmzo-bf5n-g4rcuy6u",
            //         "iss": "ellipx:beta",
            //         "uniq": "order:1731053859:874659786:0"
            //     },
            //     "type": "bid",
            //     "amount": {
            //         "v": "412",
            //         "e": 8,
            //         "f": 0.00000412
            //     },
            //     "price": {
            //         "v": "75878090000",
            //         "e": 6,
            //         "f": 75878.09
            //     },
            //     "date": "2024-11-08T08:17:39.914141972Z"
            // }
        
            response:= (<-this.PublicGetMarketCurrencyPairGetTrades(this.Extend(request, params)))
            PanicOnError(response)
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
            var trades interface{} = this.SafeList(data, "trades", []interface{}{})
        
            ch <- this.ParseTrades(trades, market, since, limit)
            return nil
        
            }()
            return ch
        }
func  (this *ellipx) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    // Format of trade ID: "BTC_USDC:1731053859:914141972:0"
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeString(trade, "id")
    // fetchTrades and fetchMyTrades return different trade structures
    var date interface{} = this.SafeDict(trade, "date")
    var timestamp interface{} = nil
    if IsTrue(IsEqual(date, nil)) {
        timestamp = this.Parse8601(this.SafeString(trade, "date"))
    } else {
        timestamp = this.SafeInteger(date, "unixms")
    }
    var typeVar interface{} = this.SafeString(trade, "type")
    var side interface{} = Ternary(IsTrue((IsEqual(typeVar, "bid"))), "buy", "sell")
    var amount interface{} = this.SafeDict(trade, "amount")
    var price interface{} = this.SafeDict(trade, "price")
    var amountFloat interface{} = this.ParseAmount(amount)
    var priceFloat interface{} = this.ParseAmount(price)
    // fetchTrades and fetchMyTrades return different trade structures
    var pair interface{} = this.SafeList(trade, "pair")
    var marketSymbol interface{} = nil
    if IsTrue(IsEqual(pair, nil)) {
        var symbol interface{} = this.SafeString(trade, "pair")
        basequoteVariable := Split(symbol, "_");
        base := GetValue(basequoteVariable,0);
        quote := GetValue(basequoteVariable,1)
        marketSymbol = Add(Add(base, "/"), quote)
    } else {
        marketSymbol = Add(Add(this.SafeString(pair, 0), "/"), this.SafeString(pair, 1))
    }
    var bidOrder interface{} = this.SafeDict(trade, "bid")
    var askOrder interface{} = this.SafeDict(trade, "ask")
    var isBuy interface{} =     (IsEqual(side, "buy"))
    var orderId interface{} = Ternary(IsTrue(isBuy), this.SafeString(bidOrder, "id"), this.SafeString(askOrder, "id"))
    return this.SafeTrade(map[string]interface{} {
        "id": id,
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": marketSymbol,
        "type": nil,
        "side": side,
        "order": orderId,
        "takerOrMaker": nil,
        "price": priceFloat,
        "amount": amountFloat,
        "cost": nil,
        "fee": nil,
    })
}
/**
 * @method
 * @name ellipx#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://docs.google.com/document/d/1ZXzTQYffKE_EglTaKptxGQERRnunuLHEMmar7VC9syM/edit?tab=t.0#heading=h.ihrjov144txg
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *ellipx) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes471922 := (<-this.LoadMarkets())
            PanicOnError(retRes471922)
        
            response:= (<-this.PrivateGetUserWallet(params))
            PanicOnError(response)
            // {
            //     "User_Wallet__": "usw-vv7hzo-qel5-gupk-neqi-7f3wz5pq",
            //     "User__": "usr-...",
            //     "Realm__": "usrr-cb3c7n-qvxv-fdrb-uc2q-gpja2foi",
            //     "Unit__": "unit-aebkye-u35b-e5zm-zt22-2qvwhsqa",
            //     "Balance": {
            //         "value": "0.00006394",
            //         "value_int": "6394",
            //         "value_disp": "0.00006394",
            //         "value_xint": {
            //             "v": "6394",
            //             "e": 8,
            //             "f": 0.00006394
            //         },
            //         "display": "0.00006394BTC",
            //         "display_short": "0.00006394BTC",
            //         "currency": "BTC",
            //         "unit": "BTC",
            //         "has_vat": false,
            //         "tax_profile": null
            //     },
            //     "Balance_Date": {
            //         "unix": 1731128270,
            //         "us": 426208,
            //         "iso": "2024-11-09 04:57:50.426208",
            //         "tz": "UTC",
            //         "full": "1731128270426208",
            //         "unixms": "1731128270426"
            //     },
            //     "Liabilities": {
            //         "value": "0.00000000",
            //         "value_int": "0",
            //         "value_disp": "0.00000000",
            //         "value_xint": {
            //             "v": "0",
            //             "e": 8,
            //             "f": 0
            //         },
            //         "display": "0.00000000BTC",
            //         "display_short": "0.00000000BTC",
            //         "currency": "BTC",
            //         "unit": "BTC",
            //         "has_vat": false,
            //         "tax_profile": null
            //     },
            //     "Index": "5",
            //     "Backend": "virtual",
            //     "Disable_Limits": "N",
            //     "Unencumbered_Balance": {
            //         "value": "0.00006394",
            //         "value_int": "6394",
            //         "value_disp": "0.00006394",
            //         "value_xint": {
            //             "v": "6394",
            //             "e": 8,
            //             "f": 0.00006394
            //         },
            //         "display": "0.00006394BTC",
            //         "display_short": "0.00006394BTC",
            //         "currency": "BTC",
            //         "unit": "BTC",
            //         "has_vat": false,
            //         "tax_profile": null
            //     }
            // }
            var result interface{} = map[string]interface{} {
                "info": response,
                "timestamp": nil,
                "datetime": nil,
            }
            var dataArray interface{} = this.SafeList(response, "data", []interface{}{})
            // Use first item's timestamp if available
            var dataArrayLength interface{} =     GetArrayLength(dataArray)
            if IsTrue(IsGreaterThan(dataArrayLength, 0)) {
                var firstItem interface{} = GetValue(dataArray, 0)
                var balanceDate interface{} = this.SafeDict(firstItem, "Balance_Date", map[string]interface{} {})
                AddElementToObject(result, "timestamp", this.SafeInteger(balanceDate, "unixms"))
                AddElementToObject(result, "datetime", this.Iso8601(GetValue(result, "timestamp")))
            }
            // Process each balance entry
            for i := 0; IsLessThan(i, GetArrayLength(dataArray)); i++ {
                var entry interface{} = GetValue(dataArray, i)
                var balance interface{} = this.SafeDict(entry, "Balance", map[string]interface{} {})
                var currency interface{} = this.SafeString(balance, "currency")
                if IsTrue(!IsEqual(currency, nil)) {
                    var account interface{} = map[string]interface{} {
                        "free": this.ParseAmount(GetValue(GetValue(entry, "Unencumbered_Balance"), "value_xint")),
                        "used": this.ParseAmount(GetValue(GetValue(entry, "Liabilities"), "value_xint")),
                        "total": this.ParseAmount(GetValue(balance, "value_xint")),
                    }
                    AddElementToObject(result, currency, account)
                }
            }
        
            ch <- this.SafeBalance(result)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ellipx#createOrder
 * @description create a new order in a market
 * @see https://docs.google.com/document/d/1ZXzTQYffKE_EglTaKptxGQERRnunuLHEMmar7VC9syM/edit?tab=t.0#heading=h.yzfak2n2bwpo
 * @param {string} symbol unified market symbol (e.g. 'BTC/USDT')
 * @param {string} type order type - the exchange automatically sets type to 'limit' if price defined, 'market' if undefined
 * @param {string} side 'buy' or 'sell'
 * @param {float} [amount] amount of base currency to trade (can be undefined if using Spend_Limit)
 * @param {float} [price] price per unit of base currency for limit orders
 * @param {object} [params] extra parameters specific to the EllipX API endpoint
 * @param {float} [params.cost] maximum amount to spend in quote currency (required for market orders if amount undefined)
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *ellipx) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes764078 := (<-this.LoadMarkets())
            PanicOnError(retRes764078)
            var market interface{} = this.Market(symbol)
            // the exchange automatically sets the type to 'limit' if the price is defined and to 'market' if it is not
            var marketId interface{} = GetValue(market, "id")
            var orderType interface{} = "bid"
            if IsTrue(IsEqual(side, "buy")) {
                orderType = "bid"
            } else {
                orderType = "ask"
            }
            var request interface{} = map[string]interface{} {
                "currencyPair": marketId,
                "Type": orderType,
            }
            if IsTrue(!IsEqual(amount, nil)) {
                AddElementToObject(request, "Amount", this.AmountToPrecision(symbol, amount))
            }
            if IsTrue(!IsEqual(price, nil)) {
                AddElementToObject(request, "Price", this.PriceToPrecision(symbol, price))
            }
            var cost interface{} = this.SafeString(params, "cost")
            if IsTrue(!IsEqual(cost, nil)) {
                params = this.Omit(params, "cost")
                AddElementToObject(request, "Spend_Limit", this.PriceToPrecision(symbol, cost))
            }
        
            response:= (<-this.PrivatePostMarketCurrencyPairOrder(this.Extend(request, params)))
            PanicOnError(response)
            // {
            //     "result": "success",
            //     "data": {
            //         "Market_Order__": "mktor-x2grmu-zwo5-fyxc-4gue-vd4ouvsa",
            //         "Market__": "mkt-lrnp2e-eaor-eobj-ua73-75j6sjxe",
            //         "User__": "usr-...",
            //         "Uniq": "order:1728719021:583795548:0",
            //         "Type": "bid",
            //         "Status": "pending",
            //         "Flags": {},
            //         "Amount": {
            //             "v": "100000000",
            //             "e": 8,
            //             "f": 1
            //         },
            //         "Price": null,
            //         "Spend_Limit": {
            //             "v": "1000000",
            //             "e": 6,
            //             "f": 1
            //         },
            //         "Executed": {
            //             "v": "0",
            //             "e": 0,
            //             "f": 0
            //         },
            //         "Secured": {
            //             "v": "1000000",
            //             "e": 6,
            //             "f": 1
            //         },
            //         "Version": "0",
            //         "Created": {
            //             "unix": 1728719020,
            //             "us": 315195,
            //             "iso": "2024-10-12 07:43:40.315195",
            //             "tz": "UTC",
            //             "full": "1728719020315195",
            //             "unixms": "1728719020315"
            //         },
            //         "Updated": {
            //             "unix": 1728719020,
            //             "us": 315195,
            //             "iso": "2024-10-12 07:43:40.315195",
            //             "tz": "UTC",
            //             "full": "1728719020315195",
            //             "unixms": "1728719020315"
            //         }
            //     }
            // }
            var order interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseOrder(order, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ellipx#fetchOrder
 * @description fetches information on an order made by the user
 * @param {string} id the order ID as returned by createOrder or fetchOrders
 * @param {string|undefined} symbol not used by ellipx.fetchOrder
 * @param {object} [params] extra parameters specific to the EllipX API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *ellipx) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes526010 := (<-this.LoadMarkets())
            PanicOnError(retRes526010)
            var request interface{} = map[string]interface{} {
                "orderUuid": id,
            }
        
            response:= (<-this.PrivateGetMarketOrderOrderUuid(this.Extend(request, params)))
            PanicOnError(response)
            var data interface{} = this.SafeDict(response, "data", map[string]interface{} {})
        
            ch <- this.ParseOrder(data, nil)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ellipx#fetchOrdersByStatus
 * @description fetches a list of orders placed on the exchange
 * @see https://docs.google.com/document/d/1ZXzTQYffKE_EglTaKptxGQERRnunuLHEMmar7VC9syM/edit?tab=t.0#heading=h.5z2nh2b5s81n
 * @param {string} status 'open' or 'closed', omit for all orders
 * @param {string} symbol unified market symbol
 * @param {int} [since] timestamp in ms of the earliest order
 * @param {int} [limit] the maximum amount of orders to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *ellipx) FetchOrdersByStatus(status interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
        
            retRes652407 := (<-this.LoadMarkets())
            PanicOnError(retRes652407)
            var market interface{} = nil
            var request interface{} = map[string]interface{} {}
            if IsTrue(!IsEqual(symbol, nil)) {
                market = this.Market(symbol)
                var marketId interface{} = GetValue(market, "id")
                AddElementToObject(request, "currencyPair", marketId)
            }
            if IsTrue(!IsEqual(status, nil)) {
                AddElementToObject(request, "Status", status)
            }
        
            response:= (<-this.PrivateGetMarketCurrencyPairOrder(this.Extend(request, params)))
            PanicOnError(response)
            // {
            //     "result": "success",
            //     "data": [
            //         {
            //             "Market_Order__": "mktor-aglvd2-iy5v-enbj-nwrb-scqsnosa",
            //             "Market__": "mkt-lrnp2e-eaor-eobj-ua73-75j6sjxe",
            //             "User__": "usr-...",
            //             "Uniq": "order:1728712511:964332600:0",
            //             "Type": "ask",
            //             "Status": "open",
            //             "Flags": {},
            //             "Amount": {
            //                 "v": "1",
            //                 "e": 8,
            //                 "f": 1.0e-8
            //             },
            //             "Price": {
            //                 "v": "63041306872",
            //                 "e": 6,
            //                 "f": 63041.306872
            //             },
            //             "Spend_Limit": null,
            //             "Executed": {
            //                 "v": "892",
            //                 "e": 8,
            //                 "f": 8.92e-6
            //             },
            //             "Secured": null,
            //             "Version": "3",
            //             "Created": {
            //                 "unix": 1728712510,
            //                 "us": 669096,
            //                 "iso": "2024-10-12 05:55:10.669096",
            //                 "tz": "UTC",
            //                 "full": "1728712510669096",
            //                 "unixms": "1728712510669"
            //             },
            //             "Updated": {
            //                 "unix": 1728712510,
            //                 "us": 669096,
            //                 "iso": "2024-10-12 05:55:10.669096",
            //                 "tz": "UTC",
            //                 "full": "1728712510669096",
            //                 "unixms": "1728712510669"
            //             }
            //         }
            //     ],
            //     "paging": {
            //         "page_no": 1,
            //         "count": "1",
            //         "page_max": 1,
            //         "results_per_page": 20
            //     }
            // }
            var data interface{} = this.SafeValue(response, "data", []interface{}{})
        
            ch <- this.ParseOrders(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ellipx#fetchOrders
 * @description fetches information on multiple orders made by the user
 * @see https://docs.google.com/document/d/1ZXzTQYffKE_EglTaKptxGQERRnunuLHEMmar7VC9syM/edit?tab=t.0#heading=h.5z2nh2b5s81n
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int|undefined} since timestamp in ms of the earliest order
 * @param {int|undefined} limit the maximum amount of orders to fetch
 * @param {object} params extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *ellipx) FetchOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchOrders requires a symbol parameter")))
            }
        
                retRes93475 :=  (<-this.FetchOrdersByStatus(nil, symbol, since, limit, params))
                PanicOnError(retRes93475)
                ch <- retRes93475
                return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ellipx#fetchOpenOrders
 * @description fetches information on open orders made by the user
 * @see https://docs.google.com/document/d/1ZXzTQYffKE_EglTaKptxGQERRnunuLHEMmar7VC9syM/edit?tab=t.0#heading=h.5z2nh2b5s81n
 * @param {string} symbol unified market symbol of the market orders were made in
 * @param {int|undefined} since timestamp in ms of the earliest order
 * @param {int|undefined} limit the maximum amount of orders to fetch
 * @param {object} params extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *ellipx) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchOpenOrders requires a symbol parameter")))
            }
        
                retRes164925 :=  (<-this.FetchOrdersByStatus("open", symbol, since, limit, params))
                PanicOnError(retRes164925)
                ch <- retRes164925
                return nil
        
            }()
            return ch
        }
func  (this *ellipx) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeString(order, "Market_Order__")
    var timestamp interface{} = this.SafeInteger(this.SafeDict(order, "Created"), "unixms")
    var orderType interface{} = this.SafeString(order, "Type")
    var side interface{} = "sell"
    if IsTrue(IsEqual(orderType, "bid")) {
        side = "buy"
    }
    var status interface{} = this.ParseOrderStatus(this.SafeString(order, "Status"))
    var amount interface{} = this.ParseNumber(this.ParseAmount(this.SafeDict(order, "Amount")))
    var price interface{} = this.ParseNumber(this.ParseAmount(this.SafeDict(order, "Price")))
    var typeVar interface{} = Ternary(IsTrue((IsEqual(price, nil))), "market", "limit")
    var executed interface{} = this.ParseNumber(this.ParseAmount(this.SafeDict(order, "Executed")))
    var filled interface{} = executed
    var remaining interface{} = this.ParseNumber(this.ParseAmount(this.SafeDict(order, "Secured")))
    var cost interface{} = this.ParseNumber(this.ParseAmount(this.SafeDict(order, "Total_Spent")))
    var symbol interface{} = Ternary(IsTrue(market), GetValue(market, "symbol"), nil)
    var clientOrderId interface{} = nil
    var timeInForce interface{} = "GTC" // default to Good Till Cancelled
    var postOnly interface{} = false
    var updated interface{} = this.SafeDict(order, "Updated", map[string]interface{} {})
    var lastTradeTimestamp interface{} = this.SafeInteger(updated, "unixms", nil)
    return this.SafeOrder(map[string]interface{} {
        "id": id,
        "clientOrderId": clientOrderId,
        "info": order,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": lastTradeTimestamp,
        "status": this.ParseOrderStatus(status),
        "symbol": symbol,
        "type": typeVar,
        "timeInForce": timeInForce,
        "postOnly": postOnly,
        "side": side,
        "price": price,
        "triggerPrice": nil,
        "average": nil,
        "cost": cost,
        "amount": amount,
        "filled": filled,
        "remaining": remaining,
        "fee": nil,
        "trades": nil,
    }, market)
}
/**
 * @method
 * @name ellipx#cancelOrder
 * @description Cancels an open order on the exchange
 * @see https://docs.google.com/document/d/1ZXzTQYffKE_EglTaKptxGQERRnunuLHEMmar7VC9syM/edit?tab=t.0#heading=h.f1qu1pb1rebn
 * @param {string} id - The order ID to cancel (format: mktor-xxxxx-xxxx-xxxx-xxxx-xxxxxxxx)
 * @param {string} [symbol] - ellipx.cancelOrder does not use the symbol parameter
 * @param {object} [params] - Extra parameters specific to the exchange API
 * @returns {Promise<object>} A Promise that resolves to the canceled order info
 */
func  (this *ellipx) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes945570 := (<-this.LoadMarkets())
            PanicOnError(retRes945570)
            var request interface{} = map[string]interface{} {
                "orderUuid": id,
            }
        
            response:= (<-this.PrivateDeleteMarketOrderOrderUuid(this.Extend(request, params)))
            PanicOnError(response)
            // {
            //     result: "success",
            //     request_id: "887dba33-d11b-43f0-8034-dd7890882cc5",
            //     time: "0.8975801467895508",
            //     data: true,
            //     access: {
            //       "mktor-rf5k5b-5fhf-dmde-wxqj-3y23jeii": {
            //         required: "A",
            //         available: "O",
            //       },
            //     },
            //   }
            // this endpoint always returns true and a warning message if the order cancelled before.
            var warningResponse interface{} = this.SafeValue(response, "warning", nil)
            var statusResponse interface{} = this.SafeBool(response, "data")
            var status interface{} = "canceled"
            if IsTrue(IsTrue(!IsEqual(statusResponse, true)) || IsTrue(!IsEqual(warningResponse, nil))) {
                status = "closed"
            }
        
            ch <- this.SafeOrder(map[string]interface{} {
                "id": id,
                "clientOrderId": nil,
                "info": this.Json(response),
                "timestamp": nil,
                "datetime": nil,
                "lastTradeTimestamp": nil,
                "status": status,
                "symbol": nil,
                "type": nil,
                "timeInForce": nil,
                "postOnly": nil,
                "side": nil,
                "price": nil,
                "triggerPrice": nil,
                "average": nil,
                "cost": nil,
                "amount": nil,
                "filled": nil,
                "remaining": nil,
                "fee": nil,
                "trades": nil,
            }, nil)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ellipx#fetchOrderTrades
 * @description fetch all the trades made from a single order
 * @param {string} id order id
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *ellipx) FetchOrderTrades(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired("fetchMyTrades requires a symbol parameter"))
            }
        
            retRes927683 := (<-this.LoadMarkets())
            PanicOnError(retRes927683)
            var market interface{} = this.Market(symbol)
            var currencyPair interface{} = GetValue(market, "id")
            var request interface{} = map[string]interface{} {
                "Market_Order__": id,
                "currencyPair": currencyPair,
            }
        
            response:= (<-this.PrivateGetMarketCurrencyPairTrade(this.Extend(request, params)))
            PanicOnError(response)
            // {
            //     "result": "success",
            //     "request_id": "fc5be99d-d085-46f8-9228-e46d0996f112",
            //     "time": 0.030913114547729492,
            //     "data": [
            //         {
            //             "id": "DOGE_USDC:1731505789:911642994:0",
            //             "pair": "DOGE_USDC",
            //             "bid": {
            //                 "id": "mktor-xb3ne5-emm5-fx7e-xggk-fyfoiye4"
            //             },
            //             "ask": {
            //                 "id": "mktor-oxmac4-mtkf-gi3o-mamg-u2cboqe4"
            //             },
            //             "type": "bid",
            //             "amount": {
            //                 "v": "334609419",
            //                 "e": 8,
            //                 "f": 3.34609419
            //             },
            //             "price": {
            //                 "v": "410673",
            //                 "e": 6,
            //                 "f": 0.410673
            //             },
            //             "date": {
            //                 "unix": 1731505789,
            //                 "us": 911642,
            //                 "iso": "2024-11-13 13:49:49.911642",
            //                 "tz": "UTC",
            //                 "full": "1731505789911642",
            //                 "unixms": "1731505789911"
            //             }
            //         },
            //         {
            //             "id": "DOGE_USDC:1731505789:911642994:4",
            //             "pair": "DOGE_USDC",
            //             "bid": {
            //                 "id": "mktor-xb3ne5-emm5-fx7e-xggk-fyfoiye4"
            //             },
            //             "ask": {
            //                 "id": "mktor-cmtztk-3z3n-gupp-uqdg-74g4wjfq"
            //             },
            //             "type": "bid",
            //             "amount": {
            //                 "v": "145453950",
            //                 "e": 8,
            //                 "f": 1.4545395
            //             },
            //             "price": {
            //                 "v": "412589",
            //                 "e": 6,
            //                 "f": 0.412589
            //             },
            //             "date": {
            //                 "unix": 1731505789,
            //                 "us": 911642,
            //                 "iso": "2024-11-13 13:49:49.911642",
            //                 "tz": "UTC",
            //                 "full": "1731505789911642",
            //                 "unixms": "1731505789911"
            //             }
            //         },
            //         {
            //             "id": "DOGE_USDC:1731505789:911642994:2",
            //             "pair": "DOGE_USDC",
            //             "bid": {
            //                 "id": "mktor-xb3ne5-emm5-fx7e-xggk-fyfoiye4"
            //             },
            //             "ask": {
            //                 "id": "mktor-6tyslh-b33b-flnm-2ata-acjkco4y"
            //             },
            //             "type": "bid",
            //             "amount": {
            //                 "v": "587627076",
            //                 "e": 8,
            //                 "f": 5.87627076
            //             },
            //             "price": {
            //                 "v": "411005",
            //                 "e": 6,
            //                 "f": 0.411005
            //             },
            //             "date": {
            //                 "unix": 1731505789,
            //                 "us": 911642,
            //                 "iso": "2024-11-13 13:49:49.911642",
            //                 "tz": "UTC",
            //                 "full": "1731505789911642",
            //                 "unixms": "1731505789911"
            //             }
            //         },
            //         {
            //             "id": "DOGE_USDC:1731505789:911642994:1",
            //             "pair": "DOGE_USDC",
            //             "bid": {
            //                 "id": "mktor-xb3ne5-emm5-fx7e-xggk-fyfoiye4"
            //             },
            //             "ask": {
            //                 "id": "mktor-ihpjlj-5ufj-dm5l-fmud-oftkqcgu"
            //             },
            //             "type": "bid",
            //             "amount": {
            //                 "v": "475845734",
            //                 "e": 8,
            //                 "f": 4.75845734
            //             },
            //             "price": {
            //                 "v": "410830",
            //                 "e": 6,
            //                 "f": 0.41083
            //             },
            //             "date": {
            //                 "unix": 1731505789,
            //                 "us": 911642,
            //                 "iso": "2024-11-13 13:49:49.911642",
            //                 "tz": "UTC",
            //                 "full": "1731505789911642",
            //                 "unixms": "1731505789911"
            //             }
            //         },
            //         {
            //             "id": "DOGE_USDC:1731505789:911642994:3",
            //             "pair": "DOGE_USDC",
            //             "bid": {
            //                 "id": "mktor-xb3ne5-emm5-fx7e-xggk-fyfoiye4"
            //             },
            //             "ask": {
            //                 "id": "mktor-d2uyb3-nzsj-aevn-dikr-tq3sxhre"
            //             },
            //             "type": "bid",
            //             "amount": {
            //                 "v": "641013461",
            //                 "e": 8,
            //                 "f": 6.41013461
            //             },
            //             "price": {
            //                 "v": "411846",
            //                 "e": 6,
            //                 "f": 0.411846
            //             },
            //             "date": {
            //                 "unix": 1731505789,
            //                 "us": 911642,
            //                 "iso": "2024-11-13 13:49:49.911642",
            //                 "tz": "UTC",
            //                 "full": "1731505789911642",
            //                 "unixms": "1731505789911"
            //             }
            //         }
            //     ],
            //     "access": {
            //         "mkt-xrkg5l-akjz-cxxl-3a2e-mul5gfo4": {
            //             "required": "r",
            //             "available": "?"
            //         },
            //         "mktor-xb3ne5-emm5-fx7e-xggk-fyfoiye4": {
            //             "required": "R",
            //             "available": "O"
            //         }
            //     },
            //     "paging": {
            //         "page_no": 1,
            //         "count": "5",
            //         "page_max": 1,
            //         "results_per_page": 20
            //     }
            // }
            var data interface{} = this.SafeList(response, "data")
        
            ch <- this.ParseTrades(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ellipx#fetchDepositAddress
 * @description fetches a crypto deposit address for a specific currency
 * @see https://docs.google.com/document/d/1ZXzTQYffKE_EglTaKptxGQERRnunuLHEMmar7VC9syM/edit?tab=t.0#heading=h.k7qe5aricayh
 * @param {string} code unified currency code (e.g. "BTC", "ETH", "USDT")
 * @param {object} [params] extra parameters specific to the EllipX API endpoint
 * @returns {object} an address structure {
 *     'currency': string, // unified currency code
 *     'address': string, // the address for deposits
 *     'tag': string|undefined, // tag/memo for deposits if needed
 *     'network': object, // network object from currency info
 *     'info': object // raw response from exchange
 * }
 * @throws {ExchangeError} if currency does not support deposits
 */
func  (this *ellipx) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes29341 := (<-this.LoadMarkets())
            PanicOnError(retRes29341)
            var currency interface{} = this.Currency(code)
            var network interface{} = this.SafeValue(GetValue(currency, "info"), "Crypto_Chain", nil)
            var request interface{} = map[string]interface{} {
                "Crypto_Token__": this.SafeString(network, "Crypto_Token__"),
                "Crypto_Chain__": this.SafeString(network, "Crypto_Chain__"),
            }
        
            response:= (<-this.PrivatePostCryptoAddressFetch(this.Extend(request, params)))
            PanicOnError(response)
            var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
            var address interface{} = this.SafeString(data, "Address")
            var tag interface{} = this.SafeString(data, "memo")
            this.CheckAddress(address)
        
            ch <- map[string]interface{} {
                "currency": code,
                "address": address,
                "tag": tag,
                "network": network,
                "info": response,
            }
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ellipx#fetchTradingFee
 * @description Fetches the current trading fees (maker and taker) applicable to the user.
 * @see https://docs.google.com/document/d/1ZXzTQYffKE_EglTaKptxGQERRnunuLHEMmar7VC9syM/edit?tab=t.0#heading=h.kki5jay2c8it
 * @param {string} [symbol] Not used by EllipX as fees are not symbol-specific.
 * @param {object} [params] Extra parameters specific to the EllipX API endpoint.
 * @returns {Promise<object>} A promise resolving to a unified trading fee structure:
 * {
 *     'info': object,        // the raw response from the exchange
 *     'symbol': undefined,   // symbol is not used for this exchange
 *     'maker': number,       // maker fee rate in decimal form
 *     'taker': number,       // taker fee rate in decimal form
 *     'percentage': true,    // indicates fees are in percentage
 *     'tierBased': false,    // indicates fees do not vary by volume tiers
 * }
 */
func  (this *ellipx) FetchTradingFee(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes979061 := (<-this.LoadMarkets())
            PanicOnError(retRes979061)
        
            response:= (<-this.PrivateGetMarketTradeFeeQuery(params))
            PanicOnError(response)
            //
            // Example response:
            // {
            //     "result": "success",
            //     "data": {
            //         "maker": 15.0,      // in basis points
            //         "taker": 25.0,      // in basis points
            //         "volume": 123456.78,
            //         "promo": {
            //             // promotional discounts if any
            //         }
            //     }
            // }
            //
            var data interface{} = this.SafeValue(response, "data", map[string]interface{} {})
            var maker interface{} = this.SafeNumber(data, "maker") // in basis points
            var taker interface{} = this.SafeNumber(data, "taker") // in basis points
            var makerFee interface{} = Ternary(IsTrue((!IsEqual(maker, nil))), Divide(maker, 10000), nil)
            var takerFee interface{} = Ternary(IsTrue((!IsEqual(taker, nil))), Divide(taker, 10000), nil)
        
            ch <- map[string]interface{} {
                "info": response,
                "symbol": nil,
                "maker": makerFee,
                "taker": takerFee,
                "percentage": true,
                "tierBased": true,
            }
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name ellipx#withdraw
 * @description Make a withdrawal request
 * @see https://docs.google.com/document/d/1ZXzTQYffKE_EglTaKptxGQERRnunuLHEMmar7VC9syM/edit?tab=t.0#heading=h.zegupoa8g4t9
 * @param {string} code Currency code
 * @param {number} amount Amount to withdraw
 * @param {string} address Destination wallet address
 * @param {string} [tag] Additional tag/memo for currencies that require it
 * @param {object} params Extra parameters specific to the EllipX API endpoint (Crypto_Chain__, Unit__)
 * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
 */
func  (this *ellipx) Withdraw(code interface{}, amount interface{}, address interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    tag := GetArg(optionalArgs, 0, nil)
            _ = tag
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            this.CheckAddress(address)
        
            retRes52300 := (<-this.LoadMarkets())
            PanicOnError(retRes52300)
            var currency interface{} = this.Currency(code)
            var networks interface{} = this.SafeValue(currency, "networks")
            if IsTrue(IsEqual(networks, nil)) {
                panic(NotSupported(Add(Add(Add(this.Id, " withdraw() for "), code), " is not supported")))
            }
        
            chainsResponse:= (<-this.PrivateGetUnitCurrency(map[string]interface{} {
            "currency": GetValue(currency, "code"),
        }))
            PanicOnError(chainsResponse) // fetch Unit__ params for currency
            var chainsData interface{} = this.SafeValue(chainsResponse, "data", []interface{}{})
            var unit interface{} = this.SafeString(chainsData, "Unit__")
            // check params again and omit params
            this.Omit(params, "Unit__")
            this.Omit(params, "Crypto_Chain__")
            var amountString interface{} = ToString(amount)
            var request interface{} = map[string]interface{} {
                "Unit__": unit,
                "amount": amountString,
                "address": address,
                "Crypto_Chain__": GetValue(networks, "id"),
            }
            if IsTrue(!IsEqual(tag, nil)) {
                AddElementToObject(request, "memo", tag)
            }
        
            response:= (<-this.PrivatePostCryptoDisbursementWithdraw(this.Extend(request, params)))
            PanicOnError(response)
            // {
            //     Crypto_Disbursement__: "crdsb-4pw3kg-ipn5-amvb-da4n-6xncy4r4",
            //     Crypto_Token__: "crtok-dnehz4-wbgv-bunf-iyd3-m7gtsz2q",
            //     Crypto_Chain__: "chain-kjfvwn-l2xn-eclc-ul5d-mb6fu5hm",
            //     User__: "usr-5oint6-ozpr-alfp-2wxi-zgbm4osy",
            //     Value: {
            //       v: "1000000000",
            //       e: "8",
            //       f: "10",
            //     },
            //     Value_USD: "4.08723",
            //     Address: "D6z62LUwyNBi3QbPkzW8C4m7VDAgu9wb2Z",
            //     Status: "pending",
            //     Transaction: null,
            //     Requested: {
            //       unix: "1731570982",
            //       us: "203569",
            //       iso: "2024-11-14 07:56:22.203569",
            //       tz: "UTC",
            //       full: "1731570982203569",
            //       unixms: "1731570982203",
            //     },
            //     Scheduled: null,
            //     Processed: null,
            //     Amount: {
            //       value: "10.00000000",
            //       value_int: "1000000000",
            //       value_disp: "10.00000000",
            //       value_xint: {
            //         v: "1000000000",
            //         e: "8",
            //         f: "10",
            //       },
            //       display: "10.00000000DOGE",
            //       display_short: "10.00000000DOGE",
            //       currency: "DOGE",
            //       unit: "DOGE",
            //       has_vat: false,
            //       tax_profile: null,
            //       raw: {
            //         value: "10.00000000",
            //         value_int: "1000000000",
            //         value_disp: "10.00000000",
            //         value_xint: {
            //           v: "1000000000",
            //           e: "8",
            //           f: "10",
            //         },
            //         display: "10.00000000DOGE",
            //         display_short: "10.00000000DOGE",
            //         currency: "DOGE",
            //         unit: "DOGE",
            //         has_vat: false,
            //         tax_profile: null,
            //       },
            //       tax: {
            //         value: "10.00000000",
            //         value_int: "1000000000",
            //         value_disp: "10.00000000",
            //         value_xint: {
            //           v: "1000000000",
            //           e: "8",
            //           f: "10",
            //         },
            //         display: "10.00000000DOGE",
            //         display_short: "10.00000000DOGE",
            //         currency: "DOGE",
            //         unit: "DOGE",
            //         has_vat: true,
            //         tax_profile: null,
            //       },
            //       tax_only: {
            //         value: "0.000",
            //         value_int: "0",
            //         value_disp: "0",
            //         value_xint: {
            //           v: "0",
            //           e: "3",
            //           f: "0",
            //         },
            //         display: "0",
            //         display_short: "0",
            //         currency: "JPY",
            //         unit: "JPY",
            //         has_vat: false,
            //         tax_profile: null,
            //       },
            //       tax_rate: "0",
            //     },
            //   }
            var data interface{} = this.SafeDict(response, "data")
            var amountResponse interface{} = this.SafeDict(data, "Amount")
            var requested interface{} = this.SafeDict(data, "Requested")
            var processed interface{} = this.SafeDict(data, "Processed")
            var withdrawId interface{} = this.SafeString(data, "Crypto_Disbursement__")
            var timestamp interface{} = this.SafeInteger(requested, "unixms")
        
            ch <- map[string]interface{} {
                "info": response,
                "id": withdrawId,
                "txid": nil,
                "timestamp": timestamp,
                "datetime": this.Iso8601(timestamp),
                "network": this.SafeString(data, "Crypto_Chain__"),
                "address": this.SafeString(data, "Address"),
                "addressTo": this.SafeString(data, "Address"),
                "addressFrom": nil,
                "tag": tag,
                "tagTo": tag,
                "tagFrom": nil,
                "type": "withdrawal",
                "amount": this.SafeNumber(amountResponse, "value"),
                "currency": code,
                "status": this.ParseTransactionStatus(this.SafeString(data, "Status")),
                "updated": this.SafeTimestamp(processed, "unix"),
                "internal": false,
                "comment": nil,
                "fee": map[string]interface{} {
                    "currency": code,
                    "cost": nil,
                    "rate": nil,
                },
            }
            return nil
        
            }()
            return ch
        }
func  (this *ellipx) ParseTransactionStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "pending": "pending",
        "completed": "ok",
        "failed": "failed",
        "cancelled": "canceled",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *ellipx) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "pending": "open",
        "running": "open",
        "post-pending": "open",
        "open": "open",
        "stop": "open",
        "invalid": "rejected",
        "done": "closed",
        "cancel": "canceled",
        "canceled": "canceled",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *ellipx) ParseAmount(amount interface{}) interface{}  {
    var v interface{} = this.SafeString(amount, "v", nil)
    var e interface{} = this.SafeInteger(amount, "e", nil)
    if IsTrue(IsTrue(IsEqual(v, nil)) || IsTrue(IsEqual(e, nil))) {
        return nil
    }
    precise := NewPrecise(v)
    precise.Decimals = e
    precise.Reduce()
    var amountString interface{} = precise.ToString()
    return amountString
}
func  (this *ellipx) ToAmount(amount interface{}, precision interface{}) interface{}  {
    var v interface{} = ToString(amount)
    var e interface{} = precision
    return map[string]interface{} {
        "v": v,
        "e": e,
    }
}
func  (this *ellipx) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    // {
    //     "code": 404,
    //     "error": "Not Found: Crypto\\Token(US)",
    //     "exception": "Exception\\NotFound",
    //     "message": "[I18N:error_not_found]",
    //     "request": "cc83738a-2438-4f53-ae44-f15306c07f32",
    //     "result": "error",
    //     "time": 0.0089569091796875,
    //     "token": "error_not_found"
    // }
    var errorCode interface{} = this.SafeString(response, "code")
    var message interface{} = this.SafeString(response, "message")
    if IsTrue(!IsEqual(errorCode, nil)) {
        this.ThrowExactlyMatchedException(GetValue(this.Exceptions, "exact"), errorCode, message)
        panic(ExchangeError(Add(Add(this.Id, " "), message)))
    }
    return nil
}


func (this *ellipx) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
