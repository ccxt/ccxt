package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type coinone struct {
    Exchange

}

func NewCoinoneCore() coinone {
   p := coinone{}
   setDefaults(&p)
   return p
}

func  (this *coinone) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "coinone",
        "name": "CoinOne",
        "countries": []interface{}{"KR"},
        "rateLimit": 50,
        "version": "v2",
        "pro": false,
        "has": map[string]interface{} {
            "CORS": nil,
            "spot": true,
            "margin": false,
            "swap": false,
            "future": false,
            "option": false,
            "addMargin": false,
            "cancelOrder": true,
            "closeAllPositions": false,
            "closePosition": false,
            "createMarketOrder": false,
            "createOrder": true,
            "createReduceOnlyOrder": false,
            "createStopLimitOrder": false,
            "createStopMarketOrder": false,
            "createStopOrder": false,
            "fetchBalance": true,
            "fetchBorrowRateHistories": false,
            "fetchBorrowRateHistory": false,
            "fetchClosedOrders": false,
            "fetchCrossBorrowRate": false,
            "fetchCrossBorrowRates": false,
            "fetchCurrencies": true,
            "fetchDepositAddress": false,
            "fetchDepositAddresses": true,
            "fetchDepositAddressesByNetwork": false,
            "fetchFundingHistory": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchIndexOHLCV": false,
            "fetchIsolatedBorrowRate": false,
            "fetchIsolatedBorrowRates": false,
            "fetchLeverage": false,
            "fetchLeverageTiers": false,
            "fetchMarginMode": false,
            "fetchMarkets": true,
            "fetchMarkOHLCV": false,
            "fetchMyTrades": true,
            "fetchOpenInterestHistory": false,
            "fetchOpenOrders": true,
            "fetchOrder": true,
            "fetchOrderBook": true,
            "fetchPosition": false,
            "fetchPositionHistory": false,
            "fetchPositionMode": false,
            "fetchPositions": false,
            "fetchPositionsForSymbol": false,
            "fetchPositionsHistory": false,
            "fetchPositionsRisk": false,
            "fetchPremiumIndexOHLCV": false,
            "fetchTicker": true,
            "fetchTickers": true,
            "fetchTrades": true,
            "reduceMargin": false,
            "setLeverage": false,
            "setMarginMode": false,
            "setPositionMode": false,
            "ws": true,
        },
        "urls": map[string]interface{} {
            "logo": "https://user-images.githubusercontent.com/1294454/38003300-adc12fba-323f-11e8-8525-725f53c4a659.jpg",
            "api": map[string]interface{} {
                "rest": "https://api.coinone.co.kr",
                "v2Public": "https://api.coinone.co.kr/public/v2",
                "v2Private": "https://api.coinone.co.kr/v2",
                "v2_1Private": "https://api.coinone.co.kr/v2.1",
            },
            "www": "https://coinone.co.kr",
            "doc": "https://doc.coinone.co.kr",
        },
        "requiredCredentials": map[string]interface{} {
            "apiKey": true,
            "secret": true,
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": []interface{}{"orderbook", "ticker", "ticker_utc", "trades"},
            },
            "v2Public": map[string]interface{} {
                "get": []interface{}{"range_units", "markets/{quote_currency}", "markets/{quote_currency}/{target_currency}", "orderbook/{quote_currency}/{target_currency}", "trades/{quote_currency}/{target_currency}", "ticker_new/{quote_currency}", "ticker_new/{quote_currency}/{target_currency}", "ticker_utc_new/{quote_currency}", "ticker_utc_new/{quote_currency}/{target_currency}", "currencies", "currencies/{currency}", "chart/{quote_currency}/{target_currency}"},
            },
            "private": map[string]interface{} {
                "post": []interface{}{"account/deposit_address", "account/btc_deposit_address", "account/balance", "account/daily_balance", "account/user_info", "account/virtual_account", "order/cancel_all", "order/cancel", "order/limit_buy", "order/limit_sell", "order/complete_orders", "order/limit_orders", "order/order_info", "transaction/auth_number", "transaction/history", "transaction/krw/history", "transaction/btc", "transaction/coin"},
            },
            "v2Private": map[string]interface{} {
                "post": []interface{}{"account/balance", "account/deposit_address", "account/user_info", "account/virtual_account", "order/cancel", "order/limit_buy", "order/limit_sell", "order/limit_orders", "order/complete_orders", "order/query_order", "transaction/auth_number", "transaction/btc", "transaction/history", "transaction/krw/history"},
            },
            "v2_1Private": map[string]interface{} {
                "post": []interface{}{"account/balance/all", "account/balance", "account/trade_fee", "account/trade_fee/{quote_currency}/{target_currency}", "order/limit", "order/cancel", "order/cancel/all", "order/open_orders", "order/open_orders/all", "order/complete_orders", "order/complete_orders/all", "order/info", "transaction/krw/history", "transaction/coin/history", "transaction/coin/withdrawal/limit"},
            },
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "tierBased": false,
                "percentage": true,
                "taker": 0.002,
                "maker": 0.002,
            },
        },
        "features": map[string]interface{} {
            "spot": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": false,
                    "triggerPriceType": nil,
                    "triggerDirection": false,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": false,
                        "FOK": false,
                        "PO": false,
                        "GTD": false,
                    },
                    "hedged": false,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyByCost": false,
                    "marketBuyRequiresPrice": false,
                    "selfTradePrevention": false,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": map[string]interface{} {
                    "marginMode": false,
                    "limit": 100,
                    "daysBack": 100000,
                    "untilDays": 100000,
                    "symbolRequired": true,
                },
                "fetchOrder": map[string]interface{} {
                    "marginMode": false,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchOpenOrders": map[string]interface{} {
                    "marginMode": false,
                    "limit": nil,
                    "trigger": false,
                    "trailing": false,
                    "symbolRequired": true,
                },
                "fetchOrders": nil,
                "fetchClosedOrders": nil,
                "fetchOHLCV": nil,
            },
            "swap": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
        "precisionMode": TICK_SIZE,
        "exceptions": map[string]interface{} {
            "104": OrderNotFound,
            "107": BadRequest,
            "108": BadSymbol,
            "405": OnMaintenance,
        },
        "commonCurrencies": map[string]interface{} {
            "SOC": "Soda Coin",
        },
    })
}
/**
 * @method
 * @name coinone#fetchCurrencies
 * @description fetches all available currencies on an exchange
 * @see https://docs.coinone.co.kr/reference/currencies
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an associative dictionary of currencies
 */
func  (this *coinone) FetchCurrencies(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            response:= (<-this.V2PublicGetCurrencies(params))
            PanicOnError(response)
            //
            //     {
            //         "result": "success",
            //         "error_code": "0",
            //         "server_time": 1701054555578,
            //         "currencies": [
            //           {
            //             "name": "Polygon",
            //             "symbol": "MATIC",
            //             "deposit_status": "normal",
            //             "withdraw_status": "normal",
            //             "deposit_confirm_count": 150,
            //             "max_precision": 8,
            //             "deposit_fee": "0.0",
            //             "withdrawal_min_amount": "1.0",
            //             "withdrawal_fee": "3.0"
            //           }
            //         ]
            //     }
            //
            var result interface{} = map[string]interface{} {}
            var currencies interface{} = this.SafeList(response, "currencies", []interface{}{})
            for i := 0; IsLessThan(i, GetArrayLength(currencies)); i++ {
                var entry interface{} = GetValue(currencies, i)
                var id interface{} = this.SafeString(entry, "symbol")
                var name interface{} = this.SafeString(entry, "name")
                var code interface{} = this.SafeCurrencyCode(id)
                var withdrawStatus interface{} = this.SafeString(entry, "withdraw_status", "")
                var depositStatus interface{} = this.SafeString(entry, "deposit_status", "")
                var isWithdrawEnabled interface{} = IsEqual(withdrawStatus, "normal")
                var isDepositEnabled interface{} = IsEqual(depositStatus, "normal")
                AddElementToObject(result, code, map[string]interface{} {
            "id": id,
            "code": code,
            "info": entry,
            "name": name,
            "active": IsTrue(isWithdrawEnabled) && IsTrue(isDepositEnabled),
            "deposit": isDepositEnabled,
            "withdraw": isWithdrawEnabled,
            "fee": this.SafeNumber(entry, "withdrawal_fee"),
            "precision": this.ParseNumber(this.ParsePrecision(this.SafeString(entry, "max_precision"))),
            "limits": map[string]interface{} {
                "amount": map[string]interface{} {
                    "min": nil,
                    "max": nil,
                },
                "withdraw": map[string]interface{} {
                    "min": this.SafeNumber(entry, "withdrawal_min_amount"),
                    "max": nil,
                },
            },
            "networks": map[string]interface{} {},
        })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinone#fetchMarkets
 * @description retrieves data on all markets for coinone
 * @see https://docs.coinone.co.kr/v1.0/reference/tickers
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object[]} an array of objects representing market data
 */
func  (this *coinone) FetchMarkets(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "quote_currency": "KRW",
            }
        
            response:= (<-this.V2PublicGetTickerNewQuoteCurrency(request))
            PanicOnError(response)
            //
            //     {
            //         "result": "success",
            //         "error_code": "0",
            //         "server_time": 1701067923060,
            //         "tickers": [
            //             {
            //                 "quote_currency": "krw",
            //                 "target_currency": "stg",
            //                 "timestamp": 1701067920001,
            //                 "high": "667.5",
            //                 "low": "667.5",
            //                 "first": "667.5",
            //                 "last": "667.5",
            //                 "quote_volume": "0.0",
            //                 "target_volume": "0.0",
            //                 "best_asks": [
            //                     {
            //                         "price": "777.0",
            //                         "qty": "73.9098"
            //                     }
            //                 ],
            //                 "best_bids": [
            //                     {
            //                         "price": "690.8",
            //                         "qty": "40.7768"
            //                     }
            //                 ],
            //                 "id": "1701067920001001"
            //             }
            //         ]
            //     }
            //
            var tickers interface{} = this.SafeList(response, "tickers", []interface{}{})
            var result interface{} = []interface{}{}
            for i := 0; IsLessThan(i, GetArrayLength(tickers)); i++ {
                var entry interface{} = this.SafeValue(tickers, i)
                var id interface{} = this.SafeString(entry, "id")
                var baseId interface{} = this.SafeStringUpper(entry, "target_currency")
                var quoteId interface{} = this.SafeStringUpper(entry, "quote_currency")
                var base interface{} = this.SafeCurrencyCode(baseId)
                var quote interface{} = this.SafeCurrencyCode(quoteId)
                AppendToArray(&result,map[string]interface{} {
                    "id": id,
                    "symbol": Add(Add(base, "/"), quote),
                    "base": base,
                    "quote": quote,
                    "settle": nil,
                    "baseId": baseId,
                    "quoteId": quoteId,
                    "settleId": nil,
                    "type": "spot",
                    "spot": true,
                    "margin": false,
                    "swap": false,
                    "future": false,
                    "option": false,
                    "active": nil,
                    "contract": false,
                    "linear": nil,
                    "inverse": nil,
                    "contractSize": nil,
                    "expiry": nil,
                    "expiryDatetime": nil,
                    "strike": nil,
                    "optionType": nil,
                    "precision": map[string]interface{} {
                        "amount": this.ParseNumber("1e-4"),
                        "price": this.ParseNumber("1e-4"),
                        "cost": this.ParseNumber("1e-8"),
                    },
                    "limits": map[string]interface{} {
                        "leverage": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "amount": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "price": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                        "cost": map[string]interface{} {
                            "min": nil,
                            "max": nil,
                        },
                    },
                    "created": nil,
                    "info": entry,
                })
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *coinone) ParseBalance(response interface{}) interface{}  {
    var result interface{} = map[string]interface{} {
        "info": response,
    }
    var balances interface{} = this.Omit(response, []interface{}{"errorCode", "result", "normalWallets"})
    var currencyIds interface{} = ObjectKeys(balances)
    for i := 0; IsLessThan(i, GetArrayLength(currencyIds)); i++ {
        var currencyId interface{} = GetValue(currencyIds, i)
        var balance interface{} = GetValue(balances, currencyId)
        var code interface{} = this.SafeCurrencyCode(currencyId)
        var account interface{} = this.Account()
        AddElementToObject(account, "free", this.SafeString(balance, "avail"))
        AddElementToObject(account, "total", this.SafeString(balance, "balance"))
        AddElementToObject(result, code, account)
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name coinone#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://docs.coinone.co.kr/v1.0/reference/v21
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *coinone) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes612852 := (<-this.LoadMarkets())
            PanicOnError(retRes612852)
        
            response:= (<-this.V2PrivatePostAccountBalance(params))
            PanicOnError(response)
        
            ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinone#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://docs.coinone.co.kr/v1.0/reference/orderbook
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *coinone) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes431401 := (<-this.LoadMarkets())
            PanicOnError(retRes431401)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "quote_currency": GetValue(market, "quote"),
                "target_currency": GetValue(market, "base"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "size", limit) // only support 5, 10, 15, 16
            }
        
            response:= (<-this.V2PublicGetOrderbookQuoteCurrencyTargetCurrency(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "result": "success",
            //         "error_code": "0",
            //         "timestamp": 1701071108673,
            //         "id": "1701071108673001",
            //         "quote_currency": "KRW",
            //         "target_currency": "BTC",
            //         "order_book_unit": "0.0",
            //         "bids": [
            //             {
            //                 "price": "50048000",
            //                 "qty": "0.01080229"
            //             }
            //         ],
            //         "asks": [
            //             {
            //                 "price": "50058000",
            //                 "qty": "0.00272592"
            //             }
            //         ]
            //     }
            //
            var timestamp interface{} = this.SafeInteger(response, "timestamp")
        
            ch <- this.ParseOrderBook(response, GetValue(market, "symbol"), timestamp, "bids", "asks", "price", "qty")
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinone#fetchTickers
 * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
 * @see https://docs.coinone.co.kr/v1.0/reference/tickers
 * @see https://docs.coinone.co.kr/v1.0/reference/ticker
 * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *coinone) FetchTickers(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbols := GetArg(optionalArgs, 0, nil)
            _ = symbols
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes869514 := (<-this.LoadMarkets())
            PanicOnError(retRes869514)
            symbols = this.MarketSymbols(symbols)
            var request interface{} = map[string]interface{} {
                "quote_currency": "KRW",
            }
            var market interface{} = nil
            var response interface{} = nil
            if IsTrue(!IsEqual(symbols, nil)) {
                var first interface{} = this.SafeString(symbols, 0)
                market = this.Market(first)
                AddElementToObject(request, "quote_currency", GetValue(market, "quote"))
                AddElementToObject(request, "target_currency", GetValue(market, "base"))
                
        response = (<-this.V2PublicGetTickerNewQuoteCurrencyTargetCurrency(this.Extend(request, params)))
                PanicOnError(response)
            } else {
                
        response = (<-this.V2PublicGetTickerNewQuoteCurrency(this.Extend(request, params)))
                PanicOnError(response)
            }
            //
            //     {
            //         "result": "success",
            //         "error_code": "0",
            //         "server_time": 1701073358487,
            //         "tickers": [
            //             {
            //                 "quote_currency": "krw",
            //                 "target_currency": "btc",
            //                 "timestamp": 1701073357818,
            //                 "high": "50543000.0",
            //                 "low": "49945000.0",
            //                 "first": "50487000.0",
            //                 "last": "50062000.0",
            //                 "quote_volume": "11349804285.3859",
            //                 "target_volume": "226.07268994",
            //                 "best_asks": [
            //                     {
            //                         "price": "50081000.0",
            //                         "qty": "0.18471358"
            //                     }
            //                 ],
            //                 "best_bids": [
            //                     {
            //                         "price": "50062000.0",
            //                         "qty": "0.04213455"
            //                     }
            //                 ],
            //                 "id": "1701073357818001"
            //             }
            //         ]
            //     }
            //
            var data interface{} = this.SafeList(response, "tickers", []interface{}{})
        
            ch <- this.ParseTickers(data, symbols)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinone#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://docs.coinone.co.kr/v1.0/reference/ticker
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *coinone) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes270704 := (<-this.LoadMarkets())
            PanicOnError(retRes270704)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "quote_currency": GetValue(market, "quote"),
                "target_currency": GetValue(market, "base"),
            }
        
            response:= (<-this.V2PublicGetTickerNewQuoteCurrencyTargetCurrency(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "result": "success",
            //         "error_code": "0",
            //         "server_time": 1701073358487,
            //         "tickers": [
            //             {
            //                 "quote_currency": "krw",
            //                 "target_currency": "btc",
            //                 "timestamp": 1701073357818,
            //                 "high": "50543000.0",
            //                 "low": "49945000.0",
            //                 "first": "50487000.0",
            //                 "last": "50062000.0",
            //                 "quote_volume": "11349804285.3859",
            //                 "target_volume": "226.07268994",
            //                 "best_asks": [
            //                     {
            //                         "price": "50081000.0",
            //                         "qty": "0.18471358"
            //                     }
            //                 ],
            //                 "best_bids": [
            //                     {
            //                         "price": "50062000.0",
            //                         "qty": "0.04213455"
            //                     }
            //                 ],
            //                 "id": "1701073357818001"
            //             }
            //         ]
            //     }
            //
            var data interface{} = this.SafeList(response, "tickers", []interface{}{})
            var ticker interface{} = this.SafeDict(data, 0, map[string]interface{} {})
        
            ch <- this.ParseTicker(ticker, market)
            return nil
        
            }()
            return ch
        }
func  (this *coinone) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "quote_currency": "krw",
    //         "target_currency": "btc",
    //         "timestamp": 1701073357818,
    //         "high": "50543000.0",
    //         "low": "49945000.0",
    //         "first": "50487000.0",
    //         "last": "50062000.0",
    //         "quote_volume": "11349804285.3859",
    //         "target_volume": "226.07268994",
    //         "best_asks": [
    //             {
    //                 "price": "50081000.0",
    //                 "qty": "0.18471358"
    //             }
    //         ],
    //         "best_bids": [
    //             {
    //                 "price": "50062000.0",
    //                 "qty": "0.04213455"
    //             }
    //         ],
    //         "id": "1701073357818001"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger(ticker, "timestamp")
    var last interface{} = this.SafeString(ticker, "last")
    var asks interface{} = this.SafeList(ticker, "best_asks", []interface{}{})
    var bids interface{} = this.SafeList(ticker, "best_bids", []interface{}{})
    var baseId interface{} = this.SafeString(ticker, "target_currency")
    var quoteId interface{} = this.SafeString(ticker, "quote_currency")
    var base interface{} = this.SafeCurrencyCode(baseId)
    var quote interface{} = this.SafeCurrencyCode(quoteId)
    return this.SafeTicker(map[string]interface{} {
        "symbol": Add(Add(base, "/"), quote),
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeString(ticker, "high"),
        "low": this.SafeString(ticker, "low"),
        "bid": this.SafeString(bids, "price"),
        "bidVolume": this.SafeString(bids, "qty"),
        "ask": this.SafeString(asks, "price"),
        "askVolume": this.SafeString(asks, "qty"),
        "vwap": nil,
        "open": this.SafeString(ticker, "first"),
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": nil,
        "percentage": nil,
        "average": nil,
        "baseVolume": this.SafeString(ticker, "target_volume"),
        "quoteVolume": this.SafeString(ticker, "quote_volume"),
        "info": ticker,
    }, market)
}
func  (this *coinone) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // fetchTrades (public)
    //
    //     {
    //         "id": "1701075265708001",
    //         "timestamp": 1701075265708,
    //         "price": "50020000",
    //         "qty": "0.00155177",
    //         "is_seller_maker": false
    //     }
    //
    // fetchMyTrades (private)
    //
    //     {
    //         "timestamp": "1416561032",
    //         "price": "419000.0",
    //         "type": "bid",
    //         "qty": "0.001",
    //         "feeRate": "-0.0015",
    //         "fee": "-0.0000015",
    //         "orderId": "E84A1AC2-8088-4FA0-B093-A3BCDB9B3C85"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeInteger(trade, "timestamp")
    market = this.SafeMarket(nil, market)
    var isSellerMaker interface{} = this.SafeBool(trade, "is_seller_maker")
    var side interface{} = nil
    if IsTrue(!IsEqual(isSellerMaker, nil)) {
        side = Ternary(IsTrue(isSellerMaker), "sell", "buy")
    }
    var priceString interface{} = this.SafeString(trade, "price")
    var amountString interface{} = this.SafeString(trade, "qty")
    var orderId interface{} = this.SafeString(trade, "orderId")
    var feeCostString interface{} = this.SafeString(trade, "fee")
    var fee interface{} = nil
    if IsTrue(!IsEqual(feeCostString, nil)) {
        feeCostString = Precise.StringAbs(feeCostString)
        var feeRateString interface{} = this.SafeString(trade, "feeRate")
        feeRateString = Precise.StringAbs(feeRateString)
        var feeCurrencyCode interface{} = Ternary(IsTrue((IsEqual(side, "sell"))), GetValue(market, "quote"), GetValue(market, "base"))
        fee = map[string]interface{} {
            "cost": feeCostString,
            "currency": feeCurrencyCode,
            "rate": feeRateString,
        }
    }
    return this.SafeTrade(map[string]interface{} {
        "id": this.SafeString(trade, "id"),
        "info": trade,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "order": orderId,
        "symbol": GetValue(market, "symbol"),
        "type": nil,
        "side": side,
        "takerOrMaker": nil,
        "price": priceString,
        "amount": amountString,
        "cost": nil,
        "fee": fee,
    }, market)
}
/**
 * @method
 * @name coinone#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://docs.coinone.co.kr/v1.0/reference/recent-completed-orders
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *coinone) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes153758 := (<-this.LoadMarkets())
            PanicOnError(retRes153758)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "quote_currency": GetValue(market, "quote"),
                "target_currency": GetValue(market, "base"),
            }
            if IsTrue(!IsEqual(limit, nil)) {
                AddElementToObject(request, "size", mathMin(limit, 200))
            }
        
            response:= (<-this.V2PublicGetTradesQuoteCurrencyTargetCurrency(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "result": "success",
            //         "error_code": "0",
            //         "server_time": 1701075315771,
            //         "quote_currency": "KRW",
            //         "target_currency": "BTC",
            //         "transactions": [
            //             {
            //                 "id": "1701075265708001",
            //                 "timestamp": 1701075265708,
            //                 "price": "50020000",
            //                 "qty": "0.00155177",
            //                 "is_seller_maker": false
            //             }
            //         ]
            //     }
            //
            var data interface{} = this.SafeList(response, "transactions", []interface{}{})
        
            ch <- this.ParseTrades(data, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinone#createOrder
 * @description create a trade order
 * @see https://doc.coinone.co.kr/#tag/Order-V2/operation/v2_order_limit_buy
 * @see https://doc.coinone.co.kr/#tag/Order-V2/operation/v2_order_limit_sell
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type must be 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinone) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(!IsEqual(typeVar, "limit")) {
                panic(ExchangeError(Add(this.Id, " createOrder() allows limit orders only")))
            }
        
            retRes504107 := (<-this.LoadMarkets())
            PanicOnError(retRes504107)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "price": price,
                "currency": GetValue(market, "id"),
                "qty": amount,
            }
            var method interface{} = Add(Add("privatePostOrder", this.Capitalize(typeVar)), this.Capitalize(side))
        
            response:= (<-this.callDynamically(method, this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "result": "success",
            //         "errorCode": "0",
            //         "orderId": "8a82c561-40b4-4cb3-9bc0-9ac9ffc1d63b"
            //     }
            //
        ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinone#fetchOrder
 * @description fetches information on an order made by the user
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinone) FetchOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchOrder() requires a symbol argument")))
            }
        
            retRes760572 := (<-this.LoadMarkets())
            PanicOnError(retRes760572)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "order_id": id,
                "currency": GetValue(market, "id"),
            }
        
            response:= (<-this.V2PrivatePostOrderQueryOrder(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "result": "success",
            //         "errorCode": "0",
            //         "orderId": "0e3019f2-1e4d-11e9-9ec7-00e04c3600d7",
            //         "baseCurrency": "KRW",
            //         "targetCurrency": "BTC",
            //         "price": "10011000.0",
            //         "originalQty": "3.0",
            //         "executedQty": "0.62",
            //         "canceledQty": "1.125",
            //         "remainQty": "1.255",
            //         "status": "partially_filled",
            //         "side": "bid",
            //         "orderedAt": 1499340941,
            //         "updatedAt": 1499341142,
            //         "feeRate": "0.002",
            //         "fee": "0.00124",
            //         "averageExecutedPrice": "10011000.0"
            //     }
            //
        ch <- this.ParseOrder(response, market)
            return nil
        
            }()
            return ch
        }
func  (this *coinone) ParseOrderStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "live": "open",
        "partially_filled": "open",
        "partially_canceled": "open",
        "filled": "closed",
        "canceled": "canceled",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *coinone) ParseOrder(order interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // createOrder
    //
    //     {
    //         "result": "success",
    //         "errorCode": "0",
    //         "orderId": "8a82c561-40b4-4cb3-9bc0-9ac9ffc1d63b"
    //     }
    //
    // fetchOrder
    //
    //     {
    //         "result": "success",
    //         "errorCode": "0",
    //         "orderId": "0e3019f2-1e4d-11e9-9ec7-00e04c3600d7",
    //         "baseCurrency": "KRW",
    //         "targetCurrency": "BTC",
    //         "price": "10011000.0",
    //         "originalQty": "3.0",
    //         "executedQty": "0.62",
    //         "canceledQty": "1.125",
    //         "remainQty": "1.255",
    //         "status": "partially_filled",
    //         "side": "bid",
    //         "orderedAt": 1499340941,
    //         "updatedAt": 1499341142,
    //         "feeRate": "0.002",
    //         "fee": "0.00124",
    //         "averageExecutedPrice": "10011000.0"
    //     }
    //
    // fetchOpenOrders
    //
    //     {
    //         "index": "0",
    //         "orderId": "68665943-1eb5-4e4b-9d76-845fc54f5489",
    //         "timestamp": "1449037367",
    //         "price": "444000.0",
    //         "qty": "0.3456",
    //         "type": "ask",
    //         "feeRate": "-0.0015"
    //     }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var id interface{} = this.SafeString(order, "orderId")
    var baseId interface{} = this.SafeString(order, "baseCurrency")
    var quoteId interface{} = this.SafeString(order, "targetCurrency")
    var base interface{} = nil
    var quote interface{} = nil
    if IsTrue(!IsEqual(baseId, nil)) {
        base = this.SafeCurrencyCode(baseId)
    }
    if IsTrue(!IsEqual(quoteId, nil)) {
        quote = this.SafeCurrencyCode(quoteId)
    }
    var symbol interface{} = nil
    if IsTrue(IsTrue((!IsEqual(base, nil))) && IsTrue((!IsEqual(quote, nil)))) {
        symbol = Add(Add(base, "/"), quote)
        market = this.SafeMarket(symbol, market, "/")
    }
    var timestamp interface{} = this.SafeTimestamp2(order, "timestamp", "updatedAt")
    var side interface{} = this.SafeString2(order, "type", "side")
    if IsTrue(IsEqual(side, "ask")) {
        side = "sell"
    } else if IsTrue(IsEqual(side, "bid")) {
        side = "buy"
    }
    var remainingString interface{} = this.SafeString(order, "remainQty")
    var amountString interface{} = this.SafeString2(order, "originalQty", "qty")
    var status interface{} = this.SafeString(order, "status")
    // https://github.com/ccxt/ccxt/pull/7067
    if IsTrue(IsEqual(status, "live")) {
        if IsTrue(IsTrue((!IsEqual(remainingString, nil))) && IsTrue((!IsEqual(amountString, nil)))) {
            var isLessThan interface{} = Precise.StringLt(remainingString, amountString)
            if IsTrue(isLessThan) {
                status = "canceled"
            }
        }
    }
    status = this.ParseOrderStatus(status)
    var fee interface{} = nil
    var feeCostString interface{} = this.SafeString(order, "fee")
    if IsTrue(!IsEqual(feeCostString, nil)) {
        var feeCurrencyCode interface{} = Ternary(IsTrue((IsEqual(side, "sell"))), quote, base)
        fee = map[string]interface{} {
            "cost": feeCostString,
            "rate": this.SafeString(order, "feeRate"),
            "currency": feeCurrencyCode,
        }
    }
    return this.SafeOrder(map[string]interface{} {
        "info": order,
        "id": id,
        "clientOrderId": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "lastTradeTimestamp": nil,
        "symbol": symbol,
        "type": "limit",
        "timeInForce": nil,
        "postOnly": nil,
        "side": side,
        "price": this.SafeString(order, "price"),
        "triggerPrice": nil,
        "cost": nil,
        "average": this.SafeString(order, "averageExecutedPrice"),
        "amount": amountString,
        "filled": this.SafeString(order, "executedQty"),
        "remaining": remainingString,
        "status": status,
        "fee": fee,
        "trades": nil,
    }, market)
}
/**
 * @method
 * @name coinone#fetchOpenOrders
 * @description fetch all unfilled currently open orders
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch open orders for
 * @param {int} [limit] the maximum number of  open orders structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinone) FetchOpenOrders(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    // The returned amount might not be same as the ordered amount. If an order is partially filled, the returned amount means the remaining amount.
            // For the same reason, the returned amount and remaining are always same, and the returned filled and cost are always zero.
            symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ExchangeError(Add(this.Id, " fetchOpenOrders() allows fetching closed orders with a specific symbol")))
            }
        
            retRes491705 := (<-this.LoadMarkets())
            PanicOnError(retRes491705)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "currency": GetValue(market, "id"),
            }
        
            response:= (<-this.PrivatePostOrderLimitOrders(this.Extend(request, params)))
            PanicOnError(response)
            //
            //     {
            //         "result": "success",
            //         "errorCode": "0",
            //         "limitOrders": [
            //             {
            //                 "index": "0",
            //                 "orderId": "68665943-1eb5-4e4b-9d76-845fc54f5489",
            //                 "timestamp": "1449037367",
            //                 "price": "444000.0",
            //                 "qty": "0.3456",
            //                 "type": "ask",
            //                 "feeRate": "-0.0015"
            //             }
            //         ]
            //     }
            //
            var limitOrders interface{} = this.SafeList(response, "limitOrders", []interface{}{})
        
            ch <- this.ParseOrders(limitOrders, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinone#fetchMyTrades
 * @description fetch all trades made by the user
 * @param {string} symbol unified market symbol
 * @param {int} [since] the earliest time in ms to fetch trades for
 * @param {int} [limit] the maximum number of trades structures to retrieve
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
 */
func  (this *coinone) FetchMyTrades(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            since := GetArg(optionalArgs, 1, nil)
            _ = since
            limit := GetArg(optionalArgs, 2, nil)
            _ = limit
            params := GetArg(optionalArgs, 3, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " fetchMyTrades() requires a symbol argument")))
            }
        
            retRes524376 := (<-this.LoadMarkets())
            PanicOnError(retRes524376)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "currency": GetValue(market, "id"),
            }
        
            response:= (<-this.V2PrivatePostOrderCompleteOrders(this.Extend(request, params)))
            PanicOnError(response)
            //
            // despite the name of the endpoint it returns trades which may have a duplicate orderId
            // https://github.com/ccxt/ccxt/pull/7067
            //
            //     {
            //         "result": "success",
            //         "errorCode": "0",
            //         "completeOrders": [
            //             {
            //                 "timestamp": "1416561032",
            //                 "price": "419000.0",
            //                 "type": "bid",
            //                 "qty": "0.001",
            //                 "feeRate": "-0.0015",
            //                 "fee": "-0.0000015",
            //                 "orderId": "E84A1AC2-8088-4FA0-B093-A3BCDB9B3C85"
            //             }
            //         ]
            //     }
            //
            var completeOrders interface{} = this.SafeList(response, "completeOrders", []interface{}{})
        
            ch <- this.ParseTrades(completeOrders, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinone#cancelOrder
 * @description cancels an open order
 * @param {string} id order id
 * @param {string} symbol unified symbol of the market the order was made in
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *coinone) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            if IsTrue(IsEqual(symbol, nil)) {
                panic(ArgumentsRequired(Add(this.Id, " cancelOrder() requires a symbol argument. To cancel the order, pass a symbol argument and {\\'price\\': 12345, \\'qty\\': 1.2345, \\'is_ask\\': 0} in the params argument of cancelOrder.")))
            }
            var price interface{} = this.SafeNumber(params, "price")
            var qty interface{} = this.SafeNumber(params, "qty")
            var isAsk interface{} = this.SafeInteger(params, "is_ask")
            if IsTrue(IsTrue(IsTrue((IsEqual(price, nil))) || IsTrue((IsEqual(qty, nil)))) || IsTrue((IsEqual(isAsk, nil)))) {
                panic(ArgumentsRequired(Add(this.Id, " cancelOrder() requires {\\'price\\': 12345, \\'qty\\': 1.2345, \\'is_ask\\': 0} in the params argument.")))
            }
        
            retRes681976 := (<-this.LoadMarkets())
            PanicOnError(retRes681976)
            var request interface{} = map[string]interface{} {
                "order_id": id,
                "price": price,
                "qty": qty,
                "is_ask": isAsk,
                "currency": this.MarketId(symbol),
            }
        
            response:= (<-this.V2PrivatePostOrderCancel(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "result": "success",
            //         "errorCode": "0"
            //     }
            //
        ch <- this.SafeOrder(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name coinone#fetchDepositAddresses
 * @description fetch deposit addresses for multiple currencies and chain types
 * @param {string[]|undefined} codes list of unified currency codes, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [address structures]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *coinone) FetchDepositAddresses(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    codes := GetArg(optionalArgs, 0, nil)
            _ = codes
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes219616 := (<-this.LoadMarkets())
            PanicOnError(retRes219616)
        
            response:= (<-this.V2PrivatePostAccountDepositAddress(params))
            PanicOnError(response)
            //
            //     {
            //         "result": "success",
            //         "errorCode": "0",
            //         "walletAddress": {
            //             "matic": null,
            //             "btc": "mnobqu4i6qMCJWDpf5UimRmr8JCvZ8FLcN",
            //             "xrp": null,
            //             "xrp_tag": "-1",
            //             "kava": null,
            //             "kava_memo": null,
            //         }
            //     }
            //
            var walletAddress interface{} = this.SafeDict(response, "walletAddress", map[string]interface{} {})
            var keys interface{} = ObjectKeys(walletAddress)
            var result interface{} = map[string]interface{} {}
            for i := 0; IsLessThan(i, GetArrayLength(keys)); i++ {
                var key interface{} = GetValue(keys, i)
                var value interface{} = GetValue(walletAddress, key)
                if IsTrue(IsTrue((!IsTrue(value))) || IsTrue((IsEqual(value, "-1")))) {
                    continue
                }
                var parts interface{} = Split(key, "_")
                var currencyId interface{} = this.SafeValue(parts, 0)
                var secondPart interface{} = this.SafeValue(parts, 1)
                var code interface{} = this.SafeCurrencyCode(currencyId)
                var depositAddress interface{} = this.SafeValue(result, code)
                if IsTrue(IsEqual(depositAddress, nil)) {
                    depositAddress = map[string]interface{} {
                        "info": value,
                        "currency": code,
                        "network": nil,
                        "address": nil,
                        "tag": nil,
                    }
                }
                var address interface{} = this.SafeString(depositAddress, "address", value)
                this.CheckAddress(address)
                AddElementToObject(depositAddress, "address", address)
                AddElementToObject(depositAddress, "info", address)
                if IsTrue((IsTrue(IsEqual(secondPart, "tag")) || IsTrue(IsEqual(secondPart, "memo")))) {
                    AddElementToObject(depositAddress, "tag", value)
                    AddElementToObject(depositAddress, "info", []interface{}{address, value})
                }
                AddElementToObject(result, code, depositAddress)
            }
        
            ch <- result
            return nil
        
            }()
            return ch
        }
func  (this *coinone) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var request interface{} = this.ImplodeParams(path, params)
    var query interface{} = this.Omit(params, this.ExtractParams(path))
    var url interface{} = Add(GetValue(GetValue(this.Urls, "api"), "rest"), "/")
    if IsTrue(IsEqual(api, "v2Public")) {
        url = Add(GetValue(GetValue(this.Urls, "api"), "v2Public"), "/")
        api = "public"
    } else if IsTrue(IsEqual(api, "v2Private")) {
        url = Add(GetValue(GetValue(this.Urls, "api"), "v2Private"), "/")
    } else if IsTrue(IsEqual(api, "v2_1Private")) {
        url = Add(GetValue(GetValue(this.Urls, "api"), "v2_1Private"), "/")
    }
    if IsTrue(IsEqual(api, "public")) {
        url = Add(url, request)
        if IsTrue(GetArrayLength(ObjectKeys(query))) {
            url = Add(url, Add("?", this.Urlencode(query)))
        }
    } else {
        this.CheckRequiredCredentials()
        url = Add(url, request)
        var nonce interface{} = ToString(this.Nonce())
        var json interface{} = this.Json(this.Extend(map[string]interface{} {
            "access_token": this.ApiKey,
            "nonce": nonce,
        }, params))
        var payload interface{} = this.StringToBase64(json)
        body = payload
        var secret interface{} = ToUpper(this.Secret)
        var signature interface{} = this.Hmac(this.Encode(payload), this.Encode(secret), sha512)
        headers = map[string]interface{} {
            "Content-Type": "application/json",
            "X-COINONE-PAYLOAD": payload,
            "X-COINONE-SIGNATURE": signature,
        }
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *coinone) HandleErrors(code interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsEqual(response, nil)) {
        return nil  // fallback to default error handler
    }
    //
    //     {"result":"error","error_code":"107","error_msg":"Parameter value is wrong"}
    //     {"result":"error","error_code":"108","error_msg":"Unknown CryptoCurrency"}
    //
    var errorCode interface{} = this.SafeString(response, "error_code")
    if IsTrue(IsTrue(!IsEqual(errorCode, nil)) && IsTrue(!IsEqual(errorCode, "0"))) {
        var feedback interface{} = Add(Add(this.Id, " "), body)
        this.ThrowExactlyMatchedException(this.Exceptions, errorCode, feedback)
        panic(ExchangeError(feedback))
    }
    return nil
}


func (this *coinone) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
