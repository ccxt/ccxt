package ccxt

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

type paymium struct {
    Exchange

}

func NewPaymiumCore() paymium {
   p := paymium{}
   setDefaults(&p)
   return p
}

func  (this *paymium) Describe() interface{}  {
    return this.DeepExtend(this.Exchange.Describe(), map[string]interface{} {
        "id": "paymium",
        "name": "Paymium",
        "countries": []interface{}{"FR", "EU"},
        "rateLimit": 2000,
        "version": "v1",
        "has": map[string]interface{} {
            "CORS": true,
            "spot": true,
            "margin": nil,
            "swap": false,
            "future": false,
            "option": false,
            "cancelOrder": true,
            "createDepositAddress": true,
            "createOrder": true,
            "fetchBalance": true,
            "fetchDepositAddress": true,
            "fetchDepositAddresses": true,
            "fetchDepositAddressesByNetwork": false,
            "fetchFundingHistory": false,
            "fetchFundingRate": false,
            "fetchFundingRateHistory": false,
            "fetchFundingRates": false,
            "fetchIndexOHLCV": false,
            "fetchMarkOHLCV": false,
            "fetchOpenInterestHistory": false,
            "fetchOrderBook": true,
            "fetchPremiumIndexOHLCV": false,
            "fetchTicker": true,
            "fetchTrades": true,
            "fetchTradingFee": false,
            "fetchTradingFees": false,
            "transfer": true,
        },
        "urls": map[string]interface{} {
            "logo": "https://user-images.githubusercontent.com/51840849/87153930-f0f02200-c2c0-11ea-9c0a-40337375ae89.jpg",
            "api": map[string]interface{} {
                "rest": "https://paymium.com/api",
            },
            "www": "https://www.paymium.com",
            "fees": "https://www.paymium.com/page/help/fees",
            "doc": []interface{}{"https://github.com/Paymium/api-documentation", "https://www.paymium.com/page/developers", "https://paymium.github.io/api-documentation/"},
            "referral": "https://www.paymium.com/page/sign-up?referral=eDAzPoRQFMvaAB8sf-qj",
        },
        "api": map[string]interface{} {
            "public": map[string]interface{} {
                "get": []interface{}{"countries", "currencies", "data/{currency}/ticker", "data/{currency}/trades", "data/{currency}/depth", "bitcoin_charts/{id}/trades", "bitcoin_charts/{id}/depth"},
            },
            "private": map[string]interface{} {
                "get": []interface{}{"user", "user/addresses", "user/addresses/{address}", "user/orders", "user/orders/{uuid}", "user/price_alerts", "merchant/get_payment/{uuid}"},
                "post": []interface{}{"user/addresses", "user/orders", "user/withdrawals", "user/email_transfers", "user/payment_requests", "user/price_alerts", "merchant/create_payment"},
                "delete": []interface{}{"user/orders/{uuid}", "user/orders/{uuid}/cancel", "user/price_alerts/{id}"},
            },
        },
        "markets": map[string]interface{} {
            "BTC/EUR": this.SafeMarketStructure(map[string]interface{} {
                "id": "eur",
                "symbol": "BTC/EUR",
                "base": "BTC",
                "quote": "EUR",
                "baseId": "btc",
                "quoteId": "eur",
                "type": "spot",
                "spot": true,
            }),
        },
        "fees": map[string]interface{} {
            "trading": map[string]interface{} {
                "maker": this.ParseNumber("-0.001"),
                "taker": this.ParseNumber("0.005"),
            },
        },
        "precisionMode": TICK_SIZE,
        "features": map[string]interface{} {
            "spot": map[string]interface{} {
                "sandbox": false,
                "createOrder": map[string]interface{} {
                    "marginMode": false,
                    "triggerPrice": false,
                    "triggerDirection": false,
                    "triggerPriceType": nil,
                    "stopLossPrice": false,
                    "takeProfitPrice": false,
                    "attachedStopLossTakeProfit": nil,
                    "timeInForce": map[string]interface{} {
                        "IOC": false,
                        "FOK": false,
                        "PO": false,
                        "GTD": false,
                    },
                    "hedged": false,
                    "trailing": false,
                    "leverage": false,
                    "marketBuyByCost": true,
                    "marketBuyRequiresPrice": false,
                    "selfTradePrevention": false,
                    "iceberg": false,
                },
                "createOrders": nil,
                "fetchMyTrades": nil,
                "fetchOrder": nil,
                "fetchOpenOrders": nil,
                "fetchOrders": nil,
                "fetchClosedOrders": nil,
                "fetchOHLCV": nil,
            },
            "swap": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
            "future": map[string]interface{} {
                "linear": nil,
                "inverse": nil,
            },
        },
    })
}
func  (this *paymium) ParseBalance(response interface{}) interface{}  {
    var result interface{} = map[string]interface{} {
        "info": response,
    }
    var currencies interface{} = ObjectKeys(this.Currencies)
    for i := 0; IsLessThan(i, GetArrayLength(currencies)); i++ {
        var code interface{} = GetValue(currencies, i)
        var currency interface{} = this.Currency(code)
        var currencyId interface{} = GetValue(currency, "id")
        var free interface{} = Add("balance_", currencyId)
        if IsTrue(InOp(response, free)) {
            var account interface{} = this.Account()
            var used interface{} = Add("locked_", currencyId)
            AddElementToObject(account, "free", this.SafeString(response, free))
            AddElementToObject(account, "used", this.SafeString(response, used))
            AddElementToObject(result, code, account)
        }
    }
    return this.SafeBalance(result)
}
/**
 * @method
 * @name paymium#fetchBalance
 * @description query for balance and get the amount of funds available for trading or funds locked in orders
 * @see https://paymium.github.io/api-documentation/#tag/User/paths/~1user/get
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
 */
func  (this *paymium) FetchBalance(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes413114 := (<-this.LoadMarkets())
            PanicOnError(retRes413114)
        
            response:= (<-this.PrivateGetUser(params))
            PanicOnError(response)
        
            ch <- this.ParseBalance(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name paymium#fetchOrderBook
 * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
 * @see https://paymium.github.io/api-documentation/#tag/Public-data/paths/~1data~1%7Bcurrency%7D~1depth/get
 * @param {string} symbol unified symbol of the market to fetch the order book for
 * @param {int} [limit] the maximum amount of order book entries to return
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
 */
func  (this *paymium) FetchOrderBook(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    limit := GetArg(optionalArgs, 0, nil)
            _ = limit
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes476675 := (<-this.LoadMarkets())
            PanicOnError(retRes476675)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "currency": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetDataCurrencyDepth(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseOrderBook(response, GetValue(market, "symbol"), nil, "bids", "asks", "price", "amount")
            return nil
        
            }()
            return ch
        }
func  (this *paymium) ParseTicker(ticker interface{}, optionalArgs ...interface{}) interface{}  {
    //
    // {
    //     "high":"33740.82",
    //     "low":"32185.15",
    //     "volume":"4.7890433",
    //     "bid":"33313.53",
    //     "ask":"33497.97",
    //     "midpoint":"33405.75",
    //     "vwap":"32802.5263553",
    //     "at":1643381654,
    //     "price":"33143.91",
    //     "open":"33116.86",
    //     "variation":"0.0817",
    //     "currency":"EUR",
    //     "trade_id":"ce2f5152-3ac5-412d-9b24-9fa72338474c",
    //     "size":"0.00041087"
    // }
    //
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var symbol interface{} = this.SafeSymbol(nil, market)
    var timestamp interface{} = this.SafeTimestamp(ticker, "at")
    var vwap interface{} = this.SafeString(ticker, "vwap")
    var baseVolume interface{} = this.SafeString(ticker, "volume")
    var quoteVolume interface{} = Precise.StringMul(baseVolume, vwap)
    var last interface{} = this.SafeString(ticker, "price")
    return this.SafeTicker(map[string]interface{} {
        "symbol": symbol,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "high": this.SafeString(ticker, "high"),
        "low": this.SafeString(ticker, "low"),
        "bid": this.SafeString(ticker, "bid"),
        "bidVolume": nil,
        "ask": this.SafeString(ticker, "ask"),
        "askVolume": nil,
        "vwap": vwap,
        "open": this.SafeString(ticker, "open"),
        "close": last,
        "last": last,
        "previousClose": nil,
        "change": nil,
        "percentage": this.SafeString(ticker, "variation"),
        "average": nil,
        "baseVolume": baseVolume,
        "quoteVolume": quoteVolume,
        "info": ticker,
    }, market)
}
/**
 * @method
 * @name paymium#fetchTicker
 * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
 * @see https://paymium.github.io/api-documentation/#tag/Public-data/paths/~1data~1%7Bcurrency%7D~1ticker/get
 * @param {string} symbol unified symbol of the market to fetch the ticker for
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
 */
func  (this *paymium) FetchTicker(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes944312 := (<-this.LoadMarkets())
            PanicOnError(retRes944312)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "currency": GetValue(market, "id"),
            }
        
            ticker:= (<-this.PublicGetDataCurrencyTicker(this.Extend(request, params)))
            PanicOnError(ticker)
        
                //
            // {
            //     "high":"33740.82",
            //     "low":"32185.15",
            //     "volume":"4.7890433",
            //     "bid":"33313.53",
            //     "ask":"33497.97",
            //     "midpoint":"33405.75",
            //     "vwap":"32802.5263553",
            //     "at":1643381654,
            //     "price":"33143.91",
            //     "open":"33116.86",
            //     "variation":"0.0817",
            //     "currency":"EUR",
            //     "trade_id":"ce2f5152-3ac5-412d-9b24-9fa72338474c",
            //     "size":"0.00041087"
            // }
            //
        ch <- this.ParseTicker(ticker, market)
            return nil
        
            }()
            return ch
        }
func  (this *paymium) ParseTrade(trade interface{}, optionalArgs ...interface{}) interface{}  {
    market := GetArg(optionalArgs, 0, nil)
    _ = market
    var timestamp interface{} = this.SafeTimestamp(trade, "created_at_int")
    var id interface{} = this.SafeString(trade, "uuid")
    market = this.SafeMarket(nil, market)
    var side interface{} = this.SafeString(trade, "side")
    var price interface{} = this.SafeString(trade, "price")
    var amountField interface{} = Add("traded_", ToLower(GetValue(market, "base")))
    var amount interface{} = this.SafeString(trade, amountField)
    return this.SafeTrade(map[string]interface{} {
        "info": trade,
        "id": id,
        "order": nil,
        "timestamp": timestamp,
        "datetime": this.Iso8601(timestamp),
        "symbol": GetValue(market, "symbol"),
        "type": nil,
        "side": side,
        "takerOrMaker": nil,
        "price": price,
        "amount": amount,
        "cost": nil,
        "fee": nil,
    }, market)
}
/**
 * @method
 * @name paymium#fetchTrades
 * @description get the list of most recent trades for a particular symbol
 * @see https://paymium.github.io/api-documentation/#tag/Public-data/paths/~1data~1%7Bcurrency%7D~1trades/get
 * @param {string} symbol unified symbol of the market to fetch trades for
 * @param {int} [since] timestamp in ms of the earliest trade to fetch
 * @param {int} [limit] the maximum amount of trades to fetch
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
 */
func  (this *paymium) FetchTrades(symbol interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    since := GetArg(optionalArgs, 0, nil)
            _ = since
            limit := GetArg(optionalArgs, 1, nil)
            _ = limit
            params := GetArg(optionalArgs, 2, map[string]interface{} {})
            _ = params
        
            retRes214193 := (<-this.LoadMarkets())
            PanicOnError(retRes214193)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "currency": GetValue(market, "id"),
            }
        
            response:= (<-this.PublicGetDataCurrencyTrades(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.ParseTrades(response, market, since, limit)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name paymium#createDepositAddress
 * @description create a currency deposit address
 * @see https://paymium.github.io/api-documentation/#tag/User/paths/~1user~1addresses/post
 * @param {string} code unified currency code of the currency for the deposit address
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *paymium) CreateDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes181020 := (<-this.LoadMarkets())
            PanicOnError(retRes181020)
        
            response:= (<-this.PrivatePostUserAddresses(params))
            PanicOnError(response)
        
                //
            //     {
            //         "address": "1HdjGr6WCTcnmW1tNNsHX7fh4Jr5C2PeKe",
            //         "valid_until": 1620041926,
            //         "currency": "BTC",
            //         "label": "Savings"
            //     }
            //
        ch <- this.ParseDepositAddress(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name paymium#fetchDepositAddress
 * @description fetch the deposit address for a currency associated with this account
 * @see https://paymium.github.io/api-documentation/#tag/User/paths/~1user~1addresses~1%7Baddress%7D/get
 * @param {string} code unified currency code
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *paymium) FetchDepositAddress(code interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes537880 := (<-this.LoadMarkets())
            PanicOnError(retRes537880)
            var request interface{} = map[string]interface{} {
                "address": code,
            }
        
            response:= (<-this.PrivateGetUserAddressesAddress(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "address": "1HdjGr6WCTcnmW1tNNsHX7fh4Jr5C2PeKe",
            //         "valid_until": 1620041926,
            //         "currency": "BTC",
            //         "label": "Savings"
            //     }
            //
        ch <- this.ParseDepositAddress(response)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name paymium#fetchDepositAddresses
 * @description fetch deposit addresses for multiple currencies and chain types
 * @see https://paymium.github.io/api-documentation/#tag/User/paths/~1user~1addresses/get
 * @param {string[]|undefined} codes list of unified currency codes, default is undefined
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a list of [address structures]{@link https://docs.ccxt.com/#/?id=address-structure}
 */
func  (this *paymium) FetchDepositAddresses(optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    codes := GetArg(optionalArgs, 0, nil)
            _ = codes
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes598930 := (<-this.LoadMarkets())
            PanicOnError(retRes598930)
        
            response:= (<-this.PrivateGetUserAddresses(params))
            PanicOnError(response)
        
                //
            //     [
            //         {
            //             "address": "1HdjGr6WCTcnmW1tNNsHX7fh4Jr5C2PeKe",
            //             "valid_until": 1620041926,
            //             "currency": "BTC",
            //             "label": "Savings"
            //         }
            //     ]
            //
        ch <- this.ParseDepositAddresses(response, codes)
            return nil
        
            }()
            return ch
        }
func  (this *paymium) ParseDepositAddress(depositAddress interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "address": "1HdjGr6WCTcnmW1tNNsHX7fh4Jr5C2PeKe",
    //         "valid_until": 1620041926,
    //         "currency": "BTC",
    //         "label": "Savings"
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var address interface{} = this.SafeString(depositAddress, "address")
    var currencyId interface{} = this.SafeString(depositAddress, "currency")
    return map[string]interface{} {
        "info": depositAddress,
        "currency": this.SafeCurrencyCode(currencyId, currency),
        "network": nil,
        "address": address,
        "tag": nil,
    }
}
/**
 * @method
 * @name paymium#createOrder
 * @description create a trade order
 * @see https://paymium.github.io/api-documentation/#tag/Order/paths/~1user~1orders/post
 * @param {string} symbol unified symbol of the market to create an order in
 * @param {string} type 'market' or 'limit'
 * @param {string} side 'buy' or 'sell'
 * @param {float} amount how much of currency you want to trade in units of base currency
 * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *paymium) CreateOrder(symbol interface{}, typeVar interface{}, side interface{}, amount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    price := GetArg(optionalArgs, 0, nil)
            _ = price
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
        
            retRes527148 := (<-this.LoadMarkets())
            PanicOnError(retRes527148)
            var market interface{} = this.Market(symbol)
            var request interface{} = map[string]interface{} {
                "type": Add(this.Capitalize(typeVar), "Order"),
                "currency": GetValue(market, "id"),
                "direction": side,
                "amount": amount,
            }
            if IsTrue(!IsEqual(typeVar, "market")) {
                AddElementToObject(request, "price", price)
            }
        
            response:= (<-this.PrivatePostUserOrders(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.SafeOrder(map[string]interface{} {
                "info": response,
                "id": GetValue(response, "uuid"),
            }, market)
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name paymium#cancelOrder
 * @description cancels an open order
 * @see https://paymium.github.io/api-documentation/#tag/Order/paths/~1user~1orders~1%7Buuid%7D/delete
 * @see https://paymium.github.io/api-documentation/#tag/Order/paths/~1user~1orders~1%7Buuid%7D~1cancel/delete
 * @param {string} id order id
 * @param {string} symbol not used by paymium cancelOrder ()
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
 */
func  (this *paymium) CancelOrder(id interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    symbol := GetArg(optionalArgs, 0, nil)
            _ = symbol
            params := GetArg(optionalArgs, 1, map[string]interface{} {})
            _ = params
            var request interface{} = map[string]interface{} {
                "uuid": id,
            }
        
            response:= (<-this.PrivateDeleteUserOrdersUuidCancel(this.Extend(request, params)))
            PanicOnError(response)
        
            ch <- this.SafeOrder(map[string]interface{} {
                "info": response,
            })
            return nil
        
            }()
            return ch
        }
/**
 * @method
 * @name paymium#transfer
 * @description transfer currency internally between wallets on the same account
 * @see https://paymium.github.io/api-documentation/#tag/Transfer/paths/~1user~1email_transfers/post
 * @param {string} code unified currency code
 * @param {float} amount amount to transfer
 * @param {string} fromAccount account to transfer from
 * @param {string} toAccount account to transfer to
 * @param {object} [params] extra parameters specific to the exchange API endpoint
 * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
 */
func  (this *paymium) Transfer(code interface{}, amount interface{}, fromAccount interface{}, toAccount interface{}, optionalArgs ...interface{}) <- chan interface{} {
            ch := make(chan interface{})
            go func() interface{} {
                defer close(ch)
                defer ReturnPanicError(ch)
                    params := GetArg(optionalArgs, 0, map[string]interface{} {})
            _ = params
        
            retRes330483 := (<-this.LoadMarkets())
            PanicOnError(retRes330483)
            var currency interface{} = this.Currency(code)
            if IsTrue(IsLessThan(GetIndexOf(toAccount, "@"), 0)) {
                panic(ExchangeError(Add(this.Id, " transfer() only allows transfers to an email address")))
            }
            if IsTrue(IsTrue(!IsEqual(code, "BTC")) && IsTrue(!IsEqual(code, "EUR"))) {
                panic(ExchangeError(Add(this.Id, " transfer() only allows BTC or EUR")))
            }
            var request interface{} = map[string]interface{} {
                "currency": GetValue(currency, "id"),
                "amount": this.CurrencyToPrecision(code, amount),
                "email": toAccount,
            }
        
            response:= (<-this.PrivatePostUserEmailTransfers(this.Extend(request, params)))
            PanicOnError(response)
        
                //
            //     {
            //         "uuid": "968f4580-e26c-4ad8-8bcd-874d23d55296",
            //         "type": "Transfer",
            //         "currency": "BTC",
            //         "currency_amount": "string",
            //         "created_at": "2013-10-24T10:34:37.000Z",
            //         "updated_at": "2013-10-24T10:34:37.000Z",
            //         "amount": "1.0",
            //         "state": "executed",
            //         "currency_fee": "0.0",
            //         "btc_fee": "0.0",
            //         "comment": "string",
            //         "traded_btc": "string",
            //         "traded_currency": "string",
            //         "direction": "buy",
            //         "price": "string",
            //         "account_operations": [
            //             {
            //                 "uuid": "968f4580-e26c-4ad8-8bcd-874d23d55296",
            //                 "amount": "1.0",
            //                 "currency": "BTC",
            //                 "created_at": "2013-10-24T10:34:37.000Z",
            //                 "created_at_int": 1389094259,
            //                 "name": "account_operation",
            //                 "address": "1FPDBXNqSkZMsw1kSkkajcj8berxDQkUoc",
            //                 "tx_hash": "string",
            //                 "is_trading_account": true
            //             }
            //         ]
            //     }
            //
        ch <- this.ParseTransfer(response, currency)
            return nil
        
            }()
            return ch
        }
func  (this *paymium) ParseTransfer(transfer interface{}, optionalArgs ...interface{}) interface{}  {
    //
    //     {
    //         "uuid": "968f4580-e26c-4ad8-8bcd-874d23d55296",
    //         "type": "Transfer",
    //         "currency": "BTC",
    //         "currency_amount": "string",
    //         "created_at": "2013-10-24T10:34:37.000Z",
    //         "updated_at": "2013-10-24T10:34:37.000Z",
    //         "amount": "1.0",
    //         "state": "executed",
    //         "currency_fee": "0.0",
    //         "btc_fee": "0.0",
    //         "comment": "string",
    //         "traded_btc": "string",
    //         "traded_currency": "string",
    //         "direction": "buy",
    //         "price": "string",
    //         "account_operations": [
    //             {
    //                 "uuid": "968f4580-e26c-4ad8-8bcd-874d23d55296",
    //                 "amount": "1.0",
    //                 "currency": "BTC",
    //                 "created_at": "2013-10-24T10:34:37.000Z",
    //                 "created_at_int": 1389094259,
    //                 "name": "account_operation",
    //                 "address": "1FPDBXNqSkZMsw1kSkkajcj8berxDQkUoc",
    //                 "tx_hash": "string",
    //                 "is_trading_account": true
    //             }
    //         ]
    //     }
    //
    currency := GetArg(optionalArgs, 0, nil)
    _ = currency
    var currencyId interface{} = this.SafeString(transfer, "currency")
    var updatedAt interface{} = this.SafeString(transfer, "updated_at")
    var timetstamp interface{} = this.ParseDate(updatedAt)
    var accountOperations interface{} = this.SafeValue(transfer, "account_operations")
    var firstOperation interface{} = this.SafeValue(accountOperations, 0, map[string]interface{} {})
    var status interface{} = this.SafeString(transfer, "state")
    return map[string]interface{} {
        "info": transfer,
        "id": this.SafeString(transfer, "uuid"),
        "timestamp": timetstamp,
        "datetime": this.Iso8601(timetstamp),
        "currency": this.SafeCurrencyCode(currencyId, currency),
        "amount": this.SafeNumber(transfer, "amount"),
        "fromAccount": nil,
        "toAccount": this.SafeString(firstOperation, "address"),
        "status": this.ParseTransferStatus(status),
    }
}
func  (this *paymium) ParseTransferStatus(status interface{}) interface{}  {
    var statuses interface{} = map[string]interface{} {
        "executed": "ok",
    }
    return this.SafeString(statuses, status, status)
}
func  (this *paymium) Sign(path interface{}, optionalArgs ...interface{}) interface{}  {
    api := GetArg(optionalArgs, 0, "public")
    _ = api
    method := GetArg(optionalArgs, 1, "GET")
    _ = method
    params := GetArg(optionalArgs, 2, map[string]interface{} {})
    _ = params
    headers := GetArg(optionalArgs, 3, nil)
    _ = headers
    body := GetArg(optionalArgs, 4, nil)
    _ = body
    var url interface{} = Add(Add(Add(Add(GetValue(GetValue(this.Urls, "api"), "rest"), "/"), this.Version), "/"), this.ImplodeParams(path, params))
    var query interface{} = this.Omit(params, this.ExtractParams(path))
    if IsTrue(IsEqual(api, "public")) {
        if IsTrue(GetArrayLength(ObjectKeys(query))) {
            url = Add(url, Add("?", this.Urlencode(query)))
        }
    } else {
        this.CheckRequiredCredentials()
        var nonce interface{} = ToString(this.Nonce())
        var auth interface{} = Add(nonce, url)
        headers = map[string]interface{} {
            "Api-Key": this.ApiKey,
            "Api-Nonce": nonce,
        }
        if IsTrue(IsEqual(method, "POST")) {
            if IsTrue(GetArrayLength(ObjectKeys(query))) {
                body = this.Json(query)
                auth = Add(auth, body)
                AddElementToObject(headers, "Content-Type", "application/json")
            }
        } else {
            if IsTrue(GetArrayLength(ObjectKeys(query))) {
                var queryString interface{} = this.Urlencode(query)
                auth = Add(auth, queryString)
                url = Add(url, Add("?", queryString))
            }
        }
        AddElementToObject(headers, "Api-Signature", this.Hmac(this.Encode(auth), this.Encode(this.Secret), sha256))
    }
    return map[string]interface{} {
        "url": url,
        "method": method,
        "body": body,
        "headers": headers,
    }
}
func  (this *paymium) HandleErrors(httpCode interface{}, reason interface{}, url interface{}, method interface{}, headers interface{}, body interface{}, response interface{}, requestHeaders interface{}, requestBody interface{}) interface{}  {
    if IsTrue(IsEqual(response, nil)) {
        return nil
    }
    var errors interface{} = this.SafeValue(response, "errors")
    if IsTrue(!IsEqual(errors, nil)) {
        panic(ExchangeError(Add(Add(this.Id, " "), this.Json(response))))
    }
    return nil
}


func (this *paymium) Init(userConfig map[string]interface{}) {
    this.Exchange = Exchange{}
    this.Exchange.InitParent(userConfig, this.Describe().(map[string]interface{}), this)
    this.Exchange.DerivedExchange = this
}
