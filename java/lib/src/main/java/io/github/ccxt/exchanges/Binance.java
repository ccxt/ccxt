package io.github.ccxt.exchanges;
import io.github.ccxt.api.BinanceApi;
import io.github.ccxt.base.Precise;
import io.github.ccxt.errors.*;
import io.github.ccxt.Helpers;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public class Binance extends BinanceApi
{
    public Object describe()
    {
        return this.deepExtend(super.describe(), new java.util.HashMap<String, Object>() {{
            put( "id", "binance" );
            put( "name", "Binance" );
            put( "countries", new java.util.ArrayList<Object>(java.util.Arrays.asList()) );
            put( "rateLimit", 50 );
            put( "certified", true );
            put( "pro", true );
            put( "has", new java.util.HashMap<String, Object>() {{
                put( "CORS", null );
                put( "spot", true );
                put( "margin", true );
                put( "swap", true );
                put( "future", true );
                put( "option", true );
                put( "addMargin", true );
                put( "borrowCrossMargin", true );
                put( "borrowIsolatedMargin", true );
                put( "cancelAllOrders", true );
                put( "cancelOrder", true );
                put( "cancelOrders", true );
                put( "closeAllPositions", false );
                put( "closePosition", false );
                put( "createConvertTrade", true );
                put( "createDepositAddress", false );
                put( "createLimitBuyOrder", true );
                put( "createLimitSellOrder", true );
                put( "createMarketBuyOrder", true );
                put( "createMarketBuyOrderWithCost", true );
                put( "createMarketOrderWithCost", true );
                put( "createMarketSellOrder", true );
                put( "createMarketSellOrderWithCost", true );
                put( "createOrder", true );
                put( "createOrders", true );
                put( "createOrderWithTakeProfitAndStopLoss", false );
                put( "createPostOnlyOrder", true );
                put( "createReduceOnlyOrder", true );
                put( "createStopLimitOrder", true );
                put( "createStopLossOrder", true );
                put( "createStopMarketOrder", false );
                put( "createStopOrder", true );
                put( "createTakeProfitOrder", true );
                put( "createTrailingPercentOrder", true );
                put( "createTriggerOrder", true );
                put( "editOrder", true );
                put( "editOrders", true );
                put( "fetchAccounts", null );
                put( "fetchAllGreeks", true );
                put( "fetchBalance", true );
                put( "fetchBidsAsks", true );
                put( "fetchBorrowInterest", true );
                put( "fetchBorrowRateHistories", false );
                put( "fetchBorrowRateHistory", true );
                put( "fetchCanceledAndClosedOrders", "emulated" );
                put( "fetchCanceledOrders", "emulated" );
                put( "fetchClosedOrder", false );
                put( "fetchClosedOrders", "emulated" );
                put( "fetchConvertCurrencies", true );
                put( "fetchConvertQuote", true );
                put( "fetchConvertTrade", true );
                put( "fetchConvertTradeHistory", true );
                put( "fetchCrossBorrowRate", true );
                put( "fetchCrossBorrowRates", false );
                put( "fetchCurrencies", true );
                put( "fetchDeposit", false );
                put( "fetchDepositAddress", true );
                put( "fetchDepositAddresses", false );
                put( "fetchDepositAddressesByNetwork", false );
                put( "fetchDeposits", true );
                put( "fetchDepositsWithdrawals", false );
                put( "fetchDepositWithdrawFee", "emulated" );
                put( "fetchDepositWithdrawFees", true );
                put( "fetchFundingHistory", true );
                put( "fetchFundingInterval", "emulated" );
                put( "fetchFundingIntervals", true );
                put( "fetchFundingRate", true );
                put( "fetchFundingRateHistory", true );
                put( "fetchFundingRates", true );
                put( "fetchGreeks", true );
                put( "fetchIndexOHLCV", true );
                put( "fetchIsolatedBorrowRate", "emulated" );
                put( "fetchIsolatedBorrowRates", true );
                put( "fetchL3OrderBook", false );
                put( "fetchLastPrices", true );
                put( "fetchLedger", true );
                put( "fetchLedgerEntry", true );
                put( "fetchLeverage", "emulated" );
                put( "fetchLeverages", true );
                put( "fetchLeverageTiers", true );
                put( "fetchLiquidations", false );
                put( "fetchLongShortRatio", false );
                put( "fetchLongShortRatioHistory", true );
                put( "fetchMarginAdjustmentHistory", true );
                put( "fetchMarginMode", true );
                put( "fetchMarginModes", true );
                put( "fetchMarketLeverageTiers", "emulated" );
                put( "fetchMarkets", true );
                put( "fetchMarkOHLCV", true );
                put( "fetchMarkPrice", true );
                put( "fetchMarkPrices", true );
                put( "fetchMyLiquidations", true );
                put( "fetchMySettlementHistory", true );
                put( "fetchMyTrades", true );
                put( "fetchOHLCV", true );
                put( "fetchOpenInterest", true );
                put( "fetchOpenInterestHistory", true );
                put( "fetchOpenOrder", true );
                put( "fetchOpenOrders", true );
                put( "fetchOption", true );
                put( "fetchOptionChain", false );
                put( "fetchOrder", true );
                put( "fetchOrderBook", true );
                put( "fetchOrderBooks", false );
                put( "fetchOrders", true );
                put( "fetchOrderTrades", true );
                put( "fetchPosition", true );
                put( "fetchPositionHistory", false );
                put( "fetchPositionMode", true );
                put( "fetchPositions", true );
                put( "fetchPositionsHistory", false );
                put( "fetchPositionsRisk", true );
                put( "fetchPremiumIndexOHLCV", true );
                put( "fetchSettlementHistory", true );
                put( "fetchStatus", true );
                put( "fetchTicker", true );
                put( "fetchTickers", true );
                put( "fetchTime", true );
                put( "fetchTrades", true );
                put( "fetchTradingFee", true );
                put( "fetchTradingFees", true );
                put( "fetchTradingLimits", "emulated" );
                put( "fetchTransactionFee", "emulated" );
                put( "fetchTransactionFees", true );
                put( "fetchTransactions", false );
                put( "fetchTransfer", false );
                put( "fetchTransfers", true );
                put( "fetchUnderlyingAssets", false );
                put( "fetchVolatilityHistory", false );
                put( "fetchWithdrawAddresses", false );
                put( "fetchWithdrawal", false );
                put( "fetchWithdrawals", true );
                put( "fetchWithdrawalWhitelist", false );
                put( "reduceMargin", true );
                put( "repayCrossMargin", true );
                put( "repayIsolatedMargin", true );
                put( "sandbox", true );
                put( "setLeverage", true );
                put( "setMargin", false );
                put( "setMarginMode", true );
                put( "setPositionMode", true );
                put( "signIn", false );
                put( "transfer", true );
                put( "withdraw", true );
            }} );
            put( "timeframes", new java.util.HashMap<String, Object>() {{
                put( "1s", "1s" );
                put( "1m", "1m" );
                put( "3m", "3m" );
                put( "5m", "5m" );
                put( "15m", "15m" );
                put( "30m", "30m" );
                put( "1h", "1h" );
                put( "2h", "2h" );
                put( "4h", "4h" );
                put( "6h", "6h" );
                put( "8h", "8h" );
                put( "12h", "12h" );
                put( "1d", "1d" );
                put( "3d", "3d" );
                put( "1w", "1w" );
                put( "1M", "1M" );
            }} );
            put( "urls", new java.util.HashMap<String, Object>() {{
                put( "logo", "https://github.com/user-attachments/assets/e9419b93-ccb0-46aa-9bff-c883f096274b" );
                put( "test", new java.util.HashMap<String, Object>() {{
                    put( "dapiPublic", "https://testnet.binancefuture.com/dapi/v1" );
                    put( "dapiPrivate", "https://testnet.binancefuture.com/dapi/v1" );
                    put( "dapiPrivateV2", "https://testnet.binancefuture.com/dapi/v2" );
                    put( "fapiPublic", "https://testnet.binancefuture.com/fapi/v1" );
                    put( "fapiPublicV2", "https://testnet.binancefuture.com/fapi/v2" );
                    put( "fapiPublicV3", "https://testnet.binancefuture.com/fapi/v3" );
                    put( "fapiPrivate", "https://testnet.binancefuture.com/fapi/v1" );
                    put( "fapiPrivateV2", "https://testnet.binancefuture.com/fapi/v2" );
                    put( "fapiPrivateV3", "https://testnet.binancefuture.com/fapi/v3" );
                    put( "public", "https://testnet.binance.vision/api/v3" );
                    put( "private", "https://testnet.binance.vision/api/v3" );
                    put( "v1", "https://testnet.binance.vision/api/v1" );
                }} );
                put( "demo", new java.util.HashMap<String, Object>() {{
                    put( "dapiPublic", "https://demo-dapi.binance.com/dapi/v1" );
                    put( "dapiPrivate", "https://demo-dapi.binance.com/dapi/v1" );
                    put( "dapiPrivateV2", "https://demo-dapi.binance.com/dapi/v2" );
                    put( "fapiPublic", "https://demo-fapi.binance.com/fapi/v1" );
                    put( "fapiPublicV2", "https://demo-fapi.binance.com/fapi/v2" );
                    put( "fapiPublicV3", "https://demo-fapi.binance.com/fapi/v3" );
                    put( "fapiPrivate", "https://demo-fapi.binance.com/fapi/v1" );
                    put( "fapiPrivateV2", "https://demo-fapi.binance.com/fapi/v2" );
                    put( "fapiPrivateV3", "https://demo-fapi.binance.com/fapi/v3" );
                    put( "public", "https://demo-api.binance.com/api/v3" );
                    put( "private", "https://demo-api.binance.com/api/v3" );
                    put( "v1", "https://demo-api.binance.com/api/v1" );
                }} );
                put( "api", new java.util.HashMap<String, Object>() {{
                    put( "sapi", "https://api.binance.com/sapi/v1" );
                    put( "sapiV2", "https://api.binance.com/sapi/v2" );
                    put( "sapiV3", "https://api.binance.com/sapi/v3" );
                    put( "sapiV4", "https://api.binance.com/sapi/v4" );
                    put( "dapiPublic", "https://dapi.binance.com/dapi/v1" );
                    put( "dapiPrivate", "https://dapi.binance.com/dapi/v1" );
                    put( "eapiPublic", "https://eapi.binance.com/eapi/v1" );
                    put( "eapiPrivate", "https://eapi.binance.com/eapi/v1" );
                    put( "dapiPrivateV2", "https://dapi.binance.com/dapi/v2" );
                    put( "dapiData", "https://dapi.binance.com/futures/data" );
                    put( "fapiPublic", "https://fapi.binance.com/fapi/v1" );
                    put( "fapiPublicV2", "https://fapi.binance.com/fapi/v2" );
                    put( "fapiPublicV3", "https://fapi.binance.com/fapi/v3" );
                    put( "fapiPrivate", "https://fapi.binance.com/fapi/v1" );
                    put( "fapiPrivateV2", "https://fapi.binance.com/fapi/v2" );
                    put( "fapiPrivateV3", "https://fapi.binance.com/fapi/v3" );
                    put( "fapiData", "https://fapi.binance.com/futures/data" );
                    put( "public", "https://api.binance.com/api/v3" );
                    put( "private", "https://api.binance.com/api/v3" );
                    put( "v1", "https://api.binance.com/api/v1" );
                    put( "papi", "https://papi.binance.com/papi/v1" );
                }} );
                put( "www", "https://www.binance.com" );
                put( "referral", new java.util.HashMap<String, Object>() {{
                    put( "url", "https://accounts.binance.com/en/register?ref=D7YA7CLY" );
                    put( "discount", 0.1 );
                }} );
                put( "doc", new java.util.ArrayList<Object>(java.util.Arrays.asList("https://developers.binance.com/en")) );
                put( "api_management", "https://www.binance.com/en/usercenter/settings/api-management" );
                put( "fees", "https://www.binance.com/en/fee/schedule" );
            }} );
            put( "api", new java.util.HashMap<String, Object>() {{
                put( "sapi", new java.util.HashMap<String, Object>() {{
                    put( "get", new java.util.HashMap<String, Object>() {{
                        put( "copyTrading/futures/userStatus", 2 );
                        put( "copyTrading/futures/leadSymbol", 2 );
                        put( "system/status", 0.1 );
                        put( "accountSnapshot", 240 );
                        put( "account/info", 0.1 );
                        put( "margin/asset", 1 );
                        put( "margin/pair", 1 );
                        put( "margin/allAssets", 0.1 );
                        put( "margin/allPairs", 0.1 );
                        put( "margin/priceIndex", 1 );
                        put( "spot/delist-schedule", 10 );
                        put( "asset/assetDividend", 1 );
                        put( "asset/dribblet", 0.1 );
                        put( "asset/transfer", 0.1 );
                        put( "asset/assetDetail", 0.1 );
                        put( "asset/tradeFee", 0.1 );
                        put( "asset/ledger-transfer/cloud-mining/queryByPage", 4.0002 );
                        put( "asset/convert-transfer/queryByPage", 0.033335 );
                        put( "asset/wallet/balance", 6 );
                        put( "asset/custody/transfer-history", 6 );
                        put( "margin/borrow-repay", 1 );
                        put( "margin/loan", 1 );
                        put( "margin/repay", 1 );
                        put( "margin/account", 1 );
                        put( "margin/transfer", 0.1 );
                        put( "margin/interestHistory", 0.1 );
                        put( "margin/forceLiquidationRec", 0.1 );
                        put( "margin/order", 1 );
                        put( "margin/openOrders", 1 );
                        put( "margin/allOrders", 20 );
                        put( "margin/myTrades", 1 );
                        put( "margin/maxBorrowable", 5 );
                        put( "margin/maxTransferable", 5 );
                        put( "margin/tradeCoeff", 1 );
                        put( "margin/isolated/transfer", 0.1 );
                        put( "margin/isolated/account", 1 );
                        put( "margin/isolated/pair", 1 );
                        put( "margin/isolated/allPairs", 1 );
                        put( "margin/isolated/accountLimit", 0.1 );
                        put( "margin/interestRateHistory", 0.1 );
                        put( "margin/orderList", 1 );
                        put( "margin/allOrderList", 20 );
                        put( "margin/openOrderList", 1 );
                        put( "margin/crossMarginData", new java.util.HashMap<String, Object>() {{
                            put( "cost", 0.1 );
                            put( "noCoin", 0.5 );
                        }} );
                        put( "margin/isolatedMarginData", new java.util.HashMap<String, Object>() {{
                            put( "cost", 0.1 );
                            put( "noCoin", 1 );
                        }} );
                        put( "margin/isolatedMarginTier", 0.1 );
                        put( "margin/rateLimit/order", 2 );
                        put( "margin/dribblet", 0.1 );
                        put( "margin/dust", 20.001 );
                        put( "margin/crossMarginCollateralRatio", 10 );
                        put( "margin/exchange-small-liability", 0.6667 );
                        put( "margin/exchange-small-liability-history", 0.6667 );
                        put( "margin/next-hourly-interest-rate", 0.6667 );
                        put( "margin/capital-flow", 10 );
                        put( "margin/delist-schedule", 10 );
                        put( "margin/available-inventory", 0.3334 );
                        put( "margin/leverageBracket", 0.1 );
                        put( "loan/vip/loanable/data", 40 );
                        put( "loan/vip/collateral/data", 40 );
                        put( "loan/vip/request/data", 2.6668 );
                        put( "loan/vip/request/interestRate", 2.6668 );
                        put( "loan/income", 40.002 );
                        put( "loan/ongoing/orders", 40 );
                        put( "loan/ltv/adjustment/history", 40 );
                        put( "loan/borrow/history", 40 );
                        put( "loan/repay/history", 40 );
                        put( "loan/loanable/data", 40 );
                        put( "loan/collateral/data", 40 );
                        put( "loan/repay/collateral/rate", 600 );
                        put( "loan/flexible/ongoing/orders", 30 );
                        put( "loan/flexible/borrow/history", 40 );
                        put( "loan/flexible/repay/history", 40 );
                        put( "loan/flexible/ltv/adjustment/history", 40 );
                        put( "loan/vip/ongoing/orders", 40 );
                        put( "loan/vip/repay/history", 40 );
                        put( "loan/vip/collateral/account", 600 );
                        put( "fiat/orders", 600.03 );
                        put( "fiat/payments", 0.1 );
                        put( "futures/transfer", 1 );
                        put( "futures/histDataLink", 0.1 );
                        put( "rebate/taxQuery", 80.004 );
                        put( "capital/config/getall", 1 );
                        put( "capital/deposit/address", 1 );
                        put( "capital/deposit/address/list", 1 );
                        put( "capital/deposit/hisrec", 0.1 );
                        put( "capital/deposit/subAddress", 0.1 );
                        put( "capital/deposit/subHisrec", 0.1 );
                        put( "capital/withdraw/history", 2 );
                        put( "capital/withdraw/address/list", 10 );
                        put( "capital/contract/convertible-coins", 4.0002 );
                        put( "convert/tradeFlow", 20.001 );
                        put( "convert/exchangeInfo", 50 );
                        put( "convert/assetInfo", 10 );
                        put( "convert/orderStatus", 0.6667 );
                        put( "convert/limit/queryOpenOrders", 20.001 );
                        put( "account/status", 0.1 );
                        put( "account/apiTradingStatus", 0.1 );
                        put( "account/apiRestrictions/ipRestriction", 0.1 );
                        put( "bnbBurn", 0.1 );
                        put( "sub-account/futures/account", 1 );
                        put( "sub-account/futures/accountSummary", 0.1 );
                        put( "sub-account/futures/positionRisk", 1 );
                        put( "sub-account/futures/internalTransfer", 0.1 );
                        put( "sub-account/list", 0.1 );
                        put( "sub-account/margin/account", 1 );
                        put( "sub-account/margin/accountSummary", 1 );
                        put( "sub-account/spotSummary", 0.1 );
                        put( "sub-account/status", 1 );
                        put( "sub-account/sub/transfer/history", 0.1 );
                        put( "sub-account/transfer/subUserHistory", 0.1 );
                        put( "sub-account/universalTransfer", 0.1 );
                        put( "sub-account/apiRestrictions/ipRestriction/thirdPartyList", 1 );
                        put( "sub-account/transaction-statistics", 0.40002 );
                        put( "sub-account/subAccountApi/ipRestriction", 20.001 );
                        put( "managed-subaccount/asset", 0.1 );
                        put( "managed-subaccount/accountSnapshot", 240 );
                        put( "managed-subaccount/queryTransLogForInvestor", 0.1 );
                        put( "managed-subaccount/queryTransLogForTradeParent", 0.40002 );
                        put( "managed-subaccount/fetch-future-asset", 0.40002 );
                        put( "managed-subaccount/marginAsset", 0.1 );
                        put( "managed-subaccount/info", 0.40002 );
                        put( "managed-subaccount/deposit/address", 0.006667 );
                        put( "managed-subaccount/query-trans-log", 0.40002 );
                        put( "lending/daily/product/list", 0.1 );
                        put( "lending/daily/userLeftQuota", 0.1 );
                        put( "lending/daily/userRedemptionQuota", 0.1 );
                        put( "lending/daily/token/position", 0.1 );
                        put( "lending/union/account", 0.1 );
                        put( "lending/union/purchaseRecord", 0.1 );
                        put( "lending/union/redemptionRecord", 0.1 );
                        put( "lending/union/interestHistory", 0.1 );
                        put( "lending/project/list", 0.1 );
                        put( "lending/project/position/list", 0.1 );
                        put( "eth-staking/eth/history/stakingHistory", 15 );
                        put( "eth-staking/eth/history/redemptionHistory", 15 );
                        put( "eth-staking/eth/history/rewardsHistory", 15 );
                        put( "eth-staking/eth/quota", 15 );
                        put( "eth-staking/eth/history/rateHistory", 15 );
                        put( "eth-staking/account", 15 );
                        put( "eth-staking/wbeth/history/wrapHistory", 15 );
                        put( "eth-staking/wbeth/history/unwrapHistory", 15 );
                        put( "eth-staking/eth/history/wbethRewardsHistory", 15 );
                        put( "sol-staking/sol/history/stakingHistory", 15 );
                        put( "sol-staking/sol/history/redemptionHistory", 15 );
                        put( "sol-staking/sol/history/bnsolRewardsHistory", 15 );
                        put( "sol-staking/sol/history/rateHistory", 15 );
                        put( "sol-staking/account", 15 );
                        put( "sol-staking/sol/quota", 15 );
                        put( "mining/pub/algoList", 0.1 );
                        put( "mining/pub/coinList", 0.1 );
                        put( "mining/worker/detail", 0.5 );
                        put( "mining/worker/list", 0.5 );
                        put( "mining/payment/list", 0.5 );
                        put( "mining/statistics/user/status", 0.5 );
                        put( "mining/statistics/user/list", 0.5 );
                        put( "mining/payment/uid", 0.5 );
                        put( "bswap/pools", 0.1 );
                        put( "bswap/liquidity", new java.util.HashMap<String, Object>() {{
                            put( "cost", 0.1 );
                            put( "noPoolId", 1 );
                        }} );
                        put( "bswap/liquidityOps", 20.001 );
                        put( "bswap/quote", 1.00005 );
                        put( "bswap/swap", 20.001 );
                        put( "bswap/poolConfigure", 1.00005 );
                        put( "bswap/addLiquidityPreview", 1.00005 );
                        put( "bswap/removeLiquidityPreview", 1.00005 );
                        put( "bswap/unclaimedRewards", 6.667 );
                        put( "bswap/claimedHistory", 6.667 );
                        put( "blvt/tokenInfo", 0.1 );
                        put( "blvt/subscribe/record", 0.1 );
                        put( "blvt/redeem/record", 0.1 );
                        put( "blvt/userLimit", 0.1 );
                        put( "apiReferral/ifNewUser", 1 );
                        put( "apiReferral/customization", 1 );
                        put( "apiReferral/userCustomization", 1 );
                        put( "apiReferral/rebate/recentRecord", 1 );
                        put( "apiReferral/rebate/historicalRecord", 1 );
                        put( "apiReferral/kickback/recentRecord", 1 );
                        put( "apiReferral/kickback/historicalRecord", 1 );
                        put( "broker/subAccountApi", 1 );
                        put( "broker/subAccount", 1 );
                        put( "broker/subAccountApi/commission/futures", 1 );
                        put( "broker/subAccountApi/commission/coinFutures", 1 );
                        put( "broker/info", 1 );
                        put( "broker/transfer", 1 );
                        put( "broker/transfer/futures", 1 );
                        put( "broker/rebate/recentRecord", 1 );
                        put( "broker/rebate/historicalRecord", 1 );
                        put( "broker/subAccount/bnbBurn/status", 1 );
                        put( "broker/subAccount/depositHist", 1 );
                        put( "broker/subAccount/spotSummary", 1 );
                        put( "broker/subAccount/marginSummary", 1 );
                        put( "broker/subAccount/futuresSummary", 1 );
                        put( "broker/rebate/futures/recentRecord", 1 );
                        put( "broker/subAccountApi/ipRestriction", 1 );
                        put( "broker/universalTransfer", 1 );
                        put( "account/apiRestrictions", 0.1 );
                        put( "c2c/orderMatch/listUserOrderHistory", 0.1 );
                        put( "nft/history/transactions", 20.001 );
                        put( "nft/history/deposit", 20.001 );
                        put( "nft/history/withdraw", 20.001 );
                        put( "nft/user/getAsset", 20.001 );
                        put( "pay/transactions", 20.001 );
                        put( "giftcard/verify", 0.1 );
                        put( "giftcard/cryptography/rsa-public-key", 0.1 );
                        put( "giftcard/buyCode/token-limit", 0.1 );
                        put( "algo/spot/openOrders", 0.1 );
                        put( "algo/spot/historicalOrders", 0.1 );
                        put( "algo/spot/subOrders", 0.1 );
                        put( "algo/futures/openOrders", 0.1 );
                        put( "algo/futures/historicalOrders", 0.1 );
                        put( "algo/futures/subOrders", 0.1 );
                        put( "portfolio/account", 0.1 );
                        put( "portfolio/collateralRate", 5 );
                        put( "portfolio/pmLoan", 3.3335 );
                        put( "portfolio/interest-history", 0.6667 );
                        put( "portfolio/asset-index-price", 0.1 );
                        put( "portfolio/repay-futures-switch", 3 );
                        put( "portfolio/margin-asset-leverage", 5 );
                        put( "portfolio/balance", 2 );
                        put( "portfolio/negative-balance-exchange-record", 2 );
                        put( "portfolio/pmloan-history", 5 );
                        put( "portfolio/earn-asset-balance", 150 );
                        put( "staking/productList", 0.1 );
                        put( "staking/position", 0.1 );
                        put( "staking/stakingRecord", 0.1 );
                        put( "staking/personalLeftQuota", 0.1 );
                        put( "lending/auto-invest/target-asset/list", 0.1 );
                        put( "lending/auto-invest/target-asset/roi/list", 0.1 );
                        put( "lending/auto-invest/all/asset", 0.1 );
                        put( "lending/auto-invest/source-asset/list", 0.1 );
                        put( "lending/auto-invest/plan/list", 0.1 );
                        put( "lending/auto-invest/plan/id", 0.1 );
                        put( "lending/auto-invest/history/list", 0.1 );
                        put( "lending/auto-invest/index/info", 0.1 );
                        put( "lending/auto-invest/index/user-summary", 0.1 );
                        put( "lending/auto-invest/one-off/status", 0.1 );
                        put( "lending/auto-invest/redeem/history", 0.1 );
                        put( "lending/auto-invest/rebalance/history", 0.1 );
                        put( "simple-earn/flexible/list", 15 );
                        put( "simple-earn/locked/list", 15 );
                        put( "simple-earn/flexible/personalLeftQuota", 15 );
                        put( "simple-earn/locked/personalLeftQuota", 15 );
                        put( "simple-earn/flexible/subscriptionPreview", 15 );
                        put( "simple-earn/locked/subscriptionPreview", 15 );
                        put( "simple-earn/flexible/history/rateHistory", 15 );
                        put( "simple-earn/flexible/position", 15 );
                        put( "simple-earn/locked/position", 15 );
                        put( "simple-earn/account", 15 );
                        put( "simple-earn/flexible/history/subscriptionRecord", 15 );
                        put( "simple-earn/locked/history/subscriptionRecord", 15 );
                        put( "simple-earn/flexible/history/redemptionRecord", 15 );
                        put( "simple-earn/locked/history/redemptionRecord", 15 );
                        put( "simple-earn/flexible/history/rewardsRecord", 15 );
                        put( "simple-earn/locked/history/rewardsRecord", 15 );
                        put( "simple-earn/flexible/history/collateralRecord", 0.1 );
                        put( "dci/product/list", 0.1 );
                        put( "dci/product/positions", 0.1 );
                        put( "dci/product/accounts", 0.1 );
                    }} );
                    put( "post", new java.util.HashMap<String, Object>() {{
                        put( "asset/dust", 0.06667 );
                        put( "asset/dust-btc", 0.1 );
                        put( "asset/transfer", 6.0003 );
                        put( "asset/get-funding-asset", 0.1 );
                        put( "asset/convert-transfer", 0.033335 );
                        put( "account/disableFastWithdrawSwitch", 0.1 );
                        put( "account/enableFastWithdrawSwitch", 0.1 );
                        put( "capital/withdraw/apply", 4.0002 );
                        put( "capital/contract/convertible-coins", 4.0002 );
                        put( "capital/deposit/credit-apply", 0.1 );
                        put( "margin/borrow-repay", 20.001 );
                        put( "margin/transfer", 4.0002 );
                        put( "margin/loan", 20.001 );
                        put( "margin/repay", 20.001 );
                        put( "margin/order", 0.040002 );
                        put( "margin/order/oco", 0.040002 );
                        put( "margin/dust", 20.001 );
                        put( "margin/exchange-small-liability", 20.001 );
                        put( "margin/isolated/transfer", 4.0002 );
                        put( "margin/isolated/account", 2.0001 );
                        put( "margin/max-leverage", 300 );
                        put( "bnbBurn", 0.1 );
                        put( "sub-account/virtualSubAccount", 0.1 );
                        put( "sub-account/margin/transfer", 4.0002 );
                        put( "sub-account/margin/enable", 0.1 );
                        put( "sub-account/futures/enable", 0.1 );
                        put( "sub-account/futures/transfer", 0.1 );
                        put( "sub-account/futures/internalTransfer", 0.1 );
                        put( "sub-account/transfer/subToSub", 0.1 );
                        put( "sub-account/transfer/subToMaster", 0.1 );
                        put( "sub-account/universalTransfer", 0.1 );
                        put( "sub-account/options/enable", 0.1 );
                        put( "managed-subaccount/deposit", 0.1 );
                        put( "managed-subaccount/withdraw", 0.1 );
                        put( "userDataStream", 0.1 );
                        put( "userDataStream/isolated", 0.1 );
                        put( "futures/transfer", 0.1 );
                        put( "lending/customizedFixed/purchase", 0.1 );
                        put( "lending/daily/purchase", 0.1 );
                        put( "lending/daily/redeem", 0.1 );
                        put( "bswap/liquidityAdd", 60 );
                        put( "bswap/liquidityRemove", 60 );
                        put( "bswap/swap", 60 );
                        put( "bswap/claimRewards", 6.667 );
                        put( "blvt/subscribe", 0.1 );
                        put( "blvt/redeem", 0.1 );
                        put( "apiReferral/customization", 1 );
                        put( "apiReferral/userCustomization", 1 );
                        put( "apiReferral/rebate/historicalRecord", 1 );
                        put( "apiReferral/kickback/historicalRecord", 1 );
                        put( "broker/subAccount", 1 );
                        put( "broker/subAccount/margin", 1 );
                        put( "broker/subAccount/futures", 1 );
                        put( "broker/subAccountApi", 1 );
                        put( "broker/subAccountApi/permission", 1 );
                        put( "broker/subAccountApi/commission", 1 );
                        put( "broker/subAccountApi/commission/futures", 1 );
                        put( "broker/subAccountApi/commission/coinFutures", 1 );
                        put( "broker/transfer", 1 );
                        put( "broker/transfer/futures", 1 );
                        put( "broker/rebate/historicalRecord", 1 );
                        put( "broker/subAccount/bnbBurn/spot", 1 );
                        put( "broker/subAccount/bnbBurn/marginInterest", 1 );
                        put( "broker/subAccount/blvt", 1 );
                        put( "broker/subAccountApi/ipRestriction", 1 );
                        put( "broker/subAccountApi/ipRestriction/ipList", 1 );
                        put( "broker/universalTransfer", 1 );
                        put( "broker/subAccountApi/permission/universalTransfer", 1 );
                        put( "broker/subAccountApi/permission/vanillaOptions", 1 );
                        put( "giftcard/createCode", 0.1 );
                        put( "giftcard/redeemCode", 0.1 );
                        put( "giftcard/buyCode", 0.1 );
                        put( "algo/spot/newOrderTwap", 20.001 );
                        put( "algo/futures/newOrderVp", 20.001 );
                        put( "algo/futures/newOrderTwap", 20.001 );
                        put( "staking/purchase", 0.1 );
                        put( "staking/redeem", 0.1 );
                        put( "staking/setAutoStaking", 0.1 );
                        put( "eth-staking/eth/stake", 15 );
                        put( "eth-staking/eth/redeem", 15 );
                        put( "eth-staking/wbeth/wrap", 15 );
                        put( "sol-staking/sol/stake", 15 );
                        put( "sol-staking/sol/redeem", 15 );
                        put( "mining/hash-transfer/config", 0.5 );
                        put( "mining/hash-transfer/config/cancel", 0.5 );
                        put( "portfolio/repay", 20.001 );
                        put( "loan/vip/renew", 40.002 );
                        put( "loan/vip/borrow", 40.002 );
                        put( "loan/borrow", 40.002 );
                        put( "loan/repay", 40.002 );
                        put( "loan/adjust/ltv", 40.002 );
                        put( "loan/customize/margin_call", 40.002 );
                        put( "loan/flexible/repay", 40.002 );
                        put( "loan/flexible/adjust/ltv", 40.002 );
                        put( "loan/vip/repay", 40.002 );
                        put( "convert/getQuote", 1.3334 );
                        put( "convert/acceptQuote", 3.3335 );
                        put( "convert/limit/placeOrder", 3.3335 );
                        put( "convert/limit/cancelOrder", 1.3334 );
                        put( "portfolio/auto-collection", 150 );
                        put( "portfolio/asset-collection", 6 );
                        put( "portfolio/bnb-transfer", 150 );
                        put( "portfolio/repay-futures-switch", 150 );
                        put( "portfolio/repay-futures-negative-balance", 150 );
                        put( "portfolio/mint", 20 );
                        put( "portfolio/redeem", 20 );
                        put( "portfolio/earn-asset-transfer", 150 );
                        put( "lending/auto-invest/plan/add", 0.1 );
                        put( "lending/auto-invest/plan/edit", 0.1 );
                        put( "lending/auto-invest/plan/edit-status", 0.1 );
                        put( "lending/auto-invest/one-off", 0.1 );
                        put( "lending/auto-invest/redeem", 0.1 );
                        put( "simple-earn/flexible/subscribe", 0.1 );
                        put( "simple-earn/locked/subscribe", 0.1 );
                        put( "simple-earn/flexible/redeem", 0.1 );
                        put( "simple-earn/locked/redeem", 0.1 );
                        put( "simple-earn/flexible/setAutoSubscribe", 15 );
                        put( "simple-earn/locked/setAutoSubscribe", 15 );
                        put( "simple-earn/locked/setRedeemOption", 5 );
                        put( "dci/product/subscribe", 0.1 );
                        put( "dci/product/auto_compound/edit", 0.1 );
                    }} );
                    put( "put", new java.util.HashMap<String, Object>() {{
                        put( "userDataStream", 0.1 );
                        put( "userDataStream/isolated", 0.1 );
                    }} );
                    put( "delete", new java.util.HashMap<String, Object>() {{
                        put( "margin/openOrders", 0.1 );
                        put( "margin/order", 0.006667 );
                        put( "margin/orderList", 0.006667 );
                        put( "margin/isolated/account", 2.0001 );
                        put( "userDataStream", 0.1 );
                        put( "userDataStream/isolated", 0.1 );
                        put( "broker/subAccountApi", 1 );
                        put( "broker/subAccountApi/ipRestriction/ipList", 1 );
                        put( "algo/spot/order", 0.1 );
                        put( "algo/futures/order", 0.1 );
                        put( "sub-account/subAccountApi/ipRestriction/ipList", 20.001 );
                    }} );
                }} );
                put( "sapiV2", new java.util.HashMap<String, Object>() {{
                    put( "get", new java.util.HashMap<String, Object>() {{
                        put( "eth-staking/account", 15 );
                        put( "sub-account/futures/account", 0.1 );
                        put( "sub-account/futures/accountSummary", 1 );
                        put( "sub-account/futures/positionRisk", 0.1 );
                        put( "loan/flexible/ongoing/orders", 30 );
                        put( "loan/flexible/borrow/history", 40 );
                        put( "loan/flexible/repay/history", 40 );
                        put( "loan/flexible/ltv/adjustment/history", 40 );
                        put( "loan/flexible/loanable/data", 40 );
                        put( "loan/flexible/collateral/data", 40 );
                        put( "portfolio/account", 2 );
                    }} );
                    put( "post", new java.util.HashMap<String, Object>() {{
                        put( "eth-staking/eth/stake", 15 );
                        put( "sub-account/subAccountApi/ipRestriction", 20.001 );
                        put( "loan/flexible/borrow", 40.002 );
                        put( "loan/flexible/repay", 40.002 );
                        put( "loan/flexible/adjust/ltv", 40.002 );
                    }} );
                }} );
                put( "sapiV3", new java.util.HashMap<String, Object>() {{
                    put( "get", new java.util.HashMap<String, Object>() {{
                        put( "sub-account/assets", 0.40002 );
                    }} );
                    put( "post", new java.util.HashMap<String, Object>() {{
                        put( "asset/getUserAsset", 0.5 );
                    }} );
                }} );
                put( "sapiV4", new java.util.HashMap<String, Object>() {{
                    put( "get", new java.util.HashMap<String, Object>() {{
                        put( "sub-account/assets", 0.40002 );
                    }} );
                }} );
                put( "dapiPublic", new java.util.HashMap<String, Object>() {{
                    put( "get", new java.util.HashMap<String, Object>() {{
                        put( "ping", 1 );
                        put( "time", 1 );
                        put( "exchangeInfo", 1 );
                        put( "depth", new java.util.HashMap<String, Object>() {{
                            put( "cost", 2 );
                            put( "byLimit", new java.util.ArrayList<Object>(java.util.Arrays.asList(new java.util.ArrayList<Object>(java.util.Arrays.asList(50, 2)), new java.util.ArrayList<Object>(java.util.Arrays.asList(100, 5)), new java.util.ArrayList<Object>(java.util.Arrays.asList(500, 10)), new java.util.ArrayList<Object>(java.util.Arrays.asList(1000, 20)))) );
                        }} );
                        put( "trades", 5 );
                        put( "historicalTrades", 20 );
                        put( "aggTrades", 20 );
                        put( "premiumIndex", 10 );
                        put( "fundingRate", 1 );
                        put( "klines", new java.util.HashMap<String, Object>() {{
                            put( "cost", 1 );
                            put( "byLimit", new java.util.ArrayList<Object>(java.util.Arrays.asList(new java.util.ArrayList<Object>(java.util.Arrays.asList(99, 1)), new java.util.ArrayList<Object>(java.util.Arrays.asList(499, 2)), new java.util.ArrayList<Object>(java.util.Arrays.asList(1000, 5)), new java.util.ArrayList<Object>(java.util.Arrays.asList(10000, 10)))) );
                        }} );
                        put( "continuousKlines", new java.util.HashMap<String, Object>() {{
                            put( "cost", 1 );
                            put( "byLimit", new java.util.ArrayList<Object>(java.util.Arrays.asList(new java.util.ArrayList<Object>(java.util.Arrays.asList(99, 1)), new java.util.ArrayList<Object>(java.util.Arrays.asList(499, 2)), new java.util.ArrayList<Object>(java.util.Arrays.asList(1000, 5)), new java.util.ArrayList<Object>(java.util.Arrays.asList(10000, 10)))) );
                        }} );
                        put( "indexPriceKlines", new java.util.HashMap<String, Object>() {{
                            put( "cost", 1 );
                            put( "byLimit", new java.util.ArrayList<Object>(java.util.Arrays.asList(new java.util.ArrayList<Object>(java.util.Arrays.asList(99, 1)), new java.util.ArrayList<Object>(java.util.Arrays.asList(499, 2)), new java.util.ArrayList<Object>(java.util.Arrays.asList(1000, 5)), new java.util.ArrayList<Object>(java.util.Arrays.asList(10000, 10)))) );
                        }} );
                        put( "markPriceKlines", new java.util.HashMap<String, Object>() {{
                            put( "cost", 1 );
                            put( "byLimit", new java.util.ArrayList<Object>(java.util.Arrays.asList(new java.util.ArrayList<Object>(java.util.Arrays.asList(99, 1)), new java.util.ArrayList<Object>(java.util.Arrays.asList(499, 2)), new java.util.ArrayList<Object>(java.util.Arrays.asList(1000, 5)), new java.util.ArrayList<Object>(java.util.Arrays.asList(10000, 10)))) );
                        }} );
                        put( "premiumIndexKlines", new java.util.HashMap<String, Object>() {{
                            put( "cost", 1 );
                            put( "byLimit", new java.util.ArrayList<Object>(java.util.Arrays.asList(new java.util.ArrayList<Object>(java.util.Arrays.asList(99, 1)), new java.util.ArrayList<Object>(java.util.Arrays.asList(499, 2)), new java.util.ArrayList<Object>(java.util.Arrays.asList(1000, 5)), new java.util.ArrayList<Object>(java.util.Arrays.asList(10000, 10)))) );
                        }} );
                        put( "ticker/24hr", new java.util.HashMap<String, Object>() {{
                            put( "cost", 1 );
                            put( "noSymbol", 40 );
                        }} );
                        put( "ticker/price", new java.util.HashMap<String, Object>() {{
                            put( "cost", 1 );
                            put( "noSymbol", 2 );
                        }} );
                        put( "ticker/bookTicker", new java.util.HashMap<String, Object>() {{
                            put( "cost", 2 );
                            put( "noSymbol", 5 );
                        }} );
                        put( "constituents", 2 );
                        put( "openInterest", 1 );
                        put( "fundingInfo", 1 );
                    }} );
                }} );
                put( "dapiData", new java.util.HashMap<String, Object>() {{
                    put( "get", new java.util.HashMap<String, Object>() {{
                        put( "delivery-price", 1 );
                        put( "openInterestHist", 1 );
                        put( "topLongShortAccountRatio", 1 );
                        put( "topLongShortPositionRatio", 1 );
                        put( "globalLongShortAccountRatio", 1 );
                        put( "takerBuySellVol", 1 );
                        put( "basis", 1 );
                    }} );
                }} );
                put( "dapiPrivate", new java.util.HashMap<String, Object>() {{
                    put( "get", new java.util.HashMap<String, Object>() {{
                        put( "positionSide/dual", 30 );
                        put( "orderAmendment", 1 );
                        put( "order", 1 );
                        put( "openOrder", 1 );
                        put( "openOrders", new java.util.HashMap<String, Object>() {{
                            put( "cost", 1 );
                            put( "noSymbol", 5 );
                        }} );
                        put( "allOrders", new java.util.HashMap<String, Object>() {{
                            put( "cost", 20 );
                            put( "noSymbol", 40 );
                        }} );
                        put( "balance", 1 );
                        put( "account", 5 );
                        put( "positionMargin/history", 1 );
                        put( "positionRisk", 1 );
                        put( "userTrades", new java.util.HashMap<String, Object>() {{
                            put( "cost", 20 );
                            put( "noSymbol", 40 );
                        }} );
                        put( "income", 20 );
                        put( "leverageBracket", 1 );
                        put( "forceOrders", new java.util.HashMap<String, Object>() {{
                            put( "cost", 20 );
                            put( "noSymbol", 50 );
                        }} );
                        put( "adlQuantile", 5 );
                        put( "commissionRate", 20 );
                        put( "income/asyn", 5 );
                        put( "income/asyn/id", 5 );
                        put( "trade/asyn", 0.5 );
                        put( "trade/asyn/id", 0.5 );
                        put( "order/asyn", 0.5 );
                        put( "order/asyn/id", 0.5 );
                        put( "pmExchangeInfo", 0.5 );
                        put( "pmAccountInfo", 0.5 );
                    }} );
                    put( "post", new java.util.HashMap<String, Object>() {{
                        put( "positionSide/dual", 1 );
                        put( "order", 4 );
                        put( "batchOrders", 5 );
                        put( "countdownCancelAll", 10 );
                        put( "leverage", 1 );
                        put( "marginType", 1 );
                        put( "positionMargin", 1 );
                        put( "listenKey", 1 );
                    }} );
                    put( "put", new java.util.HashMap<String, Object>() {{
                        put( "listenKey", 1 );
                        put( "order", 1 );
                        put( "batchOrders", 5 );
                    }} );
                    put( "delete", new java.util.HashMap<String, Object>() {{
                        put( "order", 1 );
                        put( "allOpenOrders", 1 );
                        put( "batchOrders", 5 );
                        put( "listenKey", 1 );
                    }} );
                }} );
                put( "dapiPrivateV2", new java.util.HashMap<String, Object>() {{
                    put( "get", new java.util.HashMap<String, Object>() {{
                        put( "leverageBracket", 1 );
                    }} );
                }} );
                put( "fapiPublic", new java.util.HashMap<String, Object>() {{
                    put( "get", new java.util.HashMap<String, Object>() {{
                        put( "ping", 1 );
                        put( "time", 1 );
                        put( "exchangeInfo", 1 );
                        put( "depth", new java.util.HashMap<String, Object>() {{
                            put( "cost", 2 );
                            put( "byLimit", new java.util.ArrayList<Object>(java.util.Arrays.asList(new java.util.ArrayList<Object>(java.util.Arrays.asList(50, 2)), new java.util.ArrayList<Object>(java.util.Arrays.asList(100, 5)), new java.util.ArrayList<Object>(java.util.Arrays.asList(500, 10)), new java.util.ArrayList<Object>(java.util.Arrays.asList(1000, 20)))) );
                        }} );
                        put( "trades", 5 );
                        put( "historicalTrades", 20 );
                        put( "aggTrades", 20 );
                        put( "klines", new java.util.HashMap<String, Object>() {{
                            put( "cost", 1 );
                            put( "byLimit", new java.util.ArrayList<Object>(java.util.Arrays.asList(new java.util.ArrayList<Object>(java.util.Arrays.asList(99, 1)), new java.util.ArrayList<Object>(java.util.Arrays.asList(499, 2)), new java.util.ArrayList<Object>(java.util.Arrays.asList(1000, 5)), new java.util.ArrayList<Object>(java.util.Arrays.asList(10000, 10)))) );
                        }} );
                        put( "continuousKlines", new java.util.HashMap<String, Object>() {{
                            put( "cost", 1 );
                            put( "byLimit", new java.util.ArrayList<Object>(java.util.Arrays.asList(new java.util.ArrayList<Object>(java.util.Arrays.asList(99, 1)), new java.util.ArrayList<Object>(java.util.Arrays.asList(499, 2)), new java.util.ArrayList<Object>(java.util.Arrays.asList(1000, 5)), new java.util.ArrayList<Object>(java.util.Arrays.asList(10000, 10)))) );
                        }} );
                        put( "markPriceKlines", new java.util.HashMap<String, Object>() {{
                            put( "cost", 1 );
                            put( "byLimit", new java.util.ArrayList<Object>(java.util.Arrays.asList(new java.util.ArrayList<Object>(java.util.Arrays.asList(99, 1)), new java.util.ArrayList<Object>(java.util.Arrays.asList(499, 2)), new java.util.ArrayList<Object>(java.util.Arrays.asList(1000, 5)), new java.util.ArrayList<Object>(java.util.Arrays.asList(10000, 10)))) );
                        }} );
                        put( "indexPriceKlines", new java.util.HashMap<String, Object>() {{
                            put( "cost", 1 );
                            put( "byLimit", new java.util.ArrayList<Object>(java.util.Arrays.asList(new java.util.ArrayList<Object>(java.util.Arrays.asList(99, 1)), new java.util.ArrayList<Object>(java.util.Arrays.asList(499, 2)), new java.util.ArrayList<Object>(java.util.Arrays.asList(1000, 5)), new java.util.ArrayList<Object>(java.util.Arrays.asList(10000, 10)))) );
                        }} );
                        put( "premiumIndexKlines", new java.util.HashMap<String, Object>() {{
                            put( "cost", 1 );
                            put( "byLimit", new java.util.ArrayList<Object>(java.util.Arrays.asList(new java.util.ArrayList<Object>(java.util.Arrays.asList(99, 1)), new java.util.ArrayList<Object>(java.util.Arrays.asList(499, 2)), new java.util.ArrayList<Object>(java.util.Arrays.asList(1000, 5)), new java.util.ArrayList<Object>(java.util.Arrays.asList(10000, 10)))) );
                        }} );
                        put( "fundingRate", 1 );
                        put( "fundingInfo", 1 );
                        put( "premiumIndex", 1 );
                        put( "ticker/24hr", new java.util.HashMap<String, Object>() {{
                            put( "cost", 1 );
                            put( "noSymbol", 40 );
                        }} );
                        put( "ticker/price", new java.util.HashMap<String, Object>() {{
                            put( "cost", 1 );
                            put( "noSymbol", 2 );
                        }} );
                        put( "ticker/bookTicker", new java.util.HashMap<String, Object>() {{
                            put( "cost", 1 );
                            put( "noSymbol", 2 );
                        }} );
                        put( "openInterest", 1 );
                        put( "indexInfo", 1 );
                        put( "assetIndex", new java.util.HashMap<String, Object>() {{
                            put( "cost", 1 );
                            put( "noSymbol", 10 );
                        }} );
                        put( "constituents", 2 );
                        put( "apiTradingStatus", new java.util.HashMap<String, Object>() {{
                            put( "cost", 1 );
                            put( "noSymbol", 10 );
                        }} );
                        put( "lvtKlines", 1 );
                        put( "convert/exchangeInfo", 4 );
                        put( "insuranceBalance", 1 );
                    }} );
                }} );
                put( "fapiData", new java.util.HashMap<String, Object>() {{
                    put( "get", new java.util.HashMap<String, Object>() {{
                        put( "delivery-price", 1 );
                        put( "openInterestHist", 1 );
                        put( "topLongShortAccountRatio", 1 );
                        put( "topLongShortPositionRatio", 1 );
                        put( "globalLongShortAccountRatio", 1 );
                        put( "takerlongshortRatio", 1 );
                        put( "basis", 1 );
                    }} );
                }} );
                put( "fapiPrivate", new java.util.HashMap<String, Object>() {{
                    put( "get", new java.util.HashMap<String, Object>() {{
                        put( "forceOrders", new java.util.HashMap<String, Object>() {{
                            put( "cost", 20 );
                            put( "noSymbol", 50 );
                        }} );
                        put( "allOrders", 5 );
                        put( "openOrder", 1 );
                        put( "openOrders", new java.util.HashMap<String, Object>() {{
                            put( "cost", 1 );
                            put( "noSymbol", 40 );
                        }} );
                        put( "order", 1 );
                        put( "account", 5 );
                        put( "balance", 5 );
                        put( "leverageBracket", 1 );
                        put( "positionMargin/history", 1 );
                        put( "positionRisk", 5 );
                        put( "positionSide/dual", 30 );
                        put( "userTrades", 5 );
                        put( "income", 30 );
                        put( "commissionRate", 20 );
                        put( "rateLimit/order", 1 );
                        put( "apiTradingStatus", 1 );
                        put( "multiAssetsMargin", 30 );
                        put( "apiReferral/ifNewUser", 1 );
                        put( "apiReferral/customization", 1 );
                        put( "apiReferral/userCustomization", 1 );
                        put( "apiReferral/traderNum", 1 );
                        put( "apiReferral/overview", 1 );
                        put( "apiReferral/tradeVol", 1 );
                        put( "apiReferral/rebateVol", 1 );
                        put( "apiReferral/traderSummary", 1 );
                        put( "adlQuantile", 5 );
                        put( "pmAccountInfo", 5 );
                        put( "orderAmendment", 1 );
                        put( "income/asyn", 1000 );
                        put( "income/asyn/id", 10 );
                        put( "order/asyn", 1000 );
                        put( "order/asyn/id", 10 );
                        put( "trade/asyn", 1000 );
                        put( "trade/asyn/id", 10 );
                        put( "feeBurn", 1 );
                        put( "symbolConfig", 5 );
                        put( "accountConfig", 5 );
                        put( "convert/orderStatus", 5 );
                    }} );
                    put( "post", new java.util.HashMap<String, Object>() {{
                        put( "batchOrders", 5 );
                        put( "positionSide/dual", 1 );
                        put( "positionMargin", 1 );
                        put( "marginType", 1 );
                        put( "order", 4 );
                        put( "leverage", 1 );
                        put( "listenKey", 1 );
                        put( "countdownCancelAll", 10 );
                        put( "multiAssetsMargin", 1 );
                        put( "apiReferral/customization", 1 );
                        put( "apiReferral/userCustomization", 1 );
                        put( "feeBurn", 1 );
                        put( "convert/getQuote", 200 );
                        put( "convert/acceptQuote", 20 );
                    }} );
                    put( "put", new java.util.HashMap<String, Object>() {{
                        put( "listenKey", 1 );
                        put( "order", 1 );
                        put( "batchOrders", 5 );
                    }} );
                    put( "delete", new java.util.HashMap<String, Object>() {{
                        put( "batchOrders", 1 );
                        put( "order", 1 );
                        put( "allOpenOrders", 1 );
                        put( "listenKey", 1 );
                    }} );
                }} );
                put( "fapiPublicV2", new java.util.HashMap<String, Object>() {{
                    put( "get", new java.util.HashMap<String, Object>() {{
                        put( "ticker/price", 0 );
                    }} );
                }} );
                put( "fapiPrivateV2", new java.util.HashMap<String, Object>() {{
                    put( "get", new java.util.HashMap<String, Object>() {{
                        put( "account", 1 );
                        put( "balance", 1 );
                        put( "positionRisk", 1 );
                    }} );
                }} );
                put( "fapiPublicV3", new java.util.HashMap<String, Object>() {{
                    put( "get", new java.util.HashMap<String, Object>() {{}} );
                }} );
                put( "fapiPrivateV3", new java.util.HashMap<String, Object>() {{
                    put( "get", new java.util.HashMap<String, Object>() {{
                        put( "account", 1 );
                        put( "balance", 1 );
                        put( "positionRisk", 1 );
                    }} );
                }} );
                put( "eapiPublic", new java.util.HashMap<String, Object>() {{
                    put( "get", new java.util.HashMap<String, Object>() {{
                        put( "ping", 1 );
                        put( "time", 1 );
                        put( "exchangeInfo", 1 );
                        put( "index", 1 );
                        put( "ticker", 5 );
                        put( "mark", 5 );
                        put( "depth", 1 );
                        put( "klines", 1 );
                        put( "trades", 5 );
                        put( "historicalTrades", 20 );
                        put( "exerciseHistory", 3 );
                        put( "openInterest", 3 );
                    }} );
                }} );
                put( "eapiPrivate", new java.util.HashMap<String, Object>() {{
                    put( "get", new java.util.HashMap<String, Object>() {{
                        put( "account", 3 );
                        put( "position", 5 );
                        put( "openOrders", new java.util.HashMap<String, Object>() {{
                            put( "cost", 1 );
                            put( "noSymbol", 40 );
                        }} );
                        put( "historyOrders", 3 );
                        put( "userTrades", 5 );
                        put( "exerciseRecord", 5 );
                        put( "bill", 1 );
                        put( "income/asyn", 5 );
                        put( "income/asyn/id", 5 );
                        put( "marginAccount", 3 );
                        put( "mmp", 1 );
                        put( "countdownCancelAll", 1 );
                        put( "order", 1 );
                        put( "block/order/orders", 5 );
                        put( "block/order/execute", 5 );
                        put( "block/user-trades", 5 );
                        put( "blockTrades", 5 );
                    }} );
                    put( "post", new java.util.HashMap<String, Object>() {{
                        put( "order", 1 );
                        put( "batchOrders", 5 );
                        put( "listenKey", 1 );
                        put( "mmpSet", 1 );
                        put( "mmpReset", 1 );
                        put( "countdownCancelAll", 1 );
                        put( "countdownCancelAllHeartBeat", 10 );
                        put( "block/order/create", 5 );
                        put( "block/order/execute", 5 );
                    }} );
                    put( "put", new java.util.HashMap<String, Object>() {{
                        put( "listenKey", 1 );
                        put( "block/order/create", 5 );
                    }} );
                    put( "delete", new java.util.HashMap<String, Object>() {{
                        put( "order", 1 );
                        put( "batchOrders", 1 );
                        put( "allOpenOrders", 1 );
                        put( "allOpenOrdersByUnderlying", 1 );
                        put( "listenKey", 1 );
                        put( "block/order/create", 5 );
                    }} );
                }} );
                put( "public", new java.util.HashMap<String, Object>() {{
                    put( "get", new java.util.HashMap<String, Object>() {{
                        put( "ping", 0.2 );
                        put( "time", 0.2 );
                        put( "depth", new java.util.HashMap<String, Object>() {{
                            put( "cost", 1 );
                            put( "byLimit", new java.util.ArrayList<Object>(java.util.Arrays.asList(new java.util.ArrayList<Object>(java.util.Arrays.asList(100, 1)), new java.util.ArrayList<Object>(java.util.Arrays.asList(500, 5)), new java.util.ArrayList<Object>(java.util.Arrays.asList(1000, 10)), new java.util.ArrayList<Object>(java.util.Arrays.asList(5000, 50)))) );
                        }} );
                        put( "trades", 2 );
                        put( "aggTrades", 0.4 );
                        put( "historicalTrades", 2 );
                        put( "klines", 0.4 );
                        put( "uiKlines", 0.4 );
                        put( "ticker/24hr", new java.util.HashMap<String, Object>() {{
                            put( "cost", 0.4 );
                            put( "noSymbol", 16 );
                        }} );
                        put( "ticker", new java.util.HashMap<String, Object>() {{
                            put( "cost", 0.4 );
                            put( "noSymbol", 16 );
                        }} );
                        put( "ticker/tradingDay", 0.8 );
                        put( "ticker/price", new java.util.HashMap<String, Object>() {{
                            put( "cost", 0.4 );
                            put( "noSymbol", 0.8 );
                        }} );
                        put( "ticker/bookTicker", new java.util.HashMap<String, Object>() {{
                            put( "cost", 0.4 );
                            put( "noSymbol", 0.8 );
                        }} );
                        put( "exchangeInfo", 4 );
                        put( "avgPrice", 0.4 );
                    }} );
                    put( "put", new java.util.HashMap<String, Object>() {{
                        put( "userDataStream", 0.4 );
                    }} );
                    put( "post", new java.util.HashMap<String, Object>() {{
                        put( "userDataStream", 0.4 );
                    }} );
                    put( "delete", new java.util.HashMap<String, Object>() {{
                        put( "userDataStream", 0.4 );
                    }} );
                }} );
                put( "private", new java.util.HashMap<String, Object>() {{
                    put( "get", new java.util.HashMap<String, Object>() {{
                        put( "allOrderList", 4 );
                        put( "openOrderList", 1.2 );
                        put( "orderList", 0.8 );
                        put( "order", 0.8 );
                        put( "openOrders", new java.util.HashMap<String, Object>() {{
                            put( "cost", 1.2 );
                            put( "noSymbol", 16 );
                        }} );
                        put( "allOrders", 4 );
                        put( "account", 4 );
                        put( "myTrades", 4 );
                        put( "rateLimit/order", 8 );
                        put( "myPreventedMatches", 4 );
                        put( "myAllocations", 4 );
                        put( "account/commission", 4 );
                    }} );
                    put( "post", new java.util.HashMap<String, Object>() {{
                        put( "order/oco", 0.2 );
                        put( "orderList/oco", 0.2 );
                        put( "orderList/oto", 0.2 );
                        put( "orderList/otoco", 0.2 );
                        put( "sor/order", 0.2 );
                        put( "sor/order/test", 0.2 );
                        put( "order", 0.2 );
                        put( "order/cancelReplace", 0.2 );
                        put( "order/test", 0.2 );
                    }} );
                    put( "delete", new java.util.HashMap<String, Object>() {{
                        put( "openOrders", 0.2 );
                        put( "orderList", 0.2 );
                        put( "order", 0.2 );
                    }} );
                }} );
                put( "papi", new java.util.HashMap<String, Object>() {{
                    put( "get", new java.util.HashMap<String, Object>() {{
                        put( "ping", 0.2 );
                        put( "um/order", 1 );
                        put( "um/openOrder", 1 );
                        put( "um/openOrders", new java.util.HashMap<String, Object>() {{
                            put( "cost", 1 );
                            put( "noSymbol", 40 );
                        }} );
                        put( "um/allOrders", 5 );
                        put( "cm/order", 1 );
                        put( "cm/openOrder", 1 );
                        put( "cm/openOrders", new java.util.HashMap<String, Object>() {{
                            put( "cost", 1 );
                            put( "noSymbol", 40 );
                        }} );
                        put( "cm/allOrders", 20 );
                        put( "um/conditional/openOrder", 1 );
                        put( "um/conditional/openOrders", new java.util.HashMap<String, Object>() {{
                            put( "cost", 1 );
                            put( "noSymbol", 40 );
                        }} );
                        put( "um/conditional/orderHistory", 1 );
                        put( "um/conditional/allOrders", new java.util.HashMap<String, Object>() {{
                            put( "cost", 1 );
                            put( "noSymbol", 40 );
                        }} );
                        put( "cm/conditional/openOrder", 1 );
                        put( "cm/conditional/openOrders", new java.util.HashMap<String, Object>() {{
                            put( "cost", 1 );
                            put( "noSymbol", 40 );
                        }} );
                        put( "cm/conditional/orderHistory", 1 );
                        put( "cm/conditional/allOrders", 40 );
                        put( "margin/order", 10 );
                        put( "margin/openOrders", 5 );
                        put( "margin/allOrders", 100 );
                        put( "margin/orderList", 5 );
                        put( "margin/allOrderList", 100 );
                        put( "margin/openOrderList", 5 );
                        put( "margin/myTrades", 5 );
                        put( "balance", 4 );
                        put( "account", 4 );
                        put( "margin/maxBorrowable", 1 );
                        put( "margin/maxWithdraw", 1 );
                        put( "um/positionRisk", 1 );
                        put( "cm/positionRisk", 0.2 );
                        put( "um/positionSide/dual", 6 );
                        put( "cm/positionSide/dual", 6 );
                        put( "um/userTrades", 5 );
                        put( "cm/userTrades", 20 );
                        put( "um/leverageBracket", 0.2 );
                        put( "cm/leverageBracket", 0.2 );
                        put( "margin/forceOrders", 1 );
                        put( "um/forceOrders", new java.util.HashMap<String, Object>() {{
                            put( "cost", 20 );
                            put( "noSymbol", 50 );
                        }} );
                        put( "cm/forceOrders", new java.util.HashMap<String, Object>() {{
                            put( "cost", 20 );
                            put( "noSymbol", 50 );
                        }} );
                        put( "um/apiTradingStatus", new java.util.HashMap<String, Object>() {{
                            put( "cost", 0.2 );
                            put( "noSymbol", 2 );
                        }} );
                        put( "um/commissionRate", 4 );
                        put( "cm/commissionRate", 4 );
                        put( "margin/marginLoan", 2 );
                        put( "margin/repayLoan", 2 );
                        put( "margin/marginInterestHistory", 0.2 );
                        put( "portfolio/interest-history", 10 );
                        put( "um/income", 6 );
                        put( "cm/income", 6 );
                        put( "um/account", 1 );
                        put( "cm/account", 1 );
                        put( "repay-futures-switch", 6 );
                        put( "um/adlQuantile", 5 );
                        put( "cm/adlQuantile", 5 );
                        put( "um/trade/asyn", 300 );
                        put( "um/trade/asyn/id", 2 );
                        put( "um/order/asyn", 300 );
                        put( "um/order/asyn/id", 2 );
                        put( "um/income/asyn", 300 );
                        put( "um/income/asyn/id", 2 );
                        put( "um/orderAmendment", 1 );
                        put( "cm/orderAmendment", 1 );
                        put( "um/feeBurn", 30 );
                        put( "um/accountConfig", 1 );
                        put( "um/symbolConfig", 1 );
                        put( "cm/accountConfig", 1 );
                        put( "cm/symbolConfig", 1 );
                        put( "rateLimit/order", 1 );
                    }} );
                    put( "post", new java.util.HashMap<String, Object>() {{
                        put( "um/order", 1 );
                        put( "um/conditional/order", 1 );
                        put( "cm/order", 1 );
                        put( "cm/conditional/order", 1 );
                        put( "margin/order", 1 );
                        put( "marginLoan", 100 );
                        put( "repayLoan", 100 );
                        put( "margin/order/oco", 1 );
                        put( "um/leverage", 0.2 );
                        put( "cm/leverage", 0.2 );
                        put( "um/positionSide/dual", 0.2 );
                        put( "cm/positionSide/dual", 0.2 );
                        put( "auto-collection", 150 );
                        put( "bnb-transfer", 150 );
                        put( "repay-futures-switch", 150 );
                        put( "repay-futures-negative-balance", 150 );
                        put( "listenKey", 0.2 );
                        put( "asset-collection", 6 );
                        put( "margin/repay-debt", 3000 );
                        put( "um/feeBurn", 1 );
                    }} );
                    put( "put", new java.util.HashMap<String, Object>() {{
                        put( "listenKey", 0.2 );
                        put( "um/order", 1 );
                        put( "cm/order", 1 );
                    }} );
                    put( "delete", new java.util.HashMap<String, Object>() {{
                        put( "um/order", 1 );
                        put( "um/conditional/order", 1 );
                        put( "um/allOpenOrders", 1 );
                        put( "um/conditional/allOpenOrders", 1 );
                        put( "cm/order", 1 );
                        put( "cm/conditional/order", 1 );
                        put( "cm/allOpenOrders", 1 );
                        put( "cm/conditional/allOpenOrders", 1 );
                        put( "margin/order", 2 );
                        put( "margin/allOpenOrders", 5 );
                        put( "margin/orderList", 2 );
                        put( "listenKey", 0.2 );
                    }} );
                }} );
            }} );
            put( "fees", new java.util.HashMap<String, Object>() {{
                put( "trading", new java.util.HashMap<String, Object>() {{
                    put( "feeSide", "get" );
                    put( "tierBased", false );
                    put( "percentage", true );
                    put( "taker", Binance.this.parseNumber("0.001") );
                    put( "maker", Binance.this.parseNumber("0.001") );
                }} );
                put( "linear", new java.util.HashMap<String, Object>() {{
                    put( "trading", new java.util.HashMap<String, Object>() {{
                        put( "feeSide", "quote" );
                        put( "tierBased", true );
                        put( "percentage", true );
                        put( "taker", Binance.this.parseNumber("0.000500") );
                        put( "maker", Binance.this.parseNumber("0.000200") );
                        put( "tiers", new java.util.HashMap<String, Object>() {{
                            put( "taker", new java.util.ArrayList<Object>(java.util.Arrays.asList(new java.util.ArrayList<Object>(java.util.Arrays.asList(Binance.this.parseNumber("0"), Binance.this.parseNumber("0.000400"))), new java.util.ArrayList<Object>(java.util.Arrays.asList(Binance.this.parseNumber("250"), Binance.this.parseNumber("0.000400"))), new java.util.ArrayList<Object>(java.util.Arrays.asList(Binance.this.parseNumber("2500"), Binance.this.parseNumber("0.000350"))), new java.util.ArrayList<Object>(java.util.Arrays.asList(Binance.this.parseNumber("7500"), Binance.this.parseNumber("0.000320"))), new java.util.ArrayList<Object>(java.util.Arrays.asList(Binance.this.parseNumber("22500"), Binance.this.parseNumber("0.000300"))), new java.util.ArrayList<Object>(java.util.Arrays.asList(Binance.this.parseNumber("50000"), Binance.this.parseNumber("0.000270"))), new java.util.ArrayList<Object>(java.util.Arrays.asList(Binance.this.parseNumber("100000"), Binance.this.parseNumber("0.000250"))), new java.util.ArrayList<Object>(java.util.Arrays.asList(Binance.this.parseNumber("200000"), Binance.this.parseNumber("0.000220"))), new java.util.ArrayList<Object>(java.util.Arrays.asList(Binance.this.parseNumber("400000"), Binance.this.parseNumber("0.000200"))), new java.util.ArrayList<Object>(java.util.Arrays.asList(Binance.this.parseNumber("750000"), Binance.this.parseNumber("0.000170"))))) );
                            put( "maker", new java.util.ArrayList<Object>(java.util.Arrays.asList(new java.util.ArrayList<Object>(java.util.Arrays.asList(Binance.this.parseNumber("0"), Binance.this.parseNumber("0.000200"))), new java.util.ArrayList<Object>(java.util.Arrays.asList(Binance.this.parseNumber("250"), Binance.this.parseNumber("0.000160"))), new java.util.ArrayList<Object>(java.util.Arrays.asList(Binance.this.parseNumber("2500"), Binance.this.parseNumber("0.000140"))), new java.util.ArrayList<Object>(java.util.Arrays.asList(Binance.this.parseNumber("7500"), Binance.this.parseNumber("0.000120"))), new java.util.ArrayList<Object>(java.util.Arrays.asList(Binance.this.parseNumber("22500"), Binance.this.parseNumber("0.000100"))), new java.util.ArrayList<Object>(java.util.Arrays.asList(Binance.this.parseNumber("50000"), Binance.this.parseNumber("0.000080"))), new java.util.ArrayList<Object>(java.util.Arrays.asList(Binance.this.parseNumber("100000"), Binance.this.parseNumber("0.000060"))), new java.util.ArrayList<Object>(java.util.Arrays.asList(Binance.this.parseNumber("200000"), Binance.this.parseNumber("0.000040"))), new java.util.ArrayList<Object>(java.util.Arrays.asList(Binance.this.parseNumber("400000"), Binance.this.parseNumber("0.000020"))), new java.util.ArrayList<Object>(java.util.Arrays.asList(Binance.this.parseNumber("750000"), Binance.this.parseNumber("0"))))) );
                        }} );
                    }} );
                }} );
                put( "inverse", new java.util.HashMap<String, Object>() {{
                    put( "trading", new java.util.HashMap<String, Object>() {{
                        put( "feeSide", "base" );
                        put( "tierBased", true );
                        put( "percentage", true );
                        put( "taker", Binance.this.parseNumber("0.000500") );
                        put( "maker", Binance.this.parseNumber("0.000100") );
                        put( "tiers", new java.util.HashMap<String, Object>() {{
                            put( "taker", new java.util.ArrayList<Object>(java.util.Arrays.asList(new java.util.ArrayList<Object>(java.util.Arrays.asList(Binance.this.parseNumber("0"), Binance.this.parseNumber("0.000500"))), new java.util.ArrayList<Object>(java.util.Arrays.asList(Binance.this.parseNumber("250"), Binance.this.parseNumber("0.000450"))), new java.util.ArrayList<Object>(java.util.Arrays.asList(Binance.this.parseNumber("2500"), Binance.this.parseNumber("0.000400"))), new java.util.ArrayList<Object>(java.util.Arrays.asList(Binance.this.parseNumber("7500"), Binance.this.parseNumber("0.000300"))), new java.util.ArrayList<Object>(java.util.Arrays.asList(Binance.this.parseNumber("22500"), Binance.this.parseNumber("0.000250"))), new java.util.ArrayList<Object>(java.util.Arrays.asList(Binance.this.parseNumber("50000"), Binance.this.parseNumber("0.000240"))), new java.util.ArrayList<Object>(java.util.Arrays.asList(Binance.this.parseNumber("100000"), Binance.this.parseNumber("0.000240"))), new java.util.ArrayList<Object>(java.util.Arrays.asList(Binance.this.parseNumber("200000"), Binance.this.parseNumber("0.000240"))), new java.util.ArrayList<Object>(java.util.Arrays.asList(Binance.this.parseNumber("400000"), Binance.this.parseNumber("0.000240"))), new java.util.ArrayList<Object>(java.util.Arrays.asList(Binance.this.parseNumber("750000"), Binance.this.parseNumber("0.000240"))))) );
                            put( "maker", new java.util.ArrayList<Object>(java.util.Arrays.asList(new java.util.ArrayList<Object>(java.util.Arrays.asList(Binance.this.parseNumber("0"), Binance.this.parseNumber("0.000100"))), new java.util.ArrayList<Object>(java.util.Arrays.asList(Binance.this.parseNumber("250"), Binance.this.parseNumber("0.000080"))), new java.util.ArrayList<Object>(java.util.Arrays.asList(Binance.this.parseNumber("2500"), Binance.this.parseNumber("0.000050"))), new java.util.ArrayList<Object>(java.util.Arrays.asList(Binance.this.parseNumber("7500"), Binance.this.parseNumber("0.0000030"))), new java.util.ArrayList<Object>(java.util.Arrays.asList(Binance.this.parseNumber("22500"), Binance.this.parseNumber("0"))), new java.util.ArrayList<Object>(java.util.Arrays.asList(Binance.this.parseNumber("50000"), Binance.this.parseNumber("-0.000050"))), new java.util.ArrayList<Object>(java.util.Arrays.asList(Binance.this.parseNumber("100000"), Binance.this.parseNumber("-0.000060"))), new java.util.ArrayList<Object>(java.util.Arrays.asList(Binance.this.parseNumber("200000"), Binance.this.parseNumber("-0.000070"))), new java.util.ArrayList<Object>(java.util.Arrays.asList(Binance.this.parseNumber("400000"), Binance.this.parseNumber("-0.000080"))), new java.util.ArrayList<Object>(java.util.Arrays.asList(Binance.this.parseNumber("750000"), Binance.this.parseNumber("-0.000090"))))) );
                        }} );
                    }} );
                }} );
                put( "option", new java.util.HashMap<String, Object>() {{}} );
            }} );
            put( "currencies", new java.util.HashMap<String, Object>() {{
                put( "BNFCR", Binance.this.safeCurrencyStructure(new java.util.HashMap<String, Object>() {{
                    put( "id", "BNFCR" );
                    put( "code", "BNFCR" );
                    put( "precision", Binance.this.parseNumber("0.001") );
                }}) );
            }} );
            put( "commonCurrencies", new java.util.HashMap<String, Object>() {{
                put( "BCC", "BCC" );
                put( "YOYO", "YOYOW" );
            }} );
            put( "precisionMode", TICK_SIZE );
            put( "options", new java.util.HashMap<String, Object>() {{
                put( "sandboxMode", false );
                put( "fetchMargins", true );
                put( "fetchMarkets", new java.util.HashMap<String, Object>() {{
                    put( "types", new java.util.ArrayList<Object>(java.util.Arrays.asList("spot", "linear", "inverse")) );
                }} );
                put( "loadAllOptions", false );
                put( "fetchCurrencies", true );
                put( "defaultTimeInForce", "GTC" );
                put( "defaultType", "spot" );
                put( "defaultSubType", null );
                put( "hasAlreadyAuthenticatedSuccessfully", false );
                put( "warnOnFetchOpenOrdersWithoutSymbol", true );
                put( "currencyToPrecisionRoundingMode", TRUNCATE );
                put( "throwMarginModeAlreadySet", false );
                put( "fetchPositions", "positionRisk" );
                put( "recvWindow", Helpers.multiply(10, 1000) );
                put( "timeDifference", 0 );
                put( "adjustForTimeDifference", false );
                put( "newOrderRespType", new java.util.HashMap<String, Object>() {{
                    put( "market", "FULL" );
                    put( "limit", "FULL" );
                }} );
                put( "quoteOrderQty", true );
                put( "broker", new java.util.HashMap<String, Object>() {{
                    put( "spot", "x-TKT5PX2F" );
                    put( "margin", "x-TKT5PX2F" );
                    put( "future", "x-cvBPrNm9" );
                    put( "delivery", "x-xcKtGhcu" );
                    put( "swap", "x-cvBPrNm9" );
                    put( "option", "x-xcKtGhcu" );
                    put( "inverse", "x-xcKtGhcu" );
                }} );
                put( "accountsByType", new java.util.HashMap<String, Object>() {{
                    put( "main", "MAIN" );
                    put( "spot", "MAIN" );
                    put( "funding", "FUNDING" );
                    put( "margin", "MARGIN" );
                    put( "cross", "MARGIN" );
                    put( "future", "UMFUTURE" );
                    put( "delivery", "CMFUTURE" );
                    put( "linear", "UMFUTURE" );
                    put( "swap", "UMFUTURE" );
                    put( "inverse", "CMFUTURE" );
                    put( "option", "OPTION" );
                }} );
                put( "accountsById", new java.util.HashMap<String, Object>() {{
                    put( "MAIN", "spot" );
                    put( "FUNDING", "funding" );
                    put( "MARGIN", "margin" );
                    put( "UMFUTURE", "linear" );
                    put( "CMFUTURE", "inverse" );
                    put( "OPTION", "option" );
                }} );
                put( "networks", new java.util.HashMap<String, Object>() {{
                    put( "ERC20", "ETH" );
                    put( "TRC20", "TRX" );
                    put( "BEP2", "BNB" );
                    put( "BEP20", "BSC" );
                    put( "OMNI", "OMNI" );
                    put( "EOS", "EOS" );
                    put( "SPL", "SOL" );
                    put( "SOL", "SOL" );
                }} );
                put( "networksById", new java.util.HashMap<String, Object>() {{
                    put( "SOL", "SOL" );
                }} );
                put( "impliedNetworks", new java.util.HashMap<String, Object>() {{
                    put( "ETH", new java.util.HashMap<String, Object>() {{
                        put( "ERC20", "ETH" );
                    }} );
                    put( "TRX", new java.util.HashMap<String, Object>() {{
                        put( "TRC20", "TRX" );
                    }} );
                }} );
                put( "legalMoney", new java.util.HashMap<String, Object>() {{
                    put( "MXN", true );
                    put( "UGX", true );
                    put( "SEK", true );
                    put( "CHF", true );
                    put( "VND", true );
                    put( "AED", true );
                    put( "DKK", true );
                    put( "KZT", true );
                    put( "HUF", true );
                    put( "PEN", true );
                    put( "PHP", true );
                    put( "USD", true );
                    put( "TRY", true );
                    put( "EUR", true );
                    put( "NGN", true );
                    put( "PLN", true );
                    put( "BRL", true );
                    put( "ZAR", true );
                    put( "KES", true );
                    put( "ARS", true );
                    put( "RUB", true );
                    put( "AUD", true );
                    put( "NOK", true );
                    put( "CZK", true );
                    put( "GBP", true );
                    put( "UAH", true );
                    put( "GHS", true );
                    put( "HKD", true );
                    put( "CAD", true );
                    put( "INR", true );
                    put( "JPY", true );
                    put( "NZD", true );
                }} );
                put( "legalMoneyCurrenciesById", new java.util.HashMap<String, Object>() {{
                    put( "BUSD", "USD" );
                }} );
                put( "defaultWithdrawPrecision", 1e-8 );
            }} );
            put( "features", new java.util.HashMap<String, Object>() {{
                put( "spot", new java.util.HashMap<String, Object>() {{
                    put( "sandbox", true );
                    put( "fetchCurrencies", new java.util.HashMap<String, Object>() {{
                        put( "private", true );
                    }} );
                    put( "createOrder", new java.util.HashMap<String, Object>() {{
                        put( "marginMode", true );
                        put( "triggerPrice", true );
                        put( "triggerPriceType", null );
                        put( "triggerDirection", false );
                        put( "stopLossPrice", true );
                        put( "takeProfitPrice", true );
                        put( "attachedStopLossTakeProfit", null );
                        put( "timeInForce", new java.util.HashMap<String, Object>() {{
                            put( "IOC", true );
                            put( "FOK", true );
                            put( "PO", true );
                            put( "GTD", false );
                        }} );
                        put( "hedged", true );
                        put( "leverage", false );
                        put( "marketBuyByCost", true );
                        put( "marketBuyRequiresPrice", false );
                        put( "selfTradePrevention", new java.util.HashMap<String, Object>() {{
                            put( "EXPIRE_MAKER", true );
                            put( "EXPIRE_TAKER", true );
                            put( "EXPIRE_BOTH", true );
                            put( "NONE", true );
                        }} );
                        put( "trailing", false );
                        put( "icebergAmount", true );
                    }} );
                    put( "createOrders", null );
                    put( "fetchMyTrades", new java.util.HashMap<String, Object>() {{
                        put( "marginMode", false );
                        put( "limit", 1000 );
                        put( "daysBack", null );
                        put( "untilDays", 1 );
                        put( "symbolRequired", true );
                    }} );
                    put( "fetchOrder", new java.util.HashMap<String, Object>() {{
                        put( "marginMode", true );
                        put( "trigger", false );
                        put( "trailing", false );
                        put( "symbolRequired", true );
                    }} );
                    put( "fetchOpenOrders", new java.util.HashMap<String, Object>() {{
                        put( "marginMode", true );
                        put( "limit", null );
                        put( "trigger", false );
                        put( "trailing", false );
                        put( "symbolRequired", false );
                    }} );
                    put( "fetchOrders", new java.util.HashMap<String, Object>() {{
                        put( "marginMode", true );
                        put( "limit", 1000 );
                        put( "daysBack", null );
                        put( "untilDays", 10000 );
                        put( "trigger", false );
                        put( "trailing", false );
                        put( "symbolRequired", true );
                    }} );
                    put( "fetchClosedOrders", new java.util.HashMap<String, Object>() {{
                        put( "marginMode", true );
                        put( "limit", 1000 );
                        put( "daysBack", null );
                        put( "daysBackCanceled", null );
                        put( "untilDays", 10000 );
                        put( "trigger", false );
                        put( "trailing", false );
                        put( "symbolRequired", true );
                    }} );
                    put( "fetchOHLCV", new java.util.HashMap<String, Object>() {{
                        put( "limit", 1000 );
                    }} );
                }} );
                put( "forDerivatives", new java.util.HashMap<String, Object>() {{
                    put( "sandbox", true );
                    put( "createOrder", new java.util.HashMap<String, Object>() {{
                        put( "marginMode", false );
                        put( "triggerPrice", true );
                        put( "triggerPriceType", new java.util.HashMap<String, Object>() {{
                            put( "mark", true );
                            put( "last", true );
                            put( "index", false );
                        }} );
                        put( "stopLossPrice", true );
                        put( "takeProfitPrice", true );
                        put( "attachedStopLossTakeProfit", null );
                        put( "timeInForce", new java.util.HashMap<String, Object>() {{
                            put( "IOC", true );
                            put( "FOK", true );
                            put( "PO", true );
                            put( "GTD", true );
                        }} );
                        put( "hedged", true );
                        put( "selfTradePrevention", true );
                        put( "trailing", true );
                        put( "iceberg", false );
                        put( "leverage", false );
                        put( "marketBuyRequiresPrice", false );
                        put( "marketBuyByCost", true );
                    }} );
                    put( "createOrders", new java.util.HashMap<String, Object>() {{
                        put( "max", 5 );
                    }} );
                    put( "fetchMyTrades", new java.util.HashMap<String, Object>() {{
                        put( "marginMode", false );
                        put( "daysBack", null );
                        put( "limit", 1000 );
                        put( "untilDays", 7 );
                        put( "symbolRequired", true );
                    }} );
                    put( "fetchOrder", new java.util.HashMap<String, Object>() {{
                        put( "marginMode", false );
                        put( "trigger", false );
                        put( "trailing", false );
                        put( "symbolRequired", true );
                    }} );
                    put( "fetchOpenOrders", new java.util.HashMap<String, Object>() {{
                        put( "marginMode", true );
                        put( "limit", 500 );
                        put( "trigger", false );
                        put( "trailing", false );
                        put( "symbolRequired", false );
                    }} );
                    put( "fetchOrders", new java.util.HashMap<String, Object>() {{
                        put( "marginMode", true );
                        put( "limit", 1000 );
                        put( "daysBack", 90 );
                        put( "untilDays", 7 );
                        put( "trigger", false );
                        put( "trailing", false );
                        put( "symbolRequired", true );
                    }} );
                    put( "fetchClosedOrders", new java.util.HashMap<String, Object>() {{
                        put( "marginMode", true );
                        put( "limit", 1000 );
                        put( "daysBack", 90 );
                        put( "daysBackCanceled", 3 );
                        put( "untilDays", 7 );
                        put( "trigger", false );
                        put( "trailing", false );
                        put( "symbolRequired", true );
                    }} );
                    put( "fetchOHLCV", new java.util.HashMap<String, Object>() {{
                        put( "limit", 1500 );
                    }} );
                }} );
                put( "swap", new java.util.HashMap<String, Object>() {{
                    put( "linear", new java.util.HashMap<String, Object>() {{
                        put( "extends", "forDerivatives" );
                    }} );
                    put( "inverse", new java.util.HashMap<String, Object>() {{
                        put( "extends", "forDerivatives" );
                    }} );
                }} );
                put( "future", new java.util.HashMap<String, Object>() {{
                    put( "linear", new java.util.HashMap<String, Object>() {{
                        put( "extends", "forDerivatives" );
                    }} );
                    put( "inverse", new java.util.HashMap<String, Object>() {{
                        put( "extends", "forDerivatives" );
                    }} );
                }} );
            }} );
            put( "exceptions", new java.util.HashMap<String, Object>() {{
                put( "spot", new java.util.HashMap<String, Object>() {{
                    put( "exact", new java.util.HashMap<String, Object>() {{
                        put( "-1004", OperationFailed.class );
                        put( "-1008", OperationFailed.class );
                        put( "-1099", AuthenticationError.class );
                        put( "-1108", BadRequest.class );
                        put( "-1131", BadRequest.class );
                        put( "-1134", BadRequest.class );
                        put( "-1135", BadRequest.class );
                        put( "-1145", BadRequest.class );
                        put( "-1151", BadSymbol.class );
                        put( "-2008", AuthenticationError.class );
                        put( "-2016", OperationRejected.class );
                        put( "-2021", BadResponse.class );
                        put( "-2022", BadResponse.class );
                        put( "-2026", InvalidOrder.class );
                        put( "-3000", OperationFailed.class );
                        put( "-3001", AuthenticationError.class );
                        put( "-3002", BadSymbol.class );
                        put( "-3003", BadRequest.class );
                        put( "-3004", OperationRejected.class );
                        put( "-3005", BadRequest.class );
                        put( "-3006", BadRequest.class );
                        put( "-3007", OperationFailed.class );
                        put( "-3008", BadRequest.class );
                        put( "-3009", OperationRejected.class );
                        put( "-3010", BadRequest.class );
                        put( "-3011", BadRequest.class );
                        put( "-3012", OperationRejected.class );
                        put( "-3013", BadRequest.class );
                        put( "-3014", AccountSuspended.class );
                        put( "-3015", BadRequest.class );
                        put( "-3016", BadRequest.class );
                        put( "-3017", OperationRejected.class );
                        put( "-3018", AccountSuspended.class );
                        put( "-3019", AccountSuspended.class );
                        put( "-3020", BadRequest.class );
                        put( "-3021", BadRequest.class );
                        put( "-3022", AccountSuspended.class );
                        put( "-3023", OperationRejected.class );
                        put( "-3024", OperationRejected.class );
                        put( "-3025", BadRequest.class );
                        put( "-3026", BadRequest.class );
                        put( "-3027", BadSymbol.class );
                        put( "-3028", BadSymbol.class );
                        put( "-3029", OperationFailed.class );
                        put( "-3036", AccountSuspended.class );
                        put( "-3037", OperationFailed.class );
                        put( "-3038", BadRequest.class );
                        put( "-3041", InsufficientFunds.class );
                        put( "-3042", BadRequest.class );
                        put( "-3043", PermissionDenied.class );
                        put( "-3044", OperationFailed.class );
                        put( "-3045", OperationRejected.class );
                        put( "-3999", PermissionDenied.class );
                        put( "-4000", ExchangeError.class );
                        put( "-4001", BadRequest.class );
                        put( "-4002", BadRequest.class );
                        put( "-4003", BadRequest.class );
                        put( "-4004", AuthenticationError.class );
                        put( "-4005", RateLimitExceeded.class );
                        put( "-4006", BadRequest.class );
                        put( "-4007", PermissionDenied.class );
                        put( "-4008", PermissionDenied.class );
                        put( "-4009", ExchangeError.class );
                        put( "-4010", PermissionDenied.class );
                        put( "-4011", BadRequest.class );
                        put( "-4012", PermissionDenied.class );
                        put( "-4013", AuthenticationError.class );
                        put( "-4014", OperationRejected.class );
                        put( "-4015", PermissionDenied.class );
                        put( "-4016", PermissionDenied.class );
                        put( "-4017", PermissionDenied.class );
                        put( "-4018", BadSymbol.class );
                        put( "-4019", BadRequest.class );
                        put( "-4020", ExchangeError.class );
                        put( "-4021", BadRequest.class );
                        put( "-4022", BadRequest.class );
                        put( "-4023", OperationRejected.class );
                        put( "-4024", InsufficientFunds.class );
                        put( "-4025", InsufficientFunds.class );
                        put( "-4026", InsufficientFunds.class );
                        put( "-4027", OperationFailed.class );
                        put( "-4028", BadRequest.class );
                        put( "-4029", BadRequest.class );
                        put( "-4030", BadResponse.class );
                        put( "-4031", OperationFailed.class );
                        put( "-4032", OperationRejected.class );
                        put( "-4033", BadRequest.class );
                        put( "-4034", OperationRejected.class );
                        put( "-4035", PermissionDenied.class );
                        put( "-4036", PermissionDenied.class );
                        put( "-4037", OperationFailed.class );
                        put( "-4038", OperationFailed.class );
                        put( "-4039", PermissionDenied.class );
                        put( "-4040", OperationRejected.class );
                        put( "-4041", OperationFailed.class );
                        put( "-4042", OperationRejected.class );
                        put( "-4043", OperationRejected.class );
                        put( "-4044", PermissionDenied.class );
                        put( "-4045", OperationFailed.class );
                        put( "-4046", AuthenticationError.class );
                        put( "-4047", BadRequest.class );
                        put( "-4048", ExchangeError.class );
                        put( "-4049", ExchangeError.class );
                        put( "-4050", ExchangeError.class );
                        put( "-4051", ExchangeError.class );
                        put( "-4052", ExchangeError.class );
                        put( "-4053", ExchangeError.class );
                        put( "-4054", ExchangeError.class );
                        put( "-4055", ExchangeError.class );
                        put( "-4056", ExchangeError.class );
                        put( "-4057", ExchangeError.class );
                        put( "-4058", ExchangeError.class );
                        put( "-4059", ExchangeError.class );
                        put( "-4060", OperationFailed.class );
                        put( "-4061", ExchangeError.class );
                        put( "-4062", ExchangeError.class );
                        put( "-4063", ExchangeError.class );
                        put( "-4064", ExchangeError.class );
                        put( "-4065", ExchangeError.class );
                        put( "-4066", ExchangeError.class );
                        put( "-4067", ExchangeError.class );
                        put( "-4068", ExchangeError.class );
                        put( "-4069", ExchangeError.class );
                        put( "-4070", ExchangeError.class );
                        put( "-4071", ExchangeError.class );
                        put( "-4072", ExchangeError.class );
                        put( "-4073", ExchangeError.class );
                        put( "-4074", ExchangeError.class );
                        put( "-4075", ExchangeError.class );
                        put( "-4076", ExchangeError.class );
                        put( "-4077", ExchangeError.class );
                        put( "-4078", ExchangeError.class );
                        put( "-4079", ExchangeError.class );
                        put( "-4080", ExchangeError.class );
                        put( "-4081", ExchangeError.class );
                        put( "-4082", ExchangeError.class );
                        put( "-4083", ExchangeError.class );
                        put( "-4084", ExchangeError.class );
                        put( "-4085", ExchangeError.class );
                        put( "-4086", ExchangeError.class );
                        put( "-4087", ExchangeError.class );
                        put( "-4088", ExchangeError.class );
                        put( "-4089", ExchangeError.class );
                        put( "-4091", ExchangeError.class );
                        put( "-4092", ExchangeError.class );
                        put( "-4093", ExchangeError.class );
                        put( "-4094", ExchangeError.class );
                        put( "-4095", ExchangeError.class );
                        put( "-4096", ExchangeError.class );
                        put( "-4097", ExchangeError.class );
                        put( "-4098", ExchangeError.class );
                        put( "-4099", ExchangeError.class );
                        put( "-4101", ExchangeError.class );
                        put( "-4102", ExchangeError.class );
                        put( "-4103", ExchangeError.class );
                        put( "-4104", ExchangeError.class );
                        put( "-4105", ExchangeError.class );
                        put( "-4106", ExchangeError.class );
                        put( "-4107", ExchangeError.class );
                        put( "-4108", ExchangeError.class );
                        put( "-4109", ExchangeError.class );
                        put( "-4110", ExchangeError.class );
                        put( "-4112", ExchangeError.class );
                        put( "-4113", ExchangeError.class );
                        put( "-4114", ExchangeError.class );
                        put( "-4115", ExchangeError.class );
                        put( "-4116", ExchangeError.class );
                        put( "-4117", ExchangeError.class );
                        put( "-4118", ExchangeError.class );
                        put( "-4119", ExchangeError.class );
                        put( "-4120", ExchangeError.class );
                        put( "-4121", ExchangeError.class );
                        put( "-4122", ExchangeError.class );
                        put( "-4123", ExchangeError.class );
                        put( "-4124", ExchangeError.class );
                        put( "-4125", ExchangeError.class );
                        put( "-4126", ExchangeError.class );
                        put( "-4127", ExchangeError.class );
                        put( "-4128", ExchangeError.class );
                        put( "-4129", ExchangeError.class );
                        put( "-4130", ExchangeError.class );
                        put( "-4131", ExchangeError.class );
                        put( "-4132", ExchangeError.class );
                        put( "-4133", ExchangeError.class );
                        put( "-4134", ExchangeError.class );
                        put( "-4135", ExchangeError.class );
                        put( "-4136", ExchangeError.class );
                        put( "-4137", ExchangeError.class );
                        put( "-4138", ExchangeError.class );
                        put( "-4139", ExchangeError.class );
                        put( "-4141", ExchangeError.class );
                        put( "-4142", ExchangeError.class );
                        put( "-4143", ExchangeError.class );
                        put( "-4144", ExchangeError.class );
                        put( "-4145", ExchangeError.class );
                        put( "-4146", ExchangeError.class );
                        put( "-4147", ExchangeError.class );
                        put( "-4148", ExchangeError.class );
                        put( "-4149", ExchangeError.class );
                        put( "-4150", ExchangeError.class );
                        put( "-5001", BadRequest.class );
                        put( "-5002", InsufficientFunds.class );
                        put( "-5003", InsufficientFunds.class );
                        put( "-5004", OperationRejected.class );
                        put( "-5005", OperationRejected.class );
                        put( "-5006", OperationRejected.class );
                        put( "-5007", BadRequest.class );
                        put( "-5008", OperationRejected.class );
                        put( "-5009", BadSymbol.class );
                        put( "-5010", OperationFailed.class );
                        put( "-5011", BadRequest.class );
                        put( "-5012", OperationFailed.class );
                        put( "-5013", InsufficientFunds.class );
                        put( "-5021", BadRequest.class );
                        put( "-5022", BadRequest.class );
                        put( "-6001", BadSymbol.class );
                        put( "-6003", PermissionDenied.class );
                        put( "-6004", BadRequest.class );
                        put( "-6005", BadRequest.class );
                        put( "-6006", BadRequest.class );
                        put( "-6007", OperationRejected.class );
                        put( "-6008", OperationRejected.class );
                        put( "-6009", RateLimitExceeded.class );
                        put( "-6011", OperationRejected.class );
                        put( "-6012", InsufficientFunds.class );
                        put( "-6013", BadResponse.class );
                        put( "-6014", OperationRejected.class );
                        put( "-6015", BadRequest.class );
                        put( "-6016", BadRequest.class );
                        put( "-6017", PermissionDenied.class );
                        put( "-6018", InsufficientFunds.class );
                        put( "-6019", OperationRejected.class );
                        put( "-6020", BadRequest.class );
                        put( "-7001", BadRequest.class );
                        put( "-7002", BadRequest.class );
                        put( "-10001", OperationFailed.class );
                        put( "-10002", BadRequest.class );
                        put( "-10005", BadResponse.class );
                        put( "-10007", BadRequest.class );
                        put( "-10008", BadRequest.class );
                        put( "-10009", BadRequest.class );
                        put( "-10010", BadRequest.class );
                        put( "-10011", InsufficientFunds.class );
                        put( "-10012", BadRequest.class );
                        put( "-10013", InsufficientFunds.class );
                        put( "-10015", OperationFailed.class );
                        put( "-10016", OperationFailed.class );
                        put( "-10017", OperationRejected.class );
                        put( "-10018", BadRequest.class );
                        put( "-10019", BadRequest.class );
                        put( "-10020", BadRequest.class );
                        put( "-10021", InvalidOrder.class );
                        put( "-10022", BadRequest.class );
                        put( "-10023", OperationFailed.class );
                        put( "-10024", BadRequest.class );
                        put( "-10025", OperationFailed.class );
                        put( "-10026", BadRequest.class );
                        put( "-10028", BadRequest.class );
                        put( "-10029", OperationRejected.class );
                        put( "-10030", OperationRejected.class );
                        put( "-10031", OperationRejected.class );
                        put( "-10032", OperationFailed.class );
                        put( "-10034", OperationRejected.class );
                        put( "-10039", OperationRejected.class );
                        put( "-10040", OperationRejected.class );
                        put( "-10041", OperationFailed.class );
                        put( "-10042", BadSymbol.class );
                        put( "-10043", OperationRejected.class );
                        put( "-10044", OperationRejected.class );
                        put( "-10045", OperationRejected.class );
                        put( "-10046", OperationRejected.class );
                        put( "-10047", PermissionDenied.class );
                        put( "-11008", OperationRejected.class );
                        put( "-12014", RateLimitExceeded.class );
                        put( "-13000", OperationRejected.class );
                        put( "-13001", OperationRejected.class );
                        put( "-13002", OperationRejected.class );
                        put( "-13003", PermissionDenied.class );
                        put( "-13004", OperationRejected.class );
                        put( "-13005", OperationRejected.class );
                        put( "-13006", OperationRejected.class );
                        put( "-13007", PermissionDenied.class );
                        put( "-18002", OperationRejected.class );
                        put( "-18003", OperationRejected.class );
                        put( "-18004", OperationRejected.class );
                        put( "-18005", PermissionDenied.class );
                        put( "-18006", OperationRejected.class );
                        put( "-18007", OperationRejected.class );
                        put( "-21001", BadRequest.class );
                        put( "-21002", BadRequest.class );
                        put( "-21003", BadResponse.class );
                        put( "-21004", OperationRejected.class );
                        put( "-21005", InsufficientFunds.class );
                        put( "-21006", OperationFailed.class );
                        put( "-21007", OperationFailed.class );
                        put( "-32603", BadRequest.class );
                        put( "400002", BadRequest.class );
                        put( "100001003", AuthenticationError.class );
                        put( "200003903", AuthenticationError.class );
                    }} );
                }} );
                put( "linear", new java.util.HashMap<String, Object>() {{
                    put( "exact", new java.util.HashMap<String, Object>() {{
                        put( "-1005", PermissionDenied.class );
                        put( "-1008", OperationFailed.class );
                        put( "-1011", PermissionDenied.class );
                        put( "-1023", BadRequest.class );
                        put( "-1099", AuthenticationError.class );
                        put( "-1109", PermissionDenied.class );
                        put( "-1110", BadRequest.class );
                        put( "-1113", BadRequest.class );
                        put( "-1122", BadRequest.class );
                        put( "-1126", BadSymbol.class );
                        put( "-1136", BadRequest.class );
                        put( "-2012", OperationFailed.class );
                        put( "-2016", OperationRejected.class );
                        put( "-2017", PermissionDenied.class );
                        put( "-2018", InsufficientFunds.class );
                        put( "-2019", InsufficientFunds.class );
                        put( "-2020", OperationFailed.class );
                        put( "-2021", OrderImmediatelyFillable.class );
                        put( "-2022", InvalidOrder.class );
                        put( "-2023", OperationFailed.class );
                        put( "-2024", InsufficientFunds.class );
                        put( "-2025", OperationRejected.class );
                        put( "-2026", InvalidOrder.class );
                        put( "-2027", OperationRejected.class );
                        put( "-2028", OperationRejected.class );
                        put( "-4063", BadRequest.class );
                        put( "-4064", BadRequest.class );
                        put( "-4065", BadRequest.class );
                        put( "-4066", BadRequest.class );
                        put( "-4069", BadRequest.class );
                        put( "-4070", BadRequest.class );
                        put( "-4071", BadRequest.class );
                        put( "-4072", OperationRejected.class );
                        put( "-4073", BadRequest.class );
                        put( "-4074", OperationRejected.class );
                        put( "-4075", BadRequest.class );
                        put( "-4076", OperationRejected.class );
                        put( "-4077", OperationRejected.class );
                        put( "-4078", OperationFailed.class );
                        put( "-4079", BadRequest.class );
                        put( "-4080", PermissionDenied.class );
                        put( "-4081", BadRequest.class );
                        put( "-4085", BadRequest.class );
                        put( "-4087", PermissionDenied.class );
                        put( "-4088", PermissionDenied.class );
                        put( "-4114", BadRequest.class );
                        put( "-4115", BadRequest.class );
                        put( "-4116", InvalidOrder.class );
                        put( "-4117", OperationRejected.class );
                        put( "-4118", OperationRejected.class );
                        put( "-4131", OperationRejected.class );
                        put( "-4140", BadRequest.class );
                        put( "-4141", OperationRejected.class );
                        put( "-4144", BadSymbol.class );
                        put( "-4164", InvalidOrder.class );
                        put( "-4136", InvalidOrder.class );
                        put( "-4165", BadRequest.class );
                        put( "-4167", BadRequest.class );
                        put( "-4168", BadRequest.class );
                        put( "-4169", OperationRejected.class );
                        put( "-4170", OperationRejected.class );
                        put( "-4171", OperationRejected.class );
                        put( "-4172", OperationRejected.class );
                        put( "-4183", BadRequest.class );
                        put( "-4184", BadRequest.class );
                        put( "-4192", PermissionDenied.class );
                        put( "-4202", PermissionDenied.class );
                        put( "-4203", PermissionDenied.class );
                        put( "-4205", PermissionDenied.class );
                        put( "-4206", PermissionDenied.class );
                        put( "-4208", OperationRejected.class );
                        put( "-4209", OperationRejected.class );
                        put( "-4210", BadRequest.class );
                        put( "-4211", BadRequest.class );
                        put( "-4400", PermissionDenied.class );
                        put( "-4401", PermissionDenied.class );
                        put( "-4402", PermissionDenied.class );
                        put( "-4403", PermissionDenied.class );
                        put( "-5021", OrderNotFillable.class );
                        put( "-5022", OrderNotFillable.class );
                        put( "-5024", OperationRejected.class );
                        put( "-5025", OperationRejected.class );
                        put( "-5026", OperationRejected.class );
                        put( "-5027", OperationRejected.class );
                        put( "-5028", BadRequest.class );
                        put( "-5037", BadRequest.class );
                        put( "-5038", BadRequest.class );
                        put( "-5039", BadRequest.class );
                        put( "-5040", BadRequest.class );
                        put( "-5041", OperationFailed.class );
                    }} );
                }} );
                put( "inverse", new java.util.HashMap<String, Object>() {{
                    put( "exact", new java.util.HashMap<String, Object>() {{
                        put( "-1005", PermissionDenied.class );
                        put( "-1011", PermissionDenied.class );
                        put( "-1023", BadRequest.class );
                        put( "-1109", AuthenticationError.class );
                        put( "-1110", BadSymbol.class );
                        put( "-1113", BadRequest.class );
                        put( "-1128", BadRequest.class );
                        put( "-1136", BadRequest.class );
                        put( "-2016", OperationRejected.class );
                        put( "-2018", InsufficientFunds.class );
                        put( "-2019", InsufficientFunds.class );
                        put( "-2020", OperationFailed.class );
                        put( "-2021", OrderImmediatelyFillable.class );
                        put( "-2022", InvalidOrder.class );
                        put( "-2023", OperationFailed.class );
                        put( "-2024", BadRequest.class );
                        put( "-2025", OperationRejected.class );
                        put( "-2026", InvalidOrder.class );
                        put( "-2027", OperationRejected.class );
                        put( "-2028", OperationRejected.class );
                        put( "-4086", BadRequest.class );
                        put( "-4087", BadSymbol.class );
                        put( "-4088", BadRequest.class );
                        put( "-4089", PermissionDenied.class );
                        put( "-4090", PermissionDenied.class );
                        put( "-4110", BadRequest.class );
                        put( "-4111", BadRequest.class );
                        put( "-4112", OperationRejected.class );
                        put( "-4113", OperationRejected.class );
                        put( "-4150", OperationRejected.class );
                        put( "-4151", BadRequest.class );
                        put( "-4152", BadRequest.class );
                        put( "-4154", BadRequest.class );
                        put( "-4155", BadRequest.class );
                        put( "-4178", BadRequest.class );
                        put( "-4188", BadRequest.class );
                        put( "-4192", PermissionDenied.class );
                        put( "-4194", PermissionDenied.class );
                        put( "-4195", PermissionDenied.class );
                        put( "-4196", BadRequest.class );
                        put( "-4197", OperationRejected.class );
                        put( "-4198", OperationRejected.class );
                        put( "-4199", BadRequest.class );
                        put( "-4200", PermissionDenied.class );
                        put( "-4201", PermissionDenied.class );
                        put( "-4202", OperationRejected.class );
                    }} );
                }} );
                put( "option", new java.util.HashMap<String, Object>() {{
                    put( "exact", new java.util.HashMap<String, Object>() {{
                        put( "-1003", ExchangeError.class );
                        put( "-1004", ExchangeError.class );
                        put( "-1006", ExchangeError.class );
                        put( "-1007", ExchangeError.class );
                        put( "-1008", RateLimitExceeded.class );
                        put( "-1010", ExchangeError.class );
                        put( "-1013", ExchangeError.class );
                        put( "-1108", ExchangeError.class );
                        put( "-1112", ExchangeError.class );
                        put( "-1114", ExchangeError.class );
                        put( "-1128", BadSymbol.class );
                        put( "-1129", BadSymbol.class );
                        put( "-1131", BadRequest.class );
                        put( "-2011", ExchangeError.class );
                        put( "-2018", InsufficientFunds.class );
                        put( "-2027", InsufficientFunds.class );
                        put( "-3029", OperationFailed.class );
                        put( "-4006", ExchangeError.class );
                        put( "-4007", ExchangeError.class );
                        put( "-4008", ExchangeError.class );
                        put( "-4009", ExchangeError.class );
                        put( "-4010", ExchangeError.class );
                        put( "-4011", ExchangeError.class );
                        put( "-4012", ExchangeError.class );
                        put( "-4014", ExchangeError.class );
                        put( "-4015", ExchangeError.class );
                        put( "-4016", ExchangeError.class );
                        put( "-4017", ExchangeError.class );
                        put( "-4018", ExchangeError.class );
                        put( "-4019", ExchangeError.class );
                        put( "-4020", ExchangeError.class );
                        put( "-4021", ExchangeError.class );
                        put( "-4022", ExchangeError.class );
                        put( "-4023", ExchangeError.class );
                        put( "-4024", ExchangeError.class );
                        put( "-4025", ExchangeError.class );
                        put( "-4026", ExchangeError.class );
                        put( "-4027", ExchangeError.class );
                        put( "-4028", ExchangeError.class );
                        put( "-4031", ExchangeError.class );
                        put( "-4032", ExchangeError.class );
                        put( "-4033", ExchangeError.class );
                        put( "-4034", ExchangeError.class );
                        put( "-4035", ExchangeError.class );
                        put( "-4036", ExchangeError.class );
                        put( "-4037", ExchangeError.class );
                        put( "-4038", ExchangeError.class );
                        put( "-4039", ExchangeError.class );
                        put( "-4040", ExchangeError.class );
                        put( "-4041", ExchangeError.class );
                        put( "-4042", ExchangeError.class );
                        put( "-4043", ExchangeError.class );
                        put( "-4044", ExchangeError.class );
                        put( "-4045", ExchangeError.class );
                        put( "-4046", ExchangeError.class );
                        put( "-4047", ExchangeError.class );
                        put( "-4048", ExchangeError.class );
                        put( "-4049", ExchangeError.class );
                        put( "-4050", ExchangeError.class );
                        put( "-4051", ExchangeError.class );
                        put( "-4052", ExchangeError.class );
                        put( "-4053", ExchangeError.class );
                        put( "-4054", ExchangeError.class );
                        put( "-4056", ExchangeError.class );
                        put( "-4057", ExchangeError.class );
                        put( "-4058", ExchangeError.class );
                        put( "-4059", ExchangeError.class );
                        put( "-4060", ExchangeError.class );
                        put( "-4061", ExchangeError.class );
                        put( "-4062", ExchangeError.class );
                        put( "-4063", ExchangeError.class );
                        put( "-4064", ExchangeError.class );
                        put( "-4065", ExchangeError.class );
                        put( "-4066", ExchangeError.class );
                        put( "-4067", ExchangeError.class );
                        put( "-4068", ExchangeError.class );
                        put( "-4069", ExchangeError.class );
                        put( "-4070", ExchangeError.class );
                        put( "-4071", ExchangeError.class );
                        put( "-4072", ExchangeError.class );
                        put( "-4073", ExchangeError.class );
                        put( "-4074", ExchangeError.class );
                        put( "-4075", ExchangeError.class );
                        put( "-4076", ExchangeError.class );
                        put( "-4077", ExchangeError.class );
                        put( "-4078", ExchangeError.class );
                        put( "-4079", ExchangeError.class );
                        put( "-4080", ExchangeError.class );
                        put( "-4081", ExchangeError.class );
                        put( "-4082", ExchangeError.class );
                        put( "-4083", ExchangeError.class );
                        put( "-4084", ExchangeError.class );
                        put( "-4085", ExchangeError.class );
                        put( "-4086", ExchangeError.class );
                        put( "-4087", ExchangeError.class );
                        put( "-4088", ExchangeError.class );
                        put( "-4089", ExchangeError.class );
                        put( "-4091", ExchangeError.class );
                        put( "-4092", ExchangeError.class );
                        put( "-4093", ExchangeError.class );
                        put( "-4094", ExchangeError.class );
                        put( "-4095", ExchangeError.class );
                        put( "-4096", ExchangeError.class );
                        put( "-4097", ExchangeError.class );
                        put( "-4098", ExchangeError.class );
                        put( "-4099", ExchangeError.class );
                        put( "-4101", ExchangeError.class );
                        put( "-4102", ExchangeError.class );
                        put( "-4103", ExchangeError.class );
                        put( "-4104", ExchangeError.class );
                        put( "-4105", ExchangeError.class );
                        put( "-4106", ExchangeError.class );
                        put( "-4107", ExchangeError.class );
                        put( "-4108", ExchangeError.class );
                        put( "-4109", ExchangeError.class );
                        put( "-4110", ExchangeError.class );
                        put( "-4112", ExchangeError.class );
                        put( "-4113", ExchangeError.class );
                        put( "-4114", ExchangeError.class );
                        put( "-4115", ExchangeError.class );
                        put( "-4116", ExchangeError.class );
                        put( "-4117", ExchangeError.class );
                        put( "-4118", ExchangeError.class );
                        put( "-4119", ExchangeError.class );
                        put( "-4120", ExchangeError.class );
                        put( "-4121", ExchangeError.class );
                        put( "-4122", ExchangeError.class );
                        put( "-4123", ExchangeError.class );
                        put( "-4124", ExchangeError.class );
                        put( "-4125", ExchangeError.class );
                        put( "-4126", ExchangeError.class );
                        put( "-4127", ExchangeError.class );
                        put( "-4128", ExchangeError.class );
                        put( "-4129", ExchangeError.class );
                        put( "-4130", ExchangeError.class );
                        put( "-4131", ExchangeError.class );
                        put( "-4132", ExchangeError.class );
                        put( "-4133", ExchangeError.class );
                        put( "-4134", ExchangeError.class );
                        put( "-4135", ExchangeError.class );
                        put( "-4136", ExchangeError.class );
                        put( "-4137", ExchangeError.class );
                        put( "-4138", ExchangeError.class );
                        put( "-4139", ExchangeError.class );
                        put( "-4141", ExchangeError.class );
                        put( "-4142", ExchangeError.class );
                        put( "-4143", ExchangeError.class );
                        put( "-4144", ExchangeError.class );
                        put( "-4145", ExchangeError.class );
                        put( "-4146", ExchangeError.class );
                        put( "-4147", ExchangeError.class );
                        put( "-4148", ExchangeError.class );
                        put( "-4149", ExchangeError.class );
                        put( "-4150", ExchangeError.class );
                        put( "-20121", ExchangeError.class );
                        put( "-20124", ExchangeError.class );
                        put( "-20130", ExchangeError.class );
                        put( "-20132", ExchangeError.class );
                        put( "-20194", ExchangeError.class );
                        put( "-20195", ExchangeError.class );
                        put( "-20196", ExchangeError.class );
                        put( "-20198", ExchangeError.class );
                        put( "-20204", ExchangeError.class );
                    }} );
                }} );
                put( "portfolioMargin", new java.util.HashMap<String, Object>() {{
                    put( "exact", new java.util.HashMap<String, Object>() {{
                        put( "-1000", OperationFailed.class );
                        put( "-1001", ExchangeError.class );
                        put( "-1002", PermissionDenied.class );
                        put( "-1003", RateLimitExceeded.class );
                        put( "-1004", BadRequest.class );
                        put( "-1005", PermissionDenied.class );
                        put( "-1006", BadResponse.class );
                        put( "-1007", BadResponse.class );
                        put( "-1008", OperationFailed.class );
                        put( "-1010", ExchangeError.class );
                        put( "-1011", PermissionDenied.class );
                        put( "-1013", ExchangeError.class );
                        put( "-1014", InvalidOrder.class );
                        put( "-1015", InvalidOrder.class );
                        put( "-1016", NotSupported.class );
                        put( "-1020", NotSupported.class );
                        put( "-1021", BadRequest.class );
                        put( "-1022", BadRequest.class );
                        put( "-1023", BadRequest.class );
                        put( "-1099", OperationFailed.class );
                        put( "-1100", BadRequest.class );
                        put( "-1101", BadRequest.class );
                        put( "-1102", BadRequest.class );
                        put( "-1103", BadRequest.class );
                        put( "-1104", BadRequest.class );
                        put( "-1105", BadRequest.class );
                        put( "-1106", BadRequest.class );
                        put( "-1108", BadRequest.class );
                        put( "-1109", BadRequest.class );
                        put( "-1110", BadSymbol.class );
                        put( "-1111", BadRequest.class );
                        put( "-1112", BadRequest.class );
                        put( "-1113", BadRequest.class );
                        put( "-1114", BadRequest.class );
                        put( "-1115", BadRequest.class );
                        put( "-1116", BadRequest.class );
                        put( "-1117", BadRequest.class );
                        put( "-1118", BadRequest.class );
                        put( "-1119", BadRequest.class );
                        put( "-1120", BadRequest.class );
                        put( "-1121", BadSymbol.class );
                        put( "-1125", BadRequest.class );
                        put( "-1127", BadRequest.class );
                        put( "-1128", BadRequest.class );
                        put( "-1130", BadRequest.class );
                        put( "-1131", BadRequest.class );
                        put( "-1134", BadRequest.class );
                        put( "-1136", BadRequest.class );
                        put( "-1145", BadRequest.class );
                        put( "-1151", BadRequest.class );
                        put( "-2010", InvalidOrder.class );
                        put( "-2011", OperationRejected.class );
                        put( "-2013", OrderNotFound.class );
                        put( "-2014", OperationRejected.class );
                        put( "-2015", OperationRejected.class );
                        put( "-2016", OperationFailed.class );
                        put( "-2018", OperationFailed.class );
                        put( "-2019", OperationFailed.class );
                        put( "-2020", OrderNotFillable.class );
                        put( "-2021", OrderImmediatelyFillable.class );
                        put( "-2022", InvalidOrder.class );
                        put( "-2023", OperationFailed.class );
                        put( "-2024", OperationRejected.class );
                        put( "-2025", OperationRejected.class );
                        put( "-2026", InvalidOrder.class );
                        put( "-2027", OperationRejected.class );
                        put( "-2028", OperationRejected.class );
                        put( "-4000", BadRequest.class );
                        put( "-4001", BadRequest.class );
                        put( "-4002", BadRequest.class );
                        put( "-4003", BadRequest.class );
                        put( "-4004", BadRequest.class );
                        put( "-4005", BadRequest.class );
                        put( "-4006", BadRequest.class );
                        put( "-4007", BadRequest.class );
                        put( "-4008", BadRequest.class );
                        put( "-4009", BadRequest.class );
                        put( "-4010", BadRequest.class );
                        put( "-4011", BadRequest.class );
                        put( "-4012", BadRequest.class );
                        put( "-4013", BadRequest.class );
                        put( "-4014", BadRequest.class );
                        put( "-4015", BadRequest.class );
                        put( "-4016", BadRequest.class );
                        put( "-4017", BadRequest.class );
                        put( "-4018", BadRequest.class );
                        put( "-4019", BadRequest.class );
                        put( "-4020", BadRequest.class );
                        put( "-4021", BadRequest.class );
                        put( "-4022", BadRequest.class );
                        put( "-4023", BadRequest.class );
                        put( "-4024", BadRequest.class );
                        put( "-4025", BadRequest.class );
                        put( "-4026", BadRequest.class );
                        put( "-4027", BadRequest.class );
                        put( "-4028", BadRequest.class );
                        put( "-4029", BadRequest.class );
                        put( "-4030", BadRequest.class );
                        put( "-4031", BadRequest.class );
                        put( "-4032", BadRequest.class );
                        put( "-4033", BadRequest.class );
                        put( "-4044", BadRequest.class );
                        put( "-4045", BadRequest.class );
                        put( "-4046", BadRequest.class );
                        put( "-4047", BadRequest.class );
                        put( "-4048", BadRequest.class );
                        put( "-4049", BadRequest.class );
                        put( "-4050", BadRequest.class );
                        put( "-4051", BadRequest.class );
                        put( "-4052", BadRequest.class );
                        put( "-4053", BadRequest.class );
                        put( "-4054", BadRequest.class );
                        put( "-4055", BadRequest.class );
                        put( "-4056", PermissionDenied.class );
                        put( "-4057", PermissionDenied.class );
                        put( "-4058", BadRequest.class );
                        put( "-4059", BadRequest.class );
                        put( "-4060", BadRequest.class );
                        put( "-4061", InvalidOrder.class );
                        put( "-4062", BadRequest.class );
                        put( "-4063", BadRequest.class );
                        put( "-4064", BadRequest.class );
                        put( "-4065", BadRequest.class );
                        put( "-4066", BadRequest.class );
                        put( "-4067", BadRequest.class );
                        put( "-4068", BadRequest.class );
                        put( "-4069", BadRequest.class );
                        put( "-4070", BadRequest.class );
                        put( "-4071", BadRequest.class );
                        put( "-4072", OperationRejected.class );
                        put( "-4073", BadRequest.class );
                        put( "-4074", BadRequest.class );
                        put( "-4075", BadRequest.class );
                        put( "-4076", OperationRejected.class );
                        put( "-4077", OperationRejected.class );
                        put( "-4078", OperationFailed.class );
                        put( "-4079", BadRequest.class );
                        put( "-4080", PermissionDenied.class );
                        put( "-4081", BadRequest.class );
                        put( "-4082", BadRequest.class );
                        put( "-4083", BadRequest.class );
                        put( "-4084", NotSupported.class );
                        put( "-4085", BadRequest.class );
                        put( "-4086", BadRequest.class );
                        put( "-4087", PermissionDenied.class );
                        put( "-4088", PermissionDenied.class );
                        put( "-4104", BadRequest.class );
                        put( "-4114", BadRequest.class );
                        put( "-4115", BadRequest.class );
                        put( "-4118", OperationRejected.class );
                        put( "-4131", OperationRejected.class );
                        put( "-4135", BadRequest.class );
                        put( "-4137", BadRequest.class );
                        put( "-4138", BadRequest.class );
                        put( "-4139", BadRequest.class );
                        put( "-4140", OrderImmediatelyFillable.class );
                        put( "-4141", BadRequest.class );
                        put( "-4142", OrderImmediatelyFillable.class );
                        put( "-4144", BadSymbol.class );
                        put( "-4161", OperationRejected.class );
                        put( "-4164", InvalidOrder.class );
                        put( "-4165", BadRequest.class );
                        put( "-4183", InvalidOrder.class );
                        put( "-4184", InvalidOrder.class );
                        put( "-4408", InvalidOrder.class );
                        put( "-5021", OrderNotFillable.class );
                        put( "-5022", OrderNotFillable.class );
                        put( "-5028", OperationFailed.class );
                        put( "-5041", RateLimitExceeded.class );
                    }} );
                }} );
                put( "exact", new java.util.HashMap<String, Object>() {{
                    put( "-1000", OperationFailed.class );
                    put( "-1001", OperationFailed.class );
                    put( "-1002", AuthenticationError.class );
                    put( "-1003", RateLimitExceeded.class );
                    put( "-1004", OperationRejected.class );
                    put( "-1006", OperationFailed.class );
                    put( "-1007", RequestTimeout.class );
                    put( "-1010", OperationFailed.class );
                    put( "-1013", BadRequest.class );
                    put( "-1014", InvalidOrder.class );
                    put( "-1015", RateLimitExceeded.class );
                    put( "-1016", BadRequest.class );
                    put( "-1020", BadRequest.class );
                    put( "-1021", InvalidNonce.class );
                    put( "-1022", AuthenticationError.class );
                    put( "-1100", BadRequest.class );
                    put( "-1101", BadRequest.class );
                    put( "-1102", BadRequest.class );
                    put( "-1103", BadRequest.class );
                    put( "-1104", BadRequest.class );
                    put( "-1105", BadRequest.class );
                    put( "-1106", BadRequest.class );
                    put( "-1108", BadSymbol.class );
                    put( "-1111", BadRequest.class );
                    put( "-1112", OperationFailed.class );
                    put( "-1114", BadRequest.class );
                    put( "-1115", BadRequest.class );
                    put( "-1116", BadRequest.class );
                    put( "-1117", BadRequest.class );
                    put( "-1118", BadRequest.class );
                    put( "-1119", BadRequest.class );
                    put( "-1120", BadRequest.class );
                    put( "-1121", BadSymbol.class );
                    put( "-1125", AuthenticationError.class );
                    put( "-1127", BadRequest.class );
                    put( "-1128", BadRequest.class );
                    put( "-1130", BadRequest.class );
                    put( "-2010", InvalidOrder.class );
                    put( "-2011", OrderNotFound.class );
                    put( "-2013", OrderNotFound.class );
                    put( "-2014", AuthenticationError.class );
                    put( "-2015", AuthenticationError.class );
                    put( "-4000", InvalidOrder.class );
                    put( "-4001", BadRequest.class );
                    put( "-4002", BadRequest.class );
                    put( "-4003", BadRequest.class );
                    put( "-4004", BadRequest.class );
                    put( "-4005", BadRequest.class );
                    put( "-4006", BadRequest.class );
                    put( "-4007", BadRequest.class );
                    put( "-4008", BadRequest.class );
                    put( "-4009", BadRequest.class );
                    put( "-4010", BadRequest.class );
                    put( "-4011", BadRequest.class );
                    put( "-4012", BadRequest.class );
                    put( "-4013", BadRequest.class );
                    put( "-4014", BadRequest.class );
                    put( "-4015", BadRequest.class );
                    put( "-4016", BadRequest.class );
                    put( "-4017", BadRequest.class );
                    put( "-4018", BadRequest.class );
                    put( "-4019", OperationRejected.class );
                    put( "-4020", BadRequest.class );
                    put( "-4021", BadRequest.class );
                    put( "-4022", BadRequest.class );
                    put( "-4023", BadRequest.class );
                    put( "-4024", BadRequest.class );
                    put( "-4025", BadRequest.class );
                    put( "-4026", BadRequest.class );
                    put( "-4027", BadRequest.class );
                    put( "-4028", BadRequest.class );
                    put( "-4029", BadRequest.class );
                    put( "-4030", BadRequest.class );
                    put( "-4031", BadRequest.class );
                    put( "-4032", OperationRejected.class );
                    put( "-4033", BadRequest.class );
                    put( "-4044", BadRequest.class );
                    put( "-4045", OperationRejected.class );
                    put( "-4046", OperationRejected.class );
                    put( "-4047", OperationRejected.class );
                    put( "-4048", OperationRejected.class );
                    put( "-4049", BadRequest.class );
                    put( "-4050", InsufficientFunds.class );
                    put( "-4051", InsufficientFunds.class );
                    put( "-4052", OperationRejected.class );
                    put( "-4053", BadRequest.class );
                    put( "-4054", OperationRejected.class );
                    put( "-4055", BadRequest.class );
                    put( "-4056", AuthenticationError.class );
                    put( "-4057", AuthenticationError.class );
                    put( "-4058", BadRequest.class );
                    put( "-4059", OperationRejected.class );
                    put( "-4060", BadRequest.class );
                    put( "-4061", OperationRejected.class );
                    put( "-4062", BadRequest.class );
                    put( "-4067", OperationRejected.class );
                    put( "-4068", OperationRejected.class );
                    put( "-4082", BadRequest.class );
                    put( "-4083", OperationRejected.class );
                    put( "-4084", BadRequest.class );
                    put( "-4086", BadRequest.class );
                    put( "-4104", BadRequest.class );
                    put( "-4135", BadRequest.class );
                    put( "-4137", BadRequest.class );
                    put( "-4138", BadRequest.class );
                    put( "-4139", BadRequest.class );
                    put( "-4142", OrderImmediatelyFillable.class );
                    put( "-20121", BadSymbol.class );
                    put( "-20124", BadRequest.class );
                    put( "-20130", BadRequest.class );
                    put( "-20132", BadRequest.class );
                    put( "-20194", BadRequest.class );
                    put( "-20195", BadRequest.class );
                    put( "-20196", BadRequest.class );
                    put( "-20198", OperationRejected.class );
                    put( "-20204", BadRequest.class );
                    put( "System is under maintenance.", OnMaintenance.class );
                    put( "System abnormality", OperationFailed.class );
                    put( "You are not authorized to execute this request.", PermissionDenied.class );
                    put( "API key does not exist", AuthenticationError.class );
                    put( "Order would trigger immediately.", OrderImmediatelyFillable.class );
                    put( "Stop price would trigger immediately.", OrderImmediatelyFillable.class );
                    put( "Order would immediately match and take.", OrderImmediatelyFillable.class );
                    put( "Account has insufficient balance for requested action.", InsufficientFunds.class );
                    put( "Rest API trading is not enabled.", PermissionDenied.class );
                    put( "This account may not place or cancel orders.", PermissionDenied.class );
                    put( "You don't have permission.", PermissionDenied.class );
                    put( "Market is closed.", MarketClosed.class );
                    put( "Too many requests. Please try again later.", RateLimitExceeded.class );
                    put( "This action is disabled on this account.", AccountSuspended.class );
                    put( "Limit orders require GTC for this phase.", BadRequest.class );
                    put( "This order type is not possible in this trading phase.", BadRequest.class );
                    put( "This type of sub-account exceeds the maximum number limit", OperationRejected.class );
                    put( "This symbol is restricted for this account.", PermissionDenied.class );
                    put( "This symbol is not permitted for this account.", PermissionDenied.class );
                }} );
                put( "broad", new java.util.HashMap<String, Object>() {{
                    put( "has no operation privilege", PermissionDenied.class );
                    put( "MAX_POSITION", BadRequest.class );
                }} );
            }} );
        }});
    }

    public Object isInverse(Object type, Object... optionalArgs)
    {
        Object subType = Helpers.getArg(optionalArgs, 0, null);
        if (Helpers.isTrue(Helpers.isEqual(subType, null)))
        {
            return (Helpers.isEqual(type, "delivery"));
        } else
        {
            return Helpers.isEqual(subType, "inverse");
        }
    }

    public Object isLinear(Object type, Object... optionalArgs)
    {
        Object subType = Helpers.getArg(optionalArgs, 0, null);
        if (Helpers.isTrue(Helpers.isEqual(subType, null)))
        {
            return Helpers.isTrue((Helpers.isEqual(type, "future"))) || Helpers.isTrue((Helpers.isEqual(type, "swap")));
        } else
        {
            return Helpers.isEqual(subType, "linear");
        }
    }

    public void setSandboxMode(Object enable)
    {
        super.setSandboxMode(enable);
        Helpers.addElementToObject(this.options, "sandboxMode", enable);
    }

    public Object createExpiredOptionMarket(Object symbol)
    {
        // support expired option contracts
        Object settle = "USDT";
        Object optionParts = new java.util.ArrayList<Object>(java.util.Arrays.asList(((String)symbol).split((String)"-")));
        Object symbolBase = new java.util.ArrayList<Object>(java.util.Arrays.asList(((String)symbol).split((String)"/")));
        Object base = null;
        if (Helpers.isTrue(Helpers.isGreaterThan(Helpers.getIndexOf(symbol, "/"), Helpers.opNeg(1))))
        {
            base = this.safeString(symbolBase, 0);
        } else
        {
            base = this.safeString(optionParts, 0);
        }
        Object expiry = this.safeString(optionParts, 1);
        Object strike = this.safeInteger(optionParts, 2);
        Object strikeAsString = this.safeString(optionParts, 2);
        Object optionType = this.safeString(optionParts, 3);
        Object datetime = this.convertExpireDate(expiry);
        Object timestamp = this.parse8601(datetime);
        final Object finalBase = base;
        return new java.util.HashMap<String, Object>() {{
            put( "id", Helpers.add(Helpers.add(Helpers.add(Helpers.add(Helpers.add(Helpers.add(finalBase, "-"), expiry), "-"), strikeAsString), "-"), optionType) );
            put( "symbol", Helpers.add(Helpers.add(Helpers.add(Helpers.add(Helpers.add(Helpers.add(Helpers.add(Helpers.add(Helpers.add(Helpers.add(finalBase, "/"), settle), ":"), settle), "-"), expiry), "-"), strikeAsString), "-"), optionType) );
            put( "base", finalBase );
            put( "quote", settle );
            put( "baseId", finalBase );
            put( "quoteId", settle );
            put( "active", null );
            put( "type", "option" );
            put( "linear", null );
            put( "inverse", null );
            put( "spot", false );
            put( "swap", false );
            put( "future", false );
            put( "option", true );
            put( "margin", false );
            put( "contract", true );
            put( "contractSize", null );
            put( "expiry", timestamp );
            put( "expiryDatetime", datetime );
            put( "optionType", ((Helpers.isTrue((Helpers.isEqual(optionType, "C"))))) ? "call" : "put" );
            put( "strike", strike );
            put( "settle", settle );
            put( "settleId", settle );
            put( "precision", new java.util.HashMap<String, Object>() {{
                put( "amount", null );
                put( "price", null );
            }} );
            put( "limits", new java.util.HashMap<String, Object>() {{
                put( "amount", new java.util.HashMap<String, Object>() {{
                    put( "min", null );
                    put( "max", null );
                }} );
                put( "price", new java.util.HashMap<String, Object>() {{
                    put( "min", null );
                    put( "max", null );
                }} );
                put( "cost", new java.util.HashMap<String, Object>() {{
                    put( "min", null );
                    put( "max", null );
                }} );
            }} );
            put( "info", null );
        }};
    }

    public Object market(Object symbol)
    {
        if (Helpers.isTrue(Helpers.isEqual(this.markets, null)))
        {
            throw new ExchangeError((String)Helpers.add(this.id, " markets not loaded")) ;
        }
        // defaultType has legacy support on binance
        Object defaultType = this.safeString(this.options, "defaultType");
        Object defaultSubType = this.safeString(this.options, "defaultSubType");
        Object isLegacyLinear = Helpers.isEqual(defaultType, "future");
        Object isLegacyInverse = Helpers.isEqual(defaultType, "delivery");
        Object isLegacy = Helpers.isTrue(isLegacyLinear) || Helpers.isTrue(isLegacyInverse);
        if (Helpers.isTrue((symbol instanceof String)))
        {
            if (Helpers.isTrue(Helpers.inOp(this.markets, symbol)))
            {
                Object market = Helpers.GetValue(this.markets, symbol);
                // begin diff
                if (Helpers.isTrue(Helpers.isTrue(isLegacy) && Helpers.isTrue(Helpers.GetValue(market, "spot"))))
                {
                    Object settle = ((Helpers.isTrue(isLegacyLinear))) ? Helpers.GetValue(market, "quote") : Helpers.GetValue(market, "base");
                    Object futuresSymbol = Helpers.add(Helpers.add(symbol, ":"), settle);
                    if (Helpers.isTrue(Helpers.inOp(this.markets, futuresSymbol)))
                    {
                        return Helpers.GetValue(this.markets, futuresSymbol);
                    }
                } else
                {
                    return market;
                }
            } else if (Helpers.isTrue(Helpers.inOp(this.markets_by_id, symbol)))
            {
                Object markets = Helpers.GetValue(this.markets_by_id, symbol);
                // begin diff
                if (Helpers.isTrue(isLegacyLinear))
                {
                    defaultType = "linear";
                } else if (Helpers.isTrue(isLegacyInverse))
                {
                    defaultType = "inverse";
                } else if (Helpers.isTrue(Helpers.isEqual(defaultType, null)))
                {
                    defaultType = defaultSubType;
                }
                // end diff
                for (var i = 0; Helpers.isLessThan(i, Helpers.getArrayLength(markets)); i++)
                {
                    Object market = Helpers.GetValue(markets, i);
                    if (Helpers.isTrue(Helpers.GetValue(market, defaultType)))
                    {
                        return market;
                    }
                }
                return Helpers.GetValue(markets, 0);
            } else if (Helpers.isTrue(Helpers.isTrue((Helpers.isGreaterThan(Helpers.getIndexOf(symbol, "/"), Helpers.opNeg(1)))) && Helpers.isTrue((Helpers.isLessThan(Helpers.getIndexOf(symbol, ":"), 0)))))
            {
                if (Helpers.isTrue(Helpers.isTrue((!Helpers.isEqual(defaultType, null))) && Helpers.isTrue((!Helpers.isEqual(defaultType, "spot")))))
                {
                    // support legacy symbols
                    var basequoteVariable = new java.util.ArrayList<Object>(java.util.Arrays.asList(((String)symbol).split((String)"/")));
                    var base = ((java.util.List<Object>) basequoteVariable).get(0);
                    var quote = ((java.util.List<Object>) basequoteVariable).get(1);
                    Object settle = ((Helpers.isTrue((Helpers.isEqual(quote, "USD"))))) ? base : quote;
                    Object futuresSymbol = Helpers.add(Helpers.add(symbol, ":"), settle);
                    if (Helpers.isTrue(Helpers.inOp(this.markets, futuresSymbol)))
                    {
                        return Helpers.GetValue(this.markets, futuresSymbol);
                    }
                }
            } else if (Helpers.isTrue(Helpers.isTrue((Helpers.isGreaterThan(Helpers.getIndexOf(symbol, "-C"), Helpers.opNeg(1)))) || Helpers.isTrue((Helpers.isGreaterThan(Helpers.getIndexOf(symbol, "-P"), Helpers.opNeg(1))))))
            {
                return this.createExpiredOptionMarket(symbol);
            }
        }
        throw new BadSymbol((String)Helpers.add(Helpers.add(this.id, " does not have market symbol "), symbol)) ;
    }

    public Object safeMarket(Object... optionalArgs)
    {
        Object marketId = Helpers.getArg(optionalArgs, 0, null);
        Object market = Helpers.getArg(optionalArgs, 1, null);
        Object delimiter = Helpers.getArg(optionalArgs, 2, null);
        Object marketType = Helpers.getArg(optionalArgs, 3, null);
        Object isOption = Helpers.isTrue((!Helpers.isEqual(marketId, null))) && Helpers.isTrue((Helpers.isTrue((Helpers.isGreaterThan(Helpers.getIndexOf(marketId, "-C"), Helpers.opNeg(1)))) || Helpers.isTrue((Helpers.isGreaterThan(Helpers.getIndexOf(marketId, "-P"), Helpers.opNeg(1))))));
        if (Helpers.isTrue(Helpers.isTrue(isOption) && !Helpers.isTrue((Helpers.inOp(this.markets_by_id, marketId)))))
        {
            // handle expired option contracts
            return this.createExpiredOptionMarket(marketId);
        }
        return super.safeMarket(marketId, market, delimiter, marketType);
    }

    public Object costToPrecision(Object symbol, Object cost)
    {
        return this.decimalToPrecision(cost, TRUNCATE, Helpers.GetValue(Helpers.GetValue(Helpers.GetValue(this.markets, symbol), "precision"), "quote"), this.precisionMode, this.paddingMode);
    }

    public Object nonce()
    {
        return Helpers.subtract(this.milliseconds(), Helpers.GetValue(this.options, "timeDifference"));
    }

    /**
     * @method
     * @name binance#enableDemoTrading
     * @description enables or disables demo trading mode
     * @see https://www.binance.com/en/support/faq/detail/9be58f73e5e14338809e3b705b9687dd
     * @see https://demo.binance.com/en/my/settings/api-management
     * @param {boolean} [enable] true if demo trading should be enabled, false otherwise
     */
    public void enableDemoTrading(Object enable)
    {
        if (Helpers.isTrue(this.isSandboxModeEnabled))
        {
            throw new NotSupported((String)Helpers.add(this.id, " demo trading is not supported in the sandbox environment. Please check https://www.binance.com/en/support/faq/detail/9be58f73e5e14338809e3b705b9687dd to see the differences")) ;
        }
        if (Helpers.isTrue(enable))
        {
            Helpers.addElementToObject(this.urls, "apiBackupDemoTrading", Helpers.GetValue(this.urls, "api"));
            Helpers.addElementToObject(this.urls, "api", Helpers.GetValue(this.urls, "demo"));
        } else if (Helpers.isTrue(Helpers.inOp(this.urls, "apiBackupDemoTrading")))
        {
            Helpers.addElementToObject(this.urls, "api", ((Object)Helpers.GetValue(this.urls, "apiBackupDemoTrading")));
            Object newUrls = this.omit(this.urls, "apiBackupDemoTrading");
            this.urls = newUrls;
        }
        Helpers.addElementToObject(this.options, "enableDemoTrading", enable);
    }

    /**
     * @method
     * @name binance#fetchTime
     * @description fetches the current integer timestamp in milliseconds from the exchange server
     * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/general-endpoints#check-server-time          // spot
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Check-Server-Time    // swap
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/Check-Server-time    // future
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.subType] "linear" or "inverse"
     * @returns {int} the current integer timestamp in milliseconds from the exchange server
     */
    public java.util.concurrent.CompletableFuture<Object> fetchTime(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object parameters = Helpers.getArg(optionalArgs, 0, new java.util.HashMap<String, Object>() {{}});
            Object defaultType = this.safeString2(this.options, "fetchTime", "defaultType", "spot");
            Object type = this.safeString(parameters, "type", defaultType);
            Object query = this.omit(parameters, "type");
            Object subType = null;
            var subTypeparametersVariable = this.handleSubTypeAndParams("fetchTime", null, parameters);
            subType = ((java.util.List<Object>) subTypeparametersVariable).get(0);
            parameters = ((java.util.List<Object>) subTypeparametersVariable).get(1);
            Object response = null;
            if (Helpers.isTrue(this.isLinear(type, subType)))
            {
                response = (this.fapiPublicGetTime(query)).join();
            } else if (Helpers.isTrue(this.isInverse(type, subType)))
            {
                response = (this.dapiPublicGetTime(query)).join();
            } else
            {
                response = (this.publicGetTime(query)).join();
            }
            return this.safeInteger(response, "serverTime");
        });

    }

    /**
     * @method
     * @name binance#fetchCurrencies
     * @description fetches all available currencies on an exchange
     * @see https://developers.binance.com/docs/wallet/capital/all-coins-info
     * @see https://developers.binance.com/docs/margin_trading/market-data/Get-All-Margin-Assets
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an associative dictionary of currencies
     */
    public java.util.concurrent.CompletableFuture<Object> fetchCurrencies(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object parameters = Helpers.getArg(optionalArgs, 0, new java.util.HashMap<String, Object>() {{}});
            Object fetchCurrenciesEnabled = this.safeBool(this.options, "fetchCurrencies");
            if (!Helpers.isTrue(fetchCurrenciesEnabled))
            {
                return new java.util.HashMap<String, Object>() {{}};
            }
            // this endpoint requires authentication
            // while fetchCurrencies is a public API method by design
            // therefore we check the keys here
            // and fallback to generating the currencies from the markets
            if (!Helpers.isTrue(this.checkRequiredCredentials(false)))
            {
                return new java.util.HashMap<String, Object>() {{}};
            }
            // sandbox/testnet does not support sapi endpoints
            Object apiBackup = this.safeValue(this.urls, "apiBackup");
            if (Helpers.isTrue(!Helpers.isEqual(apiBackup, null)))
            {
                return new java.util.HashMap<String, Object>() {{}};
            }
            // demotrading does not support sapi endpoints
            if (Helpers.isTrue(this.safeBool(this.options, "enableDemoTrading", false)))
            {
                return new java.util.HashMap<String, Object>() {{}};
            }
            Object promises = new java.util.ArrayList<Object>(java.util.Arrays.asList(this.sapiGetCapitalConfigGetall(parameters)));
            Object fetchMargins = this.safeBool(this.options, "fetchMargins", false);
            if (Helpers.isTrue(fetchMargins))
            {
                ((java.util.List<Object>)promises).add(this.sapiGetMarginAllPairs(parameters));
            }
            Object results = (Helpers.promiseAll(promises)).join();
            Object responseCurrencies = Helpers.GetValue(results, 0);
            Object marginablesById = null;
            if (Helpers.isTrue(fetchMargins))
            {
                Object responseMarginables = Helpers.GetValue(results, 1);
                marginablesById = this.indexBy(responseMarginables, "assetName");
            }
            Object result = new java.util.HashMap<String, Object>() {{}};
            for (var i = 0; Helpers.isLessThan(i, Helpers.getArrayLength(responseCurrencies)); i++)
            {
                //
                //    {
                //        "coin": "LINK",
                //        "depositAllEnable": true,
                //        "withdrawAllEnable": true,
                //        "name": "ChainLink",
                //        "free": "0",
                //        "locked": "0",
                //        "freeze": "0",
                //        "withdrawing": "0",
                //        "ipoing": "0",
                //        "ipoable": "0",
                //        "storage": "0",
                //        "isLegalMoney": false,
                //        "trading": true,
                //        "networkList": [
                //            {
                //                "network": "BSC",
                //                "coin": "LINK",
                //                "withdrawIntegerMultiple": "0.00000001",
                //                "isDefault": false,
                //                "depositEnable": true,
                //                "withdrawEnable": true,
                //                "depositDesc": "",
                //                "withdrawDesc": "",
                //                "specialTips": "",
                //                "specialWithdrawTips": "The network you have selected is BSC. Please ensure that the withdrawal address supports the Binance Smart Chain network. You will lose your assets if the chosen platform does not support retrievals.",
                //                "name": "BNB Smart Chain (BEP20)",
                //                "resetAddressStatus": false,
                //                "addressRegex": "^(0x)[0-9A-Fa-f]{40}$",
                //                "addressRule": "",
                //                "memoRegex": "",
                //                "withdrawFee": "0.012",
                //                "withdrawMin": "0.024",
                //                "withdrawMax": "9999999999.99999999",
                //                "minConfirm": "15",
                //                "unLockConfirm": "0",
                //                "sameAddress": false,
                //                "estimatedArrivalTime": "5",
                //                "busy": false,
                //                "country": "AE,BINANCE_BAHRAIN_BSC"
                //            },
                //            {
                //                "network": "BNB",
                //                "coin": "LINK",
                //                "withdrawIntegerMultiple": "0.00000001",
                //                "isDefault": false,
                //                "depositEnable": true,
                //                "withdrawEnable": true,
                //                "depositDesc": "",
                //                "withdrawDesc": "",
                //                "specialTips": "Both a MEMO and an Address are required to successfully deposit your LINK BEP2 tokens to Binance.",
                //                "specialWithdrawTips": "",
                //                "name": "BNB Beacon Chain (BEP2)",
                //                "resetAddressStatus": false,
                //                "addressRegex": "^(bnb1)[0-9a-z]{38}$",
                //                "addressRule": "",
                //                "memoRegex": "^[0-9A-Za-z\\-_]{1,120}$",
                //                "withdrawFee": "0.003",
                //                "withdrawMin": "0.01",
                //                "withdrawMax": "10000000000",
                //                "minConfirm": "1",
                //                "unLockConfirm": "0",
                //                "sameAddress": true,
                //                "estimatedArrivalTime": "5",
                //                "busy": false,
                //                "country": "AE,BINANCE_BAHRAIN_BSC"
                //            },
                //            {
                //                "network": "ETH",
                //                "coin": "LINK",
                //                "withdrawIntegerMultiple": "0.00000001",
                //                "isDefault": true,
                //                "depositEnable": true,
                //                "withdrawEnable": true,
                //                "depositDesc": "",
                //                "withdrawDesc": "",
                //                "name": "Ethereum (ERC20)",
                //                "resetAddressStatus": false,
                //                "addressRegex": "^(0x)[0-9A-Fa-f]{40}$",
                //                "addressRule": "",
                //                "memoRegex": "",
                //                "withdrawFee": "0.55",
                //                "withdrawMin": "1.1",
                //                "withdrawMax": "10000000000",
                //                "minConfirm": "12",
                //                "unLockConfirm": "0",
                //                "sameAddress": false,
                //                "estimatedArrivalTime": "5",
                //                "busy": false,
                //                "country": "AE,BINANCE_BAHRAIN_BSC"
                //            }
                //        ]
                //    }
                //
                Object entry = Helpers.GetValue(responseCurrencies, i);
                Object id = this.safeString(entry, "coin");
                Object name = this.safeString(entry, "name");
                Object code = this.safeCurrencyCode(id);
                Object isFiat = this.safeBool(entry, "isLegalMoney");
                Object minPrecision = null;
                Object isWithdrawEnabled = true;
                Object isDepositEnabled = true;
                Object networkList = this.safeList(entry, "networkList", new java.util.ArrayList<Object>(java.util.Arrays.asList()));
                Object fees = new java.util.HashMap<String, Object>() {{}};
                Object fee = null;
                Object networks = new java.util.HashMap<String, Object>() {{}};
                for (var j = 0; Helpers.isLessThan(j, Helpers.getArrayLength(networkList)); j++)
                {
                    Object networkItem = Helpers.GetValue(networkList, j);
                    Object network = this.safeString(networkItem, "network");
                    Object networkCode = this.networkIdToCode(network);
                    Object isETF = (Helpers.isEqual(network, "ETF")); // e.g. BTCUP, ETHDOWN
                    // const name = this.safeString (networkItem, 'name');
                    Object withdrawFee = this.safeNumber(networkItem, "withdrawFee");
                    Object depositEnable = this.safeBool(networkItem, "depositEnable");
                    Object withdrawEnable = this.safeBool(networkItem, "withdrawEnable");
                    isDepositEnabled = Helpers.isTrue(isDepositEnabled) || Helpers.isTrue(depositEnable);
                    isWithdrawEnabled = Helpers.isTrue(isWithdrawEnabled) || Helpers.isTrue(withdrawEnable);
                    Helpers.addElementToObject(fees, network, withdrawFee);
                    Object isDefault = this.safeBool(networkItem, "isDefault");
                    if (Helpers.isTrue(Helpers.isTrue(isDefault) || Helpers.isTrue((Helpers.isEqual(fee, null)))))
                    {
                        fee = withdrawFee;
                    }
                    // todo: default networks in "setMarkets" overload
                    // if (isDefault) {
                    //     this.options['defaultNetworkCodesForCurrencies'][code] = networkCode;
                    // }
                    Object precisionTick = this.safeString(networkItem, "withdrawIntegerMultiple");
                    Object withdrawPrecision = precisionTick;
                    // avoid zero values, which are mostly from fiat or leveraged tokens or some abandoned coins : https://github.com/ccxt/ccxt/pull/14902#issuecomment-1271636731
                    if (!Helpers.isTrue(Precise.stringEq(precisionTick, "0")))
                    {
                        minPrecision = ((Helpers.isTrue((Helpers.isEqual(minPrecision, null))))) ? precisionTick : Precise.stringMin(minPrecision, precisionTick);
                    } else
                    {
                        if (Helpers.isTrue(!Helpers.isTrue(isFiat) && !Helpers.isTrue(isETF)))
                        {
                            // non-fiat and non-ETF currency, there are many cases when precision is set to zero (probably bug, we've reported to binance already)
                            // in such cases, we can set default precision of 8 (which is in UI for such coins)
                            withdrawPrecision = this.omitZero(this.safeString(networkItem, "withdrawInternalMin"));
                            if (Helpers.isTrue(Helpers.isEqual(withdrawPrecision, null)))
                            {
                                withdrawPrecision = this.safeString(this.options, "defaultWithdrawPrecision");
                            }
                        }
                    }
                    final Object finalNetwork = network;
                    final Object finalWithdrawPrecision = withdrawPrecision;
                    Helpers.addElementToObject(networks, networkCode, new java.util.HashMap<String, Object>() {{
        put( "info", networkItem );
        put( "id", finalNetwork );
        put( "network", networkCode );
        put( "active", Helpers.isTrue(depositEnable) && Helpers.isTrue(withdrawEnable) );
        put( "deposit", depositEnable );
        put( "withdraw", withdrawEnable );
        put( "fee", withdrawFee );
        put( "precision", Binance.this.parseNumber(finalWithdrawPrecision) );
        put( "limits", new java.util.HashMap<String, Object>() {{
            put( "withdraw", new java.util.HashMap<String, Object>() {{
                put( "min", Binance.this.safeNumber(networkItem, "withdrawMin") );
                put( "max", Binance.this.safeNumber(networkItem, "withdrawMax") );
            }} );
            put( "deposit", new java.util.HashMap<String, Object>() {{
                put( "min", Binance.this.safeNumber(networkItem, "depositDust") );
                put( "max", null );
            }} );
        }} );
    }});
                }
                Object trading = this.safeBool(entry, "trading");
                Object active = (Helpers.isTrue(Helpers.isTrue(isWithdrawEnabled) && Helpers.isTrue(isDepositEnabled)) && Helpers.isTrue(trading));
                Object marginEntry = this.safeDict(marginablesById, id, new java.util.HashMap<String, Object>() {{}});
                //
                //     {
                //         assetName: "BTC",
                //         assetFullName: "Bitcoin",
                //         isBorrowable: true,
                //         isMortgageable: true,
                //         userMinBorrow: "0",
                //         userMinRepay: "0",
                //     }
                //
                final Object finalMinPrecision = minPrecision;
                final Object finalIsDepositEnabled = isDepositEnabled;
                final Object finalIsWithdrawEnabled = isWithdrawEnabled;
                final Object finalFee = fee;
                Helpers.addElementToObject(result, code, new java.util.HashMap<String, Object>() {{
        put( "id", id );
        put( "name", name );
        put( "code", code );
        put( "type", ((Helpers.isTrue(isFiat))) ? "fiat" : "crypto" );
        put( "precision", Binance.this.parseNumber(finalMinPrecision) );
        put( "info", entry );
        put( "active", active );
        put( "deposit", finalIsDepositEnabled );
        put( "withdraw", finalIsWithdrawEnabled );
        put( "networks", networks );
        put( "fee", finalFee );
        put( "fees", fees );
        put( "limits", Binance.this.limits );
        put( "margin", Binance.this.safeBool(marginEntry, "isBorrowable") );
    }});
            }
            return result;
        });

    }

    /**
     * @method
     * @name binance#fetchMarkets
     * @description retrieves data on all markets for binance
     * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/general-endpoints#exchange-information           // spot
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Exchange-Information     // swap
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/Exchange-Information     // future
     * @see https://developers.binance.com/docs/derivatives/option/market-data/Exchange-Information                             // option
     * @see https://developers.binance.com/docs/margin_trading/market-data/Get-All-Cross-Margin-Pairs                           // cross margin
     * @see https://developers.binance.com/docs/margin_trading/market-data/Get-All-Isolated-Margin-Symbol                       // isolated margin
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public java.util.concurrent.CompletableFuture<Object> fetchMarkets(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object parameters = Helpers.getArg(optionalArgs, 0, new java.util.HashMap<String, Object>() {{}});
            Object promisesRaw = new java.util.ArrayList<Object>(java.util.Arrays.asList());
            Object rawFetchMarkets = null;
            Object defaultTypes = new java.util.ArrayList<Object>(java.util.Arrays.asList("spot", "linear", "inverse"));
            Object fetchMarketsOptions = this.safeDict(this.options, "fetchMarkets");
            if (Helpers.isTrue(!Helpers.isEqual(fetchMarketsOptions, null)))
            {
                rawFetchMarkets = this.safeList(fetchMarketsOptions, "types", defaultTypes);
            } else
            {
                // for backward-compatibility
                rawFetchMarkets = this.safeList(this.options, "fetchMarkets", defaultTypes);
            }
            // handle loadAllOptions option
            Object loadAllOptions = this.safeBool(this.options, "loadAllOptions", false);
            if (Helpers.isTrue(loadAllOptions))
            {
                if (!Helpers.isTrue(this.inArray("option", rawFetchMarkets)))
                {
                    ((java.util.List<Object>)rawFetchMarkets).add("option");
                }
            }
            Object sandboxMode = this.safeBool(this.options, "sandboxMode", false);
            Object demoMode = this.safeBool(this.options, "enableDemoTrading", false);
            Object isDemoEnv = Helpers.isTrue(demoMode) || Helpers.isTrue(sandboxMode);
            Object fetchMarkets = new java.util.ArrayList<Object>(java.util.Arrays.asList());
            for (var i = 0; Helpers.isLessThan(i, Helpers.getArrayLength(rawFetchMarkets)); i++)
            {
                Object type = Helpers.GetValue(rawFetchMarkets, i);
                if (Helpers.isTrue(Helpers.isTrue(Helpers.isEqual(type, "option")) && Helpers.isTrue(isDemoEnv)))
                {
                    continue;
                }
                ((java.util.List<Object>)fetchMarkets).add(type);
            }
            Object fetchMargins = this.safeBool(this.options, "fetchMargins", false);
            for (var i = 0; Helpers.isLessThan(i, Helpers.getArrayLength(fetchMarkets)); i++)
            {
                Object marketType = Helpers.GetValue(fetchMarkets, i);
                if (Helpers.isTrue(Helpers.isEqual(marketType, "spot")))
                {
                    ((java.util.List<Object>)promisesRaw).add(this.publicGetExchangeInfo(parameters));
                    if (Helpers.isTrue(Helpers.isTrue(Helpers.isTrue(fetchMargins) && Helpers.isTrue(this.checkRequiredCredentials(false))) && !Helpers.isTrue(isDemoEnv)))
                    {
                        ((java.util.List<Object>)promisesRaw).add(this.sapiGetMarginAllPairs(parameters));
                        ((java.util.List<Object>)promisesRaw).add(this.sapiGetMarginIsolatedAllPairs(parameters));
                    }
                } else if (Helpers.isTrue(Helpers.isEqual(marketType, "linear")))
                {
                    ((java.util.List<Object>)promisesRaw).add(this.fapiPublicGetExchangeInfo(parameters));
                } else if (Helpers.isTrue(Helpers.isEqual(marketType, "inverse")))
                {
                    ((java.util.List<Object>)promisesRaw).add(this.dapiPublicGetExchangeInfo(parameters));
                } else if (Helpers.isTrue(Helpers.isEqual(marketType, "option")))
                {
                    ((java.util.List<Object>)promisesRaw).add(this.eapiPublicGetExchangeInfo(parameters));
                } else
                {
                    throw new ExchangeError((String)Helpers.add(Helpers.add(Helpers.add(this.id, " fetchMarkets() this.options fetchMarkets \""), marketType), "\" is not a supported market type")) ;
                }
            }
            Object results = (Helpers.promiseAll(promisesRaw)).join();
            Object markets = new java.util.ArrayList<Object>(java.util.Arrays.asList());
            Helpers.addElementToObject(this.options, "crossMarginPairsData", new java.util.ArrayList<Object>(java.util.Arrays.asList()));
            Helpers.addElementToObject(this.options, "isolatedMarginPairsData", new java.util.ArrayList<Object>(java.util.Arrays.asList()));
            for (var i = 0; Helpers.isLessThan(i, Helpers.getArrayLength(results)); i++)
            {
                Object res = this.safeValue(results, i);
                if (Helpers.isTrue(Helpers.isTrue(fetchMargins) && Helpers.isTrue(((res instanceof java.util.List) || (res.getClass().isArray())))))
                {
                    Object keysList = new java.util.ArrayList<Object>(((java.util.Map<String, Object>)this.indexBy(res, "symbol")).keySet());
                    Object length = Helpers.getArrayLength(Helpers.GetValue(this.options, "crossMarginPairsData"));
                    // first one is the cross-margin promise
                    if (Helpers.isTrue(Helpers.isEqual(length, 0)))
                    {
                        Helpers.addElementToObject(this.options, "crossMarginPairsData", keysList);
                    } else
                    {
                        Helpers.addElementToObject(this.options, "isolatedMarginPairsData", keysList);
                    }
                } else
                {
                    Object resultMarkets = this.safeList2(res, "symbols", "optionSymbols", new java.util.ArrayList<Object>(java.util.Arrays.asList()));
                    markets = this.arrayConcat(markets, resultMarkets);
                }
            }
            //
            // spot / margin
            //
            //     {
            //         "timezone":"UTC",
            //         "serverTime":1575416692969,
            //         "rateLimits":[
            //             {"rateLimitType":"REQUEST_WEIGHT","interval":"MINUTE","intervalNum":1,"limit":1200},
            //             {"rateLimitType":"ORDERS","interval":"SECOND","intervalNum":10,"limit":100},
            //             {"rateLimitType":"ORDERS","interval":"DAY","intervalNum":1,"limit":200000}
            //         ],
            //         "exchangeFilters":[],
            //         "symbols":[
            //             {
            //                 "symbol":"ETHBTC",
            //                 "status":"TRADING",
            //                 "baseAsset":"ETH",
            //                 "baseAssetPrecision":8,
            //                 "quoteAsset":"BTC",
            //                 "quotePrecision":8,
            //                 "baseCommissionPrecision":8,
            //                 "quoteCommissionPrecision":8,
            //                 "orderTypes":["LIMIT","LIMIT_MAKER","MARKET","STOP_LOSS_LIMIT","TAKE_PROFIT_LIMIT"],
            //                 "icebergAllowed":true,
            //                 "ocoAllowed":true,
            //                 "quoteOrderQtyMarketAllowed":true,
            //                 "allowTrailingStop":false,
            //                 "isSpotTradingAllowed":true,
            //                 "isMarginTradingAllowed":true,
            //                 "filters":[
            //                     {"filterType":"PRICE_FILTER","minPrice":"0.00000100","maxPrice":"100000.00000000","tickSize":"0.00000100"},
            //                     {"filterType":"PERCENT_PRICE","multiplierUp":"5","multiplierDown":"0.2","avgPriceMins":5},
            //                     {"filterType":"LOT_SIZE","minQty":"0.00100000","maxQty":"100000.00000000","stepSize":"0.00100000"},
            //                     {"filterType":"MIN_NOTIONAL","minNotional":"0.00010000","applyToMarket":true,"avgPriceMins":5},
            //                     {"filterType":"ICEBERG_PARTS","limit":10},
            //                     {"filterType":"MARKET_LOT_SIZE","minQty":"0.00000000","maxQty":"63100.00000000","stepSize":"0.00000000"},
            //                     {"filterType":"MAX_NUM_ORDERS","maxNumOrders":200},
            //                     {"filterType":"MAX_NUM_ALGO_ORDERS","maxNumAlgoOrders":5}
            //                 ],
            //                 "permissions":["SPOT","MARGIN"]}
            //             },
            //         ],
            //     }
            //
            // cross & isolated pairs response:
            //
            //     [
            //         {
            //           symbol: "BTCUSDT",
            //           base: "BTC",
            //           quote: "USDT",
            //           isMarginTrade: true,
            //           isBuyAllowed: true,
            //           isSellAllowed: true,
            //           id: "376870555451677893", // doesn't exist in isolated
            //         },
            //     ]
            //
            // futures/usdt-margined (fapi)
            //
            //     {
            //         "timezone":"UTC",
            //         "serverTime":1575417244353,
            //         "rateLimits":[
            //             {"rateLimitType":"REQUEST_WEIGHT","interval":"MINUTE","intervalNum":1,"limit":1200},
            //             {"rateLimitType":"ORDERS","interval":"MINUTE","intervalNum":1,"limit":1200}
            //         ],
            //         "exchangeFilters":[],
            //         "symbols":[
            //             {
            //                 "symbol":"BTCUSDT",
            //                 "status":"TRADING",
            //                 "maintMarginPercent":"2.5000",
            //                 "requiredMarginPercent":"5.0000",
            //                 "baseAsset":"BTC",
            //                 "quoteAsset":"USDT",
            //                 "pricePrecision":2,
            //                 "quantityPrecision":3,
            //                 "baseAssetPrecision":8,
            //                 "quotePrecision":8,
            //                 "filters":[
            //                     {"minPrice":"0.01","maxPrice":"100000","filterType":"PRICE_FILTER","tickSize":"0.01"},
            //                     {"stepSize":"0.001","filterType":"LOT_SIZE","maxQty":"1000","minQty":"0.001"},
            //                     {"stepSize":"0.001","filterType":"MARKET_LOT_SIZE","maxQty":"1000","minQty":"0.001"},
            //                     {"limit":200,"filterType":"MAX_NUM_ORDERS"},
            //                     {"multiplierDown":"0.8500","multiplierUp":"1.1500","multiplierDecimal":"4","filterType":"PERCENT_PRICE"}
            //                 ],
            //                 "orderTypes":["LIMIT","MARKET","STOP"],
            //                 "timeInForce":["GTC","IOC","FOK","GTX"]
            //             }
            //         ]
            //     }
            //
            // delivery/coin-margined (dapi)
            //
            //     {
            //         "timezone": "UTC",
            //         "serverTime": 1597667052958,
            //         "rateLimits": [
            //             {"rateLimitType":"REQUEST_WEIGHT","interval":"MINUTE","intervalNum":1,"limit":6000},
            //             {"rateLimitType":"ORDERS","interval":"MINUTE","intervalNum":1,"limit":6000}
            //         ],
            //         "exchangeFilters": [],
            //         "symbols": [
            //             {
            //                 "symbol": "BTCUSD_200925",
            //                 "pair": "BTCUSD",
            //                 "contractType": "CURRENT_QUARTER",
            //                 "deliveryDate": 1601020800000,
            //                 "onboardDate": 1590739200000,
            //                 "contractStatus": "TRADING",
            //                 "contractSize": 100,
            //                 "marginAsset": "BTC",
            //                 "maintMarginPercent": "2.5000",
            //                 "requiredMarginPercent": "5.0000",
            //                 "baseAsset": "BTC",
            //                 "quoteAsset": "USD",
            //                 "pricePrecision": 1,
            //                 "quantityPrecision": 0,
            //                 "baseAssetPrecision": 8,
            //                 "quotePrecision": 8,
            //                 "equalQtyPrecision": 4,
            //                 "filters": [
            //                     {"minPrice":"0.1","maxPrice":"100000","filterType":"PRICE_FILTER","tickSize":"0.1"},
            //                     {"stepSize":"1","filterType":"LOT_SIZE","maxQty":"100000","minQty":"1"},
            //                     {"stepSize":"0","filterType":"MARKET_LOT_SIZE","maxQty":"100000","minQty":"1"},
            //                     {"limit":200,"filterType":"MAX_NUM_ORDERS"},
            //                     {"multiplierDown":"0.9500","multiplierUp":"1.0500","multiplierDecimal":"4","filterType":"PERCENT_PRICE"}
            //                 ],
            //                 "orderTypes": ["LIMIT","MARKET","STOP","STOP_MARKET","TAKE_PROFIT","TAKE_PROFIT_MARKET","TRAILING_STOP_MARKET"],
            //                 "timeInForce": ["GTC","IOC","FOK","GTX"]
            //             },
            //             {
            //                 "symbol": "BTCUSD_PERP",
            //                 "pair": "BTCUSD",
            //                 "contractType": "PERPETUAL",
            //                 "deliveryDate": 4133404800000,
            //                 "onboardDate": 1596006000000,
            //                 "contractStatus": "TRADING",
            //                 "contractSize": 100,
            //                 "marginAsset": "BTC",
            //                 "maintMarginPercent": "2.5000",
            //                 "requiredMarginPercent": "5.0000",
            //                 "baseAsset": "BTC",
            //                 "quoteAsset": "USD",
            //                 "pricePrecision": 1,
            //                 "quantityPrecision": 0,
            //                 "baseAssetPrecision": 8,
            //                 "quotePrecision": 8,
            //                 "equalQtyPrecision": 4,
            //                 "filters": [
            //                     {"minPrice":"0.1","maxPrice":"100000","filterType":"PRICE_FILTER","tickSize":"0.1"},
            //                     {"stepSize":"1","filterType":"LOT_SIZE","maxQty":"100000","minQty":"1"},
            //                     {"stepSize":"1","filterType":"MARKET_LOT_SIZE","maxQty":"100000","minQty":"1"},
            //                     {"limit":200,"filterType":"MAX_NUM_ORDERS"},
            //                     {"multiplierDown":"0.8500","multiplierUp":"1.1500","multiplierDecimal":"4","filterType":"PERCENT_PRICE"}
            //                 ],
            //                 "orderTypes": ["LIMIT","MARKET","STOP","STOP_MARKET","TAKE_PROFIT","TAKE_PROFIT_MARKET","TRAILING_STOP_MARKET"],
            //                 "timeInForce": ["GTC","IOC","FOK","GTX"]
            //             }
            //         ]
            //     }
            //
            // options (eapi)
            //
            //     {
            //         "timezone": "UTC",
            //         "serverTime": 1675912490405,
            //         "optionContracts": [
            //             {
            //                 "id": 1,
            //                 "baseAsset": "SOL",
            //                 "quoteAsset": "USDT",
            //                 "underlying": "SOLUSDT",
            //                 "settleAsset": "USDT"
            //             },
            //             ...
            //         ],
            //         "optionAssets": [
            //             {"id":1,"name":"USDT"}
            //         ],
            //         "optionSymbols": [
            //             {
            //                 "contractId": 3,
            //                 "expiryDate": 1677225600000,
            //                 "filters": [
            //                     {"filterType":"PRICE_FILTER","minPrice":"724.6","maxPrice":"919.2","tickSize":"0.1"},
            //                     {"filterType":"LOT_SIZE","minQty":"0.01","maxQty":"1001","stepSize":"0.01"}
            //                 ],
            //                 "id": 2474,
            //                 "symbol": "ETH-230224-800-C",
            //                 "side": "CALL",
            //                 "strikePrice": "800.00000000",
            //                 "underlying": "ETHUSDT",
            //                 "unit": 1,
            //                 "makerFeeRate": "0.00020000",
            //                 "takerFeeRate": "0.00020000",
            //                 "minQty": "0.01",
            //                 "maxQty": "1000",
            //                 "initialMargin": "0.15000000",
            //                 "maintenanceMargin": "0.07500000",
            //                 "minInitialMargin": "0.10000000",
            //                 "minMaintenanceMargin": "0.05000000",
            //                 "priceScale": 1,
            //                 "quantityScale": 2,
            //                 "quoteAsset": "USDT"
            //             },
            //             ...
            //         ],
            //         "rateLimits": [
            //             {"rateLimitType":"REQUEST_WEIGHT","interval":"MINUTE","intervalNum":1,"limit":400},
            //             {"rateLimitType":"ORDERS","interval":"MINUTE","intervalNum":1,"limit":100},
            //             {"rateLimitType":"ORDERS","interval":"SECOND","intervalNum":10,"limit":30}
            //         ]
            //     }
            //
            if (Helpers.isTrue(Helpers.GetValue(this.options, "adjustForTimeDifference")))
            {
                (this.loadTimeDifference()).join();
            }
            Object result = new java.util.ArrayList<Object>(java.util.Arrays.asList());
            for (var i = 0; Helpers.isLessThan(i, Helpers.getArrayLength(markets)); i++)
            {
                ((java.util.List<Object>)result).add(this.parseMarket(Helpers.GetValue(markets, i)));
            }
            return result;
        });

    }

    public Object parseMarket(Object market)
    {
        Object swap = false;
        Object future = false;
        Object option = false;
        Object underlying = this.safeString(market, "underlying");
        Object id = this.safeString(market, "symbol");
        Object optionParts = new java.util.ArrayList<Object>(java.util.Arrays.asList(((String)id).split((String)"-")));
        Object optionBase = this.safeString(optionParts, 0);
        Object lowercaseId = this.safeStringLower(market, "symbol");
        Object baseId = this.safeString(market, "baseAsset", optionBase);
        Object quoteId = this.safeString(market, "quoteAsset");
        Object base = this.safeCurrencyCode(baseId);
        Object quote = this.safeCurrencyCode(quoteId);
        Object contractType = this.safeString(market, "contractType");
        Object contract = (Helpers.inOp(market, "contractType"));
        Object expiry = this.safeInteger2(market, "deliveryDate", "expiryDate");
        Object settleId = this.safeString(market, "marginAsset");
        if (Helpers.isTrue(Helpers.isTrue((Helpers.isEqual(contractType, "PERPETUAL"))) || Helpers.isTrue((Helpers.isEqual(expiry, 4133404800000L)))))
        {
            expiry = null;
            swap = true;
        } else if (Helpers.isTrue(!Helpers.isEqual(underlying, null)))
        {
            contract = true;
            option = true;
            settleId = ((Helpers.isTrue((Helpers.isEqual(settleId, null))))) ? "USDT" : settleId;
        } else if (Helpers.isTrue(!Helpers.isEqual(expiry, null)))
        {
            future = true;
        }
        Object settle = this.safeCurrencyCode(settleId);
        Object spot = !Helpers.isTrue(contract);
        Object filters = this.safeList(market, "filters", new java.util.ArrayList<Object>(java.util.Arrays.asList()));
        Object filtersByType = this.indexBy(filters, "filterType");
        Object status = this.safeString2(market, "status", "contractStatus");
        Object contractSize = null;
        Object fees = this.fees;
        Object linear = null;
        Object inverse = null;
        Object symbol = Helpers.add(Helpers.add(base, "/"), quote);
        Object strike = null;
        if (Helpers.isTrue(contract))
        {
            if (Helpers.isTrue(swap))
            {
                symbol = Helpers.add(Helpers.add(symbol, ":"), settle);
            } else if (Helpers.isTrue(future))
            {
                symbol = Helpers.add(Helpers.add(Helpers.add(Helpers.add(symbol, ":"), settle), "-"), this.yymmdd(expiry));
            } else if (Helpers.isTrue(option))
            {
                strike = this.numberToString(this.parseToNumeric(this.safeString(market, "strikePrice")));
                symbol = Helpers.add(Helpers.add(Helpers.add(Helpers.add(Helpers.add(Helpers.add(Helpers.add(Helpers.add(symbol, ":"), settle), "-"), this.yymmdd(expiry)), "-"), strike), "-"), this.safeString(optionParts, 3));
            }
            contractSize = this.safeNumber2(market, "contractSize", "unit", this.parseNumber("1"));
            linear = Helpers.isEqual(settle, quote);
            inverse = Helpers.isEqual(settle, base);
            Object feesType = ((Helpers.isTrue(linear))) ? "linear" : "inverse";
            fees = ((Object)this.safeDict(this.fees, feesType, new java.util.HashMap<String, Object>() {{}}));
        }
        Object active = (Helpers.isEqual(status, "TRADING"));
        if (Helpers.isTrue(spot))
        {
            Object permissions = this.safeList(market, "permissions", new java.util.ArrayList<Object>(java.util.Arrays.asList()));
            for (var j = 0; Helpers.isLessThan(j, Helpers.getArrayLength(permissions)); j++)
            {
                if (Helpers.isTrue(Helpers.isEqual(Helpers.GetValue(permissions, j), "TRD_GRP_003")))
                {
                    active = false;
                    break;
                }
            }
        }
        Object isMarginTradingAllowed = this.safeBool(market, "isMarginTradingAllowed", false);
        Object marginModes = null;
        if (Helpers.isTrue(spot))
        {
            Object hasCrossMargin = this.inArray(id, Helpers.GetValue(this.options, "crossMarginPairsData"));
            Object hasIsolatedMargin = this.inArray(id, Helpers.GetValue(this.options, "isolatedMarginPairsData"));
            marginModes = new java.util.HashMap<String, Object>() {{
                put( "cross", hasCrossMargin );
                put( "isolated", hasIsolatedMargin );
            }};
        } else if (Helpers.isTrue(Helpers.isTrue(linear) || Helpers.isTrue(inverse)))
        {
            marginModes = new java.util.HashMap<String, Object>() {{
                put( "cross", true );
                put( "isolated", true );
            }};
        }
        Object unifiedType = null;
        if (Helpers.isTrue(spot))
        {
            unifiedType = "spot";
        } else if (Helpers.isTrue(swap))
        {
            unifiedType = "swap";
        } else if (Helpers.isTrue(future))
        {
            unifiedType = "future";
        } else if (Helpers.isTrue(option))
        {
            unifiedType = "option";
            active = null;
        }
        Object parsedStrike = null;
        if (Helpers.isTrue(!Helpers.isEqual(strike, null)))
        {
            parsedStrike = this.parseToNumeric(strike);
        }
        final Object finalSymbol = symbol;
        final Object finalBase = base;
        final Object finalSettle = settle;
        final Object finalSettleId = settleId;
        final Object finalUnifiedType = unifiedType;
        final Object finalMarginModes = marginModes;
        final Object finalSwap = swap;
        final Object finalFuture = future;
        final Object finalOption = option;
        final Object finalActive = active;
        final Object finalContract = contract;
        final Object finalLinear = linear;
        final Object finalInverse = inverse;
        final Object finalFees = fees;
        final Object finalContractSize = contractSize;
        final Object finalExpiry = expiry;
        final Object finalParsedStrike = parsedStrike;
        Object entry = new java.util.HashMap<String, Object>() {{
            put( "id", id );
            put( "lowercaseId", lowercaseId );
            put( "symbol", finalSymbol );
            put( "base", finalBase );
            put( "quote", quote );
            put( "settle", finalSettle );
            put( "baseId", baseId );
            put( "quoteId", quoteId );
            put( "settleId", finalSettleId );
            put( "type", finalUnifiedType );
            put( "spot", spot );
            put( "margin", Helpers.isTrue(spot) && Helpers.isTrue(isMarginTradingAllowed) );
            put( "marginModes", finalMarginModes );
            put( "swap", finalSwap );
            put( "future", finalFuture );
            put( "option", finalOption );
            put( "active", finalActive );
            put( "contract", finalContract );
            put( "linear", finalLinear );
            put( "inverse", finalInverse );
            put( "taker", Helpers.GetValue(Helpers.GetValue(finalFees, "trading"), "taker") );
            put( "maker", Helpers.GetValue(Helpers.GetValue(finalFees, "trading"), "maker") );
            put( "contractSize", finalContractSize );
            put( "expiry", finalExpiry );
            put( "expiryDatetime", Binance.this.iso8601(finalExpiry) );
            put( "strike", finalParsedStrike );
            put( "optionType", Binance.this.safeStringLower(market, "side") );
            put( "precision", new java.util.HashMap<String, Object>() {{
                put( "amount", Binance.this.parseNumber(Binance.this.parsePrecision(Binance.this.safeString2(market, "quantityPrecision", "quantityScale"))) );
                put( "price", Binance.this.parseNumber(Binance.this.parsePrecision(Binance.this.safeString2(market, "pricePrecision", "priceScale"))) );
                put( "base", Binance.this.parseNumber(Binance.this.parsePrecision(Binance.this.safeString(market, "baseAssetPrecision"))) );
                put( "quote", Binance.this.parseNumber(Binance.this.parsePrecision(Binance.this.safeString(market, "quotePrecision"))) );
            }} );
            put( "limits", new java.util.HashMap<String, Object>() {{
                put( "leverage", new java.util.HashMap<String, Object>() {{
                    put( "min", null );
                    put( "max", null );
                }} );
                put( "amount", new java.util.HashMap<String, Object>() {{
                    put( "min", Binance.this.safeNumber(market, "minQty") );
                    put( "max", Binance.this.safeNumber(market, "maxQty") );
                }} );
                put( "price", new java.util.HashMap<String, Object>() {{
                    put( "min", null );
                    put( "max", null );
                }} );
                put( "cost", new java.util.HashMap<String, Object>() {{
                    put( "min", null );
                    put( "max", null );
                }} );
            }} );
            put( "info", market );
            put( "created", Binance.this.safeInteger(market, "onboardDate") );
        }};
        if (Helpers.isTrue(Helpers.inOp(filtersByType, "PRICE_FILTER")))
        {
            Object filter = this.safeDict(filtersByType, "PRICE_FILTER", new java.util.HashMap<String, Object>() {{}});
            // PRICE_FILTER reports zero values for maxPrice
            // since they updated filter types in November 2018
            // https://github.com/ccxt/ccxt/issues/4286
            // therefore limits['price']['max'] doesn't have any meaningful value except undefined
            Helpers.addElementToObject(Helpers.GetValue(entry, "limits"), "price", new java.util.HashMap<String, Object>() {{
    put( "min", Binance.this.safeNumber(filter, "minPrice") );
    put( "max", Binance.this.safeNumber(filter, "maxPrice") );
}});
            Helpers.addElementToObject(Helpers.GetValue(entry, "precision"), "price", this.safeNumber(filter, "tickSize"));
        }
        if (Helpers.isTrue(Helpers.inOp(filtersByType, "LOT_SIZE")))
        {
            Object filter = this.safeDict(filtersByType, "LOT_SIZE", new java.util.HashMap<String, Object>() {{}});
            Helpers.addElementToObject(Helpers.GetValue(entry, "precision"), "amount", this.safeNumber(filter, "stepSize"));
            Helpers.addElementToObject(Helpers.GetValue(entry, "limits"), "amount", new java.util.HashMap<String, Object>() {{
    put( "min", Binance.this.safeNumber(filter, "minQty") );
    put( "max", Binance.this.safeNumber(filter, "maxQty") );
}});
        }
        if (Helpers.isTrue(Helpers.inOp(filtersByType, "MARKET_LOT_SIZE")))
        {
            Object filter = this.safeDict(filtersByType, "MARKET_LOT_SIZE", new java.util.HashMap<String, Object>() {{}});
            Helpers.addElementToObject(Helpers.GetValue(entry, "limits"), "market", new java.util.HashMap<String, Object>() {{
    put( "min", Binance.this.safeNumber(filter, "minQty") );
    put( "max", Binance.this.safeNumber(filter, "maxQty") );
}});
        }
        if (Helpers.isTrue(Helpers.isTrue((Helpers.inOp(filtersByType, "MIN_NOTIONAL"))) || Helpers.isTrue((Helpers.inOp(filtersByType, "NOTIONAL")))))
        {
            Object filter = this.safeDict2(filtersByType, "MIN_NOTIONAL", "NOTIONAL", new java.util.HashMap<String, Object>() {{}});
            Helpers.addElementToObject(Helpers.GetValue(Helpers.GetValue(entry, "limits"), "cost"), "min", this.safeNumber2(filter, "minNotional", "notional"));
            Helpers.addElementToObject(Helpers.GetValue(Helpers.GetValue(entry, "limits"), "cost"), "max", this.safeNumber(filter, "maxNotional"));
        }
        return entry;
    }

    public Object parseBalanceHelper(Object entry)
    {
        Object account = this.account();
        Helpers.addElementToObject(account, "used", this.safeString(entry, "locked"));
        Helpers.addElementToObject(account, "free", this.safeString(entry, "free"));
        Object interest = this.safeString(entry, "interest");
        Object debt = this.safeString(entry, "borrowed");
        Helpers.addElementToObject(account, "debt", Precise.stringAdd(debt, interest));
        return account;
    }

    public Object parseBalanceCustom(Object response, Object... optionalArgs)
    {
        Object type = Helpers.getArg(optionalArgs, 0, null);
        Object marginMode = Helpers.getArg(optionalArgs, 1, null);
        Object isPortfolioMargin = Helpers.getArg(optionalArgs, 2, false);
        Object result = new java.util.HashMap<String, Object>() {{
            put( "info", response );
        }};
        Object timestamp = null;
        Object isolated = Helpers.isEqual(marginMode, "isolated");
        Object cross = Helpers.isTrue((Helpers.isEqual(type, "margin"))) || Helpers.isTrue((Helpers.isEqual(marginMode, "cross")));
        if (Helpers.isTrue(isPortfolioMargin))
        {
            for (var i = 0; Helpers.isLessThan(i, Helpers.getArrayLength(response)); i++)
            {
                Object entry = Helpers.GetValue(response, i);
                Object account = this.account();
                Object currencyId = this.safeString(entry, "asset");
                Object code = this.safeCurrencyCode(currencyId);
                if (Helpers.isTrue(Helpers.isEqual(type, "linear")))
                {
                    Helpers.addElementToObject(account, "free", this.safeString(entry, "umWalletBalance"));
                    Helpers.addElementToObject(account, "used", this.safeString(entry, "umUnrealizedPNL"));
                } else if (Helpers.isTrue(Helpers.isEqual(type, "inverse")))
                {
                    Helpers.addElementToObject(account, "free", this.safeString(entry, "cmWalletBalance"));
                    Helpers.addElementToObject(account, "used", this.safeString(entry, "cmUnrealizedPNL"));
                } else if (Helpers.isTrue(cross))
                {
                    Object borrowed = this.safeString(entry, "crossMarginBorrowed");
                    Object interest = this.safeString(entry, "crossMarginInterest");
                    Helpers.addElementToObject(account, "debt", Precise.stringAdd(borrowed, interest));
                    Helpers.addElementToObject(account, "free", this.safeString(entry, "crossMarginFree"));
                    Helpers.addElementToObject(account, "used", this.safeString(entry, "crossMarginLocked"));
                    Helpers.addElementToObject(account, "total", this.safeString(entry, "crossMarginAsset"));
                } else
                {
                    Object usedLinear = this.safeString(entry, "umUnrealizedPNL");
                    Object usedInverse = this.safeString(entry, "cmUnrealizedPNL");
                    Object totalUsed = Precise.stringAdd(usedLinear, usedInverse);
                    Object totalWalletBalance = this.safeString(entry, "totalWalletBalance");
                    Helpers.addElementToObject(account, "total", Precise.stringAdd(totalUsed, totalWalletBalance));
                }
                Helpers.addElementToObject(result, code, account);
            }
        } else if (Helpers.isTrue(!Helpers.isTrue(isolated) && Helpers.isTrue((Helpers.isTrue((Helpers.isEqual(type, "spot"))) || Helpers.isTrue(cross)))))
        {
            timestamp = this.safeInteger(response, "updateTime");
            Object balances = this.safeList2(response, "balances", "userAssets", new java.util.ArrayList<Object>(java.util.Arrays.asList()));
            for (var i = 0; Helpers.isLessThan(i, Helpers.getArrayLength(balances)); i++)
            {
                Object balance = Helpers.GetValue(balances, i);
                Object currencyId = this.safeString(balance, "asset");
                Object code = this.safeCurrencyCode(currencyId);
                Object account = this.account();
                Helpers.addElementToObject(account, "free", this.safeString(balance, "free"));
                Helpers.addElementToObject(account, "used", this.safeString(balance, "locked"));
                if (Helpers.isTrue(cross))
                {
                    Object debt = this.safeString(balance, "borrowed");
                    Object interest = this.safeString(balance, "interest");
                    Helpers.addElementToObject(account, "debt", Precise.stringAdd(debt, interest));
                }
                Helpers.addElementToObject(result, code, account);
            }
        } else if (Helpers.isTrue(isolated))
        {
            Object assets = this.safeList(response, "assets");
            for (var i = 0; Helpers.isLessThan(i, Helpers.getArrayLength(assets)); i++)
            {
                Object asset = Helpers.GetValue(assets, i);
                Object marketId = this.safeString(asset, "symbol");
                Object symbol = this.safeSymbol(marketId, null, null, "spot");
                Object base = this.safeDict(asset, "baseAsset", new java.util.HashMap<String, Object>() {{}});
                Object quote = this.safeDict(asset, "quoteAsset", new java.util.HashMap<String, Object>() {{}});
                Object baseCode = this.safeCurrencyCode(this.safeString(base, "asset"));
                Object quoteCode = this.safeCurrencyCode(this.safeString(quote, "asset"));
                Object subResult = new java.util.HashMap<String, Object>() {{}};
                Helpers.addElementToObject(subResult, baseCode, this.parseBalanceHelper(base));
                Helpers.addElementToObject(subResult, quoteCode, this.parseBalanceHelper(quote));
                Helpers.addElementToObject(result, symbol, this.safeBalance(subResult));
            }
        } else if (Helpers.isTrue(Helpers.isEqual(type, "savings")))
        {
            Object positionAmountVos = this.safeList(response, "positionAmountVos", new java.util.ArrayList<Object>(java.util.Arrays.asList()));
            for (var i = 0; Helpers.isLessThan(i, Helpers.getArrayLength(positionAmountVos)); i++)
            {
                Object entry = Helpers.GetValue(positionAmountVos, i);
                Object currencyId = this.safeString(entry, "asset");
                Object code = this.safeCurrencyCode(currencyId);
                Object account = this.account();
                Object usedAndTotal = this.safeString(entry, "amount");
                Helpers.addElementToObject(account, "total", usedAndTotal);
                Helpers.addElementToObject(account, "used", usedAndTotal);
                Helpers.addElementToObject(result, code, account);
            }
        } else if (Helpers.isTrue(Helpers.isEqual(type, "funding")))
        {
            for (var i = 0; Helpers.isLessThan(i, Helpers.getArrayLength(response)); i++)
            {
                Object entry = Helpers.GetValue(response, i);
                Object account = this.account();
                Object currencyId = this.safeString(entry, "asset");
                Object code = this.safeCurrencyCode(currencyId);
                Helpers.addElementToObject(account, "free", this.safeString(entry, "free"));
                Object frozen = this.safeString(entry, "freeze");
                Object withdrawing = this.safeString(entry, "withdrawing");
                Object locked = this.safeString(entry, "locked");
                Helpers.addElementToObject(account, "used", Precise.stringAdd(frozen, Precise.stringAdd(locked, withdrawing)));
                Helpers.addElementToObject(result, code, account);
            }
        } else
        {
            Object balances = response;
            if (!Helpers.isTrue(((response instanceof java.util.List) || (response.getClass().isArray()))))
            {
                balances = this.safeList(response, "assets", new java.util.ArrayList<Object>(java.util.Arrays.asList()));
            }
            for (var i = 0; Helpers.isLessThan(i, Helpers.getArrayLength(balances)); i++)
            {
                Object balance = Helpers.GetValue(balances, i);
                Object currencyId = this.safeString(balance, "asset");
                Object code = this.safeCurrencyCode(currencyId);
                Object account = this.account();
                Helpers.addElementToObject(account, "free", this.safeString(balance, "availableBalance"));
                Helpers.addElementToObject(account, "used", this.safeString(balance, "initialMargin"));
                Helpers.addElementToObject(account, "total", this.safeString2(balance, "marginBalance", "balance"));
                Helpers.addElementToObject(result, code, account);
            }
        }
        Helpers.addElementToObject(result, "timestamp", timestamp);
        Helpers.addElementToObject(result, "datetime", this.iso8601(timestamp));
        return ((Helpers.isTrue(isolated))) ? result : this.safeBalance(result);
    }

    /**
     * @method
     * @name binance#fetchBalance
     * @description query for balance and get the amount of funds available for trading or funds locked in orders
     * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/account-endpoints#account-information-user_data  // spot
     * @see https://developers.binance.com/docs/margin_trading/account/Query-Cross-Margin-Account-Details                       // cross margin
     * @see https://developers.binance.com/docs/margin_trading/account/Query-Isolated-Margin-Account-Info                       // isolated margin
     * @see https://developers.binance.com/docs/wallet/asset/funding-wallet                                                     // funding
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/account/rest-api/Futures-Account-Balance-V2   // swap
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/account/rest-api/Futures-Account-Balance      // future
     * @see https://developers.binance.com/docs/derivatives/option/account/Option-Account-Information                           // option
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/account/Account-Balance                            // portfolio margin
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.type] 'future', 'delivery', 'savings', 'funding', or 'spot' or 'papi'
     * @param {string} [params.marginMode] 'cross' or 'isolated', for margin trading, uses this.options.defaultMarginMode if not passed, defaults to undefined/None/null
     * @param {string[]|undefined} [params.symbols] unified market symbols, only used in isolated margin mode
     * @param {boolean} [params.portfolioMargin] set to true if you would like to fetch the balance for a portfolio margin account
     * @param {string} [params.subType] 'linear' or 'inverse'
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchBalance(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object parameters = Helpers.getArg(optionalArgs, 0, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object defaultType = this.safeString2(this.options, "fetchBalance", "defaultType", "spot");
            Object type = this.safeString(parameters, "type", defaultType);
            Object subType = null;
            var subTypeparametersVariable = this.handleSubTypeAndParams("fetchBalance", null, parameters);
            subType = ((java.util.List<Object>) subTypeparametersVariable).get(0);
            parameters = ((java.util.List<Object>) subTypeparametersVariable).get(1);
            Object isPortfolioMargin = null;
            var isPortfolioMarginparametersVariable = this.handleOptionAndParams2(parameters, "fetchBalance", "papi", "portfolioMargin", false);
            isPortfolioMargin = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(0);
            parameters = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(1);
            Object marginMode = null;
            Object query = null;
            var marginModequeryVariable = this.handleMarginModeAndParams("fetchBalance", parameters);
            marginMode = ((java.util.List<Object>) marginModequeryVariable).get(0);
            query = ((java.util.List<Object>) marginModequeryVariable).get(1);
            query = this.omit(query, "type");
            Object response = null;
            Object request = new java.util.HashMap<String, Object>() {{}};
            if (Helpers.isTrue(Helpers.isTrue(isPortfolioMargin) || Helpers.isTrue((Helpers.isEqual(type, "papi")))))
            {
                if (Helpers.isTrue(this.isLinear(type, subType)))
                {
                    type = "linear";
                } else if (Helpers.isTrue(this.isInverse(type, subType)))
                {
                    type = "inverse";
                }
                isPortfolioMargin = true;
                response = (this.papiGetBalance(this.extend(request, query))).join();
            } else if (Helpers.isTrue(this.isLinear(type, subType)))
            {
                type = "linear";
                Object useV2 = null;
                var useV2parametersVariable = this.handleOptionAndParams(parameters, "fetchBalance", "useV2", false);
                useV2 = ((java.util.List<Object>) useV2parametersVariable).get(0);
                parameters = ((java.util.List<Object>) useV2parametersVariable).get(1);
                parameters = this.extend(request, query);
                if (!Helpers.isTrue(useV2))
                {
                    response = (this.fapiPrivateV3GetAccount(parameters)).join();
                } else
                {
                    response = (this.fapiPrivateV2GetAccount(parameters)).join();
                }
            } else if (Helpers.isTrue(this.isInverse(type, subType)))
            {
                type = "inverse";
                response = (this.dapiPrivateGetAccount(this.extend(request, query))).join();
            } else if (Helpers.isTrue(Helpers.isEqual(marginMode, "isolated")))
            {
                Object paramSymbols = this.safeList(parameters, "symbols");
                query = this.omit(query, "symbols");
                if (Helpers.isTrue(!Helpers.isEqual(paramSymbols, null)))
                {
                    Object symbols = "";
                    if (Helpers.isTrue(((paramSymbols instanceof java.util.List) || (paramSymbols.getClass().isArray()))))
                    {
                        symbols = this.marketId(Helpers.GetValue(paramSymbols, 0));
                        for (var i = 1; Helpers.isLessThan(i, Helpers.getArrayLength(paramSymbols)); i++)
                        {
                            Object symbol = Helpers.GetValue(paramSymbols, i);
                            Object id = this.marketId(symbol);
                            symbols = Helpers.add(symbols, Helpers.add(",", id));
                        }
                    } else
                    {
                        symbols = paramSymbols;
                    }
                    Helpers.addElementToObject(request, "symbols", symbols);
                }
                response = (this.sapiGetMarginIsolatedAccount(this.extend(request, query))).join();
            } else if (Helpers.isTrue(Helpers.isTrue((Helpers.isEqual(type, "margin"))) || Helpers.isTrue((Helpers.isEqual(marginMode, "cross")))))
            {
                response = (this.sapiGetMarginAccount(this.extend(request, query))).join();
            } else if (Helpers.isTrue(Helpers.isEqual(type, "savings")))
            {
                response = (this.sapiGetLendingUnionAccount(this.extend(request, query))).join();
            } else if (Helpers.isTrue(Helpers.isEqual(type, "funding")))
            {
                response = (this.sapiPostAssetGetFundingAsset(this.extend(request, query))).join();
            } else
            {
                response = (this.privateGetAccount(this.extend(request, query))).join();
            }
            //
            // spot
            //
            //     {
            //         "makerCommission": 10,
            //         "takerCommission": 10,
            //         "buyerCommission": 0,
            //         "sellerCommission": 0,
            //         "canTrade": true,
            //         "canWithdraw": true,
            //         "canDeposit": true,
            //         "updateTime": 1575357359602,
            //         "accountType": "MARGIN",
            //         "balances": [
            //             { asset: "BTC", free: "0.00219821", locked: "0.00000000"  },
            //         ]
            //     }
            //
            // margin (cross)
            //
            //     {
            //         "borrowEnabled":true,
            //         "marginLevel":"999.00000000",
            //         "totalAssetOfBtc":"0.00000000",
            //         "totalLiabilityOfBtc":"0.00000000",
            //         "totalNetAssetOfBtc":"0.00000000",
            //         "tradeEnabled":true,
            //         "transferEnabled":true,
            //         "userAssets":[
            //             {"asset":"MATIC","borrowed":"0.00000000","free":"0.00000000","interest":"0.00000000","locked":"0.00000000","netAsset":"0.00000000"},
            //             {"asset":"VET","borrowed":"0.00000000","free":"0.00000000","interest":"0.00000000","locked":"0.00000000","netAsset":"0.00000000"},
            //             {"asset":"USDT","borrowed":"0.00000000","free":"0.00000000","interest":"0.00000000","locked":"0.00000000","netAsset":"0.00000000"}
            //         ],
            //     }
            //
            // margin (isolated)
            //
            //    {
            //        "info": {
            //            "assets": [
            //                {
            //                    "baseAsset": {
            //                        "asset": "1INCH",
            //                        "borrowEnabled": true,
            //                        "borrowed": "0",
            //                        "free": "0",
            //                        "interest": "0",
            //                        "locked": "0",
            //                        "netAsset": "0",
            //                        "netAssetOfBtc": "0",
            //                        "repayEnabled": true,
            //                        "totalAsset": "0"
            //                    },
            //                    "quoteAsset": {
            //                        "asset": "USDT",
            //                        "borrowEnabled": true,
            //                        "borrowed": "0",
            //                        "free": "11",
            //                        "interest": "0",
            //                        "locked": "0",
            //                        "netAsset": "11",
            //                        "netAssetOfBtc": "0.00054615",
            //                        "repayEnabled": true,
            //                        "totalAsset": "11"
            //                    },
            //                    "symbol": "1INCHUSDT",
            //                    "isolatedCreated": true,
            //                    "marginLevel": "999",
            //                    "marginLevelStatus": "EXCESSIVE",
            //                    "marginRatio": "5",
            //                    "indexPrice": "0.59184331",
            //                    "liquidatePrice": "0",
            //                    "liquidateRate": "0",
            //                    "tradeEnabled": true,
            //                    "enabled": true
            //                },
            //            ]
            //        }
            //    }
            //
            // futures (fapi)
            //
            //     fapiPrivateV3GetAccount
            //
            //     {
            //         "feeTier":0,
            //         "canTrade":true,
            //         "canDeposit":true,
            //         "canWithdraw":true,
            //         "updateTime":0,
            //         "totalInitialMargin":"0.00000000",
            //         "totalMaintMargin":"0.00000000",
            //         "totalWalletBalance":"0.00000000",
            //         "totalUnrealizedProfit":"0.00000000",
            //         "totalMarginBalance":"0.00000000",
            //         "totalPositionInitialMargin":"0.00000000",
            //         "totalOpenOrderInitialMargin":"0.00000000",
            //         "totalCrossWalletBalance":"0.00000000",
            //         "totalCrossUnPnl":"0.00000000",
            //         "availableBalance":"0.00000000",
            //         "maxWithdrawAmount":"0.00000000",
            //         "assets":[
            //             {
            //                 "asset":"BNB",
            //                 "walletBalance":"0.01000000",
            //                 "unrealizedProfit":"0.00000000",
            //                 "marginBalance":"0.01000000",
            //                 "maintMargin":"0.00000000",
            //                 "initialMargin":"0.00000000",
            //                 "positionInitialMargin":"0.00000000",
            //                 "openOrderInitialMargin":"0.00000000",
            //                 "maxWithdrawAmount":"0.01000000",
            //                 "crossWalletBalance":"0.01000000",
            //                 "crossUnPnl":"0.00000000",
            //                 "availableBalance":"0.01000000"
            //             }
            //         ],
            //         "positions":[
            //             {
            //                 "symbol":"BTCUSDT",
            //                 "initialMargin":"0",
            //                 "maintMargin":"0",
            //                 "unrealizedProfit":"0.00000000",
            //                 "positionInitialMargin":"0",
            //                 "openOrderInitialMargin":"0",
            //                 "leverage":"21",
            //                 "isolated":false,
            //                 "entryPrice":"0.00000",
            //                 "maxNotional":"5000000",
            //                 "positionSide":"BOTH"
            //             },
            //         ]
            //     }
            //
            //     fapiPrivateV2GetBalance
            //
            //     [
            //         {
            //             "accountAlias":"FzFzXquXXqoC",
            //             "asset":"BNB",
            //             "balance":"0.01000000",
            //             "crossWalletBalance":"0.01000000",
            //             "crossUnPnl":"0.00000000",
            //             "availableBalance":"0.01000000",
            //             "maxWithdrawAmount":"0.01000000"
            //         }
            //     ]
            //
            // binance pay
            //
            //     [
            //       {
            //         "asset": "BUSD",
            //         "free": "1129.83",
            //         "locked": "0",
            //         "freeze": "0",
            //         "withdrawing": "0"
            //       }
            //     ]
            //
            // portfolio margin
            //
            //     [
            //         {
            //             "asset": "USDT",
            //             "totalWalletBalance": "66.9923261",
            //             "crossMarginAsset": "35.9697141",
            //             "crossMarginBorrowed": "0.0",
            //             "crossMarginFree": "35.9697141",
            //             "crossMarginInterest": "0.0",
            //             "crossMarginLocked": "0.0",
            //             "umWalletBalance": "31.022612",
            //             "umUnrealizedPNL": "0.0",
            //             "cmWalletBalance": "0.0",
            //             "cmUnrealizedPNL": "0.0",
            //             "updateTime": 0,
            //             "negativeBalance": "0.0"
            //         },
            //     ]
            //
            return this.parseBalanceCustom(response, type, marginMode, isPortfolioMargin);
        });

    }

    /**
     * @method
     * @name binance#fetchOrderBook
     * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#order-book     // spot
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Order-Book   // swap
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/Order-Book   // future
     * @see https://developers.binance.com/docs/derivatives/option/market-data/Order-Book                           // option
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public java.util.concurrent.CompletableFuture<Object> fetchOrderBook(Object symbol, Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object limit = Helpers.getArg(optionalArgs, 0, null);
            Object parameters = Helpers.getArg(optionalArgs, 1, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object market = this.market(symbol);
            Object request = new java.util.HashMap<String, Object>() {{
                put( "symbol", Helpers.GetValue(market, "id") );
            }};
            if (Helpers.isTrue(!Helpers.isEqual(limit, null)))
            {
                Helpers.addElementToObject(request, "limit", limit); // default 100, max 5000, see https://github.com/binance/binance-spot-api-docs/blob/master/rest-api.md#order-book
            }
            Object response = null;
            if (Helpers.isTrue(Helpers.GetValue(market, "option")))
            {
                response = (this.eapiPublicGetDepth(this.extend(request, parameters))).join();
            } else if (Helpers.isTrue(Helpers.GetValue(market, "linear")))
            {
                response = (this.fapiPublicGetDepth(this.extend(request, parameters))).join();
            } else if (Helpers.isTrue(Helpers.GetValue(market, "inverse")))
            {
                response = (this.dapiPublicGetDepth(this.extend(request, parameters))).join();
            } else
            {
                response = (this.publicGetDepth(this.extend(request, parameters))).join();
            }
            //
            // future
            //
            //     {
            //         "lastUpdateId":333598053905,
            //         "E":1618631511986,
            //         "T":1618631511964,
            //         "bids":[
            //             ["2493.56","20.189"],
            //             ["2493.54","1.000"],
            //             ["2493.51","0.005"]
            //         ],
            //         "asks":[
            //             ["2493.57","0.877"],
            //             ["2493.62","0.063"],
            //             ["2493.71","12.054"],
            //         ]
            //     }
            //
            // options (eapi)
            //
            //     {
            //         "bids": [
            //             ["108.7","16.08"],
            //             ["106","21.29"],
            //             ["82.4","0.02"]
            //         ],
            //         "asks": [
            //             ["111.4","19.52"],
            //             ["119.9","17.6"],
            //             ["141.2","31"]
            //         ],
            //         "T": 1676771382078,
            //         "u": 1015939
            //     }
            //
            Object timestamp = this.safeInteger(response, "T");
            Object orderbook = this.parseOrderBook(response, symbol, timestamp);
            Helpers.addElementToObject(orderbook, "nonce", this.safeInteger2(response, "lastUpdateId", "u"));
            return orderbook;
        });

    }

    public Object parseTicker(Object ticker, Object... optionalArgs)
    {
        // markPrices
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "markPrice": "11793.63104561", // mark price
        //         "indexPrice": "11781.80495970", // index price
        //         "estimatedSettlePrice": "11781.16138815", // Estimated Settle Price, only useful in the last hour before the settlement starts
        //         "lastFundingRate": "0.00038246",  // This is the lastest estimated funding rate
        //         "nextFundingTime": 1597392000000,
        //         "interestRate": "0.00010000",
        //         "time": 1597370495002
        //     }
        //
        // spot - ticker
        //
        //    {
        //        "symbol": "BTCUSDT",
        //        "priceChange": "-188.18000000",
        //        "priceChangePercent": "-0.159",
        //        "weightedAvgPrice": "118356.64734074",
        //        "lastPrice": "118449.03000000",
        //        "prevClosePrice": "118637.22000000",    // field absent in rolling ticker
        //        "lastQty": "0.00731000",                // field absent in rolling ticker
        //        "bidPrice": "118449.02000000",          // field absent in rolling ticker
        //        "bidQty": "7.15931000",                 // field absent in rolling ticker
        //        "askPrice": "118449.03000000",          // field absent in rolling ticker
        //        "askQty": "0.09592000",                 // field absent in rolling ticker
        //        "openPrice": "118637.21000000",
        //        "highPrice": "119273.36000000",
        //        "lowPrice": "117427.50000000",
        //        "volume": "14741.41491000",
        //        "quoteVolume": "1744744445.80640740",
        //        "openTime": "1753701474013",
        //        "closeTime": "1753787874013",
        //        "firstId": "5116031635",
        //        "lastId": "5117964946",
        //        "count": "1933312"
        //    }
        //
        // usdm tickers
        //
        //    {
        //        "symbol": "SUSDT",
        //        "priceChange": "-0.0229000",
        //        "priceChangePercent": "-6.777",
        //        "weightedAvgPrice": "0.3210035",
        //        "lastPrice": "0.3150000",
        //        "lastQty": "16",
        //        "openPrice": "0.3379000",
        //        "highPrice": "0.3411000",
        //        "lowPrice": "0.3071000",
        //        "volume": "120588225",
        //        "quoteVolume": "38709237.2289000",
        //        "openTime": "1753701720000",
        //        "closeTime": "1753788172414",
        //        "firstId": "72234973",
        //        "lastId": "72423677",
        //        "count": "188700"
        //    }
        //
        // coinm
        //
        //     {
        //         "baseVolume": "214549.95171161",
        //         "closeTime": "1621965286847",
        //         "count": "1283779",
        //         "firstId": "152560106",
        //         "highPrice": "39938.3",
        //         "lastId": "153843955",
        //         "lastPrice": "37993.4",
        //         "lastQty": "1",
        //         "lowPrice": "36457.2",
        //         "openPrice": "37783.4",
        //         "openTime": "1621878840000",
        //         "pair": "BTCUSD",
        //         "priceChange": "210.0",
        //         "priceChangePercent": "0.556",
        //         "symbol": "BTCUSD_PERP",
        //         "volume": "81990451",
        //         "weightedAvgPrice": "38215.08713747"
        //     }
        //
        // eapi: fetchTicker, fetchTickers
        //
        //     {
        //         "symbol": "ETH-230510-1825-C",
        //         "priceChange": "-5.1",
        //         "priceChangePercent": "-0.1854",
        //         "lastPrice": "22.4",
        //         "lastQty": "0",
        //         "open": "27.5",
        //         "high": "34.1",
        //         "low": "22.4",
        //         "volume": "6.83",
        //         "amount": "201.44",
        //         "bidPrice": "21.9",
        //         "askPrice": "22.4",
        //         "openTime": 1683614771898,
        //         "closeTime": 1683695017784,
        //         "firstTradeId": 12,
        //         "tradeCount": 22,
        //         "strikePrice": "1825",
        //         "exercisePrice": "1845.95341176"
        //     }
        //
        // spot bidsAsks
        //
        //     {
        //         "symbol":"ETHBTC",
        //         "bidPrice":"0.07466800",
        //         "bidQty":"5.31990000",
        //         "askPrice":"0.07466900",
        //         "askQty":"10.93540000"
        //     }
        //
        // usdm bidsAsks
        //
        //     {
        //         "symbol":"BTCUSDT",
        //         "bidPrice":"21321.90",
        //         "bidQty":"33.592",
        //         "askPrice":"21322.00",
        //         "askQty":"1.427",
        //         "time":"1673899207538"
        //     }
        //
        // coinm bidsAsks
        //
        //     {
        //         "symbol":"BTCUSD_PERP",
        //         "pair":"BTCUSD",
        //         "bidPrice":"21301.2",
        //         "bidQty":"188",
        //         "askPrice":"21301.3",
        //         "askQty":"10302",
        //         "time":"1673899278514"
        //     }
        //
        Object market = Helpers.getArg(optionalArgs, 0, null);
        Object timestamp = this.safeInteger2(ticker, "closeTime", "time");
        Object marketType = null;
        if (Helpers.isTrue((Helpers.inOp(ticker, "time"))))
        {
            marketType = "contract";
        }
        if (Helpers.isTrue(Helpers.isEqual(marketType, null)))
        {
            marketType = ((Helpers.isTrue((Helpers.inOp(ticker, "bidQty"))))) ? "spot" : "contract";
        }
        Object marketId = this.safeString(ticker, "symbol");
        Object symbol = this.safeSymbol(marketId, market, null, marketType);
        Object last = this.safeString(ticker, "lastPrice");
        Object wAvg = this.safeString(ticker, "weightedAvgPrice");
        Object isCoinm = (Helpers.inOp(ticker, "baseVolume"));
        Object baseVolume = null;
        Object quoteVolume = null;
        if (Helpers.isTrue(isCoinm))
        {
            baseVolume = this.safeString(ticker, "baseVolume");
            // 'volume' field in inverse markets is not quoteVolume, but traded amount (per contracts)
            quoteVolume = Precise.stringMul(baseVolume, wAvg);
        } else
        {
            baseVolume = this.safeString(ticker, "volume");
            quoteVolume = this.safeString2(ticker, "quoteVolume", "amount");
        }
        final Object finalBaseVolume = baseVolume;
        final Object finalQuoteVolume = quoteVolume;
        return this.safeTicker(new java.util.HashMap<String, Object>() {{
            put( "symbol", symbol );
            put( "timestamp", timestamp );
            put( "datetime", Binance.this.iso8601(timestamp) );
            put( "high", Binance.this.safeString2(ticker, "highPrice", "high") );
            put( "low", Binance.this.safeString2(ticker, "lowPrice", "low") );
            put( "bid", Binance.this.safeString(ticker, "bidPrice") );
            put( "bidVolume", Binance.this.safeString(ticker, "bidQty") );
            put( "ask", Binance.this.safeString(ticker, "askPrice") );
            put( "askVolume", Binance.this.safeString(ticker, "askQty") );
            put( "vwap", wAvg );
            put( "open", Binance.this.safeString2(ticker, "openPrice", "open") );
            put( "close", last );
            put( "last", last );
            put( "previousClose", Binance.this.safeString(ticker, "prevClosePrice") );
            put( "change", Binance.this.safeString(ticker, "priceChange") );
            put( "percentage", Binance.this.safeString(ticker, "priceChangePercent") );
            put( "average", null );
            put( "baseVolume", finalBaseVolume );
            put( "quoteVolume", finalQuoteVolume );
            put( "markPrice", Binance.this.safeString(ticker, "markPrice") );
            put( "indexPrice", Binance.this.safeString(ticker, "indexPrice") );
            put( "info", ticker );
        }}, market);
    }

    /**
     * @method
     * @name binance#fetchStatus
     * @description the latest known information on the availability of the exchange API
     * @see https://developers.binance.com/docs/wallet/others/system-status
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [status structure]{@link https://docs.ccxt.com/#/?id=exchange-status-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchStatus(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object parameters = Helpers.getArg(optionalArgs, 0, new java.util.HashMap<String, Object>() {{}});
            Object response = (this.sapiGetSystemStatus(parameters)).join();
            //
            //     {
            //         "status": 0,              // 0: normal1system maintenance
            //         "msg": "normal"           // "normal", "system_maintenance"
            //     }
            //
            Object statusRaw = this.safeString(response, "status");
            return new java.util.HashMap<String, Object>() {{
                put( "status", Binance.this.safeString(new java.util.HashMap<String, Object>() {{
                    put( "0", "ok" );
                    put( "1", "maintenance" );
                }}, statusRaw, statusRaw) );
                put( "updated", null );
                put( "eta", null );
                put( "url", null );
                put( "info", response );
            }};
        });

    }

    /**
     * @method
     * @name binance#fetchTicker
     * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#24hr-ticker-price-change-statistics     // spot
     * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#rolling-window-price-change-statistics  // spot
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/24hr-Ticker-Price-Change-Statistics   // swap
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/24hr-Ticker-Price-Change-Statistics   // future
     * @see https://developers.binance.com/docs/derivatives/option/market-data/24hr-Ticker-Price-Change-Statistics                           // option
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.rolling] (spot only) default false, if true, uses the rolling 24 hour ticker endpoint /api/v3/ticker
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchTicker(Object symbol, Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object parameters = Helpers.getArg(optionalArgs, 0, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object market = this.market(symbol);
            Object request = new java.util.HashMap<String, Object>() {{
                put( "symbol", Helpers.GetValue(market, "id") );
            }};
            Object response = null;
            if (Helpers.isTrue(Helpers.GetValue(market, "option")))
            {
                response = (this.eapiPublicGetTicker(this.extend(request, parameters))).join();
            } else if (Helpers.isTrue(Helpers.GetValue(market, "linear")))
            {
                response = (this.fapiPublicGetTicker24hr(this.extend(request, parameters))).join();
            } else if (Helpers.isTrue(Helpers.GetValue(market, "inverse")))
            {
                response = (this.dapiPublicGetTicker24hr(this.extend(request, parameters))).join();
            } else
            {
                Object rolling = this.safeBool(parameters, "rolling", false);
                parameters = this.omit(parameters, "rolling");
                if (Helpers.isTrue(rolling))
                {
                    response = (this.publicGetTicker(this.extend(request, parameters))).join();
                } else
                {
                    response = (this.publicGetTicker24hr(this.extend(request, parameters))).join();
                }
            }
            if (Helpers.isTrue(((response instanceof java.util.List) || (response.getClass().isArray()))))
            {
                Object firstTicker = this.safeDict(response, 0, new java.util.HashMap<String, Object>() {{}});
                return this.parseTicker(firstTicker, market);
            }
            return this.parseTicker(response, market);
        });

    }

    /**
     * @method
     * @name binance#fetchBidsAsks
     * @description fetches the bid and ask price and volume for multiple markets
     * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#symbol-order-book-ticker   // spot
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Symbol-Order-Book-Ticker // swap
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/Symbol-Order-Book-Ticker // future
     * @param {string[]|undefined} symbols unified symbols of the markets to fetch the bids and asks for, all markets are returned if not assigned
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.subType] "linear" or "inverse"
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchBidsAsks(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object symbols = Helpers.getArg(optionalArgs, 0, null);
            Object parameters = Helpers.getArg(optionalArgs, 1, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            symbols = this.marketSymbols(symbols, null, true, true, true);
            Object market = this.getMarketFromSymbols(symbols);
            Object type = null;
            var typeparametersVariable = this.handleMarketTypeAndParams("fetchBidsAsks", market, parameters);
            type = ((java.util.List<Object>) typeparametersVariable).get(0);
            parameters = ((java.util.List<Object>) typeparametersVariable).get(1);
            Object subType = null;
            var subTypeparametersVariable = this.handleSubTypeAndParams("fetchBidsAsks", market, parameters);
            subType = ((java.util.List<Object>) subTypeparametersVariable).get(0);
            parameters = ((java.util.List<Object>) subTypeparametersVariable).get(1);
            Object response = null;
            if (Helpers.isTrue(this.isLinear(type, subType)))
            {
                response = (this.fapiPublicGetTickerBookTicker(parameters)).join();
            } else if (Helpers.isTrue(this.isInverse(type, subType)))
            {
                response = (this.dapiPublicGetTickerBookTicker(parameters)).join();
            } else if (Helpers.isTrue(Helpers.isEqual(type, "spot")))
            {
                Object request = new java.util.HashMap<String, Object>() {{}};
                if (Helpers.isTrue(!Helpers.isEqual(symbols, null)))
                {
                    Helpers.addElementToObject(request, "symbols", this.json(this.marketIds(symbols)));
                }
                response = (this.publicGetTickerBookTicker(this.extend(request, parameters))).join();
            } else
            {
                throw new NotSupported((String)Helpers.add(Helpers.add(Helpers.add(this.id, " fetchBidsAsks() does not support "), type), " markets yet")) ;
            }
            return this.parseTickers(response, symbols);
        });

    }

    /**
     * @method
     * @name binance#fetchLastPrices
     * @description fetches the last price for multiple markets
     * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#symbol-price-ticker    // spot
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Symbol-Price-Ticker  // swap
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/Symbol-Price-Ticker  // future
     * @param {string[]|undefined} symbols unified symbols of the markets to fetch the last prices
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.subType] "linear" or "inverse"
     * @returns {object} a dictionary of lastprices structures
     */
    public java.util.concurrent.CompletableFuture<Object> fetchLastPrices(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object symbols = Helpers.getArg(optionalArgs, 0, null);
            Object parameters = Helpers.getArg(optionalArgs, 1, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            symbols = this.marketSymbols(symbols, null, true, true, true);
            Object market = this.getMarketFromSymbols(symbols);
            Object type = null;
            var typeparametersVariable = this.handleMarketTypeAndParams("fetchLastPrices", market, parameters);
            type = ((java.util.List<Object>) typeparametersVariable).get(0);
            parameters = ((java.util.List<Object>) typeparametersVariable).get(1);
            Object subType = null;
            var subTypeparametersVariable = this.handleSubTypeAndParams("fetchLastPrices", market, parameters);
            subType = ((java.util.List<Object>) subTypeparametersVariable).get(0);
            parameters = ((java.util.List<Object>) subTypeparametersVariable).get(1);
            Object response = null;
            if (Helpers.isTrue(this.isLinear(type, subType)))
            {
                response = (this.fapiPublicV2GetTickerPrice(parameters)).join();
            } else if (Helpers.isTrue(this.isInverse(type, subType)))
            {
                response = (this.dapiPublicGetTickerPrice(parameters)).join();
            } else if (Helpers.isTrue(Helpers.isEqual(type, "spot")))
            {
                response = (this.publicGetTickerPrice(parameters)).join();
            } else
            {
                throw new NotSupported((String)Helpers.add(Helpers.add(Helpers.add(this.id, " fetchLastPrices() does not support "), type), " markets yet")) ;
            }
            return this.parseLastPrices(response, symbols);
        });

    }

    public Object parseLastPrice(Object entry, Object... optionalArgs)
    {
        //
        // spot
        //
        //     {
        //         "symbol": "LTCBTC",
        //         "price": "4.00000200"
        //     }
        //
        // usdm (swap/future)
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "price": "6000.01",
        //         "time": 1589437530011   // Transaction time
        //     }
        //
        //
        // coinm (swap/future)
        //
        //     {
        //         "symbol": "BTCUSD_200626", // symbol ("BTCUSD_200626", "BTCUSD_PERP", etc..)
        //         "ps": "BTCUSD", // pair
        //         "price": "9647.8",
        //         "time": 1591257246176
        //     }
        //
        Object market = Helpers.getArg(optionalArgs, 0, null);
        Object timestamp = this.safeInteger(entry, "time");
        Object type = ((Helpers.isTrue((Helpers.isEqual(timestamp, null))))) ? "spot" : "swap";
        Object marketId = this.safeString(entry, "symbol");
        market = this.safeMarket(marketId, market, null, type);
        final Object finalMarket = market;
        final Object finalTimestamp = timestamp;
        return new java.util.HashMap<String, Object>() {{
            put( "symbol", Helpers.GetValue(finalMarket, "symbol") );
            put( "timestamp", finalTimestamp );
            put( "datetime", Binance.this.iso8601(finalTimestamp) );
            put( "price", Binance.this.safeNumberOmitZero(entry, "price") );
            put( "side", null );
            put( "info", entry );
        }};
    }

    /**
     * @method
     * @name binance#fetchTickers
     * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
     * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#24hr-ticker-price-change-statistics    // spot
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/24hr-Ticker-Price-Change-Statistics  // swap
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/24hr-Ticker-Price-Change-Statistics  // future
     * @see https://developers.binance.com/docs/derivatives/option/market-data/24hr-Ticker-Price-Change-Statistics                          // option
     * @param {string[]} [symbols] unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.subType] "linear" or "inverse"
     * @param {string} [params.type] 'spot', 'option', use params["subType"] for swap and future markets
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchTickers(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object symbols = Helpers.getArg(optionalArgs, 0, null);
            Object parameters = Helpers.getArg(optionalArgs, 1, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            symbols = this.marketSymbols(symbols, null, true, true, true);
            Object market = this.getMarketFromSymbols(symbols);
            Object type = null;
            var typeparametersVariable = this.handleMarketTypeAndParams("fetchTickers", market, parameters);
            type = ((java.util.List<Object>) typeparametersVariable).get(0);
            parameters = ((java.util.List<Object>) typeparametersVariable).get(1);
            Object subType = null;
            var subTypeparametersVariable = this.handleSubTypeAndParams("fetchTickers", market, parameters);
            subType = ((java.util.List<Object>) subTypeparametersVariable).get(0);
            parameters = ((java.util.List<Object>) subTypeparametersVariable).get(1);
            Object response = null;
            if (Helpers.isTrue(this.isLinear(type, subType)))
            {
                response = (this.fapiPublicGetTicker24hr(parameters)).join();
            } else if (Helpers.isTrue(this.isInverse(type, subType)))
            {
                response = (this.dapiPublicGetTicker24hr(parameters)).join();
            } else if (Helpers.isTrue(Helpers.isEqual(type, "spot")))
            {
                Object rolling = this.safeBool(parameters, "rolling", false);
                parameters = this.omit(parameters, "rolling");
                if (Helpers.isTrue(rolling))
                {
                    symbols = this.marketSymbols(symbols);
                    final Object finalSymbols = symbols;
                    Object request = new java.util.HashMap<String, Object>() {{
                        put( "symbols", Binance.this.json(Binance.this.marketIds(finalSymbols)) );
                    }};
                    response = (this.publicGetTicker(this.extend(request, parameters))).join();
                    // parseTicker is not able to handle marketType for spot-rolling ticker fields, so we need custom parsing
                    return this.parseTickersForRolling(response, symbols);
                } else
                {
                    Object request = new java.util.HashMap<String, Object>() {{}};
                    if (Helpers.isTrue(!Helpers.isEqual(symbols, null)))
                    {
                        Helpers.addElementToObject(request, "symbols", this.json(this.marketIds(symbols)));
                    }
                    response = (this.publicGetTicker24hr(this.extend(request, parameters))).join();
                }
            } else if (Helpers.isTrue(Helpers.isEqual(type, "option")))
            {
                response = (this.eapiPublicGetTicker(parameters)).join();
            } else
            {
                throw new NotSupported((String)Helpers.add(Helpers.add(Helpers.add(this.id, " fetchTickers() does not support "), type), " markets yet")) ;
            }
            return this.parseTickers(response, symbols);
        });

    }

    public Object parseTickersForRolling(Object response, Object symbols)
    {
        Object results = new java.util.ArrayList<Object>(java.util.Arrays.asList());
        for (var i = 0; Helpers.isLessThan(i, Helpers.getArrayLength(response)); i++)
        {
            Object marketId = this.safeString(Helpers.GetValue(response, i), "symbol");
            Object tickerMarket = this.safeMarket(marketId, null, null, "spot");
            Object parsedTicker = this.parseTicker(Helpers.GetValue(response, i));
            Helpers.addElementToObject(parsedTicker, "symbol", Helpers.GetValue(tickerMarket, "symbol"));
            ((java.util.List<Object>)results).add(parsedTicker);
        }
        return this.filterByArray(results, "symbol", symbols);
    }

    /**
     * @method
     * @name binance#fetchMarkPrice
     * @description fetches mark price for the market
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/Index-Price-and-Mark-Price
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Mark-Price
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.subType] "linear" or "inverse"
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchMarkPrice(Object symbol, Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object parameters = Helpers.getArg(optionalArgs, 0, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object market = this.market(symbol);
            Object type = null;
            var typeparametersVariable = this.handleMarketTypeAndParams("fetchMarkPrice", market, parameters, "swap");
            type = ((java.util.List<Object>) typeparametersVariable).get(0);
            parameters = ((java.util.List<Object>) typeparametersVariable).get(1);
            Object subType = null;
            var subTypeparametersVariable = this.handleSubTypeAndParams("fetchMarkPrice", market, parameters, "linear");
            subType = ((java.util.List<Object>) subTypeparametersVariable).get(0);
            parameters = ((java.util.List<Object>) subTypeparametersVariable).get(1);
            Object request = new java.util.HashMap<String, Object>() {{
                put( "symbol", Helpers.GetValue(market, "id") );
            }};
            Object response = null;
            if (Helpers.isTrue(this.isLinear(type, subType)))
            {
                response = (this.fapiPublicGetPremiumIndex(this.extend(request, parameters))).join();
            } else if (Helpers.isTrue(this.isInverse(type, subType)))
            {
                response = (this.dapiPublicGetPremiumIndex(this.extend(request, parameters))).join();
            } else
            {
                throw new NotSupported((String)Helpers.add(Helpers.add(Helpers.add(this.id, " fetchMarkPrice() does not support "), type), " markets yet")) ;
            }
            if (Helpers.isTrue(((response instanceof java.util.List) || (response.getClass().isArray()))))
            {
                return this.parseTicker(this.safeDict(response, 0, new java.util.HashMap<String, Object>() {{}}), market);
            }
            return this.parseTicker(response, market);
        });

    }

    /**
     * @method
     * @name binance#fetchMarkPrices
     * @description fetches mark prices for multiple markets
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/Index-Price-and-Mark-Price
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Mark-Price
     * @param {string[]} [symbols] unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.subType] "linear" or "inverse"
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchMarkPrices(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object symbols = Helpers.getArg(optionalArgs, 0, null);
            Object parameters = Helpers.getArg(optionalArgs, 1, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            symbols = this.marketSymbols(symbols, null, true, true, true);
            Object market = this.getMarketFromSymbols(symbols);
            Object type = null;
            var typeparametersVariable = this.handleMarketTypeAndParams("fetchMarkPrices", market, parameters, "swap");
            type = ((java.util.List<Object>) typeparametersVariable).get(0);
            parameters = ((java.util.List<Object>) typeparametersVariable).get(1);
            Object subType = null;
            var subTypeparametersVariable = this.handleSubTypeAndParams("fetchMarkPrices", market, parameters, "linear");
            subType = ((java.util.List<Object>) subTypeparametersVariable).get(0);
            parameters = ((java.util.List<Object>) subTypeparametersVariable).get(1);
            Object response = null;
            if (Helpers.isTrue(this.isLinear(type, subType)))
            {
                response = (this.fapiPublicGetPremiumIndex(parameters)).join();
            } else if (Helpers.isTrue(this.isInverse(type, subType)))
            {
                response = (this.dapiPublicGetPremiumIndex(parameters)).join();
            } else
            {
                throw new NotSupported((String)Helpers.add(Helpers.add(Helpers.add(this.id, " fetchMarkPrices() does not support "), type), " markets yet")) ;
            }
            return this.parseTickers(response, symbols);
        });

    }

    public Object parseOHLCV(Object ohlcv, Object... optionalArgs)
    {
        // when api method = publicGetKlines || fapiPublicGetKlines || dapiPublicGetKlines
        //     [
        //         1591478520000, // open time
        //         "0.02501300",  // open
        //         "0.02501800",  // high
        //         "0.02500000",  // low
        //         "0.02500000",  // close
        //         "22.19000000", // volume
        //         1591478579999, // close time
        //         "0.55490906",  // quote asset volume, base asset volume for dapi
        //         40,            // number of trades
        //         "10.92900000", // taker buy base asset volume
        //         "0.27336462",  // taker buy quote asset volume
        //         "0"            // ignore
        //     ]
        //
        //  when api method = fapiPublicGetMarkPriceKlines || fapiPublicGetIndexPriceKlines
        //     [
        //         [
        //         1591256460000,          // Open time
        //         "9653.29201333",        // Open
        //         "9654.56401333",        // High
        //         "9653.07367333",        // Low
        //         "9653.07367333",        // Close (or latest price)
        //         "0",                    // Ignore
        //         1591256519999,          // Close time
        //         "0",                    // Ignore
        //         60,                     // Number of bisic data
        //         "0",                    // Ignore
        //         "0",                    // Ignore
        //         "0"                     // Ignore
        //         ]
        //     ]
        //
        // options
        //
        //     {
        //         "open": "32.2",
        //         "high": "32.2",
        //         "low": "32.2",
        //         "close": "32.2",
        //         "volume": "0",
        //         "interval": "5m",
        //         "tradeCount": 0,
        //         "takerVolume": "0",
        //         "takerAmount": "0",
        //         "amount": "0",
        //         "openTime": 1677096900000,
        //         "closeTime": 1677097200000
        //     }
        //
        Object market = Helpers.getArg(optionalArgs, 0, null);
        Object inverse = this.safeBool(market, "inverse");
        Object volumeIndex = ((Helpers.isTrue(inverse))) ? 7 : 5;
        return new java.util.ArrayList<Object>(java.util.Arrays.asList(this.safeInteger2(ohlcv, 0, "openTime"), this.safeNumber2(ohlcv, 1, "open"), this.safeNumber2(ohlcv, 2, "high"), this.safeNumber2(ohlcv, 3, "low"), this.safeNumber2(ohlcv, 4, "close"), this.safeNumber2(ohlcv, volumeIndex, "volume")));
    }

    /**
     * @method
     * @name binance#fetchOHLCV
     * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#klinecandlestick-data
     * @see https://developers.binance.com/docs/derivatives/option/market-data/Kline-Candlestick-Data
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Kline-Candlestick-Data
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Index-Price-Kline-Candlestick-Data
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Mark-Price-Kline-Candlestick-Data
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Premium-Index-Kline-Data
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/Kline-Candlestick-Data
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/Index-Price-Kline-Candlestick-Data
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/Mark-Price-Kline-Candlestick-Data
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/Premium-Index-Kline-Data
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.price] "mark" or "index" for mark price and index price candles
     * @param {int} [params.until] timestamp in ms of the latest candle to fetch
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public java.util.concurrent.CompletableFuture<Object> fetchOHLCV(Object symbol, Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object timeframe = Helpers.getArg(optionalArgs, 0, "1m");
            Object since = Helpers.getArg(optionalArgs, 1, null);
            Object limit = Helpers.getArg(optionalArgs, 2, null);
            Object parameters = Helpers.getArg(optionalArgs, 3, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object paginate = false;
            var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchOHLCV", "paginate", false);
            paginate = ((java.util.List<Object>) paginateparametersVariable).get(0);
            parameters = ((java.util.List<Object>) paginateparametersVariable).get(1);
            if (Helpers.isTrue(paginate))
            {
                return (this.fetchPaginatedCallDeterministic("fetchOHLCV", symbol, since, limit, timeframe, parameters, 1000)).join();
            }
            Object market = this.market(symbol);
            // binance docs say that the default limit 500, max 1500 for futures, max 1000 for spot markets
            // the reality is that the time range wider than 500 candles won't work right
            Object defaultLimit = 500;
            Object maxLimit = 1500;
            Object price = this.safeString(parameters, "price");
            Object until = this.safeInteger(parameters, "until");
            parameters = this.omit(parameters, new java.util.ArrayList<Object>(java.util.Arrays.asList("price", "until")));
            if (Helpers.isTrue(Helpers.isTrue(Helpers.isTrue(!Helpers.isEqual(since, null)) && Helpers.isTrue(!Helpers.isEqual(until, null))) && Helpers.isTrue(Helpers.isEqual(limit, null))))
            {
                limit = maxLimit;
            }
            limit = ((Helpers.isTrue((Helpers.isEqual(limit, null))))) ? defaultLimit : Helpers.mathMin(limit, maxLimit);
            final Object finalLimit = limit;
            Object request = new java.util.HashMap<String, Object>() {{
                put( "interval", Binance.this.safeString(Binance.this.timeframes, timeframe, timeframe) );
                put( "limit", finalLimit );
            }};
            Object marketId = Helpers.GetValue(market, "id");
            if (Helpers.isTrue(Helpers.isEqual(price, "index")))
            {
                Object parts = new java.util.ArrayList<Object>(java.util.Arrays.asList(((String)marketId).split((String)"_")));
                Object pair = this.safeString(parts, 0);
                Helpers.addElementToObject(request, "pair", pair); // Index price takes this argument instead of symbol
            } else
            {
                Helpers.addElementToObject(request, "symbol", marketId);
            }
            // const duration = this.parseTimeframe (timeframe);
            if (Helpers.isTrue(!Helpers.isEqual(since, null)))
            {
                Helpers.addElementToObject(request, "startTime", since);
                //
                // It didn't work before without the endTime
                // https://github.com/ccxt/ccxt/issues/8454
                //
                if (Helpers.isTrue(Helpers.GetValue(market, "inverse")))
                {
                    if (Helpers.isTrue(Helpers.isGreaterThan(since, 0)))
                    {
                        Object duration = this.parseTimeframe(timeframe);
                        Object endTime = this.sum(since, Helpers.subtract(Helpers.multiply(Helpers.multiply(limit, duration), 1000), 1));
                        Object now = this.milliseconds();
                        Helpers.addElementToObject(request, "endTime", Helpers.mathMin(now, endTime));
                    }
                }
            }
            if (Helpers.isTrue(!Helpers.isEqual(until, null)))
            {
                Helpers.addElementToObject(request, "endTime", until);
            }
            Object response = null;
            if (Helpers.isTrue(Helpers.GetValue(market, "option")))
            {
                response = (this.eapiPublicGetKlines(this.extend(request, parameters))).join();
            } else if (Helpers.isTrue(Helpers.isEqual(price, "mark")))
            {
                if (Helpers.isTrue(Helpers.GetValue(market, "inverse")))
                {
                    response = (this.dapiPublicGetMarkPriceKlines(this.extend(request, parameters))).join();
                } else
                {
                    response = (this.fapiPublicGetMarkPriceKlines(this.extend(request, parameters))).join();
                }
            } else if (Helpers.isTrue(Helpers.isEqual(price, "index")))
            {
                if (Helpers.isTrue(Helpers.GetValue(market, "inverse")))
                {
                    response = (this.dapiPublicGetIndexPriceKlines(this.extend(request, parameters))).join();
                } else
                {
                    response = (this.fapiPublicGetIndexPriceKlines(this.extend(request, parameters))).join();
                }
            } else if (Helpers.isTrue(Helpers.isEqual(price, "premiumIndex")))
            {
                if (Helpers.isTrue(Helpers.GetValue(market, "inverse")))
                {
                    response = (this.dapiPublicGetPremiumIndexKlines(this.extend(request, parameters))).join();
                } else
                {
                    response = (this.fapiPublicGetPremiumIndexKlines(this.extend(request, parameters))).join();
                }
            } else if (Helpers.isTrue(Helpers.GetValue(market, "linear")))
            {
                response = (this.fapiPublicGetKlines(this.extend(request, parameters))).join();
            } else if (Helpers.isTrue(Helpers.GetValue(market, "inverse")))
            {
                response = (this.dapiPublicGetKlines(this.extend(request, parameters))).join();
            } else
            {
                response = (this.publicGetKlines(this.extend(request, parameters))).join();
            }
            //
            //     [
            //         [1591478520000,"0.02501300","0.02501800","0.02500000","0.02500000","22.19000000",1591478579999,"0.55490906",40,"10.92900000","0.27336462","0"],
            //         [1591478580000,"0.02499600","0.02500900","0.02499400","0.02500300","21.34700000",1591478639999,"0.53370468",24,"7.53800000","0.18850725","0"],
            //         [1591478640000,"0.02500800","0.02501100","0.02500300","0.02500800","154.14200000",1591478699999,"3.85405839",97,"5.32300000","0.13312641","0"],
            //     ]
            //
            // options (eapi)
            //
            //     [
            //         {
            //             "open": "32.2",
            //             "high": "32.2",
            //             "low": "32.2",
            //             "close": "32.2",
            //             "volume": "0",
            //             "interval": "5m",
            //             "tradeCount": 0,
            //             "takerVolume": "0",
            //             "takerAmount": "0",
            //             "amount": "0",
            //             "openTime": 1677096900000,
            //             "closeTime": 1677097200000
            //         }
            //     ]
            //
            Object candles = this.parseOHLCVs(response, market, timeframe, since, limit);
            return candles;
        });

    }

    public Object parseTrade(Object trade, Object... optionalArgs)
    {
        Object market = Helpers.getArg(optionalArgs, 0, null);
        if (Helpers.isTrue(Helpers.inOp(trade, "isDustTrade")))
        {
            return this.parseDustTrade(trade, market);
        }
        //
        // aggregate trades
        // https://github.com/binance-exchange/binance-official-api-docs/blob/master/rest-api.md#compressedaggregate-trades-list
        //
        //     {
        //         "a": 26129,         // Aggregate tradeId
        //         "p": "0.01633102",  // Price
        //         "q": "4.70443515",  // Quantity
        //         "f": 27781,         // First tradeId
        //         "l": 27781,         // Last tradeId
        //         "T": 1498793709153, // Timestamp
        //         "m": true,          // Was the buyer the maker?
        //         "M": true           // Was the trade the best price match?
        //     }
        //
        // REST: aggregate trades for swap & future (both linear and inverse)
        //
        //     {
        //         "a": "269772814",
        //         "p": "25864.1",
        //         "q": "3",
        //         "f": "662149354",
        //         "l": "662149355",
        //         "T": "1694209776022",
        //         "m": false,
        //     }
        //
        // recent public trades and old public trades
        // https://github.com/binance-exchange/binance-official-api-docs/blob/master/rest-api.md#recent-trades-list
        // https://github.com/binance-exchange/binance-official-api-docs/blob/master/rest-api.md#old-trade-lookup-market_data
        //
        //     {
        //         "id": 28457,
        //         "price": "4.00000100",
        //         "qty": "12.00000000",
        //         "time": 1499865549590,
        //         "isBuyerMaker": true,
        //         "isBestMatch": true
        //     }
        //
        // private trades
        // https://github.com/binance-exchange/binance-official-api-docs/blob/master/rest-api.md#account-trade-list-user_data
        //
        //     {
        //         "symbol": "BNBBTC",
        //         "id": 28457,
        //         "orderId": 100234,
        //         "price": "4.00000100",
        //         "qty": "12.00000000",
        //         "commission": "10.10000000",
        //         "commissionAsset": "BNB",
        //         "time": 1499865549590,
        //         "isBuyer": true,
        //         "isMaker": false,
        //         "isBestMatch": true
        //     }
        //
        // futures trades
        //
        //     {
        //       "accountId": 20,
        //       "buyer": False,
        //       "commission": "-0.07819010",
        //       "commissionAsset": "USDT",
        //       "counterPartyId": 653,
        //       "id": 698759,
        //       "maker": False,
        //       "orderId": 25851813,
        //       "price": "7819.01",
        //       "qty": "0.002",
        //       "quoteQty": "0.01563",
        //       "realizedPnl": "-0.91539999",
        //       "side": "SELL",
        //       "symbol": "BTCUSDT",
        //       "time": 1569514978020
        //     }
        //     {
        //       "symbol": "BTCUSDT",
        //       "id": 477128891,
        //       "orderId": 13809777875,
        //       "side": "SELL",
        //       "price": "38479.55",
        //       "qty": "0.001",
        //       "realizedPnl": "-0.00009534",
        //       "marginAsset": "USDT",
        //       "quoteQty": "38.47955",
        //       "commission": "-0.00076959",
        //       "commissionAsset": "USDT",
        //       "time": 1612733566708,
        //       "positionSide": "BOTH",
        //       "maker": true,
        //       "buyer": false
        //     }
        //
        // { respType: FULL }
        //
        //     {
        //       "price": "4000.00000000",
        //       "qty": "1.00000000",
        //       "commission": "4.00000000",
        //       "commissionAsset": "USDT",
        //       "tradeId": "1234",
        //     }
        //
        // options: fetchMyTrades
        //
        //     {
        //         "id": 1125899906844226012,
        //         "tradeId": 73,
        //         "orderId": 4638761100843040768,
        //         "symbol": "ETH-230211-1500-C",
        //         "price": "18.70000000",
        //         "quantity": "-0.57000000",
        //         "fee": "0.17305890",
        //         "realizedProfit": "-3.53400000",
        //         "side": "SELL",
        //         "type": "LIMIT",
        //         "volatility": "0.30000000",
        //         "liquidity": "MAKER",
        //         "time": 1676085216845,
        //         "priceScale": 1,
        //         "quantityScale": 2,
        //         "optionSide": "CALL",
        //         "quoteAsset": "USDT"
        //     }
        //
        // options: fetchTrades
        //
        //     {
        //         "id": 1,
        //         "symbol": "ETH-230216-1500-C",
        //         "price": "35.5",
        //         "qty": "0.03",
        //         "quoteQty": "1.065",
        //         "side": 1,
        //         "time": 1676366446072
        //     }
        //
        // fetchMyTrades: linear portfolio margin
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "id": 4575108247,
        //         "orderId": 261942655610,
        //         "side": "SELL",
        //         "price": "47263.40",
        //         "qty": "0.010",
        //         "realizedPnl": "27.38400000",
        //         "marginAsset": "USDT",
        //         "quoteQty": "472.63",
        //         "commission": "0.18905360",
        //         "commissionAsset": "USDT",
        //         "time": 1707530039409,
        //         "buyer": false,
        //         "maker": false,
        //         "positionSide": "LONG"
        //     }
        //
        // fetchMyTrades: inverse portfolio margin
        //
        //     {
        //         "symbol": "ETHUSD_PERP",
        //         "id": 701907838,
        //         "orderId": 71548909034,
        //         "pair": "ETHUSD",
        //         "side": "SELL",
        //         "price": "2498.15",
        //         "qty": "1",
        //         "realizedPnl": "0.00012517",
        //         "marginAsset": "ETH",
        //         "baseQty": "0.00400296",
        //         "commission": "0.00000160",
        //         "commissionAsset": "ETH",
        //         "time": 1707530317519,
        //         "positionSide": "LONG",
        //         "buyer": false,
        //         "maker": false
        //     }
        //
        // fetchMyTrades: spot margin portfolio margin
        //
        //     {
        //         "symbol": "ADAUSDT",
        //         "id": 470227543,
        //         "orderId": 4421170947,
        //         "price": "0.53880000",
        //         "qty": "10.00000000",
        //         "quoteQty": "5.38800000",
        //         "commission": "0.00538800",
        //         "commissionAsset": "USDT",
        //         "time": 1707545780522,
        //         "isBuyer": false,
        //         "isMaker": false,
        //         "isBestMatch": true
        //     }
        //
        Object timestamp = this.safeInteger2(trade, "T", "time");
        Object amount = this.safeString2(trade, "q", "qty");
        amount = this.safeString(trade, "quantity", amount);
        Object marketId = this.safeString(trade, "symbol");
        Object isSpotTrade = Helpers.isTrue(Helpers.isTrue(Helpers.isTrue((Helpers.inOp(trade, "isIsolated"))) || Helpers.isTrue((Helpers.inOp(trade, "M")))) || Helpers.isTrue((Helpers.inOp(trade, "orderListId")))) || Helpers.isTrue((Helpers.inOp(trade, "isMaker")));
        Object marketType = ((Helpers.isTrue(isSpotTrade))) ? "spot" : "contract";
        market = this.safeMarket(marketId, market, null, marketType);
        Object symbol = Helpers.GetValue(market, "symbol");
        Object side = null;
        Object buyerMaker = this.safeBool2(trade, "m", "isBuyerMaker");
        Object takerOrMaker = null;
        if (Helpers.isTrue(!Helpers.isEqual(buyerMaker, null)))
        {
            side = ((Helpers.isTrue(buyerMaker))) ? "sell" : "buy"; // this is reversed intentionally
        } else if (Helpers.isTrue(Helpers.inOp(trade, "side")))
        {
            side = this.safeStringLower(trade, "side");
        } else
        {
            if (Helpers.isTrue(Helpers.inOp(trade, "isBuyer")))
            {
                side = ((Helpers.isTrue(Helpers.GetValue(trade, "isBuyer")))) ? "buy" : "sell"; // this is a true side
            }
        }
        Object fee = null;
        if (Helpers.isTrue(Helpers.inOp(trade, "commission")))
        {
            fee = new java.util.HashMap<String, Object>() {{
                put( "cost", Binance.this.safeString(trade, "commission") );
                put( "currency", Binance.this.safeCurrencyCode(Binance.this.safeString(trade, "commissionAsset")) );
            }};
        }
        if (Helpers.isTrue(Helpers.inOp(trade, "isMaker")))
        {
            takerOrMaker = ((Helpers.isTrue(Helpers.GetValue(trade, "isMaker")))) ? "maker" : "taker";
        }
        if (Helpers.isTrue(Helpers.inOp(trade, "maker")))
        {
            takerOrMaker = ((Helpers.isTrue(Helpers.GetValue(trade, "maker")))) ? "maker" : "taker";
        }
        if (Helpers.isTrue(Helpers.isTrue((Helpers.inOp(trade, "optionSide"))) || Helpers.isTrue(Helpers.GetValue(market, "option"))))
        {
            Object settle = this.safeCurrencyCode(this.safeString(trade, "quoteAsset", "USDT"));
            takerOrMaker = this.safeStringLower(trade, "liquidity");
            if (Helpers.isTrue(Helpers.inOp(trade, "fee")))
            {
                fee = new java.util.HashMap<String, Object>() {{
                    put( "cost", Binance.this.safeString(trade, "fee") );
                    put( "currency", settle );
                }};
            }
            if (Helpers.isTrue(Helpers.isTrue((!Helpers.isEqual(side, "buy"))) && Helpers.isTrue((!Helpers.isEqual(side, "sell")))))
            {
                side = ((Helpers.isTrue((Helpers.isEqual(side, "1"))))) ? "buy" : "sell";
            }
            if (Helpers.isTrue(Helpers.inOp(trade, "optionSide")))
            {
                if (Helpers.isTrue(!Helpers.isEqual(side, "buy")))
                {
                    amount = Precise.stringMul("-1", amount);
                }
            }
        }
        final Object finalSide = side;
        final Object finalTakerOrMaker = takerOrMaker;
        final Object finalAmount = amount;
        final Object finalFee = fee;
        return this.safeTrade(new java.util.HashMap<String, Object>() {{
            put( "info", trade );
            put( "timestamp", timestamp );
            put( "datetime", Binance.this.iso8601(timestamp) );
            put( "symbol", symbol );
            put( "id", Binance.this.safeStringN(trade, new java.util.ArrayList<Object>(java.util.Arrays.asList("t", "a", "tradeId", "id"))) );
            put( "order", Binance.this.safeString(trade, "orderId") );
            put( "type", Binance.this.safeStringLower(trade, "type") );
            put( "side", finalSide );
            put( "takerOrMaker", finalTakerOrMaker );
            put( "price", Binance.this.safeString2(trade, "p", "price") );
            put( "amount", finalAmount );
            put( "cost", Binance.this.safeString2(trade, "quoteQty", "baseQty") );
            put( "fee", finalFee );
        }}, market);
    }

    /**
     * @method
     * @name binance#fetchTrades
     * @description get the list of most recent trades for a particular symbol
     * Default fetchTradesMethod
     * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#compressedaggregate-trades-list    // publicGetAggTrades (spot)
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Compressed-Aggregate-Trades-List // fapiPublicGetAggTrades (swap)
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/Compressed-Aggregate-Trades-List // dapiPublicGetAggTrades (future)
     * @see https://developers.binance.com/docs/derivatives/option/market-data/Recent-Trades-List                                       // eapiPublicGetTrades (option)
     * Other fetchTradesMethod
     * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#recent-trades-list                 // publicGetTrades (spot)
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Recent-Trades-List               // fapiPublicGetTrades (swap)
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/Recent-Trades-List               // dapiPublicGetTrades (future)
     * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/market-data-endpoints#old-trade-lookup                   // publicGetHistoricalTrades (spot)
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Old-Trades-Lookup                // fapiPublicGetHistoricalTrades (swap)
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/Old-Trades-Lookup                // dapiPublicGetHistoricalTrades (future)
     * @see https://developers.binance.com/docs/derivatives/option/market-data/Old-Trades-Lookup                                        // eapiPublicGetHistoricalTrades (option)
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] only used when fetchTradesMethod is 'publicGetAggTrades', 'fapiPublicGetAggTrades', or 'dapiPublicGetAggTrades'
     * @param {int} [limit] default 500, max 1000
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] only used when fetchTradesMethod is 'publicGetAggTrades', 'fapiPublicGetAggTrades', or 'dapiPublicGetAggTrades'
     * @param {int} [params.fetchTradesMethod] 'publicGetAggTrades' (spot default), 'fapiPublicGetAggTrades' (swap default), 'dapiPublicGetAggTrades' (future default), 'eapiPublicGetTrades' (option default), 'publicGetTrades', 'fapiPublicGetTrades', 'dapiPublicGetTrades', 'publicGetHistoricalTrades', 'fapiPublicGetHistoricalTrades', 'dapiPublicGetHistoricalTrades', 'eapiPublicGetHistoricalTrades'
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     *
     * EXCHANGE SPECIFIC PARAMETERS
     * @param {int} [params.fromId] trade id to fetch from, default gets most recent trades, not used when fetchTradesMethod is 'publicGetTrades', 'fapiPublicGetTrades', 'dapiPublicGetTrades', or 'eapiPublicGetTrades'
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchTrades(Object symbol, Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object since = Helpers.getArg(optionalArgs, 0, null);
            Object limit = Helpers.getArg(optionalArgs, 1, null);
            Object parameters = Helpers.getArg(optionalArgs, 2, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object paginate = false;
            var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchTrades", "paginate");
            paginate = ((java.util.List<Object>) paginateparametersVariable).get(0);
            parameters = ((java.util.List<Object>) paginateparametersVariable).get(1);
            if (Helpers.isTrue(paginate))
            {
                return (this.fetchPaginatedCallDynamic("fetchTrades", symbol, since, limit, parameters)).join();
            }
            Object market = this.market(symbol);
            Object request = new java.util.HashMap<String, Object>() {{
                put( "symbol", Helpers.GetValue(market, "id") );
            }};
            if (!Helpers.isTrue(Helpers.GetValue(market, "option")))
            {
                if (Helpers.isTrue(!Helpers.isEqual(since, null)))
                {
                    Helpers.addElementToObject(request, "startTime", since);
                    // https://github.com/ccxt/ccxt/issues/6400
                    // https://github.com/binance-exchange/binance-official-api-docs/blob/master/rest-api.md#compressedaggregate-trades-list
                    Helpers.addElementToObject(request, "endTime", this.sum(since, 3600000));
                }
                Object until = this.safeInteger(parameters, "until");
                if (Helpers.isTrue(!Helpers.isEqual(until, null)))
                {
                    Helpers.addElementToObject(request, "endTime", until);
                }
            }
            Object method = this.safeString(this.options, "fetchTradesMethod");
            method = this.safeString2(parameters, "fetchTradesMethod", "method", method);
            if (Helpers.isTrue(!Helpers.isEqual(limit, null)))
            {
                Object isFutureOrSwap = (Helpers.isTrue(Helpers.GetValue(market, "swap")) || Helpers.isTrue(Helpers.GetValue(market, "future")));
                Object isHistoricalEndpoint = Helpers.isTrue((!Helpers.isEqual(method, null))) && Helpers.isTrue((Helpers.isGreaterThanOrEqual(Helpers.getIndexOf(method, "GetHistoricalTrades"), 0)));
                Object maxLimitForContractHistorical = ((Helpers.isTrue(isHistoricalEndpoint))) ? 500 : 1000;
                Helpers.addElementToObject(request, "limit", ((Helpers.isTrue(isFutureOrSwap))) ? Helpers.mathMin(limit, maxLimitForContractHistorical) : limit); // default = 500, maximum = 1000
            }
            parameters = this.omit(parameters, new java.util.ArrayList<Object>(java.util.Arrays.asList("until", "fetchTradesMethod")));
            Object response = null;
            if (Helpers.isTrue(Helpers.isTrue(Helpers.GetValue(market, "option")) || Helpers.isTrue(Helpers.isEqual(method, "eapiPublicGetTrades"))))
            {
                response = (this.eapiPublicGetTrades(this.extend(request, parameters))).join();
            } else if (Helpers.isTrue(Helpers.isTrue(Helpers.GetValue(market, "linear")) || Helpers.isTrue(Helpers.isEqual(method, "fapiPublicGetAggTrades"))))
            {
                response = (this.fapiPublicGetAggTrades(this.extend(request, parameters))).join();
            } else if (Helpers.isTrue(Helpers.isTrue(Helpers.GetValue(market, "inverse")) || Helpers.isTrue(Helpers.isEqual(method, "dapiPublicGetAggTrades"))))
            {
                response = (this.dapiPublicGetAggTrades(this.extend(request, parameters))).join();
            } else
            {
                response = (this.publicGetAggTrades(this.extend(request, parameters))).join();
            }
            //
            // Caveats:
            // - default limit (500) applies only if no other parameters set, trades up
            //   to the maximum limit may be returned to satisfy other parameters
            // - if both limit and time window is set and time window contains more
            //   trades than the limit then the last trades from the window are returned
            // - "tradeId" accepted and returned by this method is "aggregate" trade id
            //   which is different from actual trade id
            // - setting both fromId and time window results in error
            //
            // aggregate trades
            //
            //     [
            //         {
            //             "a": 26129,         // Aggregate tradeId
            //             "p": "0.01633102",  // Price
            //             "q": "4.70443515",  // Quantity
            //             "f": 27781,         // First tradeId
            //             "l": 27781,         // Last tradeId
            //             "T": 1498793709153, // Timestamp
            //             "m": true,          // Was the buyer the maker?
            //             "M": true           // Was the trade the best price match?
            //         }
            //     ]
            //
            // inverse (swap & future)
            //
            //     [
            //      {
            //         "a": "269772814",
            //         "p": "25864.1",
            //         "q": "3",
            //         "f": "662149354",
            //         "l": "662149355",
            //         "T": "1694209776022",
            //         "m": false,
            //      },
            //     ]
            //
            // recent public trades and historical public trades
            //
            //     [
            //         {
            //             "id": 28457,
            //             "price": "4.00000100",
            //             "qty": "12.00000000",
            //             "time": 1499865549590,
            //             "isBuyerMaker": true,
            //             "isBestMatch": true
            //         }
            //     ]
            //
            // options (eapi)
            //
            //     [
            //         {
            //             "id": 1,
            //             "symbol": "ETH-230216-1500-C",
            //             "price": "35.5",
            //             "qty": "0.03",
            //             "quoteQty": "1.065",
            //             "side": 1,
            //             "time": 1676366446072
            //         },
            //     ]
            //
            return this.parseTrades(response, market, since, limit);
        });

    }

    /**
     * @method
     * @name binance#editSpotOrder
     * @ignore
     * @description edit a trade order
     * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#cancel-an-existing-order-and-send-a-new-order-trade
     * @param {string} id cancel order id
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit' or 'STOP_LOSS' or 'STOP_LOSS_LIMIT' or 'TAKE_PROFIT' or 'TAKE_PROFIT_LIMIT' or 'STOP'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of currency you want to trade in units of base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.marginMode] 'cross' or 'isolated', for spot margin trading
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> editSpotOrder(Object id, Object symbol, Object type, Object side, Object amount, Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object price = Helpers.getArg(optionalArgs, 0, null);
            Object parameters = Helpers.getArg(optionalArgs, 1, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object market = this.market(symbol);
            if (!Helpers.isTrue(Helpers.GetValue(market, "spot")))
            {
                throw new NotSupported((String)Helpers.add(Helpers.add(Helpers.add(this.id, " editSpotOrder() does not support "), Helpers.GetValue(market, "type")), " orders")) ;
            }
            Object payload = this.editSpotOrderRequest(id, symbol, type, side, amount, price, parameters);
            Object response = (this.privatePostOrderCancelReplace(payload)).join();
            //
            // spot
            //
            //     {
            //         "cancelResult": "SUCCESS",
            //         "newOrderResult": "SUCCESS",
            //         "cancelResponse": {
            //             "symbol": "BTCUSDT",
            //             "origClientOrderId": "web_3f6286480b194b079870ac75fb6978b7",
            //             "orderId": 16383156620,
            //             "orderListId": -1,
            //             "clientOrderId": "Azt6foVTTgHPNhqBf41TTt",
            //             "price": "14000.00000000",
            //             "origQty": "0.00110000",
            //             "executedQty": "0.00000000",
            //             "cummulativeQuoteQty": "0.00000000",
            //             "status": "CANCELED",
            //             "timeInForce": "GTC",
            //             "type": "LIMIT",
            //             "side": "BUY"
            //         },
            //         "newOrderResponse": {
            //             "symbol": "BTCUSDT",
            //             "orderId": 16383176297,
            //             "orderListId": -1,
            //             "clientOrderId": "x-TKT5PX2F22ecb58eb9074fb1be018c",
            //             "transactTime": 1670891847932,
            //             "price": "13500.00000000",
            //             "origQty": "0.00085000",
            //             "executedQty": "0.00000000",
            //             "cummulativeQuoteQty": "0.00000000",
            //             "status": "NEW",
            //             "timeInForce": "GTC",
            //             "type": "LIMIT",
            //             "side": "BUY",
            //             "fills": []
            //         }
            //     }
            //
            Object data = this.safeDict(response, "newOrderResponse");
            return this.parseOrder(data, market);
        });

    }

    public Object editSpotOrderRequest(Object id, Object symbol, Object type, Object side, Object amount, Object... optionalArgs)
    {
        /**
        * @method
        * @ignore
        * @name binance#editSpotOrderRequest
        * @description helper function to build request for editSpotOrder
        * @param {string} id order id to be edited
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit' or 'STOP_LOSS' or 'STOP_LOSS_LIMIT' or 'TAKE_PROFIT' or 'TAKE_PROFIT_LIMIT' or 'STOP'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
        * @param {object} params extra parameters specific to the exchange API endpoint
        * @param {string} [params.marginMode] 'cross' or 'isolated', for spot margin trading
        * @returns {object} request to be sent to the exchange
        */
        Object price = Helpers.getArg(optionalArgs, 0, null);
        Object parameters = Helpers.getArg(optionalArgs, 1, new java.util.HashMap<String, Object>() {{}});
        Object market = this.market(symbol);
        Object clientOrderId = this.safeStringN(parameters, new java.util.ArrayList<Object>(java.util.Arrays.asList("newClientOrderId", "clientOrderId", "origClientOrderId")));
        Object request = new java.util.HashMap<String, Object>() {{
            put( "symbol", Helpers.GetValue(market, "id") );
            put( "side", ((String)side).toUpperCase() );
        }};
        Object initialUppercaseType = ((String)type).toUpperCase();
        Object uppercaseType = initialUppercaseType;
        Object postOnly = this.isPostOnly(Helpers.isEqual(initialUppercaseType, "MARKET"), Helpers.isEqual(initialUppercaseType, "LIMIT_MAKER"), parameters);
        if (Helpers.isTrue(postOnly))
        {
            uppercaseType = "LIMIT_MAKER";
        }
        Object triggerPrice = this.safeNumber2(parameters, "stopPrice", "triggerPrice");
        if (Helpers.isTrue(!Helpers.isEqual(triggerPrice, null)))
        {
            if (Helpers.isTrue(Helpers.isEqual(uppercaseType, "MARKET")))
            {
                uppercaseType = "STOP_LOSS";
            } else if (Helpers.isTrue(Helpers.isEqual(uppercaseType, "LIMIT")))
            {
                uppercaseType = "STOP_LOSS_LIMIT";
            }
        }
        Helpers.addElementToObject(request, "type", uppercaseType);
        Object validOrderTypes = this.safeList(Helpers.GetValue(market, "info"), "orderTypes");
        if (!Helpers.isTrue(this.inArray(uppercaseType, validOrderTypes)))
        {
            if (Helpers.isTrue(!Helpers.isEqual(initialUppercaseType, uppercaseType)))
            {
                throw new InvalidOrder((String)Helpers.add(Helpers.add(Helpers.add(Helpers.add(Helpers.add(this.id, " triggerPrice parameter is not allowed for "), symbol), " "), type), " orders")) ;
            } else
            {
                throw new InvalidOrder((String)Helpers.add(Helpers.add(Helpers.add(Helpers.add(Helpers.add(this.id, " "), type), " is not a valid order type for the "), symbol), " market")) ;
            }
        }
        if (Helpers.isTrue(Helpers.isEqual(clientOrderId, null)))
        {
            Object broker = this.safeDict(this.options, "broker");
            if (Helpers.isTrue(!Helpers.isEqual(broker, null)))
            {
                Object brokerId = this.safeString(broker, "spot");
                if (Helpers.isTrue(!Helpers.isEqual(brokerId, null)))
                {
                    Helpers.addElementToObject(request, "newClientOrderId", Helpers.add(brokerId, this.uuid22()));
                }
            }
        } else
        {
            Helpers.addElementToObject(request, "newClientOrderId", clientOrderId);
        }
        Helpers.addElementToObject(request, "newOrderRespType", this.safeValue(Helpers.GetValue(this.options, "newOrderRespType"), type, "RESULT")); // 'ACK' for order id, 'RESULT' for full order or 'FULL' for order with fills
        Object timeInForceIsRequired = false;
        Object priceIsRequired = false;
        Object triggerPriceIsRequired = false;
        Object quantityIsRequired = false;
        if (Helpers.isTrue(Helpers.isEqual(uppercaseType, "MARKET")))
        {
            Object quoteOrderQty = this.safeBool(this.options, "quoteOrderQty", true);
            if (Helpers.isTrue(quoteOrderQty))
            {
                Object quoteOrderQtyNew = this.safeValue2(parameters, "quoteOrderQty", "cost");
                Object precision = Helpers.GetValue(Helpers.GetValue(market, "precision"), "price");
                if (Helpers.isTrue(!Helpers.isEqual(quoteOrderQtyNew, null)))
                {
                    Helpers.addElementToObject(request, "quoteOrderQty", this.decimalToPrecision(quoteOrderQtyNew, TRUNCATE, precision, this.precisionMode));
                } else if (Helpers.isTrue(!Helpers.isEqual(price, null)))
                {
                    Object amountString = this.numberToString(amount);
                    Object priceString = this.numberToString(price);
                    Object quoteOrderQuantity = Precise.stringMul(amountString, priceString);
                    Helpers.addElementToObject(request, "quoteOrderQty", this.decimalToPrecision(quoteOrderQuantity, TRUNCATE, precision, this.precisionMode));
                } else
                {
                    quantityIsRequired = true;
                }
            } else
            {
                quantityIsRequired = true;
            }
        } else if (Helpers.isTrue(Helpers.isEqual(uppercaseType, "LIMIT")))
        {
            priceIsRequired = true;
            timeInForceIsRequired = true;
            quantityIsRequired = true;
        } else if (Helpers.isTrue(Helpers.isTrue((Helpers.isEqual(uppercaseType, "STOP_LOSS"))) || Helpers.isTrue((Helpers.isEqual(uppercaseType, "TAKE_PROFIT")))))
        {
            triggerPriceIsRequired = true;
            quantityIsRequired = true;
        } else if (Helpers.isTrue(Helpers.isTrue((Helpers.isEqual(uppercaseType, "STOP_LOSS_LIMIT"))) || Helpers.isTrue((Helpers.isEqual(uppercaseType, "TAKE_PROFIT_LIMIT")))))
        {
            quantityIsRequired = true;
            triggerPriceIsRequired = true;
            priceIsRequired = true;
            timeInForceIsRequired = true;
        } else if (Helpers.isTrue(Helpers.isEqual(uppercaseType, "LIMIT_MAKER")))
        {
            priceIsRequired = true;
            quantityIsRequired = true;
        }
        if (Helpers.isTrue(quantityIsRequired))
        {
            Helpers.addElementToObject(request, "quantity", this.amountToPrecision(symbol, amount));
        }
        if (Helpers.isTrue(priceIsRequired))
        {
            if (Helpers.isTrue(Helpers.isEqual(price, null)))
            {
                throw new InvalidOrder((String)Helpers.add(Helpers.add(Helpers.add(this.id, " editOrder() requires a price argument for a "), type), " order")) ;
            }
            Helpers.addElementToObject(request, "price", this.priceToPrecision(symbol, price));
        }
        if (Helpers.isTrue(Helpers.isTrue(timeInForceIsRequired) && Helpers.isTrue((Helpers.isEqual(this.safeString(parameters, "timeInForce"), null)))))
        {
            Helpers.addElementToObject(request, "timeInForce", Helpers.GetValue(this.options, "defaultTimeInForce")); // 'GTC' = Good To Cancel (default), 'IOC' = Immediate Or Cancel
        }
        if (Helpers.isTrue(triggerPriceIsRequired))
        {
            if (Helpers.isTrue(Helpers.isEqual(triggerPrice, null)))
            {
                throw new InvalidOrder((String)Helpers.add(Helpers.add(Helpers.add(this.id, " editOrder() requires a triggerPrice extra param for a "), type), " order")) ;
            } else
            {
                Helpers.addElementToObject(request, "stopPrice", this.priceToPrecision(symbol, triggerPrice));
            }
        }
        Helpers.addElementToObject(request, "cancelReplaceMode", "STOP_ON_FAILURE"); // If the cancel request fails, the new order placement will not be attempted.
        Object cancelId = this.safeString2(parameters, "cancelNewClientOrderId", "cancelOrigClientOrderId");
        if (Helpers.isTrue(Helpers.isEqual(cancelId, null)))
        {
            Helpers.addElementToObject(request, "cancelOrderId", id); // user can provide either cancelOrderId, cancelOrigClientOrderId or cancelOrigClientOrderId
        }
        // remove timeInForce from params because PO is only used by this.isPostOnly and it's not a valid value for Binance
        if (Helpers.isTrue(Helpers.isEqual(this.safeString(parameters, "timeInForce"), "PO")))
        {
            parameters = this.omit(parameters, new java.util.ArrayList<Object>(java.util.Arrays.asList("timeInForce")));
        }
        parameters = this.omit(parameters, new java.util.ArrayList<Object>(java.util.Arrays.asList("quoteOrderQty", "cost", "stopPrice", "newClientOrderId", "clientOrderId", "postOnly")));
        return this.extend(request, parameters);
    }

    public Object editContractOrderRequest(Object id, Object symbol, Object type, Object side, Object amount, Object... optionalArgs)
    {
        Object price = Helpers.getArg(optionalArgs, 0, null);
        Object parameters = Helpers.getArg(optionalArgs, 1, new java.util.HashMap<String, Object>() {{}});
        Object market = this.market(symbol);
        if (!Helpers.isTrue(Helpers.GetValue(market, "contract")))
        {
            throw new NotSupported((String)Helpers.add(Helpers.add(Helpers.add(this.id, " editContractOrder() does not support "), Helpers.GetValue(market, "type")), " orders")) ;
        }
        Object request = new java.util.HashMap<String, Object>() {{
            put( "symbol", Helpers.GetValue(market, "id") );
            put( "side", ((String)side).toUpperCase() );
            put( "orderId", id );
            put( "quantity", Binance.this.amountToPrecision(symbol, amount) );
        }};
        Object clientOrderId = this.safeStringN(parameters, new java.util.ArrayList<Object>(java.util.Arrays.asList("newClientOrderId", "clientOrderId", "origClientOrderId")));
        if (Helpers.isTrue(!Helpers.isEqual(price, null)))
        {
            Helpers.addElementToObject(request, "price", this.priceToPrecision(symbol, price));
        }
        if (Helpers.isTrue(!Helpers.isEqual(clientOrderId, null)))
        {
            Helpers.addElementToObject(request, "origClientOrderId", clientOrderId);
        }
        parameters = this.omit(parameters, new java.util.ArrayList<Object>(java.util.Arrays.asList("clientOrderId", "newClientOrderId")));
        return request;
    }

    /**
     * @method
     * @name binance#editContractOrder
     * @description edit a trade order
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Modify-Order
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Modify-Order
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Modify-UM-Order
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Modify-CM-Order
     * @param {string} id cancel order id
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of currency you want to trade in units of base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.portfolioMargin] set to true if you would like to edit an order in a portfolio margin account
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> editContractOrder(Object id, Object symbol, Object type, Object side, Object amount, Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object price = Helpers.getArg(optionalArgs, 0, null);
            Object parameters = Helpers.getArg(optionalArgs, 1, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object market = this.market(symbol);
            Object isPortfolioMargin = null;
            var isPortfolioMarginparametersVariable = this.handleOptionAndParams2(parameters, "editContractOrder", "papi", "portfolioMargin", false);
            isPortfolioMargin = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(0);
            parameters = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(1);
            if (Helpers.isTrue(Helpers.isTrue(Helpers.GetValue(market, "linear")) || Helpers.isTrue(isPortfolioMargin)))
            {
                if (Helpers.isTrue(Helpers.isTrue((Helpers.isEqual(price, null))) && !Helpers.isTrue((Helpers.inOp(parameters, "priceMatch")))))
                {
                    throw new ArgumentsRequired((String)Helpers.add(this.id, " editOrder() requires a price argument for portfolio margin and linear orders")) ;
                }
            }
            Object request = this.editContractOrderRequest(id, symbol, type, side, amount, price, parameters);
            Object response = null;
            if (Helpers.isTrue(Helpers.GetValue(market, "linear")))
            {
                if (Helpers.isTrue(isPortfolioMargin))
                {
                    response = (this.papiPutUmOrder(this.extend(request, parameters))).join();
                } else
                {
                    response = (this.fapiPrivatePutOrder(this.extend(request, parameters))).join();
                }
            } else if (Helpers.isTrue(Helpers.GetValue(market, "inverse")))
            {
                if (Helpers.isTrue(isPortfolioMargin))
                {
                    response = (this.papiPutCmOrder(this.extend(request, parameters))).join();
                } else
                {
                    response = (this.dapiPrivatePutOrder(this.extend(request, parameters))).join();
                }
            }
            //
            // swap and future
            //
            //     {
            //         "orderId": 151007482392,
            //         "symbol": "BTCUSDT",
            //         "status": "NEW",
            //         "clientOrderId": "web_pCCGp9AIHjziKLlpGpXI",
            //         "price": "25000",
            //         "avgPrice": "0.00000",
            //         "origQty": "0.001",
            //         "executedQty": "0",
            //         "cumQty": "0",
            //         "cumQuote": "0",
            //         "timeInForce": "GTC",
            //         "type": "LIMIT",
            //         "reduceOnly": false,
            //         "closePosition": false,
            //         "side": "BUY",
            //         "positionSide": "BOTH",
            //         "stopPrice": "0",
            //         "workingType": "CONTRACT_PRICE",
            //         "priceProtect": false,
            //         "origType": "LIMIT",
            //         "updateTime": 1684300587845
            //     }
            //
            return this.parseOrder(response, market);
        });

    }

    /**
     * @method
     * @name binance#editOrder
     * @description edit a trade order
     * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#cancel-an-existing-order-and-send-a-new-order-trade
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Modify-Order
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Modify-Order
     * @param {string} id cancel order id
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of currency you want to trade in units of base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> editOrder(Object id, Object symbol, Object type, Object side, Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object amount = Helpers.getArg(optionalArgs, 0, null);
            Object price = Helpers.getArg(optionalArgs, 1, null);
            Object parameters = Helpers.getArg(optionalArgs, 2, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object market = this.market(symbol);
            if (Helpers.isTrue(Helpers.GetValue(market, "option")))
            {
                throw new NotSupported((String)Helpers.add(Helpers.add(Helpers.add(this.id, " editOrder() does not support "), Helpers.GetValue(market, "type")), " orders")) ;
            }
            if (Helpers.isTrue(Helpers.GetValue(market, "spot")))
            {
                return (this.editSpotOrder(id, symbol, type, side, amount, price, parameters)).join();
            } else
            {
                return (this.editContractOrder(id, symbol, type, side, amount, price, parameters)).join();
            }
        });

    }

    /**
     * @method
     * @name binance#editOrders
     * @description edit a list of trade orders
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Modify-Multiple-Orders
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Modify-Multiple-Orders
     * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> editOrders(Object orders, Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object parameters = Helpers.getArg(optionalArgs, 0, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object ordersRequests = new java.util.ArrayList<Object>(java.util.Arrays.asList());
            Object orderSymbols = new java.util.ArrayList<Object>(java.util.Arrays.asList());
            for (var i = 0; Helpers.isLessThan(i, Helpers.getArrayLength(orders)); i++)
            {
                Object rawOrder = Helpers.GetValue(orders, i);
                Object marketId = this.safeString(rawOrder, "symbol");
                ((java.util.List<Object>)orderSymbols).add(marketId);
                Object id = this.safeString(rawOrder, "id");
                Object type = this.safeString(rawOrder, "type");
                Object side = this.safeString(rawOrder, "side");
                Object amount = this.safeValue(rawOrder, "amount");
                Object price = this.safeValue(rawOrder, "price");
                Object orderParams = this.safeDict(rawOrder, "params", new java.util.HashMap<String, Object>() {{}});
                Object isPortfolioMargin = null;
                var isPortfolioMarginorderParamsVariable = this.handleOptionAndParams2(orderParams, "editOrders", "papi", "portfolioMargin", false);
                isPortfolioMargin = ((java.util.List<Object>) isPortfolioMarginorderParamsVariable).get(0);
                orderParams = ((java.util.List<Object>) isPortfolioMarginorderParamsVariable).get(1);
                if (Helpers.isTrue(isPortfolioMargin))
                {
                    throw new NotSupported((String)Helpers.add(this.id, " editOrders() does not support portfolio margin orders")) ;
                }
                Object orderRequest = this.editContractOrderRequest(id, marketId, type, side, amount, price, orderParams);
                ((java.util.List<Object>)ordersRequests).add(orderRequest);
            }
            orderSymbols = this.marketSymbols(orderSymbols, null, false, true, true);
            Object market = this.market(Helpers.GetValue(orderSymbols, 0));
            if (Helpers.isTrue(Helpers.isTrue(Helpers.GetValue(market, "spot")) || Helpers.isTrue(Helpers.GetValue(market, "option"))))
            {
                throw new NotSupported((String)Helpers.add(Helpers.add(Helpers.add(this.id, " editOrders() does not support "), Helpers.GetValue(market, "type")), " orders")) ;
            }
            Object response = null;
            Object request = new java.util.HashMap<String, Object>() {{
                put( "batchOrders", ordersRequests );
            }};
            request = this.extend(request, parameters);
            if (Helpers.isTrue(Helpers.GetValue(market, "linear")))
            {
                response = (this.fapiPrivatePutBatchOrders(request)).join();
            } else if (Helpers.isTrue(Helpers.GetValue(market, "inverse")))
            {
                response = (this.dapiPrivatePutBatchOrders(request)).join();
            }
            //
            //   [
            //       {
            //          "code": -4005,
            //          "msg": "Quantity greater than max quantity."
            //       },
            //       {
            //          "orderId": 650640530,
            //          "symbol": "LTCUSDT",
            //          "status": "NEW",
            //          "clientOrderId": "x-xcKtGhcu32184eb13585491289bbaf",
            //          "price": "54.00",
            //          "avgPrice": "0.00",
            //          "origQty": "0.100",
            //          "executedQty": "0.000",
            //          "cumQty": "0.000",
            //          "cumQuote": "0.00000",
            //          "timeInForce": "GTC",
            //          "type": "LIMIT",
            //          "reduceOnly": false,
            //          "closePosition": false,
            //          "side": "BUY",
            //          "positionSide": "BOTH",
            //          "stopPrice": "0.00",
            //          "workingType": "CONTRACT_PRICE",
            //          "priceProtect": false,
            //          "origType": "LIMIT",
            //          "priceMatch": "NONE",
            //          "selfTradePreventionMode": "NONE",
            //          "goodTillDate": 0,
            //          "updateTime": 1698073926929
            //       }
            //   ]
            //
            return this.parseOrders(response);
        });

    }

    public Object parseOrderStatus(Object status)
    {
        Object statuses = new java.util.HashMap<String, Object>() {{
            put( "NEW", "open" );
            put( "PARTIALLY_FILLED", "open" );
            put( "ACCEPTED", "open" );
            put( "FILLED", "closed" );
            put( "CANCELED", "canceled" );
            put( "CANCELLED", "canceled" );
            put( "PENDING_CANCEL", "canceling" );
            put( "REJECTED", "rejected" );
            put( "EXPIRED", "expired" );
            put( "EXPIRED_IN_MATCH", "expired" );
        }};
        return this.safeString(statuses, status, status);
    }

    public Object parseOrder(Object order, Object... optionalArgs)
    {
        //
        // spot
        //
        //     {
        //         "symbol": "LTCBTC",
        //         "orderId": 1,
        //         "clientOrderId": "myOrder1",
        //         "price": "0.1",
        //         "origQty": "1.0",
        //         "executedQty": "0.0",
        //         "cummulativeQuoteQty": "0.0",
        //         "status": "NEW",
        //         "timeInForce": "GTC",
        //         "type": "LIMIT",
        //         "side": "BUY",
        //         "stopPrice": "0.0",
        //         "icebergQty": "0.0",
        //         "time": 1499827319559,
        //         "updateTime": 1499827319559,
        //         "isWorking": true
        //     }
        //
        // spot: editOrder
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "orderId": 16383176297,
        //         "orderListId": -1,
        //         "clientOrderId": "x-TKT5PX2F22ecb58eb9074fb1be018c",
        //         "transactTime": 1670891847932,
        //         "price": "13500.00000000",
        //         "origQty": "0.00085000",
        //         "executedQty": "0.00000000",
        //         "cummulativeQuoteQty": "0.00000000",
        //         "status": "NEW",
        //         "timeInForce": "GTC",
        //         "type": "LIMIT",
        //         "side": "BUY",
        //         "fills": []
        //     }
        //
        // swap and future: editOrder
        //
        //     {
        //         "orderId": 151007482392,
        //         "symbol": "BTCUSDT",
        //         "status": "NEW",
        //         "clientOrderId": "web_pCCGp9AIHjziKLlpGpXI",
        //         "price": "25000",
        //         "avgPrice": "0.00000",
        //         "origQty": "0.001",
        //         "executedQty": "0",
        //         "cumQty": "0",
        //         "cumQuote": "0",
        //         "timeInForce": "GTC",
        //         "type": "LIMIT",
        //         "reduceOnly": false,
        //         "closePosition": false,
        //         "side": "BUY",
        //         "positionSide": "BOTH",
        //         "stopPrice": "0",
        //         "workingType": "CONTRACT_PRICE",
        //         "priceProtect": false,
        //         "origType": "LIMIT",
        //         "updateTime": 1684300587845
        //     }
        //
        // futures
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "orderId": 1,
        //         "clientOrderId": "myOrder1",
        //         "price": "0.1",
        //         "origQty": "1.0",
        //         "executedQty": "1.0",
        //         "cumQuote": "10.0",
        //         "status": "NEW",
        //         "timeInForce": "GTC",
        //         "type": "LIMIT",
        //         "side": "BUY",
        //         "stopPrice": "0.0",
        //         "updateTime": 1499827319559
        //     }
        //
        // createOrder with { "newOrderRespType": "FULL" }
        //
        //     {
        //       "symbol": "BTCUSDT",
        //       "orderId": 5403233939,
        //       "orderListId": -1,
        //       "clientOrderId": "x-TKT5PX2F5e669e75b6c14f69a2c43e",
        //       "transactTime": 1617151923742,
        //       "price": "0.00000000",
        //       "origQty": "0.00050000",
        //       "executedQty": "0.00050000",
        //       "cummulativeQuoteQty": "29.47081500",
        //       "status": "FILLED",
        //       "timeInForce": "GTC",
        //       "type": "MARKET",
        //       "side": "BUY",
        //       "fills": [
        //         {
        //           "price": "58941.63000000",
        //           "qty": "0.00050000",
        //           "commission": "0.00007050",
        //           "commissionAsset": "BNB",
        //           "tradeId": 737466631
        //         }
        //       ]
        //     }
        //
        // delivery
        //
        //     {
        //       "orderId": "18742727411",
        //       "symbol": "ETHUSD_PERP",
        //       "pair": "ETHUSD",
        //       "status": "FILLED",
        //       "clientOrderId": "x-xcKtGhcu3e2d1503fdd543b3b02419",
        //       "price": "0",
        //       "avgPrice": "4522.14",
        //       "origQty": "1",
        //       "executedQty": "1",
        //       "cumBase": "0.00221134",
        //       "timeInForce": "GTC",
        //       "type": "MARKET",
        //       "reduceOnly": false,
        //       "closePosition": false,
        //       "side": "SELL",
        //       "positionSide": "BOTH",
        //       "stopPrice": "0",
        //       "workingType": "CONTRACT_PRICE",
        //       "priceProtect": false,
        //       "origType": "MARKET",
        //       "time": "1636061952660",
        //       "updateTime": "1636061952660"
        //     }
        //
        // option: createOrder, fetchOrder, fetchOpenOrders, fetchOrders
        //
        //     {
        //         "orderId": 4728833085436977152,
        //         "symbol": "ETH-230211-1500-C",
        //         "price": "10.0",
        //         "quantity": "1.00",
        //         "executedQty": "0.00",
        //         "fee": "0",
        //         "side": "BUY",
        //         "type": "LIMIT",
        //         "timeInForce": "GTC",
        //         "reduceOnly": false,
        //         "postOnly": false,
        //         "createTime": 1676083034462,
        //         "updateTime": 1676083034462,
        //         "status": "ACCEPTED",
        //         "avgPrice": "0",
        //         "source": "API",
        //         "clientOrderId": "",
        //         "priceScale": 1,
        //         "quantityScale": 2,
        //         "optionSide": "CALL",
        //         "quoteAsset": "USDT",
        //         "lastTrade": {"id":"69","time":"1676084430567","price":"24.9","qty":"1.00"},
        //         "mmp": false
        //     }
        //
        // cancelOrders/createOrders
        //
        //     {
        //         "code": -4005,
        //         "msg": "Quantity greater than max quantity."
        //     }
        //
        // createOrder, fetchOpenOrders, fetchOrder, cancelOrder, fetchOrders: portfolio margin linear swap and future
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "side": "BUY",
        //         "executedQty": "0.000",
        //         "orderId": 258649539704,
        //         "goodTillDate": 0,
        //         "avgPrice": "0",
        //         "origQty": "0.010",
        //         "clientOrderId": "x-xcKtGhcu02573c6f15e544e990057b",
        //         "positionSide": "BOTH",
        //         "cumQty": "0.000",
        //         "updateTime": 1707110415436,
        //         "type": "LIMIT",
        //         "reduceOnly": false,
        //         "price": "35000.00",
        //         "cumQuote": "0.00000",
        //         "selfTradePreventionMode": "NONE",
        //         "timeInForce": "GTC",
        //         "status": "NEW"
        //     }
        //
        // createOrder, fetchOpenOrders, fetchOrder, cancelOrder, fetchOrders: portfolio margin inverse swap and future
        //
        //     {
        //         "symbol": "ETHUSD_PERP",
        //         "side": "BUY",
        //         "cumBase": "0",
        //         "executedQty": "0",
        //         "orderId": 71275227732,
        //         "avgPrice": "0.00",
        //         "origQty": "1",
        //         "clientOrderId": "x-xcKtGhcuca5af3acfb5044198c5398",
        //         "positionSide": "BOTH",
        //         "cumQty": "0",
        //         "updateTime": 1707110994334,
        //         "type": "LIMIT",
        //         "pair": "ETHUSD",
        //         "reduceOnly": false,
        //         "price": "2000",
        //         "timeInForce": "GTC",
        //         "status": "NEW"
        //     }
        //
        // createOrder, fetchOpenOrders, fetchOpenOrder: portfolio margin linear swap and future conditional
        //
        //     {
        //         "newClientStrategyId": "x-xcKtGhcu27f109953d6e4dc0974006",
        //         "strategyId": 3645916,
        //         "strategyStatus": "NEW",
        //         "strategyType": "STOP",
        //         "origQty": "0.010",
        //         "price": "35000.00",
        //         "reduceOnly": false,
        //         "side": "BUY",
        //         "positionSide": "BOTH",
        //         "stopPrice": "45000.00",
        //         "symbol": "BTCUSDT",
        //         "timeInForce": "GTC",
        //         "bookTime": 1707112625879,
        //         "updateTime": 1707112625879,
        //         "workingType": "CONTRACT_PRICE",
        //         "priceProtect": false,
        //         "goodTillDate": 0,
        //         "selfTradePreventionMode": "NONE"
        //     }
        //
        // createOrder, fetchOpenOrders: portfolio margin inverse swap and future conditional
        //
        //     {
        //         "newClientStrategyId": "x-xcKtGhcuc6b86f053bb34933850739",
        //         "strategyId": 1423462,
        //         "strategyStatus": "NEW",
        //         "strategyType": "STOP",
        //         "origQty": "1",
        //         "price": "2000",
        //         "reduceOnly": false,
        //         "side": "BUY",
        //         "positionSide": "BOTH",
        //         "stopPrice": "3000",
        //         "symbol": "ETHUSD_PERP",
        //         "timeInForce": "GTC",
        //         "bookTime": 1707113098840,
        //         "updateTime": 1707113098840,
        //         "workingType": "CONTRACT_PRICE",
        //         "priceProtect": false
        //     }
        //
        // createOrder, cancelAllOrders, cancelOrder: portfolio margin spot margin
        //
        //     {
        //         "clientOrderId": "x-TKT5PX2Fe9ef29d8346440f0b28b86",
        //         "cummulativeQuoteQty": "0.00000000",
        //         "executedQty": "0.00000000",
        //         "fills": [],
        //         "orderId": 24684460474,
        //         "origQty": "0.00100000",
        //         "price": "35000.00000000",
        //         "selfTradePreventionMode": "EXPIRE_MAKER",
        //         "side": "BUY",
        //         "status": "NEW",
        //         "symbol": "BTCUSDT",
        //         "timeInForce": "GTC",
        //         "transactTime": 1707113538870,
        //         "type": "LIMIT"
        //     }
        //
        // fetchOpenOrders, fetchOrder, fetchOrders: portfolio margin spot margin
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "orderId": 24700763749,
        //         "clientOrderId": "x-TKT5PX2F6f724c2a4af6425f98c7b6",
        //         "price": "35000.00000000",
        //         "origQty": "0.00100000",
        //         "executedQty": "0.00000000",
        //         "cummulativeQuoteQty": "0.00000000",
        //         "status": "NEW",
        //         "timeInForce": "GTC",
        //         "type": "LIMIT",
        //         "side": "BUY",
        //         "stopPrice": "0.00000000",
        //         "icebergQty": "0.00000000",
        //         "time": 1707199187679,
        //         "updateTime": 1707199187679,
        //         "isWorking": true,
        //         "accountId": 200180970,
        //         "selfTradePreventionMode": "EXPIRE_MAKER",
        //         "preventedMatchId": null,
        //         "preventedQuantity": null
        //     }
        //
        // cancelOrder: portfolio margin linear and inverse swap conditional
        //
        //     {
        //         "strategyId": 3733211,
        //         "newClientStrategyId": "x-xcKtGhcuaf166172ed504cd1bc0396",
        //         "strategyType": "STOP",
        //         "strategyStatus": "CANCELED",
        //         "origQty": "0.010",
        //         "price": "35000.00",
        //         "reduceOnly": false,
        //         "side": "BUY",
        //         "positionSide": "BOTH",
        //         "stopPrice": "50000.00", // ignored with trailing orders
        //         "symbol": "BTCUSDT",
        //         "timeInForce": "GTC",
        //         "activatePrice": null,  // only return with trailing orders
        //         "priceRate": null,      // only return with trailing orders
        //         "bookTime": 1707270098774,
        //         "updateTime": 1707270119261,
        //         "workingType": "CONTRACT_PRICE",
        //         "priceProtect": false,
        //         "goodTillDate": 0,
        //         "selfTradePreventionMode": "NONE"
        //     }
        //
        // fetchOrders: portfolio margin linear and inverse swap conditional
        //
        //     {
        //         "newClientStrategyId": "x-xcKtGhcuaf166172ed504cd1bc0396",
        //         "strategyId": 3733211,
        //         "strategyStatus": "CANCELLED",
        //         "strategyType": "STOP",
        //         "origQty": "0.010",
        //         "price": "35000",
        //         "orderId": 0,
        //         "reduceOnly": false,
        //         "side": "BUY",
        //         "positionSide": "BOTH",
        //         "stopPrice": "50000",
        //         "symbol": "BTCUSDT",
        //         "type": "LIMIT",
        //         "bookTime": 1707270098774,
        //         "updateTime": 1707270119261,
        //         "timeInForce": "GTC",
        //         "triggerTime": 0,
        //         "workingType": "CONTRACT_PRICE",
        //         "priceProtect": false,
        //         "goodTillDate": 0,
        //         "selfTradePreventionMode": "NONE"
        //     }
        //
        // fetchOpenOrder: linear swap
        //
        //     {
        //         "orderId": 3697213934,
        //         "symbol": "BTCUSDT",
        //         "status": "NEW",
        //         "clientOrderId": "x-xcKtGhcufb20c5a7761a4aa09aa156",
        //         "price": "33000.00",
        //         "avgPrice": "0.00000",
        //         "origQty": "0.010",
        //         "executedQty": "0.000",
        //         "cumQuote": "0.00000",
        //         "timeInForce": "GTC",
        //         "type": "LIMIT",
        //         "reduceOnly": false,
        //         "closePosition": false,
        //         "side": "BUY",
        //         "positionSide": "BOTH",
        //         "stopPrice": "0.00",
        //         "workingType": "CONTRACT_PRICE",
        //         "priceProtect": false,
        //         "origType": "LIMIT",
        //         "priceMatch": "NONE",
        //         "selfTradePreventionMode": "NONE",
        //         "goodTillDate": 0,
        //         "time": 1707892893502,
        //         "updateTime": 1707892893515
        //     }
        //
        // fetchOpenOrder: inverse swap
        //
        //     {
        //         "orderId": 597368542,
        //         "symbol": "BTCUSD_PERP",
        //         "pair": "BTCUSD",
        //         "status": "NEW",
        //         "clientOrderId": "x-xcKtGhcubbde7ba93b1a4ab881eff3",
        //         "price": "35000",
        //         "avgPrice": "0",
        //         "origQty": "1",
        //         "executedQty": "0",
        //         "cumBase": "0",
        //         "timeInForce": "GTC",
        //         "type": "LIMIT",
        //         "reduceOnly": false,
        //         "closePosition": false,
        //         "side": "BUY",
        //         "positionSide": "BOTH",
        //         "stopPrice": "0",
        //         "workingType": "CONTRACT_PRICE",
        //         "priceProtect": false,
        //         "origType": "LIMIT",
        //         "time": 1707893453199,
        //         "updateTime": 1707893453199
        //     }
        //
        // fetchOpenOrder: linear portfolio margin
        //
        //     {
        //         "orderId": 264895013409,
        //         "symbol": "BTCUSDT",
        //         "status": "NEW",
        //         "clientOrderId": "x-xcKtGhcu6278f1adbdf14f74ab432e",
        //         "price": "35000",
        //         "avgPrice": "0",
        //         "origQty": "0.010",
        //         "executedQty": "0",
        //         "cumQuote": "0",
        //         "timeInForce": "GTC",
        //         "type": "LIMIT",
        //         "reduceOnly": false,
        //         "side": "BUY",
        //         "positionSide": "LONG",
        //         "origType": "LIMIT",
        //         "time": 1707893839364,
        //         "updateTime": 1707893839364,
        //         "goodTillDate": 0,
        //         "selfTradePreventionMode": "NONE"
        //     }
        //
        // fetchOpenOrder: inverse portfolio margin
        //
        //     {
        //         "orderId": 71790316950,
        //         "symbol": "ETHUSD_PERP",
        //         "pair": "ETHUSD",
        //         "status": "NEW",
        //         "clientOrderId": "x-xcKtGhcuec11030474204ab08ba2c2",
        //         "price": "2500",
        //         "avgPrice": "0",
        //         "origQty": "1",
        //         "executedQty": "0",
        //         "cumBase": "0",
        //         "timeInForce": "GTC",
        //         "type": "LIMIT",
        //         "reduceOnly": false,
        //         "side": "BUY",
        //         "positionSide": "LONG",
        //         "origType": "LIMIT",
        //         "time": 1707894181694,
        //         "updateTime": 1707894181694
        //     }
        //
        // fetchOpenOrder: inverse portfolio margin conditional
        //
        //     {
        //         "newClientStrategyId": "x-xcKtGhcu2da9c765294b433994ffce",
        //         "strategyId": 1423501,
        //         "strategyStatus": "NEW",
        //         "strategyType": "STOP",
        //         "origQty": "1",
        //         "price": "2500",
        //         "reduceOnly": false,
        //         "side": "BUY",
        //         "positionSide": "LONG",
        //         "stopPrice": "4000",
        //         "symbol": "ETHUSD_PERP",
        //         "bookTime": 1707894782679,
        //         "updateTime": 1707894782679,
        //         "timeInForce": "GTC",
        //         "workingType": "CONTRACT_PRICE",
        //         "priceProtect": false
        //     }
        //
        Object market = Helpers.getArg(optionalArgs, 0, null);
        Object code = this.safeString(order, "code");
        if (Helpers.isTrue(!Helpers.isEqual(code, null)))
        {
            // cancelOrders/createOrders might have a partial success
            return this.safeOrder(new java.util.HashMap<String, Object>() {{
                put( "info", order );
                put( "status", "rejected" );
            }}, market);
        }
        Object status = this.parseOrderStatus(this.safeString2(order, "status", "strategyStatus"));
        Object marketId = this.safeString(order, "symbol");
        Object isContract = Helpers.isTrue((Helpers.inOp(order, "positionSide"))) || Helpers.isTrue((Helpers.inOp(order, "cumQuote")));
        Object marketType = ((Helpers.isTrue(isContract))) ? "contract" : "spot";
        Object symbol = this.safeSymbol(marketId, market, null, marketType);
        Object filled = this.safeString(order, "executedQty", "0");
        Object timestamp = this.safeIntegerN(order, new java.util.ArrayList<Object>(java.util.Arrays.asList("time", "createTime", "workingTime", "transactTime", "updateTime"))); // order of the keys matters here
        Object lastTradeTimestamp = null;
        if (Helpers.isTrue(Helpers.isTrue((Helpers.inOp(order, "transactTime"))) || Helpers.isTrue((Helpers.inOp(order, "updateTime")))))
        {
            Object timestampValue = this.safeInteger2(order, "updateTime", "transactTime");
            if (Helpers.isTrue(Helpers.isEqual(status, "open")))
            {
                if (Helpers.isTrue(Precise.stringGt(filled, "0")))
                {
                    lastTradeTimestamp = timestampValue;
                }
            } else if (Helpers.isTrue(Helpers.isEqual(status, "closed")))
            {
                lastTradeTimestamp = timestampValue;
            }
        }
        Object lastUpdateTimestamp = this.safeInteger2(order, "transactTime", "updateTime");
        Object average = this.safeString(order, "avgPrice");
        Object price = this.safeString(order, "price");
        Object amount = this.safeString2(order, "origQty", "quantity");
        // - Spot/Margin market: cummulativeQuoteQty
        // - Futures market: cumQuote.
        //   Note this is not the actual cost, since Binance futures uses leverage to calculate margins.
        Object cost = this.safeString2(order, "cummulativeQuoteQty", "cumQuote");
        cost = this.safeString(order, "cumBase", cost);
        Object type = this.safeStringLower(order, "type");
        Object side = this.safeStringLower(order, "side");
        Object fills = this.safeList(order, "fills", new java.util.ArrayList<Object>(java.util.Arrays.asList()));
        Object timeInForce = this.safeString(order, "timeInForce");
        if (Helpers.isTrue(Helpers.isEqual(timeInForce, "GTX")))
        {
            // GTX means "Good Till Crossing" and is an equivalent way of saying Post Only
            timeInForce = "PO";
        }
        Object postOnly = Helpers.isTrue((Helpers.isEqual(type, "limit_maker"))) || Helpers.isTrue((Helpers.isEqual(timeInForce, "PO")));
        if (Helpers.isTrue(Helpers.isEqual(type, "limit_maker")))
        {
            type = "limit";
        }
        Object stopPriceString = this.safeString(order, "stopPrice");
        Object triggerPrice = this.parseNumber(this.omitZero(stopPriceString));
        Object feeCost = this.safeNumber(order, "fee");
        Object fee = null;
        if (Helpers.isTrue(!Helpers.isEqual(feeCost, null)))
        {
            final Object finalFeeCost = feeCost;
            fee = new java.util.HashMap<String, Object>() {{
                put( "currency", Binance.this.safeString(order, "quoteAsset") );
                put( "cost", finalFeeCost );
                put( "rate", null );
            }};
        }
        final Object finalLastTradeTimestamp = lastTradeTimestamp;
        final Object finalType = type;
        final Object finalTimeInForce = timeInForce;
        final Object finalCost = cost;
        final Object finalStatus = status;
        final Object finalFee = fee;
        return this.safeOrder(new java.util.HashMap<String, Object>() {{
            put( "info", order );
            put( "id", Binance.this.safeString2(order, "strategyId", "orderId") );
            put( "clientOrderId", Binance.this.safeString2(order, "clientOrderId", "newClientStrategyId") );
            put( "timestamp", timestamp );
            put( "datetime", Binance.this.iso8601(timestamp) );
            put( "lastTradeTimestamp", finalLastTradeTimestamp );
            put( "lastUpdateTimestamp", lastUpdateTimestamp );
            put( "symbol", symbol );
            put( "type", finalType );
            put( "timeInForce", finalTimeInForce );
            put( "postOnly", postOnly );
            put( "reduceOnly", Binance.this.safeBool(order, "reduceOnly") );
            put( "side", side );
            put( "price", price );
            put( "triggerPrice", triggerPrice );
            put( "amount", amount );
            put( "cost", finalCost );
            put( "average", average );
            put( "filled", filled );
            put( "remaining", null );
            put( "status", finalStatus );
            put( "fee", finalFee );
            put( "trades", fills );
        }}, market);
    }

    /**
     * @method
     * @name binance#createOrders
     * @description *contract only* create a list of trade orders
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Place-Multiple-Orders
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Place-Multiple-Orders
     * @see https://developers.binance.com/docs/derivatives/option/trade/Place-Multiple-Orders
     * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> createOrders(Object orders, Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object parameters = Helpers.getArg(optionalArgs, 0, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object ordersRequests = new java.util.ArrayList<Object>(java.util.Arrays.asList());
            Object orderSymbols = new java.util.ArrayList<Object>(java.util.Arrays.asList());
            for (var i = 0; Helpers.isLessThan(i, Helpers.getArrayLength(orders)); i++)
            {
                Object rawOrder = Helpers.GetValue(orders, i);
                Object marketId = this.safeString(rawOrder, "symbol");
                ((java.util.List<Object>)orderSymbols).add(marketId);
                Object type = this.safeString(rawOrder, "type");
                Object side = this.safeString(rawOrder, "side");
                Object amount = this.safeValue(rawOrder, "amount");
                Object price = this.safeValue(rawOrder, "price");
                Object orderParams = this.safeDict(rawOrder, "params", new java.util.HashMap<String, Object>() {{}});
                Object orderRequest = this.createOrderRequest(marketId, type, side, amount, price, orderParams);
                ((java.util.List<Object>)ordersRequests).add(orderRequest);
            }
            orderSymbols = this.marketSymbols(orderSymbols, null, false, true, true);
            Object market = this.market(Helpers.GetValue(orderSymbols, 0));
            if (Helpers.isTrue(Helpers.GetValue(market, "spot")))
            {
                throw new NotSupported((String)Helpers.add(Helpers.add(Helpers.add(this.id, " createOrders() does not support "), Helpers.GetValue(market, "type")), " orders")) ;
            }
            Object response = null;
            Object request = new java.util.HashMap<String, Object>() {{
                put( "batchOrders", ordersRequests );
            }};
            request = this.extend(request, parameters);
            if (Helpers.isTrue(Helpers.GetValue(market, "linear")))
            {
                response = (this.fapiPrivatePostBatchOrders(request)).join();
            } else if (Helpers.isTrue(Helpers.GetValue(market, "option")))
            {
                response = (this.eapiPrivatePostBatchOrders(request)).join();
            } else
            {
                response = (this.dapiPrivatePostBatchOrders(request)).join();
            }
            //
            //   [
            //       {
            //          "code": -4005,
            //          "msg": "Quantity greater than max quantity."
            //       },
            //       {
            //          "orderId": 650640530,
            //          "symbol": "LTCUSDT",
            //          "status": "NEW",
            //          "clientOrderId": "x-xcKtGhcu32184eb13585491289bbaf",
            //          "price": "54.00",
            //          "avgPrice": "0.00",
            //          "origQty": "0.100",
            //          "executedQty": "0.000",
            //          "cumQty": "0.000",
            //          "cumQuote": "0.00000",
            //          "timeInForce": "GTC",
            //          "type": "LIMIT",
            //          "reduceOnly": false,
            //          "closePosition": false,
            //          "side": "BUY",
            //          "positionSide": "BOTH",
            //          "stopPrice": "0.00",
            //          "workingType": "CONTRACT_PRICE",
            //          "priceProtect": false,
            //          "origType": "LIMIT",
            //          "priceMatch": "NONE",
            //          "selfTradePreventionMode": "NONE",
            //          "goodTillDate": 0,
            //          "updateTime": 1698073926929
            //       }
            //   ]
            //
            return this.parseOrders(response);
        });

    }

    /**
     * @method
     * @name binance#createOrder
     * @description create a trade order
     * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-order-trade
     * @see https://developers.binance.com/docs/binance-spot-api-docs/testnet/rest-api/trading-endpoints#test-new-order-trade
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/New-Order
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api
     * @see https://developers.binance.com/docs/derivatives/option/trade/New-Order
     * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#sor
     * @see https://developers.binance.com/docs/binance-spot-api-docs/testnet/rest-api/trading-endpoints#sor
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/New-UM-Order
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/New-CM-Order
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/New-Margin-Order
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/New-UM-Conditional-Order
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/New-CM-Conditional-Order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit' or 'STOP_LOSS' or 'STOP_LOSS_LIMIT' or 'TAKE_PROFIT' or 'TAKE_PROFIT_LIMIT' or 'STOP'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of you want to trade in units of the base currency
     * @param {float} [price] the price that the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.reduceOnly] for swap and future reduceOnly is a string 'true' or 'false' that cant be sent with close position set to true or in hedge mode. For spot margin and option reduceOnly is a boolean.
     * @param {string} [params.marginMode] 'cross' or 'isolated', for spot margin trading
     * @param {boolean} [params.sor] *spot only* whether to use SOR (Smart Order Routing) or not, default is false
     * @param {boolean} [params.test] *spot only* whether to use the test endpoint or not, default is false
     * @param {float} [params.trailingPercent] the percent to trail away from the current market price
     * @param {float} [params.trailingTriggerPrice] the price to trigger a trailing order, default uses the price argument
     * @param {float} [params.triggerPrice] the price that a trigger order is triggered at
     * @param {float} [params.stopLossPrice] the price that a stop loss order is triggered at
     * @param {float} [params.takeProfitPrice] the price that a take profit order is triggered at
     * @param {boolean} [params.portfolioMargin] set to true if you would like to create an order in a portfolio margin account
     * @param {string} [params.selfTradePrevention] set unified value for stp, one of NONE, EXPIRE_MAKER, EXPIRE_TAKER or EXPIRE_BOTH
     * @param {float} [params.icebergAmount] set iceberg amount for limit orders
     * @param {string} [params.stopLossOrTakeProfit] 'stopLoss' or 'takeProfit', required for spot trailing orders
     * @param {string} [params.positionSide] *swap and portfolio margin only* "BOTH" for one-way mode, "LONG" for buy side of hedged mode, "SHORT" for sell side of hedged mode
     * @param {bool} [params.hedged] *swap and portfolio margin only* true for hedged mode, false for one way mode, default is false
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> createOrder(Object symbol, Object type, Object side, Object amount, Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object price = Helpers.getArg(optionalArgs, 0, null);
            Object parameters = Helpers.getArg(optionalArgs, 1, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object market = this.market(symbol);
            // don't handle/omit params here, omitting happens inside createOrderRequest
            Object marketType = this.safeString(parameters, "type", Helpers.GetValue(market, "type"));
            Object marginMode = this.safeString(parameters, "marginMode");
            Object porfolioOptionsValue = this.safeBool2(this.options, "papi", "portfolioMargin", false);
            Object isPortfolioMargin = this.safeBool2(parameters, "papi", "portfolioMargin", porfolioOptionsValue);
            Object triggerPrice = this.safeString2(parameters, "triggerPrice", "stopPrice");
            Object stopLossPrice = this.safeString(parameters, "stopLossPrice");
            Object takeProfitPrice = this.safeString(parameters, "takeProfitPrice");
            Object trailingPercent = this.safeString2(parameters, "trailingPercent", "callbackRate");
            Object isTrailingPercentOrder = !Helpers.isEqual(trailingPercent, null);
            Object isStopLoss = !Helpers.isEqual(stopLossPrice, null);
            Object isTakeProfit = !Helpers.isEqual(takeProfitPrice, null);
            Object isConditional = Helpers.isTrue(Helpers.isTrue(Helpers.isTrue((!Helpers.isEqual(triggerPrice, null))) || Helpers.isTrue(isTrailingPercentOrder)) || Helpers.isTrue(isStopLoss)) || Helpers.isTrue(isTakeProfit);
            Object sor = this.safeBool2(parameters, "sor", "SOR", false);
            Object test = this.safeBool(parameters, "test", false);
            parameters = this.omit(parameters, new java.util.ArrayList<Object>(java.util.Arrays.asList("sor", "SOR", "test")));
            // if (isPortfolioMargin) {
            //     params['portfolioMargin'] = isPortfolioMargin;
            // }
            Object request = this.createOrderRequest(symbol, type, side, amount, price, parameters);
            Object response = null;
            if (Helpers.isTrue(Helpers.GetValue(market, "option")))
            {
                response = (this.eapiPrivatePostOrder(request)).join();
            } else if (Helpers.isTrue(sor))
            {
                if (Helpers.isTrue(test))
                {
                    response = (this.privatePostSorOrderTest(request)).join();
                } else
                {
                    response = (this.privatePostSorOrder(request)).join();
                }
            } else if (Helpers.isTrue(Helpers.GetValue(market, "linear")))
            {
                if (Helpers.isTrue(isPortfolioMargin))
                {
                    if (Helpers.isTrue(isConditional))
                    {
                        response = (this.papiPostUmConditionalOrder(request)).join();
                    } else
                    {
                        response = (this.papiPostUmOrder(request)).join();
                    }
                } else
                {
                    response = (this.fapiPrivatePostOrder(request)).join();
                }
            } else if (Helpers.isTrue(Helpers.GetValue(market, "inverse")))
            {
                if (Helpers.isTrue(isPortfolioMargin))
                {
                    if (Helpers.isTrue(isConditional))
                    {
                        response = (this.papiPostCmConditionalOrder(request)).join();
                    } else
                    {
                        response = (this.papiPostCmOrder(request)).join();
                    }
                } else
                {
                    response = (this.dapiPrivatePostOrder(request)).join();
                }
            } else if (Helpers.isTrue(Helpers.isTrue(Helpers.isTrue(Helpers.isEqual(marketType, "margin")) || Helpers.isTrue(!Helpers.isEqual(marginMode, null))) || Helpers.isTrue(isPortfolioMargin)))
            {
                if (Helpers.isTrue(isPortfolioMargin))
                {
                    response = (this.papiPostMarginOrder(request)).join();
                } else
                {
                    response = (this.sapiPostMarginOrder(request)).join();
                }
            } else
            {
                if (Helpers.isTrue(test))
                {
                    response = (this.privatePostOrderTest(request)).join();
                } else
                {
                    response = (this.privatePostOrder(request)).join();
                }
            }
            return this.parseOrder(response, market);
        });

    }

    public Object createOrderRequest(Object symbol, Object type, Object side, Object amount, Object... optionalArgs)
    {
        /**
        * @method
        * @ignore
        * @name binance#createOrderRequest
        * @description helper function to build the request
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much you want to trade in units of the base currency
        * @param {float} [price] the price that the order is to be fulfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @returns {object} request to be sent to the exchange
        */
        Object price = Helpers.getArg(optionalArgs, 0, null);
        Object parameters = Helpers.getArg(optionalArgs, 1, new java.util.HashMap<String, Object>() {{}});
        Object market = this.market(symbol);
        Object marketType = this.safeString(parameters, "type", Helpers.GetValue(market, "type"));
        Object clientOrderId = this.safeString2(parameters, "newClientOrderId", "clientOrderId");
        Object initialUppercaseType = ((String)type).toUpperCase();
        Object isMarketOrder = Helpers.isEqual(initialUppercaseType, "MARKET");
        Object isLimitOrder = Helpers.isEqual(initialUppercaseType, "LIMIT");
        Object upperCaseSide = ((String)side).toUpperCase();
        Object request = new java.util.HashMap<String, Object>() {{
            put( "symbol", Helpers.GetValue(market, "id") );
            put( "side", upperCaseSide );
        }};
        Object isPortfolioMargin = null;
        var isPortfolioMarginparametersVariable = this.handleOptionAndParams2(parameters, "createOrder", "papi", "portfolioMargin", false);
        isPortfolioMargin = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(0);
        parameters = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(1);
        Object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("createOrder", parameters);
        marginMode = ((java.util.List<Object>) marginModeparametersVariable).get(0);
        parameters = ((java.util.List<Object>) marginModeparametersVariable).get(1);
        Object reduceOnly = this.safeBool(parameters, "reduceOnly", false);
        if (Helpers.isTrue(reduceOnly))
        {
            if (Helpers.isTrue(Helpers.isTrue(Helpers.isEqual(marketType, "margin")) || Helpers.isTrue((!Helpers.isTrue(Helpers.GetValue(market, "contract")) && Helpers.isTrue((!Helpers.isEqual(marginMode, null)))))))
            {
                parameters = this.omit(parameters, "reduceOnly");
                Helpers.addElementToObject(request, "sideEffectType", "AUTO_REPAY");
            }
        }
        Object triggerPrice = this.safeString2(parameters, "triggerPrice", "stopPrice");
        Object stopLossPrice = this.safeString(parameters, "stopLossPrice", triggerPrice); // fallback to stopLoss
        Object takeProfitPrice = this.safeString(parameters, "takeProfitPrice");
        Object trailingDelta = this.safeString(parameters, "trailingDelta");
        Object trailingTriggerPrice = this.safeString2(parameters, "trailingTriggerPrice", "activationPrice");
        Object trailingPercent = this.safeStringN(parameters, new java.util.ArrayList<Object>(java.util.Arrays.asList("trailingPercent", "callbackRate", "trailingDelta")));
        Object priceMatch = this.safeString(parameters, "priceMatch");
        Object isTrailingPercentOrder = !Helpers.isEqual(trailingPercent, null);
        Object isStopLoss = Helpers.isTrue(!Helpers.isEqual(stopLossPrice, null)) || Helpers.isTrue(!Helpers.isEqual(trailingDelta, null));
        Object isTakeProfit = !Helpers.isEqual(takeProfitPrice, null);
        Object isTriggerOrder = !Helpers.isEqual(triggerPrice, null);
        Object isConditional = Helpers.isTrue(Helpers.isTrue(Helpers.isTrue(isTriggerOrder) || Helpers.isTrue(isTrailingPercentOrder)) || Helpers.isTrue(isStopLoss)) || Helpers.isTrue(isTakeProfit);
        Object isPortfolioMarginConditional = (Helpers.isTrue(isPortfolioMargin) && Helpers.isTrue(isConditional));
        Object isPriceMatch = !Helpers.isEqual(priceMatch, null);
        Object priceRequiredForTrailing = true;
        Object uppercaseType = ((String)type).toUpperCase();
        Object stopPrice = null;
        if (Helpers.isTrue(isTrailingPercentOrder))
        {
            if (Helpers.isTrue(Helpers.GetValue(market, "swap")))
            {
                uppercaseType = "TRAILING_STOP_MARKET";
                Helpers.addElementToObject(request, "callbackRate", trailingPercent);
                if (Helpers.isTrue(!Helpers.isEqual(trailingTriggerPrice, null)))
                {
                    Helpers.addElementToObject(request, "activationPrice", this.priceToPrecision(symbol, trailingTriggerPrice));
                }
            } else
            {
                if (Helpers.isTrue(Helpers.isTrue(Helpers.isTrue(Helpers.isTrue((!Helpers.isEqual(uppercaseType, "STOP_LOSS"))) && Helpers.isTrue((!Helpers.isEqual(uppercaseType, "TAKE_PROFIT")))) && Helpers.isTrue((!Helpers.isEqual(uppercaseType, "STOP_LOSS_LIMIT")))) && Helpers.isTrue((!Helpers.isEqual(uppercaseType, "TAKE_PROFIT_LIMIT")))))
                {
                    Object stopLossOrTakeProfit = this.safeString(parameters, "stopLossOrTakeProfit");
                    parameters = this.omit(parameters, "stopLossOrTakeProfit");
                    if (Helpers.isTrue(Helpers.isTrue((!Helpers.isEqual(stopLossOrTakeProfit, "stopLoss"))) && Helpers.isTrue((!Helpers.isEqual(stopLossOrTakeProfit, "takeProfit")))))
                    {
                        throw new InvalidOrder((String)Helpers.add(Helpers.add(this.id, symbol), " trailingPercent orders require a stopLossOrTakeProfit parameter of either stopLoss or takeProfit")) ;
                    }
                    if (Helpers.isTrue(isMarketOrder))
                    {
                        if (Helpers.isTrue(Helpers.isEqual(stopLossOrTakeProfit, "stopLoss")))
                        {
                            uppercaseType = "STOP_LOSS";
                        } else if (Helpers.isTrue(Helpers.isEqual(stopLossOrTakeProfit, "takeProfit")))
                        {
                            uppercaseType = "TAKE_PROFIT";
                        }
                    } else
                    {
                        if (Helpers.isTrue(Helpers.isEqual(stopLossOrTakeProfit, "stopLoss")))
                        {
                            uppercaseType = "STOP_LOSS_LIMIT";
                        } else if (Helpers.isTrue(Helpers.isEqual(stopLossOrTakeProfit, "takeProfit")))
                        {
                            uppercaseType = "TAKE_PROFIT_LIMIT";
                        }
                    }
                }
                if (Helpers.isTrue(Helpers.isTrue((Helpers.isEqual(uppercaseType, "STOP_LOSS"))) || Helpers.isTrue((Helpers.isEqual(uppercaseType, "TAKE_PROFIT")))))
                {
                    priceRequiredForTrailing = false;
                }
                if (Helpers.isTrue(!Helpers.isEqual(trailingTriggerPrice, null)))
                {
                    stopPrice = this.priceToPrecision(symbol, trailingTriggerPrice);
                }
                Object trailingPercentConverted = Precise.stringMul(trailingPercent, "100");
                Helpers.addElementToObject(request, "trailingDelta", trailingPercentConverted);
            }
        } else if (Helpers.isTrue(isStopLoss))
        {
            stopPrice = stopLossPrice;
            if (Helpers.isTrue(isMarketOrder))
            {
                // spot STOP_LOSS market orders are not a valid order type
                uppercaseType = ((Helpers.isTrue(Helpers.GetValue(market, "contract")))) ? "STOP_MARKET" : "STOP_LOSS";
            } else if (Helpers.isTrue(isLimitOrder))
            {
                uppercaseType = ((Helpers.isTrue(Helpers.GetValue(market, "contract")))) ? "STOP" : "STOP_LOSS_LIMIT";
            }
        } else if (Helpers.isTrue(isTakeProfit))
        {
            stopPrice = takeProfitPrice;
            if (Helpers.isTrue(isMarketOrder))
            {
                // spot TAKE_PROFIT market orders are not a valid order type
                uppercaseType = ((Helpers.isTrue(Helpers.GetValue(market, "contract")))) ? "TAKE_PROFIT_MARKET" : "TAKE_PROFIT";
            } else if (Helpers.isTrue(isLimitOrder))
            {
                uppercaseType = ((Helpers.isTrue(Helpers.GetValue(market, "contract")))) ? "TAKE_PROFIT" : "TAKE_PROFIT_LIMIT";
            }
        }
        if (Helpers.isTrue(Helpers.GetValue(market, "option")))
        {
            if (Helpers.isTrue(Helpers.isEqual(type, "market")))
            {
                throw new InvalidOrder((String)Helpers.add(Helpers.add(Helpers.add(Helpers.add(Helpers.add(this.id, " "), type), " is not a valid order type for the "), symbol), " market")) ;
            }
        } else
        {
            Object validOrderTypes = this.safeList(Helpers.GetValue(market, "info"), "orderTypes");
            if (!Helpers.isTrue(this.inArray(uppercaseType, validOrderTypes)))
            {
                if (Helpers.isTrue(!Helpers.isEqual(initialUppercaseType, uppercaseType)))
                {
                    throw new InvalidOrder((String)Helpers.add(Helpers.add(Helpers.add(Helpers.add(Helpers.add(this.id, " triggerPrice parameter is not allowed for "), symbol), " "), type), " orders")) ;
                } else
                {
                    throw new InvalidOrder((String)Helpers.add(Helpers.add(Helpers.add(Helpers.add(Helpers.add(this.id, " "), type), " is not a valid order type for the "), symbol), " market")) ;
                }
            }
        }
        Object clientOrderIdRequest = ((Helpers.isTrue(isPortfolioMarginConditional))) ? "newClientStrategyId" : "newClientOrderId";
        if (Helpers.isTrue(Helpers.isEqual(clientOrderId, null)))
        {
            Object broker = this.safeDict(this.options, "broker", new java.util.HashMap<String, Object>() {{}});
            Object defaultId = ((Helpers.isTrue((Helpers.GetValue(market, "contract"))))) ? "x-xcKtGhcu" : "x-TKT5PX2F";
            Object idMarketType = "spot";
            if (Helpers.isTrue(Helpers.GetValue(market, "contract")))
            {
                idMarketType = ((Helpers.isTrue((Helpers.isTrue(Helpers.GetValue(market, "swap")) && Helpers.isTrue(Helpers.GetValue(market, "linear")))))) ? "swap" : "inverse";
            }
            Object brokerId = this.safeString(broker, idMarketType, defaultId);
            Helpers.addElementToObject(request, clientOrderIdRequest, Helpers.add(brokerId, this.uuid22()));
        } else
        {
            Helpers.addElementToObject(request, clientOrderIdRequest, clientOrderId);
        }
        Object postOnly = null;
        if (!Helpers.isTrue(isPortfolioMargin))
        {
            postOnly = this.isPostOnly(isMarketOrder, Helpers.isEqual(initialUppercaseType, "LIMIT_MAKER"), parameters);
            if (Helpers.isTrue(Helpers.isTrue(Helpers.GetValue(market, "spot")) || Helpers.isTrue(Helpers.isEqual(marketType, "margin"))))
            {
                // only supported for spot/margin api (all margin markets are spot markets)
                if (Helpers.isTrue(postOnly))
                {
                    uppercaseType = "LIMIT_MAKER";
                }
                if (Helpers.isTrue(Helpers.isEqual(marginMode, "isolated")))
                {
                    Helpers.addElementToObject(request, "isIsolated", true);
                }
            }
        } else
        {
            postOnly = this.isPostOnly(isMarketOrder, Helpers.isEqual(initialUppercaseType, "LIMIT_MAKER"), parameters);
            if (Helpers.isTrue(postOnly))
            {
                if (!Helpers.isTrue(Helpers.GetValue(market, "contract")))
                {
                    uppercaseType = "LIMIT_MAKER";
                } else
                {
                    Helpers.addElementToObject(request, "timeInForce", "GTX");
                }
            }
        }
        // handle newOrderRespType response type
        if (Helpers.isTrue(Helpers.isTrue((Helpers.isTrue((Helpers.isEqual(marketType, "spot"))) || Helpers.isTrue((Helpers.isEqual(marketType, "margin"))))) && !Helpers.isTrue(isPortfolioMargin)))
        {
            Helpers.addElementToObject(request, "newOrderRespType", this.safeString(Helpers.GetValue(this.options, "newOrderRespType"), type, "FULL")); // 'ACK' for order id, 'RESULT' for full order or 'FULL' for order with fills
        } else
        {
            // swap, futures and options
            Helpers.addElementToObject(request, "newOrderRespType", "RESULT"); // "ACK", "RESULT", default "ACK"
        }
        Object typeRequest = ((Helpers.isTrue(isPortfolioMarginConditional))) ? "strategyType" : "type";
        Helpers.addElementToObject(request, typeRequest, uppercaseType);
        // additional required fields depending on the order type
        Object closePosition = this.safeBool(parameters, "closePosition", false);
        Object timeInForceIsRequired = false;
        Object priceIsRequired = false;
        Object triggerPriceIsRequired = false;
        Object quantityIsRequired = false;
        //
        // spot/margin
        //
        //     LIMIT                timeInForce, quantity, price
        //     MARKET               quantity or quoteOrderQty
        //     STOP_LOSS            quantity, stopPrice
        //     STOP_LOSS_LIMIT      timeInForce, quantity, price, stopPrice
        //     TAKE_PROFIT          quantity, stopPrice
        //     TAKE_PROFIT_LIMIT    timeInForce, quantity, price, stopPrice
        //     LIMIT_MAKER          quantity, price
        //
        // futures
        //
        //     LIMIT                timeInForce, quantity, price
        //     MARKET               quantity
        //     STOP/TAKE_PROFIT     quantity, price, stopPrice
        //     STOP_MARKET          stopPrice
        //     TAKE_PROFIT_MARKET   stopPrice
        //     TRAILING_STOP_MARKET callbackRate
        //
        if (Helpers.isTrue(Helpers.isEqual(uppercaseType, "MARKET")))
        {
            if (Helpers.isTrue(Helpers.GetValue(market, "spot")))
            {
                Object quoteOrderQty = this.safeBool(this.options, "quoteOrderQty", true);
                if (Helpers.isTrue(quoteOrderQty))
                {
                    Object quoteOrderQtyNew = this.safeString2(parameters, "quoteOrderQty", "cost");
                    Object precision = Helpers.GetValue(Helpers.GetValue(market, "precision"), "price");
                    if (Helpers.isTrue(!Helpers.isEqual(quoteOrderQtyNew, null)))
                    {
                        Helpers.addElementToObject(request, "quoteOrderQty", this.decimalToPrecision(quoteOrderQtyNew, TRUNCATE, precision, this.precisionMode));
                    } else if (Helpers.isTrue(!Helpers.isEqual(price, null)))
                    {
                        Object amountString = this.numberToString(amount);
                        Object priceString = this.numberToString(price);
                        Object quoteOrderQuantity = Precise.stringMul(amountString, priceString);
                        Helpers.addElementToObject(request, "quoteOrderQty", this.decimalToPrecision(quoteOrderQuantity, TRUNCATE, precision, this.precisionMode));
                    } else
                    {
                        quantityIsRequired = true;
                    }
                } else
                {
                    quantityIsRequired = true;
                }
            } else
            {
                quantityIsRequired = true;
            }
        } else if (Helpers.isTrue(Helpers.isEqual(uppercaseType, "LIMIT")))
        {
            priceIsRequired = true;
            timeInForceIsRequired = true;
            quantityIsRequired = true;
        } else if (Helpers.isTrue(Helpers.isTrue((Helpers.isEqual(uppercaseType, "STOP_LOSS"))) || Helpers.isTrue((Helpers.isEqual(uppercaseType, "TAKE_PROFIT")))))
        {
            triggerPriceIsRequired = true;
            quantityIsRequired = true;
            if (Helpers.isTrue(Helpers.isTrue((Helpers.isTrue(Helpers.GetValue(market, "linear")) || Helpers.isTrue(Helpers.GetValue(market, "inverse")))) && Helpers.isTrue(priceRequiredForTrailing)))
            {
                priceIsRequired = true;
            }
        } else if (Helpers.isTrue(Helpers.isTrue((Helpers.isEqual(uppercaseType, "STOP_LOSS_LIMIT"))) || Helpers.isTrue((Helpers.isEqual(uppercaseType, "TAKE_PROFIT_LIMIT")))))
        {
            quantityIsRequired = true;
            triggerPriceIsRequired = true;
            priceIsRequired = true;
            timeInForceIsRequired = true;
        } else if (Helpers.isTrue(Helpers.isEqual(uppercaseType, "LIMIT_MAKER")))
        {
            priceIsRequired = true;
            quantityIsRequired = true;
        } else if (Helpers.isTrue(Helpers.isEqual(uppercaseType, "STOP")))
        {
            quantityIsRequired = true;
            triggerPriceIsRequired = true;
            priceIsRequired = true;
        } else if (Helpers.isTrue(Helpers.isTrue((Helpers.isEqual(uppercaseType, "STOP_MARKET"))) || Helpers.isTrue((Helpers.isEqual(uppercaseType, "TAKE_PROFIT_MARKET")))))
        {
            if (!Helpers.isTrue(closePosition))
            {
                quantityIsRequired = true;
            }
            triggerPriceIsRequired = true;
        } else if (Helpers.isTrue(Helpers.isEqual(uppercaseType, "TRAILING_STOP_MARKET")))
        {
            if (!Helpers.isTrue(closePosition))
            {
                quantityIsRequired = true;
            }
            if (Helpers.isTrue(Helpers.isEqual(trailingPercent, null)))
            {
                throw new InvalidOrder((String)Helpers.add(Helpers.add(Helpers.add(this.id, " createOrder() requires a trailingPercent param for a "), type), " order")) ;
            }
        }
        if (Helpers.isTrue(quantityIsRequired))
        {
            Object marketAmountPrecision = this.safeString(Helpers.GetValue(market, "precision"), "amount");
            Object isPrecisionAvailable = (!Helpers.isEqual(marketAmountPrecision, null));
            if (Helpers.isTrue(isPrecisionAvailable))
            {
                Helpers.addElementToObject(request, "quantity", this.amountToPrecision(symbol, amount));
            } else
            {
                Helpers.addElementToObject(request, "quantity", this.parseToNumeric(amount)); // some options don't have the precision available
            }
        }
        if (Helpers.isTrue(Helpers.isTrue(priceIsRequired) && !Helpers.isTrue(isPriceMatch)))
        {
            if (Helpers.isTrue(Helpers.isEqual(price, null)))
            {
                throw new InvalidOrder((String)Helpers.add(Helpers.add(Helpers.add(this.id, " createOrder() requires a price argument for a "), type), " order")) ;
            }
            Object pricePrecision = this.safeString(Helpers.GetValue(market, "precision"), "price");
            Object isPricePrecisionAvailable = (!Helpers.isEqual(pricePrecision, null));
            if (Helpers.isTrue(isPricePrecisionAvailable))
            {
                Helpers.addElementToObject(request, "price", this.priceToPrecision(symbol, price));
            } else
            {
                Helpers.addElementToObject(request, "price", this.parseToNumeric(price)); // some options don't have the precision available
            }
        }
        if (Helpers.isTrue(triggerPriceIsRequired))
        {
            if (Helpers.isTrue(Helpers.GetValue(market, "contract")))
            {
                if (Helpers.isTrue(Helpers.isEqual(stopPrice, null)))
                {
                    throw new InvalidOrder((String)Helpers.add(Helpers.add(Helpers.add(this.id, " createOrder() requires a triggerPrice extra param for a "), type), " order")) ;
                }
            } else
            {
                // check for delta price as well
                if (Helpers.isTrue(Helpers.isTrue(Helpers.isTrue(Helpers.isEqual(trailingDelta, null)) && Helpers.isTrue(Helpers.isEqual(stopPrice, null))) && Helpers.isTrue(Helpers.isEqual(trailingPercent, null))))
                {
                    throw new InvalidOrder((String)Helpers.add(Helpers.add(Helpers.add(this.id, " createOrder() requires a triggerPrice, trailingDelta or trailingPercent param for a "), type), " order")) ;
                }
            }
            if (Helpers.isTrue(!Helpers.isEqual(stopPrice, null)))
            {
                Helpers.addElementToObject(request, "stopPrice", this.priceToPrecision(symbol, stopPrice));
            }
        }
        if (Helpers.isTrue(Helpers.isTrue(Helpers.isTrue(timeInForceIsRequired) && Helpers.isTrue((Helpers.isEqual(this.safeString(parameters, "timeInForce"), null)))) && Helpers.isTrue((Helpers.isEqual(this.safeString(request, "timeInForce"), null)))))
        {
            Helpers.addElementToObject(request, "timeInForce", this.safeString(this.options, "defaultTimeInForce")); // 'GTC' = Good To Cancel (default), 'IOC' = Immediate Or Cancel
        }
        if (Helpers.isTrue(Helpers.isTrue(!Helpers.isTrue(isPortfolioMargin) && Helpers.isTrue(Helpers.GetValue(market, "contract"))) && Helpers.isTrue(postOnly)))
        {
            Helpers.addElementToObject(request, "timeInForce", "GTX");
        }
        // remove timeInForce from params because PO is only used by this.isPostOnly and it's not a valid value for Binance
        if (Helpers.isTrue(Helpers.isEqual(this.safeString(parameters, "timeInForce"), "PO")))
        {
            parameters = this.omit(parameters, "timeInForce");
        }
        Object hedged = this.safeBool(parameters, "hedged", false);
        if (Helpers.isTrue(Helpers.isTrue(!Helpers.isTrue(Helpers.GetValue(market, "spot")) && !Helpers.isTrue(Helpers.GetValue(market, "option"))) && Helpers.isTrue(hedged)))
        {
            if (Helpers.isTrue(reduceOnly))
            {
                parameters = this.omit(parameters, "reduceOnly");
                side = ((Helpers.isTrue((Helpers.isEqual(side, "buy"))))) ? "sell" : "buy";
            }
            Helpers.addElementToObject(request, "positionSide", ((Helpers.isTrue((Helpers.isEqual(side, "buy"))))) ? "LONG" : "SHORT");
        }
        // unified stp
        Object selfTradePrevention = null;
        var selfTradePreventionparametersVariable = this.handleOptionAndParams(parameters, "createOrder", "selfTradePrevention");
        selfTradePrevention = ((java.util.List<Object>) selfTradePreventionparametersVariable).get(0);
        parameters = ((java.util.List<Object>) selfTradePreventionparametersVariable).get(1);
        if (Helpers.isTrue(!Helpers.isEqual(selfTradePrevention, null)))
        {
            if (Helpers.isTrue(Helpers.GetValue(market, "spot")))
            {
                Helpers.addElementToObject(request, "selfTradePreventionMode", ((String)selfTradePrevention).toUpperCase()); // binance enums exactly match the unified ccxt enums (but needs uppercase)
            }
        }
        // unified iceberg
        Object icebergAmount = this.safeNumber(parameters, "icebergAmount");
        if (Helpers.isTrue(!Helpers.isEqual(icebergAmount, null)))
        {
            if (Helpers.isTrue(Helpers.GetValue(market, "spot")))
            {
                Helpers.addElementToObject(request, "icebergQty", this.amountToPrecision(symbol, icebergAmount));
            }
        }
        Object requestParams = this.omit(parameters, new java.util.ArrayList<Object>(java.util.Arrays.asList("type", "newClientOrderId", "clientOrderId", "postOnly", "stopLossPrice", "takeProfitPrice", "stopPrice", "triggerPrice", "trailingTriggerPrice", "trailingPercent", "quoteOrderQty", "cost", "test", "hedged", "icebergAmount")));
        return this.extend(request, requestParams);
    }

    /**
     * @method
     * @name binance#createMarketOrderWithCost
     * @description create a market order by providing the symbol, side and cost
     * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-order-trade
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} side 'buy' or 'sell'
     * @param {float} cost how much you want to trade in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> createMarketOrderWithCost(Object symbol, Object side, Object cost, Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object parameters = Helpers.getArg(optionalArgs, 0, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object market = this.market(symbol);
            if (!Helpers.isTrue(Helpers.GetValue(market, "spot")))
            {
                throw new NotSupported((String)Helpers.add(this.id, " createMarketOrderWithCost() supports spot orders only")) ;
            }
            Object req = new java.util.HashMap<String, Object>() {{
                put( "cost", cost );
            }};
            return (this.createOrder(symbol, "market", side, cost, null, this.extend(req, parameters))).join();
        });

    }

    /**
     * @method
     * @name binance#createMarketBuyOrderWithCost
     * @description create a market buy order by providing the symbol and cost
     * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-order-trade
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {float} cost how much you want to trade in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> createMarketBuyOrderWithCost(Object symbol, Object cost, Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object parameters = Helpers.getArg(optionalArgs, 0, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object market = this.market(symbol);
            if (!Helpers.isTrue(Helpers.GetValue(market, "spot")))
            {
                throw new NotSupported((String)Helpers.add(this.id, " createMarketBuyOrderWithCost() supports spot orders only")) ;
            }
            Object req = new java.util.HashMap<String, Object>() {{
                put( "cost", cost );
            }};
            return (this.createOrder(symbol, "market", "buy", cost, null, this.extend(req, parameters))).join();
        });

    }

    /**
     * @method
     * @name binance#createMarketSellOrderWithCost
     * @description create a market sell order by providing the symbol and cost
     * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#new-order-trade
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {float} cost how much you want to trade in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> createMarketSellOrderWithCost(Object symbol, Object cost, Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object parameters = Helpers.getArg(optionalArgs, 0, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object market = this.market(symbol);
            if (!Helpers.isTrue(Helpers.GetValue(market, "spot")))
            {
                throw new NotSupported((String)Helpers.add(this.id, " createMarketSellOrderWithCost() supports spot orders only")) ;
            }
            Helpers.addElementToObject(parameters, "quoteOrderQty", cost);
            return (this.createOrder(symbol, "market", "sell", cost, null, parameters)).join();
        });

    }

    /**
     * @method
     * @name binance#fetchOrder
     * @description fetches information on an order made by the user
     * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#query-order-user_data
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Query-Order
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Query-Order
     * @see https://developers.binance.com/docs/derivatives/option/trade/Query-Single-Order
     * @see https://developers.binance.com/docs/margin_trading/trade/Query-Margin-Account-Order
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-UM-Order
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-CM-Order
     * @param {string} id the order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.marginMode] 'cross' or 'isolated', for spot margin trading
     * @param {boolean} [params.portfolioMargin] set to true if you would like to fetch an order in a portfolio margin account
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchOrder(Object id, Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object symbol = Helpers.getArg(optionalArgs, 0, null);
            Object parameters = Helpers.getArg(optionalArgs, 1, new java.util.HashMap<String, Object>() {{}});
            if (Helpers.isTrue(Helpers.isEqual(symbol, null)))
            {
                throw new ArgumentsRequired((String)Helpers.add(this.id, " fetchOrder() requires a symbol argument")) ;
            }
            (this.loadMarkets()).join();
            Object market = this.market(symbol);
            Object defaultType = this.safeString2(this.options, "fetchOrder", "defaultType", "spot");
            Object type = this.safeString(parameters, "type", defaultType);
            Object marginMode = null;
            var marginModeparametersVariable = this.handleMarginModeAndParams("fetchOrder", parameters);
            marginMode = ((java.util.List<Object>) marginModeparametersVariable).get(0);
            parameters = ((java.util.List<Object>) marginModeparametersVariable).get(1);
            Object isPortfolioMargin = null;
            var isPortfolioMarginparametersVariable = this.handleOptionAndParams2(parameters, "fetchOrder", "papi", "portfolioMargin", false);
            isPortfolioMargin = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(0);
            parameters = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(1);
            Object request = new java.util.HashMap<String, Object>() {{
                put( "symbol", Helpers.GetValue(market, "id") );
            }};
            Object clientOrderId = this.safeString2(parameters, "origClientOrderId", "clientOrderId");
            if (Helpers.isTrue(!Helpers.isEqual(clientOrderId, null)))
            {
                if (Helpers.isTrue(Helpers.GetValue(market, "option")))
                {
                    Helpers.addElementToObject(request, "clientOrderId", clientOrderId);
                } else
                {
                    Helpers.addElementToObject(request, "origClientOrderId", clientOrderId);
                }
            } else
            {
                Helpers.addElementToObject(request, "orderId", id);
            }
            parameters = this.omit(parameters, new java.util.ArrayList<Object>(java.util.Arrays.asList("type", "clientOrderId", "origClientOrderId")));
            Object response = null;
            if (Helpers.isTrue(Helpers.GetValue(market, "option")))
            {
                response = (this.eapiPrivateGetOrder(this.extend(request, parameters))).join();
            } else if (Helpers.isTrue(Helpers.GetValue(market, "linear")))
            {
                if (Helpers.isTrue(isPortfolioMargin))
                {
                    response = (this.papiGetUmOrder(this.extend(request, parameters))).join();
                } else
                {
                    response = (this.fapiPrivateGetOrder(this.extend(request, parameters))).join();
                }
            } else if (Helpers.isTrue(Helpers.GetValue(market, "inverse")))
            {
                if (Helpers.isTrue(isPortfolioMargin))
                {
                    response = (this.papiGetCmOrder(this.extend(request, parameters))).join();
                } else
                {
                    response = (this.dapiPrivateGetOrder(this.extend(request, parameters))).join();
                }
            } else if (Helpers.isTrue(Helpers.isTrue(Helpers.isTrue((Helpers.isEqual(type, "margin"))) || Helpers.isTrue((!Helpers.isEqual(marginMode, null)))) || Helpers.isTrue(isPortfolioMargin)))
            {
                if (Helpers.isTrue(isPortfolioMargin))
                {
                    response = (this.papiGetMarginOrder(this.extend(request, parameters))).join();
                } else
                {
                    if (Helpers.isTrue(Helpers.isEqual(marginMode, "isolated")))
                    {
                        Helpers.addElementToObject(request, "isIsolated", true);
                    }
                    response = (this.sapiGetMarginOrder(this.extend(request, parameters))).join();
                }
            } else
            {
                response = (this.privateGetOrder(this.extend(request, parameters))).join();
            }
            return this.parseOrder(response, market);
        });

    }

    /**
     * @method
     * @name binance#fetchOrders
     * @description fetches information on multiple orders made by the user
     * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#all-orders-user_data
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/All-Orders
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/All-Orders
     * @see https://developers.binance.com/docs/derivatives/option/trade/Query-Option-Order-History
     * @see https://developers.binance.com/docs/margin_trading/trade/Query-Margin-Account-All-Orders
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-UM-Orders
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-CM-Orders
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-UM-Conditional-Orders
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-CM-Conditional-Orders
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.marginMode] 'cross' or 'isolated', for spot margin trading
     * @param {int} [params.until] the latest time in ms to fetch orders for
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @param {boolean} [params.portfolioMargin] set to true if you would like to fetch orders in a portfolio margin account
     * @param {boolean} [params.trigger] set to true if you would like to fetch portfolio margin account trigger or conditional orders
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchOrders(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object symbol = Helpers.getArg(optionalArgs, 0, null);
            Object since = Helpers.getArg(optionalArgs, 1, null);
            Object limit = Helpers.getArg(optionalArgs, 2, null);
            Object parameters = Helpers.getArg(optionalArgs, 3, new java.util.HashMap<String, Object>() {{}});
            if (Helpers.isTrue(Helpers.isEqual(symbol, null)))
            {
                throw new ArgumentsRequired((String)Helpers.add(this.id, " fetchOrders() requires a symbol argument")) ;
            }
            (this.loadMarkets()).join();
            Object paginate = false;
            var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchOrders", "paginate");
            paginate = ((java.util.List<Object>) paginateparametersVariable).get(0);
            parameters = ((java.util.List<Object>) paginateparametersVariable).get(1);
            if (Helpers.isTrue(paginate))
            {
                return (this.fetchPaginatedCallDynamic("fetchOrders", symbol, since, limit, parameters)).join();
            }
            Object market = this.market(symbol);
            Object defaultType = this.safeString2(this.options, "fetchOrders", "defaultType", Helpers.GetValue(market, "type"));
            Object type = this.safeString(parameters, "type", defaultType);
            Object marginMode = null;
            var marginModeparametersVariable = this.handleMarginModeAndParams("fetchOrders", parameters);
            marginMode = ((java.util.List<Object>) marginModeparametersVariable).get(0);
            parameters = ((java.util.List<Object>) marginModeparametersVariable).get(1);
            Object isPortfolioMargin = null;
            var isPortfolioMarginparametersVariable = this.handleOptionAndParams2(parameters, "fetchOrders", "papi", "portfolioMargin", false);
            isPortfolioMargin = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(0);
            parameters = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(1);
            Object isConditional = this.safeBoolN(parameters, new java.util.ArrayList<Object>(java.util.Arrays.asList("stop", "trigger", "conditional")));
            parameters = this.omit(parameters, new java.util.ArrayList<Object>(java.util.Arrays.asList("stop", "trigger", "conditional", "type")));
            Object request = new java.util.HashMap<String, Object>() {{
                put( "symbol", Helpers.GetValue(market, "id") );
            }};
            var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
            request = ((java.util.List<Object>) requestparametersVariable).get(0);
            parameters = ((java.util.List<Object>) requestparametersVariable).get(1);
            if (Helpers.isTrue(!Helpers.isEqual(since, null)))
            {
                Helpers.addElementToObject(request, "startTime", since);
            }
            if (Helpers.isTrue(!Helpers.isEqual(limit, null)))
            {
                Helpers.addElementToObject(request, "limit", limit);
            }
            Object response = null;
            if (Helpers.isTrue(Helpers.GetValue(market, "option")))
            {
                response = (this.eapiPrivateGetHistoryOrders(this.extend(request, parameters))).join();
            } else if (Helpers.isTrue(Helpers.GetValue(market, "linear")))
            {
                if (Helpers.isTrue(isPortfolioMargin))
                {
                    if (Helpers.isTrue(isConditional))
                    {
                        response = (this.papiGetUmConditionalAllOrders(this.extend(request, parameters))).join();
                    } else
                    {
                        response = (this.papiGetUmAllOrders(this.extend(request, parameters))).join();
                    }
                } else
                {
                    response = (this.fapiPrivateGetAllOrders(this.extend(request, parameters))).join();
                }
            } else if (Helpers.isTrue(Helpers.GetValue(market, "inverse")))
            {
                if (Helpers.isTrue(isPortfolioMargin))
                {
                    if (Helpers.isTrue(isConditional))
                    {
                        response = (this.papiGetCmConditionalAllOrders(this.extend(request, parameters))).join();
                    } else
                    {
                        response = (this.papiGetCmAllOrders(this.extend(request, parameters))).join();
                    }
                } else
                {
                    response = (this.dapiPrivateGetAllOrders(this.extend(request, parameters))).join();
                }
            } else
            {
                if (Helpers.isTrue(isPortfolioMargin))
                {
                    response = (this.papiGetMarginAllOrders(this.extend(request, parameters))).join();
                } else if (Helpers.isTrue(Helpers.isTrue(Helpers.isEqual(type, "margin")) || Helpers.isTrue(!Helpers.isEqual(marginMode, null))))
                {
                    if (Helpers.isTrue(Helpers.isEqual(marginMode, "isolated")))
                    {
                        Helpers.addElementToObject(request, "isIsolated", true);
                    }
                    response = (this.sapiGetMarginAllOrders(this.extend(request, parameters))).join();
                } else
                {
                    response = (this.privateGetAllOrders(this.extend(request, parameters))).join();
                }
            }
            //
            //  spot
            //
            //     [
            //         {
            //             "symbol": "LTCBTC",
            //             "orderId": 1,
            //             "clientOrderId": "myOrder1",
            //             "price": "0.1",
            //             "origQty": "1.0",
            //             "executedQty": "0.0",
            //             "cummulativeQuoteQty": "0.0",
            //             "status": "NEW",
            //             "timeInForce": "GTC",
            //             "type": "LIMIT",
            //             "side": "BUY",
            //             "stopPrice": "0.0",
            //             "icebergQty": "0.0",
            //             "time": 1499827319559,
            //             "updateTime": 1499827319559,
            //             "isWorking": true
            //         }
            //     ]
            //
            //  futures
            //
            //     [
            //         {
            //             "symbol": "BTCUSDT",
            //             "orderId": 1,
            //             "clientOrderId": "myOrder1",
            //             "price": "0.1",
            //             "origQty": "1.0",
            //             "executedQty": "1.0",
            //             "cumQuote": "10.0",
            //             "status": "NEW",
            //             "timeInForce": "GTC",
            //             "type": "LIMIT",
            //             "side": "BUY",
            //             "stopPrice": "0.0",
            //             "updateTime": 1499827319559
            //         }
            //     ]
            //
            // options
            //
            //     [
            //         {
            //             "orderId": 4728833085436977152,
            //             "symbol": "ETH-230211-1500-C",
            //             "price": "10.0",
            //             "quantity": "1.00",
            //             "executedQty": "0.00",
            //             "fee": "0",
            //             "side": "BUY",
            //             "type": "LIMIT",
            //             "timeInForce": "GTC",
            //             "reduceOnly": false,
            //             "postOnly": false,
            //             "createTime": 1676083034462,
            //             "updateTime": 1676083034462,
            //             "status": "ACCEPTED",
            //             "avgPrice": "0",
            //             "source": "API",
            //             "clientOrderId": "",
            //             "priceScale": 1,
            //             "quantityScale": 2,
            //             "optionSide": "CALL",
            //             "quoteAsset": "USDT",
            //             "lastTrade": {"id":"69","time":"1676084430567","price":"24.9","qty":"1.00"},
            //             "mmp": false
            //         }
            //     ]
            //
            // inverse portfolio margin
            //
            //     [
            //         {
            //             "orderId": 71328442983,
            //             "symbol": "ETHUSD_PERP",
            //             "pair": "ETHUSD",
            //             "status": "CANCELED",
            //             "clientOrderId": "x-xcKtGhcu4b3e3d8515dd4dc5ba9ccc",
            //             "price": "2000",
            //             "avgPrice": "0.00",
            //             "origQty": "1",
            //             "executedQty": "0",
            //             "cumBase": "0",
            //             "timeInForce": "GTC",
            //             "type": "LIMIT",
            //             "reduceOnly": false,
            //             "side": "BUY",
            //             "origType": "LIMIT",
            //             "time": 1707197843046,
            //             "updateTime": 1707197941373,
            //             "positionSide": "BOTH"
            //         },
            //     ]
            //
            // linear portfolio margin
            //
            //     [
            //         {
            //             "orderId": 259235347005,
            //             "symbol": "BTCUSDT",
            //             "status": "CANCELED",
            //             "clientOrderId": "x-xcKtGhcu402881c9103f42bdb4183b",
            //             "price": "35000",
            //             "avgPrice": "0.00000",
            //             "origQty": "0.010",
            //             "executedQty": "0",
            //             "cumQuote": "0",
            //             "timeInForce": "GTC",
            //             "type": "LIMIT",
            //             "reduceOnly": false,
            //             "side": "BUY",
            //             "origType": "LIMIT",
            //             "time": 1707194702167,
            //             "updateTime": 1707197804748,
            //             "positionSide": "BOTH",
            //             "selfTradePreventionMode": "NONE",
            //             "goodTillDate": 0
            //         },
            //     ]
            //
            // conditional portfolio margin
            //
            //     [
            //         {
            //             "newClientStrategyId": "x-xcKtGhcuaf166172ed504cd1bc0396",
            //             "strategyId": 3733211,
            //             "strategyStatus": "CANCELLED",
            //             "strategyType": "STOP",
            //             "origQty": "0.010",
            //             "price": "35000",
            //             "orderId": 0,
            //             "reduceOnly": false,
            //             "side": "BUY",
            //             "positionSide": "BOTH",
            //             "stopPrice": "50000",
            //             "symbol": "BTCUSDT",
            //             "type": "LIMIT",
            //             "bookTime": 1707270098774,
            //             "updateTime": 1707270119261,
            //             "timeInForce": "GTC",
            //             "triggerTime": 0,
            //             "workingType": "CONTRACT_PRICE",
            //             "priceProtect": false,
            //             "goodTillDate": 0,
            //             "selfTradePreventionMode": "NONE"
            //         },
            //     ]
            //
            // spot margin portfolio margin
            //
            //     [
            //         {
            //             "symbol": "BTCUSDT",
            //             "orderId": 24684460474,
            //             "clientOrderId": "x-TKT5PX2Fe9ef29d8346440f0b28b86",
            //             "price": "35000.00000000",
            //             "origQty": "0.00100000",
            //             "executedQty": "0.00000000",
            //             "cummulativeQuoteQty": "0.00000000",
            //             "status": "CANCELED",
            //             "timeInForce": "GTC",
            //             "type": "LIMIT",
            //             "side": "BUY",
            //             "stopPrice": "0.00000000",
            //             "icebergQty": "0.00000000",
            //             "time": 1707113538870,
            //             "updateTime": 1707113797688,
            //             "isWorking": true,
            //             "accountId": 200180970,
            //             "selfTradePreventionMode": "EXPIRE_MAKER",
            //             "preventedMatchId": null,
            //             "preventedQuantity": null
            //         },
            //     ]
            //
            return this.parseOrders(response, market, since, limit);
        });

    }

    /**
     * @method
     * @name binance#fetchOpenOrders
     * @description fetch all unfilled currently open orders
     * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#current-open-orders-user_data
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Current-All-Open-Orders
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Current-All-Open-Orders
     * @see https://developers.binance.com/docs/derivatives/option/trade/Query-Current-Open-Option-Orders
     * @see https://developers.binance.com/docs/margin_trading/trade/Query-Margin-Account-Open-Orders
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-Current-UM-Open-Orders
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-Current-UM-Open-Conditional-Orders
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-Current-CM-Open-Orders
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-Current-CM-Open-Conditional-Orders
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch open orders for
     * @param {int} [limit] the maximum number of open orders structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.marginMode] 'cross' or 'isolated', for spot margin trading
     * @param {boolean} [params.portfolioMargin] set to true if you would like to fetch open orders in the portfolio margin account
     * @param {boolean} [params.trigger] set to true if you would like to fetch portfolio margin account conditional orders
     * @param {string} [params.subType] "linear" or "inverse"
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchOpenOrders(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object symbol = Helpers.getArg(optionalArgs, 0, null);
            Object since = Helpers.getArg(optionalArgs, 1, null);
            Object limit = Helpers.getArg(optionalArgs, 2, null);
            Object parameters = Helpers.getArg(optionalArgs, 3, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object market = null;
            Object type = null;
            Object request = new java.util.HashMap<String, Object>() {{}};
            Object marginMode = null;
            var marginModeparametersVariable = this.handleMarginModeAndParams("fetchOpenOrders", parameters);
            marginMode = ((java.util.List<Object>) marginModeparametersVariable).get(0);
            parameters = ((java.util.List<Object>) marginModeparametersVariable).get(1);
            Object isPortfolioMargin = null;
            var isPortfolioMarginparametersVariable = this.handleOptionAndParams2(parameters, "fetchOpenOrders", "papi", "portfolioMargin", false);
            isPortfolioMargin = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(0);
            parameters = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(1);
            Object isConditional = this.safeBoolN(parameters, new java.util.ArrayList<Object>(java.util.Arrays.asList("stop", "trigger", "conditional")));
            if (Helpers.isTrue(!Helpers.isEqual(symbol, null)))
            {
                market = this.market(symbol);
                Helpers.addElementToObject(request, "symbol", Helpers.GetValue(market, "id"));
                Object defaultType = this.safeString2(this.options, "fetchOpenOrders", "defaultType", "spot");
                Object marketType = ((Helpers.isTrue((Helpers.inOp(market, "type"))))) ? Helpers.GetValue(market, "type") : defaultType;
                type = this.safeString(parameters, "type", marketType);
            } else if (Helpers.isTrue(Helpers.GetValue(this.options, "warnOnFetchOpenOrdersWithoutSymbol")))
            {
                throw new ExchangeError((String)Helpers.add(Helpers.add(Helpers.add(this.id, " fetchOpenOrders() WARNING: fetching open orders without specifying a symbol has stricter rate limits (10 times more for spot, 40 times more for other markets) compared to requesting with symbol argument. To acknowledge this warning, set "), this.id), ".options[\"warnOnFetchOpenOrdersWithoutSymbol\"] = false to suppress this warning message.")) ;
            } else
            {
                Object defaultType = this.safeString2(this.options, "fetchOpenOrders", "defaultType", "spot");
                type = this.safeString(parameters, "type", defaultType);
            }
            Object subType = null;
            var subTypeparametersVariable = this.handleSubTypeAndParams("fetchOpenOrders", market, parameters);
            subType = ((java.util.List<Object>) subTypeparametersVariable).get(0);
            parameters = ((java.util.List<Object>) subTypeparametersVariable).get(1);
            parameters = this.omit(parameters, new java.util.ArrayList<Object>(java.util.Arrays.asList("type", "stop", "trigger", "conditional")));
            Object response = null;
            if (Helpers.isTrue(Helpers.isEqual(type, "option")))
            {
                if (Helpers.isTrue(!Helpers.isEqual(since, null)))
                {
                    Helpers.addElementToObject(request, "startTime", since);
                }
                if (Helpers.isTrue(!Helpers.isEqual(limit, null)))
                {
                    Helpers.addElementToObject(request, "limit", limit);
                }
                response = (this.eapiPrivateGetOpenOrders(this.extend(request, parameters))).join();
            } else if (Helpers.isTrue(this.isLinear(type, subType)))
            {
                if (Helpers.isTrue(isPortfolioMargin))
                {
                    if (Helpers.isTrue(isConditional))
                    {
                        response = (this.papiGetUmConditionalOpenOrders(this.extend(request, parameters))).join();
                    } else
                    {
                        response = (this.papiGetUmOpenOrders(this.extend(request, parameters))).join();
                    }
                } else
                {
                    response = (this.fapiPrivateGetOpenOrders(this.extend(request, parameters))).join();
                }
            } else if (Helpers.isTrue(this.isInverse(type, subType)))
            {
                if (Helpers.isTrue(isPortfolioMargin))
                {
                    if (Helpers.isTrue(isConditional))
                    {
                        response = (this.papiGetCmConditionalOpenOrders(this.extend(request, parameters))).join();
                    } else
                    {
                        response = (this.papiGetCmOpenOrders(this.extend(request, parameters))).join();
                    }
                } else
                {
                    response = (this.dapiPrivateGetOpenOrders(this.extend(request, parameters))).join();
                }
            } else if (Helpers.isTrue(Helpers.isTrue(Helpers.isTrue(Helpers.isEqual(type, "margin")) || Helpers.isTrue(!Helpers.isEqual(marginMode, null))) || Helpers.isTrue(isPortfolioMargin)))
            {
                if (Helpers.isTrue(isPortfolioMargin))
                {
                    response = (this.papiGetMarginOpenOrders(this.extend(request, parameters))).join();
                } else
                {
                    if (Helpers.isTrue(Helpers.isEqual(marginMode, "isolated")))
                    {
                        Helpers.addElementToObject(request, "isIsolated", true);
                        if (Helpers.isTrue(Helpers.isEqual(symbol, null)))
                        {
                            throw new ArgumentsRequired((String)Helpers.add(this.id, " fetchOpenOrders() requires a symbol argument for isolated markets")) ;
                        }
                    }
                    response = (this.sapiGetMarginOpenOrders(this.extend(request, parameters))).join();
                }
            } else
            {
                response = (this.privateGetOpenOrders(this.extend(request, parameters))).join();
            }
            return this.parseOrders(response, market, since, limit);
        });

    }

    /**
     * @method
     * @name binance#fetchOpenOrder
     * @description fetch an open order by the id
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Query-Current-Open-Order
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Query-Current-Open-Order
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-Current-UM-Open-Order
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-Current-UM-Open-Conditional-Order
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-Current-CM-Open-Order
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-Current-CM-Open-Conditional-Order
     * @param {string} id order id
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.trigger] set to true if you would like to fetch portfolio margin account stop or conditional orders
     * @param {boolean} [params.portfolioMargin] set to true if you would like to fetch for a portfolio margin account
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchOpenOrder(Object id, Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object symbol = Helpers.getArg(optionalArgs, 0, null);
            Object parameters = Helpers.getArg(optionalArgs, 1, new java.util.HashMap<String, Object>() {{}});
            if (Helpers.isTrue(Helpers.isEqual(symbol, null)))
            {
                throw new ArgumentsRequired((String)Helpers.add(this.id, " fetchOpenOrder() requires a symbol argument")) ;
            }
            (this.loadMarkets()).join();
            Object market = this.market(symbol);
            Object request = new java.util.HashMap<String, Object>() {{
                put( "symbol", Helpers.GetValue(market, "id") );
            }};
            Object isPortfolioMargin = null;
            var isPortfolioMarginparametersVariable = this.handleOptionAndParams2(parameters, "fetchOpenOrder", "papi", "portfolioMargin", false);
            isPortfolioMargin = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(0);
            parameters = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(1);
            Object isConditional = this.safeBoolN(parameters, new java.util.ArrayList<Object>(java.util.Arrays.asList("stop", "trigger", "conditional")));
            parameters = this.omit(parameters, new java.util.ArrayList<Object>(java.util.Arrays.asList("stop", "trigger", "conditional")));
            Object isPortfolioMarginConditional = (Helpers.isTrue(isPortfolioMargin) && Helpers.isTrue(isConditional));
            Object orderIdRequest = ((Helpers.isTrue(isPortfolioMarginConditional))) ? "strategyId" : "orderId";
            Helpers.addElementToObject(request, orderIdRequest, id);
            Object response = null;
            if (Helpers.isTrue(Helpers.GetValue(market, "linear")))
            {
                if (Helpers.isTrue(isPortfolioMargin))
                {
                    if (Helpers.isTrue(isConditional))
                    {
                        response = (this.papiGetUmConditionalOpenOrder(this.extend(request, parameters))).join();
                    } else
                    {
                        response = (this.papiGetUmOpenOrder(this.extend(request, parameters))).join();
                    }
                } else
                {
                    response = (this.fapiPrivateGetOpenOrder(this.extend(request, parameters))).join();
                }
            } else if (Helpers.isTrue(Helpers.GetValue(market, "inverse")))
            {
                if (Helpers.isTrue(isPortfolioMargin))
                {
                    if (Helpers.isTrue(isConditional))
                    {
                        response = (this.papiGetCmConditionalOpenOrder(this.extend(request, parameters))).join();
                    } else
                    {
                        response = (this.papiGetCmOpenOrder(this.extend(request, parameters))).join();
                    }
                } else
                {
                    response = (this.dapiPrivateGetOpenOrder(this.extend(request, parameters))).join();
                }
            } else
            {
                if (Helpers.isTrue(Helpers.GetValue(market, "option")))
                {
                    throw new NotSupported((String)Helpers.add(this.id, " fetchOpenOrder() does not support option markets")) ;
                } else if (Helpers.isTrue(Helpers.GetValue(market, "spot")))
                {
                    throw new NotSupported((String)Helpers.add(this.id, " fetchOpenOrder() does not support spot markets")) ;
                }
            }
            //
            // linear swap
            //
            //     {
            //         "orderId": 3697213934,
            //         "symbol": "BTCUSDT",
            //         "status": "NEW",
            //         "clientOrderId": "x-xcKtGhcufb20c5a7761a4aa09aa156",
            //         "price": "33000.00",
            //         "avgPrice": "0.00000",
            //         "origQty": "0.010",
            //         "executedQty": "0.000",
            //         "cumQuote": "0.00000",
            //         "timeInForce": "GTC",
            //         "type": "LIMIT",
            //         "reduceOnly": false,
            //         "closePosition": false,
            //         "side": "BUY",
            //         "positionSide": "BOTH",
            //         "stopPrice": "0.00",
            //         "workingType": "CONTRACT_PRICE",
            //         "priceProtect": false,
            //         "origType": "LIMIT",
            //         "priceMatch": "NONE",
            //         "selfTradePreventionMode": "NONE",
            //         "goodTillDate": 0,
            //         "time": 1707892893502,
            //         "updateTime": 1707892893515
            //     }
            //
            // inverse swap
            //
            //     {
            //         "orderId": 597368542,
            //         "symbol": "BTCUSD_PERP",
            //         "pair": "BTCUSD",
            //         "status": "NEW",
            //         "clientOrderId": "x-xcKtGhcubbde7ba93b1a4ab881eff3",
            //         "price": "35000",
            //         "avgPrice": "0",
            //         "origQty": "1",
            //         "executedQty": "0",
            //         "cumBase": "0",
            //         "timeInForce": "GTC",
            //         "type": "LIMIT",
            //         "reduceOnly": false,
            //         "closePosition": false,
            //         "side": "BUY",
            //         "positionSide": "BOTH",
            //         "stopPrice": "0",
            //         "workingType": "CONTRACT_PRICE",
            //         "priceProtect": false,
            //         "origType": "LIMIT",
            //         "time": 1707893453199,
            //         "updateTime": 1707893453199
            //     }
            //
            // linear portfolio margin
            //
            //     {
            //         "orderId": 264895013409,
            //         "symbol": "BTCUSDT",
            //         "status": "NEW",
            //         "clientOrderId": "x-xcKtGhcu6278f1adbdf14f74ab432e",
            //         "price": "35000",
            //         "avgPrice": "0",
            //         "origQty": "0.010",
            //         "executedQty": "0",
            //         "cumQuote": "0",
            //         "timeInForce": "GTC",
            //         "type": "LIMIT",
            //         "reduceOnly": false,
            //         "side": "BUY",
            //         "positionSide": "LONG",
            //         "origType": "LIMIT",
            //         "time": 1707893839364,
            //         "updateTime": 1707893839364,
            //         "goodTillDate": 0,
            //         "selfTradePreventionMode": "NONE"
            //     }
            //
            // inverse portfolio margin
            //
            //     {
            //         "orderId": 71790316950,
            //         "symbol": "ETHUSD_PERP",
            //         "pair": "ETHUSD",
            //         "status": "NEW",
            //         "clientOrderId": "x-xcKtGhcuec11030474204ab08ba2c2",
            //         "price": "2500",
            //         "avgPrice": "0",
            //         "origQty": "1",
            //         "executedQty": "0",
            //         "cumBase": "0",
            //         "timeInForce": "GTC",
            //         "type": "LIMIT",
            //         "reduceOnly": false,
            //         "side": "BUY",
            //         "positionSide": "LONG",
            //         "origType": "LIMIT",
            //         "time": 1707894181694,
            //         "updateTime": 1707894181694
            //     }
            //
            // linear portfolio margin conditional
            //
            //     {
            //         "newClientStrategyId": "x-xcKtGhcu2205fde44418483ca21874",
            //         "strategyId": 4084339,
            //         "strategyStatus": "NEW",
            //         "strategyType": "STOP",
            //         "origQty": "0.010",
            //         "price": "35000",
            //         "reduceOnly": false,
            //         "side": "BUY",
            //         "positionSide": "LONG",
            //         "stopPrice": "60000",
            //         "symbol": "BTCUSDT",
            //         "bookTime": 1707894490094,
            //         "updateTime": 1707894490094,
            //         "timeInForce": "GTC",
            //         "workingType": "CONTRACT_PRICE",
            //         "priceProtect": false,
            //         "goodTillDate": 0,
            //         "selfTradePreventionMode": "NONE"
            //     }
            //
            // inverse portfolio margin conditional
            //
            //     {
            //         "newClientStrategyId": "x-xcKtGhcu2da9c765294b433994ffce",
            //         "strategyId": 1423501,
            //         "strategyStatus": "NEW",
            //         "strategyType": "STOP",
            //         "origQty": "1",
            //         "price": "2500",
            //         "reduceOnly": false,
            //         "side": "BUY",
            //         "positionSide": "LONG",
            //         "stopPrice": "4000",
            //         "symbol": "ETHUSD_PERP",
            //         "bookTime": 1707894782679,
            //         "updateTime": 1707894782679,
            //         "timeInForce": "GTC",
            //         "workingType": "CONTRACT_PRICE",
            //         "priceProtect": false
            //     }
            //
            return this.parseOrder(response, market);
        });

    }

    /**
     * @method
     * @name binance#fetchClosedOrders
     * @description fetches information on multiple closed orders made by the user
     * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#all-orders-user_data
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/All-Orders
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/All-Orders
     * @see https://developers.binance.com/docs/derivatives/option/trade/Query-Option-Order-History
     * @see https://developers.binance.com/docs/margin_trading/trade/Query-Margin-Account-All-Orders
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-UM-Orders
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-CM-Orders
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-UM-Conditional-Orders
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-CM-Conditional-Orders
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @param {boolean} [params.portfolioMargin] set to true if you would like to fetch orders in a portfolio margin account
     * @param {boolean} [params.trigger] set to true if you would like to fetch portfolio margin account trigger or conditional orders
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchClosedOrders(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object symbol = Helpers.getArg(optionalArgs, 0, null);
            Object since = Helpers.getArg(optionalArgs, 1, null);
            Object limit = Helpers.getArg(optionalArgs, 2, null);
            Object parameters = Helpers.getArg(optionalArgs, 3, new java.util.HashMap<String, Object>() {{}});
            if (Helpers.isTrue(Helpers.isEqual(symbol, null)))
            {
                throw new ArgumentsRequired((String)Helpers.add(this.id, " fetchClosedOrders() requires a symbol argument")) ;
            }
            Object orders = (this.fetchOrders(symbol, since, null, parameters)).join();
            Object filteredOrders = this.filterBy(orders, "status", "closed");
            return this.filterBySinceLimit(filteredOrders, since, limit);
        });

    }

    /**
     * @method
     * @name binance#fetchCanceledOrders
     * @description fetches information on multiple canceled orders made by the user
     * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#all-orders-user_data
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/All-Orders
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/All-Orders
     * @see https://developers.binance.com/docs/derivatives/option/trade/Query-Option-Order-History
     * @see https://developers.binance.com/docs/margin_trading/trade/Query-Margin-Account-All-Orders
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-UM-Orders
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-CM-Orders
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-UM-Conditional-Orders
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-CM-Conditional-Orders
     * @param {string} symbol unified market symbol of the market the orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @param {boolean} [params.portfolioMargin] set to true if you would like to fetch orders in a portfolio margin account
     * @param {boolean} [params.trigger] set to true if you would like to fetch portfolio margin account trigger or conditional orders
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchCanceledOrders(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object symbol = Helpers.getArg(optionalArgs, 0, null);
            Object since = Helpers.getArg(optionalArgs, 1, null);
            Object limit = Helpers.getArg(optionalArgs, 2, null);
            Object parameters = Helpers.getArg(optionalArgs, 3, new java.util.HashMap<String, Object>() {{}});
            if (Helpers.isTrue(Helpers.isEqual(symbol, null)))
            {
                throw new ArgumentsRequired((String)Helpers.add(this.id, " fetchCanceledOrders() requires a symbol argument")) ;
            }
            Object orders = (this.fetchOrders(symbol, since, null, parameters)).join();
            Object filteredOrders = this.filterBy(orders, "status", "canceled");
            return this.filterBySinceLimit(filteredOrders, since, limit);
        });

    }

    /**
     * @method
     * @name binance#fetchCanceledAndClosedOrders
     * @description fetches information on multiple canceled orders made by the user
     * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#all-orders-user_data
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/All-Orders
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/All-Orders
     * @see https://developers.binance.com/docs/derivatives/option/trade/Query-Option-Order-History
     * @see https://developers.binance.com/docs/margin_trading/trade/Query-Margin-Account-All-Orders
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-UM-Orders
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-CM-Orders
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-UM-Conditional-Orders
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-All-CM-Conditional-Orders
     * @param {string} symbol unified market symbol of the market the orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @param {boolean} [params.portfolioMargin] set to true if you would like to fetch orders in a portfolio margin account
     * @param {boolean} [params.trigger] set to true if you would like to fetch portfolio margin account trigger or conditional orders
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchCanceledAndClosedOrders(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object symbol = Helpers.getArg(optionalArgs, 0, null);
            Object since = Helpers.getArg(optionalArgs, 1, null);
            Object limit = Helpers.getArg(optionalArgs, 2, null);
            Object parameters = Helpers.getArg(optionalArgs, 3, new java.util.HashMap<String, Object>() {{}});
            if (Helpers.isTrue(Helpers.isEqual(symbol, null)))
            {
                throw new ArgumentsRequired((String)Helpers.add(this.id, " fetchCanceledAndClosedOrders() requires a symbol argument")) ;
            }
            Object orders = (this.fetchOrders(symbol, since, null, parameters)).join();
            Object canceledOrders = this.filterBy(orders, "status", "canceled");
            Object closedOrders = this.filterBy(orders, "status", "closed");
            Object filteredOrders = this.arrayConcat(canceledOrders, closedOrders);
            Object sortedOrders = this.sortBy(filteredOrders, "timestamp");
            return this.filterBySinceLimit(sortedOrders, since, limit);
        });

    }

    /**
     * @method
     * @name binance#cancelOrder
     * @description cancels an open order
     * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#cancel-order-trade
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Cancel-Order
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Cancel-Order
     * @see https://developers.binance.com/docs/derivatives/option/trade/Cancel-Option-Order
     * @see https://developers.binance.com/docs/margin_trading/trade/Margin-Account-Cancel-Order
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Cancel-UM-Order
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Cancel-CM-Order
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Cancel-UM-Conditional-Order
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Cancel-CM-Conditional-Order
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Cancel-Margin-Account-Order
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.portfolioMargin] set to true if you would like to cancel an order in a portfolio margin account
     * @param {boolean} [params.trigger] set to true if you would like to cancel a portfolio margin account conditional order
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> cancelOrder(Object id, Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object symbol = Helpers.getArg(optionalArgs, 0, null);
            Object parameters = Helpers.getArg(optionalArgs, 1, new java.util.HashMap<String, Object>() {{}});
            if (Helpers.isTrue(Helpers.isEqual(symbol, null)))
            {
                throw new ArgumentsRequired((String)Helpers.add(this.id, " cancelOrder() requires a symbol argument")) ;
            }
            (this.loadMarkets()).join();
            Object market = this.market(symbol);
            Object defaultType = this.safeString2(this.options, "cancelOrder", "defaultType", "spot");
            Object type = this.safeString(parameters, "type", defaultType);
            Object marginMode = null;
            var marginModeparametersVariable = this.handleMarginModeAndParams("cancelOrder", parameters);
            marginMode = ((java.util.List<Object>) marginModeparametersVariable).get(0);
            parameters = ((java.util.List<Object>) marginModeparametersVariable).get(1);
            Object isPortfolioMargin = null;
            var isPortfolioMarginparametersVariable = this.handleOptionAndParams2(parameters, "cancelOrder", "papi", "portfolioMargin", false);
            isPortfolioMargin = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(0);
            parameters = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(1);
            Object isConditional = this.safeBoolN(parameters, new java.util.ArrayList<Object>(java.util.Arrays.asList("stop", "trigger", "conditional")));
            Object request = new java.util.HashMap<String, Object>() {{
                put( "symbol", Helpers.GetValue(market, "id") );
            }};
            Object clientOrderId = this.safeStringN(parameters, new java.util.ArrayList<Object>(java.util.Arrays.asList("origClientOrderId", "clientOrderId", "newClientStrategyId")));
            if (Helpers.isTrue(!Helpers.isEqual(clientOrderId, null)))
            {
                if (Helpers.isTrue(Helpers.GetValue(market, "option")))
                {
                    Helpers.addElementToObject(request, "clientOrderId", clientOrderId);
                } else
                {
                    if (Helpers.isTrue(Helpers.isTrue(isPortfolioMargin) && Helpers.isTrue(isConditional)))
                    {
                        Helpers.addElementToObject(request, "newClientStrategyId", clientOrderId);
                    } else
                    {
                        Helpers.addElementToObject(request, "origClientOrderId", clientOrderId);
                    }
                }
            } else
            {
                if (Helpers.isTrue(Helpers.isTrue(isPortfolioMargin) && Helpers.isTrue(isConditional)))
                {
                    Helpers.addElementToObject(request, "strategyId", id);
                } else
                {
                    Helpers.addElementToObject(request, "orderId", id);
                }
            }
            parameters = this.omit(parameters, new java.util.ArrayList<Object>(java.util.Arrays.asList("type", "origClientOrderId", "clientOrderId", "newClientStrategyId", "stop", "trigger", "conditional")));
            Object response = null;
            if (Helpers.isTrue(Helpers.GetValue(market, "option")))
            {
                response = (this.eapiPrivateDeleteOrder(this.extend(request, parameters))).join();
            } else if (Helpers.isTrue(Helpers.GetValue(market, "linear")))
            {
                if (Helpers.isTrue(isPortfolioMargin))
                {
                    if (Helpers.isTrue(isConditional))
                    {
                        response = (this.papiDeleteUmConditionalOrder(this.extend(request, parameters))).join();
                    } else
                    {
                        response = (this.papiDeleteUmOrder(this.extend(request, parameters))).join();
                    }
                } else
                {
                    response = (this.fapiPrivateDeleteOrder(this.extend(request, parameters))).join();
                }
            } else if (Helpers.isTrue(Helpers.GetValue(market, "inverse")))
            {
                if (Helpers.isTrue(isPortfolioMargin))
                {
                    if (Helpers.isTrue(isConditional))
                    {
                        response = (this.papiDeleteCmConditionalOrder(this.extend(request, parameters))).join();
                    } else
                    {
                        response = (this.papiDeleteCmOrder(this.extend(request, parameters))).join();
                    }
                } else
                {
                    response = (this.dapiPrivateDeleteOrder(this.extend(request, parameters))).join();
                }
            } else if (Helpers.isTrue(Helpers.isTrue(Helpers.isTrue((Helpers.isEqual(type, "margin"))) || Helpers.isTrue((!Helpers.isEqual(marginMode, null)))) || Helpers.isTrue(isPortfolioMargin)))
            {
                if (Helpers.isTrue(isPortfolioMargin))
                {
                    response = (this.papiDeleteMarginOrder(this.extend(request, parameters))).join();
                } else
                {
                    if (Helpers.isTrue(Helpers.isEqual(marginMode, "isolated")))
                    {
                        Helpers.addElementToObject(request, "isIsolated", true);
                    }
                    response = (this.sapiDeleteMarginOrder(this.extend(request, parameters))).join();
                }
            } else
            {
                response = (this.privateDeleteOrder(this.extend(request, parameters))).join();
            }
            return this.parseOrder(response, market);
        });

    }

    /**
     * @method
     * @name binance#cancelAllOrders
     * @description cancel all open orders in a market
     * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/trading-endpoints#cancel-all-open-orders-on-a-symbol-trade
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Cancel-All-Open-Orders
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Cancel-All-Open-Orders
     * @see https://developers.binance.com/docs/derivatives/option/trade/Cancel-all-Option-orders-on-specific-symbol
     * @see https://developers.binance.com/docs/margin_trading/trade/Margin-Account-Cancel-All-Open-Orders
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Cancel-All-UM-Open-Orders
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Cancel-All-UM-Open-Conditional-Orders
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Cancel-All-CM-Open-Orders
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Cancel-All-CM-Open-Conditional-Orders
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Cancel-Margin-Account-All-Open-Orders-on-a-Symbol
     * @param {string} symbol unified market symbol of the market to cancel orders in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.marginMode] 'cross' or 'isolated', for spot margin trading
     * @param {boolean} [params.portfolioMargin] set to true if you would like to cancel orders in a portfolio margin account
     * @param {boolean} [params.trigger] set to true if you would like to cancel portfolio margin account conditional orders
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> cancelAllOrders(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object symbol = Helpers.getArg(optionalArgs, 0, null);
            Object parameters = Helpers.getArg(optionalArgs, 1, new java.util.HashMap<String, Object>() {{}});
            if (Helpers.isTrue(Helpers.isEqual(symbol, null)))
            {
                throw new ArgumentsRequired((String)Helpers.add(this.id, " cancelAllOrders() requires a symbol argument")) ;
            }
            (this.loadMarkets()).join();
            Object market = this.market(symbol);
            Object request = new java.util.HashMap<String, Object>() {{
                put( "symbol", Helpers.GetValue(market, "id") );
            }};
            Object isPortfolioMargin = null;
            var isPortfolioMarginparametersVariable = this.handleOptionAndParams2(parameters, "cancelAllOrders", "papi", "portfolioMargin", false);
            isPortfolioMargin = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(0);
            parameters = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(1);
            Object isConditional = this.safeBoolN(parameters, new java.util.ArrayList<Object>(java.util.Arrays.asList("stop", "trigger", "conditional")));
            Object type = this.safeString(parameters, "type", Helpers.GetValue(market, "type"));
            parameters = this.omit(parameters, new java.util.ArrayList<Object>(java.util.Arrays.asList("type", "stop", "trigger", "conditional")));
            Object marginMode = null;
            var marginModeparametersVariable = this.handleMarginModeAndParams("cancelAllOrders", parameters);
            marginMode = ((java.util.List<Object>) marginModeparametersVariable).get(0);
            parameters = ((java.util.List<Object>) marginModeparametersVariable).get(1);
            Object response = null;
            if (Helpers.isTrue(Helpers.GetValue(market, "option")))
            {
                response = (this.eapiPrivateDeleteAllOpenOrders(this.extend(request, parameters))).join();
            } else if (Helpers.isTrue(Helpers.GetValue(market, "linear")))
            {
                if (Helpers.isTrue(isPortfolioMargin))
                {
                    if (Helpers.isTrue(isConditional))
                    {
                        response = (this.papiDeleteUmConditionalAllOpenOrders(this.extend(request, parameters))).join();
                    } else
                    {
                        response = (this.papiDeleteUmAllOpenOrders(this.extend(request, parameters))).join();
                    }
                } else
                {
                    response = (this.fapiPrivateDeleteAllOpenOrders(this.extend(request, parameters))).join();
                }
            } else if (Helpers.isTrue(Helpers.GetValue(market, "inverse")))
            {
                if (Helpers.isTrue(isPortfolioMargin))
                {
                    if (Helpers.isTrue(isConditional))
                    {
                        response = (this.papiDeleteCmConditionalAllOpenOrders(this.extend(request, parameters))).join();
                    } else
                    {
                        response = (this.papiDeleteCmAllOpenOrders(this.extend(request, parameters))).join();
                    }
                } else
                {
                    response = (this.dapiPrivateDeleteAllOpenOrders(this.extend(request, parameters))).join();
                }
            } else if (Helpers.isTrue(Helpers.isTrue(Helpers.isTrue((Helpers.isEqual(type, "margin"))) || Helpers.isTrue((!Helpers.isEqual(marginMode, null)))) || Helpers.isTrue(isPortfolioMargin)))
            {
                if (Helpers.isTrue(isPortfolioMargin))
                {
                    response = (this.papiDeleteMarginAllOpenOrders(this.extend(request, parameters))).join();
                } else
                {
                    if (Helpers.isTrue(Helpers.isEqual(marginMode, "isolated")))
                    {
                        Helpers.addElementToObject(request, "isIsolated", true);
                    }
                    response = (this.sapiDeleteMarginOpenOrders(this.extend(request, parameters))).join();
                }
            } else
            {
                response = (this.privateDeleteOpenOrders(this.extend(request, parameters))).join();
            }
            if (Helpers.isTrue(((response instanceof java.util.List) || (response.getClass().isArray()))))
            {
                return this.parseOrders(response, market);
            } else
            {
                final Object finalResponse = response;
                Object order = this.safeOrder(new java.util.HashMap<String, Object>() {{
                    put( "info", finalResponse );
                }});
                return new java.util.ArrayList<Object>(java.util.Arrays.asList(order));
            }
        });

    }

    /**
     * @method
     * @name binance#cancelOrders
     * @description cancel multiple orders
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Cancel-Multiple-Orders
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Cancel-Multiple-Orders
     * @param {string[]} ids order ids
     * @param {string} [symbol] unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string[]} [params.clientOrderIds] alternative to ids, array of client order ids
     *
     * EXCHANGE SPECIFIC PARAMETERS
     * @param {string[]} [params.origClientOrderIdList] max length 10 e.g. ["my_id_1","my_id_2"], encode the double quotes. No space after comma
     * @param {int[]} [params.recvWindow]
     * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> cancelOrders(Object ids, Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object symbol = Helpers.getArg(optionalArgs, 0, null);
            Object parameters = Helpers.getArg(optionalArgs, 1, new java.util.HashMap<String, Object>() {{}});
            if (Helpers.isTrue(Helpers.isEqual(symbol, null)))
            {
                throw new ArgumentsRequired((String)Helpers.add(this.id, " cancelOrders() requires a symbol argument")) ;
            }
            (this.loadMarkets()).join();
            Object market = this.market(symbol);
            if (!Helpers.isTrue(Helpers.GetValue(market, "contract")))
            {
                throw new BadRequest((String)Helpers.add(this.id, " cancelOrders is only supported for swap markets.")) ;
            }
            Object request = new java.util.HashMap<String, Object>() {{
                put( "symbol", Helpers.GetValue(market, "id") );
            }};
            Object origClientOrderIdList = this.safeList2(parameters, "origClientOrderIdList", "clientOrderIds");
            if (Helpers.isTrue(!Helpers.isEqual(origClientOrderIdList, null)))
            {
                parameters = this.omit(parameters, new java.util.ArrayList<Object>(java.util.Arrays.asList("clientOrderIds")));
                Helpers.addElementToObject(request, "origClientOrderIdList", origClientOrderIdList);
            } else
            {
                Helpers.addElementToObject(request, "orderidlist", ids);
            }
            Object response = null;
            if (Helpers.isTrue(Helpers.GetValue(market, "linear")))
            {
                response = (this.fapiPrivateDeleteBatchOrders(this.extend(request, parameters))).join();
            } else if (Helpers.isTrue(Helpers.GetValue(market, "inverse")))
            {
                response = (this.dapiPrivateDeleteBatchOrders(this.extend(request, parameters))).join();
            }
            //
            //    [
            //        {
            //            "clientOrderId": "myOrder1",
            //            "cumQty": "0",
            //            "cumQuote": "0",
            //            "executedQty": "0",
            //            "orderId": 283194212,
            //            "origQty": "11",
            //            "origType": "TRAILING_STOP_MARKET",
            //            "price": "0",
            //            "reduceOnly": false,
            //            "side": "BUY",
            //            "positionSide": "SHORT",
            //            "status": "CANCELED",
            //            "stopPrice": "9300",                  // please ignore when order type is TRAILING_STOP_MARKET
            //            "closePosition": false,               // if Close-All
            //            "symbol": "BTCUSDT",
            //            "timeInForce": "GTC",
            //            "type": "TRAILING_STOP_MARKET",
            //            "activatePrice": "9020",              // activation price, only return with TRAILING_STOP_MARKET order
            //            "priceRate": "0.3",                   // callback rate, only return with TRAILING_STOP_MARKET order
            //            "updateTime": 1571110484038,
            //            "workingType": "CONTRACT_PRICE",
            //            "priceProtect": false,                // if conditional order trigger is protected
            //            "priceMatch": "NONE",                 // price match mode
            //            "selfTradePreventionMode": "NONE",    // self trading preventation mode
            //            "goodTillDate": 0                     // order pre-set auot cancel time for TIF GTD order
            //        },
            //        {
            //            "code": -2011,
            //            "msg": "Unknown order sent."
            //        }
            //    ]
            //
            return this.parseOrders(response, market);
        });

    }

    /**
     * @method
     * @name binance#fetchOrderTrades
     * @description fetch all the trades made from a single order
     * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/account-endpoints#account-trade-list-user_data
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Account-Trade-List
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Account-Trade-List
     * @see https://developers.binance.com/docs/margin_trading/trade/Query-Margin-Account-Trade-List
     * @param {string} id order id
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchOrderTrades(Object id, Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object symbol = Helpers.getArg(optionalArgs, 0, null);
            Object since = Helpers.getArg(optionalArgs, 1, null);
            Object limit = Helpers.getArg(optionalArgs, 2, null);
            Object parameters = Helpers.getArg(optionalArgs, 3, new java.util.HashMap<String, Object>() {{}});
            if (Helpers.isTrue(Helpers.isEqual(symbol, null)))
            {
                throw new ArgumentsRequired((String)Helpers.add(this.id, " fetchOrderTrades() requires a symbol argument")) ;
            }
            (this.loadMarkets()).join();
            Object market = this.market(symbol);
            Object type = this.safeString(parameters, "type", Helpers.GetValue(market, "type"));
            parameters = this.omit(parameters, "type");
            if (Helpers.isTrue(!Helpers.isEqual(type, "spot")))
            {
                throw new NotSupported((String)Helpers.add(this.id, " fetchOrderTrades() supports spot markets only")) ;
            }
            Object request = new java.util.HashMap<String, Object>() {{
                put( "orderId", id );
            }};
            return (this.fetchMyTrades(symbol, since, limit, this.extend(request, parameters))).join();
        });

    }

    /**
     * @method
     * @name binance#fetchMyTrades
     * @description fetch all trades made by the user
     * @see https://developers.binance.com/docs/binance-spot-api-docs/rest-api/account-endpoints#account-trade-list-user_data
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Account-Trade-List
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Account-Trade-List
     * @see https://developers.binance.com/docs/margin_trading/trade/Query-Margin-Account-Trade-List
     * @see https://developers.binance.com/docs/derivatives/option/trade/Account-Trade-List
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/UM-Account-Trade-List
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/CM-Account-Trade-List
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @param {int} [params.until] the latest time in ms to fetch entries for
     * @param {boolean} [params.portfolioMargin] set to true if you would like to fetch trades for a portfolio margin account
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchMyTrades(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object symbol = Helpers.getArg(optionalArgs, 0, null);
            Object since = Helpers.getArg(optionalArgs, 1, null);
            Object limit = Helpers.getArg(optionalArgs, 2, null);
            Object parameters = Helpers.getArg(optionalArgs, 3, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object paginate = false;
            var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchMyTrades", "paginate");
            paginate = ((java.util.List<Object>) paginateparametersVariable).get(0);
            parameters = ((java.util.List<Object>) paginateparametersVariable).get(1);
            if (Helpers.isTrue(paginate))
            {
                return (this.fetchPaginatedCallDynamic("fetchMyTrades", symbol, since, limit, parameters)).join();
            }
            Object request = new java.util.HashMap<String, Object>() {{}};
            Object market = null;
            Object type = null;
            Object marginMode = null;
            if (Helpers.isTrue(!Helpers.isEqual(symbol, null)))
            {
                market = this.market(symbol);
                Helpers.addElementToObject(request, "symbol", Helpers.GetValue(market, "id"));
            }
            var typeparametersVariable = this.handleMarketTypeAndParams("fetchMyTrades", market, parameters);
            type = ((java.util.List<Object>) typeparametersVariable).get(0);
            parameters = ((java.util.List<Object>) typeparametersVariable).get(1);
            Object endTime = this.safeInteger2(parameters, "until", "endTime");
            if (Helpers.isTrue(!Helpers.isEqual(since, null)))
            {
                Object startTime = since;
                Helpers.addElementToObject(request, "startTime", startTime);
                // If startTime and endTime are both not sent, then the last 7 days' data will be returned.
                // The time between startTime and endTime cannot be longer than 7 days.
                // The parameter fromId cannot be sent with startTime or endTime.
                Object currentTimestamp = this.milliseconds();
                Object oneWeek = Helpers.multiply(Helpers.multiply(Helpers.multiply(Helpers.multiply(7, 24), 60), 60), 1000);
                if (Helpers.isTrue(Helpers.isGreaterThanOrEqual((Helpers.subtract(currentTimestamp, startTime)), oneWeek)))
                {
                    if (Helpers.isTrue(Helpers.isTrue((Helpers.isEqual(endTime, null))) && Helpers.isTrue(Helpers.GetValue(market, "linear"))))
                    {
                        endTime = this.sum(startTime, oneWeek);
                        endTime = Helpers.mathMin(endTime, currentTimestamp);
                    }
                }
            }
            if (Helpers.isTrue(!Helpers.isEqual(endTime, null)))
            {
                Helpers.addElementToObject(request, "endTime", endTime);
                parameters = this.omit(parameters, new java.util.ArrayList<Object>(java.util.Arrays.asList("endTime", "until")));
            }
            if (Helpers.isTrue(!Helpers.isEqual(limit, null)))
            {
                if (Helpers.isTrue(Helpers.isTrue((Helpers.isEqual(type, "option"))) || Helpers.isTrue(Helpers.GetValue(market, "contract"))))
                {
                    limit = Helpers.mathMin(limit, 1000); // above 1000, returns error
                }
                Helpers.addElementToObject(request, "limit", limit);
            }
            Object response = null;
            if (Helpers.isTrue(Helpers.isEqual(type, "option")))
            {
                response = (this.eapiPrivateGetUserTrades(this.extend(request, parameters))).join();
            } else
            {
                if (Helpers.isTrue(Helpers.isEqual(symbol, null)))
                {
                    throw new ArgumentsRequired((String)Helpers.add(this.id, " fetchMyTrades() requires a symbol argument")) ;
                }
                var marginModeparametersVariable = this.handleMarginModeAndParams("fetchMyTrades", parameters);
                marginMode = ((java.util.List<Object>) marginModeparametersVariable).get(0);
                parameters = ((java.util.List<Object>) marginModeparametersVariable).get(1);
                Object isPortfolioMargin = null;
                var isPortfolioMarginparametersVariable = this.handleOptionAndParams2(parameters, "fetchMyTrades", "papi", "portfolioMargin", false);
                isPortfolioMargin = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(0);
                parameters = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(1);
                if (Helpers.isTrue(Helpers.isTrue(Helpers.isEqual(type, "spot")) || Helpers.isTrue(Helpers.isEqual(type, "margin"))))
                {
                    if (Helpers.isTrue(isPortfolioMargin))
                    {
                        response = (this.papiGetMarginMyTrades(this.extend(request, parameters))).join();
                    } else if (Helpers.isTrue(Helpers.isTrue((Helpers.isEqual(type, "margin"))) || Helpers.isTrue((!Helpers.isEqual(marginMode, null)))))
                    {
                        if (Helpers.isTrue(Helpers.isEqual(marginMode, "isolated")))
                        {
                            Helpers.addElementToObject(request, "isIsolated", true);
                        }
                        response = (this.sapiGetMarginMyTrades(this.extend(request, parameters))).join();
                    } else
                    {
                        response = (this.privateGetMyTrades(this.extend(request, parameters))).join();
                    }
                } else if (Helpers.isTrue(Helpers.GetValue(market, "linear")))
                {
                    if (Helpers.isTrue(isPortfolioMargin))
                    {
                        response = (this.papiGetUmUserTrades(this.extend(request, parameters))).join();
                    } else
                    {
                        response = (this.fapiPrivateGetUserTrades(this.extend(request, parameters))).join();
                    }
                } else if (Helpers.isTrue(Helpers.GetValue(market, "inverse")))
                {
                    if (Helpers.isTrue(isPortfolioMargin))
                    {
                        response = (this.papiGetCmUserTrades(this.extend(request, parameters))).join();
                    } else
                    {
                        response = (this.dapiPrivateGetUserTrades(this.extend(request, parameters))).join();
                    }
                }
            }
            //
            // spot trade
            //
            //     [
            //         {
            //             "symbol": "BNBBTC",
            //             "id": 28457,
            //             "orderId": 100234,
            //             "price": "4.00000100",
            //             "qty": "12.00000000",
            //             "commission": "10.10000000",
            //             "commissionAsset": "BNB",
            //             "time": 1499865549590,
            //             "isBuyer": true,
            //             "isMaker": false,
            //             "isBestMatch": true,
            //         }
            //     ]
            //
            // futures trade
            //
            //     [
            //         {
            //             "accountId": 20,
            //             "buyer": False,
            //             "commission": "-0.07819010",
            //             "commissionAsset": "USDT",
            //             "counterPartyId": 653,
            //             "id": 698759,
            //             "maker": False,
            //             "orderId": 25851813,
            //             "price": "7819.01",
            //             "qty": "0.002",
            //             "quoteQty": "0.01563",
            //             "realizedPnl": "-0.91539999",
            //             "side": "SELL",
            //             "symbol": "BTCUSDT",
            //             "time": 1569514978020
            //         }
            //     ]
            //
            // options (eapi)
            //
            //     [
            //         {
            //             "id": 1125899906844226012,
            //             "tradeId": 73,
            //             "orderId": 4638761100843040768,
            //             "symbol": "ETH-230211-1500-C",
            //             "price": "18.70000000",
            //             "quantity": "-0.57000000",
            //             "fee": "0.17305890",
            //             "realizedProfit": "-3.53400000",
            //             "side": "SELL",
            //             "type": "LIMIT",
            //             "volatility": "0.30000000",
            //             "liquidity": "MAKER",
            //             "time": 1676085216845,
            //             "priceScale": 1,
            //             "quantityScale": 2,
            //             "optionSide": "CALL",
            //             "quoteAsset": "USDT"
            //         }
            //     ]
            //
            // linear portfolio margin
            //
            //     [
            //         {
            //             "symbol": "BTCUSDT",
            //             "id": 4575108247,
            //             "orderId": 261942655610,
            //             "side": "SELL",
            //             "price": "47263.40",
            //             "qty": "0.010",
            //             "realizedPnl": "27.38400000",
            //             "marginAsset": "USDT",
            //             "quoteQty": "472.63",
            //             "commission": "0.18905360",
            //             "commissionAsset": "USDT",
            //             "time": 1707530039409,
            //             "buyer": false,
            //             "maker": false,
            //             "positionSide": "LONG"
            //         }
            //     ]
            //
            // inverse portfolio margin
            //
            //     [
            //         {
            //             "symbol": "ETHUSD_PERP",
            //             "id": 701907838,
            //             "orderId": 71548909034,
            //             "pair": "ETHUSD",
            //             "side": "SELL",
            //             "price": "2498.15",
            //             "qty": "1",
            //             "realizedPnl": "0.00012517",
            //             "marginAsset": "ETH",
            //             "baseQty": "0.00400296",
            //             "commission": "0.00000160",
            //             "commissionAsset": "ETH",
            //             "time": 1707530317519,
            //             "positionSide": "LONG",
            //             "buyer": false,
            //             "maker": false
            //         }
            //     ]
            //
            // spot margin portfolio margin
            //
            //     [
            //         {
            //             "symbol": "ADAUSDT",
            //             "id": 470227543,
            //             "orderId": 4421170947,
            //             "price": "0.53880000",
            //             "qty": "10.00000000",
            //             "quoteQty": "5.38800000",
            //             "commission": "0.00538800",
            //             "commissionAsset": "USDT",
            //             "time": 1707545780522,
            //             "isBuyer": false,
            //             "isMaker": false,
            //             "isBestMatch": true
            //         }
            //     ]
            //
            return this.parseTrades(response, market, since, limit);
        });

    }

    /**
     * @method
     * @name binance#fetchMyDustTrades
     * @description fetch all dust trades made by the user
     * @see https://developers.binance.com/docs/wallet/asset/dust-log
     * @param {string} symbol not used by binance fetchMyDustTrades ()
     * @param {int} [since] the earliest time in ms to fetch my dust trades for
     * @param {int} [limit] the maximum number of dust trades to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.type] 'spot' or 'margin', default spot
     * @returns {object[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchMyDustTrades(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            //
            // Binance provides an opportunity to trade insignificant (i.e. non-tradable and non-withdrawable)
            // token leftovers (of any asset) into `BNB` coin which in turn can be used to pay trading fees with it.
            // The corresponding trades history is called the `Dust Log` and can be requested via the following end-point:
            // https://github.com/binance-exchange/binance-official-api-docs/blob/master/wapi-api.md#dustlog-user_data
            //
            Object symbol = Helpers.getArg(optionalArgs, 0, null);
            Object since = Helpers.getArg(optionalArgs, 1, null);
            Object limit = Helpers.getArg(optionalArgs, 2, null);
            Object parameters = Helpers.getArg(optionalArgs, 3, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object request = new java.util.HashMap<String, Object>() {{}};
            if (Helpers.isTrue(!Helpers.isEqual(since, null)))
            {
                Helpers.addElementToObject(request, "startTime", since);
                Helpers.addElementToObject(request, "endTime", this.sum(since, 7776000000L));
            }
            Object accountType = this.safeStringUpper(parameters, "type");
            parameters = this.omit(parameters, "type");
            if (Helpers.isTrue(!Helpers.isEqual(accountType, null)))
            {
                Helpers.addElementToObject(request, "accountType", accountType);
            }
            Object response = (this.sapiGetAssetDribblet(this.extend(request, parameters))).join();
            //     {
            //       "total": "4",
            //       "userAssetDribblets": [
            //         {
            //           "operateTime": "1627575731000",
            //           "totalServiceChargeAmount": "0.00001453",
            //           "totalTransferedAmount": "0.00072693",
            //           "transId": "70899815863",
            //           "userAssetDribbletDetails": [
            //             {
            //               "fromAsset": "LTC",
            //               "amount": "0.000006",
            //               "transferedAmount": "0.00000267",
            //               "serviceChargeAmount": "0.00000005",
            //               "operateTime": "1627575731000",
            //               "transId": "70899815863"
            //             },
            //             {
            //               "fromAsset": "GBP",
            //               "amount": "0.15949157",
            //               "transferedAmount": "0.00072426",
            //               "serviceChargeAmount": "0.00001448",
            //               "operateTime": "1627575731000",
            //               "transId": "70899815863"
            //             }
            //           ]
            //         },
            //       ]
            //     }
            Object results = this.safeList(response, "userAssetDribblets", new java.util.ArrayList<Object>(java.util.Arrays.asList()));
            Object rows = this.safeInteger(response, "total", 0);
            Object data = new java.util.ArrayList<Object>(java.util.Arrays.asList());
            for (var i = 0; Helpers.isLessThan(i, rows); i++)
            {
                Object logs = this.safeList(Helpers.GetValue(results, i), "userAssetDribbletDetails", new java.util.ArrayList<Object>(java.util.Arrays.asList()));
                for (var j = 0; Helpers.isLessThan(j, Helpers.getArrayLength(logs)); j++)
                {
                    Helpers.addElementToObject(Helpers.GetValue(logs, j), "isDustTrade", true);
                    ((java.util.List<Object>)data).add(Helpers.GetValue(logs, j));
                }
            }
            Object trades = this.parseTrades(data, null, since, limit);
            return this.filterBySinceLimit(trades, since, limit);
        });

    }

    public Object parseDustTrade(Object trade, Object... optionalArgs)
    {
        //
        //     {
        //       "fromAsset": "USDT",
        //       "amount": "0.009669",
        //       "transferedAmount": "0.00002992",
        //       "serviceChargeAmount": "0.00000059",
        //       "operateTime": "1628076010000",
        //       "transId": "71416578712",
        //       "isDustTrade": true
        //     }
        //
        Object market = Helpers.getArg(optionalArgs, 0, null);
        Object orderId = this.safeString(trade, "transId");
        Object timestamp = this.safeInteger(trade, "operateTime");
        Object currencyId = this.safeString(trade, "fromAsset");
        Object tradedCurrency = this.safeCurrencyCode(currencyId);
        Object bnb = this.currency("BNB");
        Object earnedCurrency = Helpers.GetValue(bnb, "code");
        Object applicantSymbol = Helpers.add(Helpers.add(earnedCurrency, "/"), tradedCurrency);
        Object tradedCurrencyIsQuote = false;
        if (Helpers.isTrue(Helpers.inOp(this.markets, applicantSymbol)))
        {
            tradedCurrencyIsQuote = true;
        }
        Object feeCostString = this.safeString(trade, "serviceChargeAmount");
        final Object finalEarnedCurrency = earnedCurrency;
        Object fee = new java.util.HashMap<String, Object>() {{
            put( "currency", finalEarnedCurrency );
            put( "cost", Binance.this.parseNumber(feeCostString) );
        }};
        Object symbol = null;
        Object amountString = null;
        Object costString = null;
        Object side = null;
        if (Helpers.isTrue(tradedCurrencyIsQuote))
        {
            symbol = applicantSymbol;
            amountString = this.safeString(trade, "transferedAmount");
            costString = this.safeString(trade, "amount");
            side = "buy";
        } else
        {
            symbol = Helpers.add(Helpers.add(tradedCurrency, "/"), earnedCurrency);
            amountString = this.safeString(trade, "amount");
            costString = this.safeString(trade, "transferedAmount");
            side = "sell";
        }
        Object priceString = null;
        if (Helpers.isTrue(!Helpers.isEqual(costString, null)))
        {
            if (Helpers.isTrue(amountString))
            {
                priceString = Precise.stringDiv(costString, amountString);
            }
        }
        Object id = null;
        Object amount = this.parseNumber(amountString);
        Object price = this.parseNumber(priceString);
        Object cost = this.parseNumber(costString);
        Object type = null;
        Object takerOrMaker = null;
        final Object finalSymbol = symbol;
        final Object finalSide = side;
        return new java.util.HashMap<String, Object>() {{
            put( "id", id );
            put( "timestamp", timestamp );
            put( "datetime", Binance.this.iso8601(timestamp) );
            put( "symbol", finalSymbol );
            put( "order", orderId );
            put( "type", type );
            put( "takerOrMaker", takerOrMaker );
            put( "side", finalSide );
            put( "amount", amount );
            put( "price", price );
            put( "cost", cost );
            put( "fee", fee );
            put( "info", trade );
        }};
    }

    /**
     * @method
     * @name binance#fetchDeposits
     * @description fetch all deposits made to an account
     * @see https://developers.binance.com/docs/wallet/capital/deposite-history
     * @see https://developers.binance.com/docs/fiat/rest-api/Get-Fiat-Deposit-Withdraw-History
     * @param {string} code unified currency code
     * @param {int} [since] the earliest time in ms to fetch deposits for
     * @param {int} [limit] the maximum number of deposits structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {bool} [params.fiat] if true, only fiat deposits will be returned
     * @param {int} [params.until] the latest time in ms to fetch entries for
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchDeposits(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object code = Helpers.getArg(optionalArgs, 0, null);
            Object since = Helpers.getArg(optionalArgs, 1, null);
            Object limit = Helpers.getArg(optionalArgs, 2, null);
            Object parameters = Helpers.getArg(optionalArgs, 3, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object paginate = false;
            var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchDeposits", "paginate");
            paginate = ((java.util.List<Object>) paginateparametersVariable).get(0);
            parameters = ((java.util.List<Object>) paginateparametersVariable).get(1);
            if (Helpers.isTrue(paginate))
            {
                return (this.fetchPaginatedCallDynamic("fetchDeposits", code, since, limit, parameters)).join();
            }
            Object currency = null;
            Object response = null;
            Object request = new java.util.HashMap<String, Object>() {{}};
            Object legalMoney = this.safeDict(this.options, "legalMoney", new java.util.HashMap<String, Object>() {{}});
            Object fiatOnly = this.safeBool(parameters, "fiat", false);
            parameters = this.omit(parameters, "fiatOnly");
            Object until = this.safeInteger(parameters, "until");
            parameters = this.omit(parameters, "until");
            if (Helpers.isTrue(Helpers.isTrue(fiatOnly) || Helpers.isTrue((Helpers.inOp(legalMoney, code)))))
            {
                if (Helpers.isTrue(!Helpers.isEqual(code, null)))
                {
                    currency = this.currency(code);
                }
                Helpers.addElementToObject(request, "transactionType", 0);
                if (Helpers.isTrue(!Helpers.isEqual(since, null)))
                {
                    Helpers.addElementToObject(request, "beginTime", since);
                }
                if (Helpers.isTrue(!Helpers.isEqual(until, null)))
                {
                    Helpers.addElementToObject(request, "endTime", until);
                }
                Object raw = (this.sapiGetFiatOrders(this.extend(request, parameters))).join();
                response = this.safeList(raw, "data", new java.util.ArrayList<Object>(java.util.Arrays.asList()));
            } else
            {
                if (Helpers.isTrue(!Helpers.isEqual(code, null)))
                {
                    currency = this.currency(code);
                    Helpers.addElementToObject(request, "coin", Helpers.GetValue(currency, "id"));
                }
                if (Helpers.isTrue(!Helpers.isEqual(since, null)))
                {
                    Helpers.addElementToObject(request, "startTime", since);
                    // max 3 months range https://github.com/ccxt/ccxt/issues/6495
                    Object endTime = this.sum(since, 7776000000L);
                    if (Helpers.isTrue(!Helpers.isEqual(until, null)))
                    {
                        endTime = Helpers.mathMin(endTime, until);
                    }
                    Helpers.addElementToObject(request, "endTime", endTime);
                }
                if (Helpers.isTrue(!Helpers.isEqual(limit, null)))
                {
                    Helpers.addElementToObject(request, "limit", limit);
                }
                response = (this.sapiGetCapitalDepositHisrec(this.extend(request, parameters))).join();
            }
            for (var i = 0; Helpers.isLessThan(i, Helpers.getArrayLength(response)); i++)
            {
                Helpers.addElementToObject(Helpers.GetValue(response, i), "type", "deposit");
            }
            return this.parseTransactions(response, currency, since, limit);
        });

    }

    /**
     * @method
     * @name binance#fetchWithdrawals
     * @description fetch all withdrawals made from an account
     * @see https://developers.binance.com/docs/wallet/capital/withdraw-history
     * @see https://developers.binance.com/docs/fiat/rest-api/Get-Fiat-Deposit-Withdraw-History
     * @param {string} code unified currency code
     * @param {int} [since] the earliest time in ms to fetch withdrawals for
     * @param {int} [limit] the maximum number of withdrawals structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {bool} [params.fiat] if true, only fiat withdrawals will be returned
     * @param {int} [params.until] the latest time in ms to fetch withdrawals for
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchWithdrawals(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object code = Helpers.getArg(optionalArgs, 0, null);
            Object since = Helpers.getArg(optionalArgs, 1, null);
            Object limit = Helpers.getArg(optionalArgs, 2, null);
            Object parameters = Helpers.getArg(optionalArgs, 3, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object paginate = false;
            var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchWithdrawals", "paginate");
            paginate = ((java.util.List<Object>) paginateparametersVariable).get(0);
            parameters = ((java.util.List<Object>) paginateparametersVariable).get(1);
            if (Helpers.isTrue(paginate))
            {
                return (this.fetchPaginatedCallDynamic("fetchWithdrawals", code, since, limit, parameters)).join();
            }
            Object legalMoney = this.safeDict(this.options, "legalMoney", new java.util.HashMap<String, Object>() {{}});
            Object fiatOnly = this.safeBool(parameters, "fiat", false);
            parameters = this.omit(parameters, "fiatOnly");
            Object request = new java.util.HashMap<String, Object>() {{}};
            Object until = this.safeInteger(parameters, "until");
            if (Helpers.isTrue(!Helpers.isEqual(until, null)))
            {
                parameters = this.omit(parameters, "until");
                Helpers.addElementToObject(request, "endTime", until);
            }
            Object response = null;
            Object currency = null;
            if (Helpers.isTrue(Helpers.isTrue(fiatOnly) || Helpers.isTrue((Helpers.inOp(legalMoney, code)))))
            {
                if (Helpers.isTrue(!Helpers.isEqual(code, null)))
                {
                    currency = this.currency(code);
                }
                Helpers.addElementToObject(request, "transactionType", 1);
                if (Helpers.isTrue(!Helpers.isEqual(since, null)))
                {
                    Helpers.addElementToObject(request, "beginTime", since);
                }
                Object raw = (this.sapiGetFiatOrders(this.extend(request, parameters))).join();
                response = this.safeList(raw, "data", new java.util.ArrayList<Object>(java.util.Arrays.asList()));
            } else
            {
                if (Helpers.isTrue(!Helpers.isEqual(code, null)))
                {
                    currency = this.currency(code);
                    Helpers.addElementToObject(request, "coin", Helpers.GetValue(currency, "id"));
                }
                if (Helpers.isTrue(!Helpers.isEqual(since, null)))
                {
                    Helpers.addElementToObject(request, "startTime", since);
                    // max 3 months range https://github.com/ccxt/ccxt/issues/6495
                    Helpers.addElementToObject(request, "endTime", this.sum(since, 7776000000L));
                }
                if (Helpers.isTrue(!Helpers.isEqual(limit, null)))
                {
                    Helpers.addElementToObject(request, "limit", limit);
                }
                response = (this.sapiGetCapitalWithdrawHistory(this.extend(request, parameters))).join();
            }
            for (var i = 0; Helpers.isLessThan(i, Helpers.getArrayLength(response)); i++)
            {
                Helpers.addElementToObject(Helpers.GetValue(response, i), "type", "withdrawal");
            }
            return this.parseTransactions(response, currency, since, limit);
        });

    }

    public Object parseTransactionStatusByType(Object status, Object... optionalArgs)
    {
        Object type = Helpers.getArg(optionalArgs, 0, null);
        if (Helpers.isTrue(Helpers.isEqual(type, null)))
        {
            return status;
        }
        Object statusesByType = new java.util.HashMap<String, Object>() {{
            put( "deposit", new java.util.HashMap<String, Object>() {{
                put( "0", "pending" );
                put( "1", "ok" );
                put( "6", "ok" );
                put( "Processing", "pending" );
                put( "Failed", "failed" );
                put( "Successful", "ok" );
                put( "Refunding", "canceled" );
                put( "Refunded", "canceled" );
                put( "Refund Failed", "failed" );
            }} );
            put( "withdrawal", new java.util.HashMap<String, Object>() {{
                put( "0", "pending" );
                put( "1", "canceled" );
                put( "2", "pending" );
                put( "3", "failed" );
                put( "4", "pending" );
                put( "5", "failed" );
                put( "6", "ok" );
                put( "Processing", "pending" );
                put( "Failed", "failed" );
                put( "Successful", "ok" );
                put( "Refunding", "canceled" );
                put( "Refunded", "canceled" );
                put( "Refund Failed", "failed" );
            }} );
        }};
        Object statuses = this.safeDict(statusesByType, type, new java.util.HashMap<String, Object>() {{}});
        return this.safeString(statuses, status, status);
    }

    public Object parseTransaction(Object transaction, Object... optionalArgs)
    {
        //
        // fetchDeposits
        //
        //     {
        //       "amount": "4500",
        //       "coin": "USDT",
        //       "network": "BSC",
        //       "status": 1,
        //       "address": "0xc9c923c87347ca0f3451d6d308ce84f691b9f501",
        //       "addressTag": "",
        //       "txId": "Internal transfer 51376627901",
        //       "insertTime": 1618394381000,
        //       "transferType": 1,
        //       "confirmTimes": "1/15"
        //     }
        //
        // fetchWithdrawals
        //
        //     {
        //       "id": "69e53ad305124b96b43668ceab158a18",
        //       "amount": "28.75",
        //       "transactionFee": "0.25",
        //       "coin": "XRP",
        //       "status": 6,
        //       "address": "r3T75fuLjX51mmfb5Sk1kMNuhBgBPJsjza",
        //       "addressTag": "101286922",
        //       "txId": "19A5B24ED0B697E4F0E9CD09FCB007170A605BC93C9280B9E6379C5E6EF0F65A",
        //       "applyTime": "2021-04-15 12:09:16",
        //       "network": "XRP",
        //       "transferType": 0
        //     }
        //
        // fiat transaction
        // withdraw
        //     {
        //       "orderNo": "CJW684897551397171200",
        //       "fiatCurrency": "GBP",
        //       "indicatedAmount": "29.99",
        //       "amount": "28.49",
        //       "totalFee": "1.50",
        //       "method": "bank transfer",
        //       "status": "Successful",
        //       "createTime": 1614898701000,
        //       "updateTime": 1614898820000
        //     }
        //
        // deposit
        //     {
        //       "orderNo": "25ced37075c1470ba8939d0df2316e23",
        //       "fiatCurrency": "EUR",
        //       "transactionType": 0,
        //       "indicatedAmount": "15.00",
        //       "amount": "15.00",
        //       "totalFee": "0.00",
        //       "method": "card",
        //       "status": "Failed",
        //       "createTime": "1627501026000",
        //       "updateTime": "1627501027000"
        //     }
        //
        // withdraw
        //
        //    { id: "9a67628b16ba4988ae20d329333f16bc" }
        //
        Object currency = Helpers.getArg(optionalArgs, 0, null);
        Object id = this.safeString2(transaction, "id", "orderNo");
        Object address = this.safeString(transaction, "address");
        Object tag = this.safeString(transaction, "addressTag"); // set but unused
        if (Helpers.isTrue(!Helpers.isEqual(tag, null)))
        {
            if (Helpers.isTrue(Helpers.isLessThan(((String)tag).length(), 1)))
            {
                tag = null;
            }
        }
        Object txid = this.safeString(transaction, "txId");
        if (Helpers.isTrue(Helpers.isTrue((!Helpers.isEqual(txid, null))) && Helpers.isTrue((Helpers.isGreaterThanOrEqual(Helpers.getIndexOf(txid, "Internal transfer "), 0)))))
        {
            txid = Helpers.slice(txid, 18, null);
        }
        Object currencyId = this.safeString2(transaction, "coin", "fiatCurrency");
        Object code = this.safeCurrencyCode(currencyId, currency);
        Object timestamp = null;
        timestamp = this.safeInteger2(transaction, "insertTime", "createTime");
        if (Helpers.isTrue(Helpers.isEqual(timestamp, null)))
        {
            timestamp = this.parse8601(this.safeString(transaction, "applyTime"));
        }
        Object updated = this.safeInteger2(transaction, "successTime", "updateTime");
        Object type = this.safeString(transaction, "type");
        if (Helpers.isTrue(Helpers.isEqual(type, null)))
        {
            Object txType = this.safeString(transaction, "transactionType");
            if (Helpers.isTrue(!Helpers.isEqual(txType, null)))
            {
                type = ((Helpers.isTrue((Helpers.isEqual(txType, "0"))))) ? "deposit" : "withdrawal";
            }
            Object legalMoneyCurrenciesById = this.safeDict(this.options, "legalMoneyCurrenciesById");
            code = this.safeString(legalMoneyCurrenciesById, code, code);
        }
        Object status = this.parseTransactionStatusByType(this.safeString(transaction, "status"), type);
        Object amount = this.safeNumber(transaction, "amount");
        Object feeCost = this.safeNumber2(transaction, "transactionFee", "totalFee");
        Object fee = null;
        if (Helpers.isTrue(!Helpers.isEqual(feeCost, null)))
        {
            final Object finalCode = code;
            final Object finalFeeCost = feeCost;
            fee = new java.util.HashMap<String, Object>() {{
                put( "currency", finalCode );
                put( "cost", finalFeeCost );
            }};
        }
        Object internalInteger = this.safeInteger(transaction, "transferType");
        Object intern = null;
        if (Helpers.isTrue(!Helpers.isEqual(internalInteger, null)))
        {
            intern = ((Helpers.isTrue((!Helpers.isEqual(internalInteger, 0))))) ? true : false;
        }
        Object network = this.safeString(transaction, "network");
        final Object finalTxid = txid;
        final Object finalTimestamp = timestamp;
        final Object finalTag = tag;
        final Object finalType = type;
        final Object finalCode = code;
        final Object finalIntern = intern;
        final Object finalFee = fee;
        return new java.util.HashMap<String, Object>() {{
            put( "info", transaction );
            put( "id", id );
            put( "txid", finalTxid );
            put( "timestamp", finalTimestamp );
            put( "datetime", Binance.this.iso8601(finalTimestamp) );
            put( "network", network );
            put( "address", address );
            put( "addressTo", address );
            put( "addressFrom", null );
            put( "tag", finalTag );
            put( "tagTo", finalTag );
            put( "tagFrom", null );
            put( "type", finalType );
            put( "amount", amount );
            put( "currency", finalCode );
            put( "status", status );
            put( "updated", updated );
            put( "internal", finalIntern );
            put( "comment", null );
            put( "fee", finalFee );
        }};
    }

    public Object parseTransferStatus(Object status)
    {
        Object statuses = new java.util.HashMap<String, Object>() {{
            put( "CONFIRMED", "ok" );
        }};
        return this.safeString(statuses, status, status);
    }

    public Object parseTransfer(Object transfer, Object... optionalArgs)
    {
        //
        // transfer
        //
        //     {
        //         "tranId":13526853623
        //     }
        //
        // fetchTransfers
        //
        //     {
        //         "timestamp": 1614640878000,
        //         "asset": "USDT",
        //         "amount": "25",
        //         "type": "MAIN_UMFUTURE",
        //         "status": "CONFIRMED",
        //         "tranId": 43000126248
        //     }
        //
        //     {
        //             "orderType": "C2C", // EnumPAY(C2B Merchant Acquiring Payment), PAY_REFUND(C2B Merchant Acquiring Payment,refund), C2C(C2C Transfer Payment),CRYPTO_BOX(Crypto box), CRYPTO_BOX_RF(Crypto Box, refund), C2C_HOLDING(Transfer to new Binance user), C2C_HOLDING_RF(Transfer to new Binance user,refund), PAYOUT(B2C Disbursement Payment), REMITTANCESend cash)
        //             "transactionId": "M_P_71505104267788288",
        //             "transactionTime": 1610090460133, //trade timestamp
        //             "amount": "23.72469206", //order amount(up to 8 decimal places), positive is income, negative is expenditure
        //             "currency": "BNB",
        //             "walletType": 1, //main wallet type, 1 for funding wallet, 2 for spot wallet, 3 for fiat wallet, 4 or 6 for card payment, 5 for earn wallet
        //             "walletTypes": [1,2], //array formatthere are multiple values when using combination payment
        //             "fundsDetail": [ // details
        //                     {
        //                         "currency": "USDT", //asset
        //                         "amount": "1.2",
        //                         "walletAssetCost":[ //details of asset cost per wallet
        //                             {"1":"0.6"},
        //                             {"2":"0.6"}
        //                         ]
        //                     },
        //                     {
        //                         "currency": "ETH",
        //                         "amount": "0.0001",
        //                         "walletAssetCost":[
        //                             {"1":"0.00005"},
        //                             {"2":"0.00005"}
        //                         ]
        //                     }
        //                 ],
        //             "payerInfo":{
        //                     "name":"Jack", //nickname or merchant name
        //                     "type":"USER", //account typeUSER for personalMERCHANT for merchant
        //                     "binanceId":"12345678", //binance uid
        //                     "accountId":"67736251" //binance pay id
        //                 },
        //             "receiverInfo":{
        //                     "name":"Alan", //nickname or merchant name
        //                     "type":"MERCHANT", //account typeUSER for personalMERCHANT for merchant
        //                     "email":"alan@binance.com", //email
        //                     "binanceId":"34355667", //binance uid
        //                     "accountId":"21326891", //binance pay id
        //                     "countryCode":"1", //International area code
        //                     "phoneNumber":"8057651210",
        //                     "mobileCode":"US", //country code
        //                     "extend":[ //extension field
        //                             "institutionName": "",
        //                             "cardNumber": "",
        //                             "digitalWalletId": ""
        //                     ]
        //                 }
        //             }
        Object currency = Helpers.getArg(optionalArgs, 0, null);
        Object id = this.safeString2(transfer, "tranId", "transactionId");
        Object currencyId = this.safeString2(transfer, "asset", "currency");
        Object code = this.safeCurrencyCode(currencyId, currency);
        Object amount = this.safeNumber(transfer, "amount");
        Object type = this.safeString(transfer, "type");
        Object fromAccount = null;
        Object toAccount = null;
        Object accountsById = this.safeDict(this.options, "accountsById", new java.util.HashMap<String, Object>() {{}});
        if (Helpers.isTrue(!Helpers.isEqual(type, null)))
        {
            Object parts = new java.util.ArrayList<Object>(java.util.Arrays.asList(((String)type).split((String)"_")));
            fromAccount = this.safeValue(parts, 0);
            toAccount = this.safeValue(parts, 1);
            fromAccount = this.safeString(accountsById, fromAccount, fromAccount);
            toAccount = this.safeString(accountsById, toAccount, toAccount);
        }
        Object walletType = this.safeInteger(transfer, "walletType");
        if (Helpers.isTrue(!Helpers.isEqual(walletType, null)))
        {
            Object payer = this.safeDict(transfer, "payerInfo", new java.util.HashMap<String, Object>() {{}});
            Object receiver = this.safeDict(transfer, "receiverInfo", new java.util.HashMap<String, Object>() {{}});
            fromAccount = this.safeString(payer, "accountId");
            toAccount = this.safeString(receiver, "accountId");
        }
        Object timestamp = this.safeInteger2(transfer, "timestamp", "transactionTime");
        Object status = this.parseTransferStatus(this.safeString(transfer, "status"));
        final Object finalFromAccount = fromAccount;
        final Object finalToAccount = toAccount;
        return new java.util.HashMap<String, Object>() {{
            put( "info", transfer );
            put( "id", id );
            put( "timestamp", timestamp );
            put( "datetime", Binance.this.iso8601(timestamp) );
            put( "currency", code );
            put( "amount", amount );
            put( "fromAccount", finalFromAccount );
            put( "toAccount", finalToAccount );
            put( "status", status );
        }};
    }

    public Object parseIncome(Object income, Object... optionalArgs)
    {
        //
        //     {
        //       "symbol": "ETHUSDT",
        //       "incomeType": "FUNDING_FEE",
        //       "income": "0.00134317",
        //       "asset": "USDT",
        //       "time": "1621584000000",
        //       "info": "FUNDING_FEE",
        //       "tranId": "4480321991774044580",
        //       "tradeId": ""
        //     }
        //
        Object market = Helpers.getArg(optionalArgs, 0, null);
        Object marketId = this.safeString(income, "symbol");
        Object currencyId = this.safeString(income, "asset");
        Object timestamp = this.safeInteger(income, "time");
        return new java.util.HashMap<String, Object>() {{
            put( "info", income );
            put( "symbol", Binance.this.safeSymbol(marketId, market, null, "swap") );
            put( "code", Binance.this.safeCurrencyCode(currencyId) );
            put( "timestamp", timestamp );
            put( "datetime", Binance.this.iso8601(timestamp) );
            put( "id", Binance.this.safeString(income, "tranId") );
            put( "amount", Binance.this.safeNumber(income, "income") );
        }};
    }

    /**
     * @method
     * @name binance#transfer
     * @description transfer currency internally between wallets on the same account
     * @see https://developers.binance.com/docs/wallet/asset/user-universal-transfer
     * @param {string} code unified currency code
     * @param {float} amount amount to transfer
     * @param {string} fromAccount account to transfer from
     * @param {string} toAccount account to transfer to
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.type] exchange specific transfer type
     * @param {string} [params.symbol] the unified symbol, required for isolated margin transfers
     * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> transfer(Object code, Object amount, Object fromAccount, Object toAccount, Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object parameters = Helpers.getArg(optionalArgs, 0, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object currency = this.currency(code);
            Object request = new java.util.HashMap<String, Object>() {{
                put( "asset", Helpers.GetValue(currency, "id") );
                put( "amount", Binance.this.currencyToPrecision(code, amount) );
            }};
            Helpers.addElementToObject(request, "type", this.safeString(parameters, "type"));
            parameters = this.omit(parameters, "type");
            if (Helpers.isTrue(Helpers.isEqual(Helpers.GetValue(request, "type"), null)))
            {
                Object symbol = this.safeString(parameters, "symbol");
                Object market = null;
                if (Helpers.isTrue(!Helpers.isEqual(symbol, null)))
                {
                    market = this.market(symbol);
                    parameters = this.omit(parameters, "symbol");
                }
                Object fromId = ((String)this.convertTypeToAccount(fromAccount)).toUpperCase();
                Object toId = ((String)this.convertTypeToAccount(toAccount)).toUpperCase();
                Object isolatedSymbol = null;
                if (Helpers.isTrue(!Helpers.isEqual(market, null)))
                {
                    isolatedSymbol = Helpers.GetValue(market, "id");
                }
                if (Helpers.isTrue(Helpers.isEqual(fromId, "ISOLATED")))
                {
                    if (Helpers.isTrue(Helpers.isEqual(symbol, null)))
                    {
                        throw new ArgumentsRequired((String)Helpers.add(Helpers.add(this.id, " transfer () requires params[\"symbol\"] when fromAccount is "), fromAccount)) ;
                    }
                }
                if (Helpers.isTrue(Helpers.isEqual(toId, "ISOLATED")))
                {
                    if (Helpers.isTrue(Helpers.isEqual(symbol, null)))
                    {
                        throw new ArgumentsRequired((String)Helpers.add(Helpers.add(this.id, " transfer () requires params[\"symbol\"] when toAccount is "), toAccount)) ;
                    }
                }
                Object accountsById = this.safeDict(this.options, "accountsById", new java.util.HashMap<String, Object>() {{}});
                Object fromIsolated = !Helpers.isTrue((Helpers.inOp(accountsById, fromId)));
                Object toIsolated = !Helpers.isTrue((Helpers.inOp(accountsById, toId)));
                if (Helpers.isTrue(Helpers.isTrue(fromIsolated) && Helpers.isTrue((Helpers.isEqual(market, null)))))
                {
                    isolatedSymbol = fromId; // allow user provide symbol as the from/to account
                }
                if (Helpers.isTrue(Helpers.isTrue(toIsolated) && Helpers.isTrue((Helpers.isEqual(market, null)))))
                {
                    isolatedSymbol = toId;
                }
                if (Helpers.isTrue(Helpers.isTrue(fromIsolated) || Helpers.isTrue(toIsolated)))
                {
                    Object fromFuture = Helpers.isTrue(Helpers.isEqual(fromId, "UMFUTURE")) || Helpers.isTrue(Helpers.isEqual(fromId, "CMFUTURE"));
                    Object toFuture = Helpers.isTrue(Helpers.isEqual(toId, "UMFUTURE")) || Helpers.isTrue(Helpers.isEqual(toId, "CMFUTURE"));
                    Object fromSpot = Helpers.isEqual(fromId, "MAIN");
                    Object toSpot = Helpers.isEqual(toId, "MAIN");
                    Object funding = Helpers.isTrue(Helpers.isEqual(fromId, "FUNDING")) || Helpers.isTrue(Helpers.isEqual(toId, "FUNDING"));
                    Object option = Helpers.isTrue(Helpers.isEqual(fromId, "OPTION")) || Helpers.isTrue(Helpers.isEqual(toId, "OPTION"));
                    Object prohibitedWithIsolated = Helpers.isTrue(Helpers.isTrue(Helpers.isTrue(fromFuture) || Helpers.isTrue(toFuture)) || Helpers.isTrue(funding)) || Helpers.isTrue(option);
                    if (Helpers.isTrue(Helpers.isTrue((Helpers.isTrue(fromIsolated) || Helpers.isTrue(toIsolated))) && Helpers.isTrue(prohibitedWithIsolated)))
                    {
                        throw new BadRequest((String)Helpers.add(Helpers.add(Helpers.add(Helpers.add(this.id, " transfer () does not allow transfers between "), fromAccount), " and "), toAccount)) ;
                    } else if (Helpers.isTrue(Helpers.isTrue(toSpot) && Helpers.isTrue(fromIsolated)))
                    {
                        fromId = "ISOLATED_MARGIN";
                        Helpers.addElementToObject(request, "fromSymbol", isolatedSymbol);
                    } else if (Helpers.isTrue(Helpers.isTrue(fromSpot) && Helpers.isTrue(toIsolated)))
                    {
                        toId = "ISOLATED_MARGIN";
                        Helpers.addElementToObject(request, "toSymbol", isolatedSymbol);
                    } else
                    {
                        if (Helpers.isTrue(Helpers.isTrue(fromIsolated) && Helpers.isTrue(toIsolated)))
                        {
                            Helpers.addElementToObject(request, "fromSymbol", fromId);
                            Helpers.addElementToObject(request, "toSymbol", toId);
                            fromId = "ISOLATEDMARGIN";
                            toId = "ISOLATEDMARGIN";
                        } else
                        {
                            if (Helpers.isTrue(fromIsolated))
                            {
                                Helpers.addElementToObject(request, "fromSymbol", isolatedSymbol);
                                fromId = "ISOLATEDMARGIN";
                            }
                            if (Helpers.isTrue(toIsolated))
                            {
                                Helpers.addElementToObject(request, "toSymbol", isolatedSymbol);
                                toId = "ISOLATEDMARGIN";
                            }
                        }
                    }
                    Helpers.addElementToObject(request, "type", Helpers.add(Helpers.add(fromId, "_"), toId));
                } else
                {
                    Helpers.addElementToObject(request, "type", Helpers.add(Helpers.add(fromId, "_"), toId));
                }
            }
            Object response = (this.sapiPostAssetTransfer(this.extend(request, parameters))).join();
            //
            //     {
            //         "tranId":13526853623
            //     }
            //
            return this.parseTransfer(response, currency);
        });

    }

    /**
     * @method
     * @name binance#fetchTransfers
     * @description fetch a history of internal transfers made on an account
     * @see https://developers.binance.com/docs/wallet/asset/query-user-universal-transfer
     * @param {string} code unified currency code of the currency transferred
     * @param {int} [since] the earliest time in ms to fetch transfers for
     * @param {int} [limit] the maximum number of transfers structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch transfers for
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @param {boolean} [params.internal] default false, when true will fetch pay trade history
     * @returns {object[]} a list of [transfer structures]{@link https://docs.ccxt.com/#/?id=transfer-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchTransfers(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object code = Helpers.getArg(optionalArgs, 0, null);
            Object since = Helpers.getArg(optionalArgs, 1, null);
            Object limit = Helpers.getArg(optionalArgs, 2, null);
            Object parameters = Helpers.getArg(optionalArgs, 3, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object intern = this.safeBool(parameters, "internal");
            parameters = this.omit(parameters, "internal");
            Object paginate = false;
            var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchTransfers", "paginate");
            paginate = ((java.util.List<Object>) paginateparametersVariable).get(0);
            parameters = ((java.util.List<Object>) paginateparametersVariable).get(1);
            if (Helpers.isTrue(Helpers.isTrue(paginate) && !Helpers.isTrue(intern)))
            {
                return (this.fetchPaginatedCallDynamic("fetchTransfers", code, since, limit, parameters)).join();
            }
            Object currency = null;
            if (Helpers.isTrue(!Helpers.isEqual(code, null)))
            {
                currency = this.currency(code);
            }
            Object request = new java.util.HashMap<String, Object>() {{}};
            Object limitKey = "limit";
            if (!Helpers.isTrue(intern))
            {
                Object defaultType = this.safeString2(this.options, "fetchTransfers", "defaultType", "spot");
                Object fromAccount = this.safeString(parameters, "fromAccount", defaultType);
                Object defaultTo = ((Helpers.isTrue((Helpers.isEqual(fromAccount, "future"))))) ? "spot" : "future";
                Object toAccount = this.safeString(parameters, "toAccount", defaultTo);
                Object type = this.safeString(parameters, "type");
                Object accountsByType = this.safeDict(this.options, "accountsByType", new java.util.HashMap<String, Object>() {{}});
                Object fromId = this.safeString(accountsByType, fromAccount);
                Object toId = this.safeString(accountsByType, toAccount);
                if (Helpers.isTrue(Helpers.isEqual(type, null)))
                {
                    if (Helpers.isTrue(Helpers.isEqual(fromId, null)))
                    {
                        Object keys = new java.util.ArrayList<Object>(((java.util.Map<String, Object>)accountsByType).keySet());
                        throw new ExchangeError((String)Helpers.add(Helpers.add(this.id, " fromAccount parameter must be one of "), String.join((String)", ", (java.util.List<String>)keys))) ;
                    }
                    if (Helpers.isTrue(Helpers.isEqual(toId, null)))
                    {
                        Object keys = new java.util.ArrayList<Object>(((java.util.Map<String, Object>)accountsByType).keySet());
                        throw new ExchangeError((String)Helpers.add(Helpers.add(this.id, " toAccount parameter must be one of "), String.join((String)", ", (java.util.List<String>)keys))) ;
                    }
                    type = Helpers.add(Helpers.add(fromId, "_"), toId);
                }
                Helpers.addElementToObject(request, "type", type);
                limitKey = "size";
            }
            if (Helpers.isTrue(!Helpers.isEqual(limit, null)))
            {
                Helpers.addElementToObject(request, limitKey, limit);
            }
            if (Helpers.isTrue(!Helpers.isEqual(since, null)))
            {
                Helpers.addElementToObject(request, "startTime", since);
            }
            Object until = this.safeInteger(parameters, "until");
            if (Helpers.isTrue(!Helpers.isEqual(until, null)))
            {
                parameters = this.omit(parameters, "until");
                Helpers.addElementToObject(request, "endTime", until);
            }
            Object response = null;
            if (Helpers.isTrue(intern))
            {
                response = (this.sapiGetPayTransactions(this.extend(request, parameters))).join();
            } else
            {
                response = (this.sapiGetAssetTransfer(this.extend(request, parameters))).join();
            }
            Object rows = this.safeList2(response, "rows", "data", new java.util.ArrayList<Object>(java.util.Arrays.asList()));
            return this.parseTransfers(rows, currency, since, limit);
        });

    }

    /**
     * @method
     * @name binance#fetchDepositAddress
     * @description fetch the deposit address for a currency associated with this account
     * @see https://developers.binance.com/docs/wallet/capital/deposite-address
     * @param {string} code unified currency code
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.network] network for fetch deposit address
     * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchDepositAddress(Object code, Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object parameters = Helpers.getArg(optionalArgs, 0, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object currency = this.currency(code);
            Object request = new java.util.HashMap<String, Object>() {{
                put( "coin", Helpers.GetValue(currency, "id") );
            }};
            Object networks = this.safeDict(this.options, "networks", new java.util.HashMap<String, Object>() {{}});
            Object network = this.safeStringUpper(parameters, "network"); // this line allows the user to specify either ERC20 or ETH
            network = this.safeString(networks, network, network); // handle ERC20>ETH alias
            if (Helpers.isTrue(!Helpers.isEqual(network, null)))
            {
                Helpers.addElementToObject(request, "network", network);
                parameters = this.omit(parameters, "network");
            }
            // has support for the 'network' parameter
            Object response = (this.sapiGetCapitalDepositAddress(this.extend(request, parameters))).join();
            //
            //     {
            //         "currency": "XRP",
            //         "address": "rEb8TK3gBgk5auZkwc6sHnwrGVJH8DuaLh",
            //         "tag": "108618262",
            //         "info": {
            //             "coin": "XRP",
            //             "address": "rEb8TK3gBgk5auZkwc6sHnwrGVJH8DuaLh",
            //             "tag": "108618262",
            //             "url": "https://bithomp.com/explorer/rEb8TK3gBgk5auZkwc6sHnwrGVJH8DuaLh"
            //         }
            //     }
            //
            return this.parseDepositAddress(response, currency);
        });

    }

    public Object parseDepositAddress(Object response, Object... optionalArgs)
    {
        //
        //     {
        //         "coin": "XRP",
        //         "address": "rEb8TK3gBgk5auZkwc6sHnwrGVJH8DuaLh",
        //         "tag": "108618262",
        //         "url": "https://bithomp.com/explorer/rEb8TK3gBgk5auZkwc6sHnwrGVJH8DuaLh"
        //     }
        //
        Object currency = Helpers.getArg(optionalArgs, 0, null);
        Object url = this.safeString(response, "url");
        Object address = this.safeString(response, "address");
        Object currencyId = this.safeString(response, "currency");
        Object code = this.safeCurrencyCode(currencyId, currency);
        // deposit-address endpoint provides only network url (not network ID/CODE)
        // so we should map the url to network (their data is inside currencies)
        Object networkCode = this.getNetworkCodeByNetworkUrl(code, url);
        Object tag = this.safeString(response, "tag", "");
        if (Helpers.isTrue(Helpers.isEqual(((String)tag).length(), 0)))
        {
            tag = null;
        }
        this.checkAddress(address);
        final Object finalTag = tag;
        return new java.util.HashMap<String, Object>() {{
            put( "info", response );
            put( "currency", code );
            put( "network", networkCode );
            put( "address", address );
            put( "tag", finalTag );
        }};
    }

    /**
     * @method
     * @name binance#fetchTransactionFees
     * @deprecated
     * @description please use fetchDepositWithdrawFees instead
     * @see https://developers.binance.com/docs/wallet/capital/all-coins-info
     * @param {string[]|undefined} codes not used by binance fetchTransactionFees ()
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchTransactionFees(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object codes = Helpers.getArg(optionalArgs, 0, null);
            Object parameters = Helpers.getArg(optionalArgs, 1, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object response = (this.sapiGetCapitalConfigGetall(parameters)).join();
            //
            //  [
            //     {
            //       "coin": "BAT",
            //       "depositAllEnable": true,
            //       "withdrawAllEnable": true,
            //       "name": "Basic Attention Token",
            //       "free": "0",
            //       "locked": "0",
            //       "freeze": "0",
            //       "withdrawing": "0",
            //       "ipoing": "0",
            //       "ipoable": "0",
            //       "storage": "0",
            //       "isLegalMoney": false,
            //       "trading": true,
            //       "networkList": [
            //         {
            //           "network": "BNB",
            //           "coin": "BAT",
            //           "withdrawIntegerMultiple": "0.00000001",
            //           "isDefault": false,
            //           "depositEnable": true,
            //           "withdrawEnable": true,
            //           "depositDesc": '',
            //           "withdrawDesc": '',
            //           "specialTips": "The name of this asset is Basic Attention Token (BAT). Both a MEMO and an Address are required to successfully deposit your BEP2 tokens to Binance.",
            //           "name": "BEP2",
            //           "resetAddressStatus": false,
            //           "addressRegex": "^(bnb1)[0-9a-z]{38}$",
            //           "memoRegex": "^[0-9A-Za-z\\-_]{1,120}$",
            //           "withdrawFee": "0.27",
            //           "withdrawMin": "0.54",
            //           "withdrawMax": "10000000000",
            //           "minConfirm": "1",
            //           "unLockConfirm": "0"
            //         },
            //         {
            //           "network": "BSC",
            //           "coin": "BAT",
            //           "withdrawIntegerMultiple": "0.00000001",
            //           "isDefault": false,
            //           "depositEnable": true,
            //           "withdrawEnable": true,
            //           "depositDesc": '',
            //           "withdrawDesc": '',
            //           "specialTips": "The name of this asset is Basic Attention Token. Please ensure you are depositing Basic Attention Token (BAT) tokens under the contract address ending in 9766e.",
            //           "name": "BEP20 (BSC)",
            //           "resetAddressStatus": false,
            //           "addressRegex": "^(0x)[0-9A-Fa-f]{40}$",
            //           "memoRegex": '',
            //           "withdrawFee": "0.27",
            //           "withdrawMin": "0.54",
            //           "withdrawMax": "10000000000",
            //           "minConfirm": "15",
            //           "unLockConfirm": "0"
            //         },
            //         {
            //           "network": "ETH",
            //           "coin": "BAT",
            //           "withdrawIntegerMultiple": "0.00000001",
            //           "isDefault": true,
            //           "depositEnable": true,
            //           "withdrawEnable": true,
            //           "depositDesc": '',
            //           "withdrawDesc": '',
            //           "specialTips": "The name of this asset is Basic Attention Token. Please ensure you are depositing Basic Attention Token (BAT) tokens under the contract address ending in 887ef.",
            //           "name": "ERC20",
            //           "resetAddressStatus": false,
            //           "addressRegex": "^(0x)[0-9A-Fa-f]{40}$",
            //           "memoRegex": '',
            //           "withdrawFee": "27",
            //           "withdrawMin": "54",
            //           "withdrawMax": "10000000000",
            //           "minConfirm": "12",
            //           "unLockConfirm": "0"
            //         }
            //       ]
            //     }
            //  ]
            //
            Object withdrawFees = new java.util.HashMap<String, Object>() {{}};
            for (var i = 0; Helpers.isLessThan(i, Helpers.getArrayLength(response)); i++)
            {
                Object entry = Helpers.GetValue(response, i);
                Object currencyId = this.safeString(entry, "coin");
                Object code = this.safeCurrencyCode(currencyId);
                Object networkList = this.safeList(entry, "networkList", new java.util.ArrayList<Object>(java.util.Arrays.asList()));
                Helpers.addElementToObject(withdrawFees, code, new java.util.HashMap<String, Object>() {{}});
                for (var j = 0; Helpers.isLessThan(j, Helpers.getArrayLength(networkList)); j++)
                {
                    Object networkEntry = Helpers.GetValue(networkList, j);
                    Object networkId = this.safeString(networkEntry, "network");
                    Object networkCode = this.safeCurrencyCode(networkId);
                    Object fee = this.safeNumber(networkEntry, "withdrawFee");
                    Helpers.addElementToObject(Helpers.GetValue(withdrawFees, code), networkCode, fee);
                }
            }
            return new java.util.HashMap<String, Object>() {{
                put( "withdraw", withdrawFees );
                put( "deposit", new java.util.HashMap<String, Object>() {{}} );
                put( "info", response );
            }};
        });

    }

    /**
     * @method
     * @name binance#fetchDepositWithdrawFees
     * @description fetch deposit and withdraw fees
     * @see https://developers.binance.com/docs/wallet/capital/all-coins-info
     * @param {string[]|undefined} codes not used by binance fetchDepositWithdrawFees ()
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchDepositWithdrawFees(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object codes = Helpers.getArg(optionalArgs, 0, null);
            Object parameters = Helpers.getArg(optionalArgs, 1, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object response = (this.sapiGetCapitalConfigGetall(parameters)).join();
            //
            //    [
            //        {
            //            "coin": "BAT",
            //            "depositAllEnable": true,
            //            "withdrawAllEnable": true,
            //            "name": "Basic Attention Token",
            //            "free": "0",
            //            "locked": "0",
            //            "freeze": "0",
            //            "withdrawing": "0",
            //            "ipoing": "0",
            //            "ipoable": "0",
            //            "storage": "0",
            //            "isLegalMoney": false,
            //            "trading": true,
            //            "networkList": [
            //                {
            //                    "network": "BNB",
            //                    "coin": "BAT",
            //                    "withdrawIntegerMultiple": "0.00000001",
            //                    "isDefault": false,
            //                    "depositEnable": true,
            //                    "withdrawEnable": true,
            //                    "depositDesc": '',
            //                    "withdrawDesc": '',
            //                    "specialTips": "The name of this asset is Basic Attention Token (BAT). Both a MEMO and an Address are required to successfully deposit your BEP2 tokens to Binance.",
            //                    "name": "BEP2",
            //                    "resetAddressStatus": false,
            //                    "addressRegex": "^(bnb1)[0-9a-z]{38}$",
            //                    "memoRegex": "^[0-9A-Za-z\\-_]{1,120}$",
            //                    "withdrawFee": "0.27",
            //                    "withdrawMin": "0.54",
            //                    "withdrawMax": "10000000000",
            //                    "minConfirm": "1",
            //                    "unLockConfirm": "0"
            //                },
            //                ...
            //            ]
            //        }
            //    ]
            //
            return this.parseDepositWithdrawFees(response, codes, "coin");
        });

    }

    public Object parseDepositWithdrawFee(Object fee, Object... optionalArgs)
    {
        //
        //    {
        //        "coin": "BAT",
        //        "depositAllEnable": true,
        //        "withdrawAllEnable": true,
        //        "name": "Basic Attention Token",
        //        "free": "0",
        //        "locked": "0",
        //        "freeze": "0",
        //        "withdrawing": "0",
        //        "ipoing": "0",
        //        "ipoable": "0",
        //        "storage": "0",
        //        "isLegalMoney": false,
        //        "trading": true,
        //        "networkList": [
        //            {
        //                "network": "BNB",
        //                "coin": "BAT",
        //                "withdrawIntegerMultiple": "0.00000001",
        //                "isDefault": false,
        //                "depositEnable": true,
        //                "withdrawEnable": true,
        //                "depositDesc": '',
        //                "withdrawDesc": '',
        //                "specialTips": "The name of this asset is Basic Attention Token (BAT). Both a MEMO and an Address are required to successfully deposit your BEP2 tokens to Binance.",
        //                "name": "BEP2",
        //                "resetAddressStatus": false,
        //                "addressRegex": "^(bnb1)[0-9a-z]{38}$",
        //                "memoRegex": "^[0-9A-Za-z\\-_]{1,120}$",
        //                "withdrawFee": "0.27",
        //                "withdrawMin": "0.54",
        //                "withdrawMax": "10000000000",
        //                "minConfirm": "1",
        //                "unLockConfirm": "0"
        //            },
        //            ...
        //        ]
        //    }
        //
        Object currency = Helpers.getArg(optionalArgs, 0, null);
        Object networkList = this.safeList(fee, "networkList", new java.util.ArrayList<Object>(java.util.Arrays.asList()));
        Object result = this.depositWithdrawFee(fee);
        for (var j = 0; Helpers.isLessThan(j, Helpers.getArrayLength(networkList)); j++)
        {
            Object networkEntry = Helpers.GetValue(networkList, j);
            Object networkId = this.safeString(networkEntry, "network");
            Object networkCode = this.networkIdToCode(networkId);
            Object withdrawFee = this.safeNumber(networkEntry, "withdrawFee");
            Object isDefault = this.safeBool(networkEntry, "isDefault");
            if (Helpers.isTrue(Helpers.isEqual(isDefault, true)))
            {
                Helpers.addElementToObject(result, "withdraw", new java.util.HashMap<String, Object>() {{
    put( "fee", withdrawFee );
    put( "percentage", null );
}});
            }
            Helpers.addElementToObject(Helpers.GetValue(result, "networks"), networkCode, new java.util.HashMap<String, Object>() {{
    put( "withdraw", new java.util.HashMap<String, Object>() {{
        put( "fee", withdrawFee );
        put( "percentage", null );
    }} );
    put( "deposit", new java.util.HashMap<String, Object>() {{
        put( "fee", null );
        put( "percentage", null );
    }} );
}});
        }
        return result;
    }

    /**
     * @method
     * @name binance#withdraw
     * @description make a withdrawal
     * @see https://developers.binance.com/docs/wallet/capital/withdraw
     * @param {string} code unified currency code
     * @param {float} amount the amount to withdraw
     * @param {string} address the address to withdraw to
     * @param {string} tag
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> withdraw(Object code, Object amount, Object address, Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object tag = Helpers.getArg(optionalArgs, 0, null);
            Object parameters = Helpers.getArg(optionalArgs, 1, new java.util.HashMap<String, Object>() {{}});
            var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
            tag = ((java.util.List<Object>) tagparametersVariable).get(0);
            parameters = ((java.util.List<Object>) tagparametersVariable).get(1);
            this.checkAddress(address);
            (this.loadMarkets()).join();
            Object currency = this.currency(code);
            Object request = new java.util.HashMap<String, Object>() {{
                put( "coin", Helpers.GetValue(currency, "id") );
                put( "address", address );
            }};
            if (Helpers.isTrue(!Helpers.isEqual(tag, null)))
            {
                Helpers.addElementToObject(request, "addressTag", tag);
            }
            Object networks = this.safeDict(this.options, "networks", new java.util.HashMap<String, Object>() {{}});
            Object network = this.safeStringUpper(parameters, "network"); // this line allows the user to specify either ERC20 or ETH
            network = this.safeString(networks, network, network); // handle ERC20>ETH alias
            if (Helpers.isTrue(!Helpers.isEqual(network, null)))
            {
                Helpers.addElementToObject(request, "network", network);
                parameters = this.omit(parameters, "network");
            }
            Helpers.addElementToObject(request, "amount", this.currencyToPrecision(code, amount, network));
            Object response = (this.sapiPostCapitalWithdrawApply(this.extend(request, parameters))).join();
            //     { id: '9a67628b16ba4988ae20d329333f16bc' }
            return this.parseTransaction(response, currency);
        });

    }

    public Object parseTradingFee(Object fee, Object... optionalArgs)
    {
        //
        // spot
        //     [
        //       {
        //         "symbol": "BTCUSDT",
        //         "makerCommission": "0.001",
        //         "takerCommission": "0.001"
        //       }
        //     ]
        //
        // swap
        //     {
        //         "symbol": "BTCUSD_PERP",
        //         "makerCommissionRate": "0.00015",  // 0.015%
        //         "takerCommissionRate": "0.00040"   // 0.040%
        //     }
        //
        Object market = Helpers.getArg(optionalArgs, 0, null);
        Object marketId = this.safeString(fee, "symbol");
        Object symbol = this.safeSymbol(marketId, market, null, "spot");
        return new java.util.HashMap<String, Object>() {{
            put( "info", fee );
            put( "symbol", symbol );
            put( "maker", Binance.this.safeNumber2(fee, "makerCommission", "makerCommissionRate") );
            put( "taker", Binance.this.safeNumber2(fee, "takerCommission", "takerCommissionRate") );
            put( "percentage", null );
            put( "tierBased", null );
        }};
    }

    /**
     * @method
     * @name binance#fetchTradingFee
     * @description fetch the trading fees for a market
     * @see https://developers.binance.com/docs/wallet/asset/trade-fee
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/account/rest-api/User-Commission-Rate
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/account/rest-api/User-Commission-Rate
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/account/Get-User-Commission-Rate-for-UM
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/account/Get-User-Commission-Rate-for-CM
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.portfolioMargin] set to true if you would like to fetch trading fees in a portfolio margin account
     * @param {string} [params.subType] "linear" or "inverse"
     * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchTradingFee(Object symbol, Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object parameters = Helpers.getArg(optionalArgs, 0, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object market = this.market(symbol);
            Object type = Helpers.GetValue(market, "type");
            Object subType = null;
            var subTypeparametersVariable = this.handleSubTypeAndParams("fetchTradingFee", market, parameters);
            subType = ((java.util.List<Object>) subTypeparametersVariable).get(0);
            parameters = ((java.util.List<Object>) subTypeparametersVariable).get(1);
            Object isPortfolioMargin = null;
            var isPortfolioMarginparametersVariable = this.handleOptionAndParams2(parameters, "fetchTradingFee", "papi", "portfolioMargin", false);
            isPortfolioMargin = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(0);
            parameters = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(1);
            Object isLinear = this.isLinear(type, subType);
            Object isInverse = this.isInverse(type, subType);
            Object request = new java.util.HashMap<String, Object>() {{
                put( "symbol", Helpers.GetValue(market, "id") );
            }};
            Object response = null;
            if (Helpers.isTrue(isLinear))
            {
                if (Helpers.isTrue(isPortfolioMargin))
                {
                    response = (this.papiGetUmCommissionRate(this.extend(request, parameters))).join();
                } else
                {
                    response = (this.fapiPrivateGetCommissionRate(this.extend(request, parameters))).join();
                }
            } else if (Helpers.isTrue(isInverse))
            {
                if (Helpers.isTrue(isPortfolioMargin))
                {
                    response = (this.papiGetCmCommissionRate(this.extend(request, parameters))).join();
                } else
                {
                    response = (this.dapiPrivateGetCommissionRate(this.extend(request, parameters))).join();
                }
            } else
            {
                response = (this.sapiGetAssetTradeFee(this.extend(request, parameters))).join();
            }
            //
            // spot
            //
            //     [
            //       {
            //         "symbol": "BTCUSDT",
            //         "makerCommission": "0.001",
            //         "takerCommission": "0.001"
            //       }
            //     ]
            //
            // swap
            //
            //     {
            //         "symbol": "BTCUSD_PERP",
            //         "makerCommissionRate": "0.00015",  // 0.015%
            //         "takerCommissionRate": "0.00040"   // 0.040%
            //     }
            //
            Object data = response;
            if (Helpers.isTrue(((data instanceof java.util.List) || (data.getClass().isArray()))))
            {
                
                data = this.safeDict(data, 0, new java.util.HashMap<String, Object>() {{}});
            }
            return this.parseTradingFee(data, market);
        });

    }

    /**
     * @method
     * @name binance#fetchTradingFees
     * @description fetch the trading fees for multiple markets
     * @see https://developers.binance.com/docs/wallet/asset/trade-fee
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/account/rest-api/Account-Information-V2
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/account/rest-api/Account-Information
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/account/rest-api/Account-Config
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.subType] "linear" or "inverse"
     * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
     */
    public java.util.concurrent.CompletableFuture<Object> fetchTradingFees(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object parameters = Helpers.getArg(optionalArgs, 0, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object type = null;
            var typeparametersVariable = this.handleMarketTypeAndParams("fetchTradingFees", null, parameters);
            type = ((java.util.List<Object>) typeparametersVariable).get(0);
            parameters = ((java.util.List<Object>) typeparametersVariable).get(1);
            Object subType = null;
            var subTypeparametersVariable = this.handleSubTypeAndParams("fetchTradingFees", null, parameters, "linear");
            subType = ((java.util.List<Object>) subTypeparametersVariable).get(0);
            parameters = ((java.util.List<Object>) subTypeparametersVariable).get(1);
            Object isSpotOrMargin = Helpers.isTrue((Helpers.isEqual(type, "spot"))) || Helpers.isTrue((Helpers.isEqual(type, "margin")));
            Object isLinear = this.isLinear(type, subType);
            Object isInverse = this.isInverse(type, subType);
            Object response = null;
            if (Helpers.isTrue(isSpotOrMargin))
            {
                response = (this.sapiGetAssetTradeFee(parameters)).join();
            } else if (Helpers.isTrue(isLinear))
            {
                response = (this.fapiPrivateGetAccountConfig(parameters)).join();
            } else if (Helpers.isTrue(isInverse))
            {
                response = (this.dapiPrivateGetAccount(parameters)).join();
            }
            //
            // sapi / spot
            //
            //    [
            //       {
            //         "symbol": "ZRXBNB",
            //         "makerCommission": "0.001",
            //         "takerCommission": "0.001"
            //       },
            //       {
            //         "symbol": "ZRXBTC",
            //         "makerCommission": "0.001",
            //         "takerCommission": "0.001"
            //       },
            //    ]
            //
            // fapi / future / linear
            //
            //     {
            //         "feeTier": 0,       // account commisssion tier
            //         "canTrade": true,   // if can trade
            //         "canDeposit": true,     // if can transfer in asset
            //         "canWithdraw": true,    // if can transfer out asset
            //         "updateTime": 0,
            //         "totalInitialMargin": "0.00000000",    // total initial margin required with current mark price (useless with isolated positions), only for USDT asset
            //         "totalMaintMargin": "0.00000000",     // total maintenance margin required, only for USDT asset
            //         "totalWalletBalance": "23.72469206",     // total wallet balance, only for USDT asset
            //         "totalUnrealizedProfit": "0.00000000",   // total unrealized profit, only for USDT asset
            //         "totalMarginBalance": "23.72469206",     // total margin balance, only for USDT asset
            //         "totalPositionInitialMargin": "0.00000000",    // initial margin required for positions with current mark price, only for USDT asset
            //         "totalOpenOrderInitialMargin": "0.00000000",   // initial margin required for open orders with current mark price, only for USDT asset
            //         "totalCrossWalletBalance": "23.72469206",      // crossed wallet balance, only for USDT asset
            //         "totalCrossUnPnl": "0.00000000",      // unrealized profit of crossed positions, only for USDT asset
            //         "availableBalance": "23.72469206",       // available balance, only for USDT asset
            //         "maxWithdrawAmount": "23.72469206"     // maximum amount for transfer out, only for USDT asset
            //         ...
            //     }
            //
            // dapi / delivery / inverse
            //
            //     {
            //         "canDeposit": true,
            //         "canTrade": true,
            //         "canWithdraw": true,
            //         "feeTier": 2,
            //         "updateTime": 0
            //     }
            //
            if (Helpers.isTrue(isSpotOrMargin))
            {
                //
                //    [
                //       {
                //         "symbol": "ZRXBNB",
                //         "makerCommission": "0.001",
                //         "takerCommission": "0.001"
                //       },
                //       {
                //         "symbol": "ZRXBTC",
                //         "makerCommission": "0.001",
                //         "takerCommission": "0.001"
                //       },
                //    ]
                //
                Object result = new java.util.HashMap<String, Object>() {{}};
                for (var i = 0; Helpers.isLessThan(i, Helpers.getArrayLength(response)); i++)
                {
                    Object fee = this.parseTradingFee(Helpers.GetValue(response, i));
                    Object symbol = Helpers.GetValue(fee, "symbol");
                    Helpers.addElementToObject(result, symbol, fee);
                }
                return result;
            } else if (Helpers.isTrue(isLinear))
            {
                //
                //     {
                //         "feeTier": 0,       // account commisssion tier
                //         "canTrade": true,   // if can trade
                //         "canDeposit": true,     // if can transfer in asset
                //         "canWithdraw": true,    // if can transfer out asset
                //         "updateTime": 0,
                //         "totalInitialMargin": "0.00000000",    // total initial margin required with current mark price (useless with isolated positions), only for USDT asset
                //         "totalMaintMargin": "0.00000000",     // total maintenance margin required, only for USDT asset
                //         "totalWalletBalance": "23.72469206",     // total wallet balance, only for USDT asset
                //         "totalUnrealizedProfit": "0.00000000",   // total unrealized profit, only for USDT asset
                //         "totalMarginBalance": "23.72469206",     // total margin balance, only for USDT asset
                //         "totalPositionInitialMargin": "0.00000000",    // initial margin required for positions with current mark price, only for USDT asset
                //         "totalOpenOrderInitialMargin": "0.00000000",   // initial margin required for open orders with current mark price, only for USDT asset
                //         "totalCrossWalletBalance": "23.72469206",      // crossed wallet balance, only for USDT asset
                //         "totalCrossUnPnl": "0.00000000",      // unrealized profit of crossed positions, only for USDT asset
                //         "availableBalance": "23.72469206",       // available balance, only for USDT asset
                //         "maxWithdrawAmount": "23.72469206"     // maximum amount for transfer out, only for USDT asset
                //         ...
                //     }
                //
                Object symbols = new java.util.ArrayList<Object>(((java.util.Map<String, Object>)this.markets).keySet());
                Object result = new java.util.HashMap<String, Object>() {{}};
                Object feeTier = this.safeInteger(response, "feeTier");
                Object feeTiers = Helpers.GetValue(Helpers.GetValue(Helpers.GetValue(this.fees, "linear"), "trading"), "tiers");
                Object maker = Helpers.GetValue(Helpers.GetValue(Helpers.GetValue(feeTiers, "maker"), feeTier), 1);
                Object taker = Helpers.GetValue(Helpers.GetValue(Helpers.GetValue(feeTiers, "taker"), feeTier), 1);
                for (var i = 0; Helpers.isLessThan(i, Helpers.getArrayLength(symbols)); i++)
                {
                    Object symbol = Helpers.GetValue(symbols, i);
                    Object market = Helpers.GetValue(this.markets, symbol);
                    if (Helpers.isTrue(Helpers.GetValue(market, "linear")))
                    {
                        Helpers.addElementToObject(result, symbol, new java.util.HashMap<String, Object>() {{
        put( "info", new java.util.HashMap<String, Object>() {{
            put( "feeTier", feeTier );
        }} );
        put( "symbol", symbol );
        put( "maker", maker );
        put( "taker", taker );
    }});
                    }
                }
                return result;
            } else if (Helpers.isTrue(isInverse))
            {
                //
                //     {
                //         "canDeposit": true,
                //         "canTrade": true,
                //         "canWithdraw": true,
                //         "feeTier": 2,
                //         "updateTime": 0
                //     }
                //
                Object symbols = new java.util.ArrayList<Object>(((java.util.Map<String, Object>)this.markets).keySet());
                Object result = new java.util.HashMap<String, Object>() {{}};
                Object feeTier = this.safeInteger(response, "feeTier");
                Object feeTiers = Helpers.GetValue(Helpers.GetValue(Helpers.GetValue(this.fees, "inverse"), "trading"), "tiers");
                Object maker = Helpers.GetValue(Helpers.GetValue(Helpers.GetValue(feeTiers, "maker"), feeTier), 1);
                Object taker = Helpers.GetValue(Helpers.GetValue(Helpers.GetValue(feeTiers, "taker"), feeTier), 1);
                for (var i = 0; Helpers.isLessThan(i, Helpers.getArrayLength(symbols)); i++)
                {
                    Object symbol = Helpers.GetValue(symbols, i);
                    Object market = Helpers.GetValue(this.markets, symbol);
                    if (Helpers.isTrue(Helpers.GetValue(market, "inverse")))
                    {
                        Helpers.addElementToObject(result, symbol, new java.util.HashMap<String, Object>() {{
        put( "info", new java.util.HashMap<String, Object>() {{
            put( "feeTier", feeTier );
        }} );
        put( "symbol", symbol );
        put( "maker", maker );
        put( "taker", taker );
    }});
                    }
                }
                return result;
            }
            return null;
        });

    }

    /**
     * @method
     * @name binance#futuresTransfer
     * @ignore
     * @description transfer between futures account
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/account/rest-api/New-Future-Account-Transfer
     * @param {string} code unified currency code
     * @param {float} amount the amount to transfer
     * @param {string} type 1 - transfer from spot account to USDT- futures account, 2 - transfer from USDT- futures account to spot account, 3 - transfer from spot account to COIN- futures account, 4 - transfer from COIN- futures account to spot account
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {float} params.recvWindow
     * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=futures-transfer-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> futuresTransfer(Object code, Object amount, Object type2, Object... optionalArgs)
    {
        final Object type3 = type2;
        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {
            Object type = type3;
            Object parameters = Helpers.getArg(optionalArgs, 0, new java.util.HashMap<String, Object>() {{}});
            if (Helpers.isTrue(Helpers.isTrue((Helpers.isLessThan(type, 1))) || Helpers.isTrue((Helpers.isGreaterThan(type, 4)))))
            {
                throw new ArgumentsRequired((String)Helpers.add(this.id, " type must be between 1 and 4")) ;
            }
            (this.loadMarkets()).join();
            Object currency = this.currency(code);
            final Object finalType = type;
            Object request = new java.util.HashMap<String, Object>() {{
                put( "asset", Helpers.GetValue(currency, "id") );
                put( "amount", amount );
                put( "type", finalType );
            }};
            Object response = (this.sapiPostFuturesTransfer(this.extend(request, parameters))).join();
            //
            //   {
            //       "tranId": 100000001
            //   }
            //
            return this.parseTransfer(response, currency);
        });

    }

    /**
     * @method
     * @name binance#fetchFundingRate
     * @description fetch the current funding rate
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Mark-Price
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/Index-Price-and-Mark-Price
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchFundingRate(Object symbol, Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object parameters = Helpers.getArg(optionalArgs, 0, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object market = this.market(symbol);
            Object request = new java.util.HashMap<String, Object>() {{
                put( "symbol", Helpers.GetValue(market, "id") );
            }};
            Object response = null;
            if (Helpers.isTrue(Helpers.GetValue(market, "linear")))
            {
                response = (this.fapiPublicGetPremiumIndex(this.extend(request, parameters))).join();
            } else if (Helpers.isTrue(Helpers.GetValue(market, "inverse")))
            {
                response = (this.dapiPublicGetPremiumIndex(this.extend(request, parameters))).join();
            } else
            {
                throw new NotSupported((String)Helpers.add(this.id, " fetchFundingRate() supports linear and inverse contracts only")) ;
            }
            if (Helpers.isTrue(Helpers.GetValue(market, "inverse")))
            {
                response = Helpers.GetValue(response, 0);
            }
            //
            //     {
            //         "symbol": "BTCUSDT",
            //         "markPrice": "45802.81129892",
            //         "indexPrice": "45745.47701915",
            //         "estimatedSettlePrice": "45133.91753671",
            //         "lastFundingRate": "0.00063521",
            //         "interestRate": "0.00010000",
            //         "nextFundingTime": "1621267200000",
            //         "time": "1621252344001"
            //     }
            //
            return this.parseFundingRate(response, market);
        });

    }

    /**
     * @method
     * @name binance#fetchFundingRateHistory
     * @description fetches historical funding rate prices
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Get-Funding-Rate-History
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/Get-Funding-Rate-History-of-Perpetual-Futures
     * @param {string} symbol unified symbol of the market to fetch the funding rate history for
     * @param {int} [since] timestamp in ms of the earliest funding rate to fetch
     * @param {int} [limit] the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure} to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest funding rate
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @param {string} [params.subType] "linear" or "inverse"
     * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-history-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchFundingRateHistory(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object symbol = Helpers.getArg(optionalArgs, 0, null);
            Object since = Helpers.getArg(optionalArgs, 1, null);
            Object limit = Helpers.getArg(optionalArgs, 2, null);
            Object parameters = Helpers.getArg(optionalArgs, 3, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object request = new java.util.HashMap<String, Object>() {{}};
            Object paginate = false;
            var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchFundingRateHistory", "paginate");
            paginate = ((java.util.List<Object>) paginateparametersVariable).get(0);
            parameters = ((java.util.List<Object>) paginateparametersVariable).get(1);
            if (Helpers.isTrue(paginate))
            {
                return (this.fetchPaginatedCallDeterministic("fetchFundingRateHistory", symbol, since, limit, "8h", parameters)).join();
            }
            Object defaultType = this.safeString2(this.options, "fetchFundingRateHistory", "defaultType", "future");
            Object type = this.safeString(parameters, "type", defaultType);
            Object market = null;
            if (Helpers.isTrue(!Helpers.isEqual(symbol, null)))
            {
                market = this.market(symbol);
                symbol = Helpers.GetValue(market, "symbol");
                Helpers.addElementToObject(request, "symbol", Helpers.GetValue(market, "id"));
            }
            Object subType = null;
            var subTypeparametersVariable = this.handleSubTypeAndParams("fetchFundingRateHistory", market, parameters, "linear");
            subType = ((java.util.List<Object>) subTypeparametersVariable).get(0);
            parameters = ((java.util.List<Object>) subTypeparametersVariable).get(1);
            parameters = this.omit(parameters, "type");
            if (Helpers.isTrue(!Helpers.isEqual(since, null)))
            {
                Helpers.addElementToObject(request, "startTime", since);
            }
            Object until = this.safeInteger(parameters, "until"); // unified in milliseconds
            Object endTime = this.safeInteger(parameters, "endTime", until); // exchange-specific in milliseconds
            parameters = this.omit(parameters, new java.util.ArrayList<Object>(java.util.Arrays.asList("endTime", "until")));
            if (Helpers.isTrue(!Helpers.isEqual(endTime, null)))
            {
                Helpers.addElementToObject(request, "endTime", endTime);
            }
            if (Helpers.isTrue(!Helpers.isEqual(limit, null)))
            {
                Helpers.addElementToObject(request, "limit", limit);
            }
            Object response = null;
            if (Helpers.isTrue(this.isLinear(type, subType)))
            {
                response = (this.fapiPublicGetFundingRate(this.extend(request, parameters))).join();
            } else if (Helpers.isTrue(this.isInverse(type, subType)))
            {
                response = (this.dapiPublicGetFundingRate(this.extend(request, parameters))).join();
            } else
            {
                throw new NotSupported((String)Helpers.add(Helpers.add(Helpers.add(this.id, " fetchFundingRateHistory() is not supported for "), type), " markets")) ;
            }
            //
            //     {
            //         "symbol": "BTCUSDT",
            //         "fundingRate": "0.00063521",
            //         "fundingTime": "1621267200000",
            //     }
            //
            return this.parseFundingRateHistories(response, market, since, limit);
        });

    }

    public Object parseFundingRateHistory(Object contract, Object... optionalArgs)
    {
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "fundingRate": "0.00063521",
        //         "fundingTime": "1621267200000",
        //     }
        //
        Object market = Helpers.getArg(optionalArgs, 0, null);
        Object timestamp = this.safeInteger(contract, "fundingTime");
        return new java.util.HashMap<String, Object>() {{
            put( "info", contract );
            put( "symbol", Binance.this.safeSymbol(Binance.this.safeString(contract, "symbol"), null, null, "swap") );
            put( "fundingRate", Binance.this.safeNumber(contract, "fundingRate") );
            put( "timestamp", timestamp );
            put( "datetime", Binance.this.iso8601(timestamp) );
        }};
    }

    /**
     * @method
     * @name binance#fetchFundingRates
     * @description fetch the funding rate for multiple markets
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Mark-Price
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/Index-Price-and-Mark-Price
     * @param {string[]|undefined} symbols list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.subType] "linear" or "inverse"
     * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rates-structure}, indexed by market symbols
     */
    public java.util.concurrent.CompletableFuture<Object> fetchFundingRates(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object symbols = Helpers.getArg(optionalArgs, 0, null);
            Object parameters = Helpers.getArg(optionalArgs, 1, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            symbols = this.marketSymbols(symbols);
            Object defaultType = this.safeString2(this.options, "fetchFundingRates", "defaultType", "future");
            Object type = this.safeString(parameters, "type", defaultType);
            Object subType = null;
            var subTypeparametersVariable = this.handleSubTypeAndParams("fetchFundingRates", null, parameters, "linear");
            subType = ((java.util.List<Object>) subTypeparametersVariable).get(0);
            parameters = ((java.util.List<Object>) subTypeparametersVariable).get(1);
            Object query = this.omit(parameters, "type");
            Object response = null;
            if (Helpers.isTrue(this.isLinear(type, subType)))
            {
                response = (this.fapiPublicGetPremiumIndex(query)).join();
            } else if (Helpers.isTrue(this.isInverse(type, subType)))
            {
                response = (this.dapiPublicGetPremiumIndex(query)).join();
            } else
            {
                throw new NotSupported((String)Helpers.add(this.id, " fetchFundingRates() supports linear and inverse contracts only")) ;
            }
            return this.parseFundingRates(response, symbols);
        });

    }

    public Object parseFundingRate(Object contract, Object... optionalArgs)
    {
        // ensure it matches with https://www.binance.com/en/futures/funding-history/0
        //
        // fetchFundingRate, fetchFundingRates
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "markPrice": "45802.81129892",
        //         "indexPrice": "45745.47701915",
        //         "estimatedSettlePrice": "45133.91753671",
        //         "lastFundingRate": "0.00063521",
        //         "interestRate": "0.00010000",
        //         "nextFundingTime": "1621267200000",
        //         "time": "1621252344001"
        //     }
        //
        // fetchFundingInterval, fetchFundingIntervals
        //
        //     {
        //         "symbol": "BLZUSDT",
        //         "adjustedFundingRateCap": "0.03000000",
        //         "adjustedFundingRateFloor": "-0.03000000",
        //         "fundingIntervalHours": 4,
        //         "disclaimer": false
        //     }
        //
        Object market = Helpers.getArg(optionalArgs, 0, null);
        Object timestamp = this.safeInteger(contract, "time");
        Object marketId = this.safeString(contract, "symbol");
        Object symbol = this.safeSymbol(marketId, market, null, "contract");
        Object markPrice = this.safeNumber(contract, "markPrice");
        Object indexPrice = this.safeNumber(contract, "indexPrice");
        Object interestRate = this.safeNumber(contract, "interestRate");
        Object estimatedSettlePrice = this.safeNumber(contract, "estimatedSettlePrice");
        Object fundingRate = this.safeNumber(contract, "lastFundingRate");
        Object fundingTime = this.safeInteger(contract, "nextFundingTime");
        Object interval = this.safeString(contract, "fundingIntervalHours");
        Object intervalString = null;
        if (Helpers.isTrue(!Helpers.isEqual(interval, null)))
        {
            intervalString = Helpers.add(interval, "h");
        }
        final Object finalIntervalString = intervalString;
        return new java.util.HashMap<String, Object>() {{
            put( "info", contract );
            put( "symbol", symbol );
            put( "markPrice", markPrice );
            put( "indexPrice", indexPrice );
            put( "interestRate", interestRate );
            put( "estimatedSettlePrice", estimatedSettlePrice );
            put( "timestamp", timestamp );
            put( "datetime", Binance.this.iso8601(timestamp) );
            put( "fundingRate", fundingRate );
            put( "fundingTimestamp", fundingTime );
            put( "fundingDatetime", Binance.this.iso8601(fundingTime) );
            put( "nextFundingRate", null );
            put( "nextFundingTimestamp", null );
            put( "nextFundingDatetime", null );
            put( "previousFundingRate", null );
            put( "previousFundingTimestamp", null );
            put( "previousFundingDatetime", null );
            put( "interval", finalIntervalString );
        }};
    }

    public Object parseAccountPositions(Object account, Object... optionalArgs)
    {
        Object filterClosed = Helpers.getArg(optionalArgs, 0, false);
        Object positions = this.safeList(account, "positions");
        Object assets = this.safeList(account, "assets", new java.util.ArrayList<Object>(java.util.Arrays.asList()));
        Object balances = new java.util.HashMap<String, Object>() {{}};
        for (var i = 0; Helpers.isLessThan(i, Helpers.getArrayLength(assets)); i++)
        {
            Object entry = Helpers.GetValue(assets, i);
            Object currencyId = this.safeString(entry, "asset");
            Object code = this.safeCurrencyCode(currencyId);
            Object crossWalletBalance = this.safeString(entry, "crossWalletBalance");
            Object crossUnPnl = this.safeString(entry, "crossUnPnl");
            Helpers.addElementToObject(balances, code, new java.util.HashMap<String, Object>() {{
    put( "crossMargin", Precise.stringAdd(crossWalletBalance, crossUnPnl) );
    put( "crossWalletBalance", crossWalletBalance );
}});
        }
        Object result = new java.util.ArrayList<Object>(java.util.Arrays.asList());
        for (var i = 0; Helpers.isLessThan(i, Helpers.getArrayLength(positions)); i++)
        {
            Object position = Helpers.GetValue(positions, i);
            Object marketId = this.safeString(position, "symbol");
            Object market = this.safeMarket(marketId, null, null, "contract");
            Object code = ((Helpers.isTrue(Helpers.GetValue(market, "linear")))) ? Helpers.GetValue(market, "quote") : Helpers.GetValue(market, "base");
            Object maintenanceMargin = this.safeString(position, "maintMargin");
            // check for maintenance margin so empty positions are not returned
            Object isPositionOpen = Helpers.isTrue((!Helpers.isEqual(maintenanceMargin, "0"))) && Helpers.isTrue((!Helpers.isEqual(maintenanceMargin, "0.00000000")));
            if (Helpers.isTrue(!Helpers.isTrue(filterClosed) || Helpers.isTrue(isPositionOpen)))
            {
                // sometimes not all the codes are correctly returned...
                if (Helpers.isTrue(Helpers.inOp(balances, code)))
                {
                    Object parsed = this.parseAccountPosition(this.extend(position, new java.util.HashMap<String, Object>() {{
                        put( "crossMargin", Helpers.GetValue(Helpers.GetValue(balances, code), "crossMargin") );
                        put( "crossWalletBalance", Helpers.GetValue(Helpers.GetValue(balances, code), "crossWalletBalance") );
                    }}), market);
                    ((java.util.List<Object>)result).add(parsed);
                }
            }
        }
        return result;
    }

    public Object parseAccountPosition(Object position, Object... optionalArgs)
    {
        //
        // usdm
        //
        // v3 (similar for cross & isolated)
        //
        //    {
        //        "symbol": "WLDUSDT",
        //        "positionSide": "BOTH",
        //        "positionAmt": "-849",
        //        "unrealizedProfit": "11.17920750",
        //        "notional": "-1992.46079250",
        //        "isolatedMargin": "0",
        //        "isolatedWallet": "0",
        //        "initialMargin": "99.62303962",
        //        "maintMargin": "11.95476475",
        //        "updateTime": "1721995760449"
        //        "leverage": "50",                        // in v2
        //        "entryPrice": "2.34",                    // in v2
        //        "positionInitialMargin": "118.82116614", // in v2
        //        "openOrderInitialMargin": "0",           // in v2
        //        "isolated": false,                       // in v2
        //        "breakEvenPrice": "2.3395788",           // in v2
        //        "maxNotional": "25000",                  // in v2
        //        "bidNotional": "0",                      // in v2
        //        "askNotional": "0"                       // in v2
        //    }
        //
        // coinm
        //
        //     {
        //       "symbol": "BTCUSD_210625",
        //       "initialMargin": "0.00024393",
        //       "maintMargin": "0.00002439",
        //       "unrealizedProfit": "-0.00000163",
        //       "positionInitialMargin": "0.00024393",
        //       "openOrderInitialMargin": "0",
        //       "leverage": "10",
        //       "isolated": false,
        //       "positionSide": "BOTH",
        //       "entryPrice": "41021.20000069",
        //       "maxQty": "100",
        //       "notionalValue": "0.00243939",
        //       "isolatedWallet": "0",
        //       "crossMargin": "0.314"
        //       "crossWalletBalance": "34",
        //     }
        //
        // linear portfolio margin
        //
        //     {
        //         "symbol": "CTSIUSDT",
        //         "initialMargin": "0",
        //         "maintMargin": "0",
        //         "unrealizedProfit": "0.00000000",
        //         "positionInitialMargin": "0",
        //         "openOrderInitialMargin": "0",
        //         "leverage": "20",
        //         "entryPrice": "0.0",
        //         "maxNotional": "25000",
        //         "bidNotional": "0",
        //         "askNotional": "0",
        //         "positionSide": "SHORT",
        //         "positionAmt": "0",
        //         "updateTime": 0,
        //         "notional": "0",
        //         "breakEvenPrice": "0.0"
        //     }
        //
        // inverse portoflio margin
        //
        //     {
        //         "symbol": "TRXUSD_PERP",
        //         "initialMargin": "0",
        //         "maintMargin": "0",
        //         "unrealizedProfit": "0.00000000",
        //         "positionInitialMargin": "0",
        //         "openOrderInitialMargin": "0",
        //         "leverage": "20",
        //         "entryPrice": "0.00000000",
        //         "positionSide": "SHORT",
        //         "positionAmt": "0",
        //         "maxQty": "5000000",
        //         "updateTime": 0,
        //         "notionalValue": "0",
        //         "breakEvenPrice": "0.00000000"
        //     }
        //
        Object market = Helpers.getArg(optionalArgs, 0, null);
        Object marketId = this.safeString(position, "symbol");
        market = this.safeMarket(marketId, market, null, "contract");
        Object symbol = this.safeString(market, "symbol");
        Object leverageString = this.safeString(position, "leverage");
        Object leverage = ((Helpers.isTrue((!Helpers.isEqual(leverageString, null))))) ? Helpers.parseInt(leverageString) : null;
        Object initialMarginString = this.safeString(position, "initialMargin");
        Object initialMargin = this.parseNumber(initialMarginString);
        Object initialMarginPercentageString = null;
        if (Helpers.isTrue(!Helpers.isEqual(leverageString, null)))
        {
            initialMarginPercentageString = Precise.stringDiv("1", leverageString, 8);
            Object rational = this.isRoundNumber(Helpers.mod(1000, leverage));
            if (!Helpers.isTrue(rational))
            {
                initialMarginPercentageString = Precise.stringDiv(Precise.stringAdd(initialMarginPercentageString, "1e-8"), "1", 8);
            }
        }
        // as oppose to notionalValue
        Object usdm = (Helpers.inOp(position, "notional"));
        Object maintenanceMarginString = this.safeString(position, "maintMargin");
        Object maintenanceMargin = this.parseNumber(maintenanceMarginString);
        Object entryPriceString = this.safeString(position, "entryPrice");
        Object entryPrice = this.parseNumber(entryPriceString);
        Object notionalString = this.safeString2(position, "notional", "notionalValue");
        Object notionalStringAbs = Precise.stringAbs(notionalString);
        Object notional = this.parseNumber(notionalStringAbs);
        Object contractsString = this.safeString(position, "positionAmt");
        Object contractsStringAbs = Precise.stringAbs(contractsString);
        if (Helpers.isTrue(Helpers.isEqual(contractsString, null)))
        {
            Object entryNotional = Precise.stringMul(Precise.stringMul(leverageString, initialMarginString), entryPriceString);
            Object contractSizeNew = this.safeString(market, "contractSize");
            contractsString = Precise.stringDiv(entryNotional, contractSizeNew);
            contractsStringAbs = Precise.stringDiv(Precise.stringAdd(contractsString, "0.5"), "1", 0);
        }
        Object contracts = this.parseNumber(contractsStringAbs);
        Object leverageBrackets = this.safeDict(this.options, "leverageBrackets", new java.util.HashMap<String, Object>() {{}});
        Object leverageBracket = this.safeList(leverageBrackets, symbol, new java.util.ArrayList<Object>(java.util.Arrays.asList()));
        Object maintenanceMarginPercentageString = null;
        for (var i = 0; Helpers.isLessThan(i, Helpers.getArrayLength(leverageBracket)); i++)
        {
            Object bracket = Helpers.GetValue(leverageBracket, i);
            if (Helpers.isTrue(Precise.stringLt(notionalStringAbs, Helpers.GetValue(bracket, 0))))
            {
                break;
            }
            maintenanceMarginPercentageString = Helpers.GetValue(bracket, 1);
        }
        Object maintenanceMarginPercentage = this.parseNumber(maintenanceMarginPercentageString);
        Object unrealizedPnlString = this.safeString(position, "unrealizedProfit");
        Object unrealizedPnl = this.parseNumber(unrealizedPnlString);
        Object timestamp = this.safeInteger(position, "updateTime");
        if (Helpers.isTrue(Helpers.isEqual(timestamp, 0)))
        {
            timestamp = null;
        }
        Object isolated = this.safeBool(position, "isolated");
        if (Helpers.isTrue(Helpers.isEqual(isolated, null)))
        {
            Object isolatedMarginRaw = this.safeString(position, "isolatedMargin");
            isolated = !Helpers.isTrue(Precise.stringEq(isolatedMarginRaw, "0"));
        }
        Object marginMode = null;
        Object collateralString = null;
        Object walletBalance = null;
        if (Helpers.isTrue(isolated))
        {
            marginMode = "isolated";
            walletBalance = this.safeString(position, "isolatedWallet");
            collateralString = Precise.stringAdd(walletBalance, unrealizedPnlString);
        } else
        {
            marginMode = "cross";
            walletBalance = this.safeString(position, "crossWalletBalance");
            collateralString = this.safeString(position, "crossMargin");
        }
        Object collateral = this.parseNumber(collateralString);
        Object marginRatio = null;
        Object side = null;
        Object percentage = null;
        Object liquidationPriceStringRaw = null;
        Object liquidationPrice = null;
        Object contractSize = this.safeValue(market, "contractSize");
        Object contractSizeString = this.numberToString(contractSize);
        if (Helpers.isTrue(Precise.stringEquals(notionalString, "0")))
        {
            entryPrice = null;
        } else
        {
            side = ((Helpers.isTrue(Precise.stringLt(notionalString, "0")))) ? "short" : "long";
            marginRatio = this.parseNumber(Precise.stringDiv(Precise.stringAdd(Precise.stringDiv(maintenanceMarginString, collateralString), "5e-5"), "1", 4));
            percentage = this.parseNumber(Precise.stringMul(Precise.stringDiv(unrealizedPnlString, initialMarginString, 4), "100"));
            if (Helpers.isTrue(usdm))
            {
                // calculate liquidation price
                //
                // liquidationPrice = (walletBalance / (contracts * (1 + mmp))) + (entryPrice / (1 + mmp))
                //
                // mmp = maintenanceMarginPercentage
                // where  is negative for long and positive for short
                // TODO: calculate liquidation price for coinm contracts
                Object onePlusMaintenanceMarginPercentageString = null;
                Object entryPriceSignString = entryPriceString;
                if (Helpers.isTrue(Helpers.isEqual(side, "short")))
                {
                    onePlusMaintenanceMarginPercentageString = Precise.stringAdd("1", maintenanceMarginPercentageString);
                } else
                {
                    onePlusMaintenanceMarginPercentageString = Precise.stringAdd("-1", maintenanceMarginPercentageString);
                    entryPriceSignString = Precise.stringMul("-1", entryPriceSignString);
                }
                Object leftSide = Precise.stringDiv(walletBalance, Precise.stringMul(contractsStringAbs, onePlusMaintenanceMarginPercentageString));
                Object rightSide = Precise.stringDiv(entryPriceSignString, onePlusMaintenanceMarginPercentageString);
                liquidationPriceStringRaw = Precise.stringAdd(leftSide, rightSide);
            } else
            {
                // calculate liquidation price
                //
                // liquidationPrice = (contracts * contractSize(1 - mmp)) / (1/entryPrice * contracts * contractSize - walletBalance)
                //
                Object onePlusMaintenanceMarginPercentageString = null;
                Object entryPriceSignString = entryPriceString;
                if (Helpers.isTrue(Helpers.isEqual(side, "short")))
                {
                    onePlusMaintenanceMarginPercentageString = Precise.stringSub("1", maintenanceMarginPercentageString);
                } else
                {
                    onePlusMaintenanceMarginPercentageString = Precise.stringSub("-1", maintenanceMarginPercentageString);
                    entryPriceSignString = Precise.stringMul("-1", entryPriceSignString);
                }
                Object size = Precise.stringMul(contractsStringAbs, contractSizeString);
                Object leftSide = Precise.stringMul(size, onePlusMaintenanceMarginPercentageString);
                Object rightSide = Precise.stringSub(Precise.stringMul(Precise.stringDiv("1", entryPriceSignString), size), walletBalance);
                liquidationPriceStringRaw = Precise.stringDiv(leftSide, rightSide);
            }
            Object pricePrecision = this.precisionFromString(this.safeString(Helpers.GetValue(market, "precision"), "price"));
            Object pricePrecisionPlusOne = Helpers.add(pricePrecision, 1);
            Object pricePrecisionPlusOneString = String.valueOf(pricePrecisionPlusOne);
            // round half up
            var rounder = new Precise(Helpers.add("5e-", pricePrecisionPlusOneString));
            Object rounderString = String.valueOf(rounder);
            Object liquidationPriceRoundedString = Precise.stringAdd(rounderString, liquidationPriceStringRaw);
            Object truncatedLiquidationPrice = Precise.stringDiv(liquidationPriceRoundedString, "1", pricePrecision);
            if (Helpers.isTrue(Helpers.isEqual(Helpers.GetValue(truncatedLiquidationPrice, 0), "-")))
            {
                // user cannot be liquidated
                // since he has more collateral than the size of the position
                truncatedLiquidationPrice = null;
            }
            liquidationPrice = this.parseNumber(truncatedLiquidationPrice);
        }
        Object positionSide = this.safeString(position, "positionSide");
        Object hedged = !Helpers.isEqual(positionSide, "BOTH");
        final Object finalTimestamp = timestamp;
        final Object finalInitialMarginPercentageString = initialMarginPercentageString;
        final Object finalEntryPrice = entryPrice;
        final Object finalLeverageString = leverageString;
        final Object finalMarginRatio = marginRatio;
        final Object finalLiquidationPrice = liquidationPrice;
        final Object finalMarginMode = marginMode;
        final Object finalSide = side;
        final Object finalPercentage = percentage;
        return new java.util.HashMap<String, Object>() {{
            put( "info", position );
            put( "id", null );
            put( "symbol", symbol );
            put( "timestamp", finalTimestamp );
            put( "datetime", Binance.this.iso8601(finalTimestamp) );
            put( "initialMargin", initialMargin );
            put( "initialMarginPercentage", Binance.this.parseNumber(finalInitialMarginPercentageString) );
            put( "maintenanceMargin", maintenanceMargin );
            put( "maintenanceMarginPercentage", maintenanceMarginPercentage );
            put( "entryPrice", finalEntryPrice );
            put( "notional", notional );
            put( "leverage", Binance.this.parseNumber(finalLeverageString) );
            put( "unrealizedPnl", unrealizedPnl );
            put( "contracts", contracts );
            put( "contractSize", contractSize );
            put( "marginRatio", finalMarginRatio );
            put( "liquidationPrice", finalLiquidationPrice );
            put( "markPrice", null );
            put( "collateral", collateral );
            put( "marginMode", finalMarginMode );
            put( "side", finalSide );
            put( "hedged", hedged );
            put( "percentage", finalPercentage );
        }};
    }

    public Object parsePositionRisk(Object position, Object... optionalArgs)
    {
        //
        // usdm
        //
        //  {
        //     symbol: "WLDUSDT",
        //     positionSide: "BOTH",
        //     positionAmt: "5",
        //     entryPrice: "2.3483",
        //     breakEvenPrice: "2.349356735",
        //     markPrice: "2.39560000",
        //     unRealizedProfit: "0.23650000",
        //     liquidationPrice: "0",
        //     isolatedMargin: "0",
        //     notional: "11.97800000",
        //     isolatedWallet: "0",
        //     updateTime: "1722062678998",
        //     initialMargin: "2.39560000",         // not in v2
        //     maintMargin: "0.07186800",           // not in v2
        //     positionInitialMargin: "2.39560000", // not in v2
        //     openOrderInitialMargin: "0",         // not in v2
        //     adl: "2",                            // not in v2
        //     bidNotional: "0",                    // not in v2
        //     askNotional: "0",                    // not in v2
        //     marginAsset: "USDT",                 // not in v2
        //     // the below fields are only in v2
        //     leverage: "5",
        //     maxNotionalValue: "6000000",
        //     marginType: "cross",
        //     isAutoAddMargin: "false",
        //     isolated: false,
        //     adlQuantile: "2",
        //
        // coinm
        //
        //     {
        //       "symbol": "BTCUSD_PERP",
        //       "positionAmt": "2",
        //       "entryPrice": "37643.10000021",
        //       "markPrice": "38103.05510455",
        //       "unRealizedProfit": "0.00006413",
        //       "liquidationPrice": "25119.97445760",
        //       "leverage": "2",
        //       "maxQty": "1500",
        //       "marginType": "isolated",
        //       "isolatedMargin": "0.00274471",
        //       "isAutoAddMargin": "false",
        //       "positionSide": "BOTH",
        //       "notionalValue": "0.00524892",
        //       "isolatedWallet": "0.00268058"
        //     }
        //
        // inverse portfolio margin
        //
        //     {
        //         "symbol": "ETHUSD_PERP",
        //         "positionAmt": "1",
        //         "entryPrice": "2422.400000007",
        //         "markPrice": "2424.51267823",
        //         "unRealizedProfit": "0.0000036",
        //         "liquidationPrice": "293.57678898",
        //         "leverage": "100",
        //         "positionSide": "LONG",
        //         "updateTime": 1707371941861,
        //         "maxQty": "15",
        //         "notionalValue": "0.00412454",
        //         "breakEvenPrice": "2423.368960034"
        //     }
        //
        // linear portfolio margin
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "positionAmt": "0.01",
        //         "entryPrice": "44525.0",
        //         "markPrice": "45464.1735922",
        //         "unRealizedProfit": "9.39173592",
        //         "liquidationPrice": "38007.16308568",
        //         "leverage": "100",
        //         "positionSide": "LONG",
        //         "updateTime": 1707371879042,
        //         "maxNotionalValue": "500000.0",
        //         "notional": "454.64173592",
        //         "breakEvenPrice": "44542.81"
        //     }
        //
        Object market = Helpers.getArg(optionalArgs, 0, null);
        Object marketId = this.safeString(position, "symbol");
        market = this.safeMarket(marketId, market, null, "contract");
        Object symbol = this.safeString(market, "symbol");
        Object isolatedMarginString = this.safeString(position, "isolatedMargin");
        Object leverageBrackets = this.safeDict(this.options, "leverageBrackets", new java.util.HashMap<String, Object>() {{}});
        Object leverageBracket = this.safeList(leverageBrackets, symbol, new java.util.ArrayList<Object>(java.util.Arrays.asList()));
        Object notionalString = this.safeString2(position, "notional", "notionalValue");
        Object notionalStringAbs = Precise.stringAbs(notionalString);
        Object maintenanceMarginPercentageString = null;
        for (var i = 0; Helpers.isLessThan(i, Helpers.getArrayLength(leverageBracket)); i++)
        {
            Object bracket = Helpers.GetValue(leverageBracket, i);
            if (Helpers.isTrue(Precise.stringLt(notionalStringAbs, Helpers.GetValue(bracket, 0))))
            {
                break;
            }
            maintenanceMarginPercentageString = Helpers.GetValue(bracket, 1);
        }
        Object notional = this.parseNumber(notionalStringAbs);
        Object contractsAbs = Precise.stringAbs(this.safeString(position, "positionAmt"));
        Object contracts = this.parseNumber(contractsAbs);
        Object unrealizedPnlString = this.safeString(position, "unRealizedProfit");
        Object unrealizedPnl = this.parseNumber(unrealizedPnlString);
        Object liquidationPriceString = this.omitZero(this.safeString(position, "liquidationPrice"));
        Object liquidationPrice = this.parseNumber(liquidationPriceString);
        Object collateralString = null;
        Object marginMode = this.safeString(position, "marginType");
        if (Helpers.isTrue(Helpers.isTrue(Helpers.isEqual(marginMode, null)) && Helpers.isTrue(!Helpers.isEqual(isolatedMarginString, null))))
        {
            marginMode = ((Helpers.isTrue(Precise.stringEq(isolatedMarginString, "0")))) ? "cross" : "isolated";
        }
        Object side = null;
        if (Helpers.isTrue(Precise.stringGt(notionalString, "0")))
        {
            side = "long";
        } else if (Helpers.isTrue(Precise.stringLt(notionalString, "0")))
        {
            side = "short";
        }
        Object entryPriceString = this.safeString(position, "entryPrice");
        Object entryPrice = this.parseNumber(entryPriceString);
        Object contractSize = this.safeValue(market, "contractSize");
        Object contractSizeString = this.numberToString(contractSize);
        // as oppose to notionalValue
        Object linear = (Helpers.inOp(position, "notional"));
        if (Helpers.isTrue(Helpers.isEqual(marginMode, "cross")))
        {
            // calculate collateral
            Object precision = this.safeDict(market, "precision", new java.util.HashMap<String, Object>() {{}});
            Object basePrecisionValue = this.safeString(precision, "base");
            Object quotePrecisionValue = this.safeString2(precision, "quote", "price");
            Object precisionIsUndefined = Helpers.isTrue((Helpers.isEqual(basePrecisionValue, null))) && Helpers.isTrue((Helpers.isEqual(quotePrecisionValue, null)));
            if (!Helpers.isTrue(precisionIsUndefined))
            {
                if (Helpers.isTrue(linear))
                {
                    // walletBalance = (liquidationPrice * (1 + mmp)  entryPrice) * contracts
                    Object onePlusMaintenanceMarginPercentageString = null;
                    Object entryPriceSignString = entryPriceString;
                    if (Helpers.isTrue(Helpers.isEqual(side, "short")))
                    {
                        onePlusMaintenanceMarginPercentageString = Precise.stringAdd("1", maintenanceMarginPercentageString);
                        entryPriceSignString = Precise.stringMul("-1", entryPriceSignString);
                    } else
                    {
                        onePlusMaintenanceMarginPercentageString = Precise.stringAdd("-1", maintenanceMarginPercentageString);
                    }
                    Object inner = Precise.stringMul(liquidationPriceString, onePlusMaintenanceMarginPercentageString);
                    Object leftSide = Precise.stringAdd(inner, entryPriceSignString);
                    Object quotePrecision = this.precisionFromString(this.safeString2(precision, "quote", "price"));
                    if (Helpers.isTrue(!Helpers.isEqual(quotePrecision, null)))
                    {
                        collateralString = Precise.stringDiv(Precise.stringMul(leftSide, contractsAbs), "1", quotePrecision);
                    }
                } else
                {
                    // walletBalance = (contracts * contractSize) * (1/entryPrice - (1 - mmp) / liquidationPrice)
                    Object onePlusMaintenanceMarginPercentageString = null;
                    Object entryPriceSignString = entryPriceString;
                    if (Helpers.isTrue(Helpers.isEqual(side, "short")))
                    {
                        onePlusMaintenanceMarginPercentageString = Precise.stringSub("1", maintenanceMarginPercentageString);
                    } else
                    {
                        onePlusMaintenanceMarginPercentageString = Precise.stringSub("-1", maintenanceMarginPercentageString);
                        entryPriceSignString = Precise.stringMul("-1", entryPriceSignString);
                    }
                    Object leftSide = Precise.stringMul(contractsAbs, contractSizeString);
                    Object rightSide = Precise.stringSub(Precise.stringDiv("1", entryPriceSignString), Precise.stringDiv(onePlusMaintenanceMarginPercentageString, liquidationPriceString));
                    Object basePrecision = this.precisionFromString(this.safeString(precision, "base"));
                    if (Helpers.isTrue(!Helpers.isEqual(basePrecision, null)))
                    {
                        collateralString = Precise.stringDiv(Precise.stringMul(leftSide, rightSide), "1", basePrecision);
                    }
                }
            }
        } else
        {
            collateralString = this.safeString(position, "isolatedMargin");
        }
        collateralString = ((Helpers.isTrue((Helpers.isEqual(collateralString, null))))) ? "0" : collateralString;
        Object collateral = this.parseNumber(collateralString);
        Object markPrice = this.parseNumber(this.omitZero(this.safeString(position, "markPrice")));
        Object timestamp = this.safeInteger(position, "updateTime");
        if (Helpers.isTrue(Helpers.isEqual(timestamp, 0)))
        {
            timestamp = null;
        }
        Object maintenanceMarginPercentage = this.parseNumber(maintenanceMarginPercentageString);
        Object maintenanceMarginString = Precise.stringMul(maintenanceMarginPercentageString, notionalStringAbs);
        if (Helpers.isTrue(Helpers.isEqual(maintenanceMarginString, null)))
        {
            // for a while, this new value was a backup to the existing calculations, but in future we might prioritize this
            maintenanceMarginString = this.safeString(position, "maintMargin");
        }
        Object maintenanceMargin = this.parseNumber(maintenanceMarginString);
        Object initialMarginString = null;
        Object initialMarginPercentageString = null;
        Object leverageString = this.safeString(position, "leverage");
        if (Helpers.isTrue(!Helpers.isEqual(leverageString, null)))
        {
            Object leverage = Helpers.parseInt(leverageString);
            Object rational = this.isRoundNumber(Helpers.mod(1000, leverage));
            initialMarginPercentageString = Precise.stringDiv("1", leverageString, 8);
            if (!Helpers.isTrue(rational))
            {
                initialMarginPercentageString = Precise.stringAdd(initialMarginPercentageString, "1e-8");
            }
            Object unrounded = Precise.stringMul(notionalStringAbs, initialMarginPercentageString);
            initialMarginString = Precise.stringDiv(unrounded, "1", 8);
        } else
        {
            initialMarginString = this.safeString(position, "initialMargin");
            Object unrounded = Precise.stringMul(initialMarginString, "1");
            initialMarginPercentageString = Precise.stringDiv(unrounded, notionalStringAbs, 8);
        }
        Object marginRatio = null;
        Object percentage = null;
        if (!Helpers.isTrue(Precise.stringEquals(collateralString, "0")))
        {
            marginRatio = this.parseNumber(Precise.stringDiv(Precise.stringAdd(Precise.stringDiv(maintenanceMarginString, collateralString), "5e-5"), "1", 4));
            percentage = this.parseNumber(Precise.stringMul(Precise.stringDiv(unrealizedPnlString, initialMarginString, 4), "100"));
        }
        Object positionSide = this.safeString(position, "positionSide");
        Object hedged = !Helpers.isEqual(positionSide, "BOTH");
        final Object finalLeverageString = leverageString;
        final Object finalTimestamp = timestamp;
        final Object finalInitialMarginString = initialMarginString;
        final Object finalInitialMarginPercentageString = initialMarginPercentageString;
        final Object finalMarginRatio = marginRatio;
        final Object finalMarginMode = marginMode;
        final Object finalSide = side;
        final Object finalPercentage = percentage;
        return new java.util.HashMap<String, Object>() {{
            put( "info", position );
            put( "id", null );
            put( "symbol", symbol );
            put( "contracts", contracts );
            put( "contractSize", contractSize );
            put( "unrealizedPnl", unrealizedPnl );
            put( "leverage", Binance.this.parseNumber(finalLeverageString) );
            put( "liquidationPrice", liquidationPrice );
            put( "collateral", collateral );
            put( "notional", notional );
            put( "markPrice", markPrice );
            put( "entryPrice", entryPrice );
            put( "timestamp", finalTimestamp );
            put( "initialMargin", Binance.this.parseNumber(finalInitialMarginString) );
            put( "initialMarginPercentage", Binance.this.parseNumber(finalInitialMarginPercentageString) );
            put( "maintenanceMargin", maintenanceMargin );
            put( "maintenanceMarginPercentage", maintenanceMarginPercentage );
            put( "marginRatio", finalMarginRatio );
            put( "datetime", Binance.this.iso8601(finalTimestamp) );
            put( "marginMode", finalMarginMode );
            put( "marginType", finalMarginMode );
            put( "side", finalSide );
            put( "hedged", hedged );
            put( "percentage", finalPercentage );
            put( "stopLossPrice", null );
            put( "takeProfitPrice", null );
        }};
    }

    public java.util.concurrent.CompletableFuture<Object> loadLeverageBrackets(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object reload = Helpers.getArg(optionalArgs, 0, false);
            Object parameters = Helpers.getArg(optionalArgs, 1, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            // by default cache the leverage bracket
            // it contains useful stuff like the maintenance margin and initial margin for positions
            Object leverageBrackets = this.safeDict(this.options, "leverageBrackets");
            if (Helpers.isTrue(Helpers.isTrue((Helpers.isEqual(leverageBrackets, null))) || Helpers.isTrue((reload))))
            {
                Object defaultType = this.safeString(this.options, "defaultType", "future");
                Object type = this.safeString(parameters, "type", defaultType);
                Object query = this.omit(parameters, "type");
                Object subType = null;
                var subTypeparametersVariable = this.handleSubTypeAndParams("loadLeverageBrackets", null, parameters, "linear");
                subType = ((java.util.List<Object>) subTypeparametersVariable).get(0);
                parameters = ((java.util.List<Object>) subTypeparametersVariable).get(1);
                Object isPortfolioMargin = null;
                var isPortfolioMarginparametersVariable = this.handleOptionAndParams2(parameters, "loadLeverageBrackets", "papi", "portfolioMargin", false);
                isPortfolioMargin = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(0);
                parameters = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(1);
                Object response = null;
                if (Helpers.isTrue(this.isLinear(type, subType)))
                {
                    if (Helpers.isTrue(isPortfolioMargin))
                    {
                        response = (this.papiGetUmLeverageBracket(query)).join();
                    } else
                    {
                        response = (this.fapiPrivateGetLeverageBracket(query)).join();
                    }
                } else if (Helpers.isTrue(this.isInverse(type, subType)))
                {
                    if (Helpers.isTrue(isPortfolioMargin))
                    {
                        response = (this.papiGetCmLeverageBracket(query)).join();
                    } else
                    {
                        response = (this.dapiPrivateV2GetLeverageBracket(query)).join();
                    }
                } else
                {
                    throw new NotSupported((String)Helpers.add(this.id, " loadLeverageBrackets() supports linear and inverse contracts only")) ;
                }
                Helpers.addElementToObject(this.options, "leverageBrackets", this.createSafeDictionary());
                for (var i = 0; Helpers.isLessThan(i, Helpers.getArrayLength(response)); i++)
                {
                    Object entry = Helpers.GetValue(response, i);
                    Object marketId = this.safeString(entry, "symbol");
                    Object symbol = this.safeSymbol(marketId, null, null, "contract");
                    Object brackets = this.safeList(entry, "brackets", new java.util.ArrayList<Object>(java.util.Arrays.asList()));
                    Object result = new java.util.ArrayList<Object>(java.util.Arrays.asList());
                    for (var j = 0; Helpers.isLessThan(j, Helpers.getArrayLength(brackets)); j++)
                    {
                        Object bracket = Helpers.GetValue(brackets, j);
                        Object floorValue = this.safeString2(bracket, "notionalFloor", "qtyFloor");
                        Object maintenanceMarginPercentage = this.safeString(bracket, "maintMarginRatio");
                        ((java.util.List<Object>)result).add(new java.util.ArrayList<Object>(java.util.Arrays.asList(floorValue, maintenanceMarginPercentage)));
                    }
                    Helpers.addElementToObject(Helpers.GetValue(this.options, "leverageBrackets"), symbol, result);
                }
            }
            return Helpers.GetValue(this.options, "leverageBrackets");
        });

    }

    /**
     * @method
     * @name binance#fetchLeverageTiers
     * @description retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/account/rest-api/Notional-and-Leverage-Brackets
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/account/rest-api/Notional-Bracket-for-Pair
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/account/UM-Notional-and-Leverage-Brackets
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/account/CM-Notional-and-Leverage-Brackets
     * @param {string[]|undefined} symbols list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.portfolioMargin] set to true if you would like to fetch the leverage tiers for a portfolio margin account
     * @param {string} [params.subType] "linear" or "inverse"
     * @returns {object} a dictionary of [leverage tiers structures]{@link https://docs.ccxt.com/#/?id=leverage-tiers-structure}, indexed by market symbols
     */
    public java.util.concurrent.CompletableFuture<Object> fetchLeverageTiers(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object symbols = Helpers.getArg(optionalArgs, 0, null);
            Object parameters = Helpers.getArg(optionalArgs, 1, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object type = null;
            var typeparametersVariable = this.handleMarketTypeAndParams("fetchLeverageTiers", null, parameters);
            type = ((java.util.List<Object>) typeparametersVariable).get(0);
            parameters = ((java.util.List<Object>) typeparametersVariable).get(1);
            Object subType = null;
            var subTypeparametersVariable = this.handleSubTypeAndParams("fetchLeverageTiers", null, parameters, "linear");
            subType = ((java.util.List<Object>) subTypeparametersVariable).get(0);
            parameters = ((java.util.List<Object>) subTypeparametersVariable).get(1);
            Object isPortfolioMargin = null;
            var isPortfolioMarginparametersVariable = this.handleOptionAndParams2(parameters, "fetchLeverageTiers", "papi", "portfolioMargin", false);
            isPortfolioMargin = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(0);
            parameters = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(1);
            Object response = null;
            if (Helpers.isTrue(this.isLinear(type, subType)))
            {
                if (Helpers.isTrue(isPortfolioMargin))
                {
                    response = (this.papiGetUmLeverageBracket(parameters)).join();
                } else
                {
                    response = (this.fapiPrivateGetLeverageBracket(parameters)).join();
                }
            } else if (Helpers.isTrue(this.isInverse(type, subType)))
            {
                if (Helpers.isTrue(isPortfolioMargin))
                {
                    response = (this.papiGetCmLeverageBracket(parameters)).join();
                } else
                {
                    response = (this.dapiPrivateV2GetLeverageBracket(parameters)).join();
                }
            } else
            {
                throw new NotSupported((String)Helpers.add(this.id, " fetchLeverageTiers() supports linear and inverse contracts only")) ;
            }
            //
            // usdm
            //
            //    [
            //        {
            //            "symbol": "SUSHIUSDT",
            //            "brackets": [
            //                {
            //                    "bracket": 1,
            //                    "initialLeverage": 50,
            //                    "notionalCap": 50000,
            //                    "notionalFloor": 0,
            //                    "maintMarginRatio": 0.01,
            //                    "cum": 0.0
            //                },
            //                ...
            //            ]
            //        }
            //    ]
            //
            // coinm
            //
            //     [
            //         {
            //             "symbol":"XRPUSD_210326",
            //             "brackets":[
            //                 {
            //                     "bracket":1,
            //                     "initialLeverage":20,
            //                     "qtyCap":500000,
            //                     "qtyFloor":0,
            //                     "maintMarginRatio":0.0185,
            //                     "cum":0.0
            //                 }
            //             ]
            //         }
            //     ]
            //
            return this.parseLeverageTiers(response, symbols, "symbol");
        });

    }

    public Object parseMarketLeverageTiers(Object info, Object... optionalArgs)
    {
        /**
        * @ignore
        * @method
        * @param {object} info Exchange response for 1 market
        * @param {object} market CCXT market
        */
        //
        //    {
        //        "symbol": "SUSHIUSDT",
        //        "brackets": [
        //            {
        //                "bracket": 1,
        //                "initialLeverage": 50,
        //                "notionalCap": 50000,
        //                "notionalFloor": 0,
        //                "maintMarginRatio": 0.01,
        //                "cum": 0.0
        //            },
        //            ...
        //        ]
        //    }
        //
        Object market = Helpers.getArg(optionalArgs, 0, null);
        Object marketId = this.safeString(info, "symbol");
        market = this.safeMarket(marketId, market, null, "contract");
        Object brackets = this.safeList(info, "brackets", new java.util.ArrayList<Object>(java.util.Arrays.asList()));
        Object tiers = new java.util.ArrayList<Object>(java.util.Arrays.asList());
        for (var j = 0; Helpers.isLessThan(j, Helpers.getArrayLength(brackets)); j++)
        {
            Object bracket = Helpers.GetValue(brackets, j);
final Object finalMarket = market;
                        ((java.util.List<Object>)tiers).add(new java.util.HashMap<String, Object>() {{
                put( "tier", Binance.this.safeNumber(bracket, "bracket") );
                put( "symbol", Binance.this.safeSymbol(marketId, finalMarket) );
                put( "currency", Helpers.GetValue(finalMarket, "quote") );
                put( "minNotional", Binance.this.safeNumber2(bracket, "notionalFloor", "qtyFloor") );
                put( "maxNotional", Binance.this.safeNumber2(bracket, "notionalCap", "qtyCap") );
                put( "maintenanceMarginRate", Binance.this.safeNumber(bracket, "maintMarginRatio") );
                put( "maxLeverage", Binance.this.safeNumber(bracket, "initialLeverage") );
                put( "info", bracket );
            }});
        }
        return tiers;
    }

    /**
     * @method
     * @name binance#fetchPosition
     * @description fetch data on an open position
     * @see https://developers.binance.com/docs/derivatives/option/trade/Option-Position-Information
     * @param {string} symbol unified market symbol of the market the position is held in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchPosition(Object symbol, Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object parameters = Helpers.getArg(optionalArgs, 0, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object market = this.market(symbol);
            if (!Helpers.isTrue(Helpers.GetValue(market, "option")))
            {
                throw new NotSupported((String)Helpers.add(this.id, " fetchPosition() supports option markets only")) ;
            }
            Object request = new java.util.HashMap<String, Object>() {{
                put( "symbol", Helpers.GetValue(market, "id") );
            }};
            Object response = (this.eapiPrivateGetPosition(this.extend(request, parameters))).join();
            //
            //     [
            //         {
            //             "entryPrice": "27.70000000",
            //             "symbol": "ETH-230426-1850-C",
            //             "side": "LONG",
            //             "quantity": "0.50000000",
            //             "reducibleQty": "0.50000000",
            //             "markValue": "10.250000000",
            //             "ror": "-0.2599",
            //             "unrealizedPNL": "-3.600000000",
            //             "markPrice": "20.5",
            //             "strikePrice": "1850.00000000",
            //             "positionCost": "13.85000000",
            //             "expiryDate": 1682496000000,
            //             "priceScale": 1,
            //             "quantityScale": 2,
            //             "optionSide": "CALL",
            //             "quoteAsset": "USDT",
            //             "time": 1682492427106
            //         }
            //     ]
            //
            return this.parsePosition(Helpers.GetValue(response, 0), market);
        });

    }

    /**
     * @method
     * @name binance#fetchOptionPositions
     * @description fetch data on open options positions
     * @see https://developers.binance.com/docs/derivatives/option/trade/Option-Position-Information
     * @param {string[]|undefined} symbols list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [position structures]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchOptionPositions(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object symbols = Helpers.getArg(optionalArgs, 0, null);
            Object parameters = Helpers.getArg(optionalArgs, 1, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            symbols = this.marketSymbols(symbols);
            Object request = new java.util.HashMap<String, Object>() {{}};
            Object market = null;
            if (Helpers.isTrue(!Helpers.isEqual(symbols, null)))
            {
                Object symbol = null;
                if (Helpers.isTrue(((symbols instanceof java.util.List) || (symbols.getClass().isArray()))))
                {
                    Object symbolsLength = Helpers.getArrayLength(symbols);
                    if (Helpers.isTrue(Helpers.isGreaterThan(symbolsLength, 1)))
                    {
                        throw new BadRequest((String)Helpers.add(this.id, " fetchPositions() symbols argument cannot contain more than 1 symbol")) ;
                    }
                    symbol = Helpers.GetValue(symbols, 0);
                } else
                {
                    symbol = symbols;
                }
                market = this.market(symbol);
                Helpers.addElementToObject(request, "symbol", Helpers.GetValue(market, "id"));
            }
            Object response = (this.eapiPrivateGetPosition(this.extend(request, parameters))).join();
            //
            //     [
            //         {
            //             "entryPrice": "27.70000000",
            //             "symbol": "ETH-230426-1850-C",
            //             "side": "LONG",
            //             "quantity": "0.50000000",
            //             "reducibleQty": "0.50000000",
            //             "markValue": "10.250000000",
            //             "ror": "-0.2599",
            //             "unrealizedPNL": "-3.600000000",
            //             "markPrice": "20.5",
            //             "strikePrice": "1850.00000000",
            //             "positionCost": "13.85000000",
            //             "expiryDate": 1682496000000,
            //             "priceScale": 1,
            //             "quantityScale": 2,
            //             "optionSide": "CALL",
            //             "quoteAsset": "USDT",
            //             "time": 1682492427106
            //         }
            //     ]
            //
            Object result = new java.util.ArrayList<Object>(java.util.Arrays.asList());
            for (var i = 0; Helpers.isLessThan(i, Helpers.getArrayLength(response)); i++)
            {
                ((java.util.List<Object>)result).add(this.parsePosition(Helpers.GetValue(response, i), market));
            }
            return this.filterByArrayPositions(result, "symbol", symbols, false);
        });

    }

    public Object parsePosition(Object position, Object... optionalArgs)
    {
        //
        //     {
        //         "entryPrice": "27.70000000",
        //         "symbol": "ETH-230426-1850-C",
        //         "side": "LONG",
        //         "quantity": "0.50000000",
        //         "reducibleQty": "0.50000000",
        //         "markValue": "10.250000000",
        //         "ror": "-0.2599",
        //         "unrealizedPNL": "-3.600000000",
        //         "markPrice": "20.5",
        //         "strikePrice": "1850.00000000",
        //         "positionCost": "13.85000000",
        //         "expiryDate": 1682496000000,
        //         "priceScale": 1,
        //         "quantityScale": 2,
        //         "optionSide": "CALL",
        //         "quoteAsset": "USDT",
        //         "time": 1682492427106
        //     }
        //
        Object market = Helpers.getArg(optionalArgs, 0, null);
        Object marketId = this.safeString(position, "symbol");
        market = this.safeMarket(marketId, market, null, "swap");
        Object symbol = Helpers.GetValue(market, "symbol");
        Object side = this.safeStringLower(position, "side");
        Object quantity = this.safeString(position, "quantity");
        if (Helpers.isTrue(!Helpers.isEqual(side, "long")))
        {
            quantity = Precise.stringMul("-1", quantity);
        }
        Object timestamp = this.safeInteger(position, "time");
        final Object finalSide = side;
        final Object finalQuantity = quantity;
        return this.safePosition(new java.util.HashMap<String, Object>() {{
            put( "info", position );
            put( "id", null );
            put( "symbol", symbol );
            put( "entryPrice", Binance.this.safeNumber(position, "entryPrice") );
            put( "markPrice", Binance.this.safeNumber(position, "markPrice") );
            put( "notional", Binance.this.safeNumber(position, "markValue") );
            put( "collateral", Binance.this.safeNumber(position, "positionCost") );
            put( "unrealizedPnl", Binance.this.safeNumber(position, "unrealizedPNL") );
            put( "side", finalSide );
            put( "contracts", Binance.this.parseNumber(finalQuantity) );
            put( "contractSize", null );
            put( "timestamp", timestamp );
            put( "datetime", Binance.this.iso8601(timestamp) );
            put( "hedged", null );
            put( "maintenanceMargin", null );
            put( "maintenanceMarginPercentage", null );
            put( "initialMargin", null );
            put( "initialMarginPercentage", null );
            put( "leverage", null );
            put( "liquidationPrice", null );
            put( "marginRatio", null );
            put( "marginMode", null );
            put( "percentage", null );
        }});
    }

    /**
     * @method
     * @name binance#fetchPositions
     * @description fetch all open positions
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/account/rest-api/Account-Information-V2
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/account/rest-api/Account-Information
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Position-Information-V2
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Position-Information
     * @see https://developers.binance.com/docs/derivatives/option/trade/Option-Position-Information
     * @param {string[]} [symbols] list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {object} [params.params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.method] method name to call, "positionRisk", "account" or "option", default is "positionRisk"
     * @param {bool} [params.useV2] set to true if you want to use the obsolete endpoint, where some more additional fields were provided
     * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchPositions(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object symbols = Helpers.getArg(optionalArgs, 0, null);
            Object parameters = Helpers.getArg(optionalArgs, 1, new java.util.HashMap<String, Object>() {{}});
            Object defaultMethod = null;
            var defaultMethodparametersVariable = this.handleOptionAndParams(parameters, "fetchPositions", "method");
            defaultMethod = ((java.util.List<Object>) defaultMethodparametersVariable).get(0);
            parameters = ((java.util.List<Object>) defaultMethodparametersVariable).get(1);
            if (Helpers.isTrue(Helpers.isEqual(defaultMethod, null)))
            {
                Object options = this.safeDict(this.options, "fetchPositions");
                if (Helpers.isTrue(Helpers.isEqual(options, null)))
                {
                    defaultMethod = this.safeString(this.options, "fetchPositions", "positionRisk");
                } else
                {
                    defaultMethod = "positionRisk";
                }
            }
            if (Helpers.isTrue(Helpers.isEqual(defaultMethod, "positionRisk")))
            {
                return (this.fetchPositionsRisk(symbols, parameters)).join();
            } else if (Helpers.isTrue(Helpers.isEqual(defaultMethod, "account")))
            {
                return (this.fetchAccountPositions(symbols, parameters)).join();
            } else if (Helpers.isTrue(Helpers.isEqual(defaultMethod, "option")))
            {
                return (this.fetchOptionPositions(symbols, parameters)).join();
            } else
            {
                throw new NotSupported((String)Helpers.add(Helpers.add(Helpers.add(this.id, ".options[\"fetchPositions\"][\"method\"] or params[\"method\"] = \""), defaultMethod), "\" is invalid, please choose between \"account\", \"positionRisk\" and \"option\"")) ;
            }
        });

    }

    /**
     * @method
     * @name binance#fetchAccountPositions
     * @ignore
     * @description fetch account positions
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/account/rest-api/Account-Information-V2
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/account/rest-api/Account-Information
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Position-Information-V2
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Position-Information
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/account/rest-api/Account-Information-V3
     * @param {string[]} [symbols] list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.portfolioMargin] set to true if you would like to fetch positions in a portfolio margin account
     * @param {string} [params.subType] "linear" or "inverse"
     * @param {boolean} [params.filterClosed] set to true if you would like to filter out closed positions, default is false
     * @param {boolean} [params.useV2] set to true if you want to use obsolete endpoint, where some more additional fields were provided
     * @returns {object} data on account positions
     */
    public java.util.concurrent.CompletableFuture<Object> fetchAccountPositions(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object symbols = Helpers.getArg(optionalArgs, 0, null);
            Object parameters = Helpers.getArg(optionalArgs, 1, new java.util.HashMap<String, Object>() {{}});
            if (Helpers.isTrue(!Helpers.isEqual(symbols, null)))
            {
                if (!Helpers.isTrue(((symbols instanceof java.util.List) || (symbols.getClass().isArray()))))
                {
                    throw new ArgumentsRequired((String)Helpers.add(this.id, " fetchPositions() requires an array argument for symbols")) ;
                }
            }
            (this.loadMarkets()).join();
            (this.loadLeverageBrackets(false, parameters)).join();
            Object defaultType = this.safeString(this.options, "defaultType", "future");
            Object type = this.safeString(parameters, "type", defaultType);
            parameters = this.omit(parameters, "type");
            Object subType = null;
            var subTypeparametersVariable = this.handleSubTypeAndParams("fetchAccountPositions", null, parameters, "linear");
            subType = ((java.util.List<Object>) subTypeparametersVariable).get(0);
            parameters = ((java.util.List<Object>) subTypeparametersVariable).get(1);
            Object isPortfolioMargin = null;
            var isPortfolioMarginparametersVariable = this.handleOptionAndParams2(parameters, "fetchAccountPositions", "papi", "portfolioMargin", false);
            isPortfolioMargin = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(0);
            parameters = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(1);
            Object response = null;
            if (Helpers.isTrue(this.isLinear(type, subType)))
            {
                if (Helpers.isTrue(isPortfolioMargin))
                {
                    response = (this.papiGetUmAccount(parameters)).join();
                } else
                {
                    Object useV2 = null;
                    var useV2parametersVariable = this.handleOptionAndParams(parameters, "fetchAccountPositions", "useV2", false);
                    useV2 = ((java.util.List<Object>) useV2parametersVariable).get(0);
                    parameters = ((java.util.List<Object>) useV2parametersVariable).get(1);
                    if (!Helpers.isTrue(useV2))
                    {
                        response = (this.fapiPrivateV3GetAccount(parameters)).join();
                    } else
                    {
                        response = (this.fapiPrivateV2GetAccount(parameters)).join();
                    }
                }
            } else if (Helpers.isTrue(this.isInverse(type, subType)))
            {
                if (Helpers.isTrue(isPortfolioMargin))
                {
                    response = (this.papiGetCmAccount(parameters)).join();
                } else
                {
                    response = (this.dapiPrivateGetAccount(parameters)).join();
                }
            } else
            {
                throw new NotSupported((String)Helpers.add(this.id, " fetchPositions() supports linear and inverse contracts only")) ;
            }
            Object filterClosed = null;
            var filterClosedparametersVariable = this.handleOptionAndParams(parameters, "fetchAccountPositions", "filterClosed", false);
            filterClosed = ((java.util.List<Object>) filterClosedparametersVariable).get(0);
            parameters = ((java.util.List<Object>) filterClosedparametersVariable).get(1);
            Object result = this.parseAccountPositions(response, filterClosed);
            symbols = this.marketSymbols(symbols);
            return this.filterByArrayPositions(result, "symbol", symbols, false);
        });

    }

    /**
     * @method
     * @name binance#fetchPositionsRisk
     * @ignore
     * @description fetch positions risk
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Position-Information-V2
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Position-Information
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/account/Query-UM-Position-Information
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/account/Query-CM-Position-Information
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Position-Information-V3
     * @param {string[]|undefined} symbols list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.portfolioMargin] set to true if you would like to fetch positions for a portfolio margin account
     * @param {string} [params.subType] "linear" or "inverse"
     * @param {bool} [params.useV2] set to true if you want to use the obsolete endpoint, where some more additional fields were provided
     * @returns {object} data on the positions risk
     */
    public java.util.concurrent.CompletableFuture<Object> fetchPositionsRisk(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object symbols = Helpers.getArg(optionalArgs, 0, null);
            Object parameters = Helpers.getArg(optionalArgs, 1, new java.util.HashMap<String, Object>() {{}});
            if (Helpers.isTrue(!Helpers.isEqual(symbols, null)))
            {
                if (!Helpers.isTrue(((symbols instanceof java.util.List) || (symbols.getClass().isArray()))))
                {
                    throw new ArgumentsRequired((String)Helpers.add(this.id, " fetchPositionsRisk() requires an array argument for symbols")) ;
                }
            }
            (this.loadMarkets()).join();
            (this.loadLeverageBrackets(false, parameters)).join();
            Object request = new java.util.HashMap<String, Object>() {{}};
            Object defaultType = "future";
            defaultType = this.safeString(this.options, "defaultType", defaultType);
            Object type = this.safeString(parameters, "type", defaultType);
            Object subType = null;
            var subTypeparametersVariable = this.handleSubTypeAndParams("fetchPositionsRisk", null, parameters, "linear");
            subType = ((java.util.List<Object>) subTypeparametersVariable).get(0);
            parameters = ((java.util.List<Object>) subTypeparametersVariable).get(1);
            Object isPortfolioMargin = null;
            var isPortfolioMarginparametersVariable = this.handleOptionAndParams2(parameters, "fetchPositionsRisk", "papi", "portfolioMargin", false);
            isPortfolioMargin = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(0);
            parameters = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(1);
            parameters = this.omit(parameters, "type");
            Object response = null;
            if (Helpers.isTrue(this.isLinear(type, subType)))
            {
                if (Helpers.isTrue(isPortfolioMargin))
                {
                    response = (this.papiGetUmPositionRisk(this.extend(request, parameters))).join();
                } else
                {
                    Object useV2 = null;
                    var useV2parametersVariable = this.handleOptionAndParams(parameters, "fetchPositionsRisk", "useV2", false);
                    useV2 = ((java.util.List<Object>) useV2parametersVariable).get(0);
                    parameters = ((java.util.List<Object>) useV2parametersVariable).get(1);
                    parameters = this.extend(request, parameters);
                    if (!Helpers.isTrue(useV2))
                    {
                        response = (this.fapiPrivateV3GetPositionRisk(parameters)).join();
                    } else
                    {
                        response = (this.fapiPrivateV2GetPositionRisk(parameters)).join();
                    }
                }
            } else if (Helpers.isTrue(this.isInverse(type, subType)))
            {
                if (Helpers.isTrue(isPortfolioMargin))
                {
                    response = (this.papiGetCmPositionRisk(this.extend(request, parameters))).join();
                } else
                {
                    response = (this.dapiPrivateGetPositionRisk(this.extend(request, parameters))).join();
                }
            } else
            {
                throw new NotSupported((String)Helpers.add(this.id, " fetchPositionsRisk() supports linear and inverse contracts only")) ;
            }
            // ### Response examples ###
            //
            // For One-way position mode:
            //
            //     [
            //         {
            //             "symbol": "BTCUSDT",
            //             "positionSide": "BOTH",
            //             "positionAmt": "0.000",
            //             "entryPrice": "0.00000",
            //             "markPrice": "6679.50671178",
            //             "unRealizedProfit": "0.00000000",
            //             "liquidationPrice": "0",
            //             "isolatedMargin": "0.00000000",
            //             "marginType": "isolated",
            //             "isAutoAddMargin": "false",
            //             "leverage": "10",
            //             "maxNotionalValue": "20000000",
            //             "updateTime": 0
            //        }
            //     ]
            //
            // For Hedge position mode:
            //
            //     [
            //         {
            //             "entryPrice": "6563.66500",
            //             "marginType": "isolated",
            //             "isAutoAddMargin": "false",
            //             "isolatedMargin": "15517.54150468",
            //             "leverage": "10",
            //             "liquidationPrice": "5930.78",
            //             "markPrice": "6679.50671178",
            //             "maxNotionalValue": "20000000",
            //             "positionSide": "LONG",
            //             "positionAmt": "20.000", // negative value for 'SHORT'
            //             "symbol": "BTCUSDT",
            //             "unRealizedProfit": "2316.83423560"
            //             "updateTime": 1625474304765
            //         },
            //         .. second dict is similar, but with `positionSide: SHORT`
            //     ]
            //
            // inverse portfolio margin:
            //
            //     [
            //         {
            //             "symbol": "ETHUSD_PERP",
            //             "positionAmt": "1",
            //             "entryPrice": "2422.400000007",
            //             "markPrice": "2424.51267823",
            //             "unRealizedProfit": "0.0000036",
            //             "liquidationPrice": "293.57678898",
            //             "leverage": "100",
            //             "positionSide": "LONG",
            //             "updateTime": 1707371941861,
            //             "maxQty": "15",
            //             "notionalValue": "0.00412454",
            //             "breakEvenPrice": "2423.368960034"
            //         }
            //     ]
            //
            // linear portfolio margin:
            //
            //     [
            //         {
            //             "symbol": "BTCUSDT",
            //             "positionAmt": "0.01",
            //             "entryPrice": "44525.0",
            //             "markPrice": "45464.1735922",
            //             "unRealizedProfit": "9.39173592",
            //             "liquidationPrice": "38007.16308568",
            //             "leverage": "100",
            //             "positionSide": "LONG",
            //             "updateTime": 1707371879042,
            //             "maxNotionalValue": "500000.0",
            //             "notional": "454.64173592",
            //             "breakEvenPrice": "44542.81"
            //         }
            //     ]
            //
            Object result = new java.util.ArrayList<Object>(java.util.Arrays.asList());
            for (var i = 0; Helpers.isLessThan(i, Helpers.getArrayLength(response)); i++)
            {
                Object rawPosition = Helpers.GetValue(response, i);
                Object entryPriceString = this.safeString(rawPosition, "entryPrice");
                if (Helpers.isTrue(Precise.stringGt(entryPriceString, "0")))
                {
                    ((java.util.List<Object>)result).add(this.parsePositionRisk(Helpers.GetValue(response, i)));
                }
            }
            symbols = this.marketSymbols(symbols);
            return this.filterByArrayPositions(result, "symbol", symbols, false);
        });

    }

    /**
     * @method
     * @name binance#fetchFundingHistory
     * @description fetch the history of funding payments paid and received on this account
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/account/rest-api/Get-Income-History
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/account/rest-api/Get-Income-History
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/account/Get-UM-Income-History
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/account/Get-CM-Income-History
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch funding history for
     * @param {int} [limit] the maximum number of funding history structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest funding history entry
     * @param {boolean} [params.portfolioMargin] set to true if you would like to fetch the funding history for a portfolio margin account
     * @param {string} [params.subType] "linear" or "inverse"
     * @returns {object} a [funding history structure]{@link https://docs.ccxt.com/#/?id=funding-history-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchFundingHistory(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object symbol = Helpers.getArg(optionalArgs, 0, null);
            Object since = Helpers.getArg(optionalArgs, 1, null);
            Object limit = Helpers.getArg(optionalArgs, 2, null);
            Object parameters = Helpers.getArg(optionalArgs, 3, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object market = null;
            Object request = new java.util.HashMap<String, Object>() {{
                put( "incomeType", "FUNDING_FEE" );
            }};
            if (Helpers.isTrue(!Helpers.isEqual(symbol, null)))
            {
                market = this.market(symbol);
                Helpers.addElementToObject(request, "symbol", Helpers.GetValue(market, "id"));
                if (!Helpers.isTrue(Helpers.GetValue(market, "swap")))
                {
                    throw new NotSupported((String)Helpers.add(this.id, " fetchFundingHistory() supports swap contracts only")) ;
                }
            }
            Object subType = null;
            var subTypeparametersVariable = this.handleSubTypeAndParams("fetchFundingHistory", market, parameters, "linear");
            subType = ((java.util.List<Object>) subTypeparametersVariable).get(0);
            parameters = ((java.util.List<Object>) subTypeparametersVariable).get(1);
            Object isPortfolioMargin = null;
            var isPortfolioMarginparametersVariable = this.handleOptionAndParams2(parameters, "fetchFundingHistory", "papi", "portfolioMargin", false);
            isPortfolioMargin = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(0);
            parameters = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(1);
            var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
            request = ((java.util.List<Object>) requestparametersVariable).get(0);
            parameters = ((java.util.List<Object>) requestparametersVariable).get(1);
            if (Helpers.isTrue(!Helpers.isEqual(since, null)))
            {
                Helpers.addElementToObject(request, "startTime", since);
            }
            if (Helpers.isTrue(!Helpers.isEqual(limit, null)))
            {
                Helpers.addElementToObject(request, "limit", limit);
            }
            Object defaultType = this.safeString2(this.options, "fetchFundingHistory", "defaultType", "future");
            Object type = this.safeString(parameters, "type", defaultType);
            parameters = this.omit(parameters, "type");
            Object response = null;
            if (Helpers.isTrue(this.isLinear(type, subType)))
            {
                if (Helpers.isTrue(isPortfolioMargin))
                {
                    response = (this.papiGetUmIncome(this.extend(request, parameters))).join();
                } else
                {
                    response = (this.fapiPrivateGetIncome(this.extend(request, parameters))).join();
                }
            } else if (Helpers.isTrue(this.isInverse(type, subType)))
            {
                if (Helpers.isTrue(isPortfolioMargin))
                {
                    response = (this.papiGetCmIncome(this.extend(request, parameters))).join();
                } else
                {
                    response = (this.dapiPrivateGetIncome(this.extend(request, parameters))).join();
                }
            } else
            {
                throw new NotSupported((String)Helpers.add(this.id, " fetchFundingHistory() supports linear and inverse contracts only")) ;
            }
            return this.parseIncomes(response, market, since, limit);
        });

    }

    /**
     * @method
     * @name binance#setLeverage
     * @description set the level of leverage for a market
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Change-Initial-Leverage
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Change-Initial-Leverage
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/account/Change-UM-Initial-Leverage
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/account/Change-CM-Initial-Leverage
     * @param {float} leverage the rate of leverage
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.portfolioMargin] set to true if you would like to set the leverage for a trading pair in a portfolio margin account
     * @returns {object} response from the exchange
     */
    public java.util.concurrent.CompletableFuture<Object> setLeverage(Object leverage2, Object... optionalArgs)
    {
        final Object leverage3 = leverage2;
        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {
            Object leverage = leverage3;
            Object symbol = Helpers.getArg(optionalArgs, 0, null);
            Object parameters = Helpers.getArg(optionalArgs, 1, new java.util.HashMap<String, Object>() {{}});
            if (Helpers.isTrue(Helpers.isEqual(symbol, null)))
            {
                throw new ArgumentsRequired((String)Helpers.add(this.id, " setLeverage() requires a symbol argument")) ;
            }
            // WARNING: THIS WILL INCREASE LIQUIDATION PRICE FOR OPEN ISOLATED LONG POSITIONS
            // AND DECREASE LIQUIDATION PRICE FOR OPEN ISOLATED SHORT POSITIONS
            if (Helpers.isTrue(Helpers.isTrue((Helpers.isLessThan(leverage, 1))) || Helpers.isTrue((Helpers.isGreaterThan(leverage, 125)))))
            {
                throw new BadRequest((String)Helpers.add(this.id, " leverage should be between 1 and 125")) ;
            }
            (this.loadMarkets()).join();
            Object market = this.market(symbol);
            final Object finalLeverage = leverage;
            Object request = new java.util.HashMap<String, Object>() {{
                put( "symbol", Helpers.GetValue(market, "id") );
                put( "leverage", finalLeverage );
            }};
            Object isPortfolioMargin = null;
            var isPortfolioMarginparametersVariable = this.handleOptionAndParams2(parameters, "setLeverage", "papi", "portfolioMargin", false);
            isPortfolioMargin = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(0);
            parameters = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(1);
            Object response = null;
            if (Helpers.isTrue(Helpers.GetValue(market, "linear")))
            {
                if (Helpers.isTrue(isPortfolioMargin))
                {
                    response = (this.papiPostUmLeverage(this.extend(request, parameters))).join();
                } else
                {
                    response = (this.fapiPrivatePostLeverage(this.extend(request, parameters))).join();
                }
            } else if (Helpers.isTrue(Helpers.GetValue(market, "inverse")))
            {
                if (Helpers.isTrue(isPortfolioMargin))
                {
                    response = (this.papiPostCmLeverage(this.extend(request, parameters))).join();
                } else
                {
                    response = (this.dapiPrivatePostLeverage(this.extend(request, parameters))).join();
                }
            } else
            {
                throw new NotSupported((String)Helpers.add(this.id, " setLeverage() supports linear and inverse contracts only")) ;
            }
            return response;
        });

    }

    /**
     * @method
     * @name binance#setMarginMode
     * @description set margin mode to 'cross' or 'isolated'
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Change-Margin-Type
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Change-Margin-Type
     * @param {string} marginMode 'cross' or 'isolated'
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} response from the exchange
     */
    public java.util.concurrent.CompletableFuture<Object> setMarginMode(Object marginMode2, Object... optionalArgs)
    {
        final Object marginMode3 = marginMode2;
        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {
            Object marginMode = marginMode3;
            Object symbol = Helpers.getArg(optionalArgs, 0, null);
            Object parameters = Helpers.getArg(optionalArgs, 1, new java.util.HashMap<String, Object>() {{}});
            if (Helpers.isTrue(Helpers.isEqual(symbol, null)))
            {
                throw new ArgumentsRequired((String)Helpers.add(this.id, " setMarginMode() requires a symbol argument")) ;
            }
            //
            // { "code": -4048 , "msg": "Margin type cannot be changed if there exists position." }
            //
            // or
            //
            // { "code": 200, "msg": "success" }
            //
            marginMode = ((String)marginMode).toUpperCase();
            if (Helpers.isTrue(Helpers.isEqual(marginMode, "CROSS")))
            {
                marginMode = "CROSSED";
            }
            if (Helpers.isTrue(Helpers.isTrue((!Helpers.isEqual(marginMode, "ISOLATED"))) && Helpers.isTrue((!Helpers.isEqual(marginMode, "CROSSED")))))
            {
                throw new BadRequest((String)Helpers.add(this.id, " marginMode must be either isolated or cross")) ;
            }
            (this.loadMarkets()).join();
            Object market = this.market(symbol);
            final Object finalMarginMode = marginMode;
            Object request = new java.util.HashMap<String, Object>() {{
                put( "symbol", Helpers.GetValue(market, "id") );
                put( "marginType", finalMarginMode );
            }};
            Object response = null;
            try
            {
                if (Helpers.isTrue(Helpers.GetValue(market, "linear")))
                {
                    response = (this.fapiPrivatePostMarginType(this.extend(request, parameters))).join();
                } else if (Helpers.isTrue(Helpers.GetValue(market, "inverse")))
                {
                    response = (this.dapiPrivatePostMarginType(this.extend(request, parameters))).join();
                } else
                {
                    throw new NotSupported((String)Helpers.add(this.id, " setMarginMode() supports linear and inverse contracts only")) ;
                }
            } catch(Exception e)
            {
                // not an error
                // https://github.com/ccxt/ccxt/issues/11268
                // https://github.com/ccxt/ccxt/pull/11624
                // POST https://fapi.binance.com/fapi/v1/marginType 400 Bad Request
                // binanceusdm
                if (Helpers.isTrue(e instanceof MarginModeAlreadySet))
                {
                    Object throwMarginModeAlreadySet = this.safeBool(this.options, "throwMarginModeAlreadySet", false);
                    if (Helpers.isTrue(throwMarginModeAlreadySet))
                    {
                        throw e;
                    } else
                    {
                        response = new java.util.HashMap<String, Object>() {{
                            put( "code", Helpers.opNeg(4046) );
                            put( "msg", "No need to change margin type." );
                        }};
                    }
                } else
                {
                    throw e;
                }
            }
            return response;
        });

    }

    /**
     * @method
     * @name binance#setPositionMode
     * @description set hedged to true or false for a market
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Change-Position-Mode
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Change-Position-Mode
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/account/Get-UM-Current-Position-Mode
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/account/Get-CM-Current-Position-Mode
     * @param {bool} hedged set to true to use dualSidePosition
     * @param {string} symbol not used by binance setPositionMode ()
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.portfolioMargin] set to true if you would like to set the position mode for a portfolio margin account
     * @param {string} [params.subType] "linear" or "inverse"
     * @returns {object} response from the exchange
     */
    public java.util.concurrent.CompletableFuture<Object> setPositionMode(Object hedged, Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object symbol = Helpers.getArg(optionalArgs, 0, null);
            Object parameters = Helpers.getArg(optionalArgs, 1, new java.util.HashMap<String, Object>() {{}});
            Object market = null;
            if (Helpers.isTrue(!Helpers.isEqual(symbol, null)))
            {
                market = this.market(symbol);
            }
            Object type = null;
            var typeparametersVariable = this.handleMarketTypeAndParams("setPositionMode", market, parameters);
            type = ((java.util.List<Object>) typeparametersVariable).get(0);
            parameters = ((java.util.List<Object>) typeparametersVariable).get(1);
            Object subType = null;
            var subTypeparametersVariable = this.handleSubTypeAndParams("setPositionMode", market, parameters);
            subType = ((java.util.List<Object>) subTypeparametersVariable).get(0);
            parameters = ((java.util.List<Object>) subTypeparametersVariable).get(1);
            Object isPortfolioMargin = null;
            var isPortfolioMarginparametersVariable = this.handleOptionAndParams2(parameters, "setPositionMode", "papi", "portfolioMargin", false);
            isPortfolioMargin = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(0);
            parameters = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(1);
            Object dualSidePosition = null;
            if (Helpers.isTrue(hedged))
            {
                dualSidePosition = "true";
            } else
            {
                dualSidePosition = "false";
            }
            final Object finalDualSidePosition = dualSidePosition;
            Object request = new java.util.HashMap<String, Object>() {{
                put( "dualSidePosition", finalDualSidePosition );
            }};
            Object response = null;
            if (Helpers.isTrue(this.isInverse(type, subType)))
            {
                if (Helpers.isTrue(isPortfolioMargin))
                {
                    response = (this.papiPostCmPositionSideDual(this.extend(request, parameters))).join();
                } else
                {
                    response = (this.dapiPrivatePostPositionSideDual(this.extend(request, parameters))).join();
                }
            } else if (Helpers.isTrue(this.isLinear(type, subType)))
            {
                if (Helpers.isTrue(isPortfolioMargin))
                {
                    response = (this.papiPostUmPositionSideDual(this.extend(request, parameters))).join();
                } else
                {
                    response = (this.fapiPrivatePostPositionSideDual(this.extend(request, parameters))).join();
                }
            } else
            {
                throw new BadRequest((String)Helpers.add(this.id, " setPositionMode() supports linear and inverse contracts only")) ;
            }
            //
            //     {
            //       "code": 200,
            //       "msg": "success"
            //     }
            //
            return response;
        });

    }

    /**
     * @method
     * @name binance#fetchLeverages
     * @description fetch the set leverage for all markets
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/account/rest-api/Account-Information-V2
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/account/rest-api/Account-Information
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/account/Get-UM-Account-Detail
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/account/Get-CM-Account-Detail
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/account/rest-api/Symbol-Config
     * @param {string[]} [symbols] a list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.subType] "linear" or "inverse"
     * @returns {object} a list of [leverage structures]{@link https://docs.ccxt.com/#/?id=leverage-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchLeverages(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object symbols = Helpers.getArg(optionalArgs, 0, null);
            Object parameters = Helpers.getArg(optionalArgs, 1, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            (this.loadLeverageBrackets(false, parameters)).join();
            Object type = null;
            var typeparametersVariable = this.handleMarketTypeAndParams("fetchLeverages", null, parameters);
            type = ((java.util.List<Object>) typeparametersVariable).get(0);
            parameters = ((java.util.List<Object>) typeparametersVariable).get(1);
            Object subType = null;
            var subTypeparametersVariable = this.handleSubTypeAndParams("fetchLeverages", null, parameters, "linear");
            subType = ((java.util.List<Object>) subTypeparametersVariable).get(0);
            parameters = ((java.util.List<Object>) subTypeparametersVariable).get(1);
            Object isPortfolioMargin = null;
            var isPortfolioMarginparametersVariable = this.handleOptionAndParams2(parameters, "fetchLeverages", "papi", "portfolioMargin", false);
            isPortfolioMargin = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(0);
            parameters = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(1);
            Object response = null;
            if (Helpers.isTrue(this.isLinear(type, subType)))
            {
                if (Helpers.isTrue(isPortfolioMargin))
                {
                    response = (this.papiGetUmAccount(parameters)).join();
                } else
                {
                    response = (this.fapiPrivateGetSymbolConfig(parameters)).join();
                }
            } else if (Helpers.isTrue(this.isInverse(type, subType)))
            {
                if (Helpers.isTrue(isPortfolioMargin))
                {
                    response = (this.papiGetCmAccount(parameters)).join();
                } else
                {
                    response = (this.dapiPrivateGetAccount(parameters)).join();
                }
            } else
            {
                throw new NotSupported((String)Helpers.add(this.id, " fetchLeverages() supports linear and inverse contracts only")) ;
            }
            Object leverages = this.safeList(response, "positions", new java.util.ArrayList<Object>(java.util.Arrays.asList()));
            if (Helpers.isTrue(((response instanceof java.util.List) || (response.getClass().isArray()))))
            {
                leverages = response;
            }
            return this.parseLeverages(leverages, symbols, "symbol");
        });

    }

    public Object parseLeverage(Object leverage, Object... optionalArgs)
    {
        Object market = Helpers.getArg(optionalArgs, 0, null);
        Object marketId = this.safeString(leverage, "symbol");
        Object marginModeRaw = this.safeBool(leverage, "isolated");
        Object marginMode = null;
        if (Helpers.isTrue(!Helpers.isEqual(marginModeRaw, null)))
        {
            marginMode = ((Helpers.isTrue(marginModeRaw))) ? "isolated" : "cross";
        }
        Object marginTypeRaw = this.safeStringLower(leverage, "marginType");
        if (Helpers.isTrue(!Helpers.isEqual(marginTypeRaw, null)))
        {
            marginMode = ((Helpers.isTrue((Helpers.isEqual(marginTypeRaw, "crossed"))))) ? "cross" : "isolated";
        }
        Object side = this.safeStringLower(leverage, "positionSide");
        Object longLeverage = null;
        Object shortLeverage = null;
        Object leverageValue = this.safeInteger(leverage, "leverage");
        if (Helpers.isTrue(Helpers.isTrue((Helpers.isEqual(side, null))) || Helpers.isTrue((Helpers.isEqual(side, "both")))))
        {
            longLeverage = leverageValue;
            shortLeverage = leverageValue;
        } else if (Helpers.isTrue(Helpers.isEqual(side, "long")))
        {
            longLeverage = leverageValue;
        } else if (Helpers.isTrue(Helpers.isEqual(side, "short")))
        {
            shortLeverage = leverageValue;
        }
        final Object finalMarginMode = marginMode;
        final Object finalLongLeverage = longLeverage;
        final Object finalShortLeverage = shortLeverage;
        return new java.util.HashMap<String, Object>() {{
            put( "info", leverage );
            put( "symbol", Binance.this.safeSymbol(marketId, market) );
            put( "marginMode", finalMarginMode );
            put( "longLeverage", finalLongLeverage );
            put( "shortLeverage", finalShortLeverage );
        }};
    }

    /**
     * @method
     * @name binance#fetchSettlementHistory
     * @description fetches historical settlement records
     * @see https://developers.binance.com/docs/derivatives/option/market-data/Historical-Exercise-Records
     * @param {string} symbol unified market symbol of the settlement history
     * @param {int} [since] timestamp in ms
     * @param {int} [limit] number of records, default 100, max 100
     * @param {object} [params] exchange specific params
     * @returns {object[]} a list of [settlement history objects]{@link https://docs.ccxt.com/#/?id=settlement-history-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchSettlementHistory(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object symbol = Helpers.getArg(optionalArgs, 0, null);
            Object since = Helpers.getArg(optionalArgs, 1, null);
            Object limit = Helpers.getArg(optionalArgs, 2, null);
            Object parameters = Helpers.getArg(optionalArgs, 3, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object market = ((Helpers.isTrue((Helpers.isEqual(symbol, null))))) ? null : this.market(symbol);
            Object type = null;
            var typeparametersVariable = this.handleMarketTypeAndParams("fetchSettlementHistory", market, parameters);
            type = ((java.util.List<Object>) typeparametersVariable).get(0);
            parameters = ((java.util.List<Object>) typeparametersVariable).get(1);
            if (Helpers.isTrue(!Helpers.isEqual(type, "option")))
            {
                throw new NotSupported((String)Helpers.add(this.id, " fetchSettlementHistory() supports option markets only")) ;
            }
            Object request = new java.util.HashMap<String, Object>() {{}};
            if (Helpers.isTrue(!Helpers.isEqual(symbol, null)))
            {
                symbol = Helpers.GetValue(market, "symbol");
                Helpers.addElementToObject(request, "underlying", Helpers.add(Helpers.GetValue(market, "baseId"), Helpers.GetValue(market, "quoteId")));
            }
            if (Helpers.isTrue(!Helpers.isEqual(since, null)))
            {
                Helpers.addElementToObject(request, "startTime", since);
            }
            if (Helpers.isTrue(!Helpers.isEqual(limit, null)))
            {
                Helpers.addElementToObject(request, "limit", limit);
            }
            Object response = (this.eapiPublicGetExerciseHistory(this.extend(request, parameters))).join();
            //
            //     [
            //         {
            //             "symbol": "ETH-230223-1900-P",
            //             "strikePrice": "1900",
            //             "realStrikePrice": "1665.5897334",
            //             "expiryDate": 1677139200000,
            //             "strikeResult": "REALISTIC_VALUE_STRICKEN"
            //         }
            //     ]
            //
            Object settlements = this.parseSettlements(response, market);
            Object sorted = this.sortBy(settlements, "timestamp");
            return this.filterBySymbolSinceLimit(sorted, symbol, since, limit);
        });

    }

    /**
     * @method
     * @name binance#fetchMySettlementHistory
     * @description fetches historical settlement records of the user
     * @see https://developers.binance.com/docs/derivatives/option/trade/User-Exercise-Record
     * @param {string} symbol unified market symbol of the settlement history
     * @param {int} [since] timestamp in ms
     * @param {int} [limit] number of records
     * @param {object} [params] exchange specific params
     * @returns {object[]} a list of [settlement history objects]
     */
    public java.util.concurrent.CompletableFuture<Object> fetchMySettlementHistory(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object symbol = Helpers.getArg(optionalArgs, 0, null);
            Object since = Helpers.getArg(optionalArgs, 1, null);
            Object limit = Helpers.getArg(optionalArgs, 2, null);
            Object parameters = Helpers.getArg(optionalArgs, 3, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object market = ((Helpers.isTrue((Helpers.isEqual(symbol, null))))) ? null : this.market(symbol);
            Object type = null;
            var typeparametersVariable = this.handleMarketTypeAndParams("fetchMySettlementHistory", market, parameters);
            type = ((java.util.List<Object>) typeparametersVariable).get(0);
            parameters = ((java.util.List<Object>) typeparametersVariable).get(1);
            if (Helpers.isTrue(!Helpers.isEqual(type, "option")))
            {
                throw new NotSupported((String)Helpers.add(this.id, " fetchMySettlementHistory() supports option markets only")) ;
            }
            Object request = new java.util.HashMap<String, Object>() {{}};
            if (Helpers.isTrue(!Helpers.isEqual(symbol, null)))
            {
                Helpers.addElementToObject(request, "symbol", Helpers.GetValue(market, "id"));
                symbol = Helpers.GetValue(market, "symbol");
            }
            if (Helpers.isTrue(!Helpers.isEqual(since, null)))
            {
                Helpers.addElementToObject(request, "startTime", since);
            }
            if (Helpers.isTrue(!Helpers.isEqual(limit, null)))
            {
                Helpers.addElementToObject(request, "limit", limit);
            }
            Object response = (this.eapiPrivateGetExerciseRecord(this.extend(request, parameters))).join();
            //
            //     [
            //         {
            //             "id": "1125899906842897036",
            //             "currency": "USDT",
            //             "symbol": "BTC-230728-30000-C",
            //             "exercisePrice": "30000.00000000",
            //             "markPrice": "29160.71284993",
            //             "quantity": "1.00000000",
            //             "amount": "0.00000000",
            //             "fee": "0.00000000",
            //             "createDate": 1690531200000,
            //             "priceScale": 0,
            //             "quantityScale": 2,
            //             "optionSide": "CALL",
            //             "positionSide": "LONG",
            //             "quoteAsset": "USDT"
            //         }
            //     ]
            //
            Object settlements = this.parseSettlements(response, market);
            Object sorted = this.sortBy(settlements, "timestamp");
            return this.filterBySymbolSinceLimit(sorted, symbol, since, limit);
        });

    }

    public Object parseSettlement(Object settlement, Object market)
    {
        //
        // fetchSettlementHistory
        //
        //     {
        //         "symbol": "ETH-230223-1900-P",
        //         "strikePrice": "1900",
        //         "realStrikePrice": "1665.5897334",
        //         "expiryDate": 1677139200000,
        //         "strikeResult": "REALISTIC_VALUE_STRICKEN"
        //     }
        //
        // fetchMySettlementHistory
        //
        //     {
        //         "id": "1125899906842897036",
        //         "currency": "USDT",
        //         "symbol": "BTC-230728-30000-C",
        //         "exercisePrice": "30000.00000000",
        //         "markPrice": "29160.71284993",
        //         "quantity": "1.00000000",
        //         "amount": "0.00000000",
        //         "fee": "0.00000000",
        //         "createDate": 1690531200000,
        //         "priceScale": 0,
        //         "quantityScale": 2,
        //         "optionSide": "CALL",
        //         "positionSide": "LONG",
        //         "quoteAsset": "USDT"
        //     }
        //
        Object timestamp = this.safeInteger2(settlement, "expiryDate", "createDate");
        Object marketId = this.safeString(settlement, "symbol");
        return new java.util.HashMap<String, Object>() {{
            put( "info", settlement );
            put( "symbol", Binance.this.safeSymbol(marketId, market) );
            put( "price", Binance.this.safeNumber2(settlement, "realStrikePrice", "exercisePrice") );
            put( "timestamp", timestamp );
            put( "datetime", Binance.this.iso8601(timestamp) );
        }};
    }

    public Object parseSettlements(Object settlements, Object market)
    {
        //
        // fetchSettlementHistory
        //
        //     [
        //         {
        //             "symbol": "ETH-230223-1900-P",
        //             "strikePrice": "1900",
        //             "realStrikePrice": "1665.5897334",
        //             "expiryDate": 1677139200000,
        //             "strikeResult": "EXTRINSIC_VALUE_EXPIRED"
        //         }
        //     ]
        //
        // fetchMySettlementHistory
        //
        //     [
        //         {
        //             "id": "1125899906842897036",
        //             "currency": "USDT",
        //             "symbol": "BTC-230728-30000-C",
        //             "exercisePrice": "30000.00000000",
        //             "markPrice": "29160.71284993",
        //             "quantity": "1.00000000",
        //             "amount": "0.00000000",
        //             "fee": "0.00000000",
        //             "createDate": 1690531200000,
        //             "priceScale": 0,
        //             "quantityScale": 2,
        //             "optionSide": "CALL",
        //             "positionSide": "LONG",
        //             "quoteAsset": "USDT"
        //         }
        //     ]
        //
        Object result = new java.util.ArrayList<Object>(java.util.Arrays.asList());
        for (var i = 0; Helpers.isLessThan(i, Helpers.getArrayLength(settlements)); i++)
        {
            ((java.util.List<Object>)result).add(this.parseSettlement(Helpers.GetValue(settlements, i), market));
        }
        return result;
    }

    /**
     * @method
     * @name binance#fetchLedgerEntry
     * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
     * @see https://developers.binance.com/docs/derivatives/option/account/Account-Funding-Flow
     * @param {string} id the identification number of the ledger entry
     * @param {string} code unified currency code
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchLedgerEntry(Object id, Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object code = Helpers.getArg(optionalArgs, 0, null);
            Object parameters = Helpers.getArg(optionalArgs, 1, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object type = null;
            var typeparametersVariable = this.handleMarketTypeAndParams("fetchLedgerEntry", null, parameters);
            type = ((java.util.List<Object>) typeparametersVariable).get(0);
            parameters = ((java.util.List<Object>) typeparametersVariable).get(1);
            if (Helpers.isTrue(!Helpers.isEqual(type, "option")))
            {
                throw new BadRequest((String)Helpers.add(this.id, " fetchLedgerEntry() can only be used for type option")) ;
            }
            this.checkRequiredArgument("fetchLedgerEntry", code, "code");
            Object currency = this.currency(code);
            Object request = new java.util.HashMap<String, Object>() {{
                put( "recordId", id );
                put( "currency", Helpers.GetValue(currency, "id") );
            }};
            Object response = (this.eapiPrivateGetBill(this.extend(request, parameters))).join();
            //
            //     [
            //         {
            //             "id": "1125899906845701870",
            //             "asset": "USDT",
            //             "amount": "-0.16518203",
            //             "type": "FEE",
            //             "createDate": 1676621042489
            //         }
            //     ]
            //
            Object first = this.safeDict(response, 0, response);
            return this.parseLedgerEntry(first, currency);
        });

    }

    /**
     * @method
     * @name binance#fetchLedger
     * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
     * @see https://developers.binance.com/docs/derivatives/option/account/Account-Funding-Flow
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/account/rest-api/Get-Income-History
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/account/rest-api/Get-Income-History
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/account/Get-UM-Income-History
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/account/Get-CM-Income-History
     * @param {string} [code] unified currency code
     * @param {int} [since] timestamp in ms of the earliest ledger entry
     * @param {int} [limit] max number of ledger entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest ledger entry
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @param {boolean} [params.portfolioMargin] set to true if you would like to fetch the ledger for a portfolio margin account
     * @param {string} [params.subType] "linear" or "inverse"
     * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchLedger(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object code = Helpers.getArg(optionalArgs, 0, null);
            Object since = Helpers.getArg(optionalArgs, 1, null);
            Object limit = Helpers.getArg(optionalArgs, 2, null);
            Object parameters = Helpers.getArg(optionalArgs, 3, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object paginate = false;
            var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchLedger", "paginate");
            paginate = ((java.util.List<Object>) paginateparametersVariable).get(0);
            parameters = ((java.util.List<Object>) paginateparametersVariable).get(1);
            if (Helpers.isTrue(paginate))
            {
                return (this.fetchPaginatedCallDynamic("fetchLedger", code, since, limit, parameters, null, false)).join();
            }
            Object type = null;
            Object subType = null;
            Object currency = null;
            if (Helpers.isTrue(!Helpers.isEqual(code, null)))
            {
                currency = this.currency(code);
            }
            Object request = new java.util.HashMap<String, Object>() {{}};
            var typeparametersVariable = this.handleMarketTypeAndParams("fetchLedger", null, parameters);
            type = ((java.util.List<Object>) typeparametersVariable).get(0);
            parameters = ((java.util.List<Object>) typeparametersVariable).get(1);
            var subTypeparametersVariable = this.handleSubTypeAndParams("fetchLedger", null, parameters);
            subType = ((java.util.List<Object>) subTypeparametersVariable).get(0);
            parameters = ((java.util.List<Object>) subTypeparametersVariable).get(1);
            if (Helpers.isTrue(!Helpers.isEqual(since, null)))
            {
                Helpers.addElementToObject(request, "startTime", since);
            }
            if (Helpers.isTrue(!Helpers.isEqual(limit, null)))
            {
                Helpers.addElementToObject(request, "limit", limit);
            }
            Object until = this.safeInteger(parameters, "until");
            if (Helpers.isTrue(!Helpers.isEqual(until, null)))
            {
                parameters = this.omit(parameters, "until");
                Helpers.addElementToObject(request, "endTime", until);
            }
            Object isPortfolioMargin = null;
            var isPortfolioMarginparametersVariable = this.handleOptionAndParams2(parameters, "fetchLedger", "papi", "portfolioMargin", false);
            isPortfolioMargin = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(0);
            parameters = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(1);
            Object response = null;
            if (Helpers.isTrue(Helpers.isEqual(type, "option")))
            {
                this.checkRequiredArgument("fetchLedger", code, "code");
                Helpers.addElementToObject(request, "currency", Helpers.GetValue(currency, "id"));
                response = (this.eapiPrivateGetBill(this.extend(request, parameters))).join();
            } else if (Helpers.isTrue(this.isLinear(type, subType)))
            {
                if (Helpers.isTrue(isPortfolioMargin))
                {
                    response = (this.papiGetUmIncome(this.extend(request, parameters))).join();
                } else
                {
                    response = (this.fapiPrivateGetIncome(this.extend(request, parameters))).join();
                }
            } else if (Helpers.isTrue(this.isInverse(type, subType)))
            {
                if (Helpers.isTrue(isPortfolioMargin))
                {
                    response = (this.papiGetCmIncome(this.extend(request, parameters))).join();
                } else
                {
                    response = (this.dapiPrivateGetIncome(this.extend(request, parameters))).join();
                }
            } else
            {
                throw new NotSupported((String)Helpers.add(this.id, " fetchLedger() supports contract wallets only")) ;
            }
            //
            // options (eapi)
            //
            //     [
            //         {
            //             "id": "1125899906845701870",
            //             "asset": "USDT",
            //             "amount": "-0.16518203",
            //             "type": "FEE",
            //             "createDate": 1676621042489
            //         }
            //     ]
            //
            // futures (fapi, dapi, papi)
            //
            //     [
            //         {
            //             "symbol": "",
            //             "incomeType": "TRANSFER",
            //             "income": "10.00000000",
            //             "asset": "USDT",
            //             "time": 1677645250000,
            //             "info": "TRANSFER",
            //             "tranId": 131001573082,
            //             "tradeId": ""
            //         }
            //     ]
            //
            return this.parseLedger(response, currency, since, limit);
        });

    }

    public Object parseLedgerEntry(Object item, Object... optionalArgs)
    {
        //
        // options (eapi)
        //
        //     {
        //         "id": "1125899906845701870",
        //         "asset": "USDT",
        //         "amount": "-0.16518203",
        //         "type": "FEE",
        //         "createDate": 167662104241
        //     }
        //
        // futures (fapi, dapi, papi)
        //
        //     {
        //         "symbol": "",
        //         "incomeType": "TRANSFER",
        //         "income": "10.00000000",
        //         "asset": "USDT",
        //         "time": 1677645250000,
        //         "info": "TRANSFER",
        //         "tranId": 131001573082,
        //         "tradeId": ""
        //     }
        //
        Object currency = Helpers.getArg(optionalArgs, 0, null);
        Object amount = this.safeString2(item, "amount", "income");
        Object direction = null;
        if (Helpers.isTrue(Precise.stringLe(amount, "0")))
        {
            direction = "out";
            amount = Precise.stringMul("-1", amount);
        } else
        {
            direction = "in";
        }
        Object currencyId = this.safeString(item, "asset");
        Object code = this.safeCurrencyCode(currencyId, currency);
        currency = this.safeCurrency(currencyId, currency);
        Object timestamp = this.safeInteger2(item, "createDate", "time");
        Object type = this.safeString2(item, "type", "incomeType");
        final Object finalDirection = direction;
        final Object finalAmount = amount;
        return this.safeLedgerEntry(new java.util.HashMap<String, Object>() {{
            put( "info", item );
            put( "id", Binance.this.safeString2(item, "id", "tranId") );
            put( "direction", finalDirection );
            put( "account", null );
            put( "referenceAccount", null );
            put( "referenceId", Binance.this.safeString(item, "tradeId") );
            put( "type", Binance.this.parseLedgerEntryType(type) );
            put( "currency", code );
            put( "amount", Binance.this.parseNumber(finalAmount) );
            put( "timestamp", timestamp );
            put( "datetime", Binance.this.iso8601(timestamp) );
            put( "before", null );
            put( "after", null );
            put( "status", null );
            put( "fee", null );
        }}, currency);
    }

    public Object parseLedgerEntryType(Object type)
    {
        Object ledgerType = new java.util.HashMap<String, Object>() {{
            put( "FEE", "fee" );
            put( "FUNDING_FEE", "fee" );
            put( "OPTIONS_PREMIUM_FEE", "fee" );
            put( "POSITION_LIMIT_INCREASE_FEE", "fee" );
            put( "CONTRACT", "trade" );
            put( "REALIZED_PNL", "trade" );
            put( "TRANSFER", "transfer" );
            put( "CROSS_COLLATERAL_TRANSFER", "transfer" );
            put( "INTERNAL_TRANSFER", "transfer" );
            put( "COIN_SWAP_DEPOSIT", "deposit" );
            put( "COIN_SWAP_WITHDRAW", "withdrawal" );
            put( "OPTIONS_SETTLE_PROFIT", "settlement" );
            put( "DELIVERED_SETTELMENT", "settlement" );
            put( "WELCOME_BONUS", "cashback" );
            put( "CONTEST_REWARD", "cashback" );
            put( "COMMISSION_REBATE", "rebate" );
            put( "API_REBATE", "rebate" );
            put( "REFERRAL_KICKBACK", "referral" );
            put( "COMMISSION", "commission" );
        }};
        return this.safeString(ledgerType, type, type);
    }

    public Object getNetworkCodeByNetworkUrl(Object currencyCode, Object... optionalArgs)
    {
        // depositUrl is like : https://bscscan.com/address/0xEF238AB229342849..
        Object depositUrl = Helpers.getArg(optionalArgs, 0, null);
        if (Helpers.isTrue(Helpers.isEqual(depositUrl, null)))
        {
            return null;
        }
        Object networkCode = null;
        Object currency = this.currency(currencyCode);
        Object networks = this.safeDict(currency, "networks", new java.util.HashMap<String, Object>() {{}});
        Object networkCodes = new java.util.ArrayList<Object>(((java.util.Map<String, Object>)networks).keySet());
        for (var i = 0; Helpers.isLessThan(i, Helpers.getArrayLength(networkCodes)); i++)
        {
            Object currentNetworkCode = Helpers.GetValue(networkCodes, i);
            Object info = this.safeDict(Helpers.GetValue(networks, currentNetworkCode), "info", new java.util.HashMap<String, Object>() {{}});
            Object siteUrl = this.safeString(info, "contractAddressUrl");
            // check if url matches the field's value
            if (Helpers.isTrue(Helpers.isTrue(!Helpers.isEqual(siteUrl, null)) && Helpers.isTrue(((String)depositUrl).startsWith(((String)this.getBaseDomainFromUrl(siteUrl))))))
            {
                networkCode = currentNetworkCode;
            }
        }
        return networkCode;
    }

    public Object getBaseDomainFromUrl(Object url)
    {
        if (Helpers.isTrue(Helpers.isEqual(url, null)))
        {
            return null;
        }
        Object urlParts = new java.util.ArrayList<Object>(java.util.Arrays.asList(((String)url).split((String)"/")));
        Object scheme = this.safeString(urlParts, 0);
        if (Helpers.isTrue(Helpers.isEqual(scheme, null)))
        {
            return null;
        }
        Object domain = this.safeString(urlParts, 2);
        if (Helpers.isTrue(Helpers.isEqual(domain, null)))
        {
            return null;
        }
        return Helpers.add(Helpers.add(Helpers.add(scheme, "//"), domain), "/");
    }

    public Object sign(Object path, Object... optionalArgs)
    {
        Object api = Helpers.getArg(optionalArgs, 0, "public");
        Object method = Helpers.getArg(optionalArgs, 1, "GET");
        Object parameters = Helpers.getArg(optionalArgs, 2, new java.util.HashMap<String, Object>() {{}});
        Object headers = Helpers.getArg(optionalArgs, 3, null);
        Object body = Helpers.getArg(optionalArgs, 4, null);
        Object urls = ((Object)this.urls);
        if (!Helpers.isTrue((Helpers.inOp(Helpers.GetValue(urls, "api"), api))))
        {
            throw new NotSupported((String)Helpers.add(Helpers.add(Helpers.add(this.id, " does not have a testnet/sandbox URL for "), api), " endpoints")) ;
        }
        Object url = Helpers.GetValue(Helpers.GetValue(this.urls, "api"), api);
        url = Helpers.add(url, Helpers.add("/", path));
        if (Helpers.isTrue(Helpers.isEqual(path, "historicalTrades")))
        {
            if (Helpers.isTrue(this.apiKey))
            {
                headers = new java.util.HashMap<String, Object>() {{
                    put( "X-MBX-APIKEY", Binance.this.apiKey );
                }};
            } else
            {
                throw new AuthenticationError((String)Helpers.add(this.id, " historicalTrades endpoint requires `apiKey` credential")) ;
            }
        }
        Object userDataStream = Helpers.isTrue((Helpers.isEqual(path, "userDataStream"))) || Helpers.isTrue((Helpers.isEqual(path, "listenKey")));
        if (Helpers.isTrue(userDataStream))
        {
            if (Helpers.isTrue(this.apiKey))
            {
                // v1 special case for userDataStream
                headers = new java.util.HashMap<String, Object>() {{
                    put( "X-MBX-APIKEY", Binance.this.apiKey );
                    put( "Content-Type", "application/x-www-form-urlencoded" );
                }};
                if (Helpers.isTrue(!Helpers.isEqual(method, "GET")))
                {
                    body = this.urlencode(parameters);
                }
            } else
            {
                throw new AuthenticationError((String)Helpers.add(this.id, " userDataStream endpoint requires `apiKey` credential")) ;
            }
        } else if (Helpers.isTrue(Helpers.isTrue(Helpers.isTrue(Helpers.isTrue(Helpers.isTrue(Helpers.isTrue(Helpers.isTrue(Helpers.isTrue(Helpers.isTrue(Helpers.isTrue(Helpers.isTrue(Helpers.isTrue((Helpers.isEqual(api, "private"))) || Helpers.isTrue((Helpers.isEqual(api, "eapiPrivate")))) || Helpers.isTrue((Helpers.isTrue(Helpers.isEqual(api, "sapi")) && Helpers.isTrue(!Helpers.isEqual(path, "system/status"))))) || Helpers.isTrue((Helpers.isEqual(api, "sapiV2")))) || Helpers.isTrue((Helpers.isEqual(api, "sapiV3")))) || Helpers.isTrue((Helpers.isEqual(api, "sapiV4")))) || Helpers.isTrue((Helpers.isEqual(api, "dapiPrivate")))) || Helpers.isTrue((Helpers.isEqual(api, "dapiPrivateV2")))) || Helpers.isTrue((Helpers.isEqual(api, "fapiPrivate")))) || Helpers.isTrue((Helpers.isEqual(api, "fapiPrivateV2")))) || Helpers.isTrue((Helpers.isEqual(api, "fapiPrivateV3")))) || Helpers.isTrue((Helpers.isTrue(Helpers.isEqual(api, "papi")) && Helpers.isTrue(!Helpers.isEqual(path, "ping"))))))
        {
            this.checkRequiredCredentials();
            if (Helpers.isTrue(Helpers.isTrue(Helpers.isTrue((Helpers.isGreaterThan(Helpers.getIndexOf(url, "testnet.binancefuture.com"), Helpers.opNeg(1)))) && Helpers.isTrue(this.isSandboxModeEnabled)) && Helpers.isTrue((!Helpers.isTrue(this.safeBool(this.options, "disableFuturesSandboxWarning"))))))
            {
                throw new NotSupported((String)Helpers.add(this.id, " testnet/sandbox mode is not supported for futures anymore, please check the deprecation announcement https://t.me/ccxt_announcements/92 and consider using the demo trading instead.")) ;
            }
            if (Helpers.isTrue(Helpers.isTrue(Helpers.isEqual(method, "POST")) && Helpers.isTrue((Helpers.isTrue((Helpers.isEqual(path, "order"))) || Helpers.isTrue((Helpers.isEqual(path, "sor/order")))))))
            {
                // inject in implicit API calls
                Object newClientOrderId = this.safeString(parameters, "newClientOrderId");
                if (Helpers.isTrue(Helpers.isEqual(newClientOrderId, null)))
                {
                    Object isSpotOrMargin = (Helpers.isTrue(Helpers.isGreaterThan(Helpers.getIndexOf(api, "sapi"), Helpers.opNeg(1))) || Helpers.isTrue(Helpers.isEqual(api, "private")));
                    Object marketType = ((Helpers.isTrue(isSpotOrMargin))) ? "spot" : "future";
                    Object defaultId = ((Helpers.isTrue((!Helpers.isTrue(isSpotOrMargin))))) ? "x-xcKtGhcu" : "x-TKT5PX2F";
                    Object broker = this.safeDict(this.options, "broker", new java.util.HashMap<String, Object>() {{}});
                    Object brokerId = this.safeString(broker, marketType, defaultId);
                    Helpers.addElementToObject(parameters, "newClientOrderId", Helpers.add(brokerId, this.uuid22()));
                }
            }
            Object query = null;
            // handle batchOrders
            if (Helpers.isTrue(Helpers.isTrue((Helpers.isEqual(path, "batchOrders"))) && Helpers.isTrue((Helpers.isTrue((Helpers.isEqual(method, "POST"))) || Helpers.isTrue((Helpers.isEqual(method, "PUT")))))))
            {
                Object batchOrders = this.safeList(parameters, "batchOrders");
                Object checkedBatchOrders = batchOrders;
                if (Helpers.isTrue(Helpers.isTrue(Helpers.isEqual(method, "POST")) && Helpers.isTrue(Helpers.isEqual(api, "fapiPrivate"))))
                {
                    // check broker id if batchOrders are called with fapiPrivatePostBatchOrders
                    checkedBatchOrders = new java.util.ArrayList<Object>(java.util.Arrays.asList());
                    for (var i = 0; Helpers.isLessThan(i, Helpers.getArrayLength(batchOrders)); i++)
                    {
                        Object batchOrder = Helpers.GetValue(batchOrders, i);
                        Object newClientOrderId = this.safeString(batchOrder, "newClientOrderId");
                        if (Helpers.isTrue(Helpers.isEqual(newClientOrderId, null)))
                        {
                            Object defaultId = "x-xcKtGhcu"; // batchOrders can not be spot or margin
                            Object broker = this.safeDict(this.options, "broker", new java.util.HashMap<String, Object>() {{}});
                            Object brokerId = this.safeString(broker, "future", defaultId);
                            newClientOrderId = Helpers.add(brokerId, this.uuid22());
                            Helpers.addElementToObject(batchOrder, "newClientOrderId", newClientOrderId);
                        }
                        ((java.util.List<Object>)checkedBatchOrders).add(batchOrder);
                    }
                }
                Object queryBatch = (this.json(checkedBatchOrders));
                Helpers.addElementToObject(parameters, "batchOrders", queryBatch);
            }
            Object defaultRecvWindow = this.safeInteger(this.options, "recvWindow");
            Object extendedParams = this.extend(new java.util.HashMap<String, Object>() {{
                put( "timestamp", Binance.this.nonce() );
            }}, parameters);
            if (Helpers.isTrue(!Helpers.isEqual(defaultRecvWindow, null)))
            {
                Helpers.addElementToObject(extendedParams, "recvWindow", defaultRecvWindow);
            }
            Object recvWindow = this.safeInteger(parameters, "recvWindow");
            if (Helpers.isTrue(!Helpers.isEqual(recvWindow, null)))
            {
                Helpers.addElementToObject(extendedParams, "recvWindow", recvWindow);
            }
            if (Helpers.isTrue(Helpers.isTrue((Helpers.isEqual(api, "sapi"))) && Helpers.isTrue((Helpers.isEqual(path, "asset/dust")))))
            {
                query = this.urlencodeWithArrayRepeat(extendedParams);
            } else if (Helpers.isTrue(Helpers.isTrue(Helpers.isTrue(Helpers.isTrue(Helpers.isTrue((Helpers.isEqual(path, "batchOrders"))) || Helpers.isTrue((Helpers.isGreaterThanOrEqual(Helpers.getIndexOf(path, "sub-account"), 0)))) || Helpers.isTrue((Helpers.isEqual(path, "capital/withdraw/apply")))) || Helpers.isTrue((Helpers.isGreaterThanOrEqual(Helpers.getIndexOf(path, "staking"), 0)))) || Helpers.isTrue((Helpers.isGreaterThanOrEqual(Helpers.getIndexOf(path, "simple-earn"), 0)))))
            {
                if (Helpers.isTrue(Helpers.isTrue((Helpers.isEqual(method, "DELETE"))) && Helpers.isTrue((Helpers.isEqual(path, "batchOrders")))))
                {
                    Object orderidlist = this.safeList(extendedParams, "orderidlist", new java.util.ArrayList<Object>(java.util.Arrays.asList()));
                    Object origclientorderidlist = this.safeList2(extendedParams, "origclientorderidlist", "origClientOrderIdList", new java.util.ArrayList<Object>(java.util.Arrays.asList()));
                    extendedParams = this.omit(extendedParams, new java.util.ArrayList<Object>(java.util.Arrays.asList("orderidlist", "origclientorderidlist", "origClientOrderIdList")));
                    query = this.rawencode(extendedParams);
                    Object orderidlistLength = Helpers.getArrayLength(orderidlist);
                    Object origclientorderidlistLength = Helpers.getArrayLength(origclientorderidlist);
                    if (Helpers.isTrue(Helpers.isGreaterThan(orderidlistLength, 0)))
                    {
                        query = Helpers.add(Helpers.add(Helpers.add(Helpers.add(query, "&"), "orderidlist=%5B"), String.join((String)"%2C", (java.util.List<String>)orderidlist)), "%5D");
                    }
                    if (Helpers.isTrue(Helpers.isGreaterThan(origclientorderidlistLength, 0)))
                    {
                        // wrap clientOrderids around ""
                        Object newClientOrderIds = new java.util.ArrayList<Object>(java.util.Arrays.asList());
                        for (var i = 0; Helpers.isLessThan(i, origclientorderidlistLength); i++)
                        {
                            ((java.util.List<Object>)newClientOrderIds).add(Helpers.add(Helpers.add("%22", Helpers.GetValue(origclientorderidlist, i)), "%22"));
                        }
                        query = Helpers.add(Helpers.add(Helpers.add(Helpers.add(query, "&"), "origclientorderidlist=%5B"), String.join((String)"%2C", (java.util.List<String>)newClientOrderIds)), "%5D");
                    }
                } else
                {
                    query = this.rawencode(extendedParams);
                }
            } else
            {
                query = this.urlencode(extendedParams);
            }
            Object signature = null;
            if (Helpers.isTrue(Helpers.isGreaterThan(Helpers.getIndexOf(this.secret, "PRIVATE KEY"), Helpers.opNeg(1))))
            {
                if (Helpers.isTrue(Helpers.isGreaterThan(((String)this.secret).length(), 120)))
                {
                    signature = this.encodeURIComponent(rsa(query, this.secret, sha256()));
                } else
                {
                    signature = this.encodeURIComponent(eddsa(this.encode(query), this.secret, ed25519()));
                }
            } else
            {
                signature = this.hmac(this.encode(query), this.encode(this.secret), sha256());
            }
            query = Helpers.add(query, Helpers.add(Helpers.add("&", "signature="), signature));
            headers = new java.util.HashMap<String, Object>() {{
                put( "X-MBX-APIKEY", Binance.this.apiKey );
            }};
            if (Helpers.isTrue(Helpers.isTrue((Helpers.isEqual(method, "GET"))) || Helpers.isTrue((Helpers.isEqual(method, "DELETE")))))
            {
                url = Helpers.add(url, Helpers.add("?", query));
            } else
            {
                body = query;
                Helpers.addElementToObject(headers, "Content-Type", "application/x-www-form-urlencoded");
            }
        } else
        {
            if (Helpers.isTrue(Helpers.getArrayLength(new java.util.ArrayList<Object>(((java.util.Map<String, Object>)parameters).keySet()))))
            {
                url = Helpers.add(url, Helpers.add("?", this.urlencode(parameters)));
            }
        }
        final Object finalUrl = url;
        final Object finalMethod = method;
        final Object finalBody = body;
        final Object finalHeaders = headers;
        return new java.util.HashMap<String, Object>() {{
            put( "url", finalUrl );
            put( "method", finalMethod );
            put( "body", finalBody );
            put( "headers", finalHeaders );
        }};
    }

    public Object getExceptionsByUrl(Object url, Object exactOrBroad)
    {
        Object marketType = null;
        Object hostname = ((Helpers.isTrue((!Helpers.isEqual(this.hostname, null))))) ? this.hostname : "binance.com";
        if (Helpers.isTrue(Helpers.isTrue(((String)url).startsWith(((String)Helpers.add(Helpers.add("https://api.", hostname), "/")))) || Helpers.isTrue(((String)url).startsWith(((String)"https://testnet.binance.vision")))))
        {
            marketType = "spot";
        } else if (Helpers.isTrue(Helpers.isTrue(((String)url).startsWith(((String)Helpers.add(Helpers.add("https://dapi.", hostname), "/")))) || Helpers.isTrue(((String)url).startsWith(((String)"https://testnet.binancefuture.com/dapi")))))
        {
            marketType = "inverse";
        } else if (Helpers.isTrue(Helpers.isTrue(((String)url).startsWith(((String)Helpers.add(Helpers.add("https://fapi.", hostname), "/")))) || Helpers.isTrue(((String)url).startsWith(((String)"https://testnet.binancefuture.com/fapi")))))
        {
            marketType = "linear";
        } else if (Helpers.isTrue(((String)url).startsWith(((String)Helpers.add(Helpers.add("https://eapi.", hostname), "/")))))
        {
            marketType = "option";
        } else if (Helpers.isTrue(((String)url).startsWith(((String)Helpers.add(Helpers.add("https://papi.", hostname), "/")))))
        {
            marketType = "portfolioMargin";
        }
        if (Helpers.isTrue(!Helpers.isEqual(marketType, null)))
        {
            Object exceptionsForMarketType = this.safeDict(this.exceptions, marketType, new java.util.HashMap<String, Object>() {{}});
            return this.safeDict(exceptionsForMarketType, exactOrBroad, new java.util.HashMap<String, Object>() {{}});
        }
        return new java.util.HashMap<String, Object>() {{}};
    }

    public Object handleErrors(Object code, Object reason, Object url, Object method, Object headers, Object body, Object response, Object requestHeaders, Object requestBody)
    {
        if (Helpers.isTrue(Helpers.isTrue((Helpers.isEqual(code, 418))) || Helpers.isTrue((Helpers.isEqual(code, 429)))))
        {
            throw new DDoSProtection((String)Helpers.add(Helpers.add(Helpers.add(Helpers.add(Helpers.add(Helpers.add(this.id, " "), String.valueOf(code)), " "), reason), " "), body)) ;
        }
        // error response in a form: { "code": -1013, "msg": "Invalid quantity." }
        // following block cointains legacy checks against message patterns in "msg" property
        // will switch "code" checks eventually, when we know all of them
        if (Helpers.isTrue(Helpers.isGreaterThanOrEqual(code, 400)))
        {
            if (Helpers.isTrue(Helpers.isGreaterThanOrEqual(Helpers.getIndexOf(body, "Price * QTY is zero or less"), 0)))
            {
                throw new InvalidOrder((String)Helpers.add(Helpers.add(this.id, " order cost = amount * price is zero or less "), body)) ;
            }
            if (Helpers.isTrue(Helpers.isGreaterThanOrEqual(Helpers.getIndexOf(body, "LOT_SIZE"), 0)))
            {
                throw new InvalidOrder((String)Helpers.add(Helpers.add(this.id, " order amount should be evenly divisible by lot size "), body)) ;
            }
            if (Helpers.isTrue(Helpers.isGreaterThanOrEqual(Helpers.getIndexOf(body, "PRICE_FILTER"), 0)))
            {
                throw new InvalidOrder((String)Helpers.add(Helpers.add(this.id, " order price is invalid, i.e. exceeds allowed price precision, exceeds min price or max price limits or is invalid value in general, use this.priceToPrecision (symbol, amount) "), body)) ;
            }
        }
        if (Helpers.isTrue(Helpers.isEqual(response, null)))
        {
            return null;  // fallback to default error handler
        }
        // response in format {'msg': 'The coin does not exist.', 'success': true/false}
        Object success = this.safeBool(response, "success", true);
        if (!Helpers.isTrue(success))
        {
            Object messageNew = this.safeString(response, "msg");
            Object parsedMessage = null;
            if (Helpers.isTrue(!Helpers.isEqual(messageNew, null)))
            {
                try
                {
                    parsedMessage = Helpers.parseJson(messageNew);
                } catch(Exception e)
                {
                    // do nothing
                    parsedMessage = null;
                }
                if (Helpers.isTrue(!Helpers.isEqual(parsedMessage, null)))
                {
                    response = parsedMessage;
                }
            }
        }
        Object message = this.safeString(response, "msg");
        if (Helpers.isTrue(!Helpers.isEqual(message, null)))
        {
            this.throwExactlyMatchedException(this.getExceptionsByUrl(url, "exact"), message, Helpers.add(Helpers.add(this.id, " "), message));
            this.throwExactlyMatchedException(Helpers.GetValue(this.exceptions, "exact"), message, Helpers.add(Helpers.add(this.id, " "), message));
            this.throwBroadlyMatchedException(this.getExceptionsByUrl(url, "broad"), message, Helpers.add(Helpers.add(this.id, " "), message));
            this.throwBroadlyMatchedException(Helpers.GetValue(this.exceptions, "broad"), message, Helpers.add(Helpers.add(this.id, " "), message));
        }
        // checks against error codes
        Object error = this.safeString(response, "code");
        if (Helpers.isTrue(!Helpers.isEqual(error, null)))
        {
            // https://github.com/ccxt/ccxt/issues/6501
            // https://github.com/ccxt/ccxt/issues/7742
            if (Helpers.isTrue(Helpers.isTrue((Helpers.isEqual(error, "200"))) || Helpers.isTrue(Precise.stringEquals(error, "0"))))
            {
                return null;
            }
            // a workaround for {"code":-2015,"msg":"Invalid API-key, IP, or permissions for action."}
            // despite that their message is very confusing, it is raised by Binance
            // on a temporary ban, the API key is valid, but disabled for a while
            if (Helpers.isTrue(Helpers.isTrue((Helpers.isEqual(error, "-2015"))) && Helpers.isTrue(Helpers.GetValue(this.options, "hasAlreadyAuthenticatedSuccessfully"))))
            {
                throw new DDoSProtection((String)Helpers.add(Helpers.add(this.id, " "), body)) ;
            }
            Object feedback = Helpers.add(Helpers.add(this.id, " "), body);
            if (Helpers.isTrue(Helpers.isEqual(message, "No need to change margin type.")))
            {
                throw new MarginModeAlreadySet((String)feedback) ;
            }
            this.throwExactlyMatchedException(this.getExceptionsByUrl(url, "exact"), error, feedback);
            this.throwExactlyMatchedException(Helpers.GetValue(this.exceptions, "exact"), error, feedback);
            throw new ExchangeError((String)feedback) ;
        }
        if (!Helpers.isTrue(success))
        {
            throw new ExchangeError((String)Helpers.add(Helpers.add(this.id, " "), body)) ;
        }
        if (Helpers.isTrue(((response instanceof java.util.List) || (response.getClass().isArray()))))
        {
            // cancelOrders returns an array like this: [{"code":-2011,"msg":"Unknown order sent."}]
            Object arrayLength = Helpers.getArrayLength(response);
            if (Helpers.isTrue(Helpers.isEqual(arrayLength, 1)))
            {
                Object element = Helpers.GetValue(response, 0);
                Object errorCode = this.safeString(element, "code");
                if (Helpers.isTrue(!Helpers.isEqual(errorCode, null)))
                {
                    this.throwExactlyMatchedException(this.getExceptionsByUrl(url, "exact"), errorCode, Helpers.add(Helpers.add(this.id, " "), body));
                    this.throwExactlyMatchedException(Helpers.GetValue(this.exceptions, "exact"), errorCode, Helpers.add(Helpers.add(this.id, " "), body));
                }
            }
        }
        return null;
    }

    public Object calculateRateLimiterCost(Object api, Object method, Object path, Object parameters, Object... optionalArgs)
    {
        Object config = Helpers.getArg(optionalArgs, 0, new java.util.HashMap<String, Object>() {{}});
        if (Helpers.isTrue(Helpers.isTrue((Helpers.inOp(config, "noCoin"))) && !Helpers.isTrue((Helpers.inOp(parameters, "coin")))))
        {
            return Helpers.GetValue(config, "noCoin");
        } else if (Helpers.isTrue(Helpers.isTrue((Helpers.inOp(config, "noSymbol"))) && !Helpers.isTrue((Helpers.inOp(parameters, "symbol")))))
        {
            return Helpers.GetValue(config, "noSymbol");
        } else if (Helpers.isTrue(Helpers.isTrue((Helpers.inOp(config, "noPoolId"))) && !Helpers.isTrue((Helpers.inOp(parameters, "poolId")))))
        {
            return Helpers.GetValue(config, "noPoolId");
        } else if (Helpers.isTrue(Helpers.isTrue((Helpers.inOp(config, "byLimit"))) && Helpers.isTrue((Helpers.inOp(parameters, "limit")))))
        {
            Object limit = Helpers.GetValue(parameters, "limit");
            Object byLimit = ((Object)Helpers.GetValue(config, "byLimit"));
            for (var i = 0; Helpers.isLessThan(i, Helpers.getArrayLength(byLimit)); i++)
            {
                Object entry = Helpers.GetValue(byLimit, i);
                if (Helpers.isTrue(Helpers.isLessThanOrEqual(limit, Helpers.GetValue(entry, 0))))
                {
                    return Helpers.GetValue(entry, 1);
                }
            }
        }
        return this.safeValue(config, "cost", 1);
    }

    public java.util.concurrent.CompletableFuture<Object> request(Object path, Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object api = Helpers.getArg(optionalArgs, 0, "public");
            Object method = Helpers.getArg(optionalArgs, 1, "GET");
            Object parameters = Helpers.getArg(optionalArgs, 2, new java.util.HashMap<String, Object>() {{}});
            Object headers = Helpers.getArg(optionalArgs, 3, null);
            Object body = Helpers.getArg(optionalArgs, 4, null);
            Object config = Helpers.getArg(optionalArgs, 5, new java.util.HashMap<String, Object>() {{}});
            Object response = (this.fetch2(path, api, method, parameters, headers, body, config)).join();
            // a workaround for {"code":-2015,"msg":"Invalid API-key, IP, or permissions for action."}
            if (Helpers.isTrue(Helpers.isEqual(api, "private")))
            {
                Helpers.addElementToObject(this.options, "hasAlreadyAuthenticatedSuccessfully", true);
            }
            return response;
        });

    }

    public java.util.concurrent.CompletableFuture<Object> modifyMarginHelper(Object symbol, Object amount2, Object addOrReduce, Object... optionalArgs)
    {
        final Object amount3 = amount2;
        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {
            Object amount = amount3;
            // used to modify isolated positions
            Object parameters = Helpers.getArg(optionalArgs, 0, new java.util.HashMap<String, Object>() {{}});
            Object defaultType = this.safeString(this.options, "defaultType", "future");
            if (Helpers.isTrue(Helpers.isEqual(defaultType, "spot")))
            {
                defaultType = "future";
            }
            Object type = this.safeString(parameters, "type", defaultType);
            if (Helpers.isTrue(Helpers.isTrue((Helpers.isEqual(type, "margin"))) || Helpers.isTrue((Helpers.isEqual(type, "spot")))))
            {
                throw new NotSupported((String)Helpers.add(this.id, " add / reduce margin only supported with type future or delivery")) ;
            }
            (this.loadMarkets()).join();
            Object market = this.market(symbol);
            amount = this.amountToPrecision(symbol, amount);
            final Object finalAmount = amount;
            Object request = new java.util.HashMap<String, Object>() {{
                put( "type", addOrReduce );
                put( "symbol", Helpers.GetValue(market, "id") );
                put( "amount", finalAmount );
            }};
            Object response = null;
            Object code = null;
            if (Helpers.isTrue(Helpers.GetValue(market, "linear")))
            {
                code = Helpers.GetValue(market, "quote");
                response = (this.fapiPrivatePostPositionMargin(this.extend(request, parameters))).join();
            } else
            {
                code = Helpers.GetValue(market, "base");
                response = (this.dapiPrivatePostPositionMargin(this.extend(request, parameters))).join();
            }
            //
            //     {
            //         "code": 200,
            //         "msg": "Successfully modify position margin.",
            //         "amount": 0.001,
            //         "type": 1
            //     }
            //
            final Object finalCode = code;
            return this.extend(this.parseMarginModification(response, market), new java.util.HashMap<String, Object>() {{
                put( "code", finalCode );
            }});
        });

    }

    public Object parseMarginModification(Object data, Object... optionalArgs)
    {
        //
        // add/reduce margin
        //
        //     {
        //         "code": 200,
        //         "msg": "Successfully modify position margin.",
        //         "amount": 0.001,
        //         "type": 1
        //     }
        //
        // fetchMarginAdjustmentHistory
        //
        //    {
        //        symbol: "XRPUSDT",
        //        type: "1",
        //        deltaType: "TRADE",
        //        amount: "2.57148240",
        //        asset: "USDT",
        //        time: "1711046271555",
        //        positionSide: "BOTH",
        //        clientTranId: ""
        //    }
        //
        Object market = Helpers.getArg(optionalArgs, 0, null);
        Object rawType = this.safeInteger(data, "type");
        Object errorCode = this.safeString(data, "code");
        Object marketId = this.safeString(data, "symbol");
        Object timestamp = this.safeInteger(data, "time");
        market = this.safeMarket(marketId, market, null, "swap");
        Object noErrorCode = Helpers.isEqual(errorCode, null);
        Object success = Helpers.isEqual(errorCode, "200");
        final Object finalMarket = market;
        return new java.util.HashMap<String, Object>() {{
            put( "info", data );
            put( "symbol", Helpers.GetValue(finalMarket, "symbol") );
            put( "type", ((Helpers.isTrue((Helpers.isEqual(rawType, 1))))) ? "add" : "reduce" );
            put( "marginMode", "isolated" );
            put( "amount", Binance.this.safeNumber(data, "amount") );
            put( "code", Binance.this.safeString(data, "asset") );
            put( "total", null );
            put( "status", ((Helpers.isTrue((Helpers.isTrue(success) || Helpers.isTrue(noErrorCode))))) ? "ok" : "failed" );
            put( "timestamp", timestamp );
            put( "datetime", Binance.this.iso8601(timestamp) );
        }};
    }

    /**
     * @method
     * @name binance#reduceMargin
     * @description remove margin from a position
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Modify-Isolated-Position-Margin
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Modify-Isolated-Position-Margin
     * @param {string} symbol unified market symbol
     * @param {float} amount the amount of margin to remove
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=reduce-margin-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> reduceMargin(Object symbol, Object amount, Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object parameters = Helpers.getArg(optionalArgs, 0, new java.util.HashMap<String, Object>() {{}});
            return (this.modifyMarginHelper(symbol, amount, 2, parameters)).join();
        });

    }

    /**
     * @method
     * @name binance#addMargin
     * @description add margin
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Modify-Isolated-Position-Margin
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Modify-Isolated-Position-Margin
     * @param {string} symbol unified market symbol
     * @param {float} amount amount of margin to add
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=add-margin-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> addMargin(Object symbol, Object amount, Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object parameters = Helpers.getArg(optionalArgs, 0, new java.util.HashMap<String, Object>() {{}});
            return (this.modifyMarginHelper(symbol, amount, 1, parameters)).join();
        });

    }

    /**
     * @method
     * @name binance#fetchCrossBorrowRate
     * @description fetch the rate of interest to borrow a currency for margin trading
     * @see https://developers.binance.com/docs/margin_trading/borrow-and-repay/Query-Margin-Interest-Rate-History
     * @param {string} code unified currency code
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [borrow rate structure]{@link https://docs.ccxt.com/#/?id=borrow-rate-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchCrossBorrowRate(Object code, Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object parameters = Helpers.getArg(optionalArgs, 0, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object currency = this.currency(code);
            Object request = new java.util.HashMap<String, Object>() {{
                put( "asset", Helpers.GetValue(currency, "id") );
            }};
            Object response = (this.sapiGetMarginInterestRateHistory(this.extend(request, parameters))).join();
            //
            //     [
            //         {
            //             "asset": "USDT",
            //             "timestamp": 1638230400000,
            //             "dailyInterestRate": "0.0006",
            //             "vipLevel": 0
            //         },
            //     ]
            //
            Object rate = this.safeDict(response, 0);
            return this.parseBorrowRate(rate);
        });

    }

    /**
     * @method
     * @name binance#fetchIsolatedBorrowRate
     * @description fetch the rate of interest to borrow a currency for margin trading
     * @see https://developers.binance.com/docs/margin_trading/account/Query-Isolated-Margin-Fee-Data
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     *
     * EXCHANGE SPECIFIC PARAMETERS
     * @param {object} [params.vipLevel] user's current specific margin data will be returned if viplevel is omitted
     * @returns {object} an [isolated borrow rate structure]{@link https://docs.ccxt.com/#/?id=isolated-borrow-rate-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchIsolatedBorrowRate(Object symbol, Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object parameters = Helpers.getArg(optionalArgs, 0, new java.util.HashMap<String, Object>() {{}});
            Object request = new java.util.HashMap<String, Object>() {{
                put( "symbol", symbol );
            }};
            Object borrowRates = (this.fetchIsolatedBorrowRates(this.extend(request, parameters))).join();
            return this.safeDict(borrowRates, symbol);
        });

    }

    /**
     * @method
     * @name binance#fetchIsolatedBorrowRates
     * @description fetch the borrow interest rates of all currencies
     * @see https://developers.binance.com/docs/margin_trading/account/Query-Isolated-Margin-Fee-Data
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {object} [params.symbol] unified market symbol
     *
     * EXCHANGE SPECIFIC PARAMETERS
     * @param {object} [params.vipLevel] user's current specific margin data will be returned if viplevel is omitted
     * @returns {object} a [borrow rate structure]{@link https://docs.ccxt.com/#/?id=borrow-rate-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchIsolatedBorrowRates(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object parameters = Helpers.getArg(optionalArgs, 0, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object request = new java.util.HashMap<String, Object>() {{}};
            Object symbol = this.safeString(parameters, "symbol");
            parameters = this.omit(parameters, "symbol");
            if (Helpers.isTrue(!Helpers.isEqual(symbol, null)))
            {
                Object market = this.market(symbol);
                Helpers.addElementToObject(request, "symbol", Helpers.GetValue(market, "id"));
            }
            Object response = (this.sapiGetMarginIsolatedMarginData(this.extend(request, parameters))).join();
            //
            //    [
            //        {
            //            "vipLevel": 0,
            //            "symbol": "BTCUSDT",
            //            "leverage": "10",
            //            "data": [
            //                {
            //                    "coin": "BTC",
            //                    "dailyInterest": "0.00026125",
            //                    "borrowLimit": "270"
            //                },
            //                {
            //                    "coin": "USDT",
            //                    "dailyInterest": "0.000475",
            //                    "borrowLimit": "2100000"
            //                }
            //            ]
            //        }
            //    ]
            //
            return this.parseIsolatedBorrowRates(response);
        });

    }

    /**
     * @method
     * @name binance#fetchBorrowRateHistory
     * @description retrieves a history of a currencies borrow interest rate at specific time slots
     * @see https://developers.binance.com/docs/margin_trading/borrow-and-repay/Query-Margin-Interest-Rate-History
     * @param {string} code unified currency code
     * @param {int} [since] timestamp for the earliest borrow rate
     * @param {int} [limit] the maximum number of [borrow rate structures]{@link https://docs.ccxt.com/#/?id=borrow-rate-structure} to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of [borrow rate structures]{@link https://docs.ccxt.com/#/?id=borrow-rate-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchBorrowRateHistory(Object code, Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object since = Helpers.getArg(optionalArgs, 0, null);
            Object limit = Helpers.getArg(optionalArgs, 1, null);
            Object parameters = Helpers.getArg(optionalArgs, 2, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            if (Helpers.isTrue(Helpers.isEqual(limit, null)))
            {
                limit = 93;
            } else if (Helpers.isTrue(Helpers.isGreaterThan(limit, 93)))
            {
                throw new BadRequest((String)Helpers.add(this.id, " fetchBorrowRateHistory() limit parameter cannot exceed 92")) ;
            }
            Object currency = this.currency(code);
            final Object finalLimit = limit;
            Object request = new java.util.HashMap<String, Object>() {{
                put( "asset", Helpers.GetValue(currency, "id") );
                put( "limit", finalLimit );
            }};
            if (Helpers.isTrue(!Helpers.isEqual(since, null)))
            {
                Helpers.addElementToObject(request, "startTime", since);
                Object endTime = Helpers.subtract(this.sum(since, Helpers.multiply(limit, 86400000)), 1); // required when startTime is further than 93 days in the past
                Object now = this.milliseconds();
                Helpers.addElementToObject(request, "endTime", Helpers.mathMin(endTime, now)); // cannot have an endTime later than current time
            }
            Object response = (this.sapiGetMarginInterestRateHistory(this.extend(request, parameters))).join();
            //
            //     [
            //         {
            //             "asset": "USDT",
            //             "timestamp": 1638230400000,
            //             "dailyInterestRate": "0.0006",
            //             "vipLevel": 0
            //         },
            //     ]
            //
            return this.parseBorrowRateHistory(response, code, since, limit);
        });

    }

    public Object parseBorrowRate(Object info, Object... optionalArgs)
    {
        //
        //    {
        //        "asset": "USDT",
        //        "timestamp": 1638230400000,
        //        "dailyInterestRate": "0.0006",
        //        "vipLevel": 0
        //    }
        //
        Object currency = Helpers.getArg(optionalArgs, 0, null);
        Object timestamp = this.safeInteger(info, "timestamp");
        Object currencyId = this.safeString(info, "asset");
        return new java.util.HashMap<String, Object>() {{
            put( "currency", Binance.this.safeCurrencyCode(currencyId, currency) );
            put( "rate", Binance.this.safeNumber(info, "dailyInterestRate") );
            put( "period", 86400000 );
            put( "timestamp", timestamp );
            put( "datetime", Binance.this.iso8601(timestamp) );
            put( "info", info );
        }};
    }

    public Object parseIsolatedBorrowRate(Object info, Object... optionalArgs)
    {
        //
        //    {
        //        "vipLevel": 0,
        //        "symbol": "BTCUSDT",
        //        "leverage": "10",
        //        "data": [
        //            {
        //                "coin": "BTC",
        //                "dailyInterest": "0.00026125",
        //                "borrowLimit": "270"
        //            },
        //            {
        //                "coin": "USDT",
        //                "dailyInterest": "0.000475",
        //                "borrowLimit": "2100000"
        //            }
        //        ]
        //    }
        //
        Object market = Helpers.getArg(optionalArgs, 0, null);
        Object marketId = this.safeString(info, "symbol");
        market = this.safeMarket(marketId, market, null, "spot");
        Object data = this.safeList(info, "data");
        Object baseInfo = this.safeDict(data, 0);
        Object quoteInfo = this.safeDict(data, 1);
        final Object finalMarket = market;
        return new java.util.HashMap<String, Object>() {{
            put( "info", info );
            put( "symbol", Binance.this.safeString(finalMarket, "symbol") );
            put( "base", Binance.this.safeString(baseInfo, "coin") );
            put( "baseRate", Binance.this.safeNumber(baseInfo, "dailyInterest") );
            put( "quote", Binance.this.safeString(quoteInfo, "coin") );
            put( "quoteRate", Binance.this.safeNumber(quoteInfo, "dailyInterest") );
            put( "period", 86400000 );
            put( "timestamp", null );
            put( "datetime", null );
        }};
    }

    /**
     * @method
     * @name binance#createGiftCode
     * @description create gift code
     * @see https://developers.binance.com/docs/gift_card/market-data/Create-a-single-token-gift-card
     * @param {string} code gift code
     * @param {float} amount amount of currency for the gift
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} The gift code id, code, currency and amount
     */
    public java.util.concurrent.CompletableFuture<Object> createGiftCode(Object code, Object amount, Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object parameters = Helpers.getArg(optionalArgs, 0, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object currency = this.currency(code);
            // ensure you have enough token in your funding account before calling this code
            Object request = new java.util.HashMap<String, Object>() {{
                put( "token", Helpers.GetValue(currency, "id") );
                put( "amount", amount );
            }};
            Object response = (this.sapiPostGiftcardCreateCode(this.extend(request, parameters))).join();
            //
            //     {
            //         "code": "000000",
            //         "message": "success",
            //         "data": { referenceNo: "0033002404219823", code: "AP6EXTLKNHM6CEX7" },
            //         "success": true
            //     }
            //
            Object data = this.safeDict(response, "data");
            Object giftcardCode = this.safeString(data, "code");
            Object id = this.safeString(data, "referenceNo");
            return new java.util.HashMap<String, Object>() {{
                put( "info", response );
                put( "id", id );
                put( "code", giftcardCode );
                put( "currency", code );
                put( "amount", amount );
            }};
        });

    }

    /**
     * @method
     * @name binance#redeemGiftCode
     * @description redeem gift code
     * @see https://developers.binance.com/docs/gift_card/market-data/Redeem-a-Binance-Gift-Card
     * @param {string} giftcardCode
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} response from the exchange
     */
    public java.util.concurrent.CompletableFuture<Object> redeemGiftCode(Object giftcardCode, Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object parameters = Helpers.getArg(optionalArgs, 0, new java.util.HashMap<String, Object>() {{}});
            Object request = new java.util.HashMap<String, Object>() {{
                put( "code", giftcardCode );
            }};
            Object response = (this.sapiPostGiftcardRedeemCode(this.extend(request, parameters))).join();
            //
            //     {
            //         "code": "000000",
            //         "message": "success",
            //         "data": {
            //             "referenceNo": "0033002404219823",
            //             "identityNo": "10316431732801474560"
            //         },
            //         "success": true
            //     }
            //
            return response;
        });

    }

    /**
     * @method
     * @name binance#verifyGiftCode
     * @description verify gift code
     * @see https://developers.binance.com/docs/gift_card/market-data/Verify-Binance-Gift-Card-by-Gift-Card-Number
     * @param {string} id reference number id
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} response from the exchange
     */
    public java.util.concurrent.CompletableFuture<Object> verifyGiftCode(Object id, Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object parameters = Helpers.getArg(optionalArgs, 0, new java.util.HashMap<String, Object>() {{}});
            Object request = new java.util.HashMap<String, Object>() {{
                put( "referenceNo", id );
            }};
            Object response = (this.sapiGetGiftcardVerify(this.extend(request, parameters))).join();
            //
            //     {
            //         "code": "000000",
            //         "message": "success",
            //         "data": { valid: true },
            //         "success": true
            //     }
            //
            return response;
        });

    }

    /**
     * @method
     * @name binance#fetchBorrowInterest
     * @description fetch the interest owed by the user for borrowing currency for margin trading
     * @see https://developers.binance.com/docs/margin_trading/borrow-and-repay/Get-Interest-History
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/account/Get-Margin-BorrowLoan-Interest-History
     * @param {string} [code] unified currency code
     * @param {string} [symbol] unified market symbol when fetch interest in isolated markets
     * @param {int} [since] the earliest time in ms to fetch borrrow interest for
     * @param {int} [limit] the maximum number of structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.portfolioMargin] set to true if you would like to fetch the borrow interest in a portfolio margin account
     * @returns {object[]} a list of [borrow interest structures]{@link https://docs.ccxt.com/#/?id=borrow-interest-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchBorrowInterest(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object code = Helpers.getArg(optionalArgs, 0, null);
            Object symbol = Helpers.getArg(optionalArgs, 1, null);
            Object since = Helpers.getArg(optionalArgs, 2, null);
            Object limit = Helpers.getArg(optionalArgs, 3, null);
            Object parameters = Helpers.getArg(optionalArgs, 4, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object isPortfolioMargin = null;
            var isPortfolioMarginparametersVariable = this.handleOptionAndParams2(parameters, "fetchBorrowInterest", "papi", "portfolioMargin", false);
            isPortfolioMargin = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(0);
            parameters = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(1);
            Object request = new java.util.HashMap<String, Object>() {{}};
            Object market = null;
            if (Helpers.isTrue(!Helpers.isEqual(code, null)))
            {
                Object currency = this.currency(code);
                Helpers.addElementToObject(request, "asset", Helpers.GetValue(currency, "id"));
            }
            if (Helpers.isTrue(!Helpers.isEqual(since, null)))
            {
                Helpers.addElementToObject(request, "startTime", since);
            }
            if (Helpers.isTrue(!Helpers.isEqual(limit, null)))
            {
                Helpers.addElementToObject(request, "size", limit);
            }
            var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
            request = ((java.util.List<Object>) requestparametersVariable).get(0);
            parameters = ((java.util.List<Object>) requestparametersVariable).get(1);
            Object response = null;
            if (Helpers.isTrue(isPortfolioMargin))
            {
                response = (this.papiGetMarginMarginInterestHistory(this.extend(request, parameters))).join();
            } else
            {
                if (Helpers.isTrue(!Helpers.isEqual(symbol, null)))
                {
                    market = this.market(symbol);
                    Helpers.addElementToObject(request, "isolatedSymbol", Helpers.GetValue(market, "id"));
                }
                response = (this.sapiGetMarginInterestHistory(this.extend(request, parameters))).join();
            }
            //
            // spot margin
            //
            //     {
            //         "rows":[
            //             {
            //                 "isolatedSymbol": "BNBUSDT", // isolated symbol, will not be returned for crossed margin
            //                 "asset": "BNB",
            //                 "interest": "0.02414667",
            //                 "interestAccuredTime": 1566813600000,
            //                 "interestRate": "0.01600000",
            //                 "principal": "36.22000000",
            //                 "type": "ON_BORROW"
            //             }
            //         ],
            //         "total": 1
            //     }
            //
            // spot margin portfolio margin
            //
            //     {
            //         "total": 49,
            //         "rows": [
            //             {
            //                 "txId": 1656187724899910076,
            //                 "interestAccuredTime": 1707541200000,
            //                 "asset": "USDT",
            //                 "rawAsset": "USDT",
            //                 "principal": "0.00011146",
            //                 "interest": "0.00000001",
            //                 "interestRate": "0.00089489",
            //                 "type": "PERIODIC"
            //             },
            //         ]
            //     }
            //
            Object rows = this.safeList(response, "rows");
            Object interest = this.parseBorrowInterests(rows, market);
            return this.filterByCurrencySinceLimit(interest, code, since, limit);
        });

    }

    public Object parseBorrowInterest(Object info, Object... optionalArgs)
    {
        Object market = Helpers.getArg(optionalArgs, 0, null);
        Object symbol = this.safeString(info, "isolatedSymbol");
        Object timestamp = this.safeInteger(info, "interestAccuredTime");
        Object marginMode = ((Helpers.isTrue((Helpers.isEqual(symbol, null))))) ? "cross" : "isolated";
        final Object finalSymbol = symbol;
        return new java.util.HashMap<String, Object>() {{
            put( "info", info );
            put( "symbol", finalSymbol );
            put( "currency", Binance.this.safeCurrencyCode(Binance.this.safeString(info, "asset")) );
            put( "interest", Binance.this.safeNumber(info, "interest") );
            put( "interestRate", Binance.this.safeNumber(info, "interestRate") );
            put( "amountBorrowed", Binance.this.safeNumber(info, "principal") );
            put( "marginMode", marginMode );
            put( "timestamp", timestamp );
            put( "datetime", Binance.this.iso8601(timestamp) );
        }};
    }

    /**
     * @method
     * @name binance#repayCrossMargin
     * @description repay borrowed margin and interest
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Margin-Account-Repay
     * @see https://developers.binance.com/docs/margin_trading/borrow-and-repay/Margin-Account-Borrow-Repay
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Margin-Account-Repay-Debt
     * @param {string} code unified currency code of the currency to repay
     * @param {float} amount the amount to repay
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.portfolioMargin] set to true if you would like to repay margin in a portfolio margin account
     * @param {string} [params.repayCrossMarginMethod] *portfolio margin only* 'papiPostRepayLoan' (default), 'papiPostMarginRepayDebt' (alternative)
     * @param {string} [params.specifyRepayAssets] *portfolio margin papiPostMarginRepayDebt only* specific asset list to repay debt
     * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> repayCrossMargin(Object code, Object amount, Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object parameters = Helpers.getArg(optionalArgs, 0, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object currency = this.currency(code);
            Object request = new java.util.HashMap<String, Object>() {{
                put( "asset", Helpers.GetValue(currency, "id") );
                put( "amount", Binance.this.currencyToPrecision(code, amount) );
            }};
            Object response = null;
            Object isPortfolioMargin = null;
            var isPortfolioMarginparametersVariable = this.handleOptionAndParams2(parameters, "repayCrossMargin", "papi", "portfolioMargin", false);
            isPortfolioMargin = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(0);
            parameters = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(1);
            if (Helpers.isTrue(isPortfolioMargin))
            {
                Object method = null;
                var methodparametersVariable = this.handleOptionAndParams2(parameters, "repayCrossMargin", "repayCrossMarginMethod", "method");
                method = ((java.util.List<Object>) methodparametersVariable).get(0);
                parameters = ((java.util.List<Object>) methodparametersVariable).get(1);
                if (Helpers.isTrue(Helpers.isEqual(method, "papiPostMarginRepayDebt")))
                {
                    response = (this.papiPostMarginRepayDebt(this.extend(request, parameters))).join();
                } else
                {
                    response = (this.papiPostRepayLoan(this.extend(request, parameters))).join();
                }
            } else
            {
                Helpers.addElementToObject(request, "isIsolated", "FALSE");
                Helpers.addElementToObject(request, "type", "REPAY");
                response = (this.sapiPostMarginBorrowRepay(this.extend(request, parameters))).join();
            }
            return this.parseMarginLoan(response, currency);
        });

    }

    /**
     * @method
     * @name binance#repayIsolatedMargin
     * @description repay borrowed margin and interest
     * @see https://developers.binance.com/docs/margin_trading/borrow-and-repay/Margin-Account-Borrow-Repay
     * @param {string} symbol unified market symbol, required for isolated margin
     * @param {string} code unified currency code of the currency to repay
     * @param {float} amount the amount to repay
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> repayIsolatedMargin(Object symbol, Object code, Object amount, Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object parameters = Helpers.getArg(optionalArgs, 0, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object currency = this.currency(code);
            Object market = this.market(symbol);
            Object request = new java.util.HashMap<String, Object>() {{
                put( "asset", Helpers.GetValue(currency, "id") );
                put( "amount", Binance.this.currencyToPrecision(code, amount) );
                put( "symbol", Helpers.GetValue(market, "id") );
                put( "isIsolated", "TRUE" );
                put( "type", "REPAY" );
            }};
            Object response = (this.sapiPostMarginBorrowRepay(this.extend(request, parameters))).join();
            //
            //     {
            //         "tranId": 108988250265,
            //         "clientTag":""
            //     }
            //
            return this.parseMarginLoan(response, currency);
        });

    }

    /**
     * @method
     * @name binance#borrowCrossMargin
     * @description create a loan to borrow margin
     * @see https://developers.binance.com/docs/margin_trading/borrow-and-repay/Margin-Account-Borrow-Repay
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Margin-Account-Borrow
     * @param {string} code unified currency code of the currency to borrow
     * @param {float} amount the amount to borrow
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.portfolioMargin] set to true if you would like to borrow margin in a portfolio margin account
     * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> borrowCrossMargin(Object code, Object amount, Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object parameters = Helpers.getArg(optionalArgs, 0, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object currency = this.currency(code);
            Object request = new java.util.HashMap<String, Object>() {{
                put( "asset", Helpers.GetValue(currency, "id") );
                put( "amount", Binance.this.currencyToPrecision(code, amount) );
            }};
            Object response = null;
            Object isPortfolioMargin = null;
            var isPortfolioMarginparametersVariable = this.handleOptionAndParams2(parameters, "borrowCrossMargin", "papi", "portfolioMargin", false);
            isPortfolioMargin = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(0);
            parameters = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(1);
            if (Helpers.isTrue(isPortfolioMargin))
            {
                response = (this.papiPostMarginLoan(this.extend(request, parameters))).join();
            } else
            {
                Helpers.addElementToObject(request, "isIsolated", "FALSE");
                Helpers.addElementToObject(request, "type", "BORROW");
                response = (this.sapiPostMarginBorrowRepay(this.extend(request, parameters))).join();
            }
            //
            //     {
            //         "tranId": 108988250265,
            //         "clientTag":""
            //     }
            //
            return this.parseMarginLoan(response, currency);
        });

    }

    /**
     * @method
     * @name binance#borrowIsolatedMargin
     * @description create a loan to borrow margin
     * @see https://developers.binance.com/docs/margin_trading/borrow-and-repay/Margin-Account-Borrow-Repay
     * @param {string} symbol unified market symbol, required for isolated margin
     * @param {string} code unified currency code of the currency to borrow
     * @param {float} amount the amount to borrow
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> borrowIsolatedMargin(Object symbol, Object code, Object amount, Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object parameters = Helpers.getArg(optionalArgs, 0, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object currency = this.currency(code);
            Object market = this.market(symbol);
            Object request = new java.util.HashMap<String, Object>() {{
                put( "asset", Helpers.GetValue(currency, "id") );
                put( "amount", Binance.this.currencyToPrecision(code, amount) );
                put( "symbol", Helpers.GetValue(market, "id") );
                put( "isIsolated", "TRUE" );
                put( "type", "BORROW" );
            }};
            Object response = (this.sapiPostMarginBorrowRepay(this.extend(request, parameters))).join();
            //
            //     {
            //         "tranId": 108988250265,
            //         "clientTag":""
            //     }
            //
            return this.parseMarginLoan(response, currency);
        });

    }

    public Object parseMarginLoan(Object info, Object... optionalArgs)
    {
        //
        //     {
        //         "tranId": 108988250265,
        //         "clientTag":""
        //     }
        //
        // repayCrossMargin alternative endpoint
        //
        //     {
        //         "asset": "USDC",
        //         "amount": 10,
        //         "specifyRepayAssets": null,
        //         "updateTime": 1727170761267,
        //         "success": true
        //     }
        //
        Object currency = Helpers.getArg(optionalArgs, 0, null);
        Object currencyId = this.safeString(info, "asset");
        Object timestamp = this.safeInteger(info, "updateTime");
        return new java.util.HashMap<String, Object>() {{
            put( "id", Binance.this.safeInteger(info, "tranId") );
            put( "currency", Binance.this.safeCurrencyCode(currencyId, currency) );
            put( "amount", Binance.this.safeNumber(info, "amount") );
            put( "symbol", null );
            put( "timestamp", timestamp );
            put( "datetime", Binance.this.iso8601(timestamp) );
            put( "info", info );
        }};
    }

    /**
     * @method
     * @name binance#fetchOpenInterestHistory
     * @description Retrieves the open interest history of a currency
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Open-Interest-Statistics
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/Open-Interest-Statistics
     * @param {string} symbol Unified CCXT market symbol
     * @param {string} timeframe "5m","15m","30m","1h","2h","4h","6h","12h", or "1d"
     * @param {int} [since] the time(ms) of the earliest record to retrieve as a unix timestamp
     * @param {int} [limit] default 30, max 500
     * @param {object} [params] exchange specific parameters
     * @param {int} [params.until] the time(ms) of the latest record to retrieve as a unix timestamp
     * @param {boolean} [params.paginate] default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [availble parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @returns {object} an array of [open interest structure]{@link https://docs.ccxt.com/#/?id=open-interest-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchOpenInterestHistory(Object symbol, Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object timeframe = Helpers.getArg(optionalArgs, 0, "5m");
            Object since = Helpers.getArg(optionalArgs, 1, null);
            Object limit = Helpers.getArg(optionalArgs, 2, null);
            Object parameters = Helpers.getArg(optionalArgs, 3, new java.util.HashMap<String, Object>() {{}});
            if (Helpers.isTrue(Helpers.isEqual(timeframe, "1m")))
            {
                throw new BadRequest((String)Helpers.add(this.id, " fetchOpenInterestHistory cannot use the 1m timeframe")) ;
            }
            (this.loadMarkets()).join();
            Object paginate = false;
            var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchOpenInterestHistory", "paginate", false);
            paginate = ((java.util.List<Object>) paginateparametersVariable).get(0);
            parameters = ((java.util.List<Object>) paginateparametersVariable).get(1);
            if (Helpers.isTrue(paginate))
            {
                return (this.fetchPaginatedCallDeterministic("fetchOpenInterestHistory", symbol, since, limit, timeframe, parameters, 500)).join();
            }
            Object market = this.market(symbol);
            final Object finalTimeframe = timeframe;
            Object request = new java.util.HashMap<String, Object>() {{
                put( "period", Binance.this.safeString(Binance.this.timeframes, finalTimeframe, finalTimeframe) );
            }};
            if (Helpers.isTrue(!Helpers.isEqual(limit, null)))
            {
                Helpers.addElementToObject(request, "limit", limit);
            }
            Object symbolKey = ((Helpers.isTrue(Helpers.GetValue(market, "linear")))) ? "symbol" : "pair";
            Helpers.addElementToObject(request, symbolKey, Helpers.GetValue(market, "id"));
            if (Helpers.isTrue(Helpers.GetValue(market, "inverse")))
            {
                Helpers.addElementToObject(request, "contractType", this.safeString(parameters, "contractType", "CURRENT_QUARTER"));
            }
            if (Helpers.isTrue(!Helpers.isEqual(since, null)))
            {
                Helpers.addElementToObject(request, "startTime", since);
            }
            Object until = this.safeInteger(parameters, "until"); // unified in milliseconds
            Object endTime = this.safeInteger(parameters, "endTime", until); // exchange-specific in milliseconds
            parameters = this.omit(parameters, new java.util.ArrayList<Object>(java.util.Arrays.asList("endTime", "until")));
            if (Helpers.isTrue(endTime))
            {
                Helpers.addElementToObject(request, "endTime", endTime);
            } else if (Helpers.isTrue(since))
            {
                if (Helpers.isTrue(Helpers.isEqual(limit, null)))
                {
                    limit = 30; // Exchange default
                }
                Object duration = this.parseTimeframe(timeframe);
                Helpers.addElementToObject(request, "endTime", this.sum(since, Helpers.multiply(Helpers.multiply(duration, limit), 1000)));
            }
            Object response = null;
            if (Helpers.isTrue(Helpers.GetValue(market, "inverse")))
            {
                response = (this.dapiDataGetOpenInterestHist(this.extend(request, parameters))).join();
            } else
            {
                response = (this.fapiDataGetOpenInterestHist(this.extend(request, parameters))).join();
            }
            //
            //  [
            //      {
            //          "symbol":"BTCUSDT",
            //          "sumOpenInterest":"75375.61700000",
            //          "sumOpenInterestValue":"3248828883.71251440",
            //          "timestamp":1642179900000
            //      },
            //      ...
            //  ]
            //
            return this.parseOpenInterestsHistory(response, market, since, limit);
        });

    }

    /**
     * @method
     * @name binance#fetchOpenInterest
     * @description retrieves the open interest of a contract trading pair
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Open-Interest
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/Open-Interest
     * @see https://developers.binance.com/docs/derivatives/option/market-data/Open-Interest
     * @param {string} symbol unified CCXT market symbol
     * @param {object} [params] exchange specific parameters
     * @returns {object} an open interest structure{@link https://docs.ccxt.com/#/?id=open-interest-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchOpenInterest(Object symbol2, Object... optionalArgs)
    {
        final Object symbol3 = symbol2;
        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {
            Object symbol = symbol3;
            Object parameters = Helpers.getArg(optionalArgs, 0, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object market = this.market(symbol);
            Object request = new java.util.HashMap<String, Object>() {{}};
            if (Helpers.isTrue(Helpers.GetValue(market, "option")))
            {
                Helpers.addElementToObject(request, "underlyingAsset", Helpers.GetValue(market, "baseId"));
                if (Helpers.isTrue(Helpers.isEqual(Helpers.GetValue(market, "expiry"), null)))
                {
                    throw new NotSupported((String)Helpers.add(Helpers.add(this.id, " fetchOpenInterest does not support "), symbol)) ;
                }
                Helpers.addElementToObject(request, "expiration", this.yymmdd(Helpers.GetValue(market, "expiry")));
            } else
            {
                Helpers.addElementToObject(request, "symbol", Helpers.GetValue(market, "id"));
            }
            Object response = null;
            if (Helpers.isTrue(Helpers.GetValue(market, "option")))
            {
                response = (this.eapiPublicGetOpenInterest(this.extend(request, parameters))).join();
            } else if (Helpers.isTrue(Helpers.GetValue(market, "inverse")))
            {
                response = (this.dapiPublicGetOpenInterest(this.extend(request, parameters))).join();
            } else
            {
                response = (this.fapiPublicGetOpenInterest(this.extend(request, parameters))).join();
            }
            //
            // futures (fapi)
            //
            //     {
            //         "symbol": "ETHUSDT_230331",
            //         "openInterest": "23581.677",
            //         "time": 1677356872265
            //     }
            //
            // futures (dapi)
            //
            //     {
            //         "symbol": "ETHUSD_PERP",
            //         "pair": "ETHUSD",
            //         "openInterest": "26542436",
            //         "contractType": "PERPETUAL",
            //         "time": 1677360272224
            //     }
            //
            // options (eapi)
            //
            //     [
            //         {
            //             "symbol": "ETH-230225-1625-C",
            //             "sumOpenInterest": "460.50",
            //             "sumOpenInterestUsd": "734957.4358092150",
            //             "timestamp": "1677304860000"
            //         }
            //     ]
            //
            if (Helpers.isTrue(Helpers.GetValue(market, "option")))
            {
                symbol = Helpers.GetValue(market, "symbol");
                Object result = this.parseOpenInterestsHistory(response, market);
                for (var i = 0; Helpers.isLessThan(i, Helpers.getArrayLength(result)); i++)
                {
                    Object item = Helpers.GetValue(result, i);
                    if (Helpers.isTrue(Helpers.isEqual(Helpers.GetValue(item, "symbol"), symbol)))
                    {
                        return item;
                    }
                }
            } else
            {
                return this.parseOpenInterest(response, market);
            }
            return null;
        });

    }

    public Object parseOpenInterest(Object interest, Object... optionalArgs)
    {
        Object market = Helpers.getArg(optionalArgs, 0, null);
        Object timestamp = this.safeInteger2(interest, "timestamp", "time");
        Object id = this.safeString(interest, "symbol");
        Object amount = this.safeNumber2(interest, "sumOpenInterest", "openInterest");
        Object value = this.safeNumber2(interest, "sumOpenInterestValue", "sumOpenInterestUsd");
        // Inverse returns the number of contracts different from the base or quote volume in this case
        // compared with https://www.binance.com/en/futures/funding-history/quarterly/4
        return this.safeOpenInterest(new java.util.HashMap<String, Object>() {{
            put( "symbol", Binance.this.safeSymbol(id, market, null, "contract") );
            put( "baseVolume", ((Helpers.isTrue(Helpers.GetValue(market, "inverse")))) ? null : amount );
            put( "quoteVolume", value );
            put( "openInterestAmount", amount );
            put( "openInterestValue", value );
            put( "timestamp", timestamp );
            put( "datetime", Binance.this.iso8601(timestamp) );
            put( "info", interest );
        }}, market);
    }

    /**
     * @method
     * @name binance#fetchMyLiquidations
     * @description retrieves the users liquidated positions
     * @see https://developers.binance.com/docs/margin_trading/trade/Get-Force-Liquidation-Record
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Users-Force-Orders
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Users-Force-Orders
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-Users-UM-Force-Orders
     * @see https://developers.binance.com/docs/derivatives/portfolio-margin/trade/Query-Users-CM-Force-Orders
     * @param {string} [symbol] unified CCXT market symbol
     * @param {int} [since] the earliest time in ms to fetch liquidations for
     * @param {int} [limit] the maximum number of liquidation structures to retrieve
     * @param {object} [params] exchange specific parameters for the binance api endpoint
     * @param {int} [params.until] timestamp in ms of the latest liquidation
     * @param {boolean} [params.paginate] *spot only* default false, when true will automatically paginate by calling this endpoint multiple times. See in the docs all the [available parameters](https://github.com/ccxt/ccxt/wiki/Manual#pagination-params)
     * @param {boolean} [params.portfolioMargin] set to true if you would like to fetch liquidations in a portfolio margin account
     * @param {string} [params.type] "spot"
     * @param {string} [params.subType] "linear" or "inverse"
     * @returns {object} an array of [liquidation structures]{@link https://docs.ccxt.com/#/?id=liquidation-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchMyLiquidations(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object symbol = Helpers.getArg(optionalArgs, 0, null);
            Object since = Helpers.getArg(optionalArgs, 1, null);
            Object limit = Helpers.getArg(optionalArgs, 2, null);
            Object parameters = Helpers.getArg(optionalArgs, 3, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object paginate = false;
            var paginateparametersVariable = this.handleOptionAndParams(parameters, "fetchMyLiquidations", "paginate");
            paginate = ((java.util.List<Object>) paginateparametersVariable).get(0);
            parameters = ((java.util.List<Object>) paginateparametersVariable).get(1);
            if (Helpers.isTrue(paginate))
            {
                return (this.fetchPaginatedCallIncremental("fetchMyLiquidations", symbol, since, limit, parameters, "current", 100)).join();
            }
            Object market = null;
            if (Helpers.isTrue(!Helpers.isEqual(symbol, null)))
            {
                market = this.market(symbol);
            }
            Object type = null;
            var typeparametersVariable = this.handleMarketTypeAndParams("fetchMyLiquidations", market, parameters);
            type = ((java.util.List<Object>) typeparametersVariable).get(0);
            parameters = ((java.util.List<Object>) typeparametersVariable).get(1);
            Object subType = null;
            var subTypeparametersVariable = this.handleSubTypeAndParams("fetchMyLiquidations", market, parameters, "linear");
            subType = ((java.util.List<Object>) subTypeparametersVariable).get(0);
            parameters = ((java.util.List<Object>) subTypeparametersVariable).get(1);
            Object isPortfolioMargin = null;
            var isPortfolioMarginparametersVariable = this.handleOptionAndParams2(parameters, "fetchMyLiquidations", "papi", "portfolioMargin", false);
            isPortfolioMargin = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(0);
            parameters = ((java.util.List<Object>) isPortfolioMarginparametersVariable).get(1);
            Object request = new java.util.HashMap<String, Object>() {{}};
            if (Helpers.isTrue(!Helpers.isEqual(type, "spot")))
            {
                Helpers.addElementToObject(request, "autoCloseType", "LIQUIDATION");
            }
            if (Helpers.isTrue(!Helpers.isEqual(market, null)))
            {
                Object symbolKey = ((Helpers.isTrue(Helpers.GetValue(market, "spot")))) ? "isolatedSymbol" : "symbol";
                if (!Helpers.isTrue(isPortfolioMargin))
                {
                    Helpers.addElementToObject(request, symbolKey, Helpers.GetValue(market, "id"));
                }
            }
            if (Helpers.isTrue(!Helpers.isEqual(since, null)))
            {
                Helpers.addElementToObject(request, "startTime", since);
            }
            if (Helpers.isTrue(!Helpers.isEqual(limit, null)))
            {
                if (Helpers.isTrue(Helpers.isEqual(type, "spot")))
                {
                    Helpers.addElementToObject(request, "size", limit);
                } else
                {
                    Helpers.addElementToObject(request, "limit", limit);
                }
            }
            var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
            request = ((java.util.List<Object>) requestparametersVariable).get(0);
            parameters = ((java.util.List<Object>) requestparametersVariable).get(1);
            Object response = null;
            if (Helpers.isTrue(Helpers.isEqual(type, "spot")))
            {
                if (Helpers.isTrue(isPortfolioMargin))
                {
                    response = (this.papiGetMarginForceOrders(this.extend(request, parameters))).join();
                } else
                {
                    response = (this.sapiGetMarginForceLiquidationRec(this.extend(request, parameters))).join();
                }
            } else if (Helpers.isTrue(Helpers.isEqual(subType, "linear")))
            {
                if (Helpers.isTrue(isPortfolioMargin))
                {
                    response = (this.papiGetUmForceOrders(this.extend(request, parameters))).join();
                } else
                {
                    response = (this.fapiPrivateGetForceOrders(this.extend(request, parameters))).join();
                }
            } else if (Helpers.isTrue(Helpers.isEqual(subType, "inverse")))
            {
                if (Helpers.isTrue(isPortfolioMargin))
                {
                    response = (this.papiGetCmForceOrders(this.extend(request, parameters))).join();
                } else
                {
                    response = (this.dapiPrivateGetForceOrders(this.extend(request, parameters))).join();
                }
            } else
            {
                throw new NotSupported((String)Helpers.add(Helpers.add(Helpers.add(this.id, " fetchMyLiquidations() does not support "), Helpers.GetValue(market, "type")), " markets")) ;
            }
            //
            // margin
            //
            //     {
            //         "rows": [
            //             {
            //                 "avgPrice": "0.00388359",
            //                 "executedQty": "31.39000000",
            //                 "orderId": 180015097,
            //                 "price": "0.00388110",
            //                 "qty": "31.39000000",
            //                 "side": "SELL",
            //                 "symbol": "BNBBTC",
            //                 "timeInForce": "GTC",
            //                 "isIsolated": true,
            //                 "updatedTime": 1558941374745
            //             }
            //         ],
            //         "total": 1
            //     }
            //
            // linear
            //
            //     [
            //         {
            //             "orderId": 6071832819,
            //             "symbol": "BTCUSDT",
            //             "status": "FILLED",
            //             "clientOrderId": "autoclose-1596107620040000020",
            //             "price": "10871.09",
            //             "avgPrice": "10913.21000",
            //             "origQty": "0.001",
            //             "executedQty": "0.001",
            //             "cumQuote": "10.91321",
            //             "timeInForce": "IOC",
            //             "type": "LIMIT",
            //             "reduceOnly": false,
            //             "closePosition": false,
            //             "side": "SELL",
            //             "positionSide": "BOTH",
            //             "stopPrice": "0",
            //             "workingType": "CONTRACT_PRICE",
            //             "origType": "LIMIT",
            //             "time": 1596107620044,
            //             "updateTime": 1596107620087
            //         },
            //     ]
            //
            // inverse
            //
            //     [
            //         {
            //             "orderId": 165123080,
            //             "symbol": "BTCUSD_200925",
            //             "pair": "BTCUSD",
            //             "status": "FILLED",
            //             "clientOrderId": "autoclose-1596542005017000006",
            //             "price": "11326.9",
            //             "avgPrice": "11326.9",
            //             "origQty": "1",
            //             "executedQty": "1",
            //             "cumBase": "0.00882854",
            //             "timeInForce": "IOC",
            //             "type": "LIMIT",
            //             "reduceOnly": false,
            //             "closePosition": false,
            //             "side": "SELL",
            //             "positionSide": "BOTH",
            //             "stopPrice": "0",
            //             "workingType": "CONTRACT_PRICE",
            //             "priceProtect": false,
            //             "origType": "LIMIT",
            //             "time": 1596542005019,
            //             "updateTime": 1596542005050
            //         },
            //     ]
            //
            Object liquidations = this.safeList(response, "rows", response);
            return this.parseLiquidations(liquidations, market, since, limit);
        });

    }

    public Object parseLiquidation(Object liquidation, Object... optionalArgs)
    {
        //
        // margin
        //
        //     {
        //         "avgPrice": "0.00388359",
        //         "executedQty": "31.39000000",
        //         "orderId": 180015097,
        //         "price": "0.00388110",
        //         "qty": "31.39000000",
        //         "side": "SELL",
        //         "symbol": "BNBBTC",
        //         "timeInForce": "GTC",
        //         "isIsolated": true,
        //         "updatedTime": 1558941374745
        //     }
        //
        // linear
        //
        //     {
        //         "orderId": 6071832819,
        //         "symbol": "BTCUSDT",
        //         "status": "FILLED",
        //         "clientOrderId": "autoclose-1596107620040000020",
        //         "price": "10871.09",
        //         "avgPrice": "10913.21000",
        //         "origQty": "0.001",
        //         "executedQty": "0.002",
        //         "cumQuote": "10.91321",
        //         "timeInForce": "IOC",
        //         "type": "LIMIT",
        //         "reduceOnly": false,
        //         "closePosition": false,
        //         "side": "SELL",
        //         "positionSide": "BOTH",
        //         "stopPrice": "0",
        //         "workingType": "CONTRACT_PRICE",
        //         "origType": "LIMIT",
        //         "time": 1596107620044,
        //         "updateTime": 1596107620087
        //     }
        //
        // inverse
        //
        //     {
        //         "orderId": 165123080,
        //         "symbol": "BTCUSD_200925",
        //         "pair": "BTCUSD",
        //         "status": "FILLED",
        //         "clientOrderId": "autoclose-1596542005017000006",
        //         "price": "11326.9",
        //         "avgPrice": "11326.9",
        //         "origQty": "1",
        //         "executedQty": "1",
        //         "cumBase": "0.00882854",
        //         "timeInForce": "IOC",
        //         "type": "LIMIT",
        //         "reduceOnly": false,
        //         "closePosition": false,
        //         "side": "SELL",
        //         "positionSide": "BOTH",
        //         "stopPrice": "0",
        //         "workingType": "CONTRACT_PRICE",
        //         "priceProtect": false,
        //         "origType": "LIMIT",
        //         "time": 1596542005019,
        //         "updateTime": 1596542005050
        //     }
        //
        Object market = Helpers.getArg(optionalArgs, 0, null);
        Object marketId = this.safeString(liquidation, "symbol");
        Object timestamp = this.safeInteger2(liquidation, "updatedTime", "updateTime");
        return this.safeLiquidation(new java.util.HashMap<String, Object>() {{
            put( "info", liquidation );
            put( "symbol", Binance.this.safeSymbol(marketId, market) );
            put( "contracts", Binance.this.safeNumber(liquidation, "executedQty") );
            put( "contractSize", Binance.this.safeNumber(market, "contractSize") );
            put( "price", Binance.this.safeNumber(liquidation, "avgPrice") );
            put( "side", Binance.this.safeStringLower(liquidation, "side") );
            put( "baseValue", Binance.this.safeNumber(liquidation, "cumBase") );
            put( "quoteValue", Binance.this.safeNumber(liquidation, "cumQuote") );
            put( "timestamp", timestamp );
            put( "datetime", Binance.this.iso8601(timestamp) );
        }});
    }

    /**
     * @method
     * @name binance#fetchGreeks
     * @description fetches an option contracts greeks, financial metrics used to measure the factors that affect the price of an options contract
     * @see https://developers.binance.com/docs/derivatives/option/market-data/Option-Mark-Price
     * @param {string} symbol unified symbol of the market to fetch greeks for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [greeks structure]{@link https://docs.ccxt.com/#/?id=greeks-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchGreeks(Object symbol, Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object parameters = Helpers.getArg(optionalArgs, 0, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object market = this.market(symbol);
            Object request = new java.util.HashMap<String, Object>() {{
                put( "symbol", Helpers.GetValue(market, "id") );
            }};
            Object response = (this.eapiPublicGetMark(this.extend(request, parameters))).join();
            //
            //     [
            //         {
            //             "symbol": "BTC-231229-40000-C",
            //             "markPrice": "2012",
            //             "bidIV": "0.60236275",
            //             "askIV": "0.62267244",
            //             "markIV": "0.6125176",
            //             "delta": "0.39111646",
            //             "theta": "-32.13948531",
            //             "gamma": "0.00004656",
            //             "vega": "51.70062218",
            //             "highPriceLimit": "6474",
            //             "lowPriceLimit": "5"
            //         }
            //     ]
            //
            return this.parseGreeks(Helpers.GetValue(response, 0), market);
        });

    }

    /**
     * @method
     * @name binance#fetchAllGreeks
     * @description fetches all option contracts greeks, financial metrics used to measure the factors that affect the price of an options contract
     * @see https://developers.binance.com/docs/derivatives/option/market-data/Option-Mark-Price
     * @param {string[]} [symbols] unified symbols of the markets to fetch greeks for, all markets are returned if not assigned
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [greeks structure]{@link https://docs.ccxt.com/#/?id=greeks-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchAllGreeks(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object symbols = Helpers.getArg(optionalArgs, 0, null);
            Object parameters = Helpers.getArg(optionalArgs, 1, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            symbols = this.marketSymbols(symbols, null, true, true, true);
            Object request = new java.util.HashMap<String, Object>() {{}};
            Object market = null;
            if (Helpers.isTrue(!Helpers.isEqual(symbols, null)))
            {
                Object symbolsLength = Helpers.getArrayLength(symbols);
                if (Helpers.isTrue(Helpers.isEqual(symbolsLength, 1)))
                {
                    market = this.market(Helpers.GetValue(symbols, 0));
                    Helpers.addElementToObject(request, "symbol", Helpers.GetValue(market, "id"));
                }
            }
            Object response = (this.eapiPublicGetMark(this.extend(request, parameters))).join();
            //
            //     [
            //         {
            //             "symbol": "BTC-231229-40000-C",
            //             "markPrice": "2012",
            //             "bidIV": "0.60236275",
            //             "askIV": "0.62267244",
            //             "markIV": "0.6125176",
            //             "delta": "0.39111646",
            //             "theta": "-32.13948531",
            //             "gamma": "0.00004656",
            //             "vega": "51.70062218",
            //             "highPriceLimit": "6474",
            //             "lowPriceLimit": "5"
            //         }
            //     ]
            //
            return this.parseAllGreeks(response, symbols);
        });

    }

    public Object parseGreeks(Object greeks, Object... optionalArgs)
    {
        //
        //     {
        //         "symbol": "BTC-231229-40000-C",
        //         "markPrice": "2012",
        //         "bidIV": "0.60236275",
        //         "askIV": "0.62267244",
        //         "markIV": "0.6125176",
        //         "delta": "0.39111646",
        //         "theta": "-32.13948531",
        //         "gamma": "0.00004656",
        //         "vega": "51.70062218",
        //         "highPriceLimit": "6474",
        //         "lowPriceLimit": "5"
        //     }
        //
        Object market = Helpers.getArg(optionalArgs, 0, null);
        Object marketId = this.safeString(greeks, "symbol");
        Object symbol = this.safeSymbol(marketId, market);
        return new java.util.HashMap<String, Object>() {{
            put( "symbol", symbol );
            put( "timestamp", null );
            put( "datetime", null );
            put( "delta", Binance.this.safeNumber(greeks, "delta") );
            put( "gamma", Binance.this.safeNumber(greeks, "gamma") );
            put( "theta", Binance.this.safeNumber(greeks, "theta") );
            put( "vega", Binance.this.safeNumber(greeks, "vega") );
            put( "rho", null );
            put( "bidSize", null );
            put( "askSize", null );
            put( "bidImpliedVolatility", Binance.this.safeNumber(greeks, "bidIV") );
            put( "askImpliedVolatility", Binance.this.safeNumber(greeks, "askIV") );
            put( "markImpliedVolatility", Binance.this.safeNumber(greeks, "markIV") );
            put( "bidPrice", null );
            put( "askPrice", null );
            put( "markPrice", Binance.this.safeNumber(greeks, "markPrice") );
            put( "lastPrice", null );
            put( "underlyingPrice", null );
            put( "info", greeks );
        }};
    }

    public java.util.concurrent.CompletableFuture<Object> fetchTradingLimits(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            // this method should not be called directly, use loadTradingLimits () instead
            Object symbols = Helpers.getArg(optionalArgs, 0, null);
            Object parameters = Helpers.getArg(optionalArgs, 1, new java.util.HashMap<String, Object>() {{}});
            Object markets = (this.fetchMarkets()).join();
            Object tradingLimits = new java.util.HashMap<String, Object>() {{}};
            for (var i = 0; Helpers.isLessThan(i, Helpers.getArrayLength(markets)); i++)
            {
                Object market = Helpers.GetValue(markets, i);
                Object symbol = Helpers.GetValue(market, "symbol");
                if (Helpers.isTrue(Helpers.isTrue((Helpers.isEqual(symbols, null))) || Helpers.isTrue((this.inArray(symbol, symbols)))))
                {
                    Helpers.addElementToObject(tradingLimits, symbol, Helpers.GetValue(Helpers.GetValue(market, "limits"), "amount"));
                }
            }
            return tradingLimits;
        });

    }

    /**
     * @method
     * @name binance#fetchPositionMode
     * @description fetchs the position mode, hedged or one way, hedged for binance is set identically for all linear markets or all inverse markets
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/account/rest-api/Get-Current-Position-Mode
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/account/rest-api/Get-Current-Position-Mode
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.subType] "linear" or "inverse"
     * @returns {object} an object detailing whether the market is in hedged or one-way mode
     */
    public java.util.concurrent.CompletableFuture<Object> fetchPositionMode(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object symbol = Helpers.getArg(optionalArgs, 0, null);
            Object parameters = Helpers.getArg(optionalArgs, 1, new java.util.HashMap<String, Object>() {{}});
            Object market = null;
            if (Helpers.isTrue(!Helpers.isEqual(symbol, null)))
            {
                market = this.market(symbol);
            }
            Object subType = null;
            var subTypeparametersVariable = this.handleSubTypeAndParams("fetchPositionMode", market, parameters);
            subType = ((java.util.List<Object>) subTypeparametersVariable).get(0);
            parameters = ((java.util.List<Object>) subTypeparametersVariable).get(1);
            Object response = null;
            if (Helpers.isTrue(Helpers.isEqual(subType, "linear")))
            {
                response = (this.fapiPrivateGetPositionSideDual(parameters)).join();
            } else if (Helpers.isTrue(Helpers.isEqual(subType, "inverse")))
            {
                response = (this.dapiPrivateGetPositionSideDual(parameters)).join();
            } else
            {
                throw new BadRequest((String)Helpers.add(this.id, " fetchPositionMode requires either a symbol argument or params[\"subType\"]")) ;
            }
            //
            //    {
            //        dualSidePosition: false
            //    }
            //
            Object dualSidePosition = this.safeBool(response, "dualSidePosition");
            final Object finalResponse = response;
            return new java.util.HashMap<String, Object>() {{
                put( "info", finalResponse );
                put( "hedged", dualSidePosition );
            }};
        });

    }

    /**
     * @method
     * @name binance#fetchMarginModes
     * @description fetches margin modes ("isolated" or "cross") that the market for the symbol in in, with symbol=undefined all markets for a subType (linear/inverse) are returned
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/account/rest-api/Account-Information
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/account/rest-api/Account-Information-V2
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/account/rest-api/Symbol-Config
     * @param {string[]} symbols unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.subType] "linear" or "inverse"
     * @returns {object} a list of [margin mode structures]{@link https://docs.ccxt.com/#/?id=margin-mode-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchMarginModes(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object symbols = Helpers.getArg(optionalArgs, 0, null);
            Object parameters = Helpers.getArg(optionalArgs, 1, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object market = null;
            if (Helpers.isTrue(!Helpers.isEqual(symbols, null)))
            {
                symbols = this.marketSymbols(symbols);
                market = this.market(Helpers.GetValue(symbols, 0));
            }
            Object subType = null;
            var subTypeparametersVariable = this.handleSubTypeAndParams("fetchMarginMode", market, parameters);
            subType = ((java.util.List<Object>) subTypeparametersVariable).get(0);
            parameters = ((java.util.List<Object>) subTypeparametersVariable).get(1);
            Object response = null;
            if (Helpers.isTrue(Helpers.isEqual(subType, "linear")))
            {
                response = (this.fapiPrivateGetSymbolConfig(parameters)).join();
            } else if (Helpers.isTrue(Helpers.isEqual(subType, "inverse")))
            {
                response = (this.dapiPrivateGetAccount(parameters)).join();
            } else
            {
                throw new BadRequest((String)Helpers.add(this.id, " fetchMarginModes () supports linear and inverse subTypes only")) ;
            }
            Object assets = this.safeList(response, "positions", new java.util.ArrayList<Object>(java.util.Arrays.asList()));
            if (Helpers.isTrue(((response instanceof java.util.List) || (response.getClass().isArray()))))
            {
                assets = response;
            }
            return this.parseMarginModes(assets, symbols, "symbol", "swap");
        });

    }

    /**
     * @method
     * @name binance#fetchMarginMode
     * @description fetches the margin mode of a specific symbol
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/account/rest-api/Symbol-Config
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/account/rest-api/Account-Information
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.subType] "linear" or "inverse"
     * @returns {object} a [margin mode structure]{@link https://docs.ccxt.com/#/?id=margin-mode-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchMarginMode(Object symbol, Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object parameters = Helpers.getArg(optionalArgs, 0, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object market = this.market(symbol);
            Object subType = null;
            var subTypeparametersVariable = this.handleSubTypeAndParams("fetchMarginMode", market, parameters);
            subType = ((java.util.List<Object>) subTypeparametersVariable).get(0);
            parameters = ((java.util.List<Object>) subTypeparametersVariable).get(1);
            Object response = null;
            if (Helpers.isTrue(Helpers.isEqual(subType, "linear")))
            {
                Object request = new java.util.HashMap<String, Object>() {{
                    put( "symbol", Helpers.GetValue(market, "id") );
                }};
                response = (this.fapiPrivateGetSymbolConfig(this.extend(request, parameters))).join();
            } else if (Helpers.isTrue(Helpers.isEqual(subType, "inverse")))
            {
                Object fetchMarginModesResponse = (this.fetchMarginModes(new java.util.ArrayList<Object>(java.util.Arrays.asList(symbol)), parameters)).join();
                return Helpers.GetValue(fetchMarginModesResponse, symbol);
            } else
            {
                throw new BadRequest((String)Helpers.add(this.id, " fetchMarginMode () supports linear and inverse subTypes only")) ;
            }
            return this.parseMarginMode(Helpers.GetValue(response, 0), market);
        });

    }

    public Object parseMarginMode(Object marginMode, Object... optionalArgs)
    {
        Object market = Helpers.getArg(optionalArgs, 0, null);
        Object marketId = this.safeString(marginMode, "symbol");
        market = this.safeMarket(marketId, market);
        Object marginModeRaw = this.safeBool(marginMode, "isolated");
        Object reMarginMode = null;
        if (Helpers.isTrue(!Helpers.isEqual(marginModeRaw, null)))
        {
            reMarginMode = ((Helpers.isTrue(marginModeRaw))) ? "isolated" : "cross";
        }
        Object marginTypeRaw = this.safeStringLower(marginMode, "marginType");
        if (Helpers.isTrue(!Helpers.isEqual(marginTypeRaw, null)))
        {
            reMarginMode = ((Helpers.isTrue((Helpers.isEqual(marginTypeRaw, "crossed"))))) ? "cross" : "isolated";
        }
        final Object finalMarket = market;
        final Object finalReMarginMode = reMarginMode;
        return new java.util.HashMap<String, Object>() {{
            put( "info", marginMode );
            put( "symbol", Helpers.GetValue(finalMarket, "symbol") );
            put( "marginMode", finalReMarginMode );
        }};
    }

    /**
     * @method
     * @name binance#fetchOption
     * @description fetches option data that is commonly found in an option chain
     * @see https://developers.binance.com/docs/derivatives/option/market-data/24hr-Ticker-Price-Change-Statistics
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [option chain structure]{@link https://docs.ccxt.com/#/?id=option-chain-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchOption(Object symbol, Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object parameters = Helpers.getArg(optionalArgs, 0, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object market = this.market(symbol);
            Object request = new java.util.HashMap<String, Object>() {{
                put( "symbol", Helpers.GetValue(market, "id") );
            }};
            Object response = (this.eapiPublicGetTicker(this.extend(request, parameters))).join();
            //
            //     [
            //         {
            //             "symbol": "BTC-241227-80000-C",
            //             "priceChange": "0",
            //             "priceChangePercent": "0",
            //             "lastPrice": "2750",
            //             "lastQty": "0",
            //             "open": "2750",
            //             "high": "2750",
            //             "low": "2750",
            //             "volume": "0",
            //             "amount": "0",
            //             "bidPrice": "4880",
            //             "askPrice": "0",
            //             "openTime": 0,
            //             "closeTime": 0,
            //             "firstTradeId": 0,
            //             "tradeCount": 0,
            //             "strikePrice": "80000",
            //             "exercisePrice": "63944.09893617"
            //         }
            //     ]
            //
            Object chain = this.safeDict(response, 0, new java.util.HashMap<String, Object>() {{}});
            return this.parseOption(chain, null, market);
        });

    }

    public Object parseOption(Object chain, Object... optionalArgs)
    {
        //
        //     {
        //         "symbol": "BTC-241227-80000-C",
        //         "priceChange": "0",
        //         "priceChangePercent": "0",
        //         "lastPrice": "2750",
        //         "lastQty": "0",
        //         "open": "2750",
        //         "high": "2750",
        //         "low": "2750",
        //         "volume": "0",
        //         "amount": "0",
        //         "bidPrice": "4880",
        //         "askPrice": "0",
        //         "openTime": 0,
        //         "closeTime": 0,
        //         "firstTradeId": 0,
        //         "tradeCount": 0,
        //         "strikePrice": "80000",
        //         "exercisePrice": "63944.09893617"
        //     }
        //
        Object currency = Helpers.getArg(optionalArgs, 0, null);
        Object market = Helpers.getArg(optionalArgs, 1, null);
        Object marketId = this.safeString(chain, "symbol");
        market = this.safeMarket(marketId, market);
        final Object finalMarket = market;
        return new java.util.HashMap<String, Object>() {{
            put( "info", chain );
            put( "currency", null );
            put( "symbol", Helpers.GetValue(finalMarket, "symbol") );
            put( "timestamp", null );
            put( "datetime", null );
            put( "impliedVolatility", null );
            put( "openInterest", null );
            put( "bidPrice", Binance.this.safeNumber(chain, "bidPrice") );
            put( "askPrice", Binance.this.safeNumber(chain, "askPrice") );
            put( "midPrice", null );
            put( "markPrice", null );
            put( "lastPrice", Binance.this.safeNumber(chain, "lastPrice") );
            put( "underlyingPrice", Binance.this.safeNumber(chain, "exercisePrice") );
            put( "change", Binance.this.safeNumber(chain, "priceChange") );
            put( "percentage", Binance.this.safeNumber(chain, "priceChangePercent") );
            put( "baseVolume", Binance.this.safeNumber(chain, "volume") );
            put( "quoteVolume", null );
        }};
    }

    /**
     * @method
     * @name binance#fetchMarginAdjustmentHistory
     * @description fetches the history of margin added or reduced from contract isolated positions
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/trade/rest-api/Get-Position-Margin-Change-History
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/trade/rest-api/Get-Position-Margin-Change-History
     * @param {string} symbol unified market symbol
     * @param {string} [type] "add" or "reduce"
     * @param {int} [since] timestamp in ms of the earliest change to fetch
     * @param {int} [limit] the maximum amount of changes to fetch
     * @param {object} params extra parameters specific to the exchange api endpoint
     * @param {int} [params.until] timestamp in ms of the latest change to fetch
     * @returns {object[]} a list of [margin structures]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchMarginAdjustmentHistory(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object symbol = Helpers.getArg(optionalArgs, 0, null);
            Object type = Helpers.getArg(optionalArgs, 1, null);
            Object since = Helpers.getArg(optionalArgs, 2, null);
            Object limit = Helpers.getArg(optionalArgs, 3, null);
            Object parameters = Helpers.getArg(optionalArgs, 4, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            if (Helpers.isTrue(Helpers.isEqual(symbol, null)))
            {
                throw new ArgumentsRequired((String)Helpers.add(this.id, " fetchMarginAdjustmentHistory () requires a symbol argument")) ;
            }
            Object market = this.market(symbol);
            Object until = this.safeInteger(parameters, "until");
            parameters = this.omit(parameters, "until");
            Object request = new java.util.HashMap<String, Object>() {{
                put( "symbol", Helpers.GetValue(market, "id") );
            }};
            if (Helpers.isTrue(!Helpers.isEqual(type, null)))
            {
                Helpers.addElementToObject(request, "type", ((Helpers.isTrue((Helpers.isEqual(type, "add"))))) ? 1 : 2);
            }
            if (Helpers.isTrue(!Helpers.isEqual(since, null)))
            {
                Helpers.addElementToObject(request, "startTime", since);
            }
            if (Helpers.isTrue(!Helpers.isEqual(limit, null)))
            {
                Helpers.addElementToObject(request, "limit", limit);
            }
            if (Helpers.isTrue(!Helpers.isEqual(until, null)))
            {
                Helpers.addElementToObject(request, "endTime", until);
            }
            Object response = null;
            if (Helpers.isTrue(Helpers.GetValue(market, "linear")))
            {
                response = (this.fapiPrivateGetPositionMarginHistory(this.extend(request, parameters))).join();
            } else if (Helpers.isTrue(Helpers.GetValue(market, "inverse")))
            {
                response = (this.dapiPrivateGetPositionMarginHistory(this.extend(request, parameters))).join();
            } else
            {
                throw new BadRequest((String)Helpers.add(Helpers.add(this.id, " fetchMarginAdjustmentHistory () is not supported for markets of type "), Helpers.GetValue(market, "type"))) ;
            }
            //
            //    [
            //        {
            //            symbol: "XRPUSDT",
            //            type: "1",
            //            deltaType: "TRADE",
            //            amount: "2.57148240",
            //            asset: "USDT",
            //            time: "1711046271555",
            //            positionSide: "BOTH",
            //            clientTranId: ""
            //        }
            //        ...
            //    ]
            //
            Object modifications = this.parseMarginModifications(response);
            return this.filterBySymbolSinceLimit(modifications, symbol, since, limit);
        });

    }

    /**
     * @method
     * @name binance#fetchConvertCurrencies
     * @description fetches all available currencies that can be converted
     * @see https://developers.binance.com/docs/convert/market-data/Query-order-quantity-precision-per-asset
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an associative dictionary of currencies
     */
    public java.util.concurrent.CompletableFuture<Object> fetchConvertCurrencies(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object parameters = Helpers.getArg(optionalArgs, 0, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object response = (this.sapiGetConvertAssetInfo(parameters)).join();
            //
            //     [
            //         {
            //             "asset": "BTC",
            //             "fraction": 8
            //         },
            //     ]
            //
            Object result = new java.util.HashMap<String, Object>() {{}};
            for (var i = 0; Helpers.isLessThan(i, Helpers.getArrayLength(response)); i++)
            {
                Object entry = Helpers.GetValue(response, i);
                Object id = this.safeString(entry, "asset");
                Object code = this.safeCurrencyCode(id);
                Helpers.addElementToObject(result, code, new java.util.HashMap<String, Object>() {{
        put( "info", entry );
        put( "id", id );
        put( "code", code );
        put( "networks", null );
        put( "type", null );
        put( "name", null );
        put( "active", null );
        put( "deposit", null );
        put( "withdraw", null );
        put( "fee", null );
        put( "precision", Binance.this.parseNumber(Binance.this.parsePrecision(Binance.this.safeString(entry, "fraction"))) );
        put( "limits", new java.util.HashMap<String, Object>() {{
            put( "amount", new java.util.HashMap<String, Object>() {{
                put( "min", null );
                put( "max", null );
            }} );
            put( "withdraw", new java.util.HashMap<String, Object>() {{
                put( "min", null );
                put( "max", null );
            }} );
            put( "deposit", new java.util.HashMap<String, Object>() {{
                put( "min", null );
                put( "max", null );
            }} );
        }} );
        put( "created", null );
    }});
            }
            return result;
        });

    }

    /**
     * @method
     * @name binance#fetchConvertQuote
     * @description fetch a quote for converting from one currency to another
     * @see https://developers.binance.com/docs/convert/trade/Send-quote-request
     * @param {string} fromCode the currency that you want to sell and convert from
     * @param {string} toCode the currency that you want to buy and convert into
     * @param {float} amount how much you want to trade in units of the from currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.walletType] either 'SPOT' or 'FUNDING', the default is 'SPOT'
     * @returns {object} a [conversion structure]{@link https://docs.ccxt.com/#/?id=conversion-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchConvertQuote(Object fromCode, Object toCode, Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object amount = Helpers.getArg(optionalArgs, 0, null);
            Object parameters = Helpers.getArg(optionalArgs, 1, new java.util.HashMap<String, Object>() {{}});
            if (Helpers.isTrue(Helpers.isEqual(amount, null)))
            {
                throw new ArgumentsRequired((String)Helpers.add(this.id, " fetchConvertQuote() requires an amount argument")) ;
            }
            (this.loadMarkets()).join();
            final Object finalAmount = amount;
            Object request = new java.util.HashMap<String, Object>() {{
                put( "fromAsset", fromCode );
                put( "toAsset", toCode );
                put( "fromAmount", finalAmount );
            }};
            Object response = (this.sapiPostConvertGetQuote(this.extend(request, parameters))).join();
            //
            //     {
            //         "quoteId":"12415572564",
            //         "ratio":"38163.7",
            //         "inverseRatio":"0.0000262",
            //         "validTimestamp":1623319461670,
            //         "toAmount":"3816.37",
            //         "fromAmount":"0.1"
            //     }
            //
            Object fromCurrency = this.currency(fromCode);
            Object toCurrency = this.currency(toCode);
            return this.parseConversion(response, fromCurrency, toCurrency);
        });

    }

    /**
     * @method
     * @name binance#createConvertTrade
     * @description convert from one currency to another
     * @see https://developers.binance.com/docs/convert/trade/Accept-Quote
     * @param {string} id the id of the trade that you want to make
     * @param {string} fromCode the currency that you want to sell and convert from
     * @param {string} toCode the currency that you want to buy and convert into
     * @param {float} [amount] how much you want to trade in units of the from currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [conversion structure]{@link https://docs.ccxt.com/#/?id=conversion-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> createConvertTrade(Object id, Object fromCode2, Object toCode2, Object... optionalArgs)
    {
        final Object fromCode3 = fromCode2;
        final Object toCode3 = toCode2;
        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {
            Object fromCode = fromCode3;
            Object toCode = toCode3;
            Object amount = Helpers.getArg(optionalArgs, 0, null);
            Object parameters = Helpers.getArg(optionalArgs, 1, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object request = new java.util.HashMap<String, Object>() {{}};
            Object response = null;
            if (Helpers.isTrue(Helpers.isTrue((Helpers.isEqual(fromCode, "BUSD"))) || Helpers.isTrue((Helpers.isEqual(toCode, "BUSD")))))
            {
                if (Helpers.isTrue(Helpers.isEqual(amount, null)))
                {
                    throw new ArgumentsRequired((String)Helpers.add(this.id, " createConvertTrade() requires an amount argument")) ;
                }
                Helpers.addElementToObject(request, "clientTranId", id);
                Helpers.addElementToObject(request, "asset", fromCode);
                Helpers.addElementToObject(request, "targetAsset", toCode);
                Helpers.addElementToObject(request, "amount", amount);
                response = (this.sapiPostAssetConvertTransfer(this.extend(request, parameters))).join();
            } else
            {
                Helpers.addElementToObject(request, "quoteId", id);
                response = (this.sapiPostConvertAcceptQuote(this.extend(request, parameters))).join();
            }
            Object fromCurrency = this.currency(fromCode);
            Object toCurrency = this.currency(toCode);
            return this.parseConversion(response, fromCurrency, toCurrency);
        });

    }

    /**
     * @method
     * @name binance#fetchConvertTrade
     * @description fetch the data for a conversion trade
     * @see https://developers.binance.com/docs/convert/trade/Order-Status
     * @param {string} id the id of the trade that you want to fetch
     * @param {string} [code] the unified currency code of the conversion trade
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [conversion structure]{@link https://docs.ccxt.com/#/?id=conversion-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchConvertTrade(Object id, Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object code = Helpers.getArg(optionalArgs, 0, null);
            Object parameters = Helpers.getArg(optionalArgs, 1, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object request = new java.util.HashMap<String, Object>() {{}};
            Object response = null;
            if (Helpers.isTrue(Helpers.isEqual(code, "BUSD")))
            {
                Object msInDay = 86400000;
                Object now = this.milliseconds();
                if (Helpers.isTrue(!Helpers.isEqual(code, null)))
                {
                    Object currency = this.currency(code);
                    Helpers.addElementToObject(request, "asset", Helpers.GetValue(currency, "id"));
                }
                Helpers.addElementToObject(request, "tranId", id);
                Helpers.addElementToObject(request, "startTime", Helpers.subtract(now, msInDay));
                Helpers.addElementToObject(request, "endTime", now);
                response = (this.sapiGetAssetConvertTransferQueryByPage(this.extend(request, parameters))).join();
            } else
            {
                Helpers.addElementToObject(request, "orderId", id);
                response = (this.sapiGetConvertOrderStatus(this.extend(request, parameters))).join();
            }
            Object data = response;
            if (Helpers.isTrue(Helpers.isEqual(code, "BUSD")))
            {
                Object rows = this.safeList(response, "rows", new java.util.ArrayList<Object>(java.util.Arrays.asList()));
                
                data = this.safeDict(rows, 0, new java.util.HashMap<String, Object>() {{}});
            }
            Object fromCurrencyId = this.safeString2(data, "deductedAsset", "fromAsset");
            Object toCurrencyId = this.safeString2(data, "targetAsset", "toAsset");
            Object fromCurrency = null;
            Object toCurrency = null;
            if (Helpers.isTrue(!Helpers.isEqual(fromCurrencyId, null)))
            {
                fromCurrency = this.currency(fromCurrencyId);
            }
            if (Helpers.isTrue(!Helpers.isEqual(toCurrencyId, null)))
            {
                toCurrency = this.currency(toCurrencyId);
            }
            return this.parseConversion(data, fromCurrency, toCurrency);
        });

    }

    /**
     * @method
     * @name binance#fetchConvertTradeHistory
     * @description fetch the users history of conversion trades
     * @see https://developers.binance.com/docs/convert/trade/Get-Convert-Trade-History
     * @param {string} [code] the unified currency code
     * @param {int} [since] the earliest time in ms to fetch conversions for
     * @param {int} [limit] the maximum number of conversion structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest conversion to fetch
     * @returns {object[]} a list of [conversion structures]{@link https://docs.ccxt.com/#/?id=conversion-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchConvertTradeHistory(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object code = Helpers.getArg(optionalArgs, 0, null);
            Object since = Helpers.getArg(optionalArgs, 1, null);
            Object limit = Helpers.getArg(optionalArgs, 2, null);
            Object parameters = Helpers.getArg(optionalArgs, 3, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object request = new java.util.HashMap<String, Object>() {{}};
            Object msInThirtyDays = 2592000000L;
            Object now = this.milliseconds();
            if (Helpers.isTrue(!Helpers.isEqual(since, null)))
            {
                Helpers.addElementToObject(request, "startTime", since);
            } else
            {
                Helpers.addElementToObject(request, "startTime", Helpers.subtract(now, msInThirtyDays));
            }
            Object endTime = this.safeInteger2(parameters, "endTime", "until");
            if (Helpers.isTrue(!Helpers.isEqual(endTime, null)))
            {
                Helpers.addElementToObject(request, "endTime", endTime);
            } else
            {
                Helpers.addElementToObject(request, "endTime", now);
            }
            parameters = this.omit(parameters, "until");
            Object response = null;
            Object responseQuery = null;
            Object fromCurrencyKey = null;
            Object toCurrencyKey = null;
            if (Helpers.isTrue(Helpers.isEqual(code, "BUSD")))
            {
                Object currency = this.currency(code);
                Helpers.addElementToObject(request, "asset", Helpers.GetValue(currency, "id"));
                if (Helpers.isTrue(!Helpers.isEqual(limit, null)))
                {
                    Helpers.addElementToObject(request, "size", limit);
                }
                fromCurrencyKey = "deductedAsset";
                toCurrencyKey = "targetAsset";
                responseQuery = "rows";
                response = (this.sapiGetAssetConvertTransferQueryByPage(this.extend(request, parameters))).join();
            } else
            {
                if (Helpers.isTrue(Helpers.isGreaterThan((Helpers.subtract(Helpers.GetValue(request, "endTime"), Helpers.GetValue(request, "startTime"))), msInThirtyDays)))
                {
                    throw new BadRequest((String)Helpers.add(this.id, " fetchConvertTradeHistory () the max interval between startTime and endTime is 30 days.")) ;
                }
                if (Helpers.isTrue(!Helpers.isEqual(limit, null)))
                {
                    Helpers.addElementToObject(request, "limit", limit);
                }
                fromCurrencyKey = "fromAsset";
                toCurrencyKey = "toAsset";
                responseQuery = "list";
                response = (this.sapiGetConvertTradeFlow(this.extend(request, parameters))).join();
            }
            Object rows = this.safeList(response, responseQuery, new java.util.ArrayList<Object>(java.util.Arrays.asList()));
            return this.parseConversions(rows, code, fromCurrencyKey, toCurrencyKey, since, limit);
        });

    }

    public Object parseConversion(Object conversion, Object... optionalArgs)
    {
        //
        // fetchConvertQuote
        //
        //     {
        //         "quoteId":"12415572564",
        //         "ratio":"38163.7",
        //         "inverseRatio":"0.0000262",
        //         "validTimestamp":1623319461670,
        //         "toAmount":"3816.37",
        //         "fromAmount":"0.1"
        //     }
        //
        // createConvertTrade
        //
        //     {
        //         "orderId":"933256278426274426",
        //         "createTime":1623381330472,
        //         "orderStatus":"PROCESS"
        //     }
        //
        // createConvertTrade BUSD
        //
        //     {
        //         "tranId": 118263407119,
        //         "status": "S"
        //     }
        //
        // fetchConvertTrade, fetchConvertTradeHistory BUSD
        //
        //     {
        //         "tranId": 118263615991,
        //         "type": 244,
        //         "time": 1664442078000,
        //         "deductedAsset": "BUSD",
        //         "deductedAmount": "1",
        //         "targetAsset": "USDC",
        //         "targetAmount": "1",
        //         "status": "S",
        //         "accountType": "MAIN"
        //     }
        //
        // fetchConvertTrade
        //
        //     {
        //         "orderId":933256278426274426,
        //         "orderStatus":"SUCCESS",
        //         "fromAsset":"BTC",
        //         "fromAmount":"0.00054414",
        //         "toAsset":"USDT",
        //         "toAmount":"20",
        //         "ratio":"36755",
        //         "inverseRatio":"0.00002721",
        //         "createTime":1623381330472
        //     }
        //
        // fetchConvertTradeHistory
        //
        //     {
        //         "quoteId": "f3b91c525b2644c7bc1e1cd31b6e1aa6",
        //         "orderId": 940708407462087195,
        //         "orderStatus": "SUCCESS",
        //         "fromAsset": "USDT",
        //         "fromAmount": "20",
        //         "toAsset": "BNB",
        //         "toAmount": "0.06154036",
        //         "ratio": "0.00307702",
        //         "inverseRatio": "324.99",
        //         "createTime": 1624248872184
        //     }
        //
        Object fromCurrency = Helpers.getArg(optionalArgs, 0, null);
        Object toCurrency = Helpers.getArg(optionalArgs, 1, null);
        Object timestamp = this.safeIntegerN(conversion, new java.util.ArrayList<Object>(java.util.Arrays.asList("time", "validTimestamp", "createTime")));
        Object fromCur = this.safeString2(conversion, "deductedAsset", "fromAsset");
        Object fromCode = this.safeCurrencyCode(fromCur, fromCurrency);
        Object to = this.safeString2(conversion, "targetAsset", "toAsset");
        Object toCode = this.safeCurrencyCode(to, toCurrency);
        return new java.util.HashMap<String, Object>() {{
            put( "info", conversion );
            put( "timestamp", timestamp );
            put( "datetime", Binance.this.iso8601(timestamp) );
            put( "id", Binance.this.safeStringN(conversion, new java.util.ArrayList<Object>(java.util.Arrays.asList("tranId", "orderId", "quoteId"))) );
            put( "fromCurrency", fromCode );
            put( "fromAmount", Binance.this.safeNumber2(conversion, "deductedAmount", "fromAmount") );
            put( "toCurrency", toCode );
            put( "toAmount", Binance.this.safeNumber2(conversion, "targetAmount", "toAmount") );
            put( "price", null );
            put( "fee", null );
        }};
    }

    /**
     * @method
     * @name binance#fetchFundingIntervals
     * @description fetch the funding rate interval for multiple markets
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Get-Funding-Rate-Info
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/Get-Funding-Info
     * @param {string[]} [symbols] list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.subType] "linear" or "inverse"
     * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchFundingIntervals(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object symbols = Helpers.getArg(optionalArgs, 0, null);
            Object parameters = Helpers.getArg(optionalArgs, 1, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object market = null;
            if (Helpers.isTrue(!Helpers.isEqual(symbols, null)))
            {
                symbols = this.marketSymbols(symbols);
                market = this.market(Helpers.GetValue(symbols, 0));
            }
            Object type = "swap";
            Object subType = null;
            var subTypeparametersVariable = this.handleSubTypeAndParams("fetchFundingIntervals", market, parameters, "linear");
            subType = ((java.util.List<Object>) subTypeparametersVariable).get(0);
            parameters = ((java.util.List<Object>) subTypeparametersVariable).get(1);
            Object response = null;
            if (Helpers.isTrue(this.isLinear(type, subType)))
            {
                response = (this.fapiPublicGetFundingInfo(parameters)).join();
            } else if (Helpers.isTrue(this.isInverse(type, subType)))
            {
                response = (this.dapiPublicGetFundingInfo(parameters)).join();
            } else
            {
                throw new NotSupported((String)Helpers.add(this.id, " fetchFundingIntervals() supports linear and inverse swap contracts only")) ;
            }
            //
            //     [
            //         {
            //             "symbol": "BLZUSDT",
            //             "adjustedFundingRateCap": "0.03000000",
            //             "adjustedFundingRateFloor": "-0.03000000",
            //             "fundingIntervalHours": 4,
            //             "disclaimer": false
            //         },
            //     ]
            //
            return this.parseFundingRates(response, symbols);
        });

    }

    /**
     * @method
     * @name binance#fetchLongShortRatioHistory
     * @description fetches the long short ratio history for a unified market symbol
     * @see https://developers.binance.com/docs/derivatives/usds-margined-futures/market-data/rest-api/Long-Short-Ratio
     * @see https://developers.binance.com/docs/derivatives/coin-margined-futures/market-data/rest-api/Long-Short-Ratio
     * @param {string} symbol unified symbol of the market to fetch the long short ratio for
     * @param {string} [timeframe] the period for the ratio, default is 24 hours
     * @param {int} [since] the earliest time in ms to fetch ratios for
     * @param {int} [limit] the maximum number of long short ratio structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest ratio to fetch
     * @returns {object[]} an array of [long short ratio structures]{@link https://docs.ccxt.com/#/?id=long-short-ratio-structure}
     */
    public java.util.concurrent.CompletableFuture<Object> fetchLongShortRatioHistory(Object... optionalArgs)
    {

        return java.util.concurrent.CompletableFuture.supplyAsync(() -> {

            Object symbol = Helpers.getArg(optionalArgs, 0, null);
            Object timeframe = Helpers.getArg(optionalArgs, 1, null);
            Object since = Helpers.getArg(optionalArgs, 2, null);
            Object limit = Helpers.getArg(optionalArgs, 3, null);
            Object parameters = Helpers.getArg(optionalArgs, 4, new java.util.HashMap<String, Object>() {{}});
            (this.loadMarkets()).join();
            Object market = this.market(symbol);
            if (Helpers.isTrue(Helpers.isEqual(timeframe, null)))
            {
                timeframe = "1d";
            }
            final Object finalTimeframe = timeframe;
            Object request = new java.util.HashMap<String, Object>() {{
                put( "period", finalTimeframe );
            }};
            var requestparametersVariable = this.handleUntilOption("endTime", request, parameters);
            request = ((java.util.List<Object>) requestparametersVariable).get(0);
            parameters = ((java.util.List<Object>) requestparametersVariable).get(1);
            if (Helpers.isTrue(!Helpers.isEqual(since, null)))
            {
                Helpers.addElementToObject(request, "startTime", since);
            }
            if (Helpers.isTrue(!Helpers.isEqual(limit, null)))
            {
                Helpers.addElementToObject(request, "limit", limit);
            }
            Object subType = null;
            var subTypeparametersVariable = this.handleSubTypeAndParams("fetchLongShortRatioHistory", market, parameters);
            subType = ((java.util.List<Object>) subTypeparametersVariable).get(0);
            parameters = ((java.util.List<Object>) subTypeparametersVariable).get(1);
            Object response = null;
            if (Helpers.isTrue(Helpers.isEqual(subType, "linear")))
            {
                Helpers.addElementToObject(request, "symbol", Helpers.GetValue(market, "id"));
                response = (this.fapiDataGetGlobalLongShortAccountRatio(this.extend(request, parameters))).join();
            } else if (Helpers.isTrue(Helpers.isEqual(subType, "inverse")))
            {
                Helpers.addElementToObject(request, "pair", Helpers.GetValue(Helpers.GetValue(market, "info"), "pair"));
                response = (this.dapiDataGetGlobalLongShortAccountRatio(this.extend(request, parameters))).join();
            } else
            {
                throw new BadRequest((String)Helpers.add(this.id, " fetchLongShortRatioHistory() supports linear and inverse subTypes only")) ;
            }
            return this.parseLongShortRatioHistory(response, market);
        });

    }

    public Object parseLongShortRatio(Object info, Object... optionalArgs)
    {
        //
        // linear
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "longAccount": "0.4558",
        //         "longShortRatio": "0.8376",
        //         "shortAccount": "0.5442",
        //         "timestamp": 1726790400000
        //     }
        //
        // inverse
        //
        //     {
        //         "longAccount": "0.7262",
        //         "longShortRatio": "2.6523",
        //         "shortAccount": "0.2738",
        //         "pair": "BTCUSD",
        //         "timestamp": 1726790400000
        //     }
        //
        Object market = Helpers.getArg(optionalArgs, 0, null);
        Object marketId = this.safeString(info, "symbol");
        Object timestamp = this.safeIntegerOmitZero(info, "timestamp");
        return new java.util.HashMap<String, Object>() {{
            put( "info", info );
            put( "symbol", Binance.this.safeSymbol(marketId, market, null, "contract") );
            put( "timestamp", timestamp );
            put( "datetime", Binance.this.iso8601(timestamp) );
            put( "timeframe", null );
            put( "longShortRatio", Binance.this.safeNumber(info, "longShortRatio") );
        }};
    }
}
