using ccxt;
namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

partial class bitmart : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "bitmart" },
            { "name", "BitMart" },
            { "countries", new List<object>() {"US", "CN", "HK", "KR"} },
            { "rateLimit", 33.34 },
            { "version", "v2" },
            { "certified", true },
            { "pro", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", true },
                { "swap", null },
                { "future", false },
                { "option", null },
                { "borrowMargin", true },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "cancelOrders", false },
                { "createOrder", true },
                { "createPostOnlyOrder", true },
                { "createStopLimitOrder", false },
                { "createStopMarketOrder", false },
                { "createStopOrder", false },
                { "fetchBalance", true },
                { "fetchBorrowInterest", true },
                { "fetchBorrowRate", true },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchBorrowRates", true },
                { "fetchCanceledOrders", true },
                { "fetchClosedOrders", true },
                { "fetchCurrencies", true },
                { "fetchDeposit", true },
                { "fetchDepositAddress", true },
                { "fetchDepositAddresses", false },
                { "fetchDepositAddressesByNetwork", false },
                { "fetchDeposits", true },
                { "fetchDepositWithdrawFee", true },
                { "fetchDepositWithdrawFees", false },
                { "fetchFundingHistory", null },
                { "fetchMarginMode", false },
                { "fetchMarkets", true },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", false },
                { "fetchOrderTrades", true },
                { "fetchPositionMode", false },
                { "fetchStatus", true },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", true },
                { "fetchTradingFees", false },
                { "fetchTransactionFee", true },
                { "fetchTransactionFees", false },
                { "fetchTransfer", false },
                { "fetchTransfers", false },
                { "fetchWithdrawAddressesByNetwork", false },
                { "fetchWithdrawal", true },
                { "fetchWithdrawals", true },
                { "reduceMargin", false },
                { "repayMargin", true },
                { "setLeverage", false },
                { "setMarginMode", false },
                { "transfer", true },
                { "withdraw", true },
            } },
            { "hostname", "bitmart.com" },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/1294454/129991357-8f47464b-d0f4-41d6-8a82-34122f0d1398.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "rest", "https://api-cloud.{hostname}" },
                } },
                { "www", "https://www.bitmart.com/" },
                { "doc", "https://developer-pro.bitmart.com/" },
                { "referral", new Dictionary<string, object>() {
                    { "url", "http://www.bitmart.com/?r=rQCFLh" },
                    { "discount", 0.3 },
                } },
                { "fees", "https://www.bitmart.com/fee/en" },
            } },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", true },
                { "secret", true },
                { "uid", true },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "system/time", 3 },
                        { "system/service", 3 },
                        { "spot/v1/currencies", 7.5 },
                        { "spot/v1/symbols", 7.5 },
                        { "spot/v1/symbols/details", 5 },
                        { "spot/v1/ticker", 5 },
                        { "spot/v2/ticker", 5 },
                        { "spot/v1/steps", 30 },
                        { "spot/v1/symbols/kline", 5 },
                        { "spot/v1/symbols/book", 5 },
                        { "spot/v1/symbols/trades", 5 },
                        { "contract/v1/tickers", 15 },
                        { "contract/public/details", 5 },
                        { "contract/public/depth", 5 },
                        { "contract/public/open-interest", 30 },
                        { "contract/public/funding-rate", 30 },
                        { "contract/public/kline", 5 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "account/sub-account/v1/transfer-list", 7.5 },
                        { "account/sub-account/v1/transfer-history", 7.5 },
                        { "account/sub-account/main/v1/wallet", 5 },
                        { "account/sub-account/main/v1/subaccount-list", 7.5 },
                        { "account/v1/wallet", 5 },
                        { "account/v1/currencies", 30 },
                        { "spot/v1/wallet", 5 },
                        { "account/v1/deposit/address", 30 },
                        { "account/v1/withdraw/charge", 32 },
                        { "account/v2/deposit-withdraw/history", 7.5 },
                        { "account/v1/deposit-withdraw/detail", 7.5 },
                        { "spot/v1/order_detail", 1 },
                        { "spot/v2/orders", 5 },
                        { "spot/v1/trades", 5 },
                        { "spot/v2/trades", 5 },
                        { "spot/v3/orders", 5 },
                        { "spot/v2/order_detail", 1 },
                        { "spot/v1/margin/isolated/borrow_record", 1 },
                        { "spot/v1/margin/isolated/repay_record", 1 },
                        { "spot/v1/margin/isolated/pairs", 1 },
                        { "spot/v1/margin/isolated/account", 6 },
                        { "spot/v1/trade_fee", 6 },
                        { "spot/v1/user_fee", 6 },
                        { "contract/private/assets-detail", 5 },
                        { "contract/private/order", 2 },
                        { "contract/private/order-history", 10 },
                        { "contract/private/position", 10 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "account/sub-account/main/v1/sub-to-main", 30 },
                        { "account/sub-account/sub/v1/sub-to-main", 30 },
                        { "account/sub-account/main/v1/main-to-sub", 30 },
                        { "account/sub-account/sub/v1/sub-to-sub", 30 },
                        { "account/sub-account/main/v1/sub-to-sub", 30 },
                        { "account/v1/withdraw/apply", 7.5 },
                        { "spot/v1/submit_order", 1 },
                        { "spot/v1/batch_orders", 1 },
                        { "spot/v2/cancel_order", 1 },
                        { "spot/v1/cancel_orders", 15 },
                        { "spot/v3/cancel_order", 1 },
                        { "spot/v2/batch_orders", 1 },
                        { "spot/v2/submit_order", 1 },
                        { "spot/v1/margin/submit_order", 1 },
                        { "spot/v1/margin/isolated/borrow", 6 },
                        { "spot/v1/margin/isolated/repay", 6 },
                        { "spot/v1/margin/isolated/transfer", 6 },
                        { "contract/private/trades", 10 },
                    } },
                } },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", 1 },
                { "3m", 3 },
                { "5m", 5 },
                { "15m", 15 },
                { "30m", 30 },
                { "45m", 45 },
                { "1h", 60 },
                { "2h", 120 },
                { "3h", 180 },
                { "4h", 240 },
                { "1d", 1440 },
                { "1w", 10080 },
                { "1M", 43200 },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "tierBased", true },
                    { "percentage", true },
                    { "taker", this.parseNumber("0.0025") },
                    { "maker", this.parseNumber("0.0025") },
                    { "tiers", new Dictionary<string, object>() {
                        { "taker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.0020")}, new List<object> {this.parseNumber("10"), this.parseNumber("0.18")}, new List<object> {this.parseNumber("50"), this.parseNumber("0.0016")}, new List<object> {this.parseNumber("250"), this.parseNumber("0.0014")}, new List<object> {this.parseNumber("1000"), this.parseNumber("0.0012")}, new List<object> {this.parseNumber("5000"), this.parseNumber("0.0010")}, new List<object> {this.parseNumber("25000"), this.parseNumber("0.0008")}, new List<object> {this.parseNumber("50000"), this.parseNumber("0.0006")}} },
                        { "maker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.001")}, new List<object> {this.parseNumber("10"), this.parseNumber("0.0009")}, new List<object> {this.parseNumber("50"), this.parseNumber("0.0008")}, new List<object> {this.parseNumber("250"), this.parseNumber("0.0007")}, new List<object> {this.parseNumber("1000"), this.parseNumber("0.0006")}, new List<object> {this.parseNumber("5000"), this.parseNumber("0.0005")}, new List<object> {this.parseNumber("25000"), this.parseNumber("0.0004")}, new List<object> {this.parseNumber("50000"), this.parseNumber("0.0003")}} },
                    } },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "30000", typeof(ExchangeError) },
                    { "30001", typeof(AuthenticationError) },
                    { "30002", typeof(AuthenticationError) },
                    { "30003", typeof(AccountSuspended) },
                    { "30004", typeof(AuthenticationError) },
                    { "30005", typeof(AuthenticationError) },
                    { "30006", typeof(AuthenticationError) },
                    { "30007", typeof(AuthenticationError) },
                    { "30008", typeof(AuthenticationError) },
                    { "30010", typeof(PermissionDenied) },
                    { "30011", typeof(AuthenticationError) },
                    { "30012", typeof(AuthenticationError) },
                    { "30013", typeof(RateLimitExceeded) },
                    { "30014", typeof(ExchangeNotAvailable) },
                    { "60000", typeof(BadRequest) },
                    { "60001", typeof(BadRequest) },
                    { "60002", typeof(BadRequest) },
                    { "60003", typeof(ExchangeError) },
                    { "60004", typeof(ExchangeError) },
                    { "60005", typeof(ExchangeError) },
                    { "60006", typeof(ExchangeError) },
                    { "60007", typeof(InvalidAddress) },
                    { "60008", typeof(InsufficientFunds) },
                    { "60009", typeof(ExchangeError) },
                    { "60010", typeof(ExchangeError) },
                    { "60011", typeof(InvalidAddress) },
                    { "60012", typeof(ExchangeError) },
                    { "60020", typeof(PermissionDenied) },
                    { "60021", typeof(PermissionDenied) },
                    { "60022", typeof(PermissionDenied) },
                    { "60030", typeof(BadRequest) },
                    { "60031", typeof(BadRequest) },
                    { "60050", typeof(ExchangeError) },
                    { "60051", typeof(ExchangeError) },
                    { "61001", typeof(InsufficientFunds) },
                    { "61003", typeof(BadRequest) },
                    { "50000", typeof(BadRequest) },
                    { "50001", typeof(BadSymbol) },
                    { "50002", typeof(BadRequest) },
                    { "50003", typeof(BadRequest) },
                    { "50004", typeof(BadRequest) },
                    { "50005", typeof(OrderNotFound) },
                    { "50006", typeof(InvalidOrder) },
                    { "50007", typeof(InvalidOrder) },
                    { "50008", typeof(InvalidOrder) },
                    { "50009", typeof(InvalidOrder) },
                    { "50010", typeof(InvalidOrder) },
                    { "50011", typeof(InvalidOrder) },
                    { "50012", typeof(InvalidOrder) },
                    { "50013", typeof(InvalidOrder) },
                    { "50014", typeof(BadRequest) },
                    { "50015", typeof(BadRequest) },
                    { "50016", typeof(BadRequest) },
                    { "50017", typeof(BadRequest) },
                    { "50018", typeof(BadRequest) },
                    { "50019", typeof(BadRequest) },
                    { "51004", typeof(InsufficientFunds) },
                    { "50020", typeof(InsufficientFunds) },
                    { "50021", typeof(BadRequest) },
                    { "50022", typeof(ExchangeNotAvailable) },
                    { "50023", typeof(BadSymbol) },
                    { "50029", typeof(InvalidOrder) },
                    { "50030", typeof(InvalidOrder) },
                    { "50032", typeof(OrderNotFound) },
                    { "50035", typeof(InvalidOrder) },
                    { "50034", typeof(InvalidOrder) },
                    { "51011", typeof(InvalidOrder) },
                    { "53000", typeof(AccountSuspended) },
                    { "53001", typeof(AccountSuspended) },
                    { "57001", typeof(BadRequest) },
                    { "58001", typeof(BadRequest) },
                    { "59001", typeof(ExchangeError) },
                    { "59002", typeof(ExchangeError) },
                    { "40001", typeof(ExchangeError) },
                    { "40002", typeof(ExchangeError) },
                    { "40003", typeof(ExchangeError) },
                    { "40004", typeof(ExchangeError) },
                    { "40005", typeof(ExchangeError) },
                    { "40006", typeof(PermissionDenied) },
                    { "40007", typeof(BadRequest) },
                    { "40008", typeof(InvalidNonce) },
                    { "40009", typeof(BadRequest) },
                    { "40010", typeof(BadRequest) },
                    { "40011", typeof(BadRequest) },
                    { "40012", typeof(ExchangeError) },
                    { "40013", typeof(ExchangeError) },
                    { "40014", typeof(BadSymbol) },
                    { "40015", typeof(BadSymbol) },
                    { "40016", typeof(InvalidOrder) },
                    { "40017", typeof(InvalidOrder) },
                    { "40018", typeof(InvalidOrder) },
                    { "40019", typeof(ExchangeError) },
                    { "40020", typeof(InvalidOrder) },
                    { "40021", typeof(ExchangeError) },
                    { "40022", typeof(ExchangeError) },
                    { "40023", typeof(ExchangeError) },
                    { "40024", typeof(ExchangeError) },
                    { "40025", typeof(ExchangeError) },
                    { "40026", typeof(ExchangeError) },
                    { "40027", typeof(InsufficientFunds) },
                    { "40028", typeof(PermissionDenied) },
                    { "40029", typeof(InvalidOrder) },
                    { "40030", typeof(InvalidOrder) },
                    { "40031", typeof(InvalidOrder) },
                    { "40032", typeof(InvalidOrder) },
                    { "40033", typeof(InvalidOrder) },
                    { "40034", typeof(BadSymbol) },
                    { "53002", typeof(PermissionDenied) },
                } },
                { "broad", new Dictionary<string, object>() {} },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "$GM", "GOLDMINER" },
                { "$HERO", "Step Hero" },
                { "$PAC", "PAC" },
                { "BP", "BEYOND" },
                { "GDT", "Gorilla Diamond" },
                { "GLD", "Goldario" },
                { "MVP", "MVP Coin" },
                { "TRU", "Truebit" },
            } },
            { "options", new Dictionary<string, object>() {
                { "networks", new Dictionary<string, object>() {
                    { "TRX", "TRC20" },
                    { "ETH", "ERC20" },
                } },
                { "defaultNetworks", new Dictionary<string, object>() {
                    { "USDT", "ERC20" },
                } },
                { "defaultType", "spot" },
                { "fetchBalance", new Dictionary<string, object>() {
                    { "type", "spot" },
                } },
                { "accountsByType", new Dictionary<string, object>() {
                    { "spot", "spot" },
                } },
                { "createMarketBuyOrderRequiresPrice", true },
            } },
        });
    }

    public async override Task<object> fetchTime(object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchTime
        * @description fetches the current integer timestamp in milliseconds from the exchange server
        * @param {object} params extra parameters specific to the bitmart api endpoint
        * @returns {int} the current integer timestamp in milliseconds from the exchange server
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetSystemTime(parameters);
        //
        //     {
        //         "message":"OK",
        //         "code":1000,
        //         "trace":"c4e5e5b7-fe9f-4191-89f7-53f6c5bf9030",
        //         "data":{
        //             "server_time":1599843709578
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.safeInteger(data, "server_time");
    }

    public async override Task<object> fetchStatus(object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchStatus
        * @description the latest known information on the availability of the exchange API
        * @param {object} params extra parameters specific to the bitmart api endpoint
        * @returns {object} a [status structure]{@link https://docs.ccxt.com/#/?id=exchange-status-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object options = this.safeValue(this.options, "fetchStatus", new Dictionary<string, object>() {});
        object defaultType = this.safeString(this.options, "defaultType");
        object type = this.safeString(options, "type", defaultType);
        type = this.safeString(parameters, "type", type);
        parameters = this.omit(parameters, "type");
        object response = await this.publicGetSystemService(parameters);
        //
        //     {
        //         "message": "OK",
        //         "code": 1000,
        //         "trace": "1d3f28b0-763e-4f78-90c4-5e3ad19dc595",
        //         "data": {
        //           "service": [
        //             {
        //               "title": "Spot API Stop",
        //               "service_type": "spot",
        //               "status": 2,
        //               "start_time": 1648639069125,
        //               "end_time": 1648639069125
        //             },
        //             {
        //               "title": "Contract API Stop",
        //               "service_type": "contract",
        //               "status": 2,
        //               "start_time": 1648639069125,
        //               "end_time": 1648639069125
        //             }
        //           ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object services = this.safeValue(data, "service", new List<object>() {});
        object servicesByType = this.indexBy(services, "service_type");
        if (isTrue(isEqual(type, "swap")))
        {
            type = "contract";
        }
        object service = this.safeValue(servicesByType, type);
        object status = null;
        object eta = null;
        if (isTrue(!isEqual(service, null)))
        {
            object statusCode = this.safeInteger(service, "status");
            if (isTrue(isEqual(statusCode, 2)))
            {
                status = "ok";
            } else
            {
                status = "maintenance";
                eta = this.safeInteger(service, "end_time");
            }
        }
        return new Dictionary<string, object>() {
            { "status", status },
            { "updated", null },
            { "eta", eta },
            { "url", null },
            { "info", response },
        };
    }

    public async virtual Task<object> fetchSpotMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetSpotV1SymbolsDetails(parameters);
        //
        //     {
        //         "message":"OK",
        //         "code":1000,
        //         "trace":"a67c9146-086d-4d3f-9897-5636a9bb26e1",
        //         "data":{
        //             "symbols":[
        //               {
        //                  "symbol": "BTC_USDT",
        //                  "symbol_id": 53,
        //                  "base_currency": "BTC",
        //                  "quote_currency": "USDT",
        //                  "base_min_size": "0.000010000000000000000000000000",
        //                  "base_max_size": "100000000.000000000000000000000000000000",
        //                  "price_min_precision": -1,
        //                  "price_max_precision": 2,
        //                  "quote_increment": "0.00001", // Api docs says "The minimum order quantity is also the minimum order quantity increment", however I think they mistakenly use the term 'order quantity'
        //                  "expiration": "NA",
        //                  "min_buy_amount": "5.000000000000000000000000000000",
        //                  "min_sell_amount": "5.000000000000000000000000000000",
        //                  "trade_status": "trading"
        //               },
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object symbols = this.safeValue(data, "symbols", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object market = getValue(symbols, i);
            object id = this.safeString(market, "symbol");
            object numericId = this.safeInteger(market, "symbol_id");
            object baseId = this.safeString(market, "base_currency");
            object quoteId = this.safeString(market, "quote_currency");
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            object symbol = add(add(bs, "/"), quote);
            object minBuyCost = this.safeString(market, "min_buy_amount");
            object minSellCost = this.safeString(market, "min_sell_amount");
            object minCost = Precise.stringMax(minBuyCost, minSellCost);
            object baseMinSize = this.safeNumber(market, "base_min_size");
            ((List<object>)result).Add(new Dictionary<string, object>() {
                { "id", id },
                { "numericId", numericId },
                { "symbol", symbol },
                { "base", bs },
                { "quote", quote },
                { "settle", null },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", null },
                { "type", "spot" },
                { "spot", true },
                { "margin", false },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "active", true },
                { "contract", false },
                { "linear", null },
                { "inverse", null },
                { "contractSize", null },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", baseMinSize },
                    { "price", this.parseNumber(this.parsePrecision(this.safeString(market, "price_max_precision"))) },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", baseMinSize },
                        { "max", this.safeNumber(market, "base_max_size") },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", this.parseNumber(minCost) },
                        { "max", null },
                    } },
                } },
                { "info", market },
            });
        }
        return result;
    }

    public async virtual Task<object> fetchContractMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetContractPublicDetails(parameters);
        //
        //     {
        //       "code": 1000,
        //       "message": "Ok",
        //       "trace": "9b92a999-9463-4c96-91a4-93ad1cad0d72",
        //       "data": {
        //       "symbols": [{
        //             "symbol": "BTCUSDT",
        //             "product_type": 1,
        //             "open_timestamp": 1594080000,
        //             "expire_timestamp": 0,
        //             "settle_timestamp": 0,
        //             "base_currency": "BTC",
        //             "quote_currency": "USDT",
        //             "last_price": "23920",
        //             "volume_24h": "18969368",
        //             "turnover_24h": "458933659.7858",
        //             "index_price": "23945.25191635",
        //             "index_name": "BTCUSDT",
        //             "contract_size": "0.001",
        //             "min_leverage": "1",
        //             "max_leverage": "100",
        //             "price_precision": "0.1",
        //             "vol_precision": "1",
        //             "max_volume": "500000",
        //             "min_volume": "1"
        //           },
        //           ...
        //         ]
        //       }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object symbols = this.safeValue(data, "symbols", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object market = getValue(symbols, i);
            object id = this.safeString(market, "symbol");
            object baseId = this.safeString(market, "base_currency");
            object quoteId = this.safeString(market, "quote_currency");
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            object settle = "USDT";
            object symbol = add(add(add(add(bs, "/"), quote), ":"), settle);
            object productType = this.safeNumber(market, "product_type");
            object expiry = this.safeInteger(market, "expire_timestamp");
            ((List<object>)result).Add(new Dictionary<string, object>() {
                { "id", id },
                { "numericId", null },
                { "symbol", symbol },
                { "base", bs },
                { "quote", quote },
                { "settle", settle },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", null },
                { "type", "swap" },
                { "spot", false },
                { "margin", false },
                { "swap", (isEqual(productType, 1)) },
                { "future", (isEqual(productType, 2)) },
                { "option", false },
                { "active", true },
                { "contract", true },
                { "linear", true },
                { "inverse", false },
                { "contractSize", this.safeNumber(market, "contract_size") },
                { "expiry", expiry },
                { "expiryDatetime", this.iso8601(expiry) },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", this.safeNumber(market, "vol_precision") },
                    { "price", this.safeNumber(market, "price_precision") },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "min_leverage") },
                        { "max", this.safeNumber(market, "max_leverage") },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "min_volume") },
                        { "max", this.safeNumber(market, "max_volume") },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "info", market },
            });
        }
        return result;
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchMarkets
        * @description retrieves data on all markets for bitmart
        * @param {object} params extra parameters specific to the exchange api endpoint
        * @returns {[object]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object spot = await this.fetchSpotMarkets(parameters);
        object contract = await this.fetchContractMarkets(parameters);
        return this.arrayConcat(spot, contract);
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchCurrencies
        * @description fetches all available currencies on an exchange
        * @param {object} params extra parameters specific to the bitmart api endpoint
        * @returns {object} an associative dictionary of currencies
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetSpotV1Currencies(parameters);
        //
        //     {
        //         "message":"OK",
        //         "code":1000,
        //         "trace":"8c768b3c-025f-413f-bec5-6d6411d46883",
        //         "data":{
        //             "currencies":[
        //                 {"currency":"MATIC","name":"Matic Network","withdraw_enabled":true,"deposit_enabled":true},
        //                 {"currency":"KTN","name":"Kasoutuuka News","withdraw_enabled":true,"deposit_enabled":false},
        //                 {"currency":"BRT","name":"Berith","withdraw_enabled":true,"deposit_enabled":true},
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object currencies = this.safeValue(data, "currencies", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(currencies)); postFixIncrement(ref i))
        {
            object currency = getValue(currencies, i);
            object id = this.safeString(currency, "id");
            object code = this.safeCurrencyCode(id);
            object name = this.safeString(currency, "name");
            object withdrawEnabled = this.safeValue(currency, "withdraw_enabled");
            object depositEnabled = this.safeValue(currency, "deposit_enabled");
            object active = isTrue(withdrawEnabled) && isTrue(depositEnabled);
            ((Dictionary<string, object>)result)[(string)code] = new Dictionary<string, object>() {
                { "id", id },
                { "code", code },
                { "name", name },
                { "info", currency },
                { "active", active },
                { "deposit", depositEnabled },
                { "withdraw", withdrawEnabled },
                { "fee", null },
                { "precision", null },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
            };
        }
        return result;
    }

    public async override Task<object> fetchTransactionFee(object code, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchTransactionFee
        * @description *DEPRECATED* please use fetchDepositWithdrawFee instead
        * @param {string} code unified currency code
        * @param {object} params extra parameters specific to the bitmart api endpoint
        * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        object response = await this.privateGetAccountV1WithdrawCharge(this.extend(request, parameters));
        //
        //     {
        //         message: 'OK',
        //         code: '1000',
        //         trace: '3ecc0adf-91bd-4de7-aca1-886c1122f54f',
        //         data: {
        //             today_available_withdraw_BTC: '100.0000',
        //             min_withdraw: '0.005',
        //             withdraw_precision: '8',
        //             withdraw_fee: '0.000500000000000000000000000000'
        //         }
        //     }
        //
        object data = getValue(response, "data");
        object withdrawFees = new Dictionary<string, object>() {};
        ((Dictionary<string, object>)withdrawFees)[(string)code] = this.safeNumber(data, "withdraw_fee");
        return new Dictionary<string, object>() {
            { "info", response },
            { "withdraw", withdrawFees },
            { "deposit", new Dictionary<string, object>() {} },
        };
    }

    public override object parseDepositWithdrawFee(object fee, object currency = null)
    {
        //
        //    {
        //        today_available_withdraw_BTC: '100.0000',
        //        min_withdraw: '0.005',
        //        withdraw_precision: '8',
        //        withdraw_fee: '0.000500000000000000000000000000'
        //    }
        //
        return new Dictionary<string, object>() {
            { "info", fee },
            { "withdraw", new Dictionary<string, object>() {
                { "fee", this.safeNumber(fee, "withdraw_fee") },
                { "percentage", null },
            } },
            { "deposit", new Dictionary<string, object>() {
                { "fee", null },
                { "percentage", null },
            } },
            { "networks", new Dictionary<string, object>() {} },
        };
    }

    public async override Task<object> fetchDepositWithdrawFee(object code, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchDepositWithdrawFee
        * @description fetch the fee for deposits and withdrawals
        * @param {string} code unified currency code
        * @param {object} params extra parameters specific to the bitmart api endpoint
        * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        object response = await this.privateGetAccountV1WithdrawCharge(this.extend(request, parameters));
        //
        //     {
        //         message: 'OK',
        //         code: '1000',
        //         trace: '3ecc0adf-91bd-4de7-aca1-886c1122f54f',
        //         data: {
        //             today_available_withdraw_BTC: '100.0000',
        //             min_withdraw: '0.005',
        //             withdraw_precision: '8',
        //             withdraw_fee: '0.000500000000000000000000000000'
        //         }
        //     }
        //
        object data = getValue(response, "data");
        return this.parseDepositWithdrawFee(data);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        // spot
        //
        //      {
        //          "symbol": "SOLAR_USDT",
        //          "last_price": "0.020342",
        //          "quote_volume_24h": "56817.811802",
        //          "base_volume_24h": "2172060",
        //          "high_24h": "0.256000",
        //          "low_24h": "0.016980",
        //          "open_24h": "0.022309",
        //          "close_24h": "0.020342",
        //          "best_ask": "0.020389",
        //          "best_ask_size": "339.000000000000000000000000000000",
        //          "best_bid": "0.020342",
        //          "best_bid_size": "3369.000000000000000000000000000000",
        //          "fluctuation": "-0.0882",
        //          "url": "https://www.bitmart.com/trade?symbol=SOLAR_USDT",
        //          "timestamp": 1667403439367
        //      }
        //
        // swap
        //
        //      {
        //          "contract_symbol":"DOGEUSDT",
        //          "last_price":"0.130340",
        //          "index_price":"0.13048245",
        //          "last_funding_rate":"0.00002287",
        //          "price_change_percent_24h":"-2.074",
        //          "volume_24h":"113705028.59482228",
        //          "url":"https://futures.bitmart.com/en?symbol=DOGEUSDT",
        //          "high_price":"0.134520",
        //          "low_price":"0.128570",
        //          "legal_coin_price":"0.1302699"
        //      }
        //
        object timestamp = this.safeInteger(ticker, "timestamp", this.milliseconds());
        object marketId = this.safeString2(ticker, "symbol", "contract_symbol");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object last = this.safeString2(ticker, "close_24h", "last_price");
        object percentage = this.safeString(ticker, "price_change_percent_24h");
        if (isTrue(isEqual(percentage, null)))
        {
            object percentageRaw = this.safeString(ticker, "fluctuation");
            if (isTrue(isTrue((!isEqual(percentageRaw, null))) && isTrue((!isEqual(percentageRaw, "0")))))
            {
                object direction = getValue(percentageRaw, 0);
                percentage = add(direction, Precise.stringMul(((string)percentageRaw).Replace((string)direction, (string)""), "100"));
            } else if (isTrue(isEqual(percentageRaw, "0")))
            {
                percentage = "0";
            }
        }
        object baseVolume = this.safeString(ticker, "base_volume_24h");
        object quoteVolume = this.safeString(ticker, "quote_volume_24h");
        quoteVolume = this.safeString(ticker, "volume_24h", quoteVolume);
        object average = this.safeString2(ticker, "avg_price", "index_price");
        object high = this.safeString2(ticker, "high_24h", "high_price");
        object low = this.safeString2(ticker, "low_24h", "low_price");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", high },
            { "low", low },
            { "bid", this.safeString(ticker, "best_bid") },
            { "bidVolume", this.safeString(ticker, "best_bid_size") },
            { "ask", this.safeString(ticker, "best_ask") },
            { "askVolume", this.safeString(ticker, "best_ask_size") },
            { "vwap", null },
            { "open", this.safeString(ticker, "open_24h") },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", percentage },
            { "average", average },
            { "baseVolume", baseVolume },
            { "quoteVolume", quoteVolume },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchTicker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} params extra parameters specific to the bitmart api endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {};
        object method = null;
        if (isTrue(getValue(market, "swap")))
        {
            method = "publicGetContractV1Tickers";
            ((Dictionary<string, object>)request)["contract_symbol"] = getValue(market, "id");
        } else if (isTrue(getValue(market, "spot")))
        {
            method = "publicGetSpotV1Ticker";
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        // spot
        //
        //     {
        //         "message":"OK",
        //         "code":1000,
        //         "trace":"6aa5b923-2f57-46e3-876d-feca190e0b82",
        //         "data":{
        //             "tickers":[
        //                 {
        //                     "symbol":"ETH_BTC",
        //                     "last_price":"0.036037",
        //                     "quote_volume_24h":"4380.6660000000",
        //                     "base_volume_24h":"159.3582006712",
        //                     "high_24h":"0.036972",
        //                     "low_24h":"0.035524",
        //                     "open_24h":"0.036561",
        //                     "close_24h":"0.036037",
        //                     "best_ask":"0.036077",
        //                     "best_ask_size":"9.9500",
        //                     "best_bid":"0.035983",
        //                     "best_bid_size":"4.2792",
        //                     "fluctuation":"-0.0143",
        //                     "url":"https://www.bitmart.com/trade?symbol=ETH_BTC"
        //                 }
        //             ]
        //         }
        //     }
        //
        // swap
        //
        //      {
        //          "message":"OK",
        //          "code":1000,
        //          "trace":"4a0ebceb-d3f7-45a3-8feb-f61e230e24cd",
        //          "data":{
        //              "tickers":[
        //                  {
        //                      "contract_symbol":"DOGEUSDT",
        //                      "last_price":"0.130180",
        //                      "index_price":"0.13028635",
        //                      "last_funding_rate":"0.00002025",
        //                      "price_change_percent_24h":"-2.326",
        //                      "volume_24h":"116789313.01797258",
        //                      "url":"https://futures.bitmart.com/en?symbol=DOGEUSDT",
        //                      "high_price":"0.134520",
        //                      "low_price":"0.128570",
        //                      "legal_coin_price":"0.13017401"
        //                  }
        //              ]
        //          }
        //      }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object tickers = this.safeValue(data, "tickers", new List<object>() {});
        // fails in naming for contract tickers 'contract_symbol'
        object tickersById = null;
        if (isTrue(getValue(market, "spot")))
        {
            tickersById = this.indexBy(tickers, "symbol");
        } else if (isTrue(getValue(market, "swap")))
        {
            tickersById = this.indexBy(tickers, "contract_symbol");
        }
        object ticker = this.safeValue(tickersById, getValue(market, "id"));
        return this.parseTicker(ticker, market);
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchTickers
        * @description fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
        * @see https://developer-pro.bitmart.com/en/spot/#get-ticker-of-all-pairs-v2
        * @param {[string]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} params extra parameters specific to the bitmart api endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object type = null;
        object market = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            object symbol = this.safeValue(symbols, 0);
            market = this.market(symbol);
        }
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchTickers", market, parameters);
        type = ((List<object>)typeparametersVariable)[0];
        parameters = ((List<object>)typeparametersVariable)[1];
        object method = this.getSupportedMapping(type, new Dictionary<string, object>() {
            { "spot", "publicGetSpotV2Ticker" },
            { "swap", "publicGetContractV1Tickers" },
        });
        object response = await ((Task<object>)callDynamically(this, method, new object[] { parameters }));
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object tickers = this.safeValue(data, "tickers", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(tickers)); postFixIncrement(ref i))
        {
            object ticker = this.parseTicker(getValue(tickers, i));
            object symbol = getValue(ticker, "symbol");
            ((Dictionary<string, object>)result)[(string)symbol] = ticker;
        }
        return this.filterByArray(result, "symbol", symbols);
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int|undefined} limit the maximum amount of order book entries to return
        * @param {object} params extra parameters specific to the bitmart api endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchOrderBook() does not support "), getValue(market, "type")), " markets, only spot markets are accepted")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["size"] = limit; // default 50, max 200
        }
        // request['precision'] = 4; // optional price precision / depth level whose range is defined in symbol details
        object response = await this.publicGetSpotV1SymbolsBook(this.extend(request, parameters));
        //
        // spot
        //
        //     {
        //         "message":"OK",
        //         "code":1000,
        //         "trace":"8254f8fc-431d-404f-ad9a-e716339f66c7",
        //         "data":{
        //             "buys":[
        //                 {"amount":"4.7091","total":"4.71","price":"0.034047","count":"1"},
        //                 {"amount":"5.7439","total":"10.45","price":"0.034039","count":"1"},
        //                 {"amount":"2.5249","total":"12.98","price":"0.032937","count":"1"},
        //             ],
        //             "sells":[
        //                 {"amount":"41.4365","total":"41.44","price":"0.034174","count":"1"},
        //                 {"amount":"4.2317","total":"45.67","price":"0.034183","count":"1"},
        //                 {"amount":"0.3000","total":"45.97","price":"0.034240","count":"1"},
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object timestamp = this.safeInteger(data, "timestamp");
        return this.parseOrderBook(data, symbol, timestamp, "buys", "sells", "price", "amount");
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // public fetchTrades spot ( amount = count * price )
        //
        //     {
        //          "amount": "818.94",
        //          "order_time": "1637601839035",    // ETH/USDT
        //          "price": "4221.99",
        //          "count": "0.19397",
        //          "type": "buy"
        //      }
        //
        // private fetchMyTrades spot
        //
        //     {
        //         "detail_id":256348632,
        //         "order_id":2147484350,
        //         "symbol":"BTC_USDT",
        //         "create_time":1590462303000,
        //         "side":"buy",
        //         "fees":"0.00001350",
        //         "fee_coin_name":"BTC",
        //         "notional":"88.00000000",
        //         "price_avg":"8800.00",
        //         "size":"0.01000",
        //         "exec_type":"M"
        //     }
        //
        object id = this.safeString(trade, "detail_id");
        object timestamp = this.safeInteger2(trade, "order_time", "create_time");
        object type = null;
        object side = this.safeStringLower2(trade, "type", "side");
        object takerOrMaker = null;
        object execType = this.safeString(trade, "exec_type");
        if (isTrue(!isEqual(execType, null)))
        {
            takerOrMaker = ((bool) isTrue((isEqual(execType, "M")))) ? "maker" : "taker";
        }
        object priceString = this.safeString(trade, "price");
        priceString = this.safeString(trade, "price_avg", priceString);
        object amountString = this.safeString(trade, "count");
        amountString = this.safeString(trade, "size", amountString);
        object costString = this.safeString2(trade, "amount", "notional");
        object orderId = this.safeString(trade, "order_id");
        object marketId = this.safeString(trade, "symbol");
        market = this.safeMarket(marketId, market, "_");
        object feeCostString = this.safeString(trade, "fees");
        object fee = null;
        if (isTrue(!isEqual(feeCostString, null)))
        {
            object feeCurrencyId = this.safeString(trade, "fee_coin_name");
            object feeCurrencyCode = this.safeCurrencyCode(feeCurrencyId);
            if (isTrue(isEqual(feeCurrencyCode, null)))
            {
                feeCurrencyCode = ((bool) isTrue((isEqual(side, "buy")))) ? getValue(market, "base") : getValue(market, "quote");
            }
            fee = new Dictionary<string, object>() {
                { "cost", feeCostString },
                { "currency", feeCurrencyCode },
            };
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "id", id },
            { "order", orderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", getValue(market, "symbol") },
            { "type", type },
            { "side", side },
            { "price", priceString },
            { "amount", amountString },
            { "cost", costString },
            { "takerOrMaker", takerOrMaker },
            { "fee", fee },
        }, market);
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int|undefined} since timestamp in ms of the earliest trade to fetch
        * @param {int|undefined} limit the maximum amount of trades to fetch
        * @param {object} params extra parameters specific to the bitmart api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/en/latest/manual.html?#public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchTrades() does not support "), getValue(market, "type")), " orders, only spot orders are accepted")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.publicGetSpotV1SymbolsTrades(this.extend(request, parameters));
        //
        // spot
        //
        //     {
        //         "message":"OK",
        //         "code":1000,
        //         "trace":"222d74c0-8f6d-49d9-8e1b-98118c50eeba",
        //         "data":{
        //             "trades":[
        //                 {
        //                     "amount":"0.005703",
        //                     "order_time":1599652045394,
        //                     "price":"0.034029",
        //                     "count":"0.1676",
        //                     "type":"sell"
        //                 },
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object trades = this.safeValue(data, "trades", new List<object>() {});
        return this.parseTrades(trades, market, since, limit);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        // spot
        //
        //     {
        //         "last_price":"0.034987",
        //         "timestamp":1598787420,
        //         "volume":"1.0198",
        //         "open":"0.035007",
        //         "close":"0.034987",
        //         "high":"0.035007",
        //         "low":"0.034986"
        //     }
        //
        // swap
        //
        //     {
        //         "low_price": "20090.3",
        //         "high_price": "20095.5",
        //         "open_price": "20092.6",
        //         "close_price": "20091.4",
        //         "volume": "8748",
        //         "timestamp": 1665002281
        //     }
        //
        // ws
        //
        //     [
        //         1631056350, // timestamp
        //         '46532.83', // oopen
        //         '46555.71', // high
        //         '46511.41', // low
        //         '46555.71', // close
        //         '0.25', // volume
        //     ]
        //
        if (isTrue((ohlcv.GetType().IsGenericType && ohlcv.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))
        {
            return new List<object> {this.safeTimestamp(ohlcv, 0), this.safeNumber(ohlcv, 1), this.safeNumber(ohlcv, 2), this.safeNumber(ohlcv, 3), this.safeNumber(ohlcv, 4), this.safeNumber(ohlcv, 5)};
        } else
        {
            return new List<object> {this.safeTimestamp(ohlcv, "timestamp"), this.safeNumber2(ohlcv, "open", "open_price"), this.safeNumber2(ohlcv, "high", "high_price"), this.safeNumber2(ohlcv, "low", "low_price"), this.safeNumber2(ohlcv, "close", "close_price"), this.safeNumber(ohlcv, "volume")};
        }
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchOHLCV
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @see https://developer-pro.bitmart.com/en/spot/#get-k-line
        * @see https://developer-pro.bitmart.com/en/futures/#get-k-line
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int|undefined} since timestamp in ms of the earliest candle to fetch
        * @param {int|undefined} limit the maximum amount of candles to fetch
        * @param {object} params extra parameters specific to the bitmart api endpoint
        * @returns {[[int]]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object type = getValue(market, "type");
        object duration = this.parseTimeframe(timeframe);
        object parsedTimeframe = this.safeInteger(this.timeframes, timeframe);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(parsedTimeframe, null)))
        {
            ((Dictionary<string, object>)request)["step"] = parsedTimeframe;
        } else
        {
            ((Dictionary<string, object>)request)["step"] = timeframe;
        }
        object maxLimit = 500;
        if (isTrue(isEqual(limit, null)))
        {
            limit = maxLimit;
        }
        limit = mathMin(maxLimit, limit);
        object now = this.parseToInt(divide(this.milliseconds(), 1000));
        object fromRequest = ((bool) isTrue((isEqual(type, "spot")))) ? "from" : "start_time";
        object toRequest = ((bool) isTrue((isEqual(type, "spot")))) ? "to" : "end_time";
        if (isTrue(isEqual(since, null)))
        {
            object start = subtract(now, multiply(limit, duration));
            ((Dictionary<string, object>)request)[(string)fromRequest] = start;
            ((Dictionary<string, object>)request)[(string)toRequest] = now;
        } else
        {
            object start = subtract(this.parseToInt((divide(since, 1000))), 1);
            object end = this.sum(start, multiply(limit, duration));
            ((Dictionary<string, object>)request)[(string)fromRequest] = start;
            ((Dictionary<string, object>)request)[(string)toRequest] = mathMin(end, now);
        }
        object method = "publicGetSpotV1SymbolsKline";
        if (isTrue(isEqual(type, "swap")))
        {
            method = "publicGetContractPublicKline";
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        // spot
        //
        //     {
        //         "message":"OK",
        //         "code":1000,
        //         "trace":"80d86378-ab4e-4c70-819e-b42146cf87ad",
        //         "data":{
        //             "klines":[
        //                 {"last_price":"0.034987","timestamp":1598787420,"volume":"1.0198","open":"0.035007","close":"0.034987","high":"0.035007","low":"0.034986"},
        //                 {"last_price":"0.034986","timestamp":1598787480,"volume":"0.3959","open":"0.034982","close":"0.034986","high":"0.034986","low":"0.034980"},
        //                 {"last_price":"0.034978","timestamp":1598787540,"volume":"0.3259","open":"0.034987","close":"0.034978","high":"0.034987","low":"0.034977"},
        //             ]
        //         }
        //     }
        //
        // swap
        //
        //     {
        //         "code": 1000,
        //         "message": "Ok",
        //         "data": [
        //             {
        //                 "low_price": "20090.3",
        //                 "high_price": "20095.5",
        //                 "open_price": "20092.6",
        //                 "close_price": "20091.4",
        //                 "volume": "8748",
        //                 "timestamp": 1665002281
        //             },
        //             ...
        //         ],
        //         "trace": "96c989db-e0f5-46f5-bba6-60cfcbde699b"
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object klines = this.safeValue(data, "klines", new List<object>() {});
        object ohlcv = ((bool) isTrue((isEqual(type, "spot")))) ? klines : data;
        return this.parseOHLCVs(ohlcv, market, timeframe, since, limit);
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchMyTrades
        * @description fetch all trades made by the user
        * @param {string} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch trades for
        * @param {int|undefined} limit the maximum number of trades structures to retrieve
        * @param {object} params extra parameters specific to the bitmart api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchMyTrades() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchMyTrades() does not support "), getValue(market, "type")), " orders, only spot orders are accepted")) ;
        }
        object options = this.safeValue(this.options, "fetchMyTrades", new Dictionary<string, object>() {});
        object defaultLimit = this.safeInteger(options, "limit", 200);
        if (isTrue(isEqual(limit, null)))
        {
            limit = defaultLimit;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "N", limit },
        };
        object response = await this.privateGetSpotV2Trades(this.extend(request, parameters));
        //
        // spot
        //
        //     {
        //         "message":"OK",
        //         "code":1000,
        //         "trace":"a06a5c53-8e6f-42d6-8082-2ff4718d221c",
        //         "data":{
        //             "current_page":1,
        //             "trades":[
        //                 {
        //                     "detail_id":256348632,
        //                     "order_id":2147484350,
        //                     "symbol":"BTC_USDT",
        //                     "create_time":1590462303000,
        //                     "side":"buy",
        //                     "fees":"0.00001350",
        //                     "fee_coin_name":"BTC",
        //                     "notional":"88.00000000",
        //                     "price_avg":"8800.00",
        //                     "size":"0.01000",
        //                     "exec_type":"M"
        //                 },
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object trades = this.safeValue(data, "trades", new List<object>() {});
        return this.parseTrades(trades, market, since, limit);
    }

    public async override Task<object> fetchOrderTrades(object id, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchOrderTrades
        * @description fetch all the trades made from a single order
        * @param {string} id order id
        * @param {string} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch trades for
        * @param {int|undefined} limit the maximum number of trades to retrieve
        * @param {object} params extra parameters specific to the bitmart api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOrderTrades() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchOrderTrades() does not support "), getValue(market, "type")), " orders, only spot orders are accepted")) ;
        }
        object options = this.safeValue(this.options, "fetchOrderTrades", new Dictionary<string, object>() {});
        object defaultLimit = this.safeInteger(options, "limit", 200);
        if (isTrue(isEqual(limit, null)))
        {
            limit = defaultLimit;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "order_id", id },
            { "N", limit },
        };
        object response = await this.privateGetSpotV2Trades(this.extend(request, parameters));
        //
        // spot
        //
        //     {
        //         "message":"OK",
        //         "code":1000,
        //         "trace":"a06a5c53-8e6f-42d6-8082-2ff4718d221c",
        //         "data":{
        //             "current_page":1,
        //             "trades":[
        //                 {
        //                     "detail_id":256348632,
        //                     "order_id":2147484350,
        //                     "symbol":"BTC_USDT",
        //                     "create_time":1590462303000,
        //                     "side":"buy",
        //                     "fees":"0.00001350",
        //                     "fee_coin_name":"BTC",
        //                     "notional":"88.00000000",
        //                     "price_avg":"8800.00",
        //                     "size":"0.01000",
        //                     "exec_type":"M"
        //                 },
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object trades = this.safeValue(data, "trades", new List<object>() {});
        return this.parseTrades(trades, market, since, limit);
    }

    public virtual object parseBalance(object response, object marketType)
    {
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object wallet = null;
        if (isTrue(isEqual(marketType, "swap")))
        {
            wallet = this.safeValue(response, "data", new List<object>() {});
        } else if (isTrue(isEqual(marketType, "margin")))
        {
            wallet = this.safeValue(data, "symbols", new List<object>() {});
        } else
        {
            wallet = this.safeValue(data, "wallet", new List<object>() {});
        }
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        if (isTrue(isEqual(marketType, "margin")))
        {
            for (object i = 0; isLessThan(i, getArrayLength(wallet)); postFixIncrement(ref i))
            {
                object entry = getValue(wallet, i);
                object marketId = this.safeString(entry, "symbol");
                object symbol = this.safeSymbol(marketId, null, "_");
                object bs = this.safeValue(entry, "base", new Dictionary<string, object>() {});
                object quote = this.safeValue(entry, "quote", new Dictionary<string, object>() {});
                object baseCode = this.safeCurrencyCode(this.safeString(bs, "currency"));
                object quoteCode = this.safeCurrencyCode(this.safeString(quote, "currency"));
                object subResult = new Dictionary<string, object>() {};
                ((Dictionary<string, object>)subResult)[(string)baseCode] = this.parseBalanceHelper(bs);
                ((Dictionary<string, object>)subResult)[(string)quoteCode] = this.parseBalanceHelper(quote);
                ((Dictionary<string, object>)result)[(string)symbol] = this.safeBalance(subResult);
            }
            return result;
        } else
        {
            for (object i = 0; isLessThan(i, getArrayLength(wallet)); postFixIncrement(ref i))
            {
                object balance = getValue(wallet, i);
                object currencyId = this.safeString2(balance, "id", "currency");
                currencyId = this.safeString(balance, "coin_code", currencyId);
                object code = this.safeCurrencyCode(currencyId);
                object account = this.account();
                ((Dictionary<string, object>)account)["free"] = this.safeString2(balance, "available", "available_balance");
                ((Dictionary<string, object>)account)["used"] = this.safeString2(balance, "frozen", "frozen_balance");
                ((Dictionary<string, object>)result)[(string)code] = account;
            }
            return this.safeBalance(result);
        }
    }

    public virtual object parseBalanceHelper(object entry)
    {
        object account = this.account();
        ((Dictionary<string, object>)account)["used"] = this.safeString(entry, "frozen");
        ((Dictionary<string, object>)account)["free"] = this.safeString(entry, "available");
        ((Dictionary<string, object>)account)["total"] = this.safeString(entry, "total_asset");
        object debt = this.safeString(entry, "borrow_unpaid");
        object interest = this.safeString(entry, "interest_unpaid");
        ((Dictionary<string, object>)account)["debt"] = Precise.stringAdd(debt, interest);
        return account;
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @see https://developer-pro.bitmart.com/en/spot/#get-spot-wallet-balance
        * @see https://developer-pro.bitmart.com/en/futures/#get-contract-assets-detail
        * @see https://developer-pro.bitmart.com/en/spot/#get-account-balance
        * @see https://developer-pro.bitmart.com/en/spot/#get-margin-account-details-isolated
        * @param {object} params extra parameters specific to the bitmart api endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/en/latest/manual.html?#balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object marketType = null;
        var marketTypeparametersVariable = this.handleMarketTypeAndParams("fetchBalance", null, parameters);
        marketType = ((List<object>)marketTypeparametersVariable)[0];
        parameters = ((List<object>)marketTypeparametersVariable)[1];
        object method = this.getSupportedMapping(marketType, new Dictionary<string, object>() {
            { "spot", "privateGetSpotV1Wallet" },
            { "swap", "privateGetContractPrivateAssetsDetail" },
            { "account", "privateGetAccountV1Wallet" },
            { "margin", "privateGetSpotV1MarginIsolatedAccount" },
        });
        object marginMode = this.safeString(parameters, "marginMode");
        object isMargin = this.safeValue(parameters, "margin", false);
        parameters = this.omit(parameters, new List<object>() {"margin", "marginMode"});
        if (isTrue(isTrue(!isEqual(marginMode, null)) || isTrue(isMargin)))
        {
            method = "privateGetSpotV1MarginIsolatedAccount";
            marketType = "margin";
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { parameters }));
        //
        // spot
        //
        //     {
        //         "message":"OK",
        //         "code":1000,
        //         "trace":"39069916-72f9-44c7-acde-2ad5afd21cad",
        //         "data":{
        //             "wallet":[
        //                 {"id":"BTC","name":"Bitcoin","available":"0.00000062","frozen":"0.00000000"},
        //                 {"id":"ETH","name":"Ethereum","available":"0.00002277","frozen":"0.00000000"},
        //                 {"id":"BMX","name":"BitMart Token","available":"0.00000000","frozen":"0.00000000"}
        //             ]
        //         }
        //     }
        //
        // account
        //
        //     {
        //         "message":"OK",
        //         "code":1000,
        //         "trace":"5c3b7fc7-93b2-49ef-bb59-7fdc56915b59",
        //         "data":{
        //             "wallet":[
        //                 {"currency":"BTC","name":"Bitcoin","available":"0.00000062","frozen":"0.00000000"},
        //                 {"currency":"ETH","name":"Ethereum","available":"0.00002277","frozen":"0.00000000"}
        //             ]
        //         }
        //     }
        //
        // swap
        //
        //     {
        //         "code": 1000,
        //         "message": "Ok",
        //         "data": [
        //             {
        //                 "currency": "USDT",
        //                 "available_balance": "0",
        //                 "frozen_balance": "0",
        //                 "unrealized": "0",
        //                 "equity": "0",
        //                 "position_deposit": "0"
        //             },
        //             ...
        //         ],
        //         "trace": "f9da3a39-cf45-42e7-914d-294f565dfc33"
        //     }
        //
        // margin
        //
        //     {
        //         "message": "OK",
        //         "code": 1000,
        //         "trace": "61dd6ab265c04064b72d8bc9b205f741.71.16701055600915302",
        //         "data": {
        //             "symbols": [
        //                 {
        //                     "symbol": "BTC_USDT",
        //                     "risk_rate": "999.00",
        //                     "risk_level": "1",
        //                     "buy_enabled": false,
        //                     "sell_enabled": false,
        //                     "liquidate_price": null,
        //                     "liquidate_rate": "1.15",
        //                     "base": {
        //                         "currency": "BTC",
        //                         "borrow_enabled": true,
        //                         "borrowed": "0.00000000",
        //                         "available": "0.00000000",
        //                         "frozen": "0.00000000",
        //                         "net_asset": "0.00000000",
        //                         "net_assetBTC": "0.00000000",
        //                         "total_asset": "0.00000000",
        //                         "borrow_unpaid": "0.00000000",
        //                         "interest_unpaid": "0.00000000"
        //                     },
        //                     "quote": {
        //                         "currency": "USDT",
        //                         "borrow_enabled": true,
        //                         "borrowed": "0.00000000",
        //                         "available": "20.00000000",
        //                         "frozen": "0.00000000",
        //                         "net_asset": "20.00000000",
        //                         "net_assetBTC": "0.00118008",
        //                         "total_asset": "20.00000000",
        //                         "borrow_unpaid": "0.00000000",
        //                         "interest_unpaid": "0.00000000"
        //                     }
        //                 }
        //             ]
        //         }
        //     }
        //
        return this.parseBalance(response, marketType);
    }

    public virtual object parseTradingFee(object fee, object market = null)
    {
        //
        //     {
        //         symbol: 'ETH_USDT',
        //         taker_fee_rate: '0.0025',
        //         maker_fee_rate: '0.0025'
        //     }
        //
        object marketId = this.safeString(fee, "symbol");
        object symbol = this.safeSymbol(marketId);
        return new Dictionary<string, object>() {
            { "info", fee },
            { "symbol", symbol },
            { "maker", this.safeNumber(fee, "maker_fee_rate") },
            { "taker", this.safeNumber(fee, "taker_fee_rate") },
        };
    }

    public async override Task<object> fetchTradingFee(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchTradingFee
        * @description fetch the trading fees for a market
        * @param {string} symbol unified market symbol
        * @param {object} params extra parameters specific to the bitmart api endpoint
        * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchTradingFee() does not support "), getValue(market, "type")), " orders, only spot orders are accepted")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.privateGetSpotV1TradeFee(this.extend(request, parameters));
        //
        //     {
        //         message: 'OK',
        //         code: '1000',
        //         trace: '5a6f1e40-37fe-4849-a494-03279fadcc62',
        //         data: {
        //             symbol: 'ETH_USDT',
        //             taker_fee_rate: '0.0025',
        //             maker_fee_rate: '0.0025'
        //         }
        //     }
        //
        object data = this.safeValue(response, "data");
        return this.parseTradingFee(data);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // createOrder
        //
        //     {
        //         "order_id": 2707217580
        //     }
        //
        // cancelOrder
        //
        //     '2707217580' // order id
        //
        // spot fetchOrder, fetchOrdersByStatus, fetchOpenOrders, fetchClosedOrders
        //
        //     {
        //         "order_id":1736871726781,
        //         "symbol":"BTC_USDT",
        //         "create_time":1591096004000,
        //         "side":"sell",
        //         "type":"market", // limit, market, limit_maker, ioc
        //         "price":"0.00",
        //         "price_avg":"0.00",
        //         "size":"0.02000",
        //         "notional":"0.00000000",
        //         "filled_notional":"0.00000000",
        //         "filled_size":"0.00000",
        //         "status":"8"
        //     }
        //
        object id = null;
        if (isTrue(((order).GetType() == typeof(string))))
        {
            id = order;
            order = new Dictionary<string, object>() {};
        }
        id = this.safeString(order, "order_id", id);
        object timestamp = this.safeInteger(order, "create_time");
        object marketId = this.safeString(order, "symbol");
        object symbol = this.safeSymbol(marketId, market, "_");
        object status = null;
        if (isTrue(!isEqual(market, null)))
        {
            status = this.parseOrderStatusByType(getValue(market, "type"), this.safeString(order, "status"));
        }
        object amount = this.safeString(order, "size");
        object filled = this.safeString(order, "filled_size");
        object average = this.safeString(order, "price_avg");
        object price = this.safeString(order, "price");
        object side = this.safeString(order, "side");
        object type = this.safeString(order, "type");
        object timeInForce = null;
        object postOnly = null;
        if (isTrue(isEqual(type, "limit_maker")))
        {
            type = "limit";
            postOnly = true;
            timeInForce = "PO";
        }
        if (isTrue(isEqual(type, "ioc")))
        {
            type = "limit";
            timeInForce = "IOC";
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", id },
            { "clientOrderId", null },
            { "info", order },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "symbol", symbol },
            { "type", type },
            { "timeInForce", timeInForce },
            { "postOnly", postOnly },
            { "side", side },
            { "price", price },
            { "stopPrice", null },
            { "triggerPrice", null },
            { "amount", amount },
            { "cost", null },
            { "average", average },
            { "filled", filled },
            { "remaining", null },
            { "status", status },
            { "fee", null },
            { "trades", null },
        }, market);
    }

    public virtual object parseOrderStatusByType(object type, object status)
    {
        object statusesByType = new Dictionary<string, object>() {
            { "spot", new Dictionary<string, object>() {
                { "1", "failed" },
                { "2", "open" },
                { "3", "failed" },
                { "4", "open" },
                { "5", "open" },
                { "6", "closed" },
                { "7", "canceling" },
                { "8", "canceled" },
            } },
            { "swap", new Dictionary<string, object>() {
                { "1", "open" },
                { "2", "open" },
                { "4", "closed" },
            } },
        };
        object statuses = this.safeValue(statusesByType, type, new Dictionary<string, object>() {});
        return this.safeString(statuses, status, status);
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#createOrder
        * @description create a trade order
        * @see https://developer-pro.bitmart.com/en/spot/#place-spot-order
        * @see https://developer-pro.bitmart.com/en/spot/#place-margin-order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float|undefined} price the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} params extra parameters specific to the bitmart api endpoint
        * @param {string|undefined} params.marginMode 'cross' or 'isolated'
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {};
        object timeInForce = this.safeString(parameters, "timeInForce");
        if (isTrue(isEqual(timeInForce, "FOK")))
        {
            throw new InvalidOrder ((string)add(this.id, " createOrder() only accepts timeInForce parameter values of IOC or PO")) ;
        }
        object mode = this.safeInteger(parameters, "mode"); // only for swap
        object isMarketOrder = isEqual(type, "market");
        object postOnly = null;
        object isExchangeSpecificPo = isTrue((isEqual(type, "limit_maker"))) || isTrue((isEqual(mode, 4)));
        var postOnlyparametersVariable = this.handlePostOnly(isMarketOrder, isExchangeSpecificPo, parameters);
        postOnly = ((List<object>)postOnlyparametersVariable)[0];
        parameters = ((List<object>)postOnlyparametersVariable)[1];
        parameters = this.omit(parameters, new List<object>() {"timeInForce", "postOnly"});
        object ioc = (isTrue((isEqual(timeInForce, "IOC"))) || isTrue((isEqual(type, "ioc"))));
        object isLimitOrder = isTrue(isTrue((isEqual(type, "limit"))) || isTrue(postOnly)) || isTrue(ioc);
        object method = null;
        if (isTrue(getValue(market, "spot")))
        {
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
            ((Dictionary<string, object>)request)["side"] = side;
            ((Dictionary<string, object>)request)["type"] = type;
            method = "privatePostSpotV2SubmitOrder";
            if (isTrue(isLimitOrder))
            {
                ((Dictionary<string, object>)request)["size"] = this.amountToPrecision(symbol, amount);
                ((Dictionary<string, object>)request)["price"] = this.priceToPrecision(symbol, price);
            } else if (isTrue(isMarketOrder))
            {
                // for market buy it requires the amount of quote currency to spend
                if (isTrue(isEqual(side, "buy")))
                {
                    object notional = this.safeNumber(parameters, "notional");
                    object createMarketBuyOrderRequiresPrice = this.safeValue(this.options, "createMarketBuyOrderRequiresPrice", true);
                    if (isTrue(createMarketBuyOrderRequiresPrice))
                    {
                        if (isTrue(!isEqual(price, null)))
                        {
                            if (isTrue(isEqual(notional, null)))
                            {
                                object amountString = this.numberToString(amount);
                                object priceString = this.numberToString(price);
                                notional = this.parseNumber(Precise.stringMul(amountString, priceString));
                            }
                        } else if (isTrue(isEqual(notional, null)))
                        {
                            throw new InvalidOrder ((string)add(this.id, " createOrder () requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options[\'createMarketBuyOrderRequiresPrice\'] = false and supply the total cost value in the \'amount\' argument or in the \'notional\' extra parameter (the exchange-specific behaviour)")) ;
                        }
                    } else
                    {
                        notional = ((bool) isTrue((isEqual(notional, null)))) ? amount : notional;
                    }
                    ((Dictionary<string, object>)request)["notional"] = this.decimalToPrecision(notional, TRUNCATE, getValue(getValue(market, "precision"), "price"), this.precisionMode);
                } else if (isTrue(isEqual(side, "sell")))
                {
                    ((Dictionary<string, object>)request)["size"] = this.amountToPrecision(symbol, amount);
                }
            }
        } else if (isTrue(getValue(market, "swap")))
        {
            throw new NotSupported ((string)add(this.id, " createOrder() does not accept swap orders, only spot orders are allowed")) ;
        }
        if (isTrue(postOnly))
        {
            ((Dictionary<string, object>)request)["type"] = "limit_maker";
        }
        if (isTrue(ioc))
        {
            ((Dictionary<string, object>)request)["type"] = "ioc";
        }
        var marginModequeryVariable = this.handleMarginModeAndParams("createOrder", parameters);
        var marginMode = ((List<object>) marginModequeryVariable)[0];
        var query = ((List<object>) marginModequeryVariable)[1];
        if (isTrue(!isEqual(marginMode, null)))
        {
            method = "privatePostSpotV1MarginSubmitOrder";
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        //
        // spot and margin
        //
        //     {
        //         "code": 1000,
        //         "trace":"886fb6ae-456b-4654-b4e0-d681ac05cea1",
        //         "message": "OK",
        //         "data": {
        //             "order_id": 2707217580
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object order = this.parseOrder(data, market);
        return this.extend(order, new Dictionary<string, object>() {
            { "type", type },
            { "side", side },
            { "amount", amount },
            { "price", price },
        });
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#cancelOrder
        * @description cancels an open order
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} params extra parameters specific to the bitmart api endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(add(add(this.id, " cancelOrder() does not support "), getValue(market, "type")), " orders, only spot orders are accepted")) ;
        }
        object request = new Dictionary<string, object>() {
            { "order_id", ((object)id).ToString() },
            { "symbol", getValue(market, "id") },
        };
        object response = await this.privatePostSpotV3CancelOrder(this.extend(request, parameters));
        //
        // spot
        //
        //     {
        //         "code": 1000,
        //         "trace":"886fb6ae-456b-4654-b4e0-d681ac05cea1",
        //         "message": "OK",
        //         "data": {
        //             "result": true
        //         }
        //     }
        //
        // spot alternative
        //
        //     {
        //         "code": 1000,
        //         "trace":"886fb6ae-456b-4654-b4e0-d681ac05cea1",
        //         "message": "OK",
        //         "data": true
        //     }
        //
        object data = this.safeValue(response, "data");
        if (isTrue(isEqual(data, true)))
        {
            return this.parseOrder(id, market);
        }
        object succeeded = this.safeValue(data, "succeed");
        if (isTrue(!isEqual(succeeded, null)))
        {
            id = this.safeString(succeeded, 0);
            if (isTrue(isEqual(id, null)))
            {
                throw new InvalidOrder ((string)add(add(add(add(this.id, " cancelOrder() failed to cancel "), symbol), " order id "), id)) ;
            }
        } else
        {
            object result = this.safeValue(data, "result");
            if (!isTrue(result))
            {
                throw new InvalidOrder ((string)add(add(add(add(add(this.id, " cancelOrder() "), symbol), " order id "), id), " is filled or canceled")) ;
            }
        }
        object order = this.parseOrder(id, market);
        return this.extend(order, new Dictionary<string, object>() {
            { "id", id },
        });
    }

    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#cancelAllOrders
        * @description cancel all open orders in a market
        * @see https://developer-pro.bitmart.com/en/spot/#cancel-all-orders
        * @param {string} symbol unified market symbol of the market to cancel orders in
        * @param {object} params extra parameters specific to the bitmart api endpoint
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
        }
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("cancelAllOrders", market, parameters);
        type = ((List<object>)typeparametersVariable)[0];
        parameters = ((List<object>)typeparametersVariable)[1];
        if (isTrue(!isEqual(type, "spot")))
        {
            throw new NotSupported ((string)add(add(add(this.id, " cancelAllOrders() does not support "), type), " orders, only spot orders are accepted")) ;
        }
        object side = this.safeString(parameters, "side");
        if (isTrue(!isEqual(side, null)))
        {
            ((Dictionary<string, object>)request)["side"] = side;
            parameters = this.omit(parameters, "side");
        }
        object response = await this.privatePostSpotV1CancelOrders(this.extend(request, parameters));
        //
        //     {
        //         "code": 1000,
        //         "trace":"886fb6ae-456b-4654-b4e0-d681ac05cea1",
        //         "message": "OK",
        //         "data": {}
        //     }
        //
        return response;
    }

    public async virtual Task<object> fetchOrdersByStatus(object status, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOrdersByStatus() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchOrdersByStatus() does not support "), getValue(market, "type")), " orders, only spot orders are accepted")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "offset", 1 },
            { "N", 100 },
        };
        if (isTrue(isEqual(status, "open")))
        {
            ((Dictionary<string, object>)request)["status"] = 9;
        } else if (isTrue(isEqual(status, "closed")))
        {
            ((Dictionary<string, object>)request)["status"] = 6;
        } else if (isTrue(isEqual(status, "canceled")))
        {
            ((Dictionary<string, object>)request)["status"] = 8;
        } else
        {
            ((Dictionary<string, object>)request)["status"] = status;
        }
        object response = await this.privateGetSpotV3Orders(this.extend(request, parameters));
        //
        // spot
        //
        //     {
        //         "message":"OK",
        //         "code":1000,
        //         "trace":"70e7d427-7436-4fb8-8cdd-97e1f5eadbe9",
        //         "data":{
        //             "current_page":1,
        //             "orders":[
        //                 {
        //                     "order_id":2147601241,
        //                     "symbol":"BTC_USDT",
        //                     "create_time":1591099963000,
        //                     "side":"sell",
        //                     "type":"limit",
        //                     "price":"9000.00",
        //                     "price_avg":"0.00",
        //                     "size":"1.00000",
        //                     "notional":"9000.00000000",
        //                     "filled_notional":"0.00000000",
        //                     "filled_size":"0.00000",
        //                     "status":"4"
        //                 }
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object orders = this.safeValue(data, "orders", new List<object>() {});
        return this.parseOrders(orders, market, since, limit);
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchOpenOrders
        * @description fetch all unfilled currently open orders
        * @param {string} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch open orders for
        * @param {int|undefined} limit the maximum number of  open orders structures to retrieve
        * @param {object} params extra parameters specific to the bitmart api endpoint
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.fetchOrdersByStatus("open", symbol, since, limit, parameters);
    }

    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchClosedOrders
        * @description fetches information on multiple closed orders made by the user
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int|undefined} since the earliest time in ms to fetch orders for
        * @param {int|undefined} limit the maximum number of  orde structures to retrieve
        * @param {object} params extra parameters specific to the bitmart api endpoint
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.fetchOrdersByStatus("closed", symbol, since, limit, parameters);
    }

    public async virtual Task<object> fetchCanceledOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchCanceledOrders
        * @description fetches information on multiple canceled orders made by the user
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int|undefined} since timestamp in ms of the earliest order, default is undefined
        * @param {int|undefined} limit max number of orders to return, default is undefined
        * @param {object} params extra parameters specific to the bitmart api endpoint
        * @returns {object} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.fetchOrdersByStatus("canceled", symbol, since, limit, parameters);
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchOrder
        * @description fetches information on an order made by the user
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} params extra parameters specific to the bitmart api endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchOrder() does not support "), getValue(market, "type")), " orders, only spot orders are accepted")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "order_id", id },
        };
        object response = await this.privateGetSpotV2OrderDetail(this.extend(request, parameters));
        //
        // spot
        //
        //     {
        //         "message":"OK",
        //         "code":1000,
        //         "trace":"a27c2cb5-ead4-471d-8455-1cfeda054ea6",
        //         "data": {
        //             "order_id":1736871726781,
        //             "symbol":"BTC_USDT",
        //             "create_time":1591096004000,
        //             "side":"sell",
        //             "type":"market",
        //             "price":"0.00",
        //             "price_avg":"0.00",
        //             "size":"0.02000",
        //             "notional":"0.00000000",
        //             "filled_notional":"0.00000000",
        //             "filled_size":"0.00000",
        //             "status":"8"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(data, market);
    }

    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchDepositAddress
        * @description fetch the deposit address for a currency associated with this account
        * @param {string} code unified currency code
        * @param {object} params extra parameters specific to the bitmart api endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        if (isTrue(isEqual(code, "USDT")))
        {
            object defaultNetworks = this.safeValue(this.options, "defaultNetworks");
            object defaultNetwork = this.safeStringUpper(defaultNetworks, code);
            object networks = this.safeValue(this.options, "networks", new Dictionary<string, object>() {});
            object networkInner = this.safeStringUpper(parameters, "network", defaultNetwork); // this line allows the user to specify either ERC20 or ETH
            networkInner = this.safeString(networks, networkInner, networkInner); // handle ERC20>ETH alias
            if (isTrue(!isEqual(networkInner, null)))
            {
                ((Dictionary<string, object>)request)["currency"] = add(add(getValue(request, "currency"), "-"), networkInner); // when network the currency need to be changed to currency + '-' + network https://developer-pro.bitmart.com/en/account/withdraw_apply.html on the end of page
                parameters = this.omit(parameters, "network");
            }
        }
        object response = await this.privateGetAccountV1DepositAddress(this.extend(request, parameters));
        //
        //     {
        //         "message":"OK",
        //         "code":1000,
        //         "trace":"0e6edd79-f77f-4251-abe5-83ba75d06c1a",
        //         "data":{
        //             "currency":"USDT-TRC20",
        //             "chain":"USDT-TRC20",
        //             "address":"TGR3ghy2b5VLbyAYrmiE15jasR6aPHTvC5",
        //             "address_memo":""
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object address = this.safeString(data, "address");
        object tag = this.safeString(data, "address_memo");
        object chain = this.safeString(data, "chain");
        object network = null;
        if (isTrue(!isEqual(chain, null)))
        {
            object parts = ((string)chain).Split((string)"-").ToList<object>();
            object networkId = this.safeString(parts, 1);
            network = this.safeNetwork(networkId);
        }
        this.checkAddress(address);
        return new Dictionary<string, object>() {
            { "currency", code },
            { "address", address },
            { "tag", tag },
            { "network", network },
            { "info", response },
        };
    }

    public virtual object safeNetwork(object networkId)
    {
        // TODO: parse
        return networkId;
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#withdraw
        * @description make a withdrawal
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string|undefined} tag
        * @param {object} params extra parameters specific to the bitmart api endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((List<object>)tagparametersVariable)[0];
        parameters = ((List<object>)tagparametersVariable)[1];
        this.checkAddress(address);
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "amount", amount },
            { "destination", "To Digital Address" },
            { "address", address },
        };
        if (isTrue(!isEqual(tag, null)))
        {
            ((Dictionary<string, object>)request)["address_memo"] = tag;
        }
        if (isTrue(isEqual(code, "USDT")))
        {
            object defaultNetworks = this.safeValue(this.options, "defaultNetworks");
            object defaultNetwork = this.safeStringUpper(defaultNetworks, code);
            object networks = this.safeValue(this.options, "networks", new Dictionary<string, object>() {});
            object network = this.safeStringUpper(parameters, "network", defaultNetwork); // this line allows the user to specify either ERC20 or ETH
            network = this.safeString(networks, network, network); // handle ERC20>ETH alias
            if (isTrue(!isEqual(network, null)))
            {
                ((Dictionary<string, object>)request)["currency"] = add(add(getValue(request, "currency"), "-"), network); // when network the currency need to be changed to currency + '-' + network https://developer-pro.bitmart.com/en/account/withdraw_apply.html on the end of page
                parameters = this.omit(parameters, "network");
            }
        }
        object response = await this.privatePostAccountV1WithdrawApply(this.extend(request, parameters));
        //
        //     {
        //         "code": 1000,
        //         "trace":"886fb6ae-456b-4654-b4e0-d681ac05cea1",
        //         "message": "OK",
        //         "data": {
        //             "withdraw_id": "121212"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data");
        object transaction = this.parseTransaction(data, currency);
        return this.extend(transaction, new Dictionary<string, object>() {
            { "code", code },
            { "address", address },
            { "tag", tag },
        });
    }

    public async virtual Task<object> fetchTransactionsByType(object type, object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(limit, null)))
        {
            limit = 50; // max 50
        }
        object request = new Dictionary<string, object>() {
            { "operation_type", type },
            { "offset", 1 },
            { "N", limit },
        };
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((Dictionary<string, object>)request)["currency"] = getValue(currency, "id");
        }
        if (isTrue(isEqual(code, "USDT")))
        {
            object defaultNetworks = this.safeValue(this.options, "defaultNetworks");
            object defaultNetwork = this.safeStringUpper(defaultNetworks, code);
            object networks = this.safeValue(this.options, "networks", new Dictionary<string, object>() {});
            object network = this.safeStringUpper(parameters, "network", defaultNetwork); // this line allows the user to specify either ERC20 or ETH
            network = this.safeString(networks, network, network); // handle ERC20>ETH alias
            if (isTrue(!isEqual(network, null)))
            {
                ((Dictionary<string, object>)request)["currency"] = add(((Dictionary<string, object>)request)["currency"], add("-", network)); // when network the currency need to be changed to currency + '-' + network https://developer-pro.bitmart.com/en/account/withdraw_apply.html on the end of page
                ((Dictionary<string, object>)currency)["code"] = getValue(request, "currency"); // update currency code to filter
                parameters = this.omit(parameters, "network");
            }
        }
        object response = await this.privateGetAccountV2DepositWithdrawHistory(this.extend(request, parameters));
        //
        //     {
        //         "message":"OK",
        //         "code":1000,
        //         "trace":"142bf92a-fc50-4689-92b6-590886f90b97",
        //         "data":{
        //             "records":[
        //                 {
        //                     "withdraw_id":"1679952",
        //                     "deposit_id":"",
        //                     "operation_type":"withdraw",
        //                     "currency":"BMX",
        //                     "apply_time":1588867374000,
        //                     "arrival_amount":"59.000000000000",
        //                     "fee":"1.000000000000",
        //                     "status":0,
        //                     "address":"0xe57b69a8776b37860407965B73cdFFBDFe668Bb5",
        //                     "address_memo":"",
        //                     "tx_id":""
        //                 },
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object records = this.safeValue(data, "records", new List<object>() {});
        return this.parseTransactions(records, currency, since, limit);
    }

    public async virtual Task<object> fetchDeposit(object id, object code = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchDeposit
        * @description fetch information on a deposit
        * @param {string} id deposit id
        * @param {string|undefined} code not used by bitmart fetchDeposit ()
        * @param {object} params extra parameters specific to the bitmart api endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "id", id },
        };
        object response = await this.privateGetAccountV1DepositWithdrawDetail(this.extend(request, parameters));
        //
        //     {
        //         "message":"OK",
        //         "code":1000,
        //         "trace":"f7f74924-14da-42a6-b7f2-d3799dd9a612",
        //         "data":{
        //             "record":{
        //                 "withdraw_id":"",
        //                 "deposit_id":"1679952",
        //                 "operation_type":"deposit",
        //                 "currency":"BMX",
        //                 "apply_time":1588867374000,
        //                 "arrival_amount":"59.000000000000",
        //                 "fee":"1.000000000000",
        //                 "status":0,
        //                 "address":"0xe57b69a8776b37860407965B73cdFFBDFe668Bb5",
        //                 "address_memo":"",
        //                 "tx_id":""
        //             }
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object record = this.safeValue(data, "record", new Dictionary<string, object>() {});
        return this.parseTransaction(record);
    }

    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchDeposits
        * @description fetch all deposits made to an account
        * @param {string|undefined} code unified currency code
        * @param {int|undefined} since the earliest time in ms to fetch deposits for
        * @param {int|undefined} limit the maximum number of deposits structures to retrieve
        * @param {object} params extra parameters specific to the bitmart api endpoint
        * @returns {[object]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.fetchTransactionsByType("deposit", code, since, limit, parameters);
    }

    public async virtual Task<object> fetchWithdrawal(object id, object code = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchWithdrawal
        * @description fetch data on a currency withdrawal via the withdrawal id
        * @param {string} id withdrawal id
        * @param {string|undefined} code not used by bitmart.fetchWithdrawal
        * @param {object} params extra parameters specific to the bitmart api endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "id", id },
        };
        object response = await this.privateGetAccountV1DepositWithdrawDetail(this.extend(request, parameters));
        //
        //     {
        //         "message":"OK",
        //         "code":1000,
        //         "trace":"f7f74924-14da-42a6-b7f2-d3799dd9a612",
        //         "data":{
        //             "record":{
        //                 "withdraw_id":"1679952",
        //                 "deposit_id":"",
        //                 "operation_type":"withdraw",
        //                 "currency":"BMX",
        //                 "apply_time":1588867374000,
        //                 "arrival_amount":"59.000000000000",
        //                 "fee":"1.000000000000",
        //                 "status":0,
        //                 "address":"0xe57b69a8776b37860407965B73cdFFBDFe668Bb5",
        //                 "address_memo":"",
        //                 "tx_id":""
        //             }
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object record = this.safeValue(data, "record", new Dictionary<string, object>() {});
        return this.parseTransaction(record);
    }

    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchWithdrawals
        * @description fetch all withdrawals made from an account
        * @param {string|undefined} code unified currency code
        * @param {int|undefined} since the earliest time in ms to fetch withdrawals for
        * @param {int|undefined} limit the maximum number of withdrawals structures to retrieve
        * @param {object} params extra parameters specific to the bitmart api endpoint
        * @returns {[object]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.fetchTransactionsByType("withdraw", code, since, limit, parameters);
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "0", "pending" },
            { "1", "pending" },
            { "2", "pending" },
            { "3", "ok" },
            { "4", "canceled" },
            { "5", "failed" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // withdraw
        //
        //     {
        //         "withdraw_id": "121212"
        //     }
        //
        // fetchDeposits, fetchWithdrawals, fetchWithdrawal
        //
        //     {
        //         "withdraw_id":"1679952",
        //         "deposit_id":"",
        //         "operation_type":"withdraw",
        //         "currency":"BMX",
        //         "apply_time":1588867374000,
        //         "arrival_amount":"59.000000000000",
        //         "fee":"1.000000000000",
        //         "status":0,
        //         "address":"0xe57b69a8776b37860407965B73cdFFBDFe668Bb5",
        //         "address_memo":"",
        //         "tx_id":""
        //     }
        //
        object id = null;
        object withdrawId = this.safeString(transaction, "withdraw_id");
        object depositId = this.safeString(transaction, "deposit_id");
        object type = null;
        if (isTrue(isTrue((!isEqual(withdrawId, null))) && isTrue((!isEqual(withdrawId, "")))))
        {
            type = "withdraw";
            id = withdrawId;
        } else if (isTrue(isTrue((!isEqual(depositId, null))) && isTrue((!isEqual(depositId, "")))))
        {
            type = "deposit";
            id = depositId;
        }
        object amount = this.safeNumber(transaction, "arrival_amount");
        object timestamp = this.safeInteger(transaction, "apply_time");
        object currencyId = this.safeString(transaction, "currency");
        object code = this.safeCurrencyCode(currencyId, currency);
        object status = this.parseTransactionStatus(this.safeString(transaction, "status"));
        object feeCost = this.safeNumber(transaction, "fee");
        object fee = null;
        if (isTrue(!isEqual(feeCost, null)))
        {
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", code },
            };
        }
        object txid = this.safeString(transaction, "tx_id");
        object address = this.safeString(transaction, "address");
        object tag = this.safeString(transaction, "address_memo");
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", id },
            { "currency", code },
            { "amount", amount },
            { "network", null },
            { "address", address },
            { "addressFrom", null },
            { "addressTo", null },
            { "tag", tag },
            { "tagFrom", null },
            { "tagTo", null },
            { "status", status },
            { "type", type },
            { "updated", null },
            { "txid", txid },
            { "timestamp", ((bool) isTrue((!isEqual(timestamp, 0)))) ? timestamp : null },
            { "datetime", ((bool) isTrue((!isEqual(timestamp, 0)))) ? this.iso8601(timestamp) : null },
            { "fee", fee },
        };
    }

    public async virtual Task<object> repayMargin(object code, object amount, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#repayMargin
        * @description repay borrowed margin and interest
        * @see https://developer-pro.bitmart.com/en/spot/#margin-repay-isolated
        * @param {string} code unified currency code of the currency to repay
        * @param {string} amount the amount to repay
        * @param {string} symbol unified market symbol
        * @param {object} params extra parameters specific to the bitmart api endpoint
        * @param {string|undefined} params.marginMode 'isolated' is the default and 'cross' is unavailable
        * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " repayMargin() requires a symbol argument")) ;
        }
        object market = this.market(symbol);
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "currency", getValue(currency, "id") },
            { "amount", this.currencyToPrecision(code, amount) },
        };
        parameters = this.omit(parameters, "marginMode");
        object response = await this.privatePostSpotV1MarginIsolatedRepay(this.extend(request, parameters));
        //
        //     {
        //         "message": "OK",
        //         "code": 1000,
        //         "trace": "b0a60b4c-e986-4b54-a190-8f7c05ddf685",
        //         "data": {
        //             "repay_id": "2afcc16d99bd4707818c5a355dc89bed"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object transaction = this.parseMarginLoan(data, currency);
        return this.extend(transaction, new Dictionary<string, object>() {
            { "amount", amount },
            { "symbol", symbol },
        });
    }

    public async virtual Task<object> borrowMargin(object code, object amount, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#borrowMargin
        * @description create a loan to borrow margin
        * @see https://developer-pro.bitmart.com/en/spot/#margin-borrow-isolated
        * @param {string} code unified currency code of the currency to borrow
        * @param {string} amount the amount to borrow
        * @param {string} symbol unified market symbol
        * @param {object} params extra parameters specific to the bitmart api endpoint
        * @param {string|undefined} params.marginMode 'isolated' is the default and 'cross' is unavailable
        * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " borrowMargin() requires a symbol argument")) ;
        }
        object market = this.market(symbol);
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "currency", getValue(currency, "id") },
            { "amount", this.currencyToPrecision(code, amount) },
        };
        parameters = this.omit(parameters, "marginMode");
        object response = await this.privatePostSpotV1MarginIsolatedBorrow(this.extend(request, parameters));
        //
        //     {
        //         "message": "OK",
        //         "code": 1000,
        //         "trace": "e6fda683-181e-4e78-ac9c-b27c4c8ba035",
        //         "data": {
        //             "borrow_id": "629a7177a4ed4cf09869c6a4343b788c"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object transaction = this.parseMarginLoan(data, currency);
        return this.extend(transaction, new Dictionary<string, object>() {
            { "amount", amount },
            { "symbol", symbol },
        });
    }

    public virtual object parseMarginLoan(object info, object currency = null)
    {
        //
        // borrowMargin
        //
        //     {
        //         "borrow_id": "629a7177a4ed4cf09869c6a4343b788c",
        //     }
        //
        // repayMargin
        //
        //     {
        //         "repay_id": "2afcc16d99bd4707818c5a355dc89bed",
        //     }
        //
        object timestamp = this.milliseconds();
        return new Dictionary<string, object>() {
            { "id", this.safeString2(info, "borrow_id", "repay_id") },
            { "currency", this.safeCurrencyCode(null, currency) },
            { "amount", null },
            { "symbol", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", info },
        };
    }

    public async override Task<object> fetchBorrowRate(object code, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchBorrowRate
        * @description fetch the rate of interest to borrow a currency for margin trading
        * @see https://developer-pro.bitmart.com/en/spot/#get-trading-pair-borrowing-rate-and-amount
        * @param {string} code unified currency code
        * @param {object} params extra parameters specific to the bitmart api endpoint
        * @returns {object} a [borrow rate structure]{@link https://docs.ccxt.com/#/?id=borrow-rate-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(((Dictionary<string,object>)this.markets).ContainsKey(toStringOrNull(code))))
        {
            market = this.market(code);
        } else
        {
            object defaultSettle = this.safeString(this.options, "defaultSettle", "USDT");
            if (isTrue(isEqual(code, "USDT")))
            {
                market = this.market(add(add("BTC", "/"), defaultSettle));
            } else
            {
                market = this.market(add(add(code, "/"), defaultSettle));
            }
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.privateGetSpotV1MarginIsolatedPairs(this.extend(request, parameters));
        //
        //     {
        //         "message": "OK",
        //         "code": 1000,
        //         "trace": "0985a130-a5ae-4fc1-863f-4704e214f585",
        //         "data": {
        //             "symbols": [
        //                 {
        //                     "symbol": "BTC_USDT",
        //                     "max_leverage": "5",
        //                     "symbol_enabled": true,
        //                     "base": {
        //                         "currency": "BTC",
        //                         "daily_interest": "0.00055000",
        //                         "hourly_interest": "0.00002291",
        //                         "max_borrow_amount": "2.00000000",
        //                         "min_borrow_amount": "0.00000001",
        //                         "borrowable_amount": "0.00670810"
        //                     },
        //                     "quote": {
        //                         "currency": "USDT",
        //                         "daily_interest": "0.00055000",
        //                         "hourly_interest": "0.00002291",
        //                         "max_borrow_amount": "50000.00000000",
        //                         "min_borrow_amount": "0.00000001",
        //                         "borrowable_amount": "135.12575038"
        //                     }
        //                 }
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object symbols = this.safeValue(data, "symbols", new List<object>() {});
        object currency = ((bool) isTrue((isEqual(code, "USDT")))) ? getValue(market, "quote") : getValue(market, "base");
        return this.parseBorrowRate(symbols, currency);
    }

    public virtual object parseBorrowRate(object info, object currency = null)
    {
        //
        //     {
        //         "symbol": "BTC_USDT",
        //         "max_leverage": "5",
        //         "symbol_enabled": true,
        //         "base": {
        //             "currency": "BTC",
        //             "daily_interest": "0.00055000",
        //             "hourly_interest": "0.00002291",
        //             "max_borrow_amount": "2.00000000",
        //             "min_borrow_amount": "0.00000001",
        //             "borrowable_amount": "0.00670810"
        //         },
        //         "quote": {
        //             "currency": "USDT",
        //             "daily_interest": "0.00055000",
        //             "hourly_interest": "0.00002291",
        //             "max_borrow_amount": "50000.00000000",
        //             "min_borrow_amount": "0.00000001",
        //             "borrowable_amount": "135.12575038"
        //         }
        //     }
        //
        object timestamp = this.milliseconds();
        object currencyData = ((bool) isTrue((isEqual(currency, "USDT")))) ? this.safeValue(getValue(info, 0), "quote", new Dictionary<string, object>() {}) : this.safeValue(getValue(info, 0), "base", new Dictionary<string, object>() {});
        return new Dictionary<string, object>() {
            { "currency", this.safeCurrencyCode(currency) },
            { "rate", this.safeNumber(currencyData, "hourly_interest") },
            { "period", 3600000 },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", info },
        };
    }

    public async override Task<object> fetchBorrowRates(object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchBorrowRates
        * @description fetch the borrow interest rates of all currencies, currently only works for isolated margin
        * @see https://developer-pro.bitmart.com/en/spot/#get-trading-pair-borrowing-rate-and-amount
        * @param {object} params extra parameters specific to the bitmart api endpoint
        * @returns {object} a list of [borrow rate structures]{@link https://docs.ccxt.com/#/?id=borrow-rate-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetSpotV1MarginIsolatedPairs(parameters);
        //
        //     {
        //         "message": "OK",
        //         "code": 1000,
        //         "trace": "0985a130-a5ae-4fc1-863f-4704e214f585",
        //         "data": {
        //             "symbols": [
        //                 {
        //                     "symbol": "BTC_USDT",
        //                     "max_leverage": "5",
        //                     "symbol_enabled": true,
        //                     "base": {
        //                         "currency": "BTC",
        //                         "daily_interest": "0.00055000",
        //                         "hourly_interest": "0.00002291",
        //                         "max_borrow_amount": "2.00000000",
        //                         "min_borrow_amount": "0.00000001",
        //                         "borrowable_amount": "0.00670810"
        //                     },
        //                     "quote": {
        //                         "currency": "USDT",
        //                         "daily_interest": "0.00055000",
        //                         "hourly_interest": "0.00002291",
        //                         "max_borrow_amount": "50000.00000000",
        //                         "min_borrow_amount": "0.00000001",
        //                         "borrowable_amount": "135.12575038"
        //                     }
        //                 }
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object symbols = this.safeValue(data, "symbols", new List<object>() {});
        return this.parseBorrowRates(symbols, null);
    }

    public virtual object parseBorrowRates(object info, object codeKey)
    {
        //
        //     {
        //         "symbol": "BTC_USDT",
        //         "max_leverage": "5",
        //         "symbol_enabled": true,
        //         "base": {
        //             "currency": "BTC",
        //             "daily_interest": "0.00055000",
        //             "hourly_interest": "0.00002291",
        //             "max_borrow_amount": "2.00000000",
        //             "min_borrow_amount": "0.00000001",
        //             "borrowable_amount": "0.00670810"
        //         },
        //         "quote": {
        //             "currency": "USDT",
        //             "daily_interest": "0.00055000",
        //             "hourly_interest": "0.00002291",
        //             "max_borrow_amount": "50000.00000000",
        //             "min_borrow_amount": "0.00000001",
        //             "borrowable_amount": "135.12575038"
        //         }
        //     }
        //
        object timestamp = this.milliseconds();
        object rates = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(info)); postFixIncrement(ref i))
        {
            object entry = getValue(info, i);
            object bs = this.safeValue(entry, "base", new Dictionary<string, object>() {});
            ((List<object>)rates).Add(new Dictionary<string, object>() {
                { "currency", this.safeCurrencyCode(this.safeString(bs, "currency")) },
                { "rate", this.safeNumber(bs, "hourly_interest") },
                { "period", 3600000 },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
                { "info", entry },
            });
        }
        return rates;
    }

    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#transfer
        * @description transfer currency internally between wallets on the same account, currently only supports transfer between spot and margin
        * @see https://developer-pro.bitmart.com/en/spot/#margin-asset-transfer
        * @param {string} code unified currency code
        * @param {float} amount amount to transfer
        * @param {string} fromAccount account to transfer from
        * @param {string} toAccount account to transfer to
        * @param {object} params extra parameters specific to the bitmart api endpoint
        * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object amountToPrecision = this.currencyToPrecision(code, amount);
        object request = new Dictionary<string, object>() {
            { "amount", amountToPrecision },
            { "currency", getValue(currency, "id") },
        };
        object fromId = this.convertTypeToAccount(fromAccount);
        object toId = this.convertTypeToAccount(toAccount);
        if (isTrue(isEqual(fromAccount, "spot")))
        {
            ((Dictionary<string, object>)request)["side"] = "in";
            ((Dictionary<string, object>)request)["symbol"] = toId;
        } else if (isTrue(isEqual(toAccount, "spot")))
        {
            ((Dictionary<string, object>)request)["side"] = "out";
            ((Dictionary<string, object>)request)["symbol"] = fromId;
        } else
        {
            throw new ArgumentsRequired ((string)add(this.id, " transfer() requires either fromAccount or toAccount to be spot")) ;
        }
        object response = await this.privatePostSpotV1MarginIsolatedTransfer(this.extend(request, parameters));
        //
        //     {
        //         "message": "OK",
        //         "code": 1000,
        //         "trace": "b26cecec-ef5a-47d9-9531-2bd3911d3d55",
        //         "data": {
        //             "transfer_id": "ca90d97a621e47d49774f19af6b029f5"
        //         }
        //     }
        //
        return this.extend(this.parseTransfer(response, currency), new Dictionary<string, object>() {
            { "amount", this.parseNumber(amountToPrecision) },
            { "fromAccount", fromAccount },
            { "toAccount", toAccount },
        });
    }

    public virtual object parseTransferStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "1000", "ok" },
            { "OK", "ok" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        //
        //     {
        //         "message": "OK",
        //         "code": 1000,
        //         "trace": "b26cecec-ef5a-47d9-9531-2bd3911d3d55",
        //         "data": {
        //             "transfer_id": "ca90d97a621e47d49774f19af6b029f5"
        //         }
        //     }
        //
        object data = this.safeValue(transfer, "data", new Dictionary<string, object>() {});
        return new Dictionary<string, object>() {
            { "id", this.safeString(data, "transfer_id") },
            { "timestamp", null },
            { "datetime", null },
            { "currency", this.safeCurrencyCode(null, currency) },
            { "amount", null },
            { "fromAccount", null },
            { "toAccount", null },
            { "status", this.parseTransferStatus(this.safeString2(transfer, "code", "message")) },
        };
    }

    public async override Task<object> fetchBorrowInterest(object code = null, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitmart#fetchBorrowInterest
        * @description fetch the interest owed by the user for borrowing currency for margin trading
        * @see https://developer-pro.bitmart.com/en/spot/#get-borrow-record-isolated
        * @param {string|undefined} code unified currency code
        * @param {string} symbol unified market symbol when fetch interest in isolated markets
        * @param {int|undefined} since the earliest time in ms to fetch borrrow interest for
        * @param {int|undefined} limit the maximum number of structures to retrieve
        * @param {object} params extra parameters specific to the bitmart api endpoint
        * @returns {[object]} a list of [borrow interest structures]{@link https://docs.ccxt.com/#/?id=borrow-interest-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchBorrowInterest() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["N"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["start_time"] = since;
        }
        object response = await this.privateGetSpotV1MarginIsolatedBorrowRecord(this.extend(request, parameters));
        //
        //     {
        //         "message": "OK",
        //         "code": 1000,
        //         "trace": "8ea27a2a-4aba-49fa-961d-43a0137b0ef3",
        //         "data": {
        //             "records": [
        //                 {
        //                     "borrow_id": "1659045283903rNvJnuRTJNL5J53n",
        //                     "symbol": "BTC_USDT",
        //                     "currency": "USDT",
        //                     "borrow_amount": "100.00000000",
        //                     "daily_interest": "0.00055000",
        //                     "hourly_interest": "0.00002291",
        //                     "interest_amount": "0.00229166",
        //                     "create_time": 1659045284000
        //                 },
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object rows = this.safeValue(data, "records", new List<object>() {});
        object interest = this.parseBorrowInterests(rows, market);
        return this.filterByCurrencySinceLimit(interest, code, since, limit);
    }

    public override object parseBorrowInterest(object info, object market = null)
    {
        //
        //     {
        //         "borrow_id": "1657664327844Lk5eJJugXmdHHZoe",
        //         "symbol": "BTC_USDT",
        //         "currency": "USDT",
        //         "borrow_amount": "20.00000000",
        //         "daily_interest": "0.00055000",
        //         "hourly_interest": "0.00002291",
        //         "interest_amount": "0.00045833",
        //         "create_time": 1657664329000
        //     }
        //
        object marketId = this.safeString(info, "symbol");
        market = this.safeMarket(marketId, market);
        object timestamp = this.safeInteger(info, "create_time");
        return new Dictionary<string, object>() {
            { "symbol", this.safeString(market, "symbol") },
            { "marginMode", "isolated" },
            { "currency", this.safeCurrencyCode(this.safeString(info, "currency")) },
            { "interest", this.safeNumber(info, "interest_amount") },
            { "interestRate", this.safeNumber(info, "hourly_interest") },
            { "amountBorrowed", this.safeNumber(info, "borrow_amount") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", info },
        };
    }

    public override object handleMarginModeAndParams(object methodName, object parameters = null, object defaultValue = null)
    {
        /**
        * @ignore
        * @method
        * @description marginMode specified by params["marginMode"], this.options["marginMode"], this.options["defaultMarginMode"], params["margin"] = true or this.options["defaultType"] = 'margin'
        * @param {object} params extra parameters specific to the exchange api endpoint
        * @returns {[string|undefined, object]} the marginMode in lowercase
        */
        parameters ??= new Dictionary<string, object>();
        object marginMode = null;
        var marginModeparametersVariable = base.handleMarginModeAndParams(methodName, parameters, defaultValue);
        marginMode = ((List<object>)marginModeparametersVariable)[0];
        parameters = ((List<object>)marginModeparametersVariable)[1];
        if (isTrue(!isEqual(marginMode, null)))
        {
            if (isTrue(!isEqual(marginMode, "isolated")))
            {
                throw new NotSupported ((string)add(this.id, " only isolated margin is supported")) ;
            }
        }
        return new List<object>() {marginMode, parameters};
    }

    public override object nonce()
    {
        return this.milliseconds();
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object baseUrl = this.implodeHostname(getValue(getValue(this.urls, "api"), "rest"));
        object url = add(add(baseUrl, "/"), this.implodeParams(path, parameters));
        object query = this.omit(parameters, this.extractParams(path));
        object queryString = "";
        object getOrDelete = isTrue((isEqual(method, "GET"))) || isTrue((isEqual(method, "DELETE")));
        if (isTrue(getOrDelete))
        {
            if (isTrue(getArrayLength(new List<object>(((Dictionary<string,object>)query).Keys))))
            {
                queryString = this.urlencode(query);
                url = add(url, add("?", queryString));
            }
        }
        if (isTrue(isEqual(api, "private")))
        {
            this.checkRequiredCredentials();
            object timestamp = ((object)this.milliseconds()).ToString();
            headers = new Dictionary<string, object>() {
                { "X-BM-KEY", this.apiKey },
                { "X-BM-TIMESTAMP", timestamp },
                { "Content-Type", "application/json" },
            };
            if (!isTrue(getOrDelete))
            {
                body = this.json(query);
                queryString = body;
            }
            object auth = add(add(add(add(timestamp, "#"), this.uid), "#"), queryString);
            object signature = this.hmac(this.encode(auth), this.encode(this.secret), sha256);
            ((Dictionary<string, object>)headers)["X-BM-SIGN"] = signature;
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;
        }
        //
        // spot
        //
        //     {"message":"Bad Request [to is empty]","code":50000,"trace":"f9d46e1b-4edb-4d07-a06e-4895fb2fc8fc","data":{}}
        //     {"message":"Bad Request [from is empty]","code":50000,"trace":"579986f7-c93a-4559-926b-06ba9fa79d76","data":{}}
        //     {"message":"Kline size over 500","code":50004,"trace":"d625caa8-e8ca-4bd2-b77c-958776965819","data":{}}
        //     {"message":"Balance not enough","code":50020,"trace":"7c709d6a-3292-462c-98c5-32362540aeef","data":{}}
        //
        // contract
        //
        //     {"errno":"OK","message":"INVALID_PARAMETER","code":49998,"trace":"eb5ebb54-23cd-4de2-9064-e090b6c3b2e3","data":null}
        //
        object message = this.safeStringLower(response, "message");
        object errorCode = this.safeString(response, "code");
        if (isTrue(isTrue((isTrue((!isEqual(errorCode, null))) && isTrue((!isEqual(errorCode, "1000"))))) || isTrue((isTrue((!isEqual(message, null))) && isTrue((!isEqual(message, "ok")))))))
        {
            object feedback = add(add(this.id, " "), body);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorCode, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), errorCode, feedback);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), message, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }
}
