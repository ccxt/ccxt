using ccxt;
namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

partial class bkex : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "bkex" },
            { "name", "BKEX" },
            { "countries", new List<object>() {"BVI"} },
            { "rateLimit", 100 },
            { "version", "v2" },
            { "certified", false },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", null },
                { "swap", true },
                { "future", null },
                { "option", null },
                { "addMargin", null },
                { "cancelAllOrders", null },
                { "cancelOrder", true },
                { "cancelOrders", true },
                { "createDepositAddress", null },
                { "createLimitOrder", null },
                { "createMarketOrder", null },
                { "createOrder", true },
                { "editOrder", null },
                { "fetchAccounts", null },
                { "fetchBalance", true },
                { "fetchBidsAsks", null },
                { "fetchBorrowRate", null },
                { "fetchBorrowRateHistory", null },
                { "fetchBorrowRates", null },
                { "fetchBorrowRatesPerSymbol", null },
                { "fetchCanceledOrders", null },
                { "fetchClosedOrder", null },
                { "fetchClosedOrders", true },
                { "fetchCurrencies", true },
                { "fetchDeposit", false },
                { "fetchDepositAddress", true },
                { "fetchDepositAddresses", null },
                { "fetchDepositAddressesByNetwork", null },
                { "fetchDeposits", true },
                { "fetchDepositWithdrawFee", "emulated" },
                { "fetchDepositWithdrawFees", true },
                { "fetchFundingHistory", null },
                { "fetchFundingRate", null },
                { "fetchFundingRateHistory", true },
                { "fetchFundingRates", null },
                { "fetchIndexOHLCV", null },
                { "fetchL2OrderBook", null },
                { "fetchLedger", null },
                { "fetchLedgerEntry", null },
                { "fetchLeverageTiers", null },
                { "fetchMarginMode", false },
                { "fetchMarketLeverageTiers", true },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", null },
                { "fetchMyTrades", null },
                { "fetchOHLCV", true },
                { "fetchOpenOrder", true },
                { "fetchOpenOrders", true },
                { "fetchOrder", false },
                { "fetchOrderBook", true },
                { "fetchOrderBooks", null },
                { "fetchOrders", null },
                { "fetchOrderTrades", null },
                { "fetchPosition", null },
                { "fetchPositionMode", false },
                { "fetchPositions", null },
                { "fetchPositionsRisk", null },
                { "fetchPremiumIndexOHLCV", null },
                { "fetchStatus", true },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", false },
                { "fetchTradingFees", false },
                { "fetchTradingLimits", null },
                { "fetchTransactionFee", "emulated" },
                { "fetchTransactionFees", true },
                { "fetchTransactions", null },
                { "fetchTransfer", false },
                { "fetchTransfers", false },
                { "fetchWithdrawal", false },
                { "fetchWithdrawals", true },
                { "reduceMargin", null },
                { "setLeverage", null },
                { "setMarginMode", null },
                { "setPositionMode", null },
                { "signIn", null },
                { "transfer", false },
                { "withdraw", false },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1m" },
                { "5m", "5m" },
                { "15m", "15m" },
                { "30m", "30m" },
                { "1h", "1h" },
                { "4h", "4h" },
                { "6h", "6h" },
                { "12h", "12h" },
                { "1d", "1d" },
                { "1w", "1w" },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/1294454/158043180-bb079a65-69e8-45a2-b393-f094d334e610.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "spot", "https://api.bkex.com" },
                    { "swap", "https://fapi.bkex.com" },
                } },
                { "www", "https://www.bkex.com/" },
                { "doc", new List<object>() {"https://bkexapi.github.io/docs/api_en.htm"} },
                { "fees", new List<object>() {"https://www.bkex.com/help/instruction/33"} },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "spot", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "/common/symbols", 1 },
                            { "/common/currencys", 1 },
                            { "/common/timestamp", 1 },
                            { "/q/kline", 1 },
                            { "/q/tickers", 1 },
                            { "/q/ticker/price", 1 },
                            { "/q/depth", 1 },
                            { "/q/deals", 1 },
                        } },
                    } },
                    { "swap", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "/market/candle", 1 },
                            { "/market/deals", 1 },
                            { "/market/depth", 1 },
                            { "/market/fundingRate", 1 },
                            { "/market/index", 1 },
                            { "/market/riskLimit", 1 },
                            { "/market/symbols", 1 },
                            { "/market/ticker/price", 1 },
                            { "/market/tickers", 1 },
                            { "/server/ping", 1 },
                        } },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "spot", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "/u/api/info", 1 },
                            { "/u/account/balance", 1 },
                            { "/u/wallet/address", 1 },
                            { "/u/wallet/depositRecord", 1 },
                            { "/u/wallet/withdrawRecord", 1 },
                            { "/u/order/openOrders", 1 },
                            { "/u/order/openOrder/detail", 1 },
                            { "/u/order/historyOrders", 1 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "/u/account/transfer", 1 },
                            { "/u/wallet/withdraw", 1 },
                            { "/u/order/create", 1 },
                            { "/u/order/cancel", 1 },
                            { "/u/order/batchCreate", 1 },
                            { "/u/order/batchCancel", 1 },
                        } },
                    } },
                    { "swap", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "/account/balance", 1 },
                            { "/account/balanceRecord", 1 },
                            { "/account/order", 1 },
                            { "/account/orderForced", 1 },
                            { "/account/position", 1 },
                            { "/entrust/finished", 1 },
                            { "/entrust/unFinish", 1 },
                            { "/order/finished", 1 },
                            { "/order/finishedInfo", 1 },
                            { "/order/unFinish", 1 },
                            { "/position/info", 1 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "/account/setLeverage", 1 },
                            { "/entrust/add", 1 },
                            { "/entrust/cancel", 1 },
                            { "/order/batchCancel", 1 },
                            { "/order/batchOpen", 1 },
                            { "/order/cancel", 1 },
                            { "/order/close", 1 },
                            { "/order/closeAll", 1 },
                            { "/order/open", 1 },
                            { "/position/setSpSl", 1 },
                            { "/position/update", 1 },
                        } },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "tierBased", false },
                    { "percentage", true },
                    { "maker", this.parseNumber("0.0015") },
                    { "taker", this.parseNumber("0.002") },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "timeframes", new Dictionary<string, object>() {
                    { "spot", new Dictionary<string, object>() {
                        { "1m", "1m" },
                        { "5m", "5m" },
                        { "15m", "15m" },
                        { "30m", "30m" },
                        { "1h", "1h" },
                        { "4h", "4h" },
                        { "6h", "6h" },
                        { "12h", "12h" },
                        { "1d", "1d" },
                        { "1w", "1w" },
                    } },
                    { "swap", new Dictionary<string, object>() {
                        { "1m", "M1" },
                        { "5m", "M5" },
                        { "15m", "M15" },
                        { "30m", "M30" },
                        { "1h", "H1" },
                        { "4h", "H4" },
                        { "6h", "H6" },
                        { "1d", "D1" },
                    } },
                } },
                { "defaultType", "spot" },
                { "networks", new Dictionary<string, object>() {
                    { "TRX", "TRC-20" },
                    { "TRC20", "TRC-20" },
                    { "ETH", "ERC-20" },
                    { "ERC20", "ERC-20" },
                    { "BEP20", "BEP-20(BSC)" },
                } },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "SHINJA", "SHINJA(1M)" },
            } },
            { "precisionMode", TICK_SIZE },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "1005", typeof(InsufficientFunds) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "Not Enough balance", typeof(InsufficientFunds) },
                    { "Order does not exist", typeof(InvalidOrder) },
                    { "System busy, please try again later", typeof(BadRequest) },
                } },
            } },
        });
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name bkex#fetchMarkets
        * @description retrieves data on all markets for bkex
        * @see https://bkexapi.github.io/docs/api_en.htm?shell#basicInformation-1
        * @see https://bkexapi.github.io/docs/api_en.htm?shell#contract-market-symbols
        * @param {object} params extra parameters specific to the exchange api endpoint
        * @returns {[object]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object promises = new List<object> {this.publicSpotGetCommonSymbols(parameters), this.publicSwapGetMarketSymbols(parameters)};
        promises = await promiseAll(promises);
        object spotMarkets = getValue(promises, 0);
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "minimumOrderSize": "0",
        //                 "minimumTradeVolume": "0E-18",
        //                 "pricePrecision": "11",
        //                 "supportTrade": true,
        //                 "symbol": "COMT_USDT",
        //                 "volumePrecision": 0
        //             },
        //         ],
        //         "msg": "success",
        //         "status": 0
        //     }
        //
        object swapMarkets = getValue(promises, 1);
        //
        //     {
        //         "code": 0,
        //         "msg": "success",
        //         "data": [
        //             {
        //                 "symbol": "luna_usdt",
        //                 "supportTrade": false,
        //                 "volumePrecision": 0,
        //                 "pricePrecision": 3,
        //                 "marketMiniAmount": "1",
        //                 "limitMiniAmount": "1"
        //             },
        //         ]
        //     }
        //
        object spotData = this.safeValue(spotMarkets, "data", new List<object>() {});
        object swapData = this.safeValue(swapMarkets, "data", new List<object>() {});
        object data = this.arrayConcat(spotData, swapData);
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object market = getValue(data, i);
            object marketId = this.safeString(market, "symbol");
            object id = this.safeStringUpper(market, "symbol");
            var baseIdquoteIdVariable = ((string)id).Split((string)"_").ToList<object>();
            var baseId = ((List<object>) baseIdquoteIdVariable)[0];
            var quoteId = ((List<object>) baseIdquoteIdVariable)[1];
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            object minimumOrderSize = this.safeString(market, "minimumOrderSize");
            object type = ((bool) isTrue((!isEqual(minimumOrderSize, null)))) ? "spot" : "swap";
            object swap = (isEqual(type, "swap"));
            object symbol = add(add(bs, "/"), quote);
            object settleId = null;
            object settle = null;
            if (isTrue(swap))
            {
                settleId = quoteId;
                settle = quote;
                symbol = add(add(add(add(bs, "/"), quote), ":"), settle);
            }
            object linear = ((bool) isTrue(swap)) ? true : null;
            ((List<object>)result).Add(new Dictionary<string, object>() {
                { "id", marketId },
                { "symbol", symbol },
                { "base", bs },
                { "quote", quote },
                { "settle", settle },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", settleId },
                { "type", type },
                { "spot", (isEqual(type, "spot")) },
                { "margin", false },
                { "future", false },
                { "swap", swap },
                { "option", false },
                { "active", this.safeValue(market, "supportTrade") },
                { "contract", swap },
                { "linear", linear },
                { "inverse", null },
                { "contractSize", null },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", this.parseNumber(this.parsePrecision(this.safeString(market, "volumePrecision"))) },
                    { "price", this.parseNumber(this.parsePrecision(this.safeString(market, "pricePrecision"))) },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumberN(market, new List<object>() {"minimumOrderSize", "marketMiniAmount", "limitMiniAmount"}) },
                        { "max", null },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "minimumTradeVolume") },
                        { "max", null },
                    } },
                } },
                { "info", market },
            });
        }
        return result;
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name bkex#fetchCurrencies
        * @description fetches all available currencies on an exchange
        * @param {object} params extra parameters specific to the bkex api endpoint
        * @returns {object} an associative dictionary of currencies
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicSpotGetCommonCurrencys(parameters);
        //
        // {
        //     "code": "0",
        //     "data": [
        //        {
        //           "currency": "ETH",
        //           "maxWithdrawOneDay": "100.000000000000000000",
        //           "maxWithdrawSingle": "50.000000000000000000",
        //           "minWithdrawSingle": "0.005000000000000000",
        //           "supportDeposit": true,
        //           "supportTrade": true,
        //           "supportWithdraw": true,
        //           "withdrawFee": 0.01
        //        },
        //     ],
        //     "msg": "success",
        //     "status": 0
        // }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object currency = getValue(data, i);
            object id = this.safeString(currency, "currency");
            object code = this.safeCurrencyCode(id);
            object name = this.safeString(currency, "name");
            object withdrawEnabled = this.safeValue(currency, "supportWithdraw");
            object depositEnabled = this.safeValue(currency, "supportDeposit");
            object tradeEnabled = this.safeValue(currency, "supportTrade");
            object active = isTrue(isTrue(withdrawEnabled) && isTrue(depositEnabled)) && isTrue(tradeEnabled);
            ((Dictionary<string, object>)result)[(string)code] = new Dictionary<string, object>() {
                { "id", id },
                { "code", code },
                { "name", name },
                { "deposit", depositEnabled },
                { "withdraw", withdrawEnabled },
                { "active", active },
                { "fee", this.safeNumber(currency, "withdrawFee") },
                { "precision", null },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", this.safeNumber(currency, "minWithdrawSingle") },
                        { "max", this.safeNumber(currency, "maxWithdrawSingle") },
                    } },
                } },
                { "info", currency },
            };
        }
        return result;
    }

    public async override Task<object> fetchTime(object parameters = null)
    {
        /**
        * @method
        * @name bkex#fetchTime
        * @description fetches the current integer timestamp in milliseconds from the exchange server
        * @param {object} params extra parameters specific to the bkex api endpoint
        * @returns {int} the current integer timestamp in milliseconds from the exchange server
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicSpotGetCommonTimestamp(parameters);
        //
        // {
        //     "code": '0',
        //     "data": 1573542445411,
        //     "msg": "success",
        //     "status": 0
        // }
        //
        return this.safeInteger(response, "data");
    }

    public async override Task<object> fetchStatus(object parameters = null)
    {
        /**
        * @method
        * @name bkex#fetchStatus
        * @description the latest known information on the availability of the exchange API
        * @param {object} params extra parameters specific to the bkex api endpoint
        * @returns {object} a [status structure]{@link https://docs.ccxt.com/#/?id=exchange-status-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicSpotGetCommonTimestamp(parameters);
        //
        //     {
        //         "code": '0',
        //         "data": 1573542445411,
        //         "msg": "success",
        //         "status": 0
        //     }
        //
        object statusRaw = this.safeInteger(response, "status");
        object codeRaw = this.safeInteger(response, "code");
        object updated = this.safeInteger(response, "data");
        return new Dictionary<string, object>() {
            { "status", ((bool) isTrue((isTrue(isEqual(statusRaw, 0)) && isTrue(isEqual(codeRaw, 0))))) ? "ok" : statusRaw },
            { "updated", updated },
            { "eta", null },
            { "url", null },
            { "info", response },
        };
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bkex#fetchOHLCV
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @see https://bkexapi.github.io/docs/api_en.htm?shell#quotationData-1
        * @see https://bkexapi.github.io/docs/api_en.htm?shell#contract-kline
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int|undefined} since timestamp in ms of the earliest candle to fetch
        * @param {int|undefined} limit the maximum amount of candles to fetch
        * @param {object} params extra parameters specific to the bkex api endpoint
        * @returns {[[int]]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object swap = getValue(market, "swap");
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object method = "publicSpotGetQKline";
        object timeframes = this.safeValue(this.options, "timeframes");
        if (isTrue(swap))
        {
            object swapTimeframes = this.safeValue(timeframes, "swap");
            method = "publicSwapGetMarketCandle";
            ((Dictionary<string, object>)request)["period"] = this.safeString(swapTimeframes, timeframe, timeframe);
            if (isTrue(!isEqual(limit, null)))
            {
                ((Dictionary<string, object>)request)["count"] = limit;
            }
        } else
        {
            object spotTimeframes = this.safeValue(timeframes, "spot");
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
            ((Dictionary<string, object>)request)["period"] = this.safeString(spotTimeframes, timeframe, timeframe);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            object limitRequest = ((bool) isTrue(swap)) ? "count" : "size";
            ((Dictionary<string, object>)request)[(string)limitRequest] = limit;
        }
        // their docs says that 'from/to' arguments are mandatory, however that's not true in reality
        if (isTrue(!isEqual(since, null)))
        {
            object sinceRequest = ((bool) isTrue(swap)) ? "start" : "from";
            ((Dictionary<string, object>)request)[(string)sinceRequest] = since;
            // when 'since' [from] argument is set, then exchange also requires 'to' value to be set. So we have to set 'to' argument depending 'limit' amount (if limit was not provided, then exchange-default 500).
            if (isTrue(isEqual(limit, null)))
            {
                limit = 500;
            }
            object duration = this.parseTimeframe(timeframe);
            object timerange = multiply(multiply(limit, duration), 1000);
            object toRequest = ((bool) isTrue(swap)) ? "end" : "to";
            ((Dictionary<string, object>)request)[(string)toRequest] = this.sum(getValue(request, sinceRequest), timerange);
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { request }));
        //
        // spot
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "close": "43414.68",
        //                 "high": "43446.47",
        //                 "low": "43403.05",
        //                 "open": "43406.05",
        //                 "quoteVolume": "61500.40099",
        //                 "symbol": "BTC_USDT",
        //                 "ts": "1646152440000",
        //                 "volume": 1.41627
        //             },
        //         ],
        //         "msg": "success",
        //         "status": 0
        //     }
        //
        // swap
        //
        //     {
        //         "code": 0,
        //         "msg": "success",
        //         "data": [
        //             {
        //                 "symbol": "btc_usdt",
        //                 "amount": "10.26",
        //                 "volume": "172540.9433",
        //                 "open": "16817.29",
        //                 "close": "1670476440000",
        //                 "high": "16816.45",
        //                 "low": "16817.29",
        //                 "ts": 1670476440000
        //             },
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        return this.parseOHLCVs(data, market, timeframe, since, limit);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        object baseCurrencyVolume = ((bool) isTrue(getValue(market, "swap"))) ? "amount" : "volume";
        return new List<object> {this.safeInteger(ohlcv, "ts"), this.safeFloat(ohlcv, "open"), this.safeFloat(ohlcv, "high"), this.safeFloat(ohlcv, "low"), this.safeFloat(ohlcv, "close"), this.safeFloat(ohlcv, baseCurrencyVolume)};
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bkex#fetchTicker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @see https://bkexapi.github.io/docs/api_en.htm?shell#quotationData-2
        * @see https://bkexapi.github.io/docs/api_en.htm?shell#contract-ticker-data
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} params extra parameters specific to the bkex api endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        var marketTypequeryVariable = this.handleMarketTypeAndParams("fetchTicker", market, parameters);
        var marketType = ((List<object>) marketTypequeryVariable)[0];
        var query = ((List<object>) marketTypequeryVariable)[1];
        object method = ((bool) isTrue((isEqual(marketType, "swap")))) ? "publicSwapGetMarketTickers" : "publicSpotGetQTickers";
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        //
        // spot
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "change": "6.52",
        //                 "close": "43573.470000",
        //                 "high": "44940.540000",
        //                 "low": "40799.840000",
        //                 "open": "40905.780000",
        //                 "quoteVolume": "225621691.5991",
        //                 "symbol": "BTC_USDT",
        //                 "ts": "1646156490781",
        //                 "volume": 5210.349
        //             }
        //         ],
        //         "msg": "success",
        //         "status": 0
        //     }
        //
        // swap
        //
        //     {
        //         "code": 0,
        //         "msg": "success",
        //         "data": [
        //             {
        //                 "symbol": "btc_usdt",
        //                 "amount": "171035.45",
        //                 "volume": "2934757466.3859",
        //                 "open": "17111.43",
        //                 "close": "17135.74",
        //                 "high": "17225.99",
        //                 "low": "17105.77",
        //                 "lastPrice": "17135.74",
        //                 "lastAmount": "1.05",
        //                 "lastTime": 1670709364912,
        //                 "change": "0.14"
        //             }
        //         ]
        //     }
        //
        object tickers = this.safeValue(response, "data", new List<object>() {});
        object ticker = this.safeValue(tickers, 0);
        return this.parseTicker(ticker, market);
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name bkex#fetchTickers
        * @description fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
        * @see https://bkexapi.github.io/docs/api_en.htm?shell#quotationData-2
        * @see https://bkexapi.github.io/docs/api_en.htm?shell#contract-ticker-data
        * @param {[string]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} params extra parameters specific to the bkex api endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbols, null)))
        {
            if (!isTrue((symbols.GetType().IsGenericType && symbols.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))
            {
                throw new BadRequest ((string)add(this.id, " fetchTickers() symbols argument should be an array")) ;
            }
        }
        object market = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            object marketIds = this.marketIds(symbols);
            object symbol = this.safeString(symbols, 0);
            market = this.market(symbol);
            if (isTrue(getValue(market, "swap")))
            {
                if (isTrue((symbols.GetType().IsGenericType && symbols.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))
                {
                    object symbolsLength = getArrayLength(symbols);
                    if (isTrue(isGreaterThan(symbolsLength, 1)))
                    {
                        throw new BadRequest ((string)add(this.id, " fetchTickers() symbols argument cannot contain more than 1 symbol for swap markets")) ;
                    }
                }
                ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
            } else
            {
                ((Dictionary<string, object>)request)["symbol"] = String.Join(",", ((List<object>)marketIds).ToArray());
            }
        }
        var marketTypequeryVariable = this.handleMarketTypeAndParams("fetchTickers", market, parameters);
        var marketType = ((List<object>) marketTypequeryVariable)[0];
        var query = ((List<object>) marketTypequeryVariable)[1];
        object method = ((bool) isTrue((isEqual(marketType, "swap")))) ? "publicSwapGetMarketTickers" : "publicSpotGetQTickers";
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        //
        // spot
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "change": "6.52",
        //                 "close": "43573.470000",
        //                 "high": "44940.540000",
        //                 "low": "40799.840000",
        //                 "open": "40905.780000",
        //                 "quoteVolume": "225621691.5991",
        //                 "symbol": "BTC_USDT",
        //                 "ts": "1646156490781",
        //                 "volume": 5210.349
        //             }
        //         ],
        //         "msg": "success",
        //         "status": 0
        //     }
        //
        // swap
        //
        //     {
        //         "code": 0,
        //         "msg": "success",
        //         "data": [
        //             {
        //                 "symbol": "btc_usdt",
        //                 "amount": "171035.45",
        //                 "volume": "2934757466.3859",
        //                 "open": "17111.43",
        //                 "close": "17135.74",
        //                 "high": "17225.99",
        //                 "low": "17105.77",
        //                 "lastPrice": "17135.74",
        //                 "lastAmount": "1.05",
        //                 "lastTime": 1670709364912,
        //                 "change": "0.14"
        //             }
        //         ]
        //     }
        //
        object tickers = this.safeValue(response, "data", new List<object>() {});
        return this.parseTickers(tickers, symbols, query);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        // spot
        //
        //    {
        //          "change":-0.46,
        //          "close":29664.46,
        //          "high":30784.99,
        //          "low":29455.36,
        //          "open":29803.38,
        //          "quoteVolume":714653752.6991,
        //          "symbol":"BTC_USDT",
        //          "ts":1652812048118,
        //          "volume":23684.9416
        //    }
        //
        // swap
        //
        //     {
        //         "symbol": "btc_usdt",
        //         "amount": "171035.45",
        //         "volume": "2934757466.3859",
        //         "open": "17111.43",
        //         "close": "17135.74",
        //         "high": "17225.99",
        //         "low": "17105.77",
        //         "lastPrice": "17135.74",
        //         "lastAmount": "1.05",
        //         "lastTime": 1670709364912,
        //         "change": "0.14"
        //     }
        //
        object marketId = this.safeString(ticker, "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = this.safeSymbol(marketId, market);
        object timestamp = this.safeInteger2(ticker, "ts", "lastTime");
        object baseCurrencyVolume = ((bool) isTrue(getValue(market, "swap"))) ? "amount" : "volume";
        object quoteCurrencyVolume = ((bool) isTrue(getValue(market, "swap"))) ? "volume" : "quoteVolume";
        object lastPrice = ((bool) isTrue(getValue(market, "swap"))) ? "lastPrice" : "close";
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(ticker, "high") },
            { "low", this.safeString(ticker, "low") },
            { "bid", null },
            { "bidVolume", null },
            { "ask", null },
            { "askVolume", null },
            { "vwap", null },
            { "open", this.safeString(ticker, "open") },
            { "close", this.safeString(ticker, "close") },
            { "last", this.safeString(ticker, lastPrice) },
            { "previousClose", null },
            { "change", null },
            { "percentage", this.safeString(ticker, "change") },
            { "average", null },
            { "baseVolume", this.safeString(ticker, baseCurrencyVolume) },
            { "quoteVolume", this.safeString(ticker, quoteCurrencyVolume) },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bkex#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://bkexapi.github.io/docs/api_en.htm?shell#quotationData-4
        * @see https://bkexapi.github.io/docs/api_en.htm?shell#contract-deep-data
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int|undefined} limit the maximum amount of order book entries to return
        * @param {object} params extra parameters specific to the bkex api endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object swap = getValue(market, "swap");
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object method = "publicSpotGetQDepth";
        if (isTrue(swap))
        {
            method = "publicSwapGetMarketDepth";
        } else
        {
            if (isTrue(!isEqual(limit, null)))
            {
                ((Dictionary<string, object>)request)["depth"] = mathMin(limit, 50);
            }
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        // spot
        //
        //     {
        //         "code": "0",
        //         "data": {
        //             "ask": [
        //                 ["43820.07","0.86947"],
        //                 ["43820.25","0.07503"],
        //             ],
        //             "bid": [
        //                 ["43815.94","0.43743"],
        //                 ["43815.72","0.08901"],
        //             ],
        //             "symbol": "BTC_USDT",
        //             "timestamp": 1646161595841
        //         },
        //         "msg": "success",
        //         "status": 0
        //     }
        //
        // swap
        //
        //     {
        //         "code": 0,
        //         "msg": "success",
        //         "data": {
        //             "bid": [
        //                 ["16803.170000","4.96"],
        //                 ["16803.140000","11.07"],
        //             ],
        //             "ask": [
        //                 ["16803.690000","9.2"],
        //                 ["16804.180000","9.43"],
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "data");
        object timestamp = this.safeInteger(data, "timestamp");
        return this.parseOrderBook(data, getValue(market, "symbol"), timestamp, "bid", "ask");
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bkex#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @see https://bkexapi.github.io/docs/api_en.htm?shell#quotationData-5
        * @see https://bkexapi.github.io/docs/api_en.htm?shell#contract-trades-history
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int|undefined} since timestamp in ms of the earliest trade to fetch
        * @param {int|undefined} limit the maximum amount of trades to fetch
        * @param {object} params extra parameters specific to the bkex api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/en/latest/manual.html?#public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object swap = getValue(market, "swap");
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object method = "publicSpotGetQDeals";
        if (isTrue(swap))
        {
            method = "publicSwapGetMarketDeals";
        } else
        {
            if (isTrue(!isEqual(limit, null)))
            {
                ((Dictionary<string, object>)request)["size"] = mathMin(limit, 50);
            }
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        // spot
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "direction": "S",
        //                 "price": "43930.63",
        //                 "symbol": "BTC_USDT",
        //                 "ts": "1646224171992",
        //                 "volume": 0.030653
        //             }, // first item is most recent
        //         ],
        //         "msg": "success",
        //         "status": 0
        //     }
        //
        // swap
        //
        //     {
        //         "code": 0,
        //         "msg": "success",
        //         "data": [
        //             {
        //                 "symbol": "btc_usdt",
        //                 "amount": "0.06",
        //                 "price": "17134.66",
        //                 "side": "sell",
        //                 "time": 1670651851646
        //             },
        //         ]
        //     }
        //
        object trades = this.safeValue(response, "data");
        return this.parseTrades(trades, market, since, limit);
    }

    public override object parseTrade(object trade, object market = null)
    {
        object timestamp = this.safeInteger2(trade, "ts", "time");
        object marketId = this.safeString(trade, "symbol");
        market = this.safeMarket(marketId, market);
        object side = this.parseTradeSide(this.safeString2(trade, "direction", "side"));
        object amount = this.safeNumber2(trade, "volume", "amount");
        object price = this.safeNumber(trade, "price");
        object type = null;
        object id = this.safeString(trade, "tid");
        if (isTrue(isEqual(id, null)))
        {
            id = this.syntheticTradeId(market, timestamp, side, amount, price, type);
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", id },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", getValue(market, "symbol") },
            { "order", null },
            { "type", type },
            { "side", side },
            { "takerOrMaker", null },
            { "price", price },
            { "amount", amount },
            { "cost", null },
            { "fee", null },
            { "info", trade },
        }, market);
    }

    public virtual object parseTradeSide(object side)
    {
        object sides = new Dictionary<string, object>() {
            { "B", "buy" },
            { "S", "sell" },
            { "buy", "buy" },
            { "sell", "sell" },
        };
        return this.safeString(sides, side, side);
    }

    public virtual object syntheticTradeId(object market = null, object timestamp = null, object side = null, object amount = null, object price = null, object orderType = null, object takerOrMaker = null)
    {
        // TODO: can be unified method? this approach is being used by multiple exchanges (mexc, woo-coinsbit, dydx, ...)
        object id = "";
        if (isTrue(!isEqual(timestamp, null)))
        {
            id = add(add(this.numberToString(timestamp), "-"), this.safeString(market, "id", "_"));
            if (isTrue(!isEqual(side, null)))
            {
                id = add(id, add("-", side));
            }
            if (isTrue(!isEqual(orderType, null)))
            {
                id = add(id, add("-", orderType));
            }
            if (isTrue(!isEqual(takerOrMaker, null)))
            {
                id = add(id, add("-", takerOrMaker));
            }
            if (isTrue(!isEqual(amount, null)))
            {
                id = add(id, add("-", this.numberToString(amount)));
            }
            if (isTrue(!isEqual(price, null)))
            {
                id = add(id, add("-", this.numberToString(price)));
            }
        }
        return id;
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name bkex#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @param {object} params extra parameters specific to the bkex api endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/en/latest/manual.html?#balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object query = this.omit(parameters, "type");
        object response = await this.privateSpotGetUAccountBalance(query);
        //
        // {
        //     "code": "0",
        //     "data": {
        //       "WALLET": [
        //         {
        //           "available": "0.221212121000000000",
        //           "currency": "PHX",
        //           "frozen": "0E-18",
        //           "total": 0.221212121
        //         },
        //         {
        //           "available": "44.959577229600000000",
        //           "currency": "USDT",
        //           "frozen": "0E-18",
        //           "total": 44.9595772296
        //         }
        //       ]
        //     },
        //     "msg": "success",
        //     "status": 0
        // }
        //
        object balances = this.safeValue(response, "data");
        object wallets = this.safeValue(balances, "WALLET", new List<object>() {});
        object result = new Dictionary<string, object>() {
            { "info", wallets },
        };
        for (object i = 0; isLessThan(i, getArrayLength(wallets)); postFixIncrement(ref i))
        {
            object wallet = getValue(wallets, i);
            object currencyId = getValue(wallet, "currency");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            ((Dictionary<string, object>)account)["free"] = this.safeNumber(wallet, "available");
            ((Dictionary<string, object>)account)["used"] = this.safeNumber(wallet, "frozen");
            ((Dictionary<string, object>)account)["total"] = this.safeNumber(wallet, "total");
            ((Dictionary<string, object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name bkex#fetchDepositAddress
        * @description fetch the deposit address for a currency associated with this account
        * @param {string} code unified currency code
        * @param {object} params extra parameters specific to the bkex api endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        object response = await this.privateSpotGetUWalletAddress(this.extend(request, parameters));
        // NOTE: You can only retrieve addresses of already generated wallets - so should already have generated that COIN deposit address in UI. Otherwise, it seems from API you can't create/obtain addresses for those coins.
        //
        // {
        //     "code": "0",
        //     "data": [
        //       {
        //         "currency": "BTC",
        //         "address": "1m4k2yUKTSrX6SM9FGgvwMyxQbYtRVi2N",
        //         "memo": ""
        //       }
        //     ],
        //     "msg": "success",
        //     "status": 0
        // }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseDepositAddress(data, currency);
    }

    public override object parseDepositAddress(object data, object currency = null)
    {
        object depositObject = this.safeValue(data, 0);
        object address = this.safeString(depositObject, "address");
        object tag = this.safeString(depositObject, "memo");
        object currencyId = this.safeString(depositObject, "currency");
        currency = this.safeCurrency(currencyId, currency);
        return new Dictionary<string, object>() {
            { "currency", getValue(currency, "code") },
            { "address", address },
            { "tag", tag },
            { "network", null },
            { "info", data },
        };
    }

    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bkex#fetchDeposits
        * @description fetch all deposits made to an account
        * @param {string} code unified currency code
        * @param {int|undefined} since the earliest time in ms to fetch deposits for
        * @param {int|undefined} limit the maximum number of deposits structures to retrieve
        * @param {object} params extra parameters specific to the bkex api endpoint
        * @returns {[object]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(code, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchDeposits() requires code argument")) ;
        }
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["startTime"] = since;
            object endTime = this.milliseconds();
            ((Dictionary<string, object>)request)["endTime"] = endTime;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["Size"] = limit; // Todo: id api-docs, 'size' is incorrectly required to be in Uppercase
        }
        object response = await this.privateSpotGetUWalletDepositRecord(this.extend(request, parameters));
        //
        // {
        //     "code": "0",
        //     "data": {
        //       "data": [
        //         {
        //           "createTime": "1622274255000",
        //           "currency": "BNB",
        //           "fromAddress": "bnb10af52w77pkehgxhnwgeca50q2t2354q4xexa5y",
        //           "hash": "97B982F497782C2777C0F6AD16CEAAC65A93A364B684A23A71CFBB8C010DEEA6",
        //           "id": "2021052923441510234383337",
        //           "status": "0",
        //           "toAddress": "bnb13w64gkc42c0l45m2p5me4qn35z0a3ej9ldks3j_82784659",
        //           "volume": 0.073
        //         }
        //       ],
        //       "total": 1
        //     },
        //     "msg": "success",
        //     "status": 0
        // }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object dataInner = this.safeValue(data, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(dataInner)); postFixIncrement(ref i))
        {
            ((Dictionary<string, object>)getValue(dataInner, i))["transactType"] = "deposit";
        }
        return this.parseTransactions(dataInner, currency, since, limit, parameters);
    }

    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bkex#fetchWithdrawals
        * @description fetch all withdrawals made from an account
        * @param {string} code unified currency code
        * @param {int|undefined} since the earliest time in ms to fetch withdrawals for
        * @param {int|undefined} limit the maximum number of withdrawals structures to retrieve
        * @param {object} params extra parameters specific to the bkex api endpoint
        * @returns {[object]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(code, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchWithdrawals() requires code argument")) ;
        }
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["startTime"] = since;
            object endTime = this.milliseconds();
            ((Dictionary<string, object>)request)["endTime"] = endTime;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["Size"] = limit; // Todo: id api-docs, 'size' is incorrectly required to be in Uppercase
        }
        object response = await this.privateSpotGetUWalletWithdrawRecord(this.extend(request, parameters));
        //
        // {
        //     "code": "0",
        //     "data": {
        //       "data": [
        //         {
        //           ...
        //         }
        //       ],
        //       "total": 1
        //     },
        //     "msg": "success",
        //     "status": 0
        // }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object dataInner = this.safeValue(data, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(dataInner)); postFixIncrement(ref i))
        {
            ((Dictionary<string, object>)getValue(dataInner, i))["transactType"] = "withdrawal";
        }
        return this.parseTransactions(dataInner, currency, since, limit, parameters);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // fetchDeposits
        //
        // {
        //   "createTime": "1622274255000",
        //   "currency": "BNB",
        //   "fromAddress": "bnb10af52w77pkehgxhnwgeca50q2t2354q4xexa5y",
        //   "hash": "97B982F497782C2777C0F6AD16CEAAC65A93A364B684A23A71CFBB8C010DEEA6",
        //   "id": "2021052923441510234383337",
        //   "status": "0",
        //   "toAddress": "bnb13w64gkc42c0l45m2p5me4qn35z0a3ej9ldks3j_82784659",
        //   "volume": 0.073
        // }
        //
        object id = this.safeString(transaction, "id");
        object amount = this.safeNumber(transaction, "volume");
        object addressTo = this.safeValue(transaction, "toAddress", new Dictionary<string, object>() {});
        object addressFrom = this.safeString(transaction, "fromAddress");
        object txid = this.safeString(transaction, "hash");
        object type = this.safeString(transaction, "transactType");
        object timestamp = this.safeInteger(transaction, "createTime");
        object currencyId = this.safeString(transaction, "currency");
        object code = this.safeCurrencyCode(currencyId, currency);
        object status = this.parseTransactionStatus(this.safeString(transaction, "status"));
        return new Dictionary<string, object>() {
            { "id", id },
            { "currency", code },
            { "amount", amount },
            { "network", null },
            { "address", addressTo },
            { "addressTo", addressTo },
            { "addressFrom", addressFrom },
            { "tag", null },
            { "tagTo", null },
            { "tagFrom", null },
            { "status", status },
            { "type", type },
            { "updated", null },
            { "txid", txid },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "fee", new Dictionary<string, object>() {
                { "currency", code },
                { "cost", null },
            } },
            { "info", transaction },
        };
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "-1", "failed" },
            { "0", "ok" },
            { "3", "pending" },
            { "5", "pending" },
        };
        return this.safeString(statuses, status, status);
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name bkex#createOrder
        * @description create a trade order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float|undefined} price the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} params extra parameters specific to the bkex api endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object direction = ((bool) isTrue((isEqual(side, "buy")))) ? "BID" : "ASK";
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "type", ((string)type).ToUpper() },
            { "volume", this.amountToPrecision(symbol, amount) },
            { "direction", direction },
        };
        if (isTrue(isTrue((!isEqual(type, "market"))) && isTrue((!isEqual(price, null)))))
        {
            ((Dictionary<string, object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        object response = await this.privateSpotPostUOrderCreate(this.extend(request, parameters));
        //
        // {
        //     "code": "0",
        //     "data": "2022030302410146630023187",
        //     "msg": "Create Order Successfully",
        //     "status": 0
        // }
        //
        return this.parseOrder(response, market);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bkex#cancelOrder
        * @description cancels an open order
        * @param {string} id order id
        * @param {string|undefined} symbol unified symbol of the market the order was made in
        * @param {object} params extra parameters specific to the bkex api endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = ((bool) isTrue((!isEqual(symbol, null)))) ? this.market(symbol) : null;
        object request = new Dictionary<string, object>() {
            { "orderId", id },
        };
        object response = await this.privateSpotPostUOrderCancel(this.extend(request, parameters));
        //
        // {
        //     "code": "0",
        //     "data": "2022030303032700030025325",
        //     "status": 0
        // }
        //
        return this.parseOrder(response, market);
    }

    public async virtual Task<object> cancelOrders(object ids, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bkex#cancelOrders
        * @description cancel multiple orders
        * @param {[string]} ids order ids
        * @param {string|undefined} symbol unified market symbol, default is undefined
        * @param {object} params extra parameters specific to the bkex api endpoint
        * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (!isTrue((ids.GetType().IsGenericType && ids.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrders() ids argument should be an array")) ;
        }
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "orders", this.json(ids) },
        };
        object response = await this.privateSpotPostUOrderBatchCancel(this.extend(request, parameters));
        // {
        //     "code": 0,
        //     "msg": "success",
        //     "data": {
        //        "success": 2,
        //        "fail": 0,
        //        "results": ["2019062312313131231"," 2019063123131312313"]
        //     }
        // }
        object data = this.safeValue(response, "data");
        object results = this.safeValue(data, "results");
        object market = ((bool) isTrue((!isEqual(symbol, null)))) ? this.market(symbol) : null;
        return this.parseOrders(results, market, null, null, parameters);
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bkex#fetchOpenOrders
        * @description fetch all unfilled currently open orders
        * @param {string} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch open orders for
        * @param {int|undefined} limit the maximum number of  open orders structures to retrieve
        * @param {object} params extra parameters specific to the bkex api endpoint
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOpenOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["size"] = limit; // Todo: id api-docs, 'size' is incorrectly required to be in Uppercase
        }
        object response = await this.privateSpotGetUOrderOpenOrders(this.extend(request, parameters));
        //
        // {
        //     "code": "0",
        //     "data": {
        //       "data": [
        //         {
        //           "createdTime": "1646248301418",
        //           "dealVolume": "0E-18",
        //           "direction": "BID",
        //           "frozenVolumeByOrder": "2.421300000000000000",
        //           "id": "2022030303114141830007699",
        //           "price": "0.150000000000000000",
        //           "source": "WALLET",
        //           "status": "0",
        //           "symbol": "BKK_USDT",
        //           "totalVolume": "16.142000000000000000",
        //           "type": "LIMIT"
        //         }
        //       ],
        //       "pageRequest": {
        //         "asc": false,
        //         "orderBy": "id",
        //         "page": "1",
        //         "size": 10
        //       },
        //       "total": 1
        //     },
        //     "msg": "success",
        //     "status": 0
        // }
        //
        object result = this.safeValue(response, "data");
        object innerData = this.safeValue(result, "data");
        return this.parseOrders(innerData, market, since, limit, parameters);
    }

    public async virtual Task<object> fetchOpenOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bkex#fetchOpenOrder
        * @description fetch an open order by it's id
        * @param {string} id order id
        * @param {string|undefined} symbol unified market symbol, default is undefined
        * @param {object} params extra parameters specific to the bkex api endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "orderId", id },
        };
        object response = await this.privateSpotGetUOrderOpenOrderDetail(this.extend(request, parameters));
        //
        // {
        //     "code": "0",
        //     "data": {
        //       "createdTime": "1646248301418",
        //       "dealAvgPrice": "0",
        //       "dealVolume": "0E-18",
        //       "direction": "BID",
        //       "frozenVolumeByOrder": "2.421300000000000000",
        //       "id": "2022030303114141830002452",
        //       "price": "0.150000000000000000",
        //       "source": "WALLET",
        //       "status": "0",
        //       "symbol": "BKK_USDT",
        //       "totalVolume": "16.142000000000000000",
        //       "type": "LIMIT",
        //       "updateTime": 1646248301418
        //     },
        //     "msg": "success",
        //     "status": 0
        // }
        //
        object data = this.safeValue(response, "data");
        object market = ((bool) isTrue((!isEqual(symbol, null)))) ? this.market(symbol) : null;
        return this.parseOrder(data, market);
    }

    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bkex#fetchClosedOrders
        * @description fetches information on multiple closed orders made by the user
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int|undefined} since the earliest time in ms to fetch orders for
        * @param {int|undefined} limit the maximum number of  orde structures to retrieve
        * @param {object} params extra parameters specific to the bkex api endpoint
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchClosedOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["size"] = limit; // Todo: id api-docs, 'size' is incorrectly required to be in Uppercase
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["startTime"] = since;
        }
        object response = await this.privateSpotGetUOrderHistoryOrders(this.extend(request, parameters));
        //
        // {
        //     "code": "0",
        //     "data": {
        //       "data": [
        //         {
        //           "createdTime": "1646247807000",
        //           "dealAvgPrice": "0",
        //           "dealVolume": "0",
        //           "direction": "BID",
        //           "frozenVolumeByOrder": "1.65",
        //           "id": "2022030303032700030025943",
        //           "price": "0.15",
        //           "source": "WALLET",
        //           "status": "2",
        //           "symbol": "BKK_USDT",
        //           "totalVolume": "11",
        //           "type": "LIMIT",
        //           "updateTime": 1646247852558
        //         },
        //       ],
        //       "pageRequest": {
        //         "asc": false,
        //         "orderBy": "id",
        //         "page": "1",
        //         "size": 10
        //       },
        //       "total": 6
        //     },
        //     "msg": "success",
        //     "status": 0
        // }
        //
        object result = this.safeValue(response, "data");
        object innerData = this.safeValue(result, "data");
        return this.parseOrders(innerData, market, since, limit, parameters);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // fetchOpenOrders
        //
        //  {
        //       "createdTime": "1646248301418",
        //       "dealVolume": "0E-18",
        //       "direction": "BID",
        //       "frozenVolumeByOrder": "2.421300000000000000",
        //       "id": "2022030303114141830007699",
        //       "price": "0.150000000000000000",
        //       "source": "WALLET",
        //       "status": "0",
        //       "symbol": "BKK_USDT",
        //       "totalVolume": "16.142000000000000000",
        //       "type": "LIMIT"
        //       "stopPrice":  "0.14",            // present only for 'stop' order types
        //       "operator":  ">="                // present only for 'stop' order types
        //       "dealAvgPrice": "0",             // only present in 'fetchOrder' & 'fetchClosedOrders'
        //       "updateTime": 1646248301418      // only present in 'fetchOrder' & 'fetchClosedOrders'
        //  }
        //
        object timestamp = this.safeInteger(order, "createdTime");
        object updateTime = this.safeInteger(order, "updateTime");
        object filled = this.safeString(order, "dealVolume");
        object side = this.parseOrderSide(this.safeString(order, "direction"));
        object id = this.safeString2(order, "id", "data");
        object price = this.safeString(order, "price");
        object rawStatus = this.safeString(order, "status");
        object rawType = this.safeString(order, "type");
        object type = this.parseOrderType(rawType);
        object postOnly = false;
        if (isTrue(isEqual(rawType, "LIMIT_MAKER")))
        {
            postOnly = true;
        }
        object status = null;
        if (isTrue(!isEqual(timestamp, null)))
        {
            // cancelOrder handling
            status = this.parseOrderStatus(rawStatus);
        }
        object marketId = this.safeString(order, "symbol");
        market = this.safeMarket(marketId, market);
        object amount = this.safeString(order, "totalVolume");
        object stopPrice = this.safeNumber(order, "stopPrice");
        object average = this.safeString(order, "dealAvgPrice");
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", id },
            { "clientOrderId", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", updateTime },
            { "status", status },
            { "symbol", getValue(market, "symbol") },
            { "type", type },
            { "timeInForce", null },
            { "postOnly", postOnly },
            { "side", side },
            { "price", price },
            { "stopPrice", stopPrice },
            { "triggerPrice", stopPrice },
            { "average", average },
            { "amount", amount },
            { "filled", filled },
            { "remaining", null },
            { "cost", null },
            { "trades", null },
            { "fee", null },
            { "info", order },
        }, market);
    }

    public virtual object parseOrderSide(object side)
    {
        object sides = new Dictionary<string, object>() {
            { "BID", "buy" },
            { "ASK", "sell" },
        };
        return this.safeString(sides, side, side);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "0", "open" },
            { "1", "closed" },
            { "2", "canceled" },
            { "3", "open" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object parseOrderType(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "MARKET", "market" },
            { "LIMIT", "limit" },
            { "LIMIT_MAKER", "limit" },
            { "STOP_LIMIT", "limit" },
        };
        return this.safeString(statuses, status, status);
    }

    public async override Task<object> fetchTransactionFees(object codes = null, object parameters = null)
    {
        /**
        * @method
        * @name bkex#fetchTransactionFees
        * @description *DEPRECATED* please use fetchDepositWithdrawFees instead
        * @see https://bkexapi.github.io/docs/api_en.htm?shell#basicInformation-2
        * @param {[string]|undefined} codes list of unified currency codes
        * @param {object} params extra parameters specific to the bkex api endpoint
        * @returns {object} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.publicSpotGetCommonCurrencys(parameters);
        //
        //      {
        //          "msg": "success",
        //          "code": "0",
        //          "data": [
        //            {
        //              "currency": "ETH",
        //              "maxWithdrawOneDay": 2000,
        //              "maxWithdrawSingle": 2000,
        //              "minWithdrawSingle": 0.1,
        //              "supportDeposit": true,
        //              "supportTrade": true,
        //              "supportWithdraw": true,
        //              "withdrawFee": 0.008
        //            },
        //            {
        //              "currency": "BTC",
        //              "maxWithdrawOneDay": 100,
        //              "maxWithdrawSingle": 100,
        //              "minWithdrawSingle": 0.01,
        //              "supportDeposit": true,
        //              "supportTrade": true,
        //              "supportWithdraw": true,
        //              "withdrawFee": 0.008
        //            }
        //          ]
        //      }
        //
        return this.parseTransactionFees(response, codes);
    }

    public virtual object parseTransactionFees(object response, object codes = null)
    {
        object data = this.safeValue(response, "data");
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            object currencyId = this.safeString(entry, "currency");
            object currency = this.safeCurrency(currencyId);
            object code = this.safeString(currency, "code");
            if (isTrue(isTrue((isEqual(codes, null))) || isTrue((this.inArray(code, codes)))))
            {
                ((Dictionary<string, object>)result)[(string)code] = new Dictionary<string, object>() {
                    { "withdraw", this.parseTransactionFee(entry) },
                    { "deposit", null },
                    { "info", entry },
                };
            }
        }
        return result;
    }

    public virtual object parseTransactionFee(object transaction, object currency = null)
    {
        //
        //      {
        //          "currency": "ETH",
        //          "maxWithdrawOneDay": 2000,
        //          "maxWithdrawSingle": 2000,
        //          "minWithdrawSingle": 0.1,
        //          "supportDeposit": true,
        //          "supportTrade": true,
        //          "supportWithdraw": true,
        //          "withdrawFee": 0.008
        //      }
        //
        return this.safeNumber(transaction, "withdrawFee");
    }

    public async override Task<object> fetchDepositWithdrawFees(object codes = null, object parameters = null)
    {
        /**
        * @method
        * @name bkex#fetchDepositWithdrawFees
        * @description fetch deposit and withdraw fees
        * @see https://bkexapi.github.io/docs/api_en.htm?shell#basicInformation-2
        * @param {[string]|undefined} codes list of unified currency codes
        * @param {object} params extra parameters specific to the bkex api endpoint
        * @returns {object} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.publicSpotGetCommonCurrencys(parameters);
        //
        //    {
        //        "msg": "success",
        //        "code": "0",
        //        "data": [
        //            {
        //                "currency": "ETH",
        //                "maxWithdrawOneDay": 2000,
        //                "maxWithdrawSingle": 2000,
        //                "minWithdrawSingle": 0.1,
        //                "supportDeposit": true,
        //                "supportTrade": true,
        //                "supportWithdraw": true,
        //                "withdrawFee": 0.008
        //            },
        //            {
        //                "currency": "BTC",
        //                "maxWithdrawOneDay": 100,
        //                "maxWithdrawSingle": 100,
        //                "minWithdrawSingle": 0.01,
        //                "supportDeposit": true,
        //                "supportTrade": true,
        //                "supportWithdraw": true,
        //                "withdrawFee": 0.008
        //            }
        //        ]
        //    }
        //
        object data = this.safeValue(response, "data");
        return this.parseDepositWithdrawFees(data, codes, "currency");
    }

    public override object parseDepositWithdrawFee(object fee, object currency = null)
    {
        //
        //      {
        //          "currency": "ETH",
        //          "maxWithdrawOneDay": 2000,
        //          "maxWithdrawSingle": 2000,
        //          "minWithdrawSingle": 0.1,
        //          "supportDeposit": true,
        //          "supportTrade": true,
        //          "supportWithdraw": true,
        //          "withdrawFee": 0.008
        //      }
        //
        object result = this.depositWithdrawFee(fee);
        ((Dictionary<string, object>)getValue(result, "withdraw"))["fee"] = this.safeNumber(fee, "withdrawFee");
        return result;
    }

    public async override Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bkex#fetchFundingRateHistory
        * @see https://bkexapi.github.io/docs/api_en.htm?shell#contract-fundingRate
        * @description fetches historical funding rate prices
        * @param {string|undefined} symbol unified symbol of the market to fetch the funding rate history for
        * @param {int|undefined} since timestamp in ms of the earliest funding rate to fetch
        * @param {int|undefined} limit the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/en/latest/manual.html?#funding-rate-history-structure} to fetch
        * @param {object} params extra parameters specific to the bkex api endpoint
        * @returns {[object]} a list of [funding rate structures]{@link https://docs.ccxt.com/en/latest/manual.html?#funding-rate-history-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchFundingRateHistory() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.publicSwapGetMarketFundingRate(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "msg": "success",
        //         "data": [
        //             {
        //                 "symbol": "btc_usdt",
        //                 "rate": "-0.00008654",
        //                 "time": 1670658302128
        //             },
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object rates = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            object marketId = this.safeString(entry, "symbol");
            object symbolInner = this.safeSymbol(marketId);
            object timestamp = this.safeInteger(entry, "time");
            ((List<object>)rates).Add(new Dictionary<string, object>() {
                { "info", entry },
                { "symbol", symbolInner },
                { "fundingRate", this.safeNumber(entry, "rate") },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
            });
        }
        object sorted = this.sortBy(rates, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, getValue(market, "symbol"), since, limit);
    }

    public async override Task<object> fetchMarketLeverageTiers(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bkex#fetchMarketLeverageTiers
        * @see https://bkexapi.github.io/docs/api_en.htm?shell#contract-riskLimit
        * @description retrieve information on the maximum leverage, for different trade sizes for a single market
        * @param {string} symbol unified market symbol
        * @param {object} params extra parameters specific to the bkex api endpoint
        * @returns {object} a [leverage tiers structure]{@link https://docs.ccxt.com/#/?id=leverage-tiers-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "swap")))
        {
            throw new BadRequest ((string)add(this.id, " fetchMarketLeverageTiers() supports swap markets only")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.publicSwapGetMarketRiskLimit(this.extend(request, parameters));
        //
        //     {
        //         "code": 0,
        //         "msg": "success",
        //         "data": [
        //             {
        //                 "symbol": "btc_usdt",
        //                 "minValue": "0",
        //                 "maxValue": "500000",
        //                 "maxLeverage": 100,
        //                 "maintenanceMarginRate": "0.005"
        //             },
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        return this.parseMarketLeverageTiers(data, market);
    }

    public override object parseMarketLeverageTiers(object info, object market = null)
    {
        //
        //     [
        //         {
        //             "symbol": "btc_usdt",
        //             "minValue": "0",
        //             "maxValue": "500000",
        //             "maxLeverage": 100,
        //             "maintenanceMarginRate": "0.005"
        //         },
        //     ]
        //
        object tiers = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(info)); postFixIncrement(ref i))
        {
            object tier = getValue(info, i);
            object marketId = this.safeString(info, "symbol");
            market = this.safeMarket(marketId, market);
            ((List<object>)tiers).Add(new Dictionary<string, object>() {
                { "tier", this.sum(i, 1) },
                { "currency", getValue(market, "settle") },
                { "minNotional", this.safeNumber(tier, "minValue") },
                { "maxNotional", this.safeNumber(tier, "maxValue") },
                { "maintenanceMarginRate", this.safeNumber(tier, "maintenanceMarginRate") },
                { "maxLeverage", this.safeNumber(tier, "maxLeverage") },
                { "info", tier },
            });
        }
        return tiers;
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object signed = isEqual(getValue(api, 0), "private");
        object endpoint = getValue(api, 1);
        object pathPart = ((bool) isTrue((isEqual(endpoint, "spot")))) ? this.version : add("fapi/", this.version);
        object url = add(add(add(getValue(getValue(this.urls, "api"), endpoint), "/"), pathPart), this.implodeParams(path, parameters));
        parameters = this.omit(parameters, this.extractParams(path));
        object paramsSortedEncoded = "";
        if (isTrue(getArrayLength(new List<object>(((Dictionary<string,object>)parameters).Keys))))
        {
            paramsSortedEncoded = this.rawencode(this.keysort(parameters));
            if (isTrue(isEqual(method, "GET")))
            {
                url = add(url, add("?", paramsSortedEncoded));
            }
        }
        if (isTrue(signed))
        {
            this.checkRequiredCredentials();
            object signature = this.hmac(this.encode(paramsSortedEncoded), this.encode(this.secret), sha256);
            headers = new Dictionary<string, object>() {
                { "Cache-Control", "no-cache" },
                { "Content-type", "application/x-www-form-urlencoded" },
                { "X_ACCESS_KEY", this.apiKey },
                { "X_SIGNATURE", signature },
            };
            if (isTrue(!isEqual(method, "GET")))
            {
                body = paramsSortedEncoded;
            }
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;
        }
        //
        // success
        //
        //   {
        //      "code": "0",
        //      "msg": "success",
        //      "status": 0,
        //      "data": [...],
        //   }
        //
        //
        // action error
        //
        //   {
        //     "code":1005,
        //     "msg":"BKK:Not Enough balance",
        //     "status":0
        //   }
        //
        //
        // HTTP error
        //
        //   {
        //      "timestamp": "1646041085490",
        //      "status": "403",
        //      "error": "Forbidden",
        //      "message": "",
        //      "path": "/whatever/incorrect/path"
        //   }
        //
        object message = this.safeValue(response, "msg");
        if (isTrue(isEqual(message, "success")))
        {
            return null;
        }
        object responseCode = this.safeString(response, "code");
        if (isTrue(!isEqual(responseCode, "0")))
        {
            object feedback = add(add(this.id, " "), body);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), responseCode, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), body, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }
}
