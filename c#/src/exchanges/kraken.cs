using ccxt;
namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

partial class kraken : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "kraken" },
            { "name", "Kraken" },
            { "countries", new List<object>() {"US"} },
            { "version", "0" },
            { "rateLimit", 1000 },
            { "certified", false },
            { "pro", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", true },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "addMargin", false },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "cancelOrders", true },
                { "createDepositAddress", true },
                { "createOrder", true },
                { "createStopLimitOrder", true },
                { "createStopMarketOrder", true },
                { "createStopOrder", true },
                { "editOrder", true },
                { "fetchBalance", true },
                { "fetchBorrowInterest", false },
                { "fetchBorrowRate", false },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchBorrowRates", false },
                { "fetchClosedOrders", true },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", true },
                { "fetchDeposits", true },
                { "fetchFundingHistory", false },
                { "fetchFundingRate", false },
                { "fetchFundingRateHistory", false },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", false },
                { "fetchLedger", true },
                { "fetchLedgerEntry", true },
                { "fetchLeverageTiers", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrderTrades", "emulated" },
                { "fetchPositions", true },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", true },
                { "fetchTradingFees", false },
                { "fetchWithdrawals", true },
                { "setLeverage", false },
                { "setMarginMode", false },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", 1 },
                { "5m", 5 },
                { "15m", 15 },
                { "30m", 30 },
                { "1h", 60 },
                { "4h", 240 },
                { "1d", 1440 },
                { "1w", 10080 },
                { "2w", 21600 },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/51840849/76173629-fc67fb00-61b1-11ea-84fe-f2de582f58a3.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "public", "https://api.kraken.com" },
                    { "private", "https://api.kraken.com" },
                    { "zendesk", "https://kraken.zendesk.com/api/v2/help_center/en-us/articles" },
                } },
                { "www", "https://www.kraken.com" },
                { "doc", "https://www.kraken.com/features/api" },
                { "fees", "https://www.kraken.com/en-us/features/fee-schedule" },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "tierBased", true },
                    { "percentage", true },
                    { "taker", this.parseNumber("0.0026") },
                    { "maker", this.parseNumber("0.0016") },
                    { "tiers", new Dictionary<string, object>() {
                        { "taker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.0026")}, new List<object> {this.parseNumber("50000"), this.parseNumber("0.0024")}, new List<object> {this.parseNumber("100000"), this.parseNumber("0.0022")}, new List<object> {this.parseNumber("250000"), this.parseNumber("0.0020")}, new List<object> {this.parseNumber("500000"), this.parseNumber("0.0018")}, new List<object> {this.parseNumber("1000000"), this.parseNumber("0.0016")}, new List<object> {this.parseNumber("2500000"), this.parseNumber("0.0014")}, new List<object> {this.parseNumber("5000000"), this.parseNumber("0.0012")}, new List<object> {this.parseNumber("10000000"), this.parseNumber("0.0001")}} },
                        { "maker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.0016")}, new List<object> {this.parseNumber("50000"), this.parseNumber("0.0014")}, new List<object> {this.parseNumber("100000"), this.parseNumber("0.0012")}, new List<object> {this.parseNumber("250000"), this.parseNumber("0.0010")}, new List<object> {this.parseNumber("500000"), this.parseNumber("0.0008")}, new List<object> {this.parseNumber("1000000"), this.parseNumber("0.0006")}, new List<object> {this.parseNumber("2500000"), this.parseNumber("0.0004")}, new List<object> {this.parseNumber("5000000"), this.parseNumber("0.0002")}, new List<object> {this.parseNumber("10000000"), this.parseNumber("0.0")}} },
                    } },
                } },
            } },
            { "handleContentTypeApplicationZip", true },
            { "api", new Dictionary<string, object>() {
                { "zendesk", new Dictionary<string, object>() {
                    { "get", new List<object>() {"360000292886", "201893608"} },
                } },
                { "public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "Assets", 1 },
                        { "AssetPairs", 1 },
                        { "Depth", 1 },
                        { "OHLC", 1 },
                        { "Spread", 1 },
                        { "Ticker", 1 },
                        { "Time", 1 },
                        { "Trades", 1 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "post", new Dictionary<string, object>() {
                        { "AddOrder", 0 },
                        { "AddOrderBatch", 0 },
                        { "AddExport", 3 },
                        { "Balance", 3 },
                        { "CancelAll", 3 },
                        { "CancelOrder", 0 },
                        { "CancelOrderBatch", 0 },
                        { "ClosedOrders", 6 },
                        { "DepositAddresses", 3 },
                        { "DepositMethods", 3 },
                        { "DepositStatus", 3 },
                        { "EditOrder", 0 },
                        { "ExportStatus", 3 },
                        { "GetWebSocketsToken", 3 },
                        { "Ledgers", 6 },
                        { "OpenOrders", 3 },
                        { "OpenPositions", 3 },
                        { "QueryLedgers", 3 },
                        { "QueryOrders", 3 },
                        { "QueryTrades", 3 },
                        { "RetrieveExport", 3 },
                        { "RemoveExport", 3 },
                        { "TradeBalance", 3 },
                        { "TradesHistory", 6 },
                        { "TradeVolume", 3 },
                        { "Withdraw", 3 },
                        { "WithdrawCancel", 3 },
                        { "WithdrawInfo", 3 },
                        { "WithdrawStatus", 3 },
                        { "Stake", 3 },
                        { "Unstake", 3 },
                        { "Staking/Assets", 3 },
                        { "Staking/Pending", 3 },
                        { "Staking/Transactions", 3 },
                        { "CreateSubaccount", 3 },
                        { "AccountTransfer", 3 },
                    } },
                } },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "LUNA", "LUNC" },
                { "LUNA2", "LUNA" },
                { "REPV2", "REP" },
                { "REP", "REPV1" },
                { "UST", "USTC" },
                { "XBT", "BTC" },
                { "XBT.M", "BTC.M" },
                { "XDG", "DOGE" },
            } },
            { "options", new Dictionary<string, object>() {
                { "marketsByAltname", new Dictionary<string, object>() {} },
                { "delistedMarketsById", new Dictionary<string, object>() {} },
                { "inactiveCurrencies", new List<object>() {"CAD", "USD", "JPY", "GBP"} },
                { "networks", new Dictionary<string, object>() {
                    { "ETH", "ERC20" },
                    { "TRX", "TRC20" },
                } },
                { "depositMethods", new Dictionary<string, object>() {
                    { "1INCH", "1inch (1INCH)" },
                    { "AAVE", "Aave" },
                    { "ADA", "ADA" },
                    { "ALGO", "Algorand" },
                    { "ANKR", "ANKR (ANKR)" },
                    { "ANT", "Aragon (ANT)" },
                    { "ATOM", "Cosmos" },
                    { "AXS", "Axie Infinity Shards (AXS)" },
                    { "BADGER", "Bager DAO (BADGER)" },
                    { "BAL", "Balancer (BAL)" },
                    { "BAND", "Band Protocol (BAND)" },
                    { "BAT", "BAT" },
                    { "BCH", "Bitcoin Cash" },
                    { "BNC", "Bifrost (BNC)" },
                    { "BNT", "Bancor (BNT)" },
                    { "BTC", "Bitcoin" },
                    { "CHZ", "Chiliz (CHZ)" },
                    { "COMP", "Compound (COMP)" },
                    { "CQT", "	Covalent Query Token (CQT)" },
                    { "CRV", "Curve DAO Token (CRV)" },
                    { "CTSI", "Cartesi (CTSI)" },
                    { "DAI", "Dai" },
                    { "DASH", "Dash" },
                    { "DOGE", "Dogecoin" },
                    { "DOT", "Polkadot" },
                    { "DYDX", "dYdX (DYDX)" },
                    { "ENJ", "Enjin Coin (ENJ)" },
                    { "EOS", "EOS" },
                    { "ETC", "Ether Classic (Hex)" },
                    { "ETH", "Ether (Hex)" },
                    { "EWT", "Energy Web Token" },
                    { "FEE", "Kraken Fee Credit" },
                    { "FIL", "Filecoin" },
                    { "FLOW", "Flow" },
                    { "GHST", "Aavegotchi (GHST)" },
                    { "GNO", "GNO" },
                    { "GRT", "GRT" },
                    { "ICX", "Icon" },
                    { "INJ", "Injective Protocol (INJ)" },
                    { "KAR", "Karura (KAR)" },
                    { "KAVA", "Kava" },
                    { "KEEP", "Keep Token (KEEP)" },
                    { "KNC", "Kyber Network (KNC)" },
                    { "KSM", "Kusama" },
                    { "LINK", "Link" },
                    { "LPT", "Livepeer Token (LPT)" },
                    { "LRC", "Loopring (LRC)" },
                    { "LSK", "Lisk" },
                    { "LTC", "Litecoin" },
                    { "MANA", "MANA" },
                    { "MATIC", "Polygon (MATIC)" },
                    { "MINA", "Mina" },
                    { "MIR", "Mirror Protocol (MIR)" },
                    { "MKR", "Maker (MKR)" },
                    { "MLN", "MLN" },
                    { "MOVR", "Moonriver (MOVR)" },
                    { "NANO", "NANO" },
                    { "OCEAN", "OCEAN" },
                    { "OGN", "Origin Protocol (OGN)" },
                    { "OMG", "OMG" },
                    { "OXT", "Orchid (OXT)" },
                    { "OXY", "Oxygen (OXY)" },
                    { "PAXG", "PAX (Gold)" },
                    { "PERP", "Perpetual Protocol (PERP)" },
                    { "PHA", "Phala (PHA)" },
                    { "QTUM", "QTUM" },
                    { "RARI", "Rarible (RARI)" },
                    { "RAY", "Raydium (RAY)" },
                    { "REN", "Ren Protocol (REN)" },
                    { "REP", "REPv2" },
                    { "REPV1", "REP" },
                    { "SAND", "The Sandbox (SAND)" },
                    { "SC", "Siacoin" },
                    { "SDN", "Shiden (SDN)" },
                    { "SOL", "Solana" },
                    { "SNX", "Synthetix  Network (SNX)" },
                    { "SRM", "Serum" },
                    { "STORJ", "Storj (STORJ)" },
                    { "SUSHI", "Sushiswap (SUSHI)" },
                    { "TBTC", "tBTC" },
                    { "TRX", "Tron" },
                    { "UNI", "UNI" },
                    { "USDC", "USDC" },
                    { "USDT", "Tether USD (ERC20)" },
                    { "USDT-TRC20", "Tether USD (TRC20)" },
                    { "WAVES", "Waves" },
                    { "WBTC", "Wrapped Bitcoin (WBTC)" },
                    { "XLM", "Stellar XLM" },
                    { "XMR", "Monero" },
                    { "XRP", "Ripple XRP" },
                    { "XTZ", "XTZ" },
                    { "YFI", "YFI" },
                    { "ZEC", "Zcash (Transparent)" },
                    { "ZRX", "0x (ZRX)" },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "exceptions", new Dictionary<string, object>() {
                { "EQuery:Invalid asset pair", typeof(BadSymbol) },
                { "EAPI:Invalid key", typeof(AuthenticationError) },
                { "EFunding:Unknown withdraw key", typeof(InvalidAddress) },
                { "EFunding:Invalid amount", typeof(InsufficientFunds) },
                { "EService:Unavailable", typeof(ExchangeNotAvailable) },
                { "EDatabase:Internal error", typeof(ExchangeNotAvailable) },
                { "EService:Busy", typeof(ExchangeNotAvailable) },
                { "EQuery:Unknown asset", typeof(BadSymbol) },
                { "EAPI:Rate limit exceeded", typeof(DDoSProtection) },
                { "EOrder:Rate limit exceeded", typeof(DDoSProtection) },
                { "EGeneral:Internal error", typeof(ExchangeNotAvailable) },
                { "EGeneral:Temporary lockout", typeof(DDoSProtection) },
                { "EGeneral:Permission denied", typeof(PermissionDenied) },
                { "EOrder:Unknown order", typeof(InvalidOrder) },
                { "EOrder:Order minimum not met", typeof(InvalidOrder) },
                { "EGeneral:Invalid arguments", typeof(BadRequest) },
                { "ESession:Invalid session", typeof(AuthenticationError) },
                { "EAPI:Invalid nonce", typeof(InvalidNonce) },
                { "EFunding:No funding method", typeof(BadRequest) },
                { "EFunding:Unknown asset", typeof(BadSymbol) },
                { "EService:Market in post_only mode", typeof(OnMaintenance) },
                { "EGeneral:Too many requests", typeof(DDoSProtection) },
                { "ETrade:User Locked", typeof(AccountSuspended) },
            } },
        });
    }

    public override object feeToPrecision(object symbol, object fee)
    {
        return this.decimalToPrecision(fee, TRUNCATE, getValue(getValue(getValue(this.markets, symbol), "precision"), "amount"), this.precisionMode);
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name kraken#fetchMarkets
        * @description retrieves data on all markets for kraken
        * @param {object} params extra parameters specific to the exchange api endpoint
        * @returns {[object]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetAssetPairs(parameters);
        //
        //     {
        //         "error": [],
        //         "result": {
        //             "ADAETH": {
        //                 "altname": "ADAETH",
        //                 "wsname": "ADA\/ETH",
        //                 "aclass_base": "currency",
        //                 "base": "ADA",
        //                 "aclass_quote": "currency",
        //                 "quote": "XETH",
        //                 "lot": "unit",
        //                 "pair_decimals": 7,
        //                 "lot_decimals": 8,
        //                 "lot_multiplier": 1,
        //                 "leverage_buy": [],
        //                 "leverage_sell": [],
        //                 "fees": [
        //                     [0, 0.26],
        //                     [50000, 0.24],
        //                     [100000, 0.22],
        //                     [250000, 0.2],
        //                     [500000, 0.18],
        //                     [1000000, 0.16],
        //                     [2500000, 0.14],
        //                     [5000000, 0.12],
        //                     [10000000, 0.1]
        //                 ],
        //                 "fees_maker": [
        //                     [0, 0.16],
        //                     [50000, 0.14],
        //                     [100000, 0.12],
        //                     [250000, 0.1],
        //                     [500000, 0.08],
        //                     [1000000, 0.06],
        //                     [2500000, 0.04],
        //                     [5000000, 0.02],
        //                     [10000000, 0]
        //                 ],
        //                 "fee_volume_currency": "ZUSD",
        //                 "margin_call": 80,
        //                 "margin_stop": 40,
        //                 "ordermin": "1"
        //             },
        //         }
        //     }
        //
        object markets = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object keys = new List<object>(((Dictionary<string,object>)markets).Keys);
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object id = getValue(keys, i);
            object market = getValue(markets, id);
            object baseId = this.safeString(market, "base");
            object quoteId = this.safeString(market, "quote");
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            object darkpool = isGreaterThanOrEqual(getIndexOf(id, ".d"), 0);
            object altname = this.safeString(market, "altname");
            object makerFees = this.safeValue(market, "fees_maker", new List<object>() {});
            object firstMakerFee = this.safeValue(makerFees, 0, new List<object>() {});
            object firstMakerFeeRate = this.safeString(firstMakerFee, 1);
            object maker = null;
            if (isTrue(!isEqual(firstMakerFeeRate, null)))
            {
                maker = this.parseNumber(Precise.stringDiv(firstMakerFeeRate, "100"));
            }
            object takerFees = this.safeValue(market, "fees", new List<object>() {});
            object firstTakerFee = this.safeValue(takerFees, 0, new List<object>() {});
            object firstTakerFeeRate = this.safeString(firstTakerFee, 1);
            object taker = null;
            if (isTrue(!isEqual(firstTakerFeeRate, null)))
            {
                taker = this.parseNumber(Precise.stringDiv(firstTakerFeeRate, "100"));
            }
            object leverageBuy = this.safeValue(market, "leverage_buy", new List<object>() {});
            object leverageBuyLength = getArrayLength(leverageBuy);
            object precisionPrice = this.parseNumber(this.parsePrecision(this.safeString(market, "pair_decimals")));
            ((List<object>)result).Add(new Dictionary<string, object>() {
                { "id", id },
                { "symbol", ((bool) isTrue(darkpool)) ? altname : (add(add(bs, "/"), quote)) },
                { "base", bs },
                { "quote", quote },
                { "settle", null },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", null },
                { "darkpool", darkpool },
                { "altname", getValue(market, "altname") },
                { "type", "spot" },
                { "spot", true },
                { "margin", (isGreaterThan(leverageBuyLength, 0)) },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "active", true },
                { "contract", false },
                { "linear", null },
                { "inverse", null },
                { "taker", taker },
                { "maker", maker },
                { "contractSize", null },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", this.parseNumber(this.parsePrecision(this.safeString(market, "lot_decimals"))) },
                    { "price", precisionPrice },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", this.parseNumber("1") },
                        { "max", this.safeNumber(leverageBuy, subtract(leverageBuyLength, 1), 1) },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "ordermin") },
                        { "max", null },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", precisionPrice },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "info", market },
            });
        }
        result = this.appendInactiveMarkets(result);
        ((Dictionary<string, object>)this.options)["marketsByAltname"] = this.indexBy(result, "altname");
        return result;
    }

    public override object safeCurrency(object currencyId, object currency = null)
    {
        if (isTrue(!isEqual(currencyId, null)))
        {
            if (isTrue(isGreaterThan(getArrayLength(currencyId), 3)))
            {
                if (isTrue(isTrue((isEqual(getIndexOf(currencyId, "X"), 0))) || isTrue((isEqual(getIndexOf(currencyId, "Z"), 0)))))
                {
                    if (isTrue(isGreaterThan(getIndexOf(currencyId, "."), 0)))
                    {
                        return base.safeCurrency(currencyId, currency);
                    } else
                    {
                        currencyId = ((string)currencyId).Substring((int)1);
                    }
                }
            }
        }
        return base.safeCurrency(currencyId, currency);
    }

    public virtual object appendInactiveMarkets(object result)
    {
        // result should be an array to append to
        object precision = new Dictionary<string, object>() {
            { "amount", this.parseNumber("1e-8") },
            { "price", this.parseNumber("1e-8") },
        };
        object costLimits = new Dictionary<string, object>() {
            { "min", null },
            { "max", null },
        };
        object priceLimits = new Dictionary<string, object>() {
            { "min", getValue(precision, "price") },
            { "max", null },
        };
        object amountLimits = new Dictionary<string, object>() {
            { "min", getValue(precision, "amount") },
            { "max", null },
        };
        object limits = new Dictionary<string, object>() {
            { "amount", amountLimits },
            { "price", priceLimits },
            { "cost", costLimits },
        };
        object defaults = new Dictionary<string, object>() {
            { "darkpool", false },
            { "info", null },
            { "maker", null },
            { "taker", null },
            { "active", false },
            { "precision", precision },
            { "limits", limits },
        };
        object markets = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(markets)); postFixIncrement(ref i))
        {
            ((List<object>)result).Add(this.extend(defaults, getValue(markets, i)));
        }
        return result;
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name kraken#fetchCurrencies
        * @description fetches all available currencies on an exchange
        * @param {object} params extra parameters specific to the kraken api endpoint
        * @returns {object} an associative dictionary of currencies
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetAssets(parameters);
        //
        //     {
        //         "error": [],
        //         "result": {
        //             "ADA": { "aclass": "currency", "altname": "ADA", "decimals": 8, "display_decimals": 6 },
        //             "BCH": { "aclass": "currency", "altname": "BCH", "decimals": 10, "display_decimals": 5 },
        //             ...
        //         },
        //     }
        //
        object currencies = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object ids = new List<object>(((Dictionary<string,object>)currencies).Keys);
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(ids)); postFixIncrement(ref i))
        {
            object id = getValue(ids, i);
            object currency = getValue(currencies, id);
            // todo: will need to rethink the fees
            // see: https://support.kraken.com/hc/en-us/articles/201893608-What-are-the-withdrawal-fees-
            // to add support for multiple withdrawal/deposit methods and
            // differentiated fees for each particular method
            object code = this.safeCurrencyCode(this.safeString(currency, "altname"));
            object precision = this.parseNumber(this.parsePrecision(this.safeString(currency, "decimals")));
            // assumes all currencies are active except those listed above
            object active = !isTrue(this.inArray(code, getValue(this.options, "inactiveCurrencies")));
            ((Dictionary<string, object>)result)[(string)code] = new Dictionary<string, object>() {
                { "id", id },
                { "code", code },
                { "info", currency },
                { "name", code },
                { "active", active },
                { "deposit", null },
                { "withdraw", null },
                { "fee", null },
                { "precision", precision },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", precision },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
            };
        }
        return result;
    }

    public async override Task<object> fetchTradingFee(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name kraken#fetchTradingFee
        * @description fetch the trading fees for a market
        * @param {string} symbol unified market symbol
        * @param {object} params extra parameters specific to the kraken api endpoint
        * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "pair", getValue(market, "id") },
            { "fee-info", true },
        };
        object response = await this.privatePostTradeVolume(this.extend(request, parameters));
        //
        //     {
        //        error: [],
        //        result: {
        //          currency: 'ZUSD',
        //          volume: '0.0000',
        //          fees: {
        //            XXBTZUSD: {
        //              fee: '0.2600',
        //              minfee: '0.1000',
        //              maxfee: '0.2600',
        //              nextfee: '0.2400',
        //              tiervolume: '0.0000',
        //              nextvolume: '50000.0000'
        //            }
        //          },
        //          fees_maker: {
        //            XXBTZUSD: {
        //              fee: '0.1600',
        //              minfee: '0.0000',
        //              maxfee: '0.1600',
        //              nextfee: '0.1400',
        //              tiervolume: '0.0000',
        //              nextvolume: '50000.0000'
        //            }
        //          }
        //        }
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        return this.parseTradingFee(result, market);
    }

    public virtual object parseTradingFee(object response, object market)
    {
        object makerFees = this.safeValue(response, "fees_maker", new Dictionary<string, object>() {});
        object takerFees = this.safeValue(response, "fees", new Dictionary<string, object>() {});
        object symbolMakerFee = this.safeValue(makerFees, getValue(market, "id"), new Dictionary<string, object>() {});
        object symbolTakerFee = this.safeValue(takerFees, getValue(market, "id"), new Dictionary<string, object>() {});
        return new Dictionary<string, object>() {
            { "info", response },
            { "symbol", getValue(market, "symbol") },
            { "maker", this.safeNumber(symbolMakerFee, "fee") },
            { "taker", this.safeNumber(symbolTakerFee, "fee") },
            { "percentage", true },
            { "tierBased", true },
        };
    }

    public override object parseBidAsk(object bidask, object priceKey = null, object amountKey = null)
    {
        priceKey ??= 0;
        amountKey ??= 1;
        object price = this.safeNumber(bidask, priceKey);
        object amount = this.safeNumber(bidask, amountKey);
        object timestamp = this.safeInteger(bidask, 2);
        return new List<object>() {price, amount, timestamp};
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int|undefined} limit the maximum amount of order book entries to return
        * @param {object} params extra parameters specific to the kraken api endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(getValue(market, "darkpool")))
        {
            throw new ExchangeError ((string)add(add(this.id, " fetchOrderBook() does not provide an order book for darkpool symbol "), symbol)) ;
        }
        object request = new Dictionary<string, object>() {
            { "pair", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["count"] = limit; // 100
        }
        object response = await this.publicGetDepth(this.extend(request, parameters));
        //
        //     {
        //         "error":[],
        //         "result":{
        //             "XETHXXBT":{
        //                 "asks":[
        //                     ["0.023480","4.000",1586321307],
        //                     ["0.023490","50.095",1586321306],
        //                     ["0.023500","28.535",1586321302],
        //                 ],
        //                 "bids":[
        //                     ["0.023470","59.580",1586321307],
        //                     ["0.023460","20.000",1586321301],
        //                     ["0.023440","67.832",1586321306],
        //                 ]
        //             }
        //         }
        //     }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object orderbook = this.safeValue(result, getValue(market, "id"));
        // sometimes kraken returns wsname instead of market id
        // https://github.com/ccxt/ccxt/issues/8662
        object marketInfo = this.safeValue(market, "info", new Dictionary<string, object>() {});
        object wsName = this.safeValue(marketInfo, "wsname");
        if (isTrue(!isEqual(wsName, null)))
        {
            orderbook = this.safeValue(result, wsName, orderbook);
        }
        return this.parseOrderBook(orderbook, symbol);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        //     {
        //         "a":["2432.77000","1","1.000"],
        //         "b":["2431.37000","2","2.000"],
        //         "c":["2430.58000","0.04408910"],
        //         "v":["4147.94474901","8896.96086304"],
        //         "p":["2456.22239","2568.63032"],
        //         "t":[3907,10056],
        //         "l":["2302.18000","2302.18000"],
        //         "h":["2621.14000","2860.01000"],
        //         "o":"2571.56000"
        //     }
        //
        object timestamp = this.milliseconds();
        object symbol = this.safeSymbol(null, market);
        object v = this.safeValue(ticker, "v", new List<object>() {});
        object baseVolume = this.safeString(v, 1);
        object p = this.safeValue(ticker, "p", new List<object>() {});
        object vwap = this.safeString(p, 1);
        object quoteVolume = Precise.stringMul(baseVolume, vwap);
        object c = this.safeValue(ticker, "c", new List<object>() {});
        object last = this.safeString(c, 0);
        object high = this.safeValue(ticker, "h", new List<object>() {});
        object low = this.safeValue(ticker, "l", new List<object>() {});
        object bid = this.safeValue(ticker, "b", new List<object>() {});
        object ask = this.safeValue(ticker, "a", new List<object>() {});
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(high, 1) },
            { "low", this.safeString(low, 1) },
            { "bid", this.safeString(bid, 0) },
            { "bidVolume", null },
            { "ask", this.safeString(ask, 0) },
            { "askVolume", null },
            { "vwap", vwap },
            { "open", this.safeString(ticker, "o") },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", null },
            { "average", null },
            { "baseVolume", baseVolume },
            { "quoteVolume", quoteVolume },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#fetchTickers
        * @description fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
        * @param {[string]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} params extra parameters specific to the kraken api endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbols, null)))
        {
            symbols = this.marketSymbols(symbols);
            object marketIds = new List<object>() {};
            for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
            {
                object symbol = getValue(symbols, i);
                object market = getValue(this.markets, symbol);
                if (isTrue(isTrue(getValue(market, "active")) && !isTrue(getValue(market, "darkpool"))))
                {
                    ((List<object>)marketIds).Add(getValue(market, "id"));
                }
            }
            ((Dictionary<string, object>)request)["pair"] = String.Join(",", ((List<object>)marketIds).ToArray());
        }
        object response = await this.publicGetTicker(this.extend(request, parameters));
        object tickers = getValue(response, "result");
        object ids = new List<object>(((Dictionary<string,object>)tickers).Keys);
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(ids)); postFixIncrement(ref i))
        {
            object id = getValue(ids, i);
            object market = this.safeMarket(id);
            object symbol = getValue(market, "symbol");
            object ticker = getValue(tickers, id);
            ((Dictionary<string, object>)result)[(string)symbol] = this.parseTicker(ticker, market);
        }
        return this.filterByArray(result, "symbol", symbols);
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name kraken#fetchTicker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} params extra parameters specific to the kraken api endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object darkpool = isGreaterThanOrEqual(getIndexOf(symbol, ".d"), 0);
        if (isTrue(darkpool))
        {
            throw new ExchangeError ((string)add(add(this.id, " fetchTicker() does not provide a ticker for darkpool symbol "), symbol)) ;
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "pair", getValue(market, "id") },
        };
        object response = await this.publicGetTicker(this.extend(request, parameters));
        object ticker = getValue(getValue(response, "result"), getValue(market, "id"));
        return this.parseTicker(ticker, market);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     [
        //         1591475640,
        //         "0.02500",
        //         "0.02500",
        //         "0.02500",
        //         "0.02500",
        //         "0.02500",
        //         "9.12201000",
        //         5
        //     ]
        //
        return new List<object> {this.safeTimestamp(ohlcv, 0), this.safeNumber(ohlcv, 1), this.safeNumber(ohlcv, 2), this.safeNumber(ohlcv, 3), this.safeNumber(ohlcv, 4), this.safeNumber(ohlcv, 6)};
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#fetchOHLCV
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int|undefined} since timestamp in ms of the earliest candle to fetch
        * @param {int|undefined} limit the maximum amount of candles to fetch
        * @param {object} params extra parameters specific to the kraken api endpoint
        * @returns {[[int]]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object parsedTimeframe = this.safeInteger(this.timeframes, timeframe);
        object request = new Dictionary<string, object>() {
            { "pair", getValue(market, "id") },
        };
        if (isTrue(!isEqual(parsedTimeframe, null)))
        {
            ((Dictionary<string, object>)request)["interval"] = parsedTimeframe;
        } else
        {
            ((Dictionary<string, object>)request)["interval"] = timeframe;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["since"] = this.parseToInt(divide((subtract(since, 1)), 1000));
        }
        object response = await this.publicGetOHLC(this.extend(request, parameters));
        //
        //     {
        //         "error":[],
        //         "result":{
        //             "XETHXXBT":[
        //                 [1591475580,"0.02499","0.02499","0.02499","0.02499","0.00000","0.00000000",0],
        //                 [1591475640,"0.02500","0.02500","0.02500","0.02500","0.02500","9.12201000",5],
        //                 [1591475700,"0.02499","0.02499","0.02499","0.02499","0.02499","1.28681415",2],
        //                 [1591475760,"0.02499","0.02499","0.02499","0.02499","0.02499","0.08800000",1],
        //             ],
        //             "last":1591517580
        //         }
        //     }
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object ohlcvs = this.safeValue(result, getValue(market, "id"), new List<object>() {});
        return this.parseOHLCVs(ohlcvs, market, timeframe, since, limit);
    }

    public virtual object parseLedgerEntryType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "trade", "trade" },
            { "withdrawal", "transaction" },
            { "deposit", "transaction" },
            { "transfer", "transfer" },
            { "margin", "margin" },
        };
        return this.safeString(types, type, type);
    }

    public override object parseLedgerEntry(object item, object currency = null)
    {
        //
        //     {
        //         'LTFK7F-N2CUX-PNY4SX': {
        //             refid: "TSJTGT-DT7WN-GPPQMJ",
        //             time:  1520102320.555,
        //             type: "trade",
        //             aclass: "currency",
        //             asset: "XETH",
        //             amount: "0.1087194600",
        //             fee: "0.0000000000",
        //             balance: "0.2855851000"
        //         },
        //         ...
        //     }
        //
        object id = this.safeString(item, "id");
        object direction = null;
        object account = null;
        object referenceId = this.safeString(item, "refid");
        object referenceAccount = null;
        object type = this.parseLedgerEntryType(this.safeString(item, "type"));
        object code = this.safeCurrencyCode(this.safeString(item, "asset"), currency);
        object amount = this.safeString(item, "amount");
        if (isTrue(Precise.stringLt(amount, "0")))
        {
            direction = "out";
            amount = Precise.stringAbs(amount);
        } else
        {
            direction = "in";
        }
        object time = this.safeNumber(item, "time");
        object timestamp = null;
        if (isTrue(!isEqual(time, null)))
        {
            timestamp = this.parseToInt(multiply(time, 1000));
        }
        return new Dictionary<string, object>() {
            { "info", item },
            { "id", id },
            { "direction", direction },
            { "account", account },
            { "referenceId", referenceId },
            { "referenceAccount", referenceAccount },
            { "type", type },
            { "currency", code },
            { "amount", this.parseNumber(amount) },
            { "before", null },
            { "after", this.safeNumber(item, "balance") },
            { "status", "ok" },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "fee", new Dictionary<string, object>() {
                { "cost", this.safeNumber(item, "fee") },
                { "currency", code },
            } },
        };
    }

    public async override Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#fetchLedger
        * @description fetch the history of changes, actions done by the user or operations that altered balance of the user
        * @param {string|undefined} code unified currency code, default is undefined
        * @param {int|undefined} since timestamp in ms of the earliest ledger entry, default is undefined
        * @param {int|undefined} limit max number of ledger entrys to return, default is undefined
        * @param {object} params extra parameters specific to the kraken api endpoint
        * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger-structure}
        */
        // https://www.kraken.com/features/api#get-ledgers-info
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((Dictionary<string, object>)request)["asset"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["start"] = this.parseToInt(divide(since, 1000));
        }
        object response = await this.privatePostLedgers(this.extend(request, parameters));
        // {  error: [],
        //   result: { ledger: { 'LPUAIB-TS774-UKHP7X': {   refid: "A2B4HBV-L4MDIE-JU4N3N",
        //                                                   time:  1520103488.314,
        //                                                   type: "withdrawal",
        //                                                 aclass: "currency",
        //                                                  asset: "XETH",
        //                                                 amount: "-0.2805800000",
        //                                                    fee: "0.0050000000",
        //                                                balance: "0.0000051000"           },
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object ledger = this.safeValue(result, "ledger", new Dictionary<string, object>() {});
        object keys = new List<object>(((Dictionary<string,object>)ledger).Keys);
        object items = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object key = getValue(keys, i);
            object value = getValue(ledger, key);
            ((Dictionary<string, object>)value)["id"] = key;
            ((List<object>)items).Add(value);
        }
        return this.parseLedger(items, currency, since, limit);
    }

    public async virtual Task<object> fetchLedgerEntriesByIds(object ids, object code = null, object parameters = null)
    {
        // https://www.kraken.com/features/api#query-ledgers
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        ids = String.Join(",", ((List<object>)ids).ToArray());
        object request = this.extend(new Dictionary<string, object>() {
            { "id", ids },
        }, parameters);
        object response = await this.privatePostQueryLedgers(request);
        // {  error: [],
        //   result: { 'LPUAIB-TS774-UKHP7X': {   refid: "A2B4HBV-L4MDIE-JU4N3N",
        //                                         time:  1520103488.314,
        //                                         type: "withdrawal",
        //                                       aclass: "currency",
        //                                        asset: "XETH",
        //                                       amount: "-0.2805800000",
        //                                          fee: "0.0050000000",
        //                                      balance: "0.0000051000"           } } }
        object result = getValue(response, "result");
        object keys = new List<object>(((Dictionary<string,object>)result).Keys);
        object items = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object key = getValue(keys, i);
            object value = getValue(result, key);
            ((Dictionary<string, object>)value)["id"] = key;
            ((List<object>)items).Add(value);
        }
        return this.parseLedger(items);
    }

    public async override Task<object> fetchLedgerEntry(object id, object code = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object items = await this.fetchLedgerEntriesByIds(new List<object>() {id}, code, parameters);
        return getValue(items, 0);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // fetchTrades (public)
        //
        //     [
        //         "0.032310", // price
        //         "4.28169434", // amount
        //         1541390792.763, // timestamp
        //         "s", // sell or buy
        //         "l", // limit or market
        //         ""
        //     ]
        //
        // fetchOrderTrades (private)
        //
        //     {
        //         id: 'TIMIRG-WUNNE-RRJ6GT', // injected from outside
        //         ordertxid: 'OQRPN2-LRHFY-HIFA7D',
        //         postxid: 'TKH2SE-M7IF5-CFI7LT',
        //         pair: 'USDCUSDT',
        //         time: 1586340086.457,
        //         type: 'sell',
        //         ordertype: 'market',
        //         price: '0.99860000',
        //         cost: '22.16892001',
        //         fee: '0.04433784',
        //         vol: '22.20000000',
        //         margin: '0.00000000',
        //         misc: ''
        //     }
        //
        object timestamp = null;
        object side = null;
        object type = null;
        object price = null;
        object amount = null;
        object id = null;
        object orderId = null;
        object fee = null;
        object symbol = null;
        if (isTrue((trade.GetType().IsGenericType && trade.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))
        {
            timestamp = this.safeTimestamp(trade, 2);
            side = ((bool) isTrue((isEqual(getValue(trade, 3), "s")))) ? "sell" : "buy";
            type = ((bool) isTrue((isEqual(getValue(trade, 4), "l")))) ? "limit" : "market";
            price = this.safeString(trade, 0);
            amount = this.safeString(trade, 1);
            object tradeLength = getArrayLength(trade);
            if (isTrue(isGreaterThan(tradeLength, 6)))
            {
                id = this.safeString(trade, 6); // artificially added as per #1794
            }
        } else if (isTrue(((trade).GetType() == typeof(string))))
        {
            id = trade;
        } else if (isTrue(((Dictionary<string,object>)trade).ContainsKey(toStringOrNull("ordertxid"))))
        {
            object marketId = this.safeString(trade, "pair");
            object foundMarket = this.findMarketByAltnameOrId(marketId);
            if (isTrue(!isEqual(foundMarket, null)))
            {
                market = foundMarket;
            } else if (isTrue(!isEqual(marketId, null)))
            {
                // delisted market ids go here
                market = this.getDelistedMarketById(marketId);
            }
            orderId = this.safeString(trade, "ordertxid");
            id = this.safeString2(trade, "id", "postxid");
            timestamp = this.safeTimestamp(trade, "time");
            side = this.safeString(trade, "type");
            type = this.safeString(trade, "ordertype");
            price = this.safeString(trade, "price");
            amount = this.safeString(trade, "vol");
            if (isTrue(((Dictionary<string,object>)trade).ContainsKey(toStringOrNull("fee"))))
            {
                object currency = null;
                if (isTrue(!isEqual(market, null)))
                {
                    currency = getValue(market, "quote");
                }
                fee = new Dictionary<string, object>() {
                    { "cost", this.safeString(trade, "fee") },
                    { "currency", currency },
                };
            }
        }
        if (isTrue(!isEqual(market, null)))
        {
            symbol = getValue(market, "symbol");
        }
        object cost = this.safeString(trade, "cost");
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", id },
            { "order", orderId },
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "type", type },
            { "side", side },
            { "takerOrMaker", null },
            { "price", price },
            { "amount", amount },
            { "cost", cost },
            { "fee", fee },
        }, market);
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int|undefined} since timestamp in ms of the earliest trade to fetch
        * @param {int|undefined} limit the maximum amount of trades to fetch
        * @param {object} params extra parameters specific to the kraken api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/en/latest/manual.html?#public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object id = getValue(market, "id");
        object request = new Dictionary<string, object>() {
            { "pair", id },
        };
        // https://support.kraken.com/hc/en-us/articles/218198197-How-to-pull-all-trade-data-using-the-Kraken-REST-API
        // https://github.com/ccxt/ccxt/issues/5677
        if (isTrue(!isEqual(since, null)))
        {
            // php does not format it properly
            // therefore we use string concatenation here
            ((Dictionary<string, object>)request)["since"] = multiply(since, 1000000);
            ((Dictionary<string, object>)request)["since"] = add(((object)since).ToString(), "000000"); // expected to be in nanoseconds
        }
        // https://github.com/ccxt/ccxt/issues/5698
        if (isTrue(isTrue(!isEqual(limit, null)) && isTrue(!isEqual(limit, 1000))))
        {
            object fetchTradesWarning = this.safeValue(this.options, "fetchTradesWarning", true);
            if (isTrue(fetchTradesWarning))
            {
                throw new ExchangeError ((string)add(add(add(this.id, " fetchTrades() cannot serve "), ((object)limit).ToString()), " trades without breaking the pagination, see https://github.com/ccxt/ccxt/issues/5698 for more details. Set exchange.options[\'fetchTradesWarning\'] to acknowledge this warning and silence it.")) ;
            }
        }
        object response = await this.publicGetTrades(this.extend(request, parameters));
        //
        //     {
        //         "error": [],
        //         "result": {
        //             "XETHXXBT": [
        //                 ["0.032310","4.28169434",1541390792.763,"s","l",""]
        //             ],
        //             "last": "1541439421200678657"
        //         }
        //     }
        //
        object result = getValue(response, "result");
        object trades = getValue(result, id);
        // trades is a sorted array: last (most recent trade) goes last
        object length = getArrayLength(trades);
        if (isTrue(isLessThanOrEqual(length, 0)))
        {
            return new List<object>() {};
        }
        object lastTrade = getValue(trades, subtract(length, 1));
        object lastTradeId = this.safeString(result, "last");
        ((List<object>)lastTrade).Add(lastTradeId);
        return this.parseTrades(trades, market, since, limit);
    }

    public virtual object parseBalance(object response)
    {
        object balances = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object result = new Dictionary<string, object>() {
            { "info", response },
            { "timestamp", null },
            { "datetime", null },
        };
        object currencyIds = new List<object>(((Dictionary<string,object>)balances).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(currencyIds)); postFixIncrement(ref i))
        {
            object currencyId = getValue(currencyIds, i);
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            ((Dictionary<string, object>)account)["total"] = this.safeString(balances, currencyId);
            ((Dictionary<string, object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name kraken#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @param {object} params extra parameters specific to the kraken api endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/en/latest/manual.html?#balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privatePostBalance(parameters);
        //
        //     {
        //         "error":[],
        //         "result":{
        //             "ZUSD":"58.8649",
        //             "KFEE":"4399.43",
        //             "XXBT":"0.0000034506",
        //         }
        //     }
        //
        return this.parseBalance(response);
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#createOrder
        * @description create a trade order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float|undefined} price the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} params extra parameters specific to the kraken api endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "pair", getValue(market, "id") },
            { "type", side },
            { "ordertype", type },
            { "volume", this.amountToPrecision(symbol, amount) },
        };
        object orderRequest = this.orderRequest("createOrder()", symbol, type, request, price, parameters);
        object response = await this.privatePostAddOrder(this.extend(getValue(orderRequest, 0), getValue(orderRequest, 1)));
        //
        //     {
        //         error: [],
        //         result: {
        //             descr: { order: 'buy 0.02100000 ETHUSDT @ limit 330.00' },
        //             txid: [ 'OEKVV2-IH52O-TPL6GZ' ]
        //         }
        //     }
        //
        object result = this.safeValue(response, "result");
        return this.parseOrder(result);
    }

    public virtual object findMarketByAltnameOrId(object id)
    {
        object marketsByAltname = this.safeValue(this.options, "marketsByAltname", new Dictionary<string, object>() {});
        if (isTrue(((Dictionary<string,object>)marketsByAltname).ContainsKey(toStringOrNull(id))))
        {
            return getValue(marketsByAltname, id);
        } else
        {
            return this.safeMarket(id);
        }
    }

    public virtual object getDelistedMarketById(object id)
    {
        if (isTrue(isEqual(id, null)))
        {
            return id;
        }
        object market = this.safeValue(getValue(this.options, "delistedMarketsById"), id);
        if (isTrue(!isEqual(market, null)))
        {
            return market;
        }
        object baseIdStart = 0;
        object baseIdEnd = 3;
        object quoteIdStart = 3;
        object quoteIdEnd = 6;
        if (isTrue(isEqual(getArrayLength(id), 8)))
        {
            baseIdEnd = 4;
            quoteIdStart = 4;
            quoteIdEnd = 8;
        } else if (isTrue(isEqual(getArrayLength(id), 7)))
        {
            baseIdEnd = 4;
            quoteIdStart = 4;
            quoteIdEnd = 7;
        }
        object baseId = ((string)id).Substring((int)baseIdStart, (int)baseIdEnd);
        object quoteId = ((string)id).Substring((int)quoteIdStart, (int)quoteIdEnd);
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object symbol = add(add(bs, "/"), quote);
        market = new Dictionary<string, object>() {
            { "symbol", symbol },
            { "base", bs },
            { "quote", quote },
            { "baseId", baseId },
            { "quoteId", quoteId },
        };
        ((Dictionary<string, object>)getValue(this.options, "delistedMarketsById"))[(string)id] = market;
        return market;
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "pending", "open" },
            { "open", "open" },
            { "closed", "closed" },
            { "canceled", "canceled" },
            { "expired", "expired" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // createOrder for regular orders
        //
        //     {
        //         descr: { order: 'buy 0.02100000 ETHUSDT @ limit 330.00' },
        //         txid: [ 'OEKVV2-IH52O-TPL6GZ' ]
        //     }
        //     {
        //         "txid": [ "TX_ID_HERE" ],
        //         "descr": { "order":"buy 0.12345678 ETHEUR @ market" },
        //     }
        //
        //
        // createOrder for stop orders
        //
        //     {
        //         "txid":["OSILNC-VQI5Q-775ZDQ"],
        //         "descr":{"order":"sell 167.28002676 ADAXBT @ stop loss 0.00003280 -> limit 0.00003212"}
        //     }
        //
        //
        //     {
        //         "txid":["OVHMJV-BZW2V-6NZFWF"],
        //         "descr":{"order":"sell 0.00100000 ETHUSD @ stop loss 2677.00 -> limit 2577.00 with 5:1 leverage"}
        //     }
        //
        // editOrder
        //
        //     {
        //         "status": "ok",
        //         "txid": "OAW2BO-7RWEK-PZY5UO",
        //         "originaltxid": "OXL6SS-UPNMC-26WBE7",
        //         "volume": "0.00075000",
        //         "price": "13500.0",
        //         "orders_cancelled": 1,
        //         "descr": {
        //             "order": "buy 0.00075000 XBTUSDT @ limit 13500.0"
        //         }
        //     }
        //
        object description = this.safeValue(order, "descr", new Dictionary<string, object>() {});
        object orderDescription = this.safeString(description, "order");
        object side = null;
        object type = null;
        object marketId = null;
        object price = null;
        object amount = null;
        object stopPrice = null;
        if (isTrue(!isEqual(orderDescription, null)))
        {
            object parts = ((string)orderDescription).Split((string)" ").ToList<object>();
            side = this.safeString(parts, 0);
            amount = this.safeString(parts, 1);
            marketId = this.safeString(parts, 2);
            type = this.safeString(parts, 4);
            if (isTrue(isEqual(type, "stop")))
            {
                stopPrice = this.safeString(parts, 6);
                price = this.safeString(parts, 9);
            } else if (isTrue(isEqual(type, "limit")))
            {
                price = this.safeString(parts, 5);
            }
        }
        side = this.safeString(description, "type", side);
        type = this.safeString(description, "ordertype", type);
        marketId = this.safeString(description, "pair", marketId);
        object foundMarket = this.findMarketByAltnameOrId(marketId);
        object symbol = null;
        if (isTrue(!isEqual(foundMarket, null)))
        {
            market = foundMarket;
        } else if (isTrue(!isEqual(marketId, null)))
        {
            // delisted market ids go here
            market = this.getDelistedMarketById(marketId);
        }
        object timestamp = this.safeTimestamp(order, "opentm");
        amount = this.safeString(order, "vol", amount);
        object filled = this.safeString(order, "vol_exec");
        object fee = null;
        // kraken truncates the cost in the api response so we will ignore it and calculate it from average & filled
        // const cost = this.safeString (order, 'cost');
        price = this.safeString(description, "price", price);
        if (isTrue(isTrue((isEqual(price, null))) || isTrue(Precise.stringEquals(price, "0"))))
        {
            price = this.safeString(description, "price2");
        }
        if (isTrue(isTrue((isEqual(price, null))) || isTrue(Precise.stringEquals(price, "0"))))
        {
            price = this.safeString(order, "price", price);
        }
        object average = this.safeNumber(order, "price");
        if (isTrue(!isEqual(market, null)))
        {
            symbol = getValue(market, "symbol");
            if (isTrue(((Dictionary<string,object>)order).ContainsKey(toStringOrNull("fee"))))
            {
                object flags = getValue(order, "oflags");
                object feeCost = this.safeString(order, "fee");
                fee = new Dictionary<string, object>() {
                    { "cost", feeCost },
                    { "rate", null },
                };
                if (isTrue(isGreaterThanOrEqual(getIndexOf(flags, "fciq"), 0)))
                {
                    ((Dictionary<string, object>)fee)["currency"] = getValue(market, "quote");
                } else if (isTrue(isGreaterThanOrEqual(getIndexOf(flags, "fcib"), 0)))
                {
                    ((Dictionary<string, object>)fee)["currency"] = getValue(market, "base");
                }
            }
        }
        object status = this.parseOrderStatus(this.safeString(order, "status"));
        object id = this.safeString2(order, "id", "txid");
        if (isTrue(isTrue((isEqual(id, null))) || isTrue((isEqual(((string)id).Substring((int)0, (int)1), "[")))))
        {
            object txid = this.safeValue(order, "txid");
            id = this.safeString(txid, 0);
        }
        object clientOrderId = this.safeString(order, "userref");
        object rawTrades = this.safeValue(order, "trades");
        stopPrice = this.safeNumber(order, "stopprice", stopPrice);
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", id },
            { "clientOrderId", clientOrderId },
            { "info", order },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "status", status },
            { "symbol", symbol },
            { "type", type },
            { "timeInForce", null },
            { "postOnly", null },
            { "side", side },
            { "price", price },
            { "stopPrice", stopPrice },
            { "triggerPrice", stopPrice },
            { "cost", null },
            { "amount", amount },
            { "filled", filled },
            { "average", average },
            { "remaining", null },
            { "fee", fee },
            { "trades", rawTrades },
        }, market);
    }

    public virtual object orderRequest(object method, object symbol, object type, object request, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object clientOrderId = this.safeString2(parameters, "userref", "clientOrderId");
        parameters = this.omit(parameters, new List<object>() {"userref", "clientOrderId"});
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((Dictionary<string, object>)request)["userref"] = clientOrderId;
        }
        //
        //     market
        //     limit (price = limit price)
        //     stop-loss (price = stop loss price)
        //     take-profit (price = take profit price)
        //     stop-loss-limit (price = stop loss trigger price, price2 = triggered limit price)
        //     take-profit-limit (price = take profit trigger price, price2 = triggered limit price)
        //     settle-position
        //
        if (isTrue(isEqual(type, "limit")))
        {
            ((Dictionary<string, object>)request)["price"] = this.priceToPrecision(symbol, price);
        } else if (isTrue(isTrue((isEqual(type, "stop-loss"))) || isTrue((isEqual(type, "take-profit")))))
        {
            object stopPrice = this.safeNumber2(parameters, "price", "stopPrice", price);
            if (isTrue(isEqual(stopPrice, null)))
            {
                throw new ArgumentsRequired ((string)add(add(add(add(this.id, method), " requires a price argument or a price/stopPrice parameter for a "), type), " order")) ;
            } else
            {
                ((Dictionary<string, object>)request)["price"] = this.priceToPrecision(symbol, stopPrice);
            }
        } else if (isTrue(isTrue((isEqual(type, "stop-loss-limit"))) || isTrue((isEqual(type, "take-profit-limit")))))
        {
            object stopPrice = this.safeNumber2(parameters, "price", "stopPrice");
            object limitPrice = this.safeNumber(parameters, "price2");
            object stopPriceDefined = (!isEqual(stopPrice, null));
            object limitPriceDefined = (!isEqual(limitPrice, null));
            if (isTrue(isTrue(stopPriceDefined) && isTrue(limitPriceDefined)))
            {
                ((Dictionary<string, object>)request)["price"] = this.priceToPrecision(symbol, stopPrice);
                ((Dictionary<string, object>)request)["price2"] = this.priceToPrecision(symbol, limitPrice);
            } else if (isTrue(isTrue((isEqual(price, null))) || isTrue((!isTrue((isTrue(stopPriceDefined) || isTrue(limitPriceDefined)))))))
            {
                throw new ArgumentsRequired ((string)add(add(add(add(this.id, method), " requires a price argument and/or price/stopPrice/price2 parameters for a "), type), " order")) ;
            } else
            {
                if (isTrue(stopPriceDefined))
                {
                    ((Dictionary<string, object>)request)["price"] = this.priceToPrecision(symbol, stopPrice);
                    ((Dictionary<string, object>)request)["price2"] = this.priceToPrecision(symbol, price);
                } else if (isTrue(limitPriceDefined))
                {
                    ((Dictionary<string, object>)request)["price"] = this.priceToPrecision(symbol, price);
                    ((Dictionary<string, object>)request)["price2"] = this.priceToPrecision(symbol, limitPrice);
                }
            }
        }
        object close = this.safeValue(parameters, "close");
        if (isTrue(!isEqual(close, null)))
        {
            close = this.extend(new Dictionary<string, object>() {}, close);
            object closePrice = this.safeValue(close, "price");
            if (isTrue(!isEqual(closePrice, null)))
            {
                ((Dictionary<string, object>)close)["price"] = this.priceToPrecision(symbol, closePrice);
            }
            object closePrice2 = this.safeValue(close, "price2"); // stopPrice
            if (isTrue(!isEqual(closePrice2, null)))
            {
                ((Dictionary<string, object>)close)["price2"] = this.priceToPrecision(symbol, closePrice2);
            }
            ((Dictionary<string, object>)request)["close"] = close;
        }
        parameters = this.omit(parameters, new List<object>() {"price", "stopPrice", "price2", "close"});
        return new List<object>() {request, parameters};
    }

    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#editOrder
        * @description edit a trade order
        * @see https://docs.kraken.com/rest/#tag/User-Trading/operation/editOrder
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of the currency you want to trade in units of the base currency
        * @param {float|undefined} price the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} params extra parameters specific to the kraken api endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(add(add(this.id, " editOrder() does not support "), getValue(market, "type")), " orders, only spot orders are accepted")) ;
        }
        object request = new Dictionary<string, object>() {
            { "txid", id },
            { "pair", getValue(market, "id") },
        };
        if (isTrue(!isEqual(amount, null)))
        {
            ((Dictionary<string, object>)request)["volume"] = this.amountToPrecision(symbol, amount);
        }
        object orderRequest = this.orderRequest("editOrder()", symbol, type, request, price, parameters);
        object response = await this.privatePostEditOrder(this.extend(getValue(orderRequest, 0), getValue(orderRequest, 1)));
        //
        //     {
        //         "error": [],
        //         "result": {
        //             "status": "ok",
        //             "txid": "OAW2BO-7RWEK-PZY5UO",
        //             "originaltxid": "OXL6SS-UPNMC-26WBE7",
        //             "volume": "0.00075000",
        //             "price": "13500.0",
        //             "orders_cancelled": 1,
        //             "descr": {
        //                 "order": "buy 0.00075000 XBTUSDT @ limit 13500.0"
        //             }
        //         }
        //     }
        //
        object data = this.safeValue(response, "result", new Dictionary<string, object>() {});
        return this.parseOrder(data, market);
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#fetchOrder
        * @description fetches information on an order made by the user
        * @param {string|undefined} symbol not used by kraken fetchOrder
        * @param {object} params extra parameters specific to the kraken api endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object clientOrderId = this.safeValue2(parameters, "userref", "clientOrderId");
        object request = new Dictionary<string, object>() {
            { "trades", true },
        };
        object query = parameters;
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((Dictionary<string, object>)request)["userref"] = clientOrderId;
            query = this.omit(parameters, new List<object>() {"userref", "clientOrderId"});
        } else
        {
            ((Dictionary<string, object>)request)["txid"] = id;
        }
        object response = await this.privatePostQueryOrders(this.extend(request, query));
        //
        //     {
        //         "error":[],
        //         "result":{
        //             "OTLAS3-RRHUF-NDWH5A":{
        //                 "refid":null,
        //                 "userref":null,
        //                 "status":"closed",
        //                 "reason":null,
        //                 "opentm":1586822919.3342,
        //                 "closetm":1586822919.365,
        //                 "starttm":0,
        //                 "expiretm":0,
        //                 "descr":{
        //                     "pair":"XBTUSDT",
        //                     "type":"sell",
        //                     "ordertype":"market",
        //                     "price":"0",
        //                     "price2":"0",
        //                     "leverage":"none",
        //                     "order":"sell 0.21804000 XBTUSDT @ market",
        //                     "close":""
        //                 },
        //                 "vol":"0.21804000",
        //                 "vol_exec":"0.21804000",
        //                 "cost":"1493.9",
        //                 "fee":"3.8",
        //                 "price":"6851.5",
        //                 "stopprice":"0.00000",
        //                 "limitprice":"0.00000",
        //                 "misc":"",
        //                 "oflags":"fciq",
        //                 "trades":["TT5UC3-GOIRW-6AZZ6R"]
        //             }
        //         }
        //     }
        //
        object result = this.safeValue(response, "result", new List<object>() {});
        if (!isTrue((((Dictionary<string,object>)result).ContainsKey(toStringOrNull(id)))))
        {
            throw new OrderNotFound ((string)add(add(this.id, " fetchOrder() could not find order id "), id)) ;
        }
        object order = this.parseOrder(this.extend(new Dictionary<string, object>() {
            { "id", id },
        }, getValue(result, id)));
        return this.extend(new Dictionary<string, object>() {
            { "info", response },
        }, order);
    }

    public async override Task<object> fetchOrderTrades(object id, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#fetchOrderTrades
        * @description fetch all the trades made from a single order
        * @param {string} id order id
        * @param {string|undefined} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch trades for
        * @param {int|undefined} limit the maximum number of trades to retrieve
        * @param {object} params extra parameters specific to the kraken api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object orderTrades = this.safeValue(parameters, "trades");
        object tradeIds = new List<object>() {};
        if (isTrue(isEqual(orderTrades, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOrderTrades() requires a unified order structure in the params argument or a \'trades\' param (an array of trade id strings)")) ;
        } else
        {
            for (object i = 0; isLessThan(i, getArrayLength(orderTrades)); postFixIncrement(ref i))
            {
                object orderTrade = getValue(orderTrades, i);
                if (isTrue(((orderTrade).GetType() == typeof(string))))
                {
                    ((List<object>)tradeIds).Add(orderTrade);
                } else
                {
                    ((List<object>)tradeIds).Add(getValue(orderTrade, "id"));
                }
            }
        }
        await this.loadMarkets();
        if (isTrue(!isEqual(symbol, null)))
        {
            symbol = this.symbol(symbol);
        }
        object options = this.safeValue(this.options, "fetchOrderTrades", new Dictionary<string, object>() {});
        object batchSize = this.safeInteger(options, "batchSize", 20);
        object numTradeIds = getArrayLength(tradeIds);
        object numBatches = this.parseToInt(divide(numTradeIds, batchSize));
        numBatches = this.sum(numBatches, 1);
        object result = new List<object>() {};
        for (object j = 0; isLessThan(j, numBatches); postFixIncrement(ref j))
        {
            object requestIds = new List<object>() {};
            for (object k = 0; isLessThan(k, batchSize); postFixIncrement(ref k))
            {
                object index = this.sum(multiply(j, batchSize), k);
                if (isTrue(isLessThan(index, numTradeIds)))
                {
                    ((List<object>)requestIds).Add(getValue(tradeIds, index));
                }
            }
            object request = new Dictionary<string, object>() {
                { "txid", String.Join(",", ((List<object>)requestIds).ToArray()) },
            };
            object response = await this.privatePostQueryTrades(request);
            //
            //     {
            //         error: [],
            //         result: {
            //             'TIMIRG-WUNNE-RRJ6GT': {
            //                 ordertxid: 'OQRPN2-LRHFY-HIFA7D',
            //                 postxid: 'TKH2SE-M7IF5-CFI7LT',
            //                 pair: 'USDCUSDT',
            //                 time: 1586340086.457,
            //                 type: 'sell',
            //                 ordertype: 'market',
            //                 price: '0.99860000',
            //                 cost: '22.16892001',
            //                 fee: '0.04433784',
            //                 vol: '22.20000000',
            //                 margin: '0.00000000',
            //                 misc: ''
            //             }
            //         }
            //     }
            //
            object rawTrades = this.safeValue(response, "result");
            object ids = new List<object>(((Dictionary<string,object>)rawTrades).Keys);
            for (object i = 0; isLessThan(i, getArrayLength(ids)); postFixIncrement(ref i))
            {
                ((Dictionary<string, object>)getValue(rawTrades, getValue(ids, i)))["id"] = getValue(ids, i);
            }
            object trades = this.parseTrades(rawTrades, null, since, limit);
            object tradesFilteredBySymbol = this.filterBySymbol(trades, symbol);
            result = this.arrayConcat(result, tradesFilteredBySymbol);
        }
        return result;
    }

    public async virtual Task<object> fetchOrdersByIds(object ids, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privatePostQueryOrders(this.extend(new Dictionary<string, object>() {
            { "trades", true },
            { "txid", String.Join(",", ((List<object>)ids).ToArray()) },
        }, parameters));
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object orders = new List<object>() {};
        object orderIds = new List<object>(((Dictionary<string,object>)result).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(orderIds)); postFixIncrement(ref i))
        {
            object id = getValue(orderIds, i);
            object item = getValue(result, id);
            object order = this.parseOrder(this.extend(new Dictionary<string, object>() {
                { "id", id },
            }, item));
            ((List<object>)orders).Add(order);
        }
        return orders;
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#fetchMyTrades
        * @description fetch all trades made by the user
        * @param {string|undefined} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch trades for
        * @param {int|undefined} limit the maximum number of trades structures to retrieve
        * @param {object} params extra parameters specific to the kraken api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["start"] = this.parseToInt(divide(since, 1000));
        }
        object response = await this.privatePostTradesHistory(this.extend(request, parameters));
        //
        //     {
        //         "error": [],
        //         "result": {
        //             "trades": {
        //                 "GJ3NYQ-XJRTF-THZABF": {
        //                     "ordertxid": "TKH2SE-ZIF5E-CFI7LT",
        //                     "postxid": "OEN3VX-M7IF5-JNBJAM",
        //                     "pair": "XICNXETH",
        //                     "time": 1527213229.4491,
        //                     "type": "sell",
        //                     "ordertype": "limit",
        //                     "price": "0.001612",
        //                     "cost": "0.025792",
        //                     "fee": "0.000026",
        //                     "vol": "16.00000000",
        //                     "margin": "0.000000",
        //                     "misc": ""
        //                 },
        //                 ...
        //             },
        //             "count": 9760,
        //         },
        //     }
        //
        object trades = getValue(getValue(response, "result"), "trades");
        object ids = new List<object>(((Dictionary<string,object>)trades).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(ids)); postFixIncrement(ref i))
        {
            ((Dictionary<string, object>)getValue(trades, getValue(ids, i)))["id"] = getValue(ids, i);
        }
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        return this.parseTrades(trades, market, since, limit);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#cancelOrder
        * @description cancels an open order
        * @param {string} id order id
        * @param {string|undefined} symbol unified symbol of the market the order was made in
        * @param {object} params extra parameters specific to the kraken api endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = null;
        object clientOrderId = this.safeValue2(parameters, "userref", "clientOrderId", id);
        object request = new Dictionary<string, object>() {
            { "txid", clientOrderId },
        };
        parameters = this.omit(parameters, new List<object>() {"userref", "clientOrderId"});
        try
        {
            response = await this.privatePostCancelOrder(this.extend(request, parameters));
        } catch(Exception e)
        {
            if (isTrue(this.last_http_response))
            {
                if (isTrue(isGreaterThanOrEqual(getIndexOf(this.last_http_response, "EOrder:Unknown order"), 0)))
                {
                    throw new OrderNotFound ((string)add(add(this.id, " cancelOrder() error "), this.last_http_response)) ;
                }
            }
            throw e;
        }
        return response;
    }

    public async virtual Task<object> cancelOrders(object ids, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#cancelOrders
        * @description cancel multiple orders
        * @param {[string]} ids open orders transaction ID (txid) or user reference (userref)
        * @param {string} symbol unified market symbol
        * @param {object} params extra parameters specific to the kraken api endpoint
        * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "orders", ids },
        };
        object response = await this.privatePostCancelOrderBatch(this.extend(request, parameters));
        //
        //     {
        //         "error": [],
        //         "result": {
        //           "count": 2
        //         }
        //     }
        //
        return response;
    }

    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#cancelAllOrders
        * @description cancel all open orders
        * @param {string|undefined} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
        * @param {object} params extra parameters specific to the kraken api endpoint
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        return await this.privatePostCancelAll(parameters);
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#fetchOpenOrders
        * @description fetch all unfilled currently open orders
        * @param {string|undefined} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch open orders for
        * @param {int|undefined} limit the maximum number of  open orders structures to retrieve
        * @param {object} params extra parameters specific to the kraken api endpoint
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["start"] = this.parseToInt(divide(since, 1000));
        }
        object query = parameters;
        object clientOrderId = this.safeValue2(parameters, "userref", "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((Dictionary<string, object>)request)["userref"] = clientOrderId;
            query = this.omit(parameters, new List<object>() {"userref", "clientOrderId"});
        }
        object response = await this.privatePostOpenOrders(this.extend(request, query));
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object orders = this.safeValue(result, "open", new List<object>() {});
        return this.parseOrders(orders, market, since, limit);
    }

    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#fetchClosedOrders
        * @description fetches information on multiple closed orders made by the user
        * @param {string|undefined} symbol unified market symbol of the market orders were made in
        * @param {int|undefined} since the earliest time in ms to fetch orders for
        * @param {int|undefined} limit the maximum number of  orde structures to retrieve
        * @param {object} params extra parameters specific to the kraken api endpoint
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["start"] = this.parseToInt(divide(since, 1000));
        }
        object query = parameters;
        object clientOrderId = this.safeValue2(parameters, "userref", "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((Dictionary<string, object>)request)["userref"] = clientOrderId;
            query = this.omit(parameters, new List<object>() {"userref", "clientOrderId"});
        }
        object response = await this.privatePostClosedOrders(this.extend(request, query));
        //
        //     {
        //         "error":[],
        //         "result":{
        //             "closed":{
        //                 "OETZYO-UL524-QJMXCT":{
        //                     "refid":null,
        //                     "userref":null,
        //                     "status":"canceled",
        //                     "reason":"User requested",
        //                     "opentm":1601489313.3898,
        //                     "closetm":1601489346.5507,
        //                     "starttm":0,
        //                     "expiretm":0,
        //                     "descr":{
        //                         "pair":"ETHUSDT",
        //                         "type":"buy",
        //                         "ordertype":"limit",
        //                         "price":"330.00",
        //                         "price2":"0",
        //                         "leverage":"none",
        //                         "order":"buy 0.02100000 ETHUSDT @ limit 330.00",
        //                         "close":""
        //                     },
        //                     "vol":"0.02100000",
        //                     "vol_exec":"0.00000000",
        //                     "cost":"0.00000",
        //                     "fee":"0.00000",
        //                     "price":"0.00000",
        //                     "stopprice":"0.00000",
        //                     "limitprice":"0.00000",
        //                     "misc":"",
        //                     "oflags":"fciq"
        //                 },
        //             },
        //             "count":16
        //         }
        //     }
        //
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        object orders = this.safeValue(result, "closed", new List<object>() {});
        return this.parseOrders(orders, market, since, limit);
    }

    public virtual object parseTransactionStatus(object status)
    {
        // IFEX transaction states
        object statuses = new Dictionary<string, object>() {
            { "Initial", "pending" },
            { "Pending", "pending" },
            { "Success", "ok" },
            { "Settled", "pending" },
            { "Failure", "failed" },
            { "Partial", "ok" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // fetchDeposits
        //
        //     {
        //         method: "Ether (Hex)",
        //         aclass: "currency",
        //         asset: "XETH",
        //         refid: "Q2CANKL-LBFVEE-U4Y2WQ",
        //         txid: "0x57fd704dab1a73c20e24c8696099b695d596924b401b261513cfdab23",
        //         info: "0x615f9ba7a9575b0ab4d571b2b36b1b324bd83290",
        //         amount: "7.9999257900",
        //         fee: "0.0000000000",
        //         time:  1529223212,
        //         status: "Success"
        //     }
        //
        // there can be an additional 'status-prop' field present
        // deposit pending review by exchange => 'on-hold'
        // the deposit is initiated by the exchange => 'return'
        //
        //      {
        //          type: 'deposit',
        //          method: 'Fidor Bank AG (Wire Transfer)',
        //          aclass: 'currency',
        //          asset: 'ZEUR',
        //          refid: 'xxx-xxx-xxx',
        //          txid: '12341234',
        //          info: 'BANKCODEXXX',
        //          amount: '38769.08',
        //          fee: '0.0000',
        //          time: 1644306552,
        //          status: 'Success',
        //          status-prop: 'on-hold'
        //      }
        //
        //
        // fetchWithdrawals
        //
        //     {
        //         method: "Ether",
        //         aclass: "currency",
        //         asset: "XETH",
        //         refid: "A2BF34S-O7LBNQ-UE4Y4O",
        //         txid: "0x288b83c6b0904d8400ef44e1c9e2187b5c8f7ea3d838222d53f701a15b5c274d",
        //         info: "0x7cb275a5e07ba943fee972e165d80daa67cb2dd0",
        //         amount: "9.9950000000",
        //         fee: "0.0050000000",
        //         time:  1530481750,
        //         status: "Success"
        //         status-prop: 'on-hold' // this field might not be present in some cases
        //     }
        //
        // withdraw
        //
        //     {
        //         "refid": "AGBSO6T-UFMTTQ-I7KGS6"
        //     }
        //
        object id = this.safeString(transaction, "refid");
        object txid = this.safeString(transaction, "txid");
        object timestamp = this.safeTimestamp(transaction, "time");
        object currencyId = this.safeString(transaction, "asset");
        object code = this.safeCurrencyCode(currencyId, currency);
        object address = this.safeString(transaction, "info");
        object amount = this.safeNumber(transaction, "amount");
        object status = this.parseTransactionStatus(this.safeString(transaction, "status"));
        object statusProp = this.safeString(transaction, "status-prop");
        object isOnHoldDeposit = isEqual(statusProp, "on-hold");
        object isCancellationRequest = isEqual(statusProp, "cancel-pending");
        object isOnHoldWithdrawal = isEqual(statusProp, "onhold");
        if (isTrue(isTrue(isTrue(isOnHoldDeposit) || isTrue(isCancellationRequest)) || isTrue(isOnHoldWithdrawal)))
        {
            status = "pending";
        }
        object type = this.safeString(transaction, "type"); // injected from the outside
        object feeCost = this.safeNumber(transaction, "fee");
        if (isTrue(isEqual(feeCost, null)))
        {
            if (isTrue(isEqual(type, "deposit")))
            {
                feeCost = 0;
            }
        }
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", id },
            { "currency", code },
            { "amount", amount },
            { "network", null },
            { "address", address },
            { "addressTo", null },
            { "addressFrom", null },
            { "tag", null },
            { "tagTo", null },
            { "tagFrom", null },
            { "status", status },
            { "type", type },
            { "updated", null },
            { "txid", txid },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "fee", new Dictionary<string, object>() {
                { "currency", code },
                { "cost", feeCost },
            } },
        };
    }

    public virtual object parseTransactionsByType(object type, object transactions, object code = null, object since = null, object limit = null)
    {
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(transactions)); postFixIncrement(ref i))
        {
            object transaction = this.parseTransaction(this.extend(new Dictionary<string, object>() {
                { "type", type },
            }, getValue(transactions, i)));
            ((List<object>)result).Add(transaction);
        }
        return this.filterByCurrencySinceLimit(result, code, since, limit);
    }

    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#fetchDeposits
        * @description fetch all deposits made to an account
        * @param {string|undefined} code unified currency code
        * @param {int|undefined} since the earliest time in ms to fetch deposits for
        * @param {int|undefined} limit the maximum number of deposits structures to retrieve
        * @param {object} params extra parameters specific to the kraken api endpoint
        * @returns {[object]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        // https://www.kraken.com/en-us/help/api#deposit-status
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(code, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchDeposits() requires a currency code argument")) ;
        }
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "asset", getValue(currency, "id") },
        };
        object response = await this.privatePostDepositStatus(this.extend(request, parameters));
        //
        //     {  error: [],
        //       result: [ { method: "Ether (Hex)",
        //                   aclass: "currency",
        //                    asset: "XETH",
        //                    refid: "Q2CANKL-LBFVEE-U4Y2WQ",
        //                     txid: "0x57fd704dab1a73c20e24c8696099b695d596924b401b261513cfdab23",
        //                     info: "0x615f9ba7a9575b0ab4d571b2b36b1b324bd83290",
        //                   amount: "7.9999257900",
        //                      fee: "0.0000000000",
        //                     time:  1529223212,
        //                   status: "Success"                                                       } ] }
        //
        return this.parseTransactionsByType("deposit", getValue(response, "result"), code, since, limit);
    }

    public async override Task<object> fetchTime(object parameters = null)
    {
        /**
        * @method
        * @name kraken#fetchTime
        * @description fetches the current integer timestamp in milliseconds from the exchange server
        * @param {object} params extra parameters specific to the kraken api endpoint
        * @returns {int} the current integer timestamp in milliseconds from the exchange server
        */
        // https://www.kraken.com/en-us/features/api#get-server-time
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetTime(parameters);
        //
        //    {
        //        "error": [],
        //        "result": {
        //            "unixtime": 1591502873,
        //            "rfc1123": "Sun,  7 Jun 20 04:07:53 +0000"
        //        }
        //    }
        //
        object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
        return this.safeTimestamp(result, "unixtime");
    }

    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#fetchWithdrawals
        * @description fetch all withdrawals made from an account
        * @param {string} code unified currency code
        * @param {int|undefined} since the earliest time in ms to fetch withdrawals for
        * @param {int|undefined} limit the maximum number of withdrawals structures to retrieve
        * @param {object} params extra parameters specific to the kraken api endpoint
        * @returns {[object]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        // https://www.kraken.com/en-us/help/api#withdraw-status
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(code, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchWithdrawals() requires a currency code argument")) ;
        }
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "asset", getValue(currency, "id") },
        };
        object response = await this.privatePostWithdrawStatus(this.extend(request, parameters));
        //
        //     {  error: [],
        //       result: [ { method: "Ether",
        //                   aclass: "currency",
        //                    asset: "XETH",
        //                    refid: "A2BF34S-O7LBNQ-UE4Y4O",
        //                     txid: "0x298c83c7b0904d8400ef43e1c9e2287b518f7ea3d838822d53f704a1565c274d",
        //                     info: "0x7cb275a5e07ba943fee972e165d80daa67cb2dd0",
        //                   amount: "9.9950000000",
        //                      fee: "0.0050000000",
        //                     time:  1530481750,
        //                   status: "Success"                                                             } ] }
        //
        return this.parseTransactionsByType("withdrawal", getValue(response, "result"), code, since, limit);
    }

    public async override Task<object> createDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name kraken#createDepositAddress
        * @description create a currency deposit address
        * @param {string} code unified currency code of the currency for the deposit address
        * @param {object} params extra parameters specific to the kraken api endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "new", "true" },
        };
        return await this.fetchDepositAddress(code, this.extend(request, parameters));
    }

    public async virtual Task<object> fetchDepositMethods(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "asset", getValue(currency, "id") },
        };
        object response = await this.privatePostDepositMethods(this.extend(request, parameters));
        //
        //     {
        //         "error":[],
        //         "result":[
        //             {"method":"Ether (Hex)","limit":false,"gen-address":true}
        //         ]
        //     }
        //
        //     {
        //         "error":[],
        //         "result":[
        //             {"method":"Tether USD (ERC20)","limit":false,"address-setup-fee":"0.00000000","gen-address":true},
        //             {"method":"Tether USD (TRC20)","limit":false,"address-setup-fee":"0.00000000","gen-address":true}
        //         ]
        //     }
        //
        //     {
        //         "error":[],
        //         "result":[
        //             {"method":"Bitcoin","limit":false,"fee":"0.0000000000","gen-address":true}
        //         ]
        //     }
        //
        return this.safeValue(response, "result");
    }

    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name kraken#fetchDepositAddress
        * @description fetch the deposit address for a currency associated with this account
        * @param {string} code unified currency code
        * @param {object} params extra parameters specific to the kraken api endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object network = this.safeStringUpper(parameters, "network");
        object networks = this.safeValue(this.options, "networks", new Dictionary<string, object>() {});
        network = this.safeString(networks, network, network); // support ETH > ERC20 aliases
        parameters = this.omit(parameters, "network");
        if (isTrue(isTrue((isEqual(code, "USDT"))) && isTrue((isEqual(network, "TRC20")))))
        {
            code = add(add(code, "-"), network);
        }
        object defaultDepositMethods = this.safeValue(this.options, "depositMethods", new Dictionary<string, object>() {});
        object defaultDepositMethod = this.safeString(defaultDepositMethods, code);
        object depositMethod = this.safeString(parameters, "method", defaultDepositMethod);
        // if the user has specified an exchange-specific method in params
        // we pass it as is, otherwise we take the 'network' unified param
        if (isTrue(isEqual(depositMethod, null)))
        {
            object depositMethods = await this.fetchDepositMethods(code);
            if (isTrue(!isEqual(network, null)))
            {
                // find best matching deposit method, or fallback to the first one
                for (object i = 0; isLessThan(i, getArrayLength(depositMethods)); postFixIncrement(ref i))
                {
                    object entry = this.safeString(getValue(depositMethods, i), "method");
                    if (isTrue(isGreaterThanOrEqual(getIndexOf(entry, network), 0)))
                    {
                        depositMethod = entry;
                        break;
                    }
                }
            }
            // if depositMethod was not specified, fallback to the first available deposit method
            if (isTrue(isEqual(depositMethod, null)))
            {
                object firstDepositMethod = this.safeValue(depositMethods, 0, new Dictionary<string, object>() {});
                depositMethod = this.safeString(firstDepositMethod, "method");
            }
        }
        object request = new Dictionary<string, object>() {
            { "asset", getValue(currency, "id") },
            { "method", depositMethod },
        };
        object response = await this.privatePostDepositAddresses(this.extend(request, parameters));
        //
        //     {
        //         "error":[],
        //         "result":[
        //             {"address":"0x77b5051f97efa9cc52c9ad5b023a53fc15c200d3","expiretm":"0"}
        //         ]
        //     }
        //
        object result = this.safeValue(response, "result", new List<object>() {});
        object firstResult = this.safeValue(result, 0, new Dictionary<string, object>() {});
        if (isTrue(isEqual(firstResult, null)))
        {
            throw new InvalidAddress ((string)add(add(this.id, " privatePostDepositAddresses() returned no addresses for "), code)) ;
        }
        return this.parseDepositAddress(firstResult, currency);
    }

    public override object parseDepositAddress(object depositAddress, object currency = null)
    {
        //
        //     {
        //         "address":"0x77b5051f97efa9cc52c9ad5b023a53fc15c200d3",
        //         "expiretm":"0"
        //     }
        //
        object address = this.safeString(depositAddress, "address");
        object tag = this.safeString(depositAddress, "tag");
        currency = this.safeCurrency(null, currency);
        object code = getValue(currency, "code");
        this.checkAddress(address);
        return new Dictionary<string, object>() {
            { "currency", code },
            { "address", address },
            { "tag", tag },
            { "network", null },
            { "info", depositAddress },
        };
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#withdraw
        * @description make a withdrawal
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string|undefined} tag
        * @param {object} params extra parameters specific to the kraken api endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((List<object>)tagparametersVariable)[0];
        parameters = ((List<object>)tagparametersVariable)[1];
        this.checkAddress(address);
        if (isTrue(((Dictionary<string,object>)parameters).ContainsKey(toStringOrNull("key"))))
        {
            await this.loadMarkets();
            object currency = this.currency(code);
            object request = new Dictionary<string, object>() {
                { "asset", getValue(currency, "id") },
                { "amount", amount },
            };
            object response = await this.privatePostWithdraw(this.extend(request, parameters));
            //
            //     {
            //         "error": [],
            //         "result": {
            //             "refid": "AGBSO6T-UFMTTQ-I7KGS6"
            //         }
            //     }
            //
            object result = this.safeValue(response, "result", new Dictionary<string, object>() {});
            return this.parseTransaction(result, currency);
        }
        throw new ExchangeError ((string)add(this.id, " withdraw() requires a \'key\' parameter (withdrawal key name, as set up on your account)")) ;
    }

    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name kraken#fetchPositions
        * @description fetch all open positions
        * @param {[string]|undefined} symbols not used by kraken fetchPositions ()
        * @param {object} params extra parameters specific to the kraken api endpoint
        * @returns {[object]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object response = await this.privatePostOpenPositions(this.extend(request, parameters));
        //
        // no consolidation
        //
        //     {
        //         error: [],
        //         result: {
        //             'TGUFMY-FLESJ-VYIX3J': {
        //                 ordertxid: "O3LRNU-ZKDG5-XNCDFR",
        //                 posstatus: "open",
        //                 pair: "ETHUSDT",
        //                 time:  1611557231.4584,
        //                 type: "buy",
        //                 ordertype: "market",
        //                 cost: "28.49800",
        //                 fee: "0.07979",
        //                 vol: "0.02000000",
        //                 vol_closed: "0.00000000",
        //                 margin: "14.24900",
        //                 terms: "0.0200% per 4 hours",
        //                 rollovertm: "1611571631",
        //                 misc: "",
        //                 oflags: ""
        //             }
        //         }
        //     }
        //
        // consolidation by market
        //
        //     {
        //         error: [],
        //         result: [
        //             {
        //                 pair: "ETHUSDT",
        //                 positions: "1",
        //                 type: "buy",
        //                 leverage: "2.00000",
        //                 cost: "28.49800",
        //                 fee: "0.07979",
        //                 vol: "0.02000000",
        //                 vol_closed: "0.00000000",
        //                 margin: "14.24900"
        //             }
        //         ]
        //     }
        //
        object result = this.safeValue(response, "result");
        // todo unify parsePosition/parsePositions
        return result;
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object url = add(add(add(add(add("/", this.version), "/"), api), "/"), path);
        if (isTrue(isEqual(api, "public")))
        {
            if (isTrue(getArrayLength(new List<object>(((Dictionary<string,object>)parameters).Keys))))
            {
                // urlencodeNested is used to address https://github.com/ccxt/ccxt/issues/12872
                url = add(url, add("?", this.urlencodeNested(parameters)));
            }
        } else if (isTrue(isEqual(api, "private")))
        {
            object isCancelOrderBatch = (isEqual(path, "CancelOrderBatch"));
            this.checkRequiredCredentials();
            object nonce = ((object)this.nonce()).ToString();
            // urlencodeNested is used to address https://github.com/ccxt/ccxt/issues/12872
            if (isTrue(isCancelOrderBatch))
            {
                body = this.json(this.extend(new Dictionary<string, object>() {
                    { "nonce", nonce },
                }, parameters));
            } else
            {
                body = this.urlencodeNested(this.extend(new Dictionary<string, object>() {
                    { "nonce", nonce },
                }, parameters));
            }
            object auth = this.encode(add(nonce, body));
            object hash = this.hash(auth, sha256, "binary");
            object binary = this.encode(url);
            object binhash = this.binaryConcat(binary, hash);
            object secret = this.base64ToBinary(this.secret);
            object signature = this.hmac(binhash, secret, sha512, "base64");
            headers = new Dictionary<string, object>() {
                { "API-Key", this.apiKey },
                { "API-Sign", signature },
            };
            if (isTrue(isCancelOrderBatch))
            {
                ((Dictionary<string, object>)headers)["Content-Type"] = "application/json";
            } else
            {
                ((Dictionary<string, object>)headers)["Content-Type"] = "application/x-www-form-urlencoded";
            }
        } else
        {
            url = add("/", path);
        }
        url = add(getValue(getValue(this.urls, "api"), api), url);
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object nonce()
    {
        return this.milliseconds();
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(code, 520)))
        {
            throw new ExchangeNotAvailable ((string)add(add(add(add(this.id, " "), ((object)code).ToString()), " "), reason)) ;
        }
        // todo: rewrite this for "broad" exceptions matching
        if (isTrue(isGreaterThanOrEqual(getIndexOf(body, "Invalid order"), 0)))
        {
            throw new InvalidOrder ((string)add(add(this.id, " "), body)) ;
        }
        if (isTrue(isGreaterThanOrEqual(getIndexOf(body, "Invalid nonce"), 0)))
        {
            throw new InvalidNonce ((string)add(add(this.id, " "), body)) ;
        }
        if (isTrue(isGreaterThanOrEqual(getIndexOf(body, "Insufficient funds"), 0)))
        {
            throw new InsufficientFunds ((string)add(add(this.id, " "), body)) ;
        }
        if (isTrue(isGreaterThanOrEqual(getIndexOf(body, "Cancel pending"), 0)))
        {
            throw new CancelPending ((string)add(add(this.id, " "), body)) ;
        }
        if (isTrue(isGreaterThanOrEqual(getIndexOf(body, "Invalid arguments:volume"), 0)))
        {
            throw new InvalidOrder ((string)add(add(this.id, " "), body)) ;
        }
        if (isTrue(isGreaterThanOrEqual(getIndexOf(body, "Rate limit exceeded"), 0)))
        {
            throw new RateLimitExceeded ((string)add(add(this.id, " "), body)) ;
        }
        if (isTrue(isEqual(response, null)))
        {
            return null;
        }
        if (isTrue(isEqual(getValue(body, 0), "{")))
        {
            if (isTrue(!((response).GetType() == typeof(string))))
            {
                if (isTrue(((Dictionary<string,object>)response).ContainsKey(toStringOrNull("error"))))
                {
                    object numErrors = getArrayLength(getValue(response, "error"));
                    if (isTrue(numErrors))
                    {
                        object message = add(add(this.id, " "), body);
                        for (object i = 0; isLessThan(i, getArrayLength(getValue(response, "error"))); postFixIncrement(ref i))
                        {
                            object error = getValue(getValue(response, "error"), i);
                            this.throwExactlyMatchedException(this.exceptions, error, message);
                        }
                        throw new ExchangeError ((string)message) ;
                    }
                }
            }
        }
        return null;
    }
}
