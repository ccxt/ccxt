using ccxt;
namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

partial class buda : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "buda" },
            { "name", "Buda" },
            { "countries", new List<object>() {"AR", "CL", "CO", "PE"} },
            { "rateLimit", 1000 },
            { "version", "v2" },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", false },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "addMargin", false },
                { "cancelOrder", true },
                { "createDepositAddress", true },
                { "createOrder", true },
                { "createReduceOnlyOrder", false },
                { "fetchBalance", true },
                { "fetchBorrowRate", false },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchBorrowRates", false },
                { "fetchBorrowRatesPerSymbol", false },
                { "fetchClosedOrders", true },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", true },
                { "fetchDeposits", true },
                { "fetchFundingHistory", false },
                { "fetchFundingRate", false },
                { "fetchFundingRateHistory", false },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", false },
                { "fetchLeverage", false },
                { "fetchMarginMode", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyTrades", false },
                { "fetchOHLCV", true },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", true },
                { "fetchPosition", false },
                { "fetchPositionMode", false },
                { "fetchPositions", false },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchTicker", true },
                { "fetchTrades", true },
                { "fetchTradingFee", false },
                { "fetchTradingFees", false },
                { "fetchTransactionFees", true },
                { "fetchTransfer", false },
                { "fetchTransfers", false },
                { "fetchWithdrawal", false },
                { "fetchWithdrawals", true },
                { "reduceMargin", false },
                { "setLeverage", false },
                { "setMarginMode", false },
                { "setPositionMode", false },
                { "transfer", false },
                { "withdraw", true },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/1294454/47380619-8a029200-d706-11e8-91e0-8a391fe48de3.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "rest", "https://www.buda.com/api" },
                } },
                { "www", "https://www.buda.com" },
                { "doc", "https://api.buda.com" },
                { "fees", "https://www.buda.com/comisiones" },
            } },
            { "status", new Dictionary<string, object>() {
                { "status", "error" },
                { "updated", null },
                { "eta", null },
                { "url", null },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new List<object>() {"pairs", "markets", "currencies", "markets/{market}", "markets/{market}/ticker", "markets/{market}/volume", "markets/{market}/order_book", "markets/{market}/trades", "currencies/{currency}/fees/deposit", "currencies/{currency}/fees/withdrawal", "tv/history"} },
                    { "post", new List<object>() {"markets/{market}/quotations"} },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new List<object>() {"balances", "balances/{currency}", "currencies/{currency}/balances", "orders", "orders/{id}", "markets/{market}/orders", "deposits", "currencies/{currency}/deposits", "withdrawals", "currencies/{currency}/withdrawals", "currencies/{currency}/receive_addresses", "currencies/{currency}/receive_addresses/{id}"} },
                    { "post", new List<object>() {"markets/{market}/orders", "currencies/{currency}/deposits", "currencies/{currency}/withdrawals", "currencies/{currency}/simulated_withdrawals", "currencies/{currency}/receive_addresses"} },
                    { "put", new List<object>() {"orders/{id}"} },
                } },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1" },
                { "5m", "5" },
                { "30m", "30" },
                { "1h", "60" },
                { "2h", "120" },
                { "1d", "D" },
                { "1w", "W" },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "tierBased", true },
                    { "percentage", true },
                    { "taker", 0.008 },
                    { "maker", 0.004 },
                    { "tiers", new Dictionary<string, object>() {
                        { "taker", new List<object>() {new List<object>() {0, 0.008}, new List<object>() {2000, 0.007}, new List<object>() {20000, 0.006}, new List<object>() {100000, 0.005}, new List<object>() {500000, 0.004}, new List<object>() {2500000, 0.003}, new List<object>() {12500000, 0.002}} },
                        { "maker", new List<object>() {new List<object>() {0, 0.004}, new List<object>() {2000, 0.0035}, new List<object>() {20000, 0.003}, new List<object>() {100000, 0.0025}, new List<object>() {500000, 0.002}, new List<object>() {2500000, 0.0015}, new List<object>() {12500000, 0.001}} },
                    } },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "exceptions", new Dictionary<string, object>() {
                { "not_authorized", typeof(AuthenticationError) },
                { "forbidden", typeof(PermissionDenied) },
                { "invalid_record", typeof(ExchangeError) },
                { "not_found", typeof(ExchangeError) },
                { "parameter_missing", typeof(ExchangeError) },
                { "bad_parameter", typeof(ExchangeError) },
            } },
        });
    }

    public async virtual Task<object> fetchCurrencyInfo(object currency, object currencies = null)
    {
        if (!isTrue(currencies))
        {
            object response = await this.publicGetCurrencies();
            //
            //     {
            //         "currencies":[
            //             {
            //                 "id":"BTC",
            //                 "symbol":"฿",
            //                 "managed":true,
            //                 "input_decimals":8,
            //                 "display_decimals":8,
            //                 "timezone":"UTC",
            //                 "deposit_minimum":["0.0","BTC"],
            //                 "withdrawal_minimum":["0.00001","BTC"],
            //                 "max_digits_for_decimals":6,
            //                 "crypto":true,
            //                 "address_explorer":"https://blockchair.com/bitcoin/address/",
            //                 "tx_explorer":"https://blockchair.com/bitcoin/transaction/",
            //                 "amount_to_micro_multiplier":1000000000000
            //             }
            //         ]
            //     }
            //
            currencies = this.safeValue(response, "currencies");
        }
        for (object i = 0; isLessThan(i, getArrayLength(currencies)); postFixIncrement(ref i))
        {
            object currencyInfo = getValue(currencies, i);
            if (isTrue(isEqual(getValue(currencyInfo, "id"), currency)))
            {
                return currencyInfo;
            }
        }
        return null;
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name buda#fetchMarkets
        * @description retrieves data on all markets for buda
        * @param {object} params extra parameters specific to the exchange api endpoint
        * @returns {[object]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object marketsResponse = await this.publicGetMarkets(parameters);
        //
        //     {
        //         "markets": [
        //           {
        //             "id": "BTC-CLP",
        //             "name": "btc-clp",
        //             "base_currency": "BTC",
        //             "quote_currency": "CLP",
        //             "minimum_order_amount": [
        //               "0.00002",
        //               "BTC"
        //             ],
        //             "disabled": false,
        //             "illiquid": false,
        //             "rpo_disabled": null,
        //             "taker_fee": "0.8",
        //             "maker_fee": "0.4",
        //             "max_orders_per_minute": 50,
        //             "maker_discount_percentage": "0.0",
        //             "taker_discount_percentage": "0.0"
        //           },
        //         ]
        //     }
        //
        object markets = this.safeValue(marketsResponse, "markets", new List<object>() {});
        object currenciesResponse = await this.publicGetCurrencies();
        object currencies = this.safeValue(currenciesResponse, "currencies");
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(markets)); postFixIncrement(ref i))
        {
            object market = getValue(markets, i);
            object baseId = this.safeString(market, "base_currency");
            object quoteId = this.safeString(market, "quote_currency");
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            object baseInfo = await this.fetchCurrencyInfo(baseId, currencies);
            object quoteInfo = await this.fetchCurrencyInfo(quoteId, currencies);
            object minimumOrderAmount = this.safeValue(market, "minimum_order_amount", new List<object>() {});
            object taker_fee = this.safeString(market, "taker_fee");
            object maker_fee = this.safeString(market, "maker_fee");
            ((List<object>)result).Add(new Dictionary<string, object>() {
                { "id", this.safeString(market, "id") },
                { "symbol", add(add(bs, "/"), quote) },
                { "base", bs },
                { "quote", quote },
                { "settle", null },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", null },
                { "type", "spot" },
                { "spot", true },
                { "margin", false },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "active", true },
                { "contract", false },
                { "linear", null },
                { "inverse", null },
                { "contractSize", null },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "taker", this.parseNumber(Precise.stringDiv(taker_fee, "1000")) },
                { "maker", this.parseNumber(Precise.stringDiv(maker_fee, "1000")) },
                { "precision", new Dictionary<string, object>() {
                    { "amount", this.parseNumber(this.parsePrecision(this.safeString(baseInfo, "input_decimals"))) },
                    { "price", this.parseNumber(this.parsePrecision(this.safeString(quoteInfo, "input_decimals"))) },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber(minimumOrderAmount, 0) },
                        { "max", null },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "info", market },
            });
        }
        return result;
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name buda#fetchCurrencies
        * @description fetches all available currencies on an exchange
        * @param {object} params extra parameters specific to the buda api endpoint
        * @returns {object} an associative dictionary of currencies
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetCurrencies();
        //
        //     {
        //         "currencies":[
        //             {
        //                 "id":"BTC",
        //                 "symbol":"฿",
        //                 "managed":true,
        //                 "input_decimals":8,
        //                 "display_decimals":8,
        //                 "timezone":"UTC",
        //                 "deposit_minimum":["0.0","BTC"],
        //                 "withdrawal_minimum":["0.00001","BTC"],
        //                 "max_digits_for_decimals":6,
        //                 "crypto":true,
        //                 "address_explorer":"https://blockchair.com/bitcoin/address/",
        //                 "tx_explorer":"https://blockchair.com/bitcoin/transaction/",
        //                 "amount_to_micro_multiplier":1000000000000
        //             }
        //         ]
        //     }
        //
        object currencies = getValue(response, "currencies");
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(currencies)); postFixIncrement(ref i))
        {
            object currency = getValue(currencies, i);
            object managed = this.safeValue(currency, "managed", false);
            if (!isTrue(managed))
            {

            }
            object id = this.safeString(currency, "id");
            object code = this.safeCurrencyCode(id);
            object precision = this.parseNumber(this.parsePrecision(this.safeString(currency, "input_decimals")));
            object depositMinimum = this.safeValue(currency, "deposit_minimum", new List<object>() {});
            object withdrawalMinimum = this.safeValue(currency, "withdrawal_minimum", new List<object>() {});
            object minDeposit = this.safeNumber(depositMinimum, 0);
            object minWithdraw = this.safeNumber(withdrawalMinimum, 0);
            ((Dictionary<string, object>)result)[(string)code] = new Dictionary<string, object>() {
                { "id", id },
                { "code", code },
                { "info", currency },
                { "name", null },
                { "active", true },
                { "deposit", null },
                { "withdraw", null },
                { "fee", null },
                { "precision", precision },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", precision },
                        { "max", null },
                    } },
                    { "deposit", new Dictionary<string, object>() {
                        { "min", minDeposit },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", minWithdraw },
                    } },
                } },
            };
        }
        return result;
    }

    public async override Task<object> fetchTransactionFees(object codes = null, object parameters = null)
    {
        /**
        * @method
        * @name buda#fetchTransactionFees
        * @description fetch transaction fees
        * @param {[string]|undefined} codes list of unified currency codes
        * @param {object} params extra parameters specific to the buda api endpoint
        * @returns {object} a list of [fees structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        //  by default it will try load withdrawal fees of all currencies (with separate requests)
        //  however if you define codes = [ 'ETH', 'BTC' ] in args it will only load those
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object withdrawFees = new Dictionary<string, object>() {};
        object depositFees = new Dictionary<string, object>() {};
        object info = new Dictionary<string, object>() {};
        if (isTrue(isEqual(codes, null)))
        {
            codes = new List<object>(((Dictionary<string,object>)this.currencies).Keys);
        }
        for (object i = 0; isLessThan(i, getArrayLength(codes)); postFixIncrement(ref i))
        {
            object code = getValue(codes, i);
            object currency = this.currency(code);
            object request = new Dictionary<string, object>() {
                { "currency", getValue(currency, "id") },
            };
            object withdrawResponse = await this.publicGetCurrenciesCurrencyFeesWithdrawal(request);
            object depositResponse = await this.publicGetCurrenciesCurrencyFeesDeposit(request);
            ((Dictionary<string, object>)withdrawFees)[(string)code] = this.parseTransactionFee(getValue(withdrawResponse, "fee"));
            ((Dictionary<string, object>)depositFees)[(string)code] = this.parseTransactionFee(getValue(depositResponse, "fee"));
            ((Dictionary<string, object>)info)[(string)code] = new Dictionary<string, object>() {
                { "withdraw", withdrawResponse },
                { "deposit", depositResponse },
            };
        }
        return new Dictionary<string, object>() {
            { "withdraw", withdrawFees },
            { "deposit", depositFees },
            { "info", info },
        };
    }

    public virtual object parseTransactionFee(object fee, object type = null)
    {
        if (isTrue(isEqual(type, null)))
        {
            type = getValue(fee, "name");
        }
        if (isTrue(isEqual(type, "withdrawal")))
        {
            type = "withdraw";
        }
        return new Dictionary<string, object>() {
            { "type", type },
            { "currency", getValue(getValue(fee, "base"), 1) },
            { "rate", getValue(fee, "percent") },
            { "cost", parseFloat(getValue(getValue(fee, "base"), 0)) },
        };
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name buda#fetchTicker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} params extra parameters specific to the buda api endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
        };
        object response = await this.publicGetMarketsMarketTicker(this.extend(request, parameters));
        //
        //     {
        //         "ticker":{
        //             "market_id":"ETH-BTC",
        //             "last_price":["0.07300001","BTC"],
        //             "min_ask":["0.07716895","BTC"],
        //             "max_bid":["0.0754966","BTC"],
        //             "volume":["0.168965697","ETH"],
        //             "price_variation_24h":"-0.046",
        //             "price_variation_7d":"-0.085"
        //         }
        //     }
        //
        object ticker = this.safeValue(response, "ticker");
        return this.parseTicker(ticker, market);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        // fetchTicker
        //
        //     {
        //         "market_id":"ETH-BTC",
        //         "last_price":["0.07300001","BTC"],
        //         "min_ask":["0.07716895","BTC"],
        //         "max_bid":["0.0754966","BTC"],
        //         "volume":["0.168965697","ETH"],
        //         "price_variation_24h":"-0.046",
        //         "price_variation_7d":"-0.085"
        //     }
        //
        object timestamp = this.milliseconds();
        object marketId = this.safeString(ticker, "market_id");
        object symbol = this.safeSymbol(marketId, market, "-");
        object lastPrice = this.safeValue(ticker, "last_price", new List<object>() {});
        object last = this.safeString(lastPrice, 0);
        object percentage = this.safeString(ticker, "price_variation_24h");
        percentage = Precise.stringMul(percentage, "100");
        object maxBid = this.safeValue(ticker, "max_bid", new List<object>() {});
        object minAsk = this.safeValue(ticker, "min_ask", new List<object>() {});
        object baseVolume = this.safeValue(ticker, "volume", new List<object>() {});
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", null },
            { "low", null },
            { "bid", this.safeString(maxBid, 0) },
            { "bidVolume", null },
            { "ask", this.safeString(minAsk, 0) },
            { "askVolume", null },
            { "vwap", null },
            { "open", null },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", percentage },
            { "average", null },
            { "baseVolume", this.safeString(baseVolume, 0) },
            { "quoteVolume", null },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name buda#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int|undefined} since timestamp in ms of the earliest trade to fetch
        * @param {int|undefined} limit the maximum amount of trades to fetch
        * @param {object} params extra parameters specific to the buda api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/en/latest/manual.html?#public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
        };
        // the since argument works backwards – returns trades up to the specified timestamp
        // therefore not implemented here
        // the method is still available for users to be able to traverse backwards in time
        // by using the timestamp from the first received trade upon each iteration
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit; // 50 max
        }
        object response = await this.publicGetMarketsMarketTrades(this.extend(request, parameters));
        //
        //     { trades: {      market_id:   "ETH-BTC",
        //                      timestamp:    null,
        //                 last_timestamp:   "1536901277302",
        //                        entries: [ [ "1540077456791", "0.0063767", "0.03", "sell", 479842 ],
        //                                   [ "1539916642772", "0.01888263", "0.03019563", "sell", 479438 ],
        //                                   [ "1539834081787", "0.023718648", "0.031001", "sell", 479069 ],
        //                                   ... ]
        //
        return this.parseTrades(getValue(getValue(response, "trades"), "entries"), market, since, limit);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // fetchTrades (public)
        //  [ "1540077456791", "0.0063767", "0.03", "sell", 479842 ]
        //
        object timestamp = null;
        object side = null;
        object type = null;
        object priceString = null;
        object amountString = null;
        object id = null;
        object order = null;
        object fee = null;
        object symbol = null;
        if (isTrue(market))
        {
            symbol = getValue(market, "symbol");
        }
        if (isTrue((trade.GetType().IsGenericType && trade.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))
        {
            timestamp = this.safeInteger(trade, 0);
            priceString = this.safeString(trade, 1);
            amountString = this.safeString(trade, 2);
            side = this.safeString(trade, 3);
            id = this.safeString(trade, 4);
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", id },
            { "order", order },
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "type", type },
            { "side", side },
            { "takerOrMaker", null },
            { "price", priceString },
            { "amount", amountString },
            { "cost", null },
            { "fee", fee },
        }, market);
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name buda#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int|undefined} limit the maximum amount of order book entries to return
        * @param {object} params extra parameters specific to the buda api endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
        };
        object response = await this.publicGetMarketsMarketOrderBook(this.extend(request, parameters));
        object orderbook = this.safeValue(response, "order_book");
        return this.parseOrderBook(orderbook, getValue(market, "symbol"));
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name buda#fetchOHLCV
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int|undefined} since timestamp in ms of the earliest candle to fetch
        * @param {int|undefined} limit the maximum amount of candles to fetch
        * @param {object} params extra parameters specific to the buda api endpoint
        * @returns {[[int]]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(isEqual(since, null)))
        {
            since = subtract(this.milliseconds(), 86400000);
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "resolution", this.safeString(this.timeframes, timeframe, timeframe) },
            { "from", divide(since, 1000) },
            { "to", this.seconds() },
        };
        object response = await this.publicGetTvHistory(this.extend(request, parameters));
        return this.parseTradingViewOHLCV(response, market, timeframe, since, limit);
    }

    public virtual object parseBalance(object response)
    {
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        object balances = this.safeValue(response, "balances", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
        {
            object balance = getValue(balances, i);
            object currencyId = this.safeString(balance, "id");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            ((Dictionary<string, object>)account)["free"] = this.safeString(getValue(balance, "available_amount"), 0);
            ((Dictionary<string, object>)account)["total"] = this.safeString(getValue(balance, "amount"), 0);
            ((Dictionary<string, object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name buda#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @param {object} params extra parameters specific to the buda api endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/en/latest/manual.html?#balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetBalances(parameters);
        return this.parseBalance(response);
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name buda#fetchOrder
        * @description fetches information on an order made by the user
        * @param {string|undefined} symbol not used by buda fetchOrder
        * @param {object} params extra parameters specific to the buda api endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "id", parseInt(id) },
        };
        object response = await this.privateGetOrdersId(this.extend(request, parameters));
        object order = this.safeValue(response, "order");
        return this.parseOrder(order);
    }

    public async override Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name buda#fetchOrders
        * @description fetches information on multiple orders made by the user
        * @param {string|undefined} symbol unified market symbol of the market orders were made in
        * @param {int|undefined} since the earliest time in ms to fetch orders for
        * @param {int|undefined} limit the maximum number of  orde structures to retrieve
        * @param {object} params extra parameters specific to the buda api endpoint
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
            { "per", limit },
        };
        object response = await this.privateGetMarketsMarketOrders(this.extend(request, parameters));
        object orders = this.safeValue(response, "orders");
        return this.parseOrders(orders, market, since, limit);
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name buda#fetchOpenOrders
        * @description fetch all unfilled currently open orders
        * @param {string|undefined} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch open orders for
        * @param {int|undefined} limit the maximum number of  open orders structures to retrieve
        * @param {object} params extra parameters specific to the buda api endpoint
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "state", "pending" },
        };
        return await this.fetchOrders(symbol, since, limit, this.extend(request, parameters));
    }

    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name buda#fetchClosedOrders
        * @description fetches information on multiple closed orders made by the user
        * @param {string|undefined} symbol unified market symbol of the market orders were made in
        * @param {int|undefined} since the earliest time in ms to fetch orders for
        * @param {int|undefined} limit the maximum number of  orde structures to retrieve
        * @param {object} params extra parameters specific to the buda api endpoint
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "state", "traded" },
        };
        return await this.fetchOrders(symbol, since, limit, this.extend(request, parameters));
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name buda#createOrder
        * @description create a trade order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float|undefined} price the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} params extra parameters specific to the buda api endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object requestSide = ((bool) isTrue((isEqual(side, "buy")))) ? "Bid" : "Ask";
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "market", getValue(market, "id") },
            { "price_type", type },
            { "type", requestSide },
            { "amount", this.amountToPrecision(symbol, amount) },
        };
        if (isTrue(isEqual(type, "limit")))
        {
            ((Dictionary<string, object>)request)["limit"] = this.priceToPrecision(symbol, price);
        }
        object response = await this.privatePostMarketsMarketOrders(this.extend(request, parameters));
        object order = this.safeValue(response, "order");
        return this.parseOrder(order);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name buda#cancelOrder
        * @description cancels an open order
        * @param {string} id order id
        * @param {string|undefined} symbol not used by buda cancelOrder ()
        * @param {object} params extra parameters specific to the buda api endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "id", parseInt(id) },
            { "state", "canceling" },
        };
        object response = await this.privatePutOrdersId(this.extend(request, parameters));
        object order = this.safeValue(response, "order");
        return this.parseOrder(order);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "traded", "closed" },
            { "received", "open" },
            { "canceling", "canceled" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        //     {
        //         'id': 63679183,
        //         'uuid': 'f9697bee-627e-4175-983f-0d5a41963fec',
        //         'market_id': 'ETH-CLP',
        //         'account_id': 51590,
        //         'type': 'Ask',
        //         'state': 'received',
        //         'created_at': '2021-01-04T08:29:52.730Z',
        //         'fee_currency': 'CLP',
        //         'price_type': 'limit',
        //         'source': None,
        //         'limit': ['741000.0', 'CLP'],
        //         'amount': ['0.001', 'ETH'],
        //         'original_amount': ['0.001', 'ETH'],
        //         'traded_amount': ['0.0', 'ETH'],
        //         'total_exchanged': ['0.0', 'CLP'],
        //         'paid_fee': ['0.0', 'CLP']
        //     }
        //
        object id = this.safeString(order, "id");
        object timestamp = this.parse8601(this.safeString(order, "created_at"));
        object datetime = this.iso8601(timestamp);
        object marketId = this.safeString(order, "market_id");
        object symbol = this.safeSymbol(marketId, market, "-");
        object type = this.safeString(order, "price_type");
        object side = this.safeStringLower(order, "type");
        object status = this.parseOrderStatus(this.safeString(order, "state"));
        object originalAmount = this.safeValue(order, "original_amount", new List<object>() {});
        object amount = this.safeString(originalAmount, 0);
        object remainingAmount = this.safeValue(order, "amount", new List<object>() {});
        object remaining = this.safeString(remainingAmount, 0);
        object tradedAmount = this.safeValue(order, "traded_amount", new List<object>() {});
        object filled = this.safeString(tradedAmount, 0);
        object totalExchanged = this.safeValue(order, "total_exchanged", new List<object>() {});
        object cost = this.safeString(totalExchanged, 0);
        object limitPrice = this.safeValue(order, "limit", new List<object>() {});
        object price = this.safeString(limitPrice, 0);
        if (isTrue(isEqual(price, null)))
        {
            if (isTrue(!isEqual(limitPrice, null)))
            {
                price = limitPrice;
            }
        }
        object paidFee = this.safeValue(order, "paid_fee", new List<object>() {});
        object feeCost = this.safeString(paidFee, 0);
        object fee = null;
        if (isTrue(!isEqual(feeCost, null)))
        {
            object feeCurrencyId = this.safeString(paidFee, 1);
            object feeCurrencyCode = this.safeCurrencyCode(feeCurrencyId);
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
                { "code", feeCurrencyCode },
                { "currency", feeCurrencyCode },
            };
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", id },
            { "clientOrderId", null },
            { "datetime", datetime },
            { "timestamp", timestamp },
            { "lastTradeTimestamp", null },
            { "status", status },
            { "symbol", symbol },
            { "type", type },
            { "timeInForce", null },
            { "postOnly", null },
            { "side", side },
            { "price", price },
            { "stopPrice", null },
            { "triggerPrice", null },
            { "average", null },
            { "cost", cost },
            { "amount", amount },
            { "filled", filled },
            { "remaining", remaining },
            { "trades", null },
            { "fee", fee },
        }, market);
    }

    public virtual object isFiat(object code)
    {
        object fiats = new Dictionary<string, object>() {
            { "ARS", true },
            { "CLP", true },
            { "COP", true },
            { "PEN", true },
        };
        return this.safeValue(fiats, code, false);
    }

    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name buda#fetchDepositAddress
        * @description fetch the deposit address for a currency associated with this account
        * @param {string} code unified currency code
        * @param {object} params extra parameters specific to the buda api endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        if (isTrue(this.isFiat(code)))
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchDepositAddress() for fiat "), code), " is not supported")) ;
        }
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        object response = await this.privateGetCurrenciesCurrencyReceiveAddresses(this.extend(request, parameters));
        object receiveAddresses = this.safeValue(response, "receive_addresses");
        object addressPool = new List<object>() {};
        for (object i = 1; isLessThan(i, getArrayLength(receiveAddresses)); postFixIncrement(ref i))
        {
            object receiveAddress = getValue(receiveAddresses, i);
            if (isTrue(getValue(receiveAddress, "ready")))
            {
                object addressInner = getValue(receiveAddress, "address");
                this.checkAddress(addressInner);
                ((List<object>)addressPool).Add(addressInner);
            }
        }
        object addressPoolLength = getArrayLength(addressPool);
        if (isTrue(isLessThan(addressPoolLength, 1)))
        {
            throw new AddressPending ((string)add(add(add(this.id, ": there are no addresses ready for receiving "), code), ", retry again later)")) ;
        }
        object address = getValue(addressPool, 0);
        return new Dictionary<string, object>() {
            { "currency", code },
            { "address", address },
            { "tag", null },
            { "network", null },
            { "info", receiveAddresses },
        };
    }

    public async override Task<object> createDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name buda#createDepositAddress
        * @description create a currency deposit address
        * @param {string} code unified currency code of the currency for the deposit address
        * @param {object} params extra parameters specific to the buda api endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        if (isTrue(this.isFiat(code)))
        {
            throw new NotSupported ((string)add(add(add(this.id, " createDepositAddress() of fiat for "), code), " is not supported")) ;
        }
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
        };
        object response = await this.privatePostCurrenciesCurrencyReceiveAddresses(this.extend(request, parameters));
        object address = this.safeString(getValue(response, "receive_address"), "address"); // the creation is async and returns a null address, returns only the id
        return new Dictionary<string, object>() {
            { "currency", code },
            { "address", address },
            { "tag", null },
            { "info", response },
        };
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "rejected", "failed" },
            { "confirmed", "ok" },
            { "anulled", "canceled" },
            { "retained", "canceled" },
            { "pending_confirmation", "pending" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        object id = this.safeString(transaction, "id");
        object timestamp = this.parse8601(this.safeString(transaction, "created_at"));
        object currencyId = this.safeString(transaction, "currency");
        object code = this.safeCurrencyCode(currencyId, currency);
        object amount = parseFloat(getValue(getValue(transaction, "amount"), 0));
        object fee = parseFloat(getValue(getValue(transaction, "fee"), 0));
        object feeCurrency = getValue(getValue(transaction, "fee"), 1);
        object status = this.parseTransactionStatus(this.safeString(transaction, "state"));
        object type = ((bool) isTrue((((Dictionary<string,object>)transaction).ContainsKey(toStringOrNull("deposit_data"))))) ? "deposit" : "withdrawal";
        object data = this.safeValue(transaction, add(type, "_data"), new Dictionary<string, object>() {});
        object address = this.safeValue(data, "target_address");
        object txid = this.safeString(data, "tx_hash");
        object updated = this.parse8601(this.safeString(data, "updated_at"));
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", id },
            { "txid", txid },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "network", null },
            { "address", address },
            { "addressTo", null },
            { "addressFrom", null },
            { "tag", null },
            { "tagTo", null },
            { "tagFrom", null },
            { "type", type },
            { "amount", amount },
            { "currency", code },
            { "status", status },
            { "updated", updated },
            { "fee", new Dictionary<string, object>() {
                { "cost", fee },
                { "rate", feeCurrency },
            } },
        };
    }

    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name buda#fetchDeposits
        * @description fetch all deposits made to an account
        * @param {string} code unified currency code
        * @param {int|undefined} since the earliest time in ms to fetch deposits for
        * @param {int|undefined} limit the maximum number of deposits structures to retrieve
        * @param {object} params extra parameters specific to the buda api endpoint
        * @returns {[object]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(code, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchDeposits() requires a currency code argument")) ;
        }
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "per", limit },
        };
        object response = await this.privateGetCurrenciesCurrencyDeposits(this.extend(request, parameters));
        object deposits = this.safeValue(response, "deposits");
        return this.parseTransactions(deposits, currency, since, limit);
    }

    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name buda#fetchWithdrawals
        * @description fetch all withdrawals made from an account
        * @param {string} code unified currency code
        * @param {int|undefined} since the earliest time in ms to fetch withdrawals for
        * @param {int|undefined} limit the maximum number of withdrawals structures to retrieve
        * @param {object} params extra parameters specific to the buda api endpoint
        * @returns {[object]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(code, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchWithdrawals() requires a currency code argument")) ;
        }
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "per", limit },
        };
        object response = await this.privateGetCurrenciesCurrencyWithdrawals(this.extend(request, parameters));
        object withdrawals = this.safeValue(response, "withdrawals");
        return this.parseTransactions(withdrawals, currency, since, limit);
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name buda#withdraw
        * @description make a withdrawal
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string|undefined} tag
        * @param {object} params extra parameters specific to the buda api endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((List<object>)tagparametersVariable)[0];
        parameters = ((List<object>)tagparametersVariable)[1];
        this.checkAddress(address);
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency", getValue(currency, "id") },
            { "amount", amount },
            { "withdrawal_data", new Dictionary<string, object>() {
                { "target_address", address },
            } },
        };
        object response = await this.privatePostCurrenciesCurrencyWithdrawals(this.extend(request, parameters));
        object withdrawal = this.safeValue(response, "withdrawal");
        return this.parseTransaction(withdrawal);
    }

    public override object nonce()
    {
        return this.microseconds();
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object request = this.implodeParams(path, parameters);
        object query = this.omit(parameters, this.extractParams(path));
        if (isTrue(getArrayLength(new List<object>(((Dictionary<string,object>)query).Keys))))
        {
            if (isTrue(isEqual(method, "GET")))
            {
                request = add(request, add("?", this.urlencode(query)));
            } else
            {
                body = this.json(query);
            }
        }
        object url = add(add(add(add(getValue(getValue(this.urls, "api"), "rest"), "/"), this.version), "/"), request);
        if (isTrue(isEqual(api, "private")))
        {
            this.checkRequiredCredentials();
            object nonce = ((object)this.nonce()).ToString();
            object components = new List<object>() {method, add(add(add("/api/", this.version), "/"), request)};
            if (isTrue(body))
            {
                object base64Body = this.stringToBase64(body);
                ((List<object>)components).Add(base64Body);
            }
            ((List<object>)components).Add(nonce);
            object message = String.Join(" ", ((List<object>)components).ToArray());
            object signature = this.hmac(this.encode(message), this.encode(this.secret), sha384);
            headers = new Dictionary<string, object>() {
                { "X-SBTC-APIKEY", this.apiKey },
                { "X-SBTC-SIGNATURE", signature },
                { "X-SBTC-NONCE", nonce },
                { "Content-Type", "application/json" },
            };
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;  // fallback to default error handler
        }
        if (isTrue(isGreaterThanOrEqual(code, 400)))
        {
            object errorCode = this.safeString(response, "code");
            object message = this.safeString(response, "message", body);
            object feedback = add(add(this.id, " "), message);
            if (isTrue(!isEqual(errorCode, null)))
            {
                this.throwExactlyMatchedException(this.exceptions, errorCode, feedback);
                throw new ExchangeError ((string)feedback) ;
            }
        }
        return null;
    }
}
