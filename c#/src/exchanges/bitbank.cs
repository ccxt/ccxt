using ccxt;
namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

partial class bitbank : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "bitbank" },
            { "name", "bitbank" },
            { "countries", new List<object>() {"JP"} },
            { "version", "v1" },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", false },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "addMargin", false },
                { "cancelOrder", true },
                { "createOrder", true },
                { "createReduceOnlyOrder", false },
                { "fetchBalance", true },
                { "fetchBorrowRate", false },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchBorrowRates", false },
                { "fetchBorrowRatesPerSymbol", false },
                { "fetchDepositAddress", true },
                { "fetchFundingHistory", false },
                { "fetchFundingRate", false },
                { "fetchFundingRateHistory", false },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", false },
                { "fetchLeverage", false },
                { "fetchLeverageTiers", false },
                { "fetchMarginMode", false },
                { "fetchMarkOHLCV", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchPosition", false },
                { "fetchPositionMode", false },
                { "fetchPositions", false },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchTicker", true },
                { "fetchTrades", true },
                { "fetchTradingFee", false },
                { "fetchTradingFees", true },
                { "fetchTransfer", false },
                { "fetchTransfers", false },
                { "reduceMargin", false },
                { "setLeverage", false },
                { "setMarginMode", false },
                { "setPositionMode", false },
                { "transfer", false },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1min" },
                { "5m", "5min" },
                { "15m", "15min" },
                { "30m", "30min" },
                { "1h", "1hour" },
                { "4h", "4hour" },
                { "8h", "8hour" },
                { "12h", "12hour" },
                { "1d", "1day" },
                { "1w", "1week" },
            } },
            { "hostname", "bitbank.cc" },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/1294454/37808081-b87f2d9c-2e59-11e8-894d-c1900b7584fe.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "public", "https://public.{hostname}" },
                    { "private", "https://api.{hostname}" },
                    { "markets", "https://api.{hostname}" },
                } },
                { "www", "https://bitbank.cc/" },
                { "doc", "https://docs.bitbank.cc/" },
                { "fees", "https://bitbank.cc/docs/fees/" },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new List<object>() {"{pair}/ticker", "{pair}/depth", "{pair}/transactions", "{pair}/transactions/{yyyymmdd}", "{pair}/candlestick/{candletype}/{yyyymmdd}"} },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new List<object>() {"user/assets", "user/spot/order", "user/spot/active_orders", "user/spot/trade_history", "user/withdrawal_account"} },
                    { "post", new List<object>() {"user/spot/order", "user/spot/cancel_order", "user/spot/cancel_orders", "user/spot/orders_info", "user/request_withdrawal"} },
                } },
                { "markets", new Dictionary<string, object>() {
                    { "get", new List<object>() {"spot/pairs"} },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "exceptions", new Dictionary<string, object>() {
                { "20001", typeof(AuthenticationError) },
                { "20002", typeof(AuthenticationError) },
                { "20003", typeof(AuthenticationError) },
                { "20005", typeof(AuthenticationError) },
                { "20004", typeof(InvalidNonce) },
                { "40020", typeof(InvalidOrder) },
                { "40021", typeof(InvalidOrder) },
                { "40025", typeof(ExchangeError) },
                { "40013", typeof(OrderNotFound) },
                { "40014", typeof(OrderNotFound) },
                { "50008", typeof(PermissionDenied) },
                { "50009", typeof(OrderNotFound) },
                { "50010", typeof(OrderNotFound) },
                { "60001", typeof(InsufficientFunds) },
                { "60005", typeof(InvalidOrder) },
            } },
        });
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name bitbank#fetchMarkets
        * @description retrieves data on all markets for bitbank
        * @param {object} params extra parameters specific to the exchange api endpoint
        * @returns {[object]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.marketsGetSpotPairs(parameters);
        //
        //     {
        //       "success": 1,
        //       "data": {
        //         "pairs": [
        //           {
        //             "name": "btc_jpy",
        //             "base_asset": "btc",
        //             "quote_asset": "jpy",
        //             "maker_fee_rate_base": "0",
        //             "taker_fee_rate_base": "0",
        //             "maker_fee_rate_quote": "-0.0002",
        //             "taker_fee_rate_quote": "0.0012",
        //             "unit_amount": "0.0001",
        //             "limit_max_amount": "1000",
        //             "market_max_amount": "10",
        //             "market_allowance_rate": "0.2",
        //             "price_digits": 0,
        //             "amount_digits": 4,
        //             "is_enabled": true,
        //             "stop_order": false,
        //             "stop_order_and_cancel": false
        //           }
        //         ]
        //       }
        //     }
        //
        object data = this.safeValue(response, "data");
        object pairs = this.safeValue(data, "pairs", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(pairs)); postFixIncrement(ref i))
        {
            object entry = getValue(pairs, i);
            object id = this.safeString(entry, "name");
            object baseId = this.safeString(entry, "base_asset");
            object quoteId = this.safeString(entry, "quote_asset");
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            ((List<object>)result).Add(new Dictionary<string, object>() {
                { "id", id },
                { "symbol", add(add(bs, "/"), quote) },
                { "base", bs },
                { "quote", quote },
                { "settle", null },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", null },
                { "type", "spot" },
                { "spot", true },
                { "margin", false },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "active", this.safeValue(entry, "is_enabled") },
                { "contract", false },
                { "linear", null },
                { "inverse", null },
                { "taker", this.safeNumber(entry, "taker_fee_rate_quote") },
                { "maker", this.safeNumber(entry, "maker_fee_rate_quote") },
                { "contractSize", null },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", this.parseNumber(this.parsePrecision(this.safeString(entry, "amount_digits"))) },
                    { "price", this.parseNumber(this.parsePrecision(this.safeString(entry, "price_digits"))) },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber(entry, "unit_amount") },
                        { "max", this.safeNumber(entry, "limit_max_amount") },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "info", entry },
            });
        }
        return result;
    }

    public override object parseTicker(object ticker, object market = null)
    {
        object symbol = this.safeSymbol(null, market);
        object timestamp = this.safeInteger(ticker, "timestamp");
        object last = this.safeString(ticker, "last");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(ticker, "high") },
            { "low", this.safeString(ticker, "low") },
            { "bid", this.safeString(ticker, "buy") },
            { "bidVolume", null },
            { "ask", this.safeString(ticker, "sell") },
            { "askVolume", null },
            { "vwap", null },
            { "open", null },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", null },
            { "average", null },
            { "baseVolume", this.safeString(ticker, "vol") },
            { "quoteVolume", null },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bitbank#fetchTicker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} params extra parameters specific to the bitbank api endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "pair", getValue(market, "id") },
        };
        object response = await this.publicGetPairTicker(this.extend(request, parameters));
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseTicker(data, market);
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitbank#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int|undefined} limit the maximum amount of order book entries to return
        * @param {object} params extra parameters specific to the bitbank api endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "pair", getValue(market, "id") },
        };
        object response = await this.publicGetPairDepth(this.extend(request, parameters));
        object orderbook = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object timestamp = this.safeInteger(orderbook, "timestamp");
        return this.parseOrderBook(orderbook, getValue(market, "symbol"), timestamp);
    }

    public override object parseTrade(object trade, object market = null)
    {
        object timestamp = this.safeInteger(trade, "executed_at");
        market = this.safeMarket(null, market);
        object priceString = this.safeString(trade, "price");
        object amountString = this.safeString(trade, "amount");
        object id = this.safeString2(trade, "transaction_id", "trade_id");
        object takerOrMaker = this.safeString(trade, "maker_taker");
        object fee = null;
        object feeCostString = this.safeString(trade, "fee_amount_quote");
        if (isTrue(!isEqual(feeCostString, null)))
        {
            fee = new Dictionary<string, object>() {
                { "currency", getValue(market, "quote") },
                { "cost", feeCostString },
            };
        }
        object orderId = this.safeString(trade, "order_id");
        object type = this.safeString(trade, "type");
        object side = this.safeString(trade, "side");
        return this.safeTrade(new Dictionary<string, object>() {
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", getValue(market, "symbol") },
            { "id", id },
            { "order", orderId },
            { "type", type },
            { "side", side },
            { "takerOrMaker", takerOrMaker },
            { "price", priceString },
            { "amount", amountString },
            { "cost", null },
            { "fee", fee },
            { "info", trade },
        }, market);
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitbank#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int|undefined} since timestamp in ms of the earliest trade to fetch
        * @param {int|undefined} limit the maximum amount of trades to fetch
        * @param {object} params extra parameters specific to the bitbank api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/en/latest/manual.html?#public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "pair", getValue(market, "id") },
        };
        object response = await this.publicGetPairTransactions(this.extend(request, parameters));
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object trades = this.safeValue(data, "transactions", new List<object>() {});
        return this.parseTrades(trades, market, since, limit);
    }

    public async override Task<object> fetchTradingFees(object parameters = null)
    {
        /**
        * @method
        * @name bitbank#fetchTradingFees
        * @description fetch the trading fees for multiple markets
        * @param {object} params extra parameters specific to the bitbank api endpoint
        * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.marketsGetSpotPairs(parameters);
        //
        //     {
        //         success: '1',
        //         data: {
        //           pairs: [
        //             {
        //               name: 'btc_jpy',
        //               base_asset: 'btc',
        //               quote_asset: 'jpy',
        //               maker_fee_rate_base: '0',
        //               taker_fee_rate_base: '0',
        //               maker_fee_rate_quote: '-0.0002',
        //               taker_fee_rate_quote: '0.0012',
        //               unit_amount: '0.0001',
        //               limit_max_amount: '1000',
        //               market_max_amount: '10',
        //               market_allowance_rate: '0.2',
        //               price_digits: '0',
        //               amount_digits: '4',
        //               is_enabled: true,
        //               stop_order: false,
        //               stop_order_and_cancel: false
        //             },
        //             ...
        //           ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object pairs = this.safeValue(data, "pairs", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(pairs)); postFixIncrement(ref i))
        {
            object pair = getValue(pairs, i);
            object marketId = this.safeString(pair, "name");
            object market = this.safeMarket(marketId);
            object symbol = getValue(market, "symbol");
            ((Dictionary<string, object>)result)[(string)symbol] = new Dictionary<string, object>() {
                { "info", pair },
                { "symbol", symbol },
                { "maker", this.safeNumber(pair, "maker_fee_rate_quote") },
                { "taker", this.safeNumber(pair, "taker_fee_rate_quote") },
                { "percentage", true },
                { "tierBased", false },
            };
        }
        return result;
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     [
        //         "0.02501786",
        //         "0.02501786",
        //         "0.02501786",
        //         "0.02501786",
        //         "0.0000",
        //         1591488000000
        //     ]
        //
        return new List<object> {this.safeInteger(ohlcv, 5), this.safeNumber(ohlcv, 0), this.safeNumber(ohlcv, 1), this.safeNumber(ohlcv, 2), this.safeNumber(ohlcv, 3), this.safeNumber(ohlcv, 4)};
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitbank#fetchOHLCV
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int|undefined} since timestamp in ms of the earliest candle to fetch
        * @param {int|undefined} limit the maximum amount of candles to fetch
        * @param {object} params extra parameters specific to the bitbank api endpoint
        * @returns {[[int]]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(since, null)))
        {
            if (isTrue(isEqual(limit, null)))
            {
                limit = 1000; // it doesn't have any defaults, might return 200, might 2000 (i.e. https://public.bitbank.cc/btc_jpy/candlestick/4hour/2020)
            }
            object duration = this.parseTimeframe(timeframe);
            since = subtract(this.milliseconds(), multiply(multiply(duration, 1000), limit));
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "pair", getValue(market, "id") },
            { "candletype", this.safeString(this.timeframes, timeframe, timeframe) },
            { "yyyymmdd", this.yyyymmdd(since, "") },
        };
        object response = await this.publicGetPairCandlestickCandletypeYyyymmdd(this.extend(request, parameters));
        //
        //     {
        //         "success":1,
        //         "data":{
        //             "candlestick":[
        //                 {
        //                     "type":"5min",
        //                     "ohlcv":[
        //                         ["0.02501786","0.02501786","0.02501786","0.02501786","0.0000",1591488000000],
        //                         ["0.02501747","0.02501953","0.02501747","0.02501953","0.3017",1591488300000],
        //                         ["0.02501762","0.02501762","0.02500392","0.02500392","0.1500",1591488600000],
        //                     ]
        //                 }
        //             ],
        //             "timestamp":1591508668190
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object candlestick = this.safeValue(data, "candlestick", new List<object>() {});
        object first = this.safeValue(candlestick, 0, new Dictionary<string, object>() {});
        object ohlcv = this.safeValue(first, "ohlcv", new List<object>() {});
        return this.parseOHLCVs(ohlcv, market, timeframe, since, limit);
    }

    public virtual object parseBalance(object response)
    {
        object result = new Dictionary<string, object>() {
            { "info", response },
            { "timestamp", null },
            { "datetime", null },
        };
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object assets = this.safeValue(data, "assets", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(assets)); postFixIncrement(ref i))
        {
            object balance = getValue(assets, i);
            object currencyId = this.safeString(balance, "asset");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            ((Dictionary<string, object>)account)["free"] = this.safeString(balance, "free_amount");
            ((Dictionary<string, object>)account)["used"] = this.safeString(balance, "locked_amount");
            ((Dictionary<string, object>)account)["total"] = this.safeString(balance, "onhand_amount");
            ((Dictionary<string, object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name bitbank#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @param {object} params extra parameters specific to the bitbank api endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/en/latest/manual.html?#balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetUserAssets(parameters);
        //
        //     {
        //       "success": "1",
        //       "data": {
        //         "assets": [
        //           {
        //             "asset": "jpy",
        //             "amount_precision": "4",
        //             "onhand_amount": "0.0000",
        //             "locked_amount": "0.0000",
        //             "free_amount": "0.0000",
        //             "stop_deposit": false,
        //             "stop_withdrawal": false,
        //             "withdrawal_fee": {
        //               "threshold": "30000.0000",
        //               "under": "550.0000",
        //               "over": "770.0000"
        //             }
        //           },
        //           {
        //             "asset": "btc",
        //             "amount_precision": "8",
        //             "onhand_amount": "0.00000000",
        //             "locked_amount": "0.00000000",
        //             "free_amount": "0.00000000",
        //             "stop_deposit": false,
        //             "stop_withdrawal": false,
        //             "withdrawal_fee": "0.00060000"
        //           },
        //         ]
        //       }
        //     }
        //
        return this.parseBalance(response);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "UNFILLED", "open" },
            { "PARTIALLY_FILLED", "open" },
            { "FULLY_FILLED", "closed" },
            { "CANCELED_UNFILLED", "canceled" },
            { "CANCELED_PARTIALLY_FILLED", "canceled" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseOrder(object order, object market = null)
    {
        object id = this.safeString(order, "order_id");
        object marketId = this.safeString(order, "pair");
        market = this.safeMarket(marketId, market);
        object timestamp = this.safeInteger(order, "ordered_at");
        object price = this.safeString(order, "price");
        object amount = this.safeString(order, "start_amount");
        object filled = this.safeString(order, "executed_amount");
        object remaining = this.safeString(order, "remaining_amount");
        object average = this.safeString(order, "average_price");
        object status = this.parseOrderStatus(this.safeString(order, "status"));
        object type = this.safeStringLower(order, "type");
        object side = this.safeStringLower(order, "side");
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", id },
            { "clientOrderId", null },
            { "datetime", this.iso8601(timestamp) },
            { "timestamp", timestamp },
            { "lastTradeTimestamp", null },
            { "status", status },
            { "symbol", getValue(market, "symbol") },
            { "type", type },
            { "timeInForce", null },
            { "postOnly", null },
            { "side", side },
            { "price", price },
            { "stopPrice", null },
            { "triggerPrice", null },
            { "cost", null },
            { "average", average },
            { "amount", amount },
            { "filled", filled },
            { "remaining", remaining },
            { "trades", null },
            { "fee", null },
            { "info", order },
        }, market);
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name bitbank#createOrder
        * @description create a trade order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float|undefined} price the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} params extra parameters specific to the bitbank api endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "pair", getValue(market, "id") },
            { "amount", this.amountToPrecision(symbol, amount) },
            { "side", side },
            { "type", type },
        };
        if (isTrue(isEqual(type, "limit")))
        {
            ((Dictionary<string, object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        object response = await this.privatePostUserSpotOrder(this.extend(request, parameters));
        object data = this.safeValue(response, "data");
        return this.parseOrder(data, market);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitbank#cancelOrder
        * @description cancels an open order
        * @param {string} id order id
        * @param {string|undefined} symbol unified symbol of the market the order was made in
        * @param {object} params extra parameters specific to the bitbank api endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "order_id", id },
            { "pair", getValue(market, "id") },
        };
        object response = await this.privatePostUserSpotCancelOrder(this.extend(request, parameters));
        object data = this.safeValue(response, "data");
        return data;
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bitbank#fetchOrder
        * @description fetches information on an order made by the user
        * @param {string|undefined} symbol unified symbol of the market the order was made in
        * @param {object} params extra parameters specific to the bitbank api endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "order_id", id },
            { "pair", getValue(market, "id") },
        };
        object response = await this.privateGetUserSpotOrder(this.extend(request, parameters));
        object data = this.safeValue(response, "data");
        return this.parseOrder(data, market);
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitbank#fetchOpenOrders
        * @description fetch all unfilled currently open orders
        * @param {string|undefined} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch open orders for
        * @param {int|undefined} limit the maximum number of  open orders structures to retrieve
        * @param {object} params extra parameters specific to the bitbank api endpoint
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "pair", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["count"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["since"] = this.parseToInt(divide(since, 1000));
        }
        object response = await this.privateGetUserSpotActiveOrders(this.extend(request, parameters));
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object orders = this.safeValue(data, "orders", new List<object>() {});
        return this.parseOrders(orders, market, since, limit);
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bitbank#fetchMyTrades
        * @description fetch all trades made by the user
        * @param {string|undefined} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch trades for
        * @param {int|undefined} limit the maximum number of trades structures to retrieve
        * @param {object} params extra parameters specific to the bitbank api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((Dictionary<string, object>)request)["pair"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["count"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["since"] = this.parseToInt(divide(since, 1000));
        }
        object response = await this.privateGetUserSpotTradeHistory(this.extend(request, parameters));
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object trades = this.safeValue(data, "trades", new List<object>() {});
        return this.parseTrades(trades, market, since, limit);
    }

    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name bitbank#fetchDepositAddress
        * @description fetch the deposit address for a currency associated with this account
        * @param {string} code unified currency code
        * @param {object} params extra parameters specific to the bitbank api endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "asset", getValue(currency, "id") },
        };
        object response = await this.privateGetUserWithdrawalAccount(this.extend(request, parameters));
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        // Not sure about this if there could be more than one account...
        object accounts = this.safeValue(data, "accounts", new List<object>() {});
        object firstAccount = this.safeValue(accounts, 0, new Dictionary<string, object>() {});
        object address = this.safeString(firstAccount, "address");
        return new Dictionary<string, object>() {
            { "currency", currency },
            { "address", address },
            { "tag", null },
            { "network", null },
            { "info", response },
        };
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name bitbank#withdraw
        * @description make a withdrawal
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string|undefined} tag
        * @param {object} params extra parameters specific to the bitbank api endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((List<object>)tagparametersVariable)[0];
        parameters = ((List<object>)tagparametersVariable)[1];
        if (!isTrue((((Dictionary<string,object>)parameters).ContainsKey(toStringOrNull("uuid")))))
        {
            throw new ExchangeError ((string)add(this.id, " uuid is required for withdrawal")) ;
        }
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "asset", getValue(currency, "id") },
            { "amount", amount },
        };
        object response = await this.privatePostUserRequestWithdrawal(this.extend(request, parameters));
        //
        //     {
        //         "success": 1,
        //         "data": {
        //             "uuid": "string",
        //             "asset": "btc",
        //             "amount": 0,
        //             "account_uuid": "string",
        //             "fee": 0,
        //             "status": "DONE",
        //             "label": "string",
        //             "txid": "string",
        //             "address": "string",
        //             "requested_at": 0
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseTransaction(data, currency);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // withdraw
        //
        //     {
        //         "uuid": "string",
        //         "asset": "btc",
        //         "amount": 0,
        //         "account_uuid": "string",
        //         "fee": 0,
        //         "status": "DONE",
        //         "label": "string",
        //         "txid": "string",
        //         "address": "string",
        //         "requested_at": 0
        //     }
        //
        object txid = this.safeString(transaction, "txid");
        currency = this.safeCurrency(null, currency);
        return new Dictionary<string, object>() {
            { "id", txid },
            { "txid", txid },
            { "timestamp", null },
            { "datetime", null },
            { "network", null },
            { "addressFrom", null },
            { "address", null },
            { "addressTo", null },
            { "amount", null },
            { "type", null },
            { "currency", getValue(currency, "code") },
            { "status", null },
            { "updated", null },
            { "tagFrom", null },
            { "tag", null },
            { "tagTo", null },
            { "comment", null },
            { "fee", null },
            { "info", transaction },
        };
    }

    public override object nonce()
    {
        return this.milliseconds();
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object query = this.omit(parameters, this.extractParams(path));
        object url = add(this.implodeHostname(getValue(getValue(this.urls, "api"), api)), "/");
        if (isTrue(isTrue((isEqual(api, "public"))) || isTrue((isEqual(api, "markets")))))
        {
            url = add(url, this.implodeParams(path, parameters));
            if (isTrue(getArrayLength(new List<object>(((Dictionary<string,object>)query).Keys))))
            {
                url = add(url, add("?", this.urlencode(query)));
            }
        } else
        {
            this.checkRequiredCredentials();
            object nonce = ((object)this.nonce()).ToString();
            object auth = nonce;
            url = add(url, add(add(this.version, "/"), this.implodeParams(path, parameters)));
            if (isTrue(isEqual(method, "POST")))
            {
                body = this.json(query);
                auth = add(auth, body);
            } else
            {
                auth = add(auth, add(add(add("/", this.version), "/"), path));
                if (isTrue(getArrayLength(new List<object>(((Dictionary<string,object>)query).Keys))))
                {
                    query = this.urlencode(query);
                    url = add(url, add("?", query));
                    auth = add(auth, add("?", query));
                }
            }
            headers = new Dictionary<string, object>() {
                { "Content-Type", "application/json" },
                { "ACCESS-KEY", this.apiKey },
                { "ACCESS-NONCE", nonce },
                { "ACCESS-SIGNATURE", this.hmac(this.encode(auth), this.encode(this.secret), sha256) },
            };
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object httpCode, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;
        }
        object success = this.safeInteger(response, "success");
        object data = this.safeValue(response, "data");
        if (isTrue(!isTrue(success) || !isTrue(data)))
        {
            object errorMessages = new Dictionary<string, object>() {
                { "10000", "URL does not exist" },
                { "10001", "A system error occurred. Please contact support" },
                { "10002", "Invalid JSON format. Please check the contents of transmission" },
                { "10003", "A system error occurred. Please contact support" },
                { "10005", "A timeout error occurred. Please wait for a while and try again" },
                { "20001", "API authentication failed" },
                { "20002", "Illegal API key" },
                { "20003", "API key does not exist" },
                { "20004", "API Nonce does not exist" },
                { "20005", "API signature does not exist" },
                { "20011", "Two-step verification failed" },
                { "20014", "SMS authentication failed" },
                { "30001", "Please specify the order quantity" },
                { "30006", "Please specify the order ID" },
                { "30007", "Please specify the order ID array" },
                { "30009", "Please specify the stock" },
                { "30012", "Please specify the order price" },
                { "30013", "Trade Please specify either" },
                { "30015", "Please specify the order type" },
                { "30016", "Please specify asset name" },
                { "30019", "Please specify uuid" },
                { "30039", "Please specify the amount to be withdrawn" },
                { "40001", "The order quantity is invalid" },
                { "40006", "Count value is invalid" },
                { "40007", "End time is invalid" },
                { "40008", "end_id Value is invalid" },
                { "40009", "The from_id value is invalid" },
                { "40013", "The order ID is invalid" },
                { "40014", "The order ID array is invalid" },
                { "40015", "Too many specified orders" },
                { "40017", "Incorrect issue name" },
                { "40020", "The order price is invalid" },
                { "40021", "The trading classification is invalid" },
                { "40022", "Start date is invalid" },
                { "40024", "The order type is invalid" },
                { "40025", "Incorrect asset name" },
                { "40028", "uuid is invalid" },
                { "40048", "The amount of withdrawal is illegal" },
                { "50003", "Currently, this account is in a state where you can not perform the operation you specified. Please contact support" },
                { "50004", "Currently, this account is temporarily registered. Please try again after registering your account" },
                { "50005", "Currently, this account is locked. Please contact support" },
                { "50006", "Currently, this account is locked. Please contact support" },
                { "50008", "User identification has not been completed" },
                { "50009", "Your order does not exist" },
                { "50010", "Can not cancel specified order" },
                { "50011", "API not found" },
                { "60001", "The number of possessions is insufficient" },
                { "60002", "It exceeds the quantity upper limit of the tender buying order" },
                { "60003", "The specified quantity exceeds the limit" },
                { "60004", "The specified quantity is below the threshold" },
                { "60005", "The specified price is above the limit" },
                { "60006", "The specified price is below the lower limit" },
                { "70001", "A system error occurred. Please contact support" },
                { "70002", "A system error occurred. Please contact support" },
                { "70003", "A system error occurred. Please contact support" },
                { "70004", "We are unable to accept orders as the transaction is currently suspended" },
                { "70005", "Order can not be accepted because purchase order is currently suspended" },
                { "70006", "We can not accept orders because we are currently unsubscribed " },
                { "70009", "We are currently temporarily restricting orders to be carried out. Please use the limit order." },
                { "70010", "We are temporarily raising the minimum order quantity as the system load is now rising." },
            };
            object errorClasses = this.exceptions;
            object code = this.safeString(data, "code");
            object message = this.safeString(errorMessages, code, "Error");
            object ErrorClass = this.safeValue(errorClasses, code);
            if (isTrue(!isEqual(ErrorClass, null)))
            {
                throwDynamicException(getValue(errorClasses, code), message);
            } else
            {
                throw new ExchangeError ((string)add(add(this.id, " "), this.json(response))) ;
            }
        }
        return null;
    }
}
