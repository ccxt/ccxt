using ccxt;
namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

partial class bittrex : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "bittrex" },
            { "name", "Bittrex" },
            { "countries", new List<object>() {"US"} },
            { "version", "v3" },
            { "rateLimit", 1500 },
            { "certified", false },
            { "pro", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", false },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "addMargin", false },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "createDepositAddress", true },
                { "createMarketOrder", true },
                { "createOrder", true },
                { "createReduceOnlyOrder", false },
                { "createStopLimitOrder", true },
                { "createStopMarketOrder", true },
                { "createStopOrder", true },
                { "fetchBalance", true },
                { "fetchBidsAsks", true },
                { "fetchBorrowRate", false },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchBorrowRates", false },
                { "fetchBorrowRatesPerSymbol", false },
                { "fetchClosedOrders", true },
                { "fetchCurrencies", true },
                { "fetchDeposit", true },
                { "fetchDepositAddress", true },
                { "fetchDeposits", true },
                { "fetchFundingHistory", false },
                { "fetchFundingRate", false },
                { "fetchFundingRateHistory", false },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", false },
                { "fetchLeverage", false },
                { "fetchLeverageTiers", false },
                { "fetchMarginMode", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrderTrades", true },
                { "fetchPosition", false },
                { "fetchPositionMode", false },
                { "fetchPositions", false },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", true },
                { "fetchTradingFees", true },
                { "fetchTransactionFees", null },
                { "fetchTransactions", false },
                { "fetchWithdrawal", true },
                { "fetchWithdrawals", true },
                { "reduceMargin", false },
                { "setLeverage", false },
                { "setMarginMode", false },
                { "setPositionMode", false },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "MINUTE_1" },
                { "5m", "MINUTE_5" },
                { "1h", "HOUR_1" },
                { "1d", "DAY_1" },
            } },
            { "hostname", "bittrex.com" },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/51840849/87153921-edf53180-c2c0-11ea-96b9-f2a9a95a455b.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "public", "https://api.bittrex.com" },
                    { "private", "https://api.bittrex.com" },
                } },
                { "www", "https://bittrex.com" },
                { "doc", new List<object>() {"https://bittrex.github.io/api/v3"} },
                { "fees", new List<object>() {"https://bittrex.zendesk.com/hc/en-us/articles/115003684371-BITTREX-SERVICE-FEES-AND-WITHDRAWAL-LIMITATIONS", "https://bittrex.zendesk.com/hc/en-us/articles/115000199651-What-fees-does-Bittrex-charge-"} },
                { "referral", "https://bittrex.com/Account/Register?referralCode=1ZE-G0G-M3B" },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new List<object>() {"ping", "currencies", "currencies/{symbol}", "markets", "markets/tickers", "markets/summaries", "markets/{marketSymbol}", "markets/{marketSymbol}/summary", "markets/{marketSymbol}/orderbook", "markets/{marketSymbol}/trades", "markets/{marketSymbol}/ticker", "markets/{marketSymbol}/candles/{candleInterval}/recent", "markets/{marketSymbol}/candles/{candleInterval}/historical/{year}/{month}/{day}", "markets/{marketSymbol}/candles/{candleInterval}/historical/{year}/{month}", "markets/{marketSymbol}/candles/{candleInterval}/historical/{year}"} },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new List<object>() {"account", "account/fees/fiat", "account/fees/fiat/{currencySymbol}", "account/fees/trading", "account/fees/trading/{marketSymbol}", "account/volume", "account/permissions/markets", "account/permissions/markets/{marketSymbol}", "account/permissions/currencies", "account/permissions/currencies/{currencySymbol}", "addresses", "addresses/{currencySymbol}", "balances", "balances/{currencySymbol}", "deposits/open", "deposits/closed", "deposits/ByTxId/{txId}", "deposits/{depositId}", "executions", "executions/last-id", "executions/{executionId}", "orders/closed", "orders/open", "orders/{orderId}", "orders/{orderId}/executions", "ping", "subaccounts/{subaccountId}", "subaccounts", "subaccounts/withdrawals/open", "subaccounts/withdrawals/closed", "subaccounts/deposits/open", "subaccounts/deposits/closed", "withdrawals/open", "withdrawals/closed", "withdrawals/ByTxId/{txId}", "withdrawals/{withdrawalId}", "withdrawals/allowed-addresses", "conditional-orders/{conditionalOrderId}", "conditional-orders/closed", "conditional-orders/open", "transfers/sent", "transfers/received", "transfers/{transferId}", "funds-transfer-methods/{fundsTransferMethodId}"} },
                    { "post", new List<object>() {"addresses", "orders", "subaccounts", "withdrawals", "conditional-orders", "transfers", "batch"} },
                    { "delete", new List<object>() {"orders/open", "orders/{orderId}", "withdrawals/{withdrawalId}", "conditional-orders/{conditionalOrderId}"} },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "tierBased", true },
                    { "percentage", true },
                    { "maker", this.parseNumber("0.0075") },
                    { "taker", this.parseNumber("0.0075") },
                } },
                { "funding", new Dictionary<string, object>() {
                    { "tierBased", false },
                    { "percentage", false },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "BAD_REQUEST", typeof(BadRequest) },
                    { "STARTDATE_OUT_OF_RANGE", typeof(BadRequest) },
                    { "APISIGN_NOT_PROVIDED", typeof(AuthenticationError) },
                    { "APIKEY_INVALID", typeof(AuthenticationError) },
                    { "INVALID_SIGNATURE", typeof(AuthenticationError) },
                    { "INVALID_CURRENCY", typeof(ExchangeError) },
                    { "INVALID_PERMISSION", typeof(AuthenticationError) },
                    { "INSUFFICIENT_FUNDS", typeof(InsufficientFunds) },
                    { "INVALID_CEILING_MARKET_BUY", typeof(InvalidOrder) },
                    { "INVALID_FIAT_ACCOUNT", typeof(InvalidOrder) },
                    { "INVALID_ORDER_TYPE", typeof(InvalidOrder) },
                    { "QUANTITY_NOT_PROVIDED", typeof(InvalidOrder) },
                    { "MIN_TRADE_REQUIREMENT_NOT_MET", typeof(InvalidOrder) },
                    { "NOT_FOUND", typeof(OrderNotFound) },
                    { "ORDER_NOT_OPEN", typeof(OrderNotFound) },
                    { "INVALID_ORDER", typeof(InvalidOrder) },
                    { "UUID_INVALID", typeof(OrderNotFound) },
                    { "RATE_NOT_PROVIDED", typeof(InvalidOrder) },
                    { "INVALID_MARKET", typeof(BadSymbol) },
                    { "WHITELIST_VIOLATION_IP", typeof(PermissionDenied) },
                    { "DUST_TRADE_DISALLOWED_MIN_VALUE", typeof(InvalidOrder) },
                    { "RESTRICTED_MARKET", typeof(BadSymbol) },
                    { "We are down for scheduled maintenance, but weâ€™ll be back up shortly.", typeof(OnMaintenance) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "throttled", typeof(DDoSProtection) },
                    { "problem", typeof(ExchangeNotAvailable) },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "fetchTicker", new Dictionary<string, object>() {
                    { "method", "publicGetMarketsMarketSymbolTicker" },
                } },
                { "fetchTickers", new Dictionary<string, object>() {
                    { "method", "publicGetMarketsTickers" },
                } },
                { "fetchDeposits", new Dictionary<string, object>() {
                    { "status", "ok" },
                } },
                { "fetchWithdrawals", new Dictionary<string, object>() {
                    { "status", "ok" },
                } },
                { "parseOrderStatus", false },
                { "hasAlreadyAuthenticatedSuccessfully", false },
                { "subaccountId", null },
                { "fetchClosedOrdersFilterBySince", true },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "BIFI", "Bifrost Finance" },
                { "BTR", "BTRIPS" },
                { "GMT", "GMT Token" },
                { "MEME", "Memetic" },
                { "MER", "Mercury" },
                { "PROS", "Pros.Finance" },
                { "REPV2", "REP" },
                { "TON", "Tokamak Network" },
            } },
        });
    }

    public override object feeToPrecision(object symbol, object fee)
    {
        return this.decimalToPrecision(fee, TRUNCATE, getValue(getValue(getValue(this.markets, symbol), "precision"), "price"), this.precisionMode);
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name bittrex#fetchMarkets
        * @description retrieves data on all markets for bittrex
        * @param {object} params extra parameters specific to the exchange api endpoint
        * @returns {[object]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetMarkets(parameters);
        //
        //     [
        //         {
        //             "symbol":"LTC-BTC",
        //             "baseCurrencySymbol":"LTC",
        //             "quoteCurrencySymbol":"BTC",
        //             "minTradeSize":"0.01686767",
        //             "precision":8,
        //             "status":"ONLINE", // "OFFLINE"
        //             "createdAt":"2014-02-13T00:00:00Z"
        //         },
        //         {
        //             "symbol":"VDX-USDT",
        //             "baseCurrencySymbol":"VDX",
        //             "quoteCurrencySymbol":"USDT",
        //             "minTradeSize":"300.00000000",
        //             "precision":8,
        //             "status":"ONLINE", // "OFFLINE"
        //             "createdAt":"2019-05-23T00:41:21.843Z",
        //             "notice":"USDT has swapped to an ERC20-based token as of August 5, 2019."
        //         }
        //     ]
        //
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object market = getValue(response, i);
            object baseId = this.safeString(market, "baseCurrencySymbol");
            object quoteId = this.safeString(market, "quoteCurrencySymbol");
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            object status = this.safeString(market, "status");
            ((List<object>)result).Add(new Dictionary<string, object>() {
                { "id", this.safeString(market, "symbol") },
                { "symbol", add(add(bs, "/"), quote) },
                { "base", bs },
                { "quote", quote },
                { "settle", null },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", null },
                { "type", "spot" },
                { "spot", true },
                { "margin", false },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "active", (isEqual(status, "ONLINE")) },
                { "contract", false },
                { "linear", null },
                { "inverse", null },
                { "contractSize", null },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", this.parseNumber("1e-8") },
                    { "price", this.parseNumber(this.parsePrecision(this.safeString(market, "precision"))) },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "minTradeSize") },
                        { "max", null },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "info", market },
            });
        }
        return result;
    }

    public virtual object parseBalance(object response)
    {
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        object indexed = this.indexBy(response, "currencySymbol");
        object currencyIds = new List<object>(((Dictionary<string,object>)indexed).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(currencyIds)); postFixIncrement(ref i))
        {
            object currencyId = getValue(currencyIds, i);
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            object balance = getValue(indexed, currencyId);
            ((Dictionary<string, object>)account)["free"] = this.safeString(balance, "available");
            ((Dictionary<string, object>)account)["total"] = this.safeString(balance, "total");
            ((Dictionary<string, object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name bittrex#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @param {object} params extra parameters specific to the bittrex api endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/en/latest/manual.html?#balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetBalances(parameters);
        return this.parseBalance(response);
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bittrex#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int|undefined} limit the maximum amount of order book entries to return
        * @param {object} params extra parameters specific to the bittrex api endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "marketSymbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            if (isTrue(isTrue(isTrue((!isEqual(limit, 1))) && isTrue((!isEqual(limit, 25)))) && isTrue((!isEqual(limit, 500)))))
            {
                throw new BadRequest ((string)add(this.id, " fetchOrderBook() limit argument must be undefined, 1, 25 or 500, default is 25")) ;
            }
            ((Dictionary<string, object>)request)["depth"] = limit;
        }
        object response = await this.publicGetMarketsMarketSymbolOrderbook(this.extend(request, parameters));
        //
        //     {
        //         "bid":[
        //             {"quantity":"0.01250000","rate":"10718.56200003"},
        //             {"quantity":"0.10000000","rate":"10718.56200002"},
        //             {"quantity":"0.39648292","rate":"10718.56200001"},
        //         ],
        //         "ask":[
        //             {"quantity":"0.05100000","rate":"10724.30099631"},
        //             {"quantity":"0.10000000","rate":"10724.30099632"},
        //             {"quantity":"0.26000000","rate":"10724.30099634"},
        //         ]
        //     }
        //
        object sequence = this.safeInteger(this.last_response_headers, "Sequence");
        object orderbook = this.parseOrderBook(response, getValue(market, "symbol"), null, "bid", "ask", "rate", "quantity");
        ((Dictionary<string, object>)orderbook)["nonce"] = sequence;
        return orderbook;
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name bittrex#fetchCurrencies
        * @description fetches all available currencies on an exchange
        * @param {object} params extra parameters specific to the bittrex api endpoint
        * @returns {object} an associative dictionary of currencies
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetCurrencies(parameters);
        //
        //     [
        //         {
        //             "symbol":"1ST",
        //             "name":"Firstblood",
        //             "coinType":"ETH_CONTRACT",
        //             "status":"ONLINE",
        //             "minConfirmations":36,
        //             "notice":"",
        //             "txFee":"4.50000000",
        //             "logoUrl":"https://bittrexblobstorage.blob.core.windows.net/public/5685a7be-1edf-4ba0-a313-b5309bb204f8.png",
        //             "prohibitedIn":[],
        //             "baseAddress":"0xfbb1b73c4f0bda4f67dca266ce6ef42f520fbb98",
        //             "associatedTermsOfService":[]
        //         }
        //     ]
        //
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object currency = getValue(response, i);
            object id = this.safeString(currency, "symbol");
            object code = this.safeCurrencyCode(id);
            object precision = this.parseNumber("1e-8"); // default precision, seems exchange has same amount-precision across all pairs in UI too. todo: fix "magic constants"
            object fee = this.safeNumber(currency, "txFee"); // todo: redesign
            object isActive = this.safeString(currency, "status");
            ((Dictionary<string, object>)result)[(string)code] = new Dictionary<string, object>() {
                { "id", id },
                { "code", code },
                { "info", currency },
                { "type", this.safeString(currency, "coinType") },
                { "name", this.safeString(currency, "name") },
                { "active", (isEqual(isActive, "ONLINE")) },
                { "deposit", null },
                { "withdraw", null },
                { "fee", fee },
                { "precision", precision },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", precision },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", fee },
                        { "max", null },
                    } },
                } },
            };
        }
        return result;
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        // ticker
        //
        //     {
        //         "symbol":"ETH-BTC",
        //         "lastTradeRate":"0.03284496",
        //         "bidRate":"0.03284523",
        //         "askRate":"0.03286857"
        //     }
        //
        // summary
        //
        //     {
        //         "symbol":"ETH-BTC",
        //         "high":"0.03369528",
        //         "low":"0.03282442",
        //         "volume":"4307.83794556",
        //         "quoteVolume":"143.08608869",
        //         "percentChange":"0.79",
        //         "updatedAt":"2020-09-29T07:36:57.823Z"
        //     }
        //
        object timestamp = this.parse8601(this.safeString(ticker, "updatedAt"));
        object marketId = this.safeString(ticker, "symbol");
        market = this.safeMarket(marketId, market, "-");
        object symbol = getValue(market, "symbol");
        object percentage = this.safeString(ticker, "percentChange");
        object last = this.safeString(ticker, "lastTradeRate");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(ticker, "high") },
            { "low", this.safeString(ticker, "low") },
            { "bid", this.safeString(ticker, "bidRate") },
            { "bidVolume", null },
            { "ask", this.safeString(ticker, "askRate") },
            { "askVolume", null },
            { "vwap", null },
            { "open", null },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", percentage },
            { "average", null },
            { "baseVolume", this.safeString(ticker, "volume") },
            { "quoteVolume", this.safeString(ticker, "quoteVolume") },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name bittrex#fetchTickers
        * @description fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
        * @param {[string]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} params extra parameters specific to the bittrex api endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object options = this.safeValue(this.options, "fetchTickers", new Dictionary<string, object>() {});
        object defaultMethod = this.safeString(options, "method", "publicGetMarketsTickers");
        object method = this.safeString(parameters, "method", defaultMethod);
        parameters = this.omit(parameters, "method");
        object response = await ((Task<object>)callDynamically(this, method, new object[] { parameters }));
        //
        // publicGetMarketsTickers
        //
        //     [
        //         {
        //             "symbol":"4ART-BTC",
        //             "lastTradeRate":"0.00000210",
        //             "bidRate":"0.00000210",
        //             "askRate":"0.00000215"
        //         }
        //     ]
        //
        // publicGetMarketsSummaries
        //
        //     [
        //         {
        //             "symbol":"4ART-BTC",
        //             "high":"0.00000206",
        //             "low":"0.00000196",
        //             "volume":"14871.32000233",
        //             "quoteVolume":"0.02932756",
        //             "percentChange":"1.48",
        //             "updatedAt":"2020-09-29T07:34:32.757Z"
        //         }
        //     ]
        //
        object tickers = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object ticker = this.parseTicker(getValue(response, i));
            ((List<object>)tickers).Add(ticker);
        }
        return this.filterByArray(tickers, "symbol", symbols);
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bittrex#fetchTicker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} params extra parameters specific to the bittrex api endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "marketSymbol", getValue(market, "id") },
        };
        object options = this.safeValue(this.options, "fetchTicker", new Dictionary<string, object>() {});
        object defaultMethod = this.safeString(options, "method", "publicGetMarketsMarketSymbolTicker");
        object method = this.safeString(parameters, "method", defaultMethod);
        parameters = this.omit(parameters, "method");
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        // publicGetMarketsMarketSymbolTicker
        //
        //     {
        //         "symbol":"ETH-BTC",
        //         "lastTradeRate":"0.03284496",
        //         "bidRate":"0.03284523",
        //         "askRate":"0.03286857"
        //     }
        //
        //
        // publicGetMarketsMarketSymbolSummary
        //
        //     {
        //         "symbol":"ETH-BTC",
        //         "high":"0.03369528",
        //         "low":"0.03282442",
        //         "volume":"4307.83794556",
        //         "quoteVolume":"143.08608869",
        //         "percentChange":"0.79",
        //         "updatedAt":"2020-09-29T07:36:57.823Z"
        //     }
        //
        return this.parseTicker(response, market);
    }

    public async override Task<object> fetchBidsAsks(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name bittrex#fetchBidsAsks
        * @description fetches the bid and ask price and volume for multiple markets
        * @param {[string]|undefined} symbols unified symbols of the markets to fetch the bids and asks for, all markets are returned if not assigned
        * @param {object} params extra parameters specific to the binance api endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.publicGetMarketsTickers(parameters);
        //
        //     [
        //       {
        //         "symbol":"ETH-BTC",
        //         "lastTradeRate":"0.03284496",
        //         "bidRate":"0.03284523",
        //         "askRate":"0.03286857"
        //       }
        //     ]
        //
        return this.parseTickers(response, symbols);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // public fetchTrades
        //
        //      {
        //          "id": "8a614d4e-e455-45b0-9aac-502b0aeb433f",
        //          "executedAt": "2021-11-25T14:54:44.65Z",
        //          "quantity": "30.00000000",
        //          "rate": "1.72923112",
        //          "takerSide": "SELL"
        //      }
        //
        // private fetchOrderTrades
        //      {
        //          "id": "8a614d4e-e455-45b0-9aac-502b0aeb433f",
        //          "marketSymbol": "ADA-USDT",
        //          "executedAt": "2021-11-25T14:54:44.65Z",
        //          "quantity": "30.00000000",
        //          "rate": "1.72923112",
        //          "orderId": "6f7abf18-6901-4659-a48c-db0e88440ea4",
        //          "commission": "0.38907700",
        //          "isTaker":  true
        //      }
        //
        // private fetchMyTrades
        //      {
        //          "id":"7e6488c9-294f-4137-b0f2-9f86578186fe",
        //          "marketSymbol":"DOGE-USDT",
        //          "executedAt":"2022-08-12T21:27:37.92Z",
        //          "quantity":"100.00000000",
        //          "rate":"0.071584100000",
        //          "orderId":"2d53f11a-fb22-4820-b04d-80e5f48e6005",
        //          "commission":"0.05368807",
        //          "isTaker":true,
        //          "direction":"BUY"
        //      }
        //
        object timestamp = this.parse8601(this.safeString(trade, "executedAt"));
        object id = this.safeString(trade, "id");
        object order = this.safeString(trade, "orderId");
        object marketId = this.safeString(trade, "marketSymbol");
        market = this.safeMarket(marketId, market, "-");
        object priceString = this.safeString(trade, "rate");
        object amountString = this.safeString(trade, "quantity");
        object takerOrMaker = null;
        object side = this.safeStringLower2(trade, "takerSide", "direction");
        object isTaker = this.safeValue(trade, "isTaker");
        if (isTrue(!isEqual(isTaker, null)))
        {
            takerOrMaker = ((bool) isTrue(isTaker)) ? "taker" : "maker";
            if (!isTrue(isTaker))
            {
                if (isTrue(isEqual(side, "buy")))
                {
                    side = "sell";
                } else if (isTrue(isEqual(side, "sell")))
                {
                    side = "buy";
                }
            }
        }
        object fee = null;
        object feeCostString = this.safeString(trade, "commission");
        if (isTrue(!isEqual(feeCostString, null)))
        {
            fee = new Dictionary<string, object>() {
                { "cost", feeCostString },
                { "currency", getValue(market, "quote") },
            };
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", getValue(market, "symbol") },
            { "id", id },
            { "order", order },
            { "takerOrMaker", takerOrMaker },
            { "type", null },
            { "side", side },
            { "price", priceString },
            { "amount", amountString },
            { "cost", null },
            { "fee", fee },
        }, market);
    }

    public async override Task<object> fetchTime(object parameters = null)
    {
        /**
        * @method
        * @name bittrex#fetchTime
        * @description fetches the current integer timestamp in milliseconds from the exchange server
        * @param {object} params extra parameters specific to the bittrex api endpoint
        * @returns {int} the current integer timestamp in milliseconds from the exchange server
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetPing(parameters);
        //
        //     {
        //         "serverTime": 1594596023162
        //     }
        //
        return this.safeInteger(response, "serverTime");
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bittrex#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int|undefined} since timestamp in ms of the earliest trade to fetch
        * @param {int|undefined} limit the maximum amount of trades to fetch
        * @param {object} params extra parameters specific to the bittrex api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/en/latest/manual.html?#public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "marketSymbol", getValue(market, "id") },
        };
        object response = await this.publicGetMarketsMarketSymbolTrades(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "id":"9c5589db-42fb-436c-b105-5e2edcb95673",
        //             "executedAt":"2020-10-03T11:48:43.38Z",
        //             "quantity":"0.17939626",
        //             "rate":"0.03297952",
        //             "takerSide":"BUY"
        //         }
        //     ]
        //
        return this.parseTrades(response, market, since, limit);
    }

    public async override Task<object> fetchTradingFee(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name bittrex#fetchTradingFee
        * @description fetch the trading fees for a market
        * @param {string} symbol unified market symbol
        * @param {object} params extra parameters specific to the bittrex api endpoint
        * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "marketSymbol", getValue(market, "id") },
        };
        object response = await this.privateGetAccountFeesTradingMarketSymbol(this.extend(request, parameters));
        //
        //     {
        //         "marketSymbol":"1INCH-ETH",
        //         "makerRate":"0.00750000",
        //         "takerRate":"0.00750000"
        //     }
        //
        return this.parseTradingFee(response, market);
    }

    public async override Task<object> fetchTradingFees(object parameters = null)
    {
        /**
        * @method
        * @name bittrex#fetchTradingFees
        * @description fetch the trading fees for multiple markets
        * @param {object} params extra parameters specific to the bittrex api endpoint
        * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetAccountFeesTrading(parameters);
        //
        //     [
        //         {"marketSymbol":"1ECO-BTC","makerRate":"0.00750000","takerRate":"0.00750000"},
        //         {"marketSymbol":"1ECO-USDT","makerRate":"0.00750000","takerRate":"0.00750000"},
        //         {"marketSymbol":"1INCH-BTC","makerRate":"0.00750000","takerRate":"0.00750000"},
        //         {"marketSymbol":"1INCH-ETH","makerRate":"0.00750000","takerRate":"0.00750000"},
        //         {"marketSymbol":"1INCH-USD","makerRate":"0.00750000","takerRate":"0.00750000"},
        //     ]
        //
        return this.parseTradingFees(response);
    }

    public virtual object parseTradingFee(object fee, object market = null)
    {
        object marketId = this.safeString(fee, "marketSymbol");
        object maker = this.safeNumber(fee, "makerRate");
        object taker = this.safeNumber(fee, "takerRate");
        return new Dictionary<string, object>() {
            { "info", fee },
            { "symbol", this.safeSymbol(marketId, market) },
            { "maker", maker },
            { "taker", taker },
        };
    }

    public virtual object parseTradingFees(object fees)
    {
        object result = new Dictionary<string, object>() {
            { "info", fees },
        };
        for (object i = 0; isLessThan(i, getArrayLength(fees)); postFixIncrement(ref i))
        {
            object fee = this.parseTradingFee(getValue(fees, i));
            object symbol = getValue(fee, "symbol");
            ((Dictionary<string, object>)result)[(string)symbol] = fee;
        }
        return result;
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     {
        //         "startsAt":"2020-06-12T02:35:00Z",
        //         "open":"0.02493753",
        //         "high":"0.02493753",
        //         "low":"0.02493753",
        //         "close":"0.02493753",
        //         "volume":"0.09590123",
        //         "quoteVolume":"0.00239153"
        //     }
        //
        return new List<object> {this.parse8601(this.safeString(ohlcv, "startsAt")), this.safeNumber(ohlcv, "open"), this.safeNumber(ohlcv, "high"), this.safeNumber(ohlcv, "low"), this.safeNumber(ohlcv, "close"), this.safeNumber(ohlcv, "volume")};
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bittrex#fetchOHLCV
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int|undefined} since timestamp in ms of the earliest candle to fetch
        * @param {int|undefined} limit the maximum amount of candles to fetch
        * @param {object} params extra parameters specific to the bittrex api endpoint
        * @returns {[[int]]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object reverseId = add(add(getValue(market, "baseId"), "-"), getValue(market, "quoteId"));
        object request = new Dictionary<string, object>() {
            { "candleInterval", this.safeString(this.timeframes, timeframe, timeframe) },
            { "marketSymbol", reverseId },
        };
        object method = "publicGetMarketsMarketSymbolCandlesCandleIntervalRecent";
        if (isTrue(!isEqual(since, null)))
        {
            object now = this.milliseconds();
            object difference = Math.Abs((double)subtract(now, since));
            object sinceDate = this.yyyymmdd(since);
            object parts = ((string)sinceDate).Split((string)"-").ToList<object>();
            object sinceYear = this.safeInteger(parts, 0);
            object sinceMonth = this.safeInteger(parts, 1);
            object sinceDay = this.safeInteger(parts, 2);
            if (isTrue(isEqual(timeframe, "1d")))
            {
                // if the since argument is beyond one year into the past
                if (isTrue(isGreaterThan(difference, 31622400000)))
                {
                    method = "publicGetMarketsMarketSymbolCandlesCandleIntervalHistoricalYear";
                    ((Dictionary<string, object>)request)["year"] = sinceYear;
                }
            } else if (isTrue(isEqual(timeframe, "1h")))
            {
                // if the since argument is beyond 31 days into the past
                if (isTrue(isGreaterThan(difference, 2678400000)))
                {
                    method = "publicGetMarketsMarketSymbolCandlesCandleIntervalHistoricalYearMonth";
                    ((Dictionary<string, object>)request)["year"] = sinceYear;
                    ((Dictionary<string, object>)request)["month"] = sinceMonth;
                }
            } else
            {
                // if the since argument is beyond 1 day into the past
                if (isTrue(isGreaterThan(difference, 86400000)))
                {
                    method = "publicGetMarketsMarketSymbolCandlesCandleIntervalHistoricalYearMonthDay";
                    ((Dictionary<string, object>)request)["year"] = sinceYear;
                    ((Dictionary<string, object>)request)["month"] = sinceMonth;
                    ((Dictionary<string, object>)request)["day"] = sinceDay;
                }
            }
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        //     [
        //         {"startsAt":"2020-06-12T02:35:00Z","open":"0.02493753","high":"0.02493753","low":"0.02493753","close":"0.02493753","volume":"0.09590123","quoteVolume":"0.00239153"},
        //         {"startsAt":"2020-06-12T02:40:00Z","open":"0.02491874","high":"0.02491874","low":"0.02490970","close":"0.02490970","volume":"0.04515695","quoteVolume":"0.00112505"},
        //         {"startsAt":"2020-06-12T02:45:00Z","open":"0.02490753","high":"0.02493143","low":"0.02490753","close":"0.02493143","volume":"0.17769640","quoteVolume":"0.00442663"}
        //     ]
        //
        return this.parseOHLCVs(response, market, timeframe, since, limit);
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bittrex#fetchOpenOrders
        * @description fetch all unfilled currently open orders
        * @param {string|undefined} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch open orders for
        * @param {int|undefined} limit the maximum number of  open orders structures to retrieve
        * @param {object} params extra parameters specific to the bittrex api endpoint
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        object stop = this.safeValue(parameters, "stop");
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((Dictionary<string, object>)request)["marketSymbol"] = getValue(market, "id");
        }
        object method = "privateGetOrdersOpen";
        if (isTrue(stop))
        {
            method = "privateGetConditionalOrdersOpen";
        }
        object query = this.omit(parameters, "stop");
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        //
        // Spot
        //
        //     [
        //         {
        //             "id": "df6cf5ee-fc27-4b61-991a-cc94b6459ac9",
        //             "marketSymbol": "BTC-USDT",
        //             "direction": "BUY",
        //             "type": "LIMIT",
        //             "quantity": "0.00023277",
        //             "limit": "30000.00000000",
        //             "timeInForce": "GOOD_TIL_CANCELLED",
        //             "fillQuantity": "0.00000000",
        //             "commission": "0.00000000",
        //             "proceeds": "0.00000000",
        //             "status": "OPEN",
        //             "createdAt": "2022-04-20T02:33:53.16Z",
        //             "updatedAt": "2022-04-20T02:33:53.16Z"
        //         }
        //     ]
        //
        // Stop
        //
        //     [
        //         {
        //             "id": "f64f7c4f-295c-408b-9cbc-601981abf100",
        //             "marketSymbol": "BTC-USDT",
        //             "operand": "LTE",
        //             "triggerPrice": "0.10000000",
        //             "orderToCreate": {
        //                 "marketSymbol": "BTC-USDT",
        //                 "direction": "BUY",
        //                 "type": "LIMIT",
        //                 "quantity": "0.00020000",
        //                 "limit": "30000.00000000",
        //                 "timeInForce": "GOOD_TIL_CANCELLED"
        //             },
        //             "status": "OPEN",
        //             "createdAt": "2022-04-20T02:38:12.26Z",
        //             "updatedAt": "2022-04-20T02:38:12.26Z"
        //         }
        //     ]
        //
        return this.parseOrders(response, market, since, limit);
    }

    public async override Task<object> fetchOrderTrades(object id, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bittrex#fetchOrderTrades
        * @description fetch all the trades made from a single order
        * @param {string} id order id
        * @param {string|undefined} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch trades for
        * @param {int|undefined} limit the maximum number of trades to retrieve
        * @param {object} params extra parameters specific to the bittrex api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "orderId", id },
        };
        object response = await this.privateGetOrdersOrderIdExecutions(this.extend(request, parameters));
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        return this.parseTrades(response, market, since, limit);
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name bittrex#createOrder
        * @description create a trade order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float|undefined} price the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} params extra parameters specific to the bittrex api endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        // A ceiling order is a market or limit order that allows you to specify
        // the amount of quote currency you want to spend (or receive, if selling)
        // instead of the quantity of the market currency (e.g. buy $100 USD of BTC
        // at the current market BTC price)
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object uppercaseType = null;
        if (isTrue(!isEqual(type, null)))
        {
            uppercaseType = ((string)type).ToUpper();
        }
        object reverseId = add(add(getValue(market, "baseId"), "-"), getValue(market, "quoteId"));
        object stop = this.safeValue(parameters, "stop");
        object stopPrice = this.safeNumber2(parameters, "triggerPrice", "stopPrice");
        object request = new Dictionary<string, object>() {
            { "marketSymbol", reverseId },
        };
        object method = "privatePostOrders";
        if (isTrue(isTrue(stop) || isTrue(stopPrice)))
        {
            method = "privatePostConditionalOrders";
            object operand = this.safeString(parameters, "operand");
            if (isTrue(isEqual(operand, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " createOrder() requires an operand parameter")) ;
            }
            object trailingStopPercent = this.safeNumber(parameters, "trailingStopPercent");
            object orderToCreate = this.safeValue(parameters, "orderToCreate");
            object orderToCancel = this.safeValue(parameters, "orderToCancel");
            if (isTrue(isEqual(stopPrice, null)))
            {
                ((Dictionary<string, object>)request)["trailingStopPercent"] = this.priceToPrecision(symbol, trailingStopPercent);
            }
            if (isTrue(orderToCreate))
            {
                object isCeilingLimit = (isEqual(uppercaseType, "CEILING_LIMIT"));
                object isCeilingMarket = (isEqual(uppercaseType, "CEILING_MARKET"));
                object isCeilingOrder = isTrue(isCeilingLimit) || isTrue(isCeilingMarket);
                object ceiling = null;
                object limit = null;
                object timeInForce = null;
                if (isTrue(isCeilingOrder))
                {
                    object cost = null;
                    if (isTrue(isCeilingLimit))
                    {
                        limit = this.priceToPrecision(symbol, price);
                        cost = this.safeNumber2(parameters, "ceiling", "cost", amount);
                    } else if (isTrue(isCeilingMarket))
                    {
                        cost = this.safeNumber2(parameters, "ceiling", "cost");
                        if (isTrue(isEqual(cost, null)))
                        {
                            if (isTrue(isEqual(price, null)))
                            {
                                cost = amount;
                            } else
                            {
                                cost = multiply(amount, price);
                            }
                        }
                    }
                    ceiling = this.costToPrecision(symbol, cost);
                    timeInForce = "IMMEDIATE_OR_CANCEL";
                } else
                {
                    if (isTrue(isEqual(uppercaseType, "LIMIT")))
                    {
                        limit = this.priceToPrecision(symbol, price);
                        timeInForce = "GOOD_TIL_CANCELLED";
                    } else
                    {
                        timeInForce = "IMMEDIATE_OR_CANCEL";
                    }
                }
                ((Dictionary<string, object>)request)["orderToCreate"] = new Dictionary<string, object>() {
                    { "marketSymbol", reverseId },
                    { "direction", ((string)side).ToUpper() },
                    { "type", uppercaseType },
                    { "quantity", this.amountToPrecision(symbol, amount) },
                    { "ceiling", ceiling },
                    { "limit", limit },
                    { "timeInForce", timeInForce },
                    { "clientOrderId", this.safeString(parameters, "clientOrderId") },
                    { "useAwards", this.safeValue(parameters, "useAwards") },
                };
            }
            if (isTrue(orderToCancel))
            {
                ((Dictionary<string, object>)request)["orderToCancel"] = orderToCancel;
            }
            ((Dictionary<string, object>)request)["triggerPrice"] = this.priceToPrecision(symbol, stopPrice);
            ((Dictionary<string, object>)request)["operand"] = operand;
        } else
        {
            if (isTrue(!isEqual(side, null)))
            {
                ((Dictionary<string, object>)request)["direction"] = ((string)side).ToUpper();
            }
            ((Dictionary<string, object>)request)["type"] = uppercaseType;
            object isCeilingLimit = (isEqual(uppercaseType, "CEILING_LIMIT"));
            object isCeilingMarket = (isEqual(uppercaseType, "CEILING_MARKET"));
            object isCeilingOrder = isTrue(isCeilingLimit) || isTrue(isCeilingMarket);
            if (isTrue(isCeilingOrder))
            {
                object cost = null;
                if (isTrue(isCeilingLimit))
                {
                    ((Dictionary<string, object>)request)["limit"] = this.priceToPrecision(symbol, price);
                    cost = this.safeNumber2(parameters, "ceiling", "cost", amount);
                } else if (isTrue(isCeilingMarket))
                {
                    cost = this.safeNumber2(parameters, "ceiling", "cost");
                    if (isTrue(isEqual(cost, null)))
                    {
                        if (isTrue(isEqual(price, null)))
                        {
                            cost = amount;
                        } else
                        {
                            cost = multiply(amount, price);
                        }
                    }
                }
                ((Dictionary<string, object>)request)["ceiling"] = this.costToPrecision(symbol, cost);
                // bittrex only accepts IMMEDIATE_OR_CANCEL or FILL_OR_KILL for ceiling orders
                ((Dictionary<string, object>)request)["timeInForce"] = "IMMEDIATE_OR_CANCEL";
            } else
            {
                ((Dictionary<string, object>)request)["quantity"] = this.amountToPrecision(symbol, amount);
                if (isTrue(isEqual(uppercaseType, "LIMIT")))
                {
                    ((Dictionary<string, object>)request)["limit"] = this.priceToPrecision(symbol, price);
                    ((Dictionary<string, object>)request)["timeInForce"] = "GOOD_TIL_CANCELLED";
                } else
                {
                    // bittrex does not allow GOOD_TIL_CANCELLED for market orders
                    ((Dictionary<string, object>)request)["timeInForce"] = "IMMEDIATE_OR_CANCEL";
                }
            }
        }
        object query = this.omit(parameters, new List<object>() {"stop", "stopPrice", "ceiling", "cost", "operand", "trailingStopPercent", "orderToCreate", "orderToCancel"});
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        //
        // Spot
        //
        //     {
        //         id: 'f03d5e98-b5ac-48fb-8647-dd4db828a297',
        //         marketSymbol: 'BTC-USDT',
        //         direction: 'SELL',
        //         type: 'LIMIT',
        //         quantity: '0.01',
        //         limit: '6000',
        //         timeInForce: 'GOOD_TIL_CANCELLED',
        //         fillQuantity: '0.00000000',
        //         commission: '0.00000000',
        //         proceeds: '0.00000000',
        //         status: 'OPEN',
        //         createdAt: '2020-03-18T02:37:33.42Z',
        //         updatedAt: '2020-03-18T02:37:33.42Z'
        //       }
        //
        // Stop
        //
        //     {
        //         "id": "9791fe52-a3e5-4ac3-ae03-e327b2993571",
        //         "marketSymbol": "BTC-USDT",
        //         "operand": "LTE",
        //         "triggerPrice": "0.1",
        //         "orderToCreate": {
        //             "marketSymbol": "BTC-USDT",
        //             "direction": "BUY",
        //             "type": "LIMIT",
        //             "quantity": "0.0002",
        //             "limit": "30000",
        //             "timeInForce": "GOOD_TIL_CANCELLED"
        //         },
        //         "status": "OPEN",
        //         "createdAt": "2022-04-19T21:02:14.17Z",
        //         "updatedAt": "2022-04-19T21:02:14.17Z"
        //     }
        //
        return this.parseOrder(response, market);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bittrex#cancelOrder
        * @description cancels an open order
        * @param {string} id order id
        * @param {string|undefined} symbol unified symbol of the market the order was made in
        * @param {object} params extra parameters specific to the bittrex api endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object stop = this.safeValue(parameters, "stop");
        object request = new Dictionary<string, object>() {};
        object method = null;
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        if (isTrue(stop))
        {
            method = "privateDeleteConditionalOrdersConditionalOrderId";
            request = new Dictionary<string, object>() {
                { "conditionalOrderId", id },
            };
        } else
        {
            method = "privateDeleteOrdersOrderId";
            request = new Dictionary<string, object>() {
                { "orderId", id },
            };
        }
        object query = this.omit(parameters, "stop");
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        //
        // Spot
        //
        //     [
        //         {
        //             "id": "df6cf5ee-fc27-4b61-991a-cc94b6459ac9",
        //             "marketSymbol": "BTC-USDT",
        //             "direction": "BUY",
        //             "type": "LIMIT",
        //             "quantity": "0.00023277",
        //             "limit": "30000.00000000",
        //             "timeInForce": "GOOD_TIL_CANCELLED",
        //             "fillQuantity": "0.00000000",
        //             "commission": "0.00000000",
        //             "proceeds": "0.00000000",
        //             "status": "CANCELLED",
        //             "createdAt": "2022-04-20T02:33:53.16Z",
        //             "updatedAt": "2022-04-20T02:33:53.16Z"
        //         }
        //     ]
        //
        // Stop
        //
        //     [
        //         {
        //             "id": "f64f7c4f-295c-408b-9cbc-601981abf100",
        //             "marketSymbol": "BTC-USDT",
        //             "operand": "LTE",
        //             "triggerPrice": "0.10000000",
        //             "orderToCreate": {
        //                 "marketSymbol": "BTC-USDT",
        //                 "direction": "BUY",
        //                 "type": "LIMIT",
        //                 "quantity": "0.00020000",
        //                 "limit": "30000.00000000",
        //                 "timeInForce": "GOOD_TIL_CANCELLED"
        //             },
        //             "status": "CANCELLED",
        //             "createdAt": "2022-04-20T02:38:12.26Z",
        //             "updatedAt": "2022-04-20T02:38:12.26Z"
        //             "closedAt": "2022-04-20T03:47:24.69Z"
        //         }
        //     ]
        //
        return this.extend(this.parseOrder(response, market), new Dictionary<string, object>() {
            { "id", id },
            { "info", response },
            { "status", "canceled" },
        });
    }

    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bittrex#cancelAllOrders
        * @description cancel all open orders
        * @param {string|undefined} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
        * @param {object} params extra parameters specific to the bittrex api endpoint
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((Dictionary<string, object>)request)["marketSymbol"] = getValue(market, "id");
        }
        object response = await this.privateDeleteOrdersOpen(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "id":"66582be0-5337-4d8c-b212-c356dd525801",
        //             "statusCode":"SUCCESS",
        //             "result":{
        //                 "id":"66582be0-5337-4d8c-b212-c356dd525801",
        //                 "marketSymbol":"BTC-USDT",
        //                 "direction":"BUY",
        //                 "type":"LIMIT",
        //                 "quantity":"0.01000000",
        //                 "limit":"3000.00000000",
        //                 "timeInForce":"GOOD_TIL_CANCELLED",
        //                 "fillQuantity":"0.00000000",
        //                 "commission":"0.00000000",
        //                 "proceeds":"0.00000000",
        //                 "status":"CLOSED",
        //                 "createdAt":"2020-10-06T12:31:53.39Z",
        //                 "updatedAt":"2020-10-06T12:54:28.8Z",
        //                 "closedAt":"2020-10-06T12:54:28.8Z"
        //             }
        //         }
        //     ]
        //
        object orders = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object result = this.safeValue(getValue(response, i), "result", new Dictionary<string, object>() {});
            ((List<object>)orders).Add(result);
        }
        return this.parseOrders(orders, market);
    }

    public async virtual Task<object> fetchDeposit(object id, object code = null, object parameters = null)
    {
        /**
        * @method
        * @name bittrex#fetchDeposit
        * @description fetch data on a currency deposit via the deposit id
        * @param {string} id deposit id
        * @param {string|undefined} code filter by currency code
        * @param {object} params extra parameters specific to the bittrex api endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "txId", id },
        };
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        object response = await this.privateGetDepositsByTxIdTxId(this.extend(request, parameters));
        object transactions = this.parseTransactions(response, currency, null, null);
        return this.safeValue(transactions, 0);
    }

    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bittrex#fetchDeposits
        * @description fetch all deposits made to an account
        * @param {string|undefined} code unified currency code
        * @param {int|undefined} since the earliest time in ms to fetch deposits for
        * @param {int|undefined} limit the maximum number of deposits structures to retrieve
        * @param {object} params extra parameters specific to the bittrex api endpoint
        * @param {int|undefined} params.endDate Filters out result after this timestamp. Uses ISO-8602 format.
        * @param {string|undefined} params.nextPageToken The unique identifier of the item that the resulting query result should start after, in the sort order of the given endpoint. Used for traversing a paginated set in the forward direction.
        * @param {string|undefined} params.previousPageToken The unique identifier of the item that the resulting query result should end before, in the sort order of the given endpoint. Used for traversing a paginated set in the reverse direction.
        * @returns {[object]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        // https://support.bittrex.com/hc/en-us/articles/115003723911
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((Dictionary<string, object>)request)["currencySymbol"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            object startDate = multiply(this.parseToInt(divide(since, 1000)), 1000);
            ((Dictionary<string, object>)request)["startDate"] = this.iso8601(startDate);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["pageSize"] = limit;
        }
        object method = null;
        object options = this.safeValue(this.options, "fetchDeposits", new Dictionary<string, object>() {});
        object defaultStatus = this.safeString(options, "status", "ok");
        object status = this.safeString(parameters, "status", defaultStatus);
        if (isTrue(isEqual(status, "pending")))
        {
            method = "privateGetDepositsOpen";
        } else
        {
            method = "privateGetDepositsClosed";
        }
        parameters = this.omit(parameters, "status");
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        // we cannot filter by `since` timestamp, as it isn't set by Bittrex
        // see https://github.com/ccxt/ccxt/issues/4067
        // return this.parseTransactions (response, currency, since, limit);
        return this.parseTransactions(response, currency, null, limit);
    }

    public async virtual Task<object> fetchPendingDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bittrex#fetchPendingDeposits
        * @description fetch all pending deposits made from an account
        * @param {string|undefined} code unified currency code
        * @param {int|undefined} since the earliest time in ms to fetch withdrawals for
        * @param {int|undefined} limit the maximum number of withdrawals structures to retrieve
        * @param {object} params extra parameters specific to the bittrex api endpoint
        * @param {int|undefined} params.endDate Filters out result after this timestamp. Uses ISO-8602 format.
        * @param {string|undefined} params.nextPageToken The unique identifier of the item that the resulting query result should start after, in the sort order of the given endpoint. Used for traversing a paginated set in the forward direction.
        * @param {string|undefined} params.previousPageToken The unique identifier of the item that the resulting query result should end before, in the sort order of the given endpoint. Used for traversing a paginated set in the reverse direction.
        * @returns {[object]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        return this.fetchDeposits(code, since, limit, this.extend(parameters, new Dictionary<string, object>() {
            { "status", "pending" },
        }));
    }

    public async virtual Task<object> fetchWithdrawal(object id, object code = null, object parameters = null)
    {
        /**
        * @method
        * @name bittrex#fetchWithdrawal
        * @description fetch data on a currency withdrawal via the withdrawal id
        * @param {string} id withdrawal id
        * @param {string|undefined} code filter by currency code
        * @param {object} params extra parameters specific to the bittrex api endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "txId", id },
        };
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        object response = await this.privateGetWithdrawalsByTxIdTxId(this.extend(request, parameters));
        object transactions = this.parseTransactions(response, currency, null, null);
        return this.safeValue(transactions, 0);
    }

    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bittrex#fetchWithdrawals
        * @description fetch all withdrawals made from an account
        * @param {string|undefined} code unified currency code
        * @param {int|undefined} since the earliest time in ms to fetch withdrawals for
        * @param {int|undefined} limit the maximum number of withdrawals structures to retrieve
        * @param {object} params extra parameters specific to the bittrex api endpoint
        * @param {int|undefined} params.endDate Filters out result after this timestamp. Uses ISO-8602 format.
        * @param {string|undefined} params.nextPageToken The unique identifier of the item that the resulting query result should start after, in the sort order of the given endpoint. Used for traversing a paginated set in the forward direction.
        * @param {string|undefined} params.previousPageToken The unique identifier of the item that the resulting query result should end before, in the sort order of the given endpoint. Used for traversing a paginated set in the reverse direction.
        * @returns {[object]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        // https://support.bittrex.com/hc/en-us/articles/115003723911
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((Dictionary<string, object>)request)["currencySymbol"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            object startDate = multiply(this.parseToInt(divide(since, 1000)), 1000);
            ((Dictionary<string, object>)request)["startDate"] = this.iso8601(startDate);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["pageSize"] = limit;
        }
        object method = null;
        object options = this.safeValue(this.options, "fetchWithdrawals", new Dictionary<string, object>() {});
        object defaultStatus = this.safeString(options, "status", "ok");
        object status = this.safeString(parameters, "status", defaultStatus);
        if (isTrue(isEqual(status, "pending")))
        {
            method = "privateGetWithdrawalsOpen";
        } else
        {
            method = "privateGetWithdrawalsClosed";
        }
        parameters = this.omit(parameters, "status");
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        return this.parseTransactions(response, currency, since, limit);
    }

    public async virtual Task<object> fetchPendingWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bittrex#fetchPendingWithdrawals
        * @description fetch all pending withdrawals made from an account
        * @param {string|undefined} code unified currency code
        * @param {int|undefined} since the earliest time in ms to fetch withdrawals for
        * @param {int|undefined} limit the maximum number of withdrawals structures to retrieve
        * @param {object} params extra parameters specific to the bittrex api endpoint
        * @param {int|undefined} params.endDate Filters out result after this timestamp. Uses ISO-8602 format.
        * @param {string|undefined} params.nextPageToken The unique identifier of the item that the resulting query result should start after, in the sort order of the given endpoint. Used for traversing a paginated set in the forward direction.
        * @param {string|undefined} params.previousPageToken The unique identifier of the item that the resulting query result should end before, in the sort order of the given endpoint. Used for traversing a paginated set in the reverse direction.
        * @returns {[object]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        return this.fetchWithdrawals(code, since, limit, this.extend(parameters, new Dictionary<string, object>() {
            { "status", "pending" },
        }));
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // fetchDeposits
        //
        //      {
        //          "id": "77f2e4f0-a33d-4285-9140-ed5b20533a17",
        //          "currencySymbol": "ETH",
        //          "quantity": "0.36487773",
        //          "cryptoAddress": "0xeee7cff0f587706acdddfc1ff65968936fcf621e",
        //          "txId": "0x059fd3279452a245b308a944a0ee341ff9d17652a8a1bc663e6006282128c782",
        //          "confirmations": 44,
        //          "updatedAt": "2017-12-28T13:57:42.753Z",
        //          "completedAt": "2017-12-28T13:57:42.753Z",
        //          "status": "COMPLETED",
        //          "source": "BLOCKCHAIN"
        //      }
        //
        // fetchWithdrawals
        //
        //      {
        //          "id":"d20d556c-59ac-4480-95d8-268f8d4adedb",
        //          "currencySymbol":"OMG",
        //          "quantity":"2.67000000",
        //          "cryptoAddress":"0xa7daa9acdb41c0c476966ee23d388d6f2a1448cd",
        //          "cryptoAddressTag":"",
        //          "txCost":"0.10000000",
        //          "txId":"0xb54b8c5fb889aa9f9154e013cc5dd67b3048a3e0ae58ba845868225cda154bf5",
        //          "status":"COMPLETED",
        //          "createdAt":"2017-12-16T20:46:22.5Z",
        //          "completedAt":"2017-12-16T20:48:03.887Z",
        //          "target":"BLOCKCHAIN"
        //      }
        //
        // withdraw
        //
        //     {
        //         "currencySymbol": "string",
        //         "quantity": "number (double)",
        //         "cryptoAddress": "string",
        //         "cryptoAddressTag": "string",
        //         "fundsTransferMethodId": "string (uuid)",
        //         "clientWithdrawalId": "string (uuid)"
        //     }
        //
        object id = this.safeString2(transaction, "id", "clientWithdrawalId");
        object amount = this.safeNumber(transaction, "quantity");
        object address = this.safeString(transaction, "cryptoAddress");
        object addressTo = null;
        object addressFrom = null;
        object isDeposit = isEqual(this.safeString(transaction, "source"), "BLOCKCHAIN");
        if (isTrue(isDeposit))
        {
            addressFrom = address;
        } else
        {
            addressTo = address;
        }
        object txid = this.safeString(transaction, "txId");
        object updated = this.parse8601(this.safeString(transaction, "updatedAt"));
        object opened = this.parse8601(this.safeString(transaction, "createdAt"));
        object timestamp = ((bool) isTrue(opened)) ? opened : updated;
        object type = ((bool) isTrue((isEqual(opened, null)))) ? "deposit" : "withdrawal";
        object currencyId = this.safeString(transaction, "currencySymbol");
        object code = this.safeCurrencyCode(currencyId, currency);
        object status = "pending";
        if (isTrue(isEqual(type, "deposit")))
        {
            //
            // deposits numConfirmations never reach the minConfirmations number
            // we set all of them to 'ok', otherwise they'd all be 'pending'
            //
            //     const numConfirmations = this.safeInteger (transaction, 'Confirmations', 0);
            //     const minConfirmations = this.safeInteger (currency['info'], 'MinConfirmation');
            //     if (numConfirmations >= minConfirmations) {
            //         status = 'ok';
            //     }
            //
            status = "ok";
        } else
        {
            object responseStatus = this.safeString(transaction, "status");
            if (isTrue(isEqual(responseStatus, "ERROR_INVALID_ADDRESS")))
            {
                status = "failed";
            } else if (isTrue(isEqual(responseStatus, "CANCELLED")))
            {
                status = "canceled";
            } else if (isTrue(isEqual(responseStatus, "PENDING")))
            {
                status = "pending";
            } else if (isTrue(isEqual(responseStatus, "COMPLETED")))
            {
                status = "ok";
            } else if (isTrue(isTrue(isEqual(responseStatus, "AUTHORIZED")) && isTrue((!isEqual(txid, null)))))
            {
                status = "ok";
            }
        }
        object feeCost = this.safeNumber(transaction, "txCost");
        if (isTrue(isEqual(feeCost, null)))
        {
            if (isTrue(isEqual(type, "deposit")))
            {
                // according to https://support.bittrex.com/hc/en-us/articles/115000199651-What-fees-does-Bittrex-charge-
                feeCost = 0;
            }
        }
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", id },
            { "currency", code },
            { "amount", amount },
            { "network", null },
            { "address", address },
            { "addressTo", addressTo },
            { "addressFrom", addressFrom },
            { "tag", null },
            { "tagTo", null },
            { "tagFrom", null },
            { "status", status },
            { "type", type },
            { "updated", updated },
            { "txid", txid },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "fee", new Dictionary<string, object>() {
                { "currency", code },
                { "cost", feeCost },
            } },
        };
    }

    public virtual object parseTimeInForce(object timeInForce)
    {
        object timeInForces = new Dictionary<string, object>() {
            { "GOOD_TIL_CANCELLED", "GTC" },
            { "IMMEDIATE_OR_CANCEL", "IOC" },
            { "FILL_OR_KILL", "FOK" },
            { "POST_ONLY_GOOD_TIL_CANCELLED", "PO" },
        };
        return this.safeString(timeInForces, timeInForce, timeInForce);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // Spot createOrder, fetchOpenOrders, fetchClosedOrders, fetchOrder, cancelOrder
        //
        //     {
        //         id: '1be35109-b763-44ce-b6ea-05b6b0735c0c',
        //         marketSymbol: 'LTC-ETH',
        //         direction: 'BUY',
        //         type: 'LIMIT',
        //         quantity: '0.50000000',
        //         limit: '0.17846699',
        //         timeInForce: 'GOOD_TIL_CANCELLED',
        //         clientOrderId: 'ff156d39-fe01-44ca-8f21-b0afa19ef228',
        //         fillQuantity: '0.50000000',
        //         commission: '0.00022286',
        //         proceeds: '0.08914915',
        //         status: 'CLOSED',
        //         createdAt: '2018-06-23T13:14:28.613Z',
        //         updatedAt: '2018-06-23T13:14:30.19Z',
        //         closedAt: '2018-06-23T13:14:30.19Z'
        //     }
        //
        // Stop createOrder, fetchOpenOrders, fetchClosedOrders, fetchOrder, cancelOrder
        //
        //     {
        //         "id": "9791fe52-a3e5-4ac3-ae03-e327b2993571",
        //         "marketSymbol": "BTC-USDT",
        //         "operand": "LTE",
        //         "triggerPrice": "0.1",
        //         "orderToCreate": {
        //             "marketSymbol": "BTC-USDT",
        //             "direction": "BUY",
        //             "type": "LIMIT",
        //             "quantity": "0.0002",
        //             "limit": "30000",
        //             "timeInForce": "GOOD_TIL_CANCELLED"
        //         },
        //         "status": "OPEN",
        //         "createdAt": "2022-04-19T21:02:14.17Z",
        //         "updatedAt": "2022-04-19T21:02:14.17Z",
        //         "closedAt": "2022-04-20T03:47:24.69Z"
        //     }
        //
        object marketSymbol = this.safeString(order, "marketSymbol");
        market = this.safeMarket(marketSymbol, market, "-");
        object symbol = getValue(market, "symbol");
        object feeCurrency = getValue(market, "quote");
        object createdAt = this.safeString(order, "createdAt");
        object updatedAt = this.safeString(order, "updatedAt");
        object closedAt = this.safeString(order, "closedAt");
        object clientOrderId = this.safeString(order, "clientOrderId");
        object lastTradeTimestamp = null;
        if (isTrue(!isEqual(closedAt, null)))
        {
            lastTradeTimestamp = this.parse8601(closedAt);
        } else if (isTrue(updatedAt))
        {
            lastTradeTimestamp = this.parse8601(updatedAt);
        }
        object timestamp = this.parse8601(createdAt);
        object direction = this.safeStringLower(order, "direction");
        if (isTrue(isEqual(direction, null)))
        {
            object conditionalOrder = this.safeValue(order, "orderToCreate");
            if (isTrue(isEqual(conditionalOrder, null)))
            {
                conditionalOrder = this.safeValue(order, "orderToCancel");
            }
            direction = this.safeStringLower(conditionalOrder, "direction");
        }
        object type = this.safeStringLower(order, "type");
        if (isTrue(isEqual(type, null)))
        {
            object conditionalOrder = this.safeValue(order, "orderToCreate");
            if (isTrue(isEqual(conditionalOrder, null)))
            {
                conditionalOrder = this.safeValue(order, "orderToCancel");
            }
            type = this.safeStringLower(conditionalOrder, "type");
        }
        object quantity = this.safeString(order, "quantity");
        if (isTrue(isEqual(quantity, null)))
        {
            object conditionalOrder = this.safeValue(order, "orderToCreate");
            if (isTrue(isEqual(conditionalOrder, null)))
            {
                conditionalOrder = this.safeValue(order, "orderToCancel");
            }
            quantity = this.safeString(conditionalOrder, "quantity");
        }
        object limit = this.safeString(order, "limit");
        if (isTrue(isEqual(limit, null)))
        {
            object conditionalOrder = this.safeValue(order, "orderToCreate");
            if (isTrue(isEqual(conditionalOrder, null)))
            {
                conditionalOrder = this.safeValue(order, "orderToCancel");
            }
            limit = this.safeString(conditionalOrder, "limit");
        }
        object timeInForce = this.parseTimeInForce(this.safeString(order, "timeInForce"));
        if (isTrue(isEqual(timeInForce, null)))
        {
            object conditionalOrder = this.safeValue(order, "orderToCreate");
            if (isTrue(isEqual(conditionalOrder, null)))
            {
                conditionalOrder = this.safeValue(order, "orderToCancel");
            }
            timeInForce = this.parseTimeInForce(this.safeString(conditionalOrder, "timeInForce"));
        }
        object fillQuantity = this.safeString(order, "fillQuantity");
        object commission = this.safeNumber(order, "commission");
        object proceeds = this.safeString(order, "proceeds");
        object status = this.safeStringLower(order, "status");
        object postOnly = (isEqual(timeInForce, "PO"));
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", this.safeString(order, "id") },
            { "clientOrderId", clientOrderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", lastTradeTimestamp },
            { "symbol", symbol },
            { "type", type },
            { "timeInForce", timeInForce },
            { "postOnly", postOnly },
            { "side", direction },
            { "price", limit },
            { "stopPrice", this.safeString(order, "triggerPrice") },
            { "triggerPrice", this.safeString(order, "triggerPrice") },
            { "cost", proceeds },
            { "average", null },
            { "amount", quantity },
            { "filled", fillQuantity },
            { "remaining", null },
            { "status", status },
            { "fee", new Dictionary<string, object>() {
                { "cost", commission },
                { "currency", feeCurrency },
            } },
            { "info", order },
            { "trades", null },
        }, market);
    }

    public override object parseOrders(object orders, object market = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(getValue(this.options, "fetchClosedOrdersFilterBySince")))
        {
            return base.parseOrders(orders, market, since, limit, parameters);
        } else
        {
            return base.parseOrders(orders, market, null, limit, parameters);
        }
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "CLOSED", "closed" },
            { "OPEN", "open" },
            { "CANCELLED", "canceled" },
            { "CANCELED", "canceled" },
        };
        return this.safeString(statuses, status, status);
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name bittrex#fetchOrder
        * @description fetches information on an order made by the user
        * @param {string|undefined} symbol unified symbol of the market the order was made in
        * @param {object} params extra parameters specific to the bittrex api endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object stop = this.safeValue(parameters, "stop");
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object response = null;
        object method = null;
        try
        {
            object request = new Dictionary<string, object>() {};
            if (isTrue(stop))
            {
                method = "privateGetConditionalOrdersConditionalOrderId";
                ((Dictionary<string, object>)request)["conditionalOrderId"] = id;
            } else
            {
                method = "privateGetOrdersOrderId";
                ((Dictionary<string, object>)request)["orderId"] = id;
            }
            object query = this.omit(parameters, "stop");
            response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        } catch(Exception e)
        {
            if (isTrue(this.last_json_response))
            {
                object message = this.safeString(this.last_json_response, "message");
                if (isTrue(isEqual(message, "UUID_INVALID")))
                {
                    throw new OrderNotFound ((string)add(add(this.id, " fetchOrder() error: "), this.last_http_response)) ;
                }
            }
            throw e;
        }
        return this.parseOrder(response, market);
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bittrex#fetchMyTrades
        * @description fetch all trades made by the user
        * @param {string|undefined} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch trades for
        * @param {int|undefined} limit the maximum number of trades structures to retrieve
        * @param {object} params extra parameters specific to the bittrex api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["pageSize"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["startDate"] = add(this.ymdhms(since, "T"), "Z");
        }
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            symbol = getValue(market, "symbol");
            ((Dictionary<string, object>)request)["marketSymbol"] = getValue(market, "id");
        }
        object response = await this.privateGetExecutions(this.extend(request, parameters));
        object trades = this.parseTrades(response, market);
        return ((object)this.filterBySymbolSinceLimit(trades, symbol, since, limit));
    }

    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name bittrex#fetchClosedOrders
        * @description fetches information on multiple closed orders made by the user
        * @param {string|undefined} symbol unified market symbol of the market orders were made in
        * @param {int|undefined} since the earliest time in ms to fetch orders for
        * @param {int|undefined} limit the maximum number of  orde structures to retrieve
        * @param {object} params extra parameters specific to the bittrex api endpoint
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object stop = this.safeValue(parameters, "stop");
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["pageSize"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["startDate"] = add(this.ymdhms(since, "T"), "Z");
        }
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            // because of this line we will have to rethink the entire v3
            // in other words, markets define all the rest of the API
            // and v3 market ids are reversed in comparison to v1
            // v3 has to be a completely separate implementation
            // otherwise we will have to shuffle symbols and currencies everywhere
            // which is prone to errors, as was shown here
            // https://github.com/ccxt/ccxt/pull/5219#issuecomment-499646209
            ((Dictionary<string, object>)request)["marketSymbol"] = add(add(getValue(market, "base"), "-"), getValue(market, "quote"));
        }
        object method = "privateGetOrdersClosed";
        if (isTrue(stop))
        {
            method = "privateGetConditionalOrdersClosed";
        }
        object query = this.omit(parameters, "stop");
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        //
        // Spot
        //
        //     [
        //         {
        //             "id": "df6cf5ee-fc27-4b61-991a-cc94b6459ac9",
        //             "marketSymbol": "BTC-USDT",
        //             "direction": "BUY",
        //             "type": "LIMIT",
        //             "quantity": "0.00023277",
        //             "limit": "30000.00000000",
        //             "timeInForce": "GOOD_TIL_CANCELLED",
        //             "fillQuantity": "0.00000000",
        //             "commission": "0.00000000",
        //             "proceeds": "0.00000000",
        //             "status": "OPEN",
        //             "createdAt": "2022-04-20T02:33:53.16Z",
        //             "updatedAt": "2022-04-20T02:33:53.16Z"
        //         }
        //     ]
        //
        // Stop
        //
        //     [
        //         {
        //             "id": "f64f7c4f-295c-408b-9cbc-601981abf100",
        //             "marketSymbol": "BTC-USDT",
        //             "operand": "LTE",
        //             "triggerPrice": "0.10000000",
        //             "orderToCreate": {
        //                 "marketSymbol": "BTC-USDT",
        //                 "direction": "BUY",
        //                 "type": "LIMIT",
        //                 "quantity": "0.00020000",
        //                 "limit": "30000.00000000",
        //                 "timeInForce": "GOOD_TIL_CANCELLED"
        //             },
        //             "status": "OPEN",
        //             "createdAt": "2022-04-20T02:38:12.26Z",
        //             "updatedAt": "2022-04-20T02:38:12.26Z"
        //         }
        //     ]
        //
        return this.parseOrders(response, market, since, limit);
    }

    public async override Task<object> createDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name bittrex#createDepositAddress
        * @description create a currency deposit address
        * @param {string} code unified currency code of the currency for the deposit address
        * @param {object} params extra parameters specific to the bittrex api endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currencySymbol", getValue(currency, "id") },
        };
        object response = await this.privatePostAddresses(this.extend(request, parameters));
        //
        //     {
        //         "status":"PROVISIONED",
        //         "currencySymbol":"XRP",
        //         "cryptoAddress":"rPVMhWBsfF9iMXYj3aAzJVkPDTFNSyWdKy",
        //         "cryptoAddressTag":"392034158"
        //     }
        //
        object address = this.safeString(response, "cryptoAddress");
        object message = this.safeString(response, "status");
        if (isTrue(!isTrue(address) || isTrue(isEqual(message, "REQUESTED"))))
        {
            throw new AddressPending ((string)add(add(add(this.id, " the address for "), code), " is being generated (pending, not ready yet, retry again later)")) ;
        }
        this.checkAddress(address);
        return new Dictionary<string, object>() {
            { "currency", code },
            { "address", address },
            { "tag", this.safeString(response, "cryptoAddressTag") },
            { "network", null },
            { "info", response },
        };
    }

    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name bittrex#fetchDepositAddress
        * @description fetch the deposit address for a currency associated with this account
        * @param {string} code unified currency code
        * @param {object} params extra parameters specific to the bittrex api endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currencySymbol", getValue(currency, "id") },
        };
        object response = await this.privateGetAddressesCurrencySymbol(this.extend(request, parameters));
        //
        //     {
        //         "status":"PROVISIONED",
        //         "currencySymbol":"XRP",
        //         "cryptoAddress":"rPVMhWBsfF9iMXYj3aAzJVkPDTFNSyWdKy",
        //         "cryptoAddressTag":"392034158"
        //     }
        //
        object address = this.safeString(response, "cryptoAddress");
        object message = this.safeString(response, "status");
        if (isTrue(!isTrue(address) || isTrue(isEqual(message, "REQUESTED"))))
        {
            throw new AddressPending ((string)add(add(add(this.id, " the address for "), code), " is being generated (pending, not ready yet, retry again later)")) ;
        }
        this.checkAddress(address);
        return new Dictionary<string, object>() {
            { "currency", code },
            { "address", address },
            { "tag", this.safeString(response, "cryptoAddressTag") },
            { "network", null },
            { "info", response },
        };
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name bittrex#withdraw
        * @description make a withdrawal
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string|undefined} tag
        * @param {object} params extra parameters specific to the bittrex api endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((List<object>)tagparametersVariable)[0];
        parameters = ((List<object>)tagparametersVariable)[1];
        this.checkAddress(address);
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currencySymbol", getValue(currency, "id") },
            { "quantity", amount },
            { "cryptoAddress", address },
        };
        if (isTrue(!isEqual(tag, null)))
        {
            ((Dictionary<string, object>)request)["cryptoAddressTag"] = tag;
        }
        object response = await this.privatePostWithdrawals(this.extend(request, parameters));
        //
        //     {
        //         "currencySymbol": "string",
        //         "quantity": "number (double)",
        //         "cryptoAddress": "string",
        //         "cryptoAddressTag": "string",
        //         "fundsTransferMethodId": "string (uuid)",
        //         "clientWithdrawalId": "string (uuid)"
        //     }
        //
        return this.parseTransaction(response, currency);
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "v3";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object url = add(this.implodeParams(getValue(getValue(this.urls, "api"), api), new Dictionary<string, object>() {
    { "hostname", this.hostname },
}), "/");
        if (isTrue(isEqual(api, "private")))
        {
            url = add(url, add(this.version, "/"));
            this.checkRequiredCredentials();
            url = add(url, this.implodeParams(path, parameters));
            parameters = this.omit(parameters, this.extractParams(path));
            object hashString = "";
            if (isTrue(isEqual(method, "POST")))
            {
                body = this.json(parameters);
                hashString = body;
            } else
            {
                if (isTrue(getArrayLength(new List<object>(((Dictionary<string,object>)parameters).Keys))))
                {
                    url = add(url, add("?", this.rawencode(parameters)));
                }
            }
            object contentHash = this.hash(this.encode(hashString), sha512, "hex");
            object timestamp = ((object)this.milliseconds()).ToString();
            object auth = add(add(add(timestamp, url), method), contentHash);
            object subaccountId = this.safeValue(this.options, "subaccountId");
            if (isTrue(!isEqual(subaccountId, null)))
            {
                auth = add(auth, subaccountId);
            }
            object signature = this.hmac(this.encode(auth), this.encode(this.secret), sha512);
            headers = new Dictionary<string, object>() {
                { "Api-Key", this.apiKey },
                { "Api-Timestamp", timestamp },
                { "Api-Content-Hash", contentHash },
                { "Api-Signature", signature },
            };
            if (isTrue(!isEqual(subaccountId, null)))
            {
                ((Dictionary<string, object>)headers)["Api-Subaccount-Id"] = subaccountId;
            }
            if (isTrue(isEqual(method, "POST")))
            {
                ((Dictionary<string, object>)headers)["Content-Type"] = "application/json";
            }
        } else
        {
            if (isTrue(isEqual(api, "public")))
            {
                url = add(url, add(this.version, "/"));
            }
            url = add(url, this.implodeParams(path, parameters));
            parameters = this.omit(parameters, this.extractParams(path));
            if (isTrue(getArrayLength(new List<object>(((Dictionary<string,object>)parameters).Keys))))
            {
                url = add(url, add("?", this.urlencode(parameters)));
            }
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;  // fallback to default error handler
        }
        //
        //     { success: false, message: "message" }
        //
        if (isTrue(isEqual(getValue(body, 0), "{")))
        {
            object feedback = add(add(this.id, " "), body);
            object success = this.safeValue(response, "success");
            if (isTrue(isEqual(success, null)))
            {
                object codeInner = this.safeString(response, "code");
                if (isTrue(isTrue((isEqual(codeInner, "NOT_FOUND"))) && isTrue((isGreaterThanOrEqual(getIndexOf(url, "addresses"), 0)))))
                {
                    throw new InvalidAddress ((string)feedback) ;
                }
                if (isTrue(!isEqual(codeInner, null)))
                {
                    this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), codeInner, feedback);
                    this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), codeInner, feedback);
                }
                // throw new ExchangeError (this.id + ' malformed response ' + this.json (response));
                return null;
            }
            if (isTrue(((success).GetType() == typeof(string))))
            {
                // bleutrade uses string instead of boolean
                success = (isEqual(success, "true"));
            }
            if (!isTrue(success))
            {
                object message = this.safeString(response, "message");
                if (isTrue(isEqual(message, "APIKEY_INVALID")))
                {
                    if (isTrue(getValue(this.options, "hasAlreadyAuthenticatedSuccessfully")))
                    {
                        throw new DDoSProtection ((string)feedback) ;
                    } else
                    {
                        throw new AuthenticationError ((string)feedback) ;
                    }
                }
                // https://github.com/ccxt/ccxt/issues/4932
                // the following two lines are now redundant, see line 171 in describe()
                //
                //     if (message === 'DUST_TRADE_DISALLOWED_MIN_VALUE_50K_SAT')
                //         throw new InvalidOrder (this.id + ' order cost should be over 50k satoshi ' + this.json (response));
                //
                if (isTrue(isEqual(message, "INVALID_ORDER")))
                {
                    // Bittrex will return an ambiguous INVALID_ORDER message
                    // upon canceling already-canceled and closed orders
                    // therefore this special case for cancelOrder
                    // let url = 'https://bittrex.com/api/v1.1/market/cancel?apikey=API_KEY&uuid=ORDER_UUID'
                    object cancel = "cancel";
                    object indexOfCancel = getIndexOf(url, cancel);
                    if (isTrue(isGreaterThanOrEqual(indexOfCancel, 0)))
                    {
                        object urlParts = ((string)url).Split((string)"?").ToList<object>();
                        object numParts = getArrayLength(urlParts);
                        if (isTrue(isGreaterThan(numParts, 1)))
                        {
                            object query = getValue(urlParts, 1);
                            object parameters = ((string)query).Split((string)"&").ToList<object>();
                            object numParams = getArrayLength(parameters);
                            object orderId = null;
                            for (object i = 0; isLessThan(i, numParams); postFixIncrement(ref i))
                            {
                                object param = getValue(parameters, i);
                                object keyValue = ((string)param).Split((string)"=").ToList<object>();
                                if (isTrue(isEqual(getValue(keyValue, 0), "uuid")))
                                {
                                    orderId = getValue(keyValue, 1);
                                    break;
                                }
                            }
                            if (isTrue(!isEqual(orderId, null)))
                            {
                                throw new OrderNotFound ((string)add(add(add(add(this.id, " cancelOrder "), orderId), " "), this.json(response))) ;
                            } else
                            {
                                throw new OrderNotFound ((string)add(add(this.id, " cancelOrder "), this.json(response))) ;
                            }
                        }
                    }
                }
                this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), message, feedback);
                if (isTrue(!isEqual(message, null)))
                {
                    this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
                }
                throw new ExchangeError ((string)feedback) ;
            }
        }
        return null;
    }
}
