using ccxt;
namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

partial class okx : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "okx" },
            { "name", "OKX" },
            { "countries", new List<object>() {"CN", "US"} },
            { "version", "v5" },
            { "rateLimit", 100 },
            { "pro", true },
            { "certified", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", true },
                { "swap", true },
                { "future", true },
                { "option", null },
                { "addMargin", true },
                { "borrowMargin", true },
                { "cancelAllOrders", false },
                { "cancelOrder", true },
                { "cancelOrders", true },
                { "createDepositAddress", false },
                { "createOrder", true },
                { "createPostOnlyOrder", true },
                { "createReduceOnlyOrder", true },
                { "createStopLimitOrder", true },
                { "createStopMarketOrder", true },
                { "createStopOrder", true },
                { "editOrder", true },
                { "fetchAccounts", true },
                { "fetchBalance", true },
                { "fetchBidsAsks", null },
                { "fetchBorrowInterest", true },
                { "fetchBorrowRate", true },
                { "fetchBorrowRateHistories", true },
                { "fetchBorrowRateHistory", true },
                { "fetchBorrowRates", true },
                { "fetchBorrowRatesPerSymbol", false },
                { "fetchCanceledOrders", true },
                { "fetchClosedOrder", null },
                { "fetchClosedOrders", true },
                { "fetchCurrencies", true },
                { "fetchDeposit", true },
                { "fetchDepositAddress", true },
                { "fetchDepositAddresses", false },
                { "fetchDepositAddressesByNetwork", true },
                { "fetchDeposits", true },
                { "fetchDepositWithdrawFee", "emulated" },
                { "fetchDepositWithdrawFees", true },
                { "fetchFundingHistory", true },
                { "fetchFundingRate", true },
                { "fetchFundingRateHistory", true },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", true },
                { "fetchL3OrderBook", false },
                { "fetchLedger", true },
                { "fetchLedgerEntry", null },
                { "fetchLeverage", true },
                { "fetchLeverageTiers", false },
                { "fetchMarketLeverageTiers", true },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", true },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterest", true },
                { "fetchOpenInterestHistory", true },
                { "fetchOpenOrder", null },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrderBooks", false },
                { "fetchOrders", false },
                { "fetchOrderTrades", true },
                { "fetchPermissions", null },
                { "fetchPosition", true },
                { "fetchPositions", true },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchStatus", true },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", true },
                { "fetchTradingFees", false },
                { "fetchTradingLimits", false },
                { "fetchTransactionFee", false },
                { "fetchTransactionFees", false },
                { "fetchTransactions", false },
                { "fetchTransfer", true },
                { "fetchTransfers", false },
                { "fetchWithdrawal", true },
                { "fetchWithdrawals", true },
                { "fetchWithdrawalWhitelist", false },
                { "reduceMargin", true },
                { "repayMargin", true },
                { "setLeverage", true },
                { "setMargin", false },
                { "setMarginMode", true },
                { "setPositionMode", true },
                { "signIn", false },
                { "transfer", true },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1m" },
                { "3m", "3m" },
                { "5m", "5m" },
                { "15m", "15m" },
                { "30m", "30m" },
                { "1h", "1H" },
                { "2h", "2H" },
                { "4h", "4H" },
                { "6h", "6H" },
                { "12h", "12H" },
                { "1d", "1D" },
                { "1w", "1W" },
                { "1M", "1M" },
                { "3M", "3M" },
            } },
            { "hostname", "www.okx.com" },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/1294454/152485636-38b19e4a-bece-4dec-979a-5982859ffc04.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "rest", "https://{hostname}" },
                } },
                { "www", "https://www.okx.com" },
                { "doc", "https://www.okx.com/docs-v5/en/" },
                { "fees", "https://www.okx.com/pages/products/fees.html" },
                { "referral", "https://www.okx.com/join/1888677" },
                { "test", new Dictionary<string, object>() {
                    { "rest", "https://{hostname}" },
                } },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "market/tickers", 1 },
                        { "market/ticker", 1 },
                        { "market/index-tickers", 1 },
                        { "market/books", 1 },
                        { "market/books-lite", 1.66 },
                        { "market/candles", 0.5 },
                        { "market/history-candles", 1 },
                        { "market/history-mark-price-candles", 2 },
                        { "market/history-index-candles", 2 },
                        { "market/index-candles", 1 },
                        { "market/mark-price-candles", 1 },
                        { "market/trades", 1 },
                        { "market/platform-24-volume", 10 },
                        { "market/open-oracle", 40 },
                        { "market/index-components", 1 },
                        { "market/option/instrument-family-trades", 1 },
                        { "public/instruments", 1 },
                        { "public/instrument-tick-bands", 4 },
                        { "public/delivery-exercise-history", 0.5 },
                        { "public/open-interest", 1 },
                        { "public/funding-rate", 1 },
                        { "public/funding-rate-history", 1 },
                        { "public/price-limit", 1 },
                        { "public/opt-summary", 1 },
                        { "public/estimated-price", 2 },
                        { "public/discount-rate-interest-free-quota", 10 },
                        { "public/time", 2 },
                        { "public/liquidation-orders", 0.5 },
                        { "public/mark-price", 2 },
                        { "public/option-trades", 1 },
                        { "public/position-tiers", 2 },
                        { "public/underlying", 1 },
                        { "public/interest-rate-loan-quota", 10 },
                        { "public/vip-interest-rate-loan-quota", 10 },
                        { "rubik/stat/trading-data/support-coin", 4 },
                        { "rubik/stat/taker-volume", 4 },
                        { "rubik/stat/margin/loan-ratio", 4 },
                        { "rubik/stat/contracts/long-short-account-ratio", 4 },
                        { "rubik/stat/contracts/open-interest-volume", 4 },
                        { "rubik/stat/option/open-interest-volume", 4 },
                        { "rubik/stat/option/open-interest-volume-ratio", 4 },
                        { "rubik/stat/option/open-interest-volume-expiry", 4 },
                        { "rubik/stat/option/open-interest-volume-strike", 4 },
                        { "rubik/stat/option/taker-block-volume", 4 },
                        { "system/status", 100 },
                        { "finance/savings/lending-rate-summary", divide(5, 3) },
                        { "finance/savings/lending-rate-history", divide(5, 3) },
                        { "market/exchange-rate", 20 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "account/account-position-risk", 2 },
                        { "account/balance", 2 },
                        { "account/positions", 2 },
                        { "account/positions-history", 2 },
                        { "account/bills", divide(5, 3) },
                        { "account/bills-archive", divide(5, 3) },
                        { "account/config", 4 },
                        { "account/max-size", 1 },
                        { "account/max-avail-size", 1 },
                        { "account/leverage-info", 1 },
                        { "account/max-loan", 1 },
                        { "account/trade-fee", 4 },
                        { "account/interest-accrued", 4 },
                        { "account/interest-rate", 4 },
                        { "account/max-withdrawal", 1 },
                        { "account/risk-state", 2 },
                        { "account/borrow-repay-history", 4 },
                        { "account/quick-margin-borrow-repay-history", 4 },
                        { "account/interest-limits", 4 },
                        { "account/vip-interest-accrued", 4 },
                        { "account/vip-loan-order-list", 4 },
                        { "account/vip-loan-order-detail", 4 },
                        { "asset/asset-valuation", divide(1, 5) },
                        { "asset/deposit-address", divide(5, 3) },
                        { "asset/balances", divide(5, 3) },
                        { "asset/transfer-state", 10 },
                        { "asset/deposit-history", divide(5, 3) },
                        { "asset/withdrawal-history", divide(5, 3) },
                        { "asset/deposit-withdraw-status", 20 },
                        { "asset/currencies", divide(5, 3) },
                        { "asset/bills", divide(5, 3) },
                        { "asset/piggy-balance", divide(5, 3) },
                        { "asset/deposit-lightning", 5 },
                        { "asset/non-tradable-assets", divide(5, 3) },
                        { "trade/order", divide(1, 3) },
                        { "trade/orders-pending", 1 },
                        { "trade/orders-history", 0.5 },
                        { "trade/orders-history-archive", 1 },
                        { "trade/fills", divide(1, 3) },
                        { "trade/fills-history", 2 },
                        { "trade/orders-algo-pending", 1 },
                        { "trade/orders-algo-history", 1 },
                        { "trade/order-algo", 1 },
                        { "account/subaccount/balances", 10 },
                        { "asset/subaccount/bills", divide(5, 3) },
                        { "users/subaccount/list", 10 },
                        { "users/subaccount/apikey", 10 },
                        { "users/entrust-subaccount-list", 10 },
                        { "broker/nd/info", 10 },
                        { "broker/nd/subaccount-info", 10 },
                        { "asset/broker/nd/subaccount-deposit-address", 4 },
                        { "asset/broker/nd/subaccount-deposit-history", 4 },
                        { "broker/nd/rebate-daily", 1 },
                        { "broker/nd/subaccount/apikey", 10 },
                        { "broker/nd/rebate-per-orders", 300 },
                        { "asset/broker/nd/subaccount-withdrawal-history", 4 },
                        { "asset/convert/currencies", divide(5, 3) },
                        { "asset/convert/currency-pair", divide(5, 3) },
                        { "asset/convert/estimate-quote", 5 },
                        { "asset/convert/trade", 5 },
                        { "asset/convert/history", divide(5, 3) },
                        { "account/greeks", 2 },
                        { "finance/staking-defi/offers", 1 },
                        { "finance/staking-defi/orders-active", 1 },
                        { "finance/staking-defi/orders-history", 1 },
                        { "finance/savings/balance", divide(5, 3) },
                        { "finance/savings/lending-history", divide(5, 3) },
                        { "rfq/counterparties", 4 },
                        { "rfq/maker-instrument-settings", 4 },
                        { "rfq/rfqs", 10 },
                        { "rfq/quotes", 10 },
                        { "rfq/trades", 4 },
                        { "rfq/public-trades", 4 },
                        { "copytrading/current-subpositions", 10 },
                        { "copytrading/subpositions-history", 10 },
                        { "copytrading/instruments", 10 },
                        { "copytrading/profit-sharing-details", 10 },
                        { "copytrading/total-profit-sharing", 10 },
                        { "copytrading/unrealized-profit-sharing-details", 10 },
                        { "tradingBot/grid/orders-algo-pending", 1 },
                        { "tradingBot/grid/orders-algo-history", 1 },
                        { "tradingBot/grid/orders-algo-details", 1 },
                        { "tradingBot/grid/sub-orders", 1 },
                        { "tradingBot/grid/positions", 1 },
                        { "tradingBot/grid/ai-param", 1 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "account/set-position-mode", 4 },
                        { "account/set-leverage", 1 },
                        { "account/position/margin-balance", 1 },
                        { "account/set-greeks", 4 },
                        { "account/set-isolated-mode", 4 },
                        { "account/set-riskOffset-type", 2 },
                        { "account/simulated_margin", 10 },
                        { "account/borrow-repay", divide(5, 3) },
                        { "account/quick-margin-borrow-repay", 4 },
                        { "account/activate-option", 4 },
                        { "account/set-auto-loan", 4 },
                        { "asset/transfer", 10 },
                        { "asset/withdrawal", divide(5, 3) },
                        { "asset/withdrawal-lightning", 5 },
                        { "asset/cancel-withdrawal", divide(5, 3) },
                        { "asset/convert-dust-assets", 10 },
                        { "trade/order", divide(1, 3) },
                        { "trade/batch-orders", divide(1, 15) },
                        { "trade/cancel-order", divide(1, 3) },
                        { "trade/cancel-batch-orders", divide(1, 15) },
                        { "trade/amend-order", divide(1, 3) },
                        { "trade/amend-batch-orders", divide(1, 3) },
                        { "trade/close-position", 1 },
                        { "trade/order-algo", 1 },
                        { "trade/cancel-algos", 1 },
                        { "trade/cancel-advance-algos", 1 },
                        { "users/subaccount/delete-apikey", 10 },
                        { "users/subaccount/modify-apikey", 10 },
                        { "users/subaccount/apikey", 10 },
                        { "users/subaccount/set-transfer-out", 10 },
                        { "asset/subaccount/transfer", 10 },
                        { "broker/nd/create-subaccount", 10 },
                        { "broker/nd/delete-subaccount", 10 },
                        { "broker/nd/set-subaccount-level", 4 },
                        { "broker/nd/set-subaccount-fee-rate", 4 },
                        { "asset/broker/nd/subaccount-deposit-address", 4 },
                        { "broker/nd/subaccount/apikey", 10 },
                        { "broker/nd/subaccount/delete-apikey", 10 },
                        { "broker/nd/subaccount/modify-apikey", 10 },
                        { "broker/nd/rebate-per-orders", 36000 },
                        { "finance/staking-defi/purchase", 3 },
                        { "finance/staking-defi/redeem", 3 },
                        { "finance/staking-defi/cancel", 3 },
                        { "finance/savings/purchase-redempt", divide(5, 3) },
                        { "finance/savings/set-lending-rate", divide(5, 3) },
                        { "rfq/create-rfq", 4 },
                        { "rfq/cancel-rfq", 4 },
                        { "rfq/cancel-batch-rfqs", 10 },
                        { "rfq/cancel-all-rfqs", 10 },
                        { "rfq/execute-quote", 10 },
                        { "rfq/maker-instrument-settings", 4 },
                        { "rfq/mmp-reset", 4 },
                        { "rfq/create-quote", 0.4 },
                        { "rfq/cancel-quote", 0.4 },
                        { "rfq/cancel-batch-quotes", 10 },
                        { "rfq/cancel-all-quotes", 10 },
                        { "copytrading/algo-order", 20 },
                        { "copytrading/close-subposition", 10 },
                        { "copytrading/set-instruments", 10 },
                        { "tradingBot/grid/order-algo", 1 },
                        { "tradingBot/grid/amend-order-algo", 1 },
                        { "tradingBot/grid/stop-order-algo", 1 },
                        { "tradingBot/grid/withdraw-income", 1 },
                        { "tradingBot/grid/compute-margin-balance", 1 },
                        { "tradingBot/grid/margin-balance", 1 },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "taker", this.parseNumber("0.0015") },
                    { "maker", this.parseNumber("0.0010") },
                } },
                { "spot", new Dictionary<string, object>() {
                    { "taker", this.parseNumber("0.0015") },
                    { "maker", this.parseNumber("0.0010") },
                } },
                { "future", new Dictionary<string, object>() {
                    { "taker", this.parseNumber("0.0005") },
                    { "maker", this.parseNumber("0.0002") },
                } },
                { "swap", new Dictionary<string, object>() {
                    { "taker", this.parseNumber("0.00050") },
                    { "maker", this.parseNumber("0.00020") },
                } },
            } },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", true },
                { "secret", true },
                { "password", true },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "1", typeof(ExchangeError) },
                    { "2", typeof(ExchangeError) },
                    { "50000", typeof(BadRequest) },
                    { "50001", typeof(OnMaintenance) },
                    { "50002", typeof(BadRequest) },
                    { "50004", typeof(RequestTimeout) },
                    { "50005", typeof(ExchangeNotAvailable) },
                    { "50006", typeof(BadRequest) },
                    { "50007", typeof(AccountSuspended) },
                    { "50008", typeof(AuthenticationError) },
                    { "50009", typeof(AccountSuspended) },
                    { "50010", typeof(ExchangeError) },
                    { "50011", typeof(RateLimitExceeded) },
                    { "50012", typeof(ExchangeError) },
                    { "50013", typeof(ExchangeNotAvailable) },
                    { "50014", typeof(BadRequest) },
                    { "50015", typeof(ExchangeError) },
                    { "50016", typeof(ExchangeError) },
                    { "50017", typeof(ExchangeError) },
                    { "50018", typeof(ExchangeError) },
                    { "50019", typeof(ExchangeError) },
                    { "50020", typeof(ExchangeError) },
                    { "50021", typeof(ExchangeError) },
                    { "50022", typeof(ExchangeError) },
                    { "50023", typeof(ExchangeError) },
                    { "50024", typeof(BadRequest) },
                    { "50025", typeof(ExchangeError) },
                    { "50026", typeof(ExchangeNotAvailable) },
                    { "50027", typeof(PermissionDenied) },
                    { "50028", typeof(ExchangeError) },
                    { "50044", typeof(BadRequest) },
                    { "50100", typeof(ExchangeError) },
                    { "50101", typeof(AuthenticationError) },
                    { "50102", typeof(InvalidNonce) },
                    { "50103", typeof(AuthenticationError) },
                    { "50104", typeof(AuthenticationError) },
                    { "50105", typeof(AuthenticationError) },
                    { "50106", typeof(AuthenticationError) },
                    { "50107", typeof(AuthenticationError) },
                    { "50108", typeof(ExchangeError) },
                    { "50109", typeof(ExchangeError) },
                    { "50110", typeof(PermissionDenied) },
                    { "50111", typeof(AuthenticationError) },
                    { "50112", typeof(AuthenticationError) },
                    { "50113", typeof(AuthenticationError) },
                    { "50114", typeof(AuthenticationError) },
                    { "50115", typeof(BadRequest) },
                    { "51000", typeof(BadRequest) },
                    { "51001", typeof(BadSymbol) },
                    { "51002", typeof(BadSymbol) },
                    { "51003", typeof(BadRequest) },
                    { "51004", typeof(InvalidOrder) },
                    { "51005", typeof(InvalidOrder) },
                    { "51006", typeof(InvalidOrder) },
                    { "51007", typeof(InvalidOrder) },
                    { "51008", typeof(InsufficientFunds) },
                    { "51009", typeof(AccountSuspended) },
                    { "51010", typeof(AccountNotEnabled) },
                    { "51011", typeof(InvalidOrder) },
                    { "51012", typeof(BadSymbol) },
                    { "51014", typeof(BadSymbol) },
                    { "51015", typeof(BadSymbol) },
                    { "51016", typeof(InvalidOrder) },
                    { "51017", typeof(ExchangeError) },
                    { "51018", typeof(ExchangeError) },
                    { "51019", typeof(ExchangeError) },
                    { "51020", typeof(InvalidOrder) },
                    { "51021", typeof(BadSymbol) },
                    { "51022", typeof(BadSymbol) },
                    { "51023", typeof(ExchangeError) },
                    { "51024", typeof(AccountSuspended) },
                    { "51025", typeof(ExchangeError) },
                    { "51026", typeof(BadSymbol) },
                    { "51027", typeof(BadSymbol) },
                    { "51028", typeof(BadSymbol) },
                    { "51029", typeof(BadSymbol) },
                    { "51030", typeof(BadSymbol) },
                    { "51031", typeof(InvalidOrder) },
                    { "51100", typeof(InvalidOrder) },
                    { "51101", typeof(InvalidOrder) },
                    { "51102", typeof(InvalidOrder) },
                    { "51103", typeof(InvalidOrder) },
                    { "51104", typeof(InvalidOrder) },
                    { "51105", typeof(InvalidOrder) },
                    { "51106", typeof(InvalidOrder) },
                    { "51107", typeof(InvalidOrder) },
                    { "51108", typeof(InvalidOrder) },
                    { "51109", typeof(InvalidOrder) },
                    { "51110", typeof(InvalidOrder) },
                    { "51111", typeof(BadRequest) },
                    { "51112", typeof(InvalidOrder) },
                    { "51113", typeof(RateLimitExceeded) },
                    { "51115", typeof(InvalidOrder) },
                    { "51116", typeof(InvalidOrder) },
                    { "51117", typeof(InvalidOrder) },
                    { "51118", typeof(InvalidOrder) },
                    { "51119", typeof(InsufficientFunds) },
                    { "51120", typeof(InvalidOrder) },
                    { "51121", typeof(InvalidOrder) },
                    { "51122", typeof(InvalidOrder) },
                    { "51124", typeof(InvalidOrder) },
                    { "51125", typeof(InvalidOrder) },
                    { "51126", typeof(InvalidOrder) },
                    { "51127", typeof(InsufficientFunds) },
                    { "51128", typeof(InvalidOrder) },
                    { "51129", typeof(InvalidOrder) },
                    { "51130", typeof(BadSymbol) },
                    { "51131", typeof(InsufficientFunds) },
                    { "51132", typeof(InvalidOrder) },
                    { "51133", typeof(InvalidOrder) },
                    { "51134", typeof(InvalidOrder) },
                    { "51135", typeof(InvalidOrder) },
                    { "51136", typeof(InvalidOrder) },
                    { "51137", typeof(InvalidOrder) },
                    { "51138", typeof(InvalidOrder) },
                    { "51139", typeof(InvalidOrder) },
                    { "51156", typeof(BadRequest) },
                    { "51159", typeof(BadRequest) },
                    { "51162", typeof(InvalidOrder) },
                    { "51163", typeof(InvalidOrder) },
                    { "51166", typeof(InvalidOrder) },
                    { "51201", typeof(InvalidOrder) },
                    { "51202", typeof(InvalidOrder) },
                    { "51203", typeof(InvalidOrder) },
                    { "51204", typeof(InvalidOrder) },
                    { "51205", typeof(InvalidOrder) },
                    { "51250", typeof(InvalidOrder) },
                    { "51251", typeof(InvalidOrder) },
                    { "51252", typeof(InvalidOrder) },
                    { "51253", typeof(InvalidOrder) },
                    { "51254", typeof(InvalidOrder) },
                    { "51255", typeof(InvalidOrder) },
                    { "51256", typeof(InvalidOrder) },
                    { "51257", typeof(InvalidOrder) },
                    { "51258", typeof(InvalidOrder) },
                    { "51259", typeof(InvalidOrder) },
                    { "51260", typeof(InvalidOrder) },
                    { "51261", typeof(InvalidOrder) },
                    { "51262", typeof(InvalidOrder) },
                    { "51263", typeof(InvalidOrder) },
                    { "51264", typeof(InvalidOrder) },
                    { "51265", typeof(InvalidOrder) },
                    { "51267", typeof(InvalidOrder) },
                    { "51268", typeof(InvalidOrder) },
                    { "51269", typeof(InvalidOrder) },
                    { "51270", typeof(InvalidOrder) },
                    { "51271", typeof(InvalidOrder) },
                    { "51272", typeof(InvalidOrder) },
                    { "51273", typeof(InvalidOrder) },
                    { "51274", typeof(InvalidOrder) },
                    { "51275", typeof(InvalidOrder) },
                    { "51276", typeof(InvalidOrder) },
                    { "51277", typeof(InvalidOrder) },
                    { "51278", typeof(InvalidOrder) },
                    { "51279", typeof(InvalidOrder) },
                    { "51280", typeof(InvalidOrder) },
                    { "51321", typeof(InvalidOrder) },
                    { "51322", typeof(InvalidOrder) },
                    { "51323", typeof(BadRequest) },
                    { "51324", typeof(BadRequest) },
                    { "51325", typeof(InvalidOrder) },
                    { "51327", typeof(InvalidOrder) },
                    { "51328", typeof(InvalidOrder) },
                    { "51329", typeof(InvalidOrder) },
                    { "51330", typeof(InvalidOrder) },
                    { "51400", typeof(OrderNotFound) },
                    { "51401", typeof(OrderNotFound) },
                    { "51402", typeof(OrderNotFound) },
                    { "51403", typeof(InvalidOrder) },
                    { "51404", typeof(InvalidOrder) },
                    { "51405", typeof(ExchangeError) },
                    { "51406", typeof(ExchangeError) },
                    { "51407", typeof(BadRequest) },
                    { "51408", typeof(ExchangeError) },
                    { "51409", typeof(ExchangeError) },
                    { "51410", typeof(CancelPending) },
                    { "51500", typeof(ExchangeError) },
                    { "51501", typeof(ExchangeError) },
                    { "51502", typeof(InsufficientFunds) },
                    { "51503", typeof(ExchangeError) },
                    { "51506", typeof(ExchangeError) },
                    { "51508", typeof(ExchangeError) },
                    { "51509", typeof(ExchangeError) },
                    { "51510", typeof(ExchangeError) },
                    { "51511", typeof(ExchangeError) },
                    { "51600", typeof(ExchangeError) },
                    { "51601", typeof(ExchangeError) },
                    { "51602", typeof(ExchangeError) },
                    { "51603", typeof(OrderNotFound) },
                    { "51732", typeof(AuthenticationError) },
                    { "51733", typeof(AuthenticationError) },
                    { "51734", typeof(AuthenticationError) },
                    { "51735", typeof(ExchangeError) },
                    { "51736", typeof(InsufficientFunds) },
                    { "52000", typeof(ExchangeError) },
                    { "54000", typeof(ExchangeError) },
                    { "54001", typeof(ExchangeError) },
                    { "58000", typeof(ExchangeError) },
                    { "58001", typeof(AuthenticationError) },
                    { "58002", typeof(PermissionDenied) },
                    { "58003", typeof(ExchangeError) },
                    { "58004", typeof(AccountSuspended) },
                    { "58005", typeof(ExchangeError) },
                    { "58006", typeof(ExchangeError) },
                    { "58007", typeof(ExchangeError) },
                    { "58100", typeof(ExchangeError) },
                    { "58101", typeof(AccountSuspended) },
                    { "58102", typeof(RateLimitExceeded) },
                    { "58103", typeof(ExchangeError) },
                    { "58104", typeof(ExchangeError) },
                    { "58105", typeof(ExchangeError) },
                    { "58106", typeof(ExchangeError) },
                    { "58107", typeof(ExchangeError) },
                    { "58108", typeof(ExchangeError) },
                    { "58109", typeof(ExchangeError) },
                    { "58110", typeof(ExchangeError) },
                    { "58111", typeof(ExchangeError) },
                    { "58112", typeof(ExchangeError) },
                    { "58114", typeof(ExchangeError) },
                    { "58115", typeof(ExchangeError) },
                    { "58116", typeof(ExchangeError) },
                    { "58117", typeof(ExchangeError) },
                    { "58125", typeof(BadRequest) },
                    { "58126", typeof(BadRequest) },
                    { "58127", typeof(BadRequest) },
                    { "58128", typeof(BadRequest) },
                    { "58200", typeof(ExchangeError) },
                    { "58201", typeof(ExchangeError) },
                    { "58202", typeof(ExchangeError) },
                    { "58203", typeof(InvalidAddress) },
                    { "58204", typeof(AccountSuspended) },
                    { "58205", typeof(ExchangeError) },
                    { "58206", typeof(ExchangeError) },
                    { "58207", typeof(InvalidAddress) },
                    { "58208", typeof(ExchangeError) },
                    { "58209", typeof(ExchangeError) },
                    { "58210", typeof(ExchangeError) },
                    { "58211", typeof(ExchangeError) },
                    { "58212", typeof(ExchangeError) },
                    { "58213", typeof(AuthenticationError) },
                    { "58221", typeof(BadRequest) },
                    { "58222", typeof(BadRequest) },
                    { "58224", typeof(BadRequest) },
                    { "58227", typeof(BadRequest) },
                    { "58228", typeof(BadRequest) },
                    { "58229", typeof(InsufficientFunds) },
                    { "58300", typeof(ExchangeError) },
                    { "58350", typeof(InsufficientFunds) },
                    { "59000", typeof(ExchangeError) },
                    { "59001", typeof(ExchangeError) },
                    { "59100", typeof(ExchangeError) },
                    { "59101", typeof(ExchangeError) },
                    { "59102", typeof(ExchangeError) },
                    { "59103", typeof(InsufficientFunds) },
                    { "59104", typeof(ExchangeError) },
                    { "59105", typeof(ExchangeError) },
                    { "59106", typeof(ExchangeError) },
                    { "59107", typeof(ExchangeError) },
                    { "59108", typeof(InsufficientFunds) },
                    { "59109", typeof(ExchangeError) },
                    { "59128", typeof(InvalidOrder) },
                    { "59200", typeof(InsufficientFunds) },
                    { "59201", typeof(InsufficientFunds) },
                    { "59216", typeof(BadRequest) },
                    { "59300", typeof(ExchangeError) },
                    { "59301", typeof(ExchangeError) },
                    { "59313", typeof(ExchangeError) },
                    { "59401", typeof(ExchangeError) },
                    { "59500", typeof(ExchangeError) },
                    { "59501", typeof(ExchangeError) },
                    { "59502", typeof(ExchangeError) },
                    { "59503", typeof(ExchangeError) },
                    { "59504", typeof(ExchangeError) },
                    { "59505", typeof(ExchangeError) },
                    { "59506", typeof(ExchangeError) },
                    { "59507", typeof(ExchangeError) },
                    { "59508", typeof(AccountSuspended) },
                    { "60001", typeof(AuthenticationError) },
                    { "60002", typeof(AuthenticationError) },
                    { "60003", typeof(AuthenticationError) },
                    { "60004", typeof(AuthenticationError) },
                    { "60005", typeof(AuthenticationError) },
                    { "60006", typeof(InvalidNonce) },
                    { "60007", typeof(AuthenticationError) },
                    { "60008", typeof(AuthenticationError) },
                    { "60009", typeof(AuthenticationError) },
                    { "60010", typeof(AuthenticationError) },
                    { "60011", typeof(AuthenticationError) },
                    { "60012", typeof(BadRequest) },
                    { "60013", typeof(BadRequest) },
                    { "60014", typeof(RateLimitExceeded) },
                    { "60015", typeof(NetworkError) },
                    { "60016", typeof(ExchangeNotAvailable) },
                    { "60017", typeof(BadRequest) },
                    { "60018", typeof(BadRequest) },
                    { "60019", typeof(BadRequest) },
                    { "63999", typeof(ExchangeError) },
                    { "70010", typeof(BadRequest) },
                    { "70013", typeof(BadRequest) },
                    { "70016", typeof(BadRequest) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "Internal Server Error", typeof(ExchangeNotAvailable) },
                    { "server error", typeof(ExchangeNotAvailable) },
                } },
            } },
            { "httpExceptions", new Dictionary<string, object>() {
                { "429", typeof(ExchangeNotAvailable) },
            } },
            { "precisionMode", TICK_SIZE },
            { "options", new Dictionary<string, object>() {
                { "sandboxMode", false },
                { "defaultNetwork", "ERC20" },
                { "networks", new Dictionary<string, object>() {
                    { "BTC", "Bitcoin" },
                    { "OMNI", "Omni" },
                    { "SOL", "Solana" },
                    { "LTC", "Litecoin" },
                    { "MATIC", "Polygon" },
                    { "OP", "Optimism" },
                    { "ARB", "Arbitrum one" },
                    { "AVAX", "Avalanche C-Chain" },
                } },
                { "networksById", new Dictionary<string, object>() {
                    { "Bitcoin", "BTC" },
                    { "Omni", "OMNI" },
                    { "Solana", "SOL" },
                    { "Litecoin", "LTC" },
                    { "Polygon", "MATIC" },
                    { "Optimism", "OP" },
                    { "Arbitrum one", "ARB" },
                    { "Avalanche C-Chain", "AVAX" },
                } },
                { "fetchOpenInterestHistory", new Dictionary<string, object>() {
                    { "timeframes", new Dictionary<string, object>() {
                        { "5m", "5m" },
                        { "1h", "1H" },
                        { "1d", "1D" },
                        { "5M", "5m" },
                        { "1H", "1H" },
                        { "1D", "1D" },
                    } },
                } },
                { "fetchOHLCV", new Dictionary<string, object>() {
                    { "timezone", "UTC" },
                } },
                { "fetchPositions", new Dictionary<string, object>() {
                    { "method", "privateGetAccountPositions" },
                } },
                { "createOrder", "privatePostTradeBatchOrders" },
                { "createMarketBuyOrderRequiresPrice", false },
                { "fetchMarkets", new List<object>() {"spot", "future", "swap", "option"} },
                { "defaultType", "spot" },
                { "fetchLedger", new Dictionary<string, object>() {
                    { "method", "privateGetAccountBills" },
                } },
                { "fetchOrder", new Dictionary<string, object>() {
                    { "method", "privateGetTradeOrder" },
                } },
                { "fetchOpenOrders", new Dictionary<string, object>() {
                    { "method", "privateGetTradeOrdersPending" },
                } },
                { "cancelOrders", new Dictionary<string, object>() {
                    { "method", "privatePostTradeCancelBatchOrders" },
                } },
                { "fetchCanceledOrders", new Dictionary<string, object>() {
                    { "method", "privateGetTradeOrdersHistory" },
                } },
                { "fetchClosedOrders", new Dictionary<string, object>() {
                    { "method", "privateGetTradeOrdersHistory" },
                } },
                { "algoOrderTypes", new Dictionary<string, object>() {
                    { "conditional", true },
                    { "trigger", true },
                    { "oco", true },
                    { "move_order_stop", true },
                    { "iceberg", true },
                    { "twap", true },
                } },
                { "accountsByType", new Dictionary<string, object>() {
                    { "funding", "6" },
                    { "trading", "18" },
                    { "spot", "18" },
                    { "future", "18" },
                    { "futures", "18" },
                    { "margin", "18" },
                    { "swap", "18" },
                    { "option", "18" },
                } },
                { "accountsById", new Dictionary<string, object>() {
                    { "6", "funding" },
                    { "18", "trading" },
                } },
                { "exchangeType", new Dictionary<string, object>() {
                    { "spot", "SPOT" },
                    { "margin", "MARGIN" },
                    { "swap", "SWAP" },
                    { "future", "FUTURES" },
                    { "futures", "FUTURES" },
                    { "option", "OPTION" },
                    { "SPOT", "SPOT" },
                    { "MARGIN", "MARGIN" },
                    { "SWAP", "SWAP" },
                    { "FUTURES", "FUTURES" },
                    { "OPTION", "OPTION" },
                } },
                { "brokerId", "e847386590ce4dBC" },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "AE", "AET" },
                { "BOX", "DefiBox" },
                { "HOT", "Hydro Protocol" },
                { "HSR", "HC" },
                { "MAG", "Maggie" },
                { "SBTC", "Super Bitcoin" },
                { "TRADE", "Unitrade" },
                { "YOYO", "YOYOW" },
                { "WIN", "WinToken" },
            } },
        });
    }

    public override object handleMarketTypeAndParams(object methodName, object market = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object instType = this.safeString(parameters, "instType");
        parameters = this.omit(parameters, "instType");
        object type = this.safeString(parameters, "type");
        if (isTrue(isTrue((isEqual(type, null))) && isTrue((!isEqual(instType, null)))))
        {
            ((Dictionary<string, object>)parameters)["type"] = instType;
        }
        return base.handleMarketTypeAndParams(methodName, market, parameters);
    }

    public virtual object convertToInstrumentType(object type)
    {
        object exchangeTypes = this.safeValue(this.options, "exchangeType", new Dictionary<string, object>() {});
        return this.safeString(exchangeTypes, type, type);
    }

    public async override Task<object> fetchStatus(object parameters = null)
    {
        /**
        * @method
        * @name okx#fetchStatus
        * @description the latest known information on the availability of the exchange API
        * @param {object} params extra parameters specific to the okx api endpoint
        * @returns {object} a [status structure]{@link https://docs.ccxt.com/#/?id=exchange-status-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetSystemStatus(parameters);
        //
        // Note, if there is no maintenance around, the 'data' array is empty
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "begin": "1621328400000",
        //                 "end": "1621329000000",
        //                 "href": "https://www.okx.com/support/hc/en-us/articles/360060882172",
        //                 "scheDesc": "",
        //                 "serviceType": "1", // 0 WebSocket, 1 Spot/Margin, 2 Futures, 3 Perpetual, 4 Options, 5 Trading service
        //                 "state": "scheduled", // ongoing, completed, canceled
        //                 "system": "classic", // classic, unified
        //                 "title": "Classic Spot System Upgrade"
        //             },
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object dataLength = getArrayLength(data);
        object update = new Dictionary<string, object>() {
            { "updated", null },
            { "status", ((bool) isTrue((isEqual(dataLength, 0)))) ? "ok" : "maintenance" },
            { "eta", null },
            { "url", null },
            { "info", response },
        };
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object eventVar = getValue(data, i);
            object state = this.safeString(eventVar, "state");
            if (isTrue(isEqual(state, "ongoing")))
            {
                ((Dictionary<string, object>)update)["eta"] = this.safeInteger(eventVar, "end");
                ((Dictionary<string, object>)update)["status"] = "maintenance";
            }
        }
        return update;
    }

    public async override Task<object> fetchTime(object parameters = null)
    {
        /**
        * @method
        * @name okx#fetchTime
        * @description fetches the current integer timestamp in milliseconds from the exchange server
        * @param {object} params extra parameters specific to the okx api endpoint
        * @returns {int} the current integer timestamp in milliseconds from the exchange server
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetPublicTime(parameters);
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {"ts": "1621247923668"}
        //         ],
        //         "msg": ""
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object first = this.safeValue(data, 0, new Dictionary<string, object>() {});
        return this.safeInteger(first, "ts");
    }

    public async override Task<object> fetchAccounts(object parameters = null)
    {
        /**
        * @method
        * @name okx#fetchAccounts
        * @description fetch all the accounts associated with a profile
        * @param {object} params extra parameters specific to the okx api endpoint
        * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/#/?id=account-structure} indexed by the account type
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.privateGetAccountConfig(parameters);
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "acctLv": "2",
        //                 "autoLoan": false,
        //                 "ctIsoMode": "automatic",
        //                 "greeksType": "PA",
        //                 "level": "Lv1",
        //                 "levelTmp": "",
        //                 "mgnIsoMode": "automatic",
        //                 "posMode": "long_short_mode",
        //                 "uid": "88018754289672195"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object account = getValue(data, i);
            object accountId = this.safeString(account, "uid");
            object type = this.safeString(account, "acctLv");
            ((List<object>)result).Add(new Dictionary<string, object>() {
                { "id", accountId },
                { "type", type },
                { "currency", null },
                { "info", account },
            });
        }
        return result;
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name okx#fetchMarkets
        * @description retrieves data on all markets for okx
        * @param {object} params extra parameters specific to the exchange api endpoint
        * @returns {[object]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object types = this.safeValue(this.options, "fetchMarkets");
        object promises = new List<object>() {};
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(types)); postFixIncrement(ref i))
        {
            ((List<object>)promises).Add(this.fetchMarketsByType(getValue(types, i), parameters));
        }
        // why not both ¯\_(ツ)_/¯
        promises = await promiseAll(promises);
        for (object i = 0; isLessThan(i, getArrayLength(promises)); postFixIncrement(ref i))
        {
            result = this.arrayConcat(result, getValue(promises, i));
        }
        return result;
    }

    public virtual object parseMarkets(object markets)
    {
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(markets)); postFixIncrement(ref i))
        {
            ((List<object>)result).Add(this.parseMarket(getValue(markets, i)));
        }
        return result;
    }

    public virtual object parseMarket(object market)
    {
        //
        //     {
        //         "alias": "", // this_week, next_week, quarter, next_quarter
        //         "baseCcy": "BTC",
        //         "category": "1",
        //         "ctMult": "",
        //         "ctType": "", // inverse, linear
        //         "ctVal": "",
        //         "ctValCcy": "",
        //         "expTime": "",
        //         "instId": "BTC-USDT", // BTC-USD-210521, CSPR-USDT-SWAP, BTC-USD-210517-44000-C
        //         "instType": "SPOT", // SPOT, FUTURES, SWAP, OPTION
        //         "lever": "10",
        //         "listTime": "1548133413000",
        //         "lotSz": "0.00000001",
        //         "minSz": "0.00001",
        //         "optType": "",
        //         "quoteCcy": "USDT",
        //         "settleCcy": "",
        //         "state": "live",
        //         "stk": "",
        //         "tickSz": "0.1",
        //         "uly": ""
        //     }
        //
        //     {
        //         alias: "",
        //         baseCcy: "",
        //         category: "1",
        //         ctMult: "0.1",
        //         ctType: "",
        //         ctVal: "1",
        //         ctValCcy: "BTC",
        //         expTime: "1648195200000",
        //         instId: "BTC-USD-220325-194000-P",
        //         instType: "OPTION",
        //         lever: "",
        //         listTime: "1631262612280",
        //         lotSz: "1",
        //         minSz: "1",
        //         optType: "P",
        //         quoteCcy: "",
        //         settleCcy: "BTC",
        //         state: "live",
        //         stk: "194000",
        //         tickSz: "0.0005",
        //         uly: "BTC-USD"
        //     }
        //
        object id = this.safeString(market, "instId");
        object type = this.safeStringLower(market, "instType");
        if (isTrue(isEqual(type, "futures")))
        {
            type = "future";
        }
        object spot = (isEqual(type, "spot"));
        object future = (isEqual(type, "future"));
        object swap = (isEqual(type, "swap"));
        object option = (isEqual(type, "option"));
        object contract = isTrue(isTrue(swap) || isTrue(future)) || isTrue(option);
        object baseId = this.safeString(market, "baseCcy");
        object quoteId = this.safeString(market, "quoteCcy");
        object settleId = this.safeString(market, "settleCcy");
        object settle = this.safeCurrencyCode(settleId);
        object underlying = this.safeString(market, "uly");
        if (isTrue(isTrue((!isEqual(underlying, null))) && !isTrue(spot)))
        {
            object parts = ((string)underlying).Split((string)"-").ToList<object>();
            baseId = this.safeString(parts, 0);
            quoteId = this.safeString(parts, 1);
        }
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object symbol = add(add(bs, "/"), quote);
        object expiry = null;
        object strikePrice = null;
        object optionType = null;
        if (isTrue(contract))
        {
            symbol = add(add(symbol, ":"), settle);
            expiry = this.safeInteger(market, "expTime");
            if (isTrue(future))
            {
                object ymd = this.yymmdd(expiry);
                symbol = add(add(symbol, "-"), ymd);
            } else if (isTrue(option))
            {
                strikePrice = this.safeString(market, "stk");
                optionType = this.safeString(market, "optType");
                object ymd = this.yymmdd(expiry);
                symbol = add(add(add(add(add(add(symbol, "-"), ymd), "-"), strikePrice), "-"), optionType);
                optionType = ((bool) isTrue((isEqual(optionType, "P")))) ? "put" : "call";
            }
        }
        object tickSize = this.safeString(market, "tickSz");
        object minAmountString = this.safeString(market, "minSz");
        object minAmount = this.parseNumber(minAmountString);
        object fees = this.safeValue2(this.fees, type, "trading", new Dictionary<string, object>() {});
        object precisionPrice = this.parseNumber(tickSize);
        object maxLeverage = this.safeString(market, "lever", "1");
        maxLeverage = Precise.stringMax(maxLeverage, "1");
        return this.extend(fees, new Dictionary<string, object>() {
            { "id", id },
            { "symbol", symbol },
            { "base", bs },
            { "quote", quote },
            { "settle", settle },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settleId", settleId },
            { "type", type },
            { "spot", spot },
            { "margin", isTrue(spot) && isTrue((Precise.stringGt(maxLeverage, "1"))) },
            { "swap", swap },
            { "future", future },
            { "option", option },
            { "active", true },
            { "contract", contract },
            { "linear", ((bool) isTrue(contract)) ? (isEqual(quoteId, settleId)) : null },
            { "inverse", ((bool) isTrue(contract)) ? (isEqual(baseId, settleId)) : null },
            { "contractSize", ((bool) isTrue(contract)) ? this.safeNumber(market, "ctVal") : null },
            { "expiry", expiry },
            { "expiryDatetime", this.iso8601(expiry) },
            { "strike", strikePrice },
            { "optionType", optionType },
            { "precision", new Dictionary<string, object>() {
                { "amount", this.safeNumber(market, "lotSz") },
                { "price", precisionPrice },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", this.parseNumber("1") },
                    { "max", this.parseNumber(maxLeverage) },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", minAmount },
                    { "max", null },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", precisionPrice },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
            } },
            { "info", market },
        });
    }

    public async virtual Task<object> fetchMarketsByType(object type, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "instType", this.convertToInstrumentType(type) },
        };
        if (isTrue(isEqual(type, "option")))
        {
            object defaultUnderlying = this.safeValue(this.options, "defaultUnderlying", "BTC-USD");
            object currencyId = this.safeString2(parameters, "uly", "marketId", defaultUnderlying);
            if (isTrue(isEqual(currencyId, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchMarketsByType() requires an underlying uly or marketId parameter for options markets")) ;
            } else
            {
                ((Dictionary<string, object>)request)["uly"] = currencyId;
            }
        }
        object response = await this.publicGetPublicInstruments(this.extend(request, parameters));
        //
        // spot, future, swap, option
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "alias": "", // this_week, next_week, quarter, next_quarter
        //                 "baseCcy": "BTC",
        //                 "category": "1",
        //                 "ctMult": "",
        //                 "ctType": "", // inverse, linear
        //                 "ctVal": "",
        //                 "ctValCcy": "",
        //                 "expTime": "",
        //                 "instId": "BTC-USDT", // BTC-USD-210521, CSPR-USDT-SWAP, BTC-USD-210517-44000-C
        //                 "instType": "SPOT", // SPOT, FUTURES, SWAP, OPTION
        //                 "lever": "10",
        //                 "listTime": "1548133413000",
        //                 "lotSz": "0.00000001",
        //                 "minSz": "0.00001",
        //                 "optType": "",
        //                 "quoteCcy": "USDT",
        //                 "settleCcy": "",
        //                 "state": "live",
        //                 "stk": "",
        //                 "tickSz": "0.1",
        //                 "uly": ""
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        return this.parseMarkets(data);
    }

    public virtual object safeNetwork(object networkId)
    {
        object networksById = new Dictionary<string, object>() {
            { "Bitcoin", "BTC" },
            { "Omni", "OMNI" },
            { "TRON", "TRC20" },
        };
        return this.safeString(networksById, networkId, networkId);
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name okx#fetchCurrencies
        * @description fetches all available currencies on an exchange
        * @see https://www.okx.com/docs-v5/en/#rest-api-funding-get-currencies
        * @param {object} params extra parameters specific to the okx api endpoint
        * @returns {object} an associative dictionary of currencies
        */
        // this endpoint requires authentication
        // while fetchCurrencies is a public API method by design
        // therefore we check the keys here
        // and fallback to generating the currencies from the markets
        parameters ??= new Dictionary<string, object>();
        object isSandboxMode = this.safeValue(this.options, "sandboxMode", false);
        if (isTrue(!isTrue(this.checkRequiredCredentials(false)) || isTrue(isSandboxMode)))
        {
            return null;
        }
        //
        // has['fetchCurrencies'] is currently set to true, but an unauthorized request returns
        //
        //     {"msg":"Request header “OK_ACCESS_KEY“ can't be empty.","code":"50103"}
        //
        object response = await this.privateGetAssetCurrencies(parameters);
        //
        //    {
        //        "code": "0",
        //        "data": [
        //            {
        //                "canDep": true,
        //                "canInternal": false,
        //                "canWd": true,
        //                "ccy": "USDT",
        //                "chain": "USDT-TRC20",
        //                "logoLink": "https://static.coinall.ltd/cdn/assets/imgs/221/5F74EB20302D7761.png",
        //                "mainNet": false,
        //                "maxFee": "1.6",
        //                "maxWd": "8852150",
        //                "minFee": "0.8",
        //                "minWd": "2",
        //                "name": "Tether",
        //                "usedWdQuota": "0",
        //                "wdQuota": "500",
        //                "wdTickSz": "3"
        //            },
        //            {
        //                "canDep": true,
        //                "canInternal": false,
        //                "canWd": true,
        //                "ccy": "USDT",
        //                "chain": "USDT-ERC20",
        //                "logoLink": "https://static.coinall.ltd/cdn/assets/imgs/221/5F74EB20302D7761.png",
        //                "mainNet": false,
        //                "maxFee": "16",
        //                "maxWd": "8852150",
        //                "minFee": "8",
        //                "minWd": "2",
        //                "name": "Tether",
        //                "usedWdQuota": "0",
        //                "wdQuota": "500",
        //                "wdTickSz": "3"
        //            },
        //            ...
        //        ],
        //        "msg": ""
        //    }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        object dataByCurrencyId = this.groupBy(data, "ccy");
        object currencyIds = new List<object>(((Dictionary<string,object>)dataByCurrencyId).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(currencyIds)); postFixIncrement(ref i))
        {
            object currencyId = getValue(currencyIds, i);
            object currency = this.safeCurrency(currencyId);
            object code = getValue(currency, "code");
            object chains = getValue(dataByCurrencyId, currencyId);
            object networks = new Dictionary<string, object>() {};
            object currencyActive = false;
            object depositEnabled = null;
            object withdrawEnabled = null;
            object maxPrecision = null;
            for (object j = 0; isLessThan(j, getArrayLength(chains)); postFixIncrement(ref j))
            {
                object chain = getValue(chains, j);
                object canDeposit = this.safeValue(chain, "canDep");
                object canWithdraw = this.safeValue(chain, "canWd");
                object canInternal = this.safeValue(chain, "canInternal");
                object active = ((bool) isTrue((isTrue(isTrue(canDeposit) && isTrue(canWithdraw)) && isTrue(canInternal)))) ? true : false;
                currencyActive = ((bool) isTrue((active))) ? active : currencyActive;
                object networkId = this.safeString(chain, "chain");
                if (isTrue(isTrue(canDeposit) && !isTrue(depositEnabled)))
                {
                    depositEnabled = true;
                } else if (!isTrue(canDeposit))
                {
                    depositEnabled = false;
                }
                if (isTrue(isTrue(canWithdraw) && !isTrue(withdrawEnabled)))
                {
                    withdrawEnabled = true;
                } else if (!isTrue(canWithdraw))
                {
                    withdrawEnabled = false;
                }
                if (isTrue(isTrue((!isEqual(networkId, null))) && isTrue((isGreaterThanOrEqual(getIndexOf(networkId, "-"), 0)))))
                {
                    object parts = ((string)networkId).Split((string)"-").ToList<object>();
                    object chainPart = this.safeString(parts, 1, networkId);
                    object networkCode = this.safeNetwork(chainPart);
                    object precision = this.parsePrecision(this.safeString(chain, "wdTickSz"));
                    if (isTrue(isEqual(maxPrecision, null)))
                    {
                        maxPrecision = precision;
                    } else
                    {
                        maxPrecision = Precise.stringMin(maxPrecision, precision);
                    }
                    ((Dictionary<string, object>)networks)[(string)networkCode] = new Dictionary<string, object>() {
                        { "id", networkId },
                        { "network", networkCode },
                        { "active", active },
                        { "deposit", canDeposit },
                        { "withdraw", canWithdraw },
                        { "fee", this.safeNumber(chain, "minFee") },
                        { "precision", this.parseNumber(precision) },
                        { "limits", new Dictionary<string, object>() {
                            { "withdraw", new Dictionary<string, object>() {
                                { "min", this.safeNumber(chain, "minWd") },
                                { "max", this.safeNumber(chain, "maxWd") },
                            } },
                        } },
                        { "info", chain },
                    };
                }
            }
            object firstChain = this.safeValue(chains, 0);
            ((Dictionary<string, object>)result)[(string)code] = new Dictionary<string, object>() {
                { "info", null },
                { "code", code },
                { "id", currencyId },
                { "name", this.safeString(firstChain, "name") },
                { "active", currencyActive },
                { "deposit", depositEnabled },
                { "withdraw", withdrawEnabled },
                { "fee", null },
                { "precision", this.parseNumber(maxPrecision) },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "networks", networks },
            };
        }
        return result;
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name okx#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int|undefined} limit the maximum amount of order book entries to return
        * @param {object} params extra parameters specific to the okx api endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
        };
        limit = ((bool) isTrue((isEqual(limit, null)))) ? 20 : limit;
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["sz"] = limit; // max 400
        }
        object response = await this.publicGetMarketBooks(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "asks": [
        //                     ["0.07228","4.211619","0","2"], // price, amount, liquidated orders, total open orders
        //                     ["0.0723","299.880364","0","2"],
        //                     ["0.07231","3.72832","0","1"],
        //                 ],
        //                 "bids": [
        //                     ["0.07221","18.5","0","1"],
        //                     ["0.0722","18.5","0","1"],
        //                     ["0.07219","0.505407","0","1"],
        //                 ],
        //                 "ts": "1621438475342"
        //             }
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object first = this.safeValue(data, 0, new Dictionary<string, object>() {});
        object timestamp = this.safeInteger(first, "ts");
        return this.parseOrderBook(first, symbol, timestamp);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        //     {
        //         "instType": "SPOT",
        //         "instId": "ETH-BTC",
        //         "last": "0.07319",
        //         "lastSz": "0.044378",
        //         "askPx": "0.07322",
        //         "askSz": "4.2",
        //         "bidPx": "0.0732",
        //         "bidSz": "6.050058",
        //         "open24h": "0.07801",
        //         "high24h": "0.07975",
        //         "low24h": "0.06019",
        //         "volCcy24h": "11788.887619",
        //         "vol24h": "167493.829229",
        //         "ts": "1621440583784",
        //         "sodUtc0": "0.07872",
        //         "sodUtc8": "0.07345"
        //     }
        //
        object timestamp = this.safeInteger(ticker, "ts");
        object marketId = this.safeString(ticker, "instId");
        market = this.safeMarket(marketId, market, "-");
        object symbol = getValue(market, "symbol");
        object last = this.safeString(ticker, "last");
        object open = this.safeString(ticker, "open24h");
        object spot = this.safeValue(market, "spot", false);
        object quoteVolume = ((bool) isTrue(spot)) ? this.safeString(ticker, "volCcy24h") : null;
        object baseVolume = this.safeString(ticker, "vol24h");
        object high = this.safeString(ticker, "high24h");
        object low = this.safeString(ticker, "low24h");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", high },
            { "low", low },
            { "bid", this.safeString(ticker, "bidPx") },
            { "bidVolume", this.safeString(ticker, "bidSz") },
            { "ask", this.safeString(ticker, "askPx") },
            { "askVolume", this.safeString(ticker, "askSz") },
            { "vwap", null },
            { "open", open },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", null },
            { "average", null },
            { "baseVolume", baseVolume },
            { "quoteVolume", quoteVolume },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name okx#fetchTicker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} params extra parameters specific to the okx api endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
        };
        object response = await this.publicGetMarketTicker(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "instType": "SPOT",
        //                 "instId": "ETH-BTC",
        //                 "last": "0.07319",
        //                 "lastSz": "0.044378",
        //                 "askPx": "0.07322",
        //                 "askSz": "4.2",
        //                 "bidPx": "0.0732",
        //                 "bidSz": "6.050058",
        //                 "open24h": "0.07801",
        //                 "high24h": "0.07975",
        //                 "low24h": "0.06019",
        //                 "volCcy24h": "11788.887619",
        //                 "vol24h": "167493.829229",
        //                 "ts": "1621440583784",
        //                 "sodUtc0": "0.07872",
        //                 "sodUtc8": "0.07345"
        //             }
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object first = this.safeValue(data, 0, new Dictionary<string, object>() {});
        return this.parseTicker(first, market);
    }

    public async virtual Task<object> fetchTickersByType(object type, object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "instType", this.convertToInstrumentType(type) },
        };
        if (isTrue(isEqual(type, "option")))
        {
            object defaultUnderlying = this.safeValue(this.options, "defaultUnderlying", "BTC-USD");
            object currencyId = this.safeString2(parameters, "uly", "marketId", defaultUnderlying);
            if (isTrue(isEqual(currencyId, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchTickersByType() requires an underlying uly or marketId parameter for options markets")) ;
            } else
            {
                ((Dictionary<string, object>)request)["uly"] = currencyId;
            }
        }
        object response = await this.publicGetMarketTickers(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "instType": "SPOT",
        //                 "instId": "BCD-BTC",
        //                 "last": "0.0000769",
        //                 "lastSz": "5.4788",
        //                 "askPx": "0.0000777",
        //                 "askSz": "3.2197",
        //                 "bidPx": "0.0000757",
        //                 "bidSz": "4.7509",
        //                 "open24h": "0.0000885",
        //                 "high24h": "0.0000917",
        //                 "low24h": "0.0000596",
        //                 "volCcy24h": "9.2877",
        //                 "vol24h": "124824.1985",
        //                 "ts": "1621441741434",
        //                 "sodUtc0": "0.0000905",
        //                 "sodUtc8": "0.0000729"
        //             },
        //         ]
        //     }
        //
        object tickers = this.safeValue(response, "data", new List<object>() {});
        return this.parseTickers(tickers, symbols);
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name okx#fetchTickers
        * @description fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
        * @param {[string]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} params extra parameters specific to the okx api endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object first = this.safeString(symbols, 0);
        object market = null;
        if (isTrue(!isEqual(first, null)))
        {
            market = this.market(first);
        }
        var typequeryVariable = this.handleMarketTypeAndParams("fetchTickers", market, parameters);
        var type = ((List<object>) typequeryVariable)[0];
        var query = ((List<object>) typequeryVariable)[1];
        return await this.fetchTickersByType(type, symbols, query);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // public fetchTrades
        //
        //     {
        //         "instId": "ETH-BTC",
        //         "side": "sell",
        //         "sz": "0.119501",
        //         "px": "0.07065",
        //         "tradeId": "15826757",
        //         "ts": "1621446178316"
        //     }
        //
        // private fetchMyTrades
        //
        //     {
        //         "side": "buy",
        //         "fillSz": "0.007533",
        //         "fillPx": "2654.98",
        //         "fee": "-0.000007533",
        //         "ordId": "317321390244397056",
        //         "instType": "SPOT",
        //         "instId": "ETH-USDT",
        //         "clOrdId": "",
        //         "posSide": "net",
        //         "billId": "317321390265368576",
        //         "tag": "0",
        //         "execType": "T",
        //         "tradeId": "107601752",
        //         "feeCcy": "ETH",
        //         "ts": "1621927314985"
        //     }
        //
        object id = this.safeString(trade, "tradeId");
        object marketId = this.safeString(trade, "instId");
        market = this.safeMarket(marketId, market, "-");
        object symbol = getValue(market, "symbol");
        object timestamp = this.safeInteger(trade, "ts");
        object price = this.safeString2(trade, "fillPx", "px");
        object amount = this.safeString2(trade, "fillSz", "sz");
        object side = this.safeString(trade, "side");
        object orderId = this.safeString(trade, "ordId");
        object feeCostString = this.safeString(trade, "fee");
        object fee = null;
        if (isTrue(!isEqual(feeCostString, null)))
        {
            object feeCostSigned = Precise.stringNeg(feeCostString);
            object feeCurrencyId = this.safeString(trade, "feeCcy");
            object feeCurrencyCode = this.safeCurrencyCode(feeCurrencyId);
            fee = new Dictionary<string, object>() {
                { "cost", feeCostSigned },
                { "currency", feeCurrencyCode },
            };
        }
        object takerOrMaker = this.safeString(trade, "execType");
        if (isTrue(isEqual(takerOrMaker, "T")))
        {
            takerOrMaker = "taker";
        } else if (isTrue(isEqual(takerOrMaker, "M")))
        {
            takerOrMaker = "maker";
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "id", id },
            { "order", orderId },
            { "type", null },
            { "takerOrMaker", takerOrMaker },
            { "side", side },
            { "price", price },
            { "amount", amount },
            { "cost", null },
            { "fee", fee },
        }, market);
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name okx#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int|undefined} since timestamp in ms of the earliest trade to fetch
        * @param {int|undefined} limit the maximum amount of trades to fetch
        * @param {object} params extra parameters specific to the okx api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/en/latest/manual.html?#public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit; // default 100
        }
        object response = await this.publicGetMarketTrades(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {"instId":"ETH-BTC","side":"sell","sz":"0.119501","px":"0.07065","tradeId":"15826757","ts":"1621446178316"},
        //             {"instId":"ETH-BTC","side":"sell","sz":"0.03","px":"0.07068","tradeId":"15826756","ts":"1621446178066"},
        //             {"instId":"ETH-BTC","side":"buy","sz":"0.507","px":"0.07069","tradeId":"15826755","ts":"1621446175085"},
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        return this.parseTrades(data, market, since, limit);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     [
        //         "1678928760000", // timestamp
        //         "24341.4", // open
        //         "24344", // high
        //         "24313.2", // low
        //         "24323", // close
        //         "628", // contract volume
        //         "2.5819", // base volume
        //         "62800", // quote volume
        //         "0" // candlestick state
        //     ]
        //
        object res = this.handleMarketTypeAndParams("fetchOHLCV", market, null);
        object type = getValue(res, 0);
        object volumeIndex = ((bool) isTrue((isEqual(type, "spot")))) ? 5 : 6;
        return new List<object> {this.safeInteger(ohlcv, 0), this.safeNumber(ohlcv, 1), this.safeNumber(ohlcv, 2), this.safeNumber(ohlcv, 3), this.safeNumber(ohlcv, 4), this.safeNumber(ohlcv, volumeIndex)};
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name okx#fetchOHLCV
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @see https://www.okx.com/docs-v5/en/#rest-api-market-data-get-candlesticks
        * @see https://www.okx.com/docs-v5/en/#rest-api-market-data-get-candlesticks-history
        * @see https://www.okx.com/docs-v5/en/#rest-api-market-data-get-mark-price-candlesticks
        * @see https://www.okx.com/docs-v5/en/#rest-api-market-data-get-mark-price-candlesticks-history
        * @see https://www.okx.com/docs-v5/en/#rest-api-market-data-get-index-candlesticks
        * @see https://www.okx.com/docs-v5/en/#rest-api-market-data-get-index-candlesticks-history
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int|undefined} since timestamp in ms of the earliest candle to fetch
        * @param {int|undefined} limit the maximum amount of candles to fetch
        * @param {object} params extra parameters specific to the okx api endpoint
        * @param {string|undefined} params.price "mark" or "index" for mark price and index price candles
        * @param {int|undefined} params.until timestamp in ms of the latest candle to fetch
        * @returns {[[int]]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object price = this.safeString(parameters, "price");
        parameters = this.omit(parameters, "price");
        object options = this.safeValue(this.options, "fetchOHLCV", new Dictionary<string, object>() {});
        object timezone = this.safeString(options, "timezone", "UTC");
        if (isTrue(isEqual(limit, null)))
        {
            limit = 100; // default 100, max 100
        }
        object duration = this.parseTimeframe(timeframe);
        object bar = this.safeString(this.timeframes, timeframe, timeframe);
        if (isTrue(isTrue((isEqual(timezone, "UTC"))) && isTrue((isGreaterThanOrEqual(duration, 21600)))))
        {
            bar = add(bar, ((string)timezone).ToLower());
        }
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
            { "bar", bar },
            { "limit", limit },
        };
        object defaultType = "Candles";
        if (isTrue(!isEqual(since, null)))
        {
            object now = this.milliseconds();
            object difference = subtract(now, since);
            // if the since timestamp is more than limit candles back in the past
            if (isTrue(isGreaterThan(difference, multiply(multiply(1440, duration), 1000))))
            {
                defaultType = "HistoryCandles";
            }
            object durationInMilliseconds = multiply(duration, 1000);
            object startTime = mathMax(subtract(since, 1), 0);
            ((Dictionary<string, object>)request)["before"] = startTime;
            ((Dictionary<string, object>)request)["after"] = this.sum(startTime, multiply(durationInMilliseconds, limit));
        }
        object until = this.safeInteger(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            ((Dictionary<string, object>)request)["after"] = until;
            parameters = this.omit(parameters, "until");
        }
        defaultType = this.safeString(options, "type", defaultType); // Candles or HistoryCandles
        object type = this.safeString(parameters, "type", defaultType);
        parameters = this.omit(parameters, "type");
        object method = add("publicGetMarket", type);
        object isHistoryCandles = (isEqual(type, "HistoryCandles"));
        if (isTrue(isEqual(price, "mark")))
        {
            method = ((bool) isTrue((isHistoryCandles))) ? "publicGetMarketHistoryMarkPriceCandles" : "publicGetMarketMarkPriceCandles";
        } else if (isTrue(isEqual(price, "index")))
        {
            method = ((bool) isTrue((isHistoryCandles))) ? "publicGetMarketHistoryIndexCandles" : "publicGetMarketIndexCandles";
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             ["1678928760000","24341.4","24344","24313.2","24323","628","2.5819","62800","0"],
        //             ["1678928700000","24324.1","24347.6","24321.7","24341.4","2565","10.5401","256500","1"],
        //             ["1678928640000","24300.2","24324.1","24288","24324.1","3304","13.5937","330400","1"],
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        return this.parseOHLCVs(data, market, timeframe, since, limit);
    }

    public async override Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name okx#fetchFundingRateHistory
        * @description fetches historical funding rate prices
        * @param {string|undefined} symbol unified symbol of the market to fetch the funding rate history for
        * @param {int|undefined} since timestamp in ms of the earliest funding rate to fetch
        * @param {int|undefined} limit the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/en/latest/manual.html?#funding-rate-history-structure} to fetch
        * @param {object} params extra parameters specific to the okx api endpoint
        * @returns {[object]} a list of [funding rate structures]{@link https://docs.ccxt.com/en/latest/manual.html?#funding-rate-history-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchFundingRateHistory() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["before"] = mathMax(subtract(since, 1), 0);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object response = await this.publicGetPublicFundingRateHistory(this.extend(request, parameters));
        //
        //     {
        //         "code":"0",
        //         "msg":"",
        //         "data":[
        //             {
        //                 "instType":"SWAP",
        //                 "instId":"BTC-USDT-SWAP",
        //                 "fundingRate":"0.018",
        //                 "realizedRate":"0.017",
        //                 "fundingTime":"1597026383085"
        //             },
        //             {
        //                 "instType":"SWAP",
        //                 "instId":"BTC-USDT-SWAP",
        //                 "fundingRate":"0.018",
        //                 "realizedRate":"0.017",
        //                 "fundingTime":"1597026383085"
        //             }
        //         ]
        //     }
        //
        object rates = new List<object>() {};
        object data = this.safeValue(response, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object rate = getValue(data, i);
            object timestamp = this.safeNumber(rate, "fundingTime");
            ((List<object>)rates).Add(new Dictionary<string, object>() {
                { "info", rate },
                { "symbol", this.safeSymbol(this.safeString(rate, "instId")) },
                { "fundingRate", this.safeNumber(rate, "realizedRate") },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
            });
        }
        object sorted = this.sortBy(rates, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, getValue(market, "symbol"), since, limit);
    }

    public virtual object parseBalanceByType(object type, object response)
    {
        if (isTrue(isEqual(type, "funding")))
        {
            return this.parseFundingBalance(response);
        } else
        {
            return this.parseTradingBalance(response);
        }
    }

    public virtual object parseTradingBalance(object response)
    {
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        object data = this.safeValue(response, "data", new List<object>() {});
        object first = this.safeValue(data, 0, new Dictionary<string, object>() {});
        object timestamp = this.safeInteger(first, "uTime");
        object details = this.safeValue(first, "details", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(details)); postFixIncrement(ref i))
        {
            object balance = getValue(details, i);
            object currencyId = this.safeString(balance, "ccy");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            // it may be incorrect to use total, free and used for swap accounts
            object eq = this.safeString(balance, "eq");
            object availEq = this.safeString(balance, "availEq");
            if (isTrue(isTrue((isEqual(eq, null))) || isTrue((isEqual(availEq, null)))))
            {
                ((Dictionary<string, object>)account)["free"] = this.safeString(balance, "availBal");
                ((Dictionary<string, object>)account)["used"] = this.safeString(balance, "frozenBal");
            } else
            {
                ((Dictionary<string, object>)account)["total"] = eq;
                ((Dictionary<string, object>)account)["free"] = availEq;
            }
            ((Dictionary<string, object>)result)[(string)code] = account;
        }
        ((Dictionary<string, object>)result)["timestamp"] = timestamp;
        ((Dictionary<string, object>)result)["datetime"] = this.iso8601(timestamp);
        return this.safeBalance(result);
    }

    public virtual object parseFundingBalance(object response)
    {
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        object data = this.safeValue(response, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object balance = getValue(data, i);
            object currencyId = this.safeString(balance, "ccy");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            // it may be incorrect to use total, free and used for swap accounts
            ((Dictionary<string, object>)account)["total"] = this.safeString(balance, "bal");
            ((Dictionary<string, object>)account)["free"] = this.safeString(balance, "availBal");
            ((Dictionary<string, object>)account)["used"] = this.safeString(balance, "frozenBal");
            ((Dictionary<string, object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public virtual object parseTradingFee(object fee, object market = null)
    {
        // https://www.okx.com/docs-v5/en/#rest-api-account-get-fee-rates
        //
        //     {
        //         "category": "1",
        //         "delivery": "",
        //         "exercise": "",
        //         "instType": "SPOT",
        //         "level": "Lv1",
        //         "maker": "-0.0008",
        //         "taker": "-0.001",
        //         "ts": "1639043138472"
        //     }
        //
        return new Dictionary<string, object>() {
            { "info", fee },
            { "symbol", this.safeSymbol(null, market) },
            { "maker", this.parseNumber(Precise.stringNeg(this.safeString2(fee, "maker", "makerU"))) },
            { "taker", this.parseNumber(Precise.stringNeg(this.safeString2(fee, "taker", "takerU"))) },
        };
    }

    public async override Task<object> fetchTradingFee(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name okx#fetchTradingFee
        * @description fetch the trading fees for a market
        * @param {string} symbol unified market symbol
        * @param {object} params extra parameters specific to the okx api endpoint
        * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instType", this.convertToInstrumentType(getValue(market, "type")) },
        };
        if (isTrue(getValue(market, "spot")))
        {
            ((Dictionary<string, object>)request)["instId"] = getValue(market, "id");
        } else if (isTrue(isTrue(isTrue(getValue(market, "swap")) || isTrue(getValue(market, "future"))) || isTrue(getValue(market, "option"))))
        {
            ((Dictionary<string, object>)request)["uly"] = add(add(getValue(market, "baseId"), "-"), getValue(market, "quoteId"));
        } else
        {
            throw new NotSupported ((string)add(this.id, " fetchTradingFee() supports spot, swap, future or option markets only")) ;
        }
        object response = await this.privateGetAccountTradeFee(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "category": "1",
        //                 "delivery": "",
        //                 "exercise": "",
        //                 "instType": "SPOT",
        //                 "level": "Lv1",
        //                 "maker": "-0.0008",
        //                 "taker": "-0.001",
        //                 "ts": "1639043138472"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object first = this.safeValue(data, 0, new Dictionary<string, object>() {});
        return this.parseTradingFee(first, market);
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name okx#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @param {object} params extra parameters specific to the okx api endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/en/latest/manual.html?#balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        var marketTypequeryVariable = this.handleMarketTypeAndParams("fetchBalance", null, parameters);
        var marketType = ((List<object>) marketTypequeryVariable)[0];
        var query = ((List<object>) marketTypequeryVariable)[1];
        object method = null;
        if (isTrue(isEqual(marketType, "funding")))
        {
            method = "privateGetAssetBalances";
        } else
        {
            method = "privateGetAccountBalance";
        }
        object request = new Dictionary<string, object>() {};
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "adjEq": "",
        //                 "details": [
        //                     {
        //                         "availBal": "",
        //                         "availEq": "28.21006347",
        //                         "cashBal": "28.21006347",
        //                         "ccy": "USDT",
        //                         "crossLiab": "",
        //                         "disEq": "28.2687404020176",
        //                         "eq":"28 .21006347",
        //                         "eqUsd": "28.2687404020176",
        //                         "frozenBal": "0",
        //                         "interest": "",
        //                         "isoEq": "0",
        //                         "isoLiab": "",
        //                         "liab": "",
        //                         "maxLoan": "",
        //                         "mgnRatio": "",
        //                         "notionalLever": "0",
        //                         "ordFrozen": "0",
        //                         "twap": "0",
        //                         "uTime": "1621556539861",
        //                         "upl": "0",
        //                         "uplLiab": ""
        //                     }
        //                 ],
        //                 "imr": "",
        //                 "isoEq": "0",
        //                 "mgnRatio": "",
        //                 "mmr": "",
        //                 "notionalUsd": "",
        //                 "ordFroz": "",
        //                 "totalEq": "28.2687404020176",
        //                 "uTime": "1621556553510"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "adjEq": "",
        //                 "details": [
        //                     {
        //                         "availBal": "0.049",
        //                         "availEq": "",
        //                         "cashBal": "0.049",
        //                         "ccy": "BTC",
        //                         "crossLiab": "",
        //                         "disEq": "1918.55678",
        //                         "eq": "0.049",
        //                         "eqUsd": "1918.55678",
        //                         "frozenBal": "0",
        //                         "interest": "",
        //                         "isoEq": "",
        //                         "isoLiab": "",
        //                         "liab": "",
        //                         "maxLoan": "",
        //                         "mgnRatio": "",
        //                         "notionalLever": "",
        //                         "ordFrozen": "0",
        //                         "twap": "0",
        //                         "uTime": "1621973128591",
        //                         "upl": "",
        //                         "uplLiab": ""
        //                     }
        //                 ],
        //                 "imr": "",
        //                 "isoEq": "",
        //                 "mgnRatio": "",
        //                 "mmr": "",
        //                 "notionalUsd": "",
        //                 "ordFroz": "",
        //                 "totalEq": "1918.55678",
        //                 "uTime": "1622045126908"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        // funding
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "availBal": "0.00005426",
        //                 "bal": 0.0000542600000000,
        //                 "ccy": "BTC",
        //                 "frozenBal": "0"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        return this.parseBalanceByType(marketType, response);
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name okx#createOrder
        * @description create a trade order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float|undefined} price the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} params extra parameters specific to the okx api endpoint
        * @param {bool|undefined} params.reduceOnly MARGIN orders only, or swap/future orders in net mode
        * @param {bool|undefined} params.postOnly true to place a post only order
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
            { "side", side },
            { "ordType", type },
            { "sz", this.amountToPrecision(symbol, amount) },
        };
        object spot = getValue(market, "spot");
        object contract = getValue(market, "contract");
        object triggerPrice = this.safeValueN(parameters, new List<object>() {"triggerPrice", "stopPrice", "triggerPx"});
        object timeInForce = this.safeString(parameters, "timeInForce", "GTC");
        object takeProfitPrice = this.safeValue2(parameters, "takeProfitPrice", "tpTriggerPx");
        object tpOrdPx = this.safeValue(parameters, "tpOrdPx", price);
        object tpTriggerPxType = this.safeString(parameters, "tpTriggerPxType", "last");
        object stopLossPrice = this.safeValue2(parameters, "stopLossPrice", "slTriggerPx");
        object slOrdPx = this.safeValue(parameters, "slOrdPx", price);
        object slTriggerPxType = this.safeString(parameters, "slTriggerPxType", "last");
        object clientOrderId = this.safeString2(parameters, "clOrdId", "clientOrderId");
        object defaultMarginMode = this.safeString2(this.options, "defaultMarginMode", "marginMode", "cross");
        object marginMode = this.safeString2(parameters, "marginMode", "tdMode"); // cross or isolated, tdMode not ommited so as to be extended into the request
        object margin = false;
        if (isTrue(isTrue((!isEqual(marginMode, null))) && isTrue((!isEqual(marginMode, "cash")))))
        {
            margin = true;
        } else
        {
            marginMode = defaultMarginMode;
            margin = this.safeValue(parameters, "margin", false);
        }
        if (isTrue(spot))
        {
            if (isTrue(margin))
            {
                object defaultCurrency = ((bool) isTrue((isEqual(side, "buy")))) ? getValue(market, "quote") : getValue(market, "base");
                object currency = this.safeString(parameters, "ccy", defaultCurrency);
                ((Dictionary<string, object>)request)["ccy"] = this.safeCurrencyCode(currency);
            }
            object tradeMode = ((bool) isTrue(margin)) ? marginMode : "cash";
            ((Dictionary<string, object>)request)["tdMode"] = tradeMode;
        } else if (isTrue(contract))
        {
            ((Dictionary<string, object>)request)["tdMode"] = marginMode;
        }
        object isMarketOrder = isEqual(type, "market");
        object postOnly = false;
        var postOnlyparametersVariable = this.handlePostOnly(isMarketOrder, isEqual(type, "post_only"), parameters);
        postOnly = ((List<object>)postOnlyparametersVariable)[0];
        parameters = ((List<object>)postOnlyparametersVariable)[1];
        parameters = this.omit(parameters, new List<object>() {"currency", "ccy", "marginMode", "timeInForce", "stopPrice", "triggerPrice", "clientOrderId", "stopLossPrice", "takeProfitPrice", "slOrdPx", "tpOrdPx", "margin"});
        object ioc = isTrue((isEqual(timeInForce, "IOC"))) || isTrue((isEqual(type, "ioc")));
        object fok = isTrue((isEqual(timeInForce, "FOK"))) || isTrue((isEqual(type, "fok")));
        object trigger = isTrue((!isEqual(triggerPrice, null))) || isTrue((isEqual(type, "trigger")));
        object conditional = isTrue(isTrue((!isEqual(stopLossPrice, null))) || isTrue((!isEqual(takeProfitPrice, null)))) || isTrue((isEqual(type, "conditional")));
        object marketIOC = isTrue((isTrue(isMarketOrder) && isTrue(ioc))) || isTrue((isEqual(type, "optimal_limit_ioc")));
        object defaultMethod = this.safeString(this.options, "createOrder", "privatePostTradeBatchOrders");
        object defaultTgtCcy = this.safeString(this.options, "tgtCcy", "base_ccy");
        object tgtCcy = this.safeString(parameters, "tgtCcy", defaultTgtCcy);
        if (isTrue(isTrue((!isTrue(contract))) && isTrue((!isTrue(margin)))))
        {
            ((Dictionary<string, object>)request)["tgtCcy"] = tgtCcy;
        }
        object method = defaultMethod;
        if (isTrue(isTrue(isMarketOrder) || isTrue(marketIOC)))
        {
            ((Dictionary<string, object>)request)["ordType"] = "market";
            if (isTrue(isTrue(spot) && isTrue((isEqual(side, "buy")))))
            {
                // spot market buy: "sz" can refer either to base currency units or to quote currency units
                // see documentation: https://www.okx.com/docs-v5/en/#rest-api-trade-place-order
                if (isTrue(isEqual(tgtCcy, "quote_ccy")))
                {
                    // quote_ccy: sz refers to units of quote currency
                    object notional = this.safeNumber2(parameters, "cost", "sz");
                    object createMarketBuyOrderRequiresPrice = this.safeValue(this.options, "createMarketBuyOrderRequiresPrice", true);
                    if (isTrue(createMarketBuyOrderRequiresPrice))
                    {
                        if (isTrue(!isEqual(price, null)))
                        {
                            if (isTrue(isEqual(notional, null)))
                            {
                                object amountString = this.numberToString(amount);
                                object priceString = this.numberToString(price);
                                object quoteAmount = Precise.stringMul(amountString, priceString);
                                notional = this.parseNumber(quoteAmount);
                            }
                        } else if (isTrue(isEqual(notional, null)))
                        {
                            throw new InvalidOrder ((string)add(this.id, " createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options[\'createMarketBuyOrderRequiresPrice\'] = false and supply the total cost value in the \'amount\' argument or in the \'cost\' unified extra parameter or in exchange-specific \'sz\' extra parameter (the exchange-specific behaviour)")) ;
                        }
                    } else
                    {
                        notional = ((bool) isTrue((isEqual(notional, null)))) ? amount : notional;
                    }
                    ((Dictionary<string, object>)request)["sz"] = this.costToPrecision(symbol, notional);
                    parameters = this.omit(parameters, new List<object>() {"cost", "sz"});
                }
            }
            if (isTrue(isTrue(marketIOC) && isTrue(contract)))
            {
                ((Dictionary<string, object>)request)["ordType"] = "optimal_limit_ioc";
            }
        } else
        {
            if (isTrue(isTrue((!isTrue(trigger))) && isTrue((!isTrue(conditional)))))
            {
                ((Dictionary<string, object>)request)["px"] = this.priceToPrecision(symbol, price);
            }
        }
        if (isTrue(postOnly))
        {
            method = defaultMethod;
            ((Dictionary<string, object>)request)["ordType"] = "post_only";
        } else if (isTrue(isTrue(ioc) && !isTrue(marketIOC)))
        {
            method = defaultMethod;
            ((Dictionary<string, object>)request)["ordType"] = "ioc";
        } else if (isTrue(fok))
        {
            method = defaultMethod;
            ((Dictionary<string, object>)request)["ordType"] = "fok";
        } else if (isTrue(trigger))
        {
            method = "privatePostTradeOrderAlgo";
            ((Dictionary<string, object>)request)["ordType"] = "trigger";
            ((Dictionary<string, object>)request)["triggerPx"] = this.priceToPrecision(symbol, triggerPrice);
            ((Dictionary<string, object>)request)["orderPx"] = ((bool) isTrue(isMarketOrder)) ? "-1" : this.priceToPrecision(symbol, price);
        } else if (isTrue(conditional))
        {
            method = "privatePostTradeOrderAlgo";
            ((Dictionary<string, object>)request)["ordType"] = "conditional";
            object twoWayCondition = (isTrue((!isEqual(takeProfitPrice, null))) && isTrue((!isEqual(stopLossPrice, null))));
            // if TP and SL are sent together
            // as ordType 'conditional' only stop-loss order will be applied
            if (isTrue(twoWayCondition))
            {
                ((Dictionary<string, object>)request)["ordType"] = "oco";
            }
            if (isTrue(!isEqual(takeProfitPrice, null)))
            {
                ((Dictionary<string, object>)request)["tpTriggerPx"] = this.priceToPrecision(symbol, takeProfitPrice);
                ((Dictionary<string, object>)request)["tpOrdPx"] = ((bool) isTrue((isEqual(tpOrdPx, null)))) ? "-1" : this.priceToPrecision(symbol, tpOrdPx);
                ((Dictionary<string, object>)request)["tpTriggerPxType"] = tpTriggerPxType;
            }
            if (isTrue(!isEqual(stopLossPrice, null)))
            {
                ((Dictionary<string, object>)request)["slTriggerPx"] = this.priceToPrecision(symbol, stopLossPrice);
                ((Dictionary<string, object>)request)["slOrdPx"] = ((bool) isTrue((isEqual(slOrdPx, null)))) ? "-1" : this.priceToPrecision(symbol, slOrdPx);
                ((Dictionary<string, object>)request)["slTriggerPxType"] = slTriggerPxType;
            }
        }
        if (isTrue(isTrue(isTrue(isTrue((isEqual(type, "oco"))) || isTrue((isEqual(type, "move_order_stop")))) || isTrue((isEqual(type, "iceberg")))) || isTrue((isEqual(type, "twap")))))
        {
            method = "privatePostTradeOrderAlgo";
        }
        if (isTrue(isEqual(clientOrderId, null)))
        {
            object brokerId = this.safeString(this.options, "brokerId");
            if (isTrue(!isEqual(brokerId, null)))
            {
                ((Dictionary<string, object>)request)["clOrdId"] = add(brokerId, this.uuid16());
                ((Dictionary<string, object>)request)["tag"] = brokerId;
            }
        } else
        {
            ((Dictionary<string, object>)request)["clOrdId"] = clientOrderId;
            parameters = this.omit(parameters, new List<object>() {"clOrdId", "clientOrderId"});
        }
        object extendedRequest = null;
        if (isTrue(isTrue((isEqual(method, "privatePostTradeOrder"))) || isTrue((isEqual(method, "privatePostTradeOrderAlgo")))))
        {
            extendedRequest = this.extend(request, parameters);
        } else if (isTrue(isEqual(method, "privatePostTradeBatchOrders")))
        {
            // keep the request body the same
            // submit a single order in an array to the batch order endpoint
            // because it has a lower ratelimit
            extendedRequest = new List<object> {this.extend(request, parameters)};
        } else
        {
            throw new ExchangeError ((string)add(this.id, " createOrder() this.options[\"createOrder\"] must be either privatePostTradeBatchOrders or privatePostTradeOrder")) ;
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { extendedRequest }));
        object data = this.safeValue(response, "data", new List<object>() {});
        object first = this.safeValue(data, 0);
        object order = this.parseOrder(first, market);
        return this.extend(order, new Dictionary<string, object>() {
            { "type", type },
            { "side", side },
        });
    }

    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name okx#editOrder
        * @description edit a trade order
        * @see https://www.okx.com/docs-v5/en/#rest-api-trade-amend-order
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of the currency you want to trade in units of the base currency
        * @param {float|undefined} price the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} params extra parameters specific to the okx api endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " editOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(add(add(this.id, " editOrder() does not support "), getValue(market, "type")), " orders, only spot orders are accepted")) ;
        }
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
        };
        object clientOrderId = this.safeString2(parameters, "clOrdId", "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((Dictionary<string, object>)request)["clOrdId"] = clientOrderId;
        } else
        {
            ((Dictionary<string, object>)request)["ordId"] = id;
        }
        parameters = this.omit(parameters, new List<object>() {"clOrdId", "clientOrderId"});
        if (isTrue(!isEqual(amount, null)))
        {
            ((Dictionary<string, object>)request)["newSz"] = this.amountToPrecision(symbol, amount);
        }
        if (isTrue(!isEqual(price, null)))
        {
            ((Dictionary<string, object>)request)["newPx"] = this.priceToPrecision(symbol, price);
        }
        object response = await this.callAsync("privatePostTradeAmendOrder", this.extend(request, parameters));
        //
        //     {
        //        "code": "0",
        //        "data": [
        //            {
        //                 "clOrdId": "e847386590ce4dBCc1a045253497a547",
        //                 "ordId": "559176536793178112",
        //                 "reqId": "",
        //                 "sCode": "0",
        //                 "sMsg": ""
        //            }
        //        ],
        //        "msg": ""
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object first = this.safeValue(data, 0);
        object order = this.parseOrder(first, market);
        return this.extend(order, new Dictionary<string, object>() {
            { "type", type },
            { "side", side },
        });
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name okx#cancelOrder
        * @description cancels an open order
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} params extra parameters specific to the okx api endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object stop = this.safeValue(parameters, "stop");
        if (isTrue(stop))
        {
            object orderInner = await this.cancelOrders(new List<object>() {id}, symbol, parameters);
            return this.safeValue(orderInner, 0);
        }
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
        };
        object clientOrderId = this.safeString2(parameters, "clOrdId", "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((Dictionary<string, object>)request)["clOrdId"] = clientOrderId;
        } else
        {
            ((Dictionary<string, object>)request)["ordId"] = id;
        }
        object query = this.omit(parameters, new List<object>() {"clOrdId", "clientOrderId"});
        object response = await this.privatePostTradeCancelOrder(this.extend(request, query));
        // {"code":"0","data":[{"clOrdId":"","ordId":"317251910906576896","sCode":"0","sMsg":""}],"msg":""}
        object data = this.safeValue(response, "data", new List<object>() {});
        object order = this.safeValue(data, 0);
        return this.parseOrder(order, market);
    }

    public virtual object parseIds(object ids)
    {
        /**
         * @ignore
         * @method
         * @name okx#parseIds
         * @param {[str]|str} ids order ids
         * @returns {[str]} list of order ids
         */
        if (isTrue(((ids).GetType() == typeof(string))))
        {
            return ((string)ids).Split((string)",").ToList<object>();
        } else
        {
            return ids;
        }
    }

    public async virtual Task<object> cancelOrders(object ids, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name okx#cancelOrders
        * @description cancel multiple orders
        * @param {[string]} ids order ids
        * @param {string} symbol unified market symbol
        * @param {object} params extra parameters specific to the okx api endpoint
        * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        // TODO : the original endpoint signature differs, according to that you can skip individual symbol and assign ids in batch. At this moment, `params` is not being used too.
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new List<object>() {};
        object options = this.safeValue(this.options, "cancelOrders", new Dictionary<string, object>() {});
        object defaultMethod = this.safeString(options, "method", "privatePostTradeCancelBatchOrders");
        object method = this.safeString(parameters, "method", defaultMethod);
        object clientOrderIds = this.parseIds(this.safeValue2(parameters, "clOrdId", "clientOrderId"));
        object algoIds = this.parseIds(this.safeValue(parameters, "algoId"));
        object stop = this.safeValue(parameters, "stop");
        if (isTrue(stop))
        {
            method = "privatePostTradeCancelAlgos";
        }
        if (isTrue(isEqual(clientOrderIds, null)))
        {
            ids = this.parseIds(ids);
            if (isTrue(!isEqual(algoIds, null)))
            {
                for (object i = 0; isLessThan(i, getArrayLength(algoIds)); postFixIncrement(ref i))
                {
                    ((List<object>)request).Add(new Dictionary<string, object>() {
                        { "algoId", getValue(algoIds, i) },
                        { "instId", getValue(market, "id") },
                    });
                }
            }
            for (object i = 0; isLessThan(i, getArrayLength(ids)); postFixIncrement(ref i))
            {
                if (isTrue(stop))
                {
                    ((List<object>)request).Add(new Dictionary<string, object>() {
                        { "algoId", getValue(ids, i) },
                        { "instId", getValue(market, "id") },
                    });
                } else
                {
                    ((List<object>)request).Add(new Dictionary<string, object>() {
                        { "ordId", getValue(ids, i) },
                        { "instId", getValue(market, "id") },
                    });
                }
            }
        } else
        {
            for (object i = 0; isLessThan(i, getArrayLength(clientOrderIds)); postFixIncrement(ref i))
            {
                ((List<object>)request).Add(new Dictionary<string, object>() {
                    { "instId", getValue(market, "id") },
                    { "clOrdId", getValue(clientOrderIds, i) },
                });
            }
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { request })); // * dont extend with params, otherwise ARRAY will be turned into OBJECT
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "clOrdId": "e123456789ec4dBC1123456ba123b45e",
        //                 "ordId": "405071912345641543",
        //                 "sCode": "0",
        //                 "sMsg": ""
        //             },
        //             ...
        //         ],
        //         "msg": ""
        //     }
        //
        // Algo order
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "algoId": "431375349042380800",
        //                 "sCode": "0",
        //                 "sMsg": ""
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        object ordersData = this.safeValue(response, "data", new List<object>() {});
        return this.parseOrders(ordersData, market, null, null, parameters);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "canceled", "canceled" },
            { "live", "open" },
            { "partially_filled", "open" },
            { "filled", "closed" },
            { "effective", "closed" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // createOrder
        //
        //     {
        //         "clOrdId": "oktswap6",
        //         "ordId": "312269865356374016",
        //         "tag": "",
        //         "sCode": "0",
        //         "sMsg": ""
        //     }
        //
        // editOrder
        //
        //     {
        //         "clOrdId": "e847386590ce4dBCc1a045253497a547",
        //         "ordId": "559176536793178112",
        //         "reqId": "",
        //         "sCode": "0",
        //         "sMsg": ""
        //     }
        //
        // Spot and Swap fetchOrder, fetchOpenOrders
        //
        //     {
        //         "accFillSz": "0",
        //         "avgPx": "",
        //         "cTime": "1621910749815",
        //         "category": "normal",
        //         "ccy": "",
        //         "clOrdId": "",
        //         "fee": "0",
        //         "feeCcy": "ETH",
        //         "fillPx": "",
        //         "fillSz": "0",
        //         "fillTime": "",
        //         "instId": "ETH-USDT",
        //         "instType": "SPOT",
        //         "lever": "",
        //         "ordId": "317251910906576896",
        //         "ordType": "limit",
        //         "pnl": "0",
        //         "posSide": "net",
        //         "px": "2000",
        //         "rebate": "0",
        //         "rebateCcy": "USDT",
        //         "side": "buy",
        //         "slOrdPx": "",
        //         "slTriggerPx": "",
        //         "state": "live",
        //         "sz": "0.001",
        //         "tag": "",
        //         "tdMode": "cash",
        //         "tpOrdPx": "",
        //         "tpTriggerPx": "",
        //         "tradeId": "",
        //         "uTime": "1621910749815"
        //     }
        //
        // Algo Order fetchOpenOrders, fetchCanceledOrders, fetchClosedOrders
        //
        //     {
        //         "activePx": "",
        //         "activePxType": "",
        //         "actualPx": "",
        //         "actualSide": "buy",
        //         "actualSz": "0",
        //         "algoId": "431375349042380800",
        //         "cTime": "1649119897778",
        //         "callbackRatio": "",
        //         "callbackSpread": "",
        //         "ccy": "",
        //         "ctVal": "0.01",
        //         "instId": "BTC-USDT-SWAP",
        //         "instType": "SWAP",
        //         "last": "46538.9",
        //         "lever": "125",
        //         "moveTriggerPx": "",
        //         "notionalUsd": "467.059",
        //         "ordId": "",
        //         "ordPx": "50000",
        //         "ordType": "trigger",
        //         "posSide": "long",
        //         "pxLimit": "",
        //         "pxSpread": "",
        //         "pxVar": "",
        //         "side": "buy",
        //         "slOrdPx": "",
        //         "slTriggerPx": "",
        //         "slTriggerPxType": "",
        //         "state": "live",
        //         "sz": "1",
        //         "szLimit": "",
        //         "tag": "",
        //         "tdMode": "isolated",
        //         "tgtCcy": "",
        //         "timeInterval": "",
        //         "tpOrdPx": "",
        //         "tpTriggerPx": "",
        //         "tpTriggerPxType": "",
        //         "triggerPx": "50000",
        //         "triggerPxType": "last",
        //         "triggerTime": "",
        //         "uly": "BTC-USDT"
        //     }
        //
        object id = this.safeString2(order, "algoId", "ordId");
        object timestamp = this.safeInteger(order, "cTime");
        object lastTradeTimestamp = this.safeInteger(order, "fillTime");
        object side = this.safeString(order, "side");
        object type = this.safeString(order, "ordType");
        object postOnly = null;
        object timeInForce = null;
        if (isTrue(isEqual(type, "post_only")))
        {
            postOnly = true;
            type = "limit";
        } else if (isTrue(isEqual(type, "fok")))
        {
            timeInForce = "FOK";
            type = "limit";
        } else if (isTrue(isEqual(type, "ioc")))
        {
            timeInForce = "IOC";
            type = "limit";
        }
        object marketId = this.safeString(order, "instId");
        object symbol = this.safeSymbol(marketId, market, "-");
        object filled = this.safeString(order, "accFillSz");
        object price = this.safeString2(order, "px", "ordPx");
        object average = this.safeString(order, "avgPx");
        object status = this.parseOrderStatus(this.safeString(order, "state"));
        object feeCostString = this.safeString(order, "fee");
        object amount = null;
        object cost = null;
        // spot market buy: "sz" can refer either to base currency units or to quote currency units
        // see documentation: https://www.okx.com/docs-v5/en/#rest-api-trade-place-order
        object defaultTgtCcy = this.safeString(this.options, "tgtCcy", "base_ccy");
        object tgtCcy = this.safeString(order, "tgtCcy", defaultTgtCcy);
        object instType = this.safeString(order, "instType");
        if (isTrue(isTrue(isTrue(isTrue((isEqual(side, "buy"))) && isTrue((isEqual(type, "market")))) && isTrue((isEqual(instType, "SPOT")))) && isTrue((isEqual(tgtCcy, "quote_ccy")))))
        {
            // "sz" refers to the cost
            cost = this.safeString(order, "sz");
        } else
        {
            // "sz" refers to the trade currency amount
            amount = this.safeString(order, "sz");
        }
        object fee = null;
        if (isTrue(!isEqual(feeCostString, null)))
        {
            object feeCostSigned = Precise.stringNeg(feeCostString);
            object feeCurrencyId = this.safeString(order, "feeCcy");
            object feeCurrencyCode = this.safeCurrencyCode(feeCurrencyId);
            fee = new Dictionary<string, object>() {
                { "cost", this.parseNumber(feeCostSigned) },
                { "currency", feeCurrencyCode },
            };
        }
        object clientOrderId = this.safeString(order, "clOrdId");
        if (isTrue(isTrue((!isEqual(clientOrderId, null))) && isTrue((isLessThan(((string)clientOrderId).Length, 1)))))
        {
            clientOrderId = null; // fix empty clientOrderId string
        }
        object stopLossPrice = this.safeNumber2(order, "slTriggerPx", "slOrdPx");
        object takeProfitPrice = this.safeNumber2(order, "tpTriggerPx", "tpOrdPx");
        object stopPrice = this.safeNumberN(order, new List<object>() {"triggerPx", "moveTriggerPx"});
        object reduceOnlyRaw = this.safeString(order, "reduceOnly");
        object reduceOnly = false;
        if (isTrue(!isEqual(reduceOnly, null)))
        {
            reduceOnly = (isEqual(reduceOnlyRaw, "true"));
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", id },
            { "clientOrderId", clientOrderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", lastTradeTimestamp },
            { "symbol", symbol },
            { "type", type },
            { "timeInForce", timeInForce },
            { "postOnly", postOnly },
            { "side", side },
            { "price", price },
            { "stopLossPrice", stopLossPrice },
            { "takeProfitPrice", takeProfitPrice },
            { "stopPrice", stopPrice },
            { "triggerPrice", stopPrice },
            { "average", average },
            { "cost", cost },
            { "amount", amount },
            { "filled", filled },
            { "remaining", null },
            { "status", status },
            { "fee", fee },
            { "trades", null },
            { "reduceOnly", reduceOnly },
        }, market);
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name okx#fetchOrder
        * @description fetch an order by the id
        * @param {string} id the order id
        * @param {string} symbol unified market symbol
        * @param {object} params extra and exchange specific parameters
        * @returns [an order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
        };
        object clientOrderId = this.safeString2(parameters, "clOrdId", "clientOrderId");
        object options = this.safeValue(this.options, "fetchOrder", new Dictionary<string, object>() {});
        object defaultMethod = this.safeString(options, "method", "privateGetTradeOrder");
        object method = this.safeString(parameters, "method", defaultMethod);
        object stop = this.safeValue(parameters, "stop");
        if (isTrue(stop))
        {
            method = "privateGetTradeOrderAlgo";
            if (isTrue(!isEqual(clientOrderId, null)))
            {
                ((Dictionary<string, object>)request)["algoClOrdId"] = clientOrderId;
            } else
            {
                ((Dictionary<string, object>)request)["algoId"] = id;
            }
        } else
        {
            if (isTrue(!isEqual(clientOrderId, null)))
            {
                ((Dictionary<string, object>)request)["clOrdId"] = clientOrderId;
            } else
            {
                ((Dictionary<string, object>)request)["ordId"] = id;
            }
        }
        object query = this.omit(parameters, new List<object>() {"method", "clOrdId", "clientOrderId", "stop"});
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        //
        // Spot and Swap
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "accFillSz": "0",
        //                 "avgPx": "",
        //                 "cTime": "1621910749815",
        //                 "category": "normal",
        //                 "ccy": "",
        //                 "clOrdId": "",
        //                 "fee": "0",
        //                 "feeCcy": "ETH",
        //                 "fillPx": "",
        //                 "fillSz": "0",
        //                 "fillTime": "",
        //                 "instId": "ETH-USDT",
        //                 "instType": "SPOT",
        //                 "lever": "",
        //                 "ordId": "317251910906576896",
        //                 "ordType": "limit",
        //                 "pnl": "0",
        //                 "posSide": "net",
        //                 "px":"20 00",
        //                 "rebate": "0",
        //                 "rebateCcy": "USDT",
        //                 "side": "buy",
        //                 "slOrdPx": "",
        //                 "slTriggerPx": "",
        //                 "state": "live",
        //                 "sz":"0. 001",
        //                 "tag": "",
        //                 "tdMode": "cash",
        //                 "tpOrdPx": "",
        //                 "tpTriggerPx": "",
        //                 "tradeId": "",
        //                 "uTime": "1621910749815"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        // Algo order
        //     {
        //         "code":"0",
        //         "msg":"",
        //         "data":[
        //             {
        //                 "instType":"FUTURES",
        //                 "instId":"BTC-USD-200329",
        //                 "ordId":"123445",
        //                 "ccy":"BTC",
        //                 "clOrdId":"",
        //                 "algoId":"1234",
        //                 "sz":"999",
        //                 "closeFraction":"",
        //                 "ordType":"oco",
        //                 "side":"buy",
        //                 "posSide":"long",
        //                 "tdMode":"cross",
        //                 "tgtCcy": "",
        //                 "state":"effective",
        //                 "lever":"20",
        //                 "tpTriggerPx":"",
        //                 "tpTriggerPxType":"",
        //                 "tpOrdPx":"",
        //                 "slTriggerPx":"",
        //                 "slTriggerPxType":"",
        //                 "triggerPx":"99",
        //                 "triggerPxType":"last",
        //                 "ordPx":"12",
        //                 "actualSz":"",
        //                 "actualPx":"",
        //                 "actualSide":"",
        //                 "pxVar":"",
        //                 "pxSpread":"",
        //                 "pxLimit":"",
        //                 "szLimit":"",
        //                 "tag": "adadadadad",
        //                 "timeInterval":"",
        //                 "callbackRatio":"",
        //                 "callbackSpread":"",
        //                 "activePx":"",
        //                 "moveTriggerPx":"",
        //                 "reduceOnly": "false",
        //                 "triggerTime":"1597026383085",
        //                 "last": "16012",
        //                 "failCode": "",
        //                 "algoClOrdId": "",
        //                 "cTime":"1597026383000"
        //             }
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object order = this.safeValue(data, 0);
        return this.parseOrder(order, market);
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name okx#fetchOpenOrders
        * @description Fetch orders that are still open
        * @description fetch all unfilled currently open orders
        * @param {string|undefined} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch open orders for
        * @param {int|undefined} limit the maximum number of  open orders structures to retrieve
        * @param {object} params extra parameters specific to the okx api endpoint
        * @param {int} params.till Timestamp in ms of the latest time to retrieve orders for
        * @param {bool} params.stop True if fetching trigger or conditional orders
        * @param {string} params.ordType "conditional", "oco", "trigger", "move_order_stop", "iceberg", or "twap"
        * @param {string|undefined} params.algoId Algo ID "'433845797218942976'"
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((Dictionary<string, object>)request)["instId"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit; // default 100, max 100
        }
        object options = this.safeValue(this.options, "fetchOpenOrders", new Dictionary<string, object>() {});
        object algoOrderTypes = this.safeValue(this.options, "algoOrderTypes", new Dictionary<string, object>() {});
        object defaultMethod = this.safeString(options, "method", "privateGetTradeOrdersPending");
        object method = this.safeString(parameters, "method", defaultMethod);
        object ordType = this.safeString(parameters, "ordType");
        object stop = this.safeValue(parameters, "stop");
        if (isTrue(isTrue(stop) || isTrue((((Dictionary<string,object>)algoOrderTypes).ContainsKey(toStringOrNull(ordType))))))
        {
            method = "privateGetTradeOrdersAlgoPending";
            if (isTrue(stop))
            {
                if (isTrue(isEqual(ordType, null)))
                {
                    throw new ArgumentsRequired ((string)add(this.id, " fetchOpenOrders() requires an \"ordType\" string parameter, \"conditional\", \"oco\", \"trigger\", \"move_order_stop\", \"iceberg\", or \"twap\"")) ;
                }
            }
        }
        object query = this.omit(parameters, new List<object>() {"method", "stop"});
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "accFillSz": "0",
        //                 "avgPx": "",
        //                 "cTime": "1621910749815",
        //                 "category": "normal",
        //                 "ccy": "",
        //                 "clOrdId": "",
        //                 "fee": "0",
        //                 "feeCcy": "ETH",
        //                 "fillPx": "",
        //                 "fillSz": "0",
        //                 "fillTime": "",
        //                 "instId": "ETH-USDT",
        //                 "instType": "SPOT",
        //                 "lever": "",
        //                 "ordId": "317251910906576896",
        //                 "ordType": "limit",
        //                 "pnl": "0",
        //                 "posSide": "net",
        //                 "px":"20 00",
        //                 "rebate": "0",
        //                 "rebateCcy": "USDT",
        //                 "side": "buy",
        //                 "slOrdPx": "",
        //                 "slTriggerPx": "",
        //                 "state": "live",
        //                 "sz":"0. 001",
        //                 "tag": "",
        //                 "tdMode": "cash",
        //                 "tpOrdPx": "",
        //                 "tpTriggerPx": "",
        //                 "tradeId": "",
        //                 "uTime": "1621910749815"
        //             }
        //         ],
        //         "msg":""
        //     }
        //
        // Algo order
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "activePx": "",
        //                 "activePxType": "",
        //                 "actualPx": "",
        //                 "actualSide": "buy",
        //                 "actualSz": "0",
        //                 "algoId": "431375349042380800",
        //                 "cTime": "1649119897778",
        //                 "callbackRatio": "",
        //                 "callbackSpread": "",
        //                 "ccy": "",
        //                 "ctVal": "0.01",
        //                 "instId": "BTC-USDT-SWAP",
        //                 "instType": "SWAP",
        //                 "last": "46538.9",
        //                 "lever": "125",
        //                 "moveTriggerPx": "",
        //                 "notionalUsd": "467.059",
        //                 "ordId": "",
        //                 "ordPx": "50000",
        //                 "ordType": "trigger",
        //                 "posSide": "long",
        //                 "pxLimit": "",
        //                 "pxSpread": "",
        //                 "pxVar": "",
        //                 "side": "buy",
        //                 "slOrdPx": "",
        //                 "slTriggerPx": "",
        //                 "slTriggerPxType": "",
        //                 "state": "live",
        //                 "sz": "1",
        //                 "szLimit": "",
        //                 "tag": "",
        //                 "tdMode": "isolated",
        //                 "tgtCcy": "",
        //                 "timeInterval": "",
        //                 "tpOrdPx": "",
        //                 "tpTriggerPx": "",
        //                 "tpTriggerPxType": "",
        //                 "triggerPx": "50000",
        //                 "triggerPxType": "last",
        //                 "triggerTime": "",
        //                 "uly": "BTC-USDT"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        return this.parseOrders(data, market, since, limit);
    }

    public async virtual Task<object> fetchCanceledOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name okx#fetchCanceledOrders
        * @description fetches information on multiple canceled orders made by the user
        * @param {string|undefined} symbol unified market symbol of the market orders were made in
        * @param {int|undefined} since timestamp in ms of the earliest order, default is undefined
        * @param {int|undefined} limit max number of orders to return, default is undefined
        * @param {object} params extra parameters specific to the okx api endpoint
        * @param {bool} params.stop True if fetching trigger or conditional orders
        * @param {string} params.ordType "conditional", "oco", "trigger", "move_order_stop", "iceberg", or "twap"
        * @param {string|undefined} params.algoId Algo ID "'433845797218942976'"
        * @param {int|undefined} params.until timestamp in ms to fetch orders for
        * @returns {object} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((Dictionary<string, object>)request)["instId"] = getValue(market, "id");
        }
        object type = null;
        object query = null;
        var typequeryVariable = this.handleMarketTypeAndParams("fetchCanceledOrders", market, parameters);
        type = ((List<object>)typequeryVariable)[0];
        query = ((List<object>)typequeryVariable)[1];
        ((Dictionary<string, object>)request)["instType"] = this.convertToInstrumentType(type);
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit; // default 100, max 100
        }
        ((Dictionary<string, object>)request)["state"] = "canceled";
        object options = this.safeValue(this.options, "fetchCanceledOrders", new Dictionary<string, object>() {});
        object algoOrderTypes = this.safeValue(this.options, "algoOrderTypes", new Dictionary<string, object>() {});
        object defaultMethod = this.safeString(options, "method", "privateGetTradeOrdersHistory");
        object method = this.safeString(parameters, "method", defaultMethod);
        object ordType = this.safeString(parameters, "ordType");
        object stop = this.safeValue(parameters, "stop");
        if (isTrue(isTrue(stop) || isTrue((((Dictionary<string,object>)algoOrderTypes).ContainsKey(toStringOrNull(ordType))))))
        {
            method = "privateGetTradeOrdersAlgoHistory";
            object algoId = this.safeString(parameters, "algoId");
            if (isTrue(!isEqual(algoId, null)))
            {
                ((Dictionary<string, object>)request)["algoId"] = algoId;
                parameters = this.omit(parameters, "algoId");
            }
            if (isTrue(stop))
            {
                if (isTrue(isEqual(ordType, null)))
                {
                    throw new ArgumentsRequired ((string)add(this.id, " fetchCanceledOrders() requires an \"ordType\" string parameter, \"conditional\", \"oco\", \"trigger\", \"move_order_stop\", \"iceberg\", or \"twap\"")) ;
                }
                ((Dictionary<string, object>)request)["ordType"] = ordType;
            }
        } else
        {
            if (isTrue(!isEqual(since, null)))
            {
                ((Dictionary<string, object>)request)["begin"] = since;
            }
            object until = this.safeInteger2(query, "till", "until");
            if (isTrue(!isEqual(until, null)))
            {
                ((Dictionary<string, object>)request)["end"] = until;
                query = this.omit(query, new List<object>() {"until", "till"});
            }
        }
        object send = this.omit(query, new List<object>() {"method", "stop", "ordType"});
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, send) }));
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "accFillSz": "0",
        //                 "avgPx": "",
        //                 "cTime": "1644037822494",
        //                 "category": "normal",
        //                 "ccy": "",
        //                 "clOrdId": "",
        //                 "fee": "0",
        //                 "feeCcy": "BTC",
        //                 "fillPx": "",
        //                 "fillSz": "0",
        //                 "fillTime": "",
        //                 "instId": "BTC-USDT",
        //                 "instType": "SPOT",
        //                 "lever": "",
        //                 "ordId": "410059580352409602",
        //                 "ordType": "limit",
        //                 "pnl": "0",
        //                 "posSide": "net",
        //                 "px": "30000",
        //                 "rebate": "0",
        //                 "rebateCcy": "USDT",
        //                 "side": "buy",
        //                 "slOrdPx": "",
        //                 "slTriggerPx": "",
        //                 "slTriggerPxType": "",
        //                 "source": "",
        //                 "state": "canceled",
        //                 "sz": "0.0005452",
        //                 "tag": "",
        //                 "tdMode": "cash",
        //                 "tgtCcy": "",
        //                 "tpOrdPx": "",
        //                 "tpTriggerPx": "",
        //                 "tpTriggerPxType": "",
        //                 "tradeId": "",
        //                 "uTime": "1644038165667"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        // Algo order
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "activePx": "",
        //                 "activePxType": "",
        //                 "actualPx": "",
        //                 "actualSide": "buy",
        //                 "actualSz": "0",
        //                 "algoId": "433845797218942976",
        //                 "cTime": "1649708898523",
        //                 "callbackRatio": "",
        //                 "callbackSpread": "",
        //                 "ccy": "",
        //                 "ctVal": "0.01",
        //                 "instId": "BTC-USDT-SWAP",
        //                 "instType": "SWAP",
        //                 "last": "39950.4",
        //                 "lever": "125",
        //                 "moveTriggerPx": "",
        //                 "notionalUsd": "1592.1760000000002",
        //                 "ordId": "",
        //                 "ordPx": "29000",
        //                 "ordType": "trigger",
        //                 "posSide": "long",
        //                 "pxLimit": "",
        //                 "pxSpread": "",
        //                 "pxVar": "",
        //                 "side": "buy",
        //                 "slOrdPx": "",
        //                 "slTriggerPx": "",
        //                 "slTriggerPxType": "",
        //                 "state": "canceled",
        //                 "sz": "4",
        //                 "szLimit": "",
        //                 "tag": "",
        //                 "tdMode": "isolated",
        //                 "tgtCcy": "",
        //                 "timeInterval": "",
        //                 "tpOrdPx": "",
        //                 "tpTriggerPx": "",
        //                 "tpTriggerPxType": "",
        //                 "triggerPx": "30000",
        //                 "triggerPxType": "last",
        //                 "triggerTime": "",
        //                 "uly": "BTC-USDT"
        //             },
        //         ],
        //         "msg": ""
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        return this.parseOrders(data, market, since, limit);
    }

    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name okx#fetchClosedOrders
        * @description fetches information on multiple closed orders made by the user
        * @param {string|undefined} symbol unified market symbol of the market orders were made in
        * @param {int|undefined} since the earliest time in ms to fetch orders for
        * @param {int|undefined} limit the maximum number of  orde structures to retrieve
        * @param {object} params extra parameters specific to the okx api endpoint
        * @param {bool} params.stop True if fetching trigger or conditional orders
        * @param {string} params.ordType "conditional", "oco", "trigger", "move_order_stop", "iceberg", or "twap"
        * @param {string|undefined} params.algoId Algo ID "'433845797218942976'"
        * @param {int|undefined} params.until timestamp in ms to fetch orders for
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((Dictionary<string, object>)request)["instId"] = getValue(market, "id");
        }
        object type = null;
        object query = null;
        var typequeryVariable = this.handleMarketTypeAndParams("fetchClosedOrders", market, parameters);
        type = ((List<object>)typequeryVariable)[0];
        query = ((List<object>)typequeryVariable)[1];
        ((Dictionary<string, object>)request)["instType"] = this.convertToInstrumentType(type);
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit; // default 100, max 100
        }
        object options = this.safeValue(this.options, "fetchClosedOrders", new Dictionary<string, object>() {});
        object algoOrderTypes = this.safeValue(this.options, "algoOrderTypes", new Dictionary<string, object>() {});
        object defaultMethod = this.safeString(options, "method", "privateGetTradeOrdersHistory");
        object method = this.safeString(parameters, "method", defaultMethod);
        object ordType = this.safeString(parameters, "ordType");
        object stop = this.safeValue(parameters, "stop");
        if (isTrue(isTrue(stop) || isTrue((((Dictionary<string,object>)algoOrderTypes).ContainsKey(toStringOrNull(ordType))))))
        {
            method = "privateGetTradeOrdersAlgoHistory";
            if (isTrue(stop))
            {
                if (isTrue(isEqual(ordType, null)))
                {
                    throw new ArgumentsRequired ((string)add(this.id, " fetchClosedOrders() requires an \"ordType\" string parameter, \"conditional\", \"oco\", \"trigger\", \"move_order_stop\", \"iceberg\", or \"twap\"")) ;
                }
            }
            ((Dictionary<string, object>)request)["state"] = "effective";
        } else
        {
            if (isTrue(!isEqual(since, null)))
            {
                ((Dictionary<string, object>)request)["begin"] = since;
            }
            object until = this.safeInteger2(query, "till", "until");
            if (isTrue(!isEqual(until, null)))
            {
                ((Dictionary<string, object>)request)["end"] = until;
                query = this.omit(query, new List<object>() {"until", "till"});
            }
            ((Dictionary<string, object>)request)["state"] = "filled";
        }
        object send = this.omit(query, new List<object>() {"method", "stop"});
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, send) }));
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "accFillSz": "0",
        //                 "avgPx": "",
        //                 "cTime": "1621910749815",
        //                 "category": "normal",
        //                 "ccy": "",
        //                 "clOrdId": "",
        //                 "fee": "0",
        //                 "feeCcy": "ETH",
        //                 "fillPx": "",
        //                 "fillSz": "0",
        //                 "fillTime": "",
        //                 "instId": "ETH-USDT",
        //                 "instType": "SPOT",
        //                 "lever": "",
        //                 "ordId": "317251910906576896",
        //                 "ordType": "limit",
        //                 "pnl": "0",
        //                 "posSide": "net",
        //                 "px": "2000",
        //                 "rebate": "0",
        //                 "rebateCcy": "USDT",
        //                 "side": "buy",
        //                 "slOrdPx": "",
        //                 "slTriggerPx": "",
        //                 "state": "live",
        //                 "sz": "0.001",
        //                 "tag": "",
        //                 "tdMode": "cash",
        //                 "tpOrdPx": "",
        //                 "tpTriggerPx": "",
        //                 "tradeId": "",
        //                 "uTime": "1621910749815"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        // Algo order
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "activePx": "",
        //                 "activePxType": "",
        //                 "actualPx": "",
        //                 "actualSide": "buy",
        //                 "actualSz": "0",
        //                 "algoId": "433845797218942976",
        //                 "cTime": "1649708898523",
        //                 "callbackRatio": "",
        //                 "callbackSpread": "",
        //                 "ccy": "",
        //                 "ctVal": "0.01",
        //                 "instId": "BTC-USDT-SWAP",
        //                 "instType": "SWAP",
        //                 "last": "39950.4",
        //                 "lever": "125",
        //                 "moveTriggerPx": "",
        //                 "notionalUsd": "1592.1760000000002",
        //                 "ordId": "",
        //                 "ordPx": "29000",
        //                 "ordType": "trigger",
        //                 "posSide": "long",
        //                 "pxLimit": "",
        //                 "pxSpread": "",
        //                 "pxVar": "",
        //                 "side": "buy",
        //                 "slOrdPx": "",
        //                 "slTriggerPx": "",
        //                 "slTriggerPxType": "",
        //                 "state": "effective",
        //                 "sz": "4",
        //                 "szLimit": "",
        //                 "tag": "",
        //                 "tdMode": "isolated",
        //                 "tgtCcy": "",
        //                 "timeInterval": "",
        //                 "tpOrdPx": "",
        //                 "tpTriggerPx": "",
        //                 "tpTriggerPxType": "",
        //                 "triggerPx": "30000",
        //                 "triggerPxType": "last",
        //                 "triggerTime": "",
        //                 "uly": "BTC-USDT"
        //             },
        //         ],
        //         "msg": ""
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        return this.parseOrders(data, market, since, limit);
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name okx#fetchMyTrades
        * @description fetch all trades made by the user
        * @param {string|undefined} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch trades for
        * @param {int|undefined} limit the maximum number of trades structures to retrieve
        * @param {object} params extra parameters specific to the okx api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((Dictionary<string, object>)request)["instId"] = getValue(market, "id");
        }
        var typequeryVariable = this.handleMarketTypeAndParams("fetchMyTrades", market, parameters);
        var type = ((List<object>) typequeryVariable)[0];
        var query = ((List<object>) typequeryVariable)[1];
        ((Dictionary<string, object>)request)["instType"] = this.convertToInstrumentType(type);
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit; // default 100, max 100
        }
        object response = await this.privateGetTradeFillsHistory(this.extend(request, query));
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "side": "buy",
        //                 "fillSz": "0.007533",
        //                 "fillPx": "2654.98",
        //                 "fee": "-0.000007533",
        //                 "ordId": "317321390244397056",
        //                 "instType": "SPOT",
        //                 "instId": "ETH-USDT",
        //                 "clOrdId": "",
        //                 "posSide": "net",
        //                 "billId": "317321390265368576",
        //                 "tag": "0",
        //                 "execType": "T",
        //                 "tradeId": "107601752",
        //                 "feeCcy": "ETH",
        //                 "ts": "1621927314985"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        return this.parseTrades(data, market, since, limit, query);
    }

    public async override Task<object> fetchOrderTrades(object id, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name okx#fetchOrderTrades
        * @description fetch all the trades made from a single order
        * @param {string} id order id
        * @param {string|undefined} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch trades for
        * @param {int|undefined} limit the maximum number of trades to retrieve
        * @param {object} params extra parameters specific to the okx api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "ordId", id },
        };
        return await this.fetchMyTrades(symbol, since, limit, this.extend(request, parameters));
    }

    public async override Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name okx#fetchLedger
        * @description fetch the history of changes, actions done by the user or operations that altered balance of the user
        * @see https://www.okx.com/docs-v5/en/#rest-api-account-get-bills-details-last-7-days
        * @see https://www.okx.com/docs-v5/en/#rest-api-account-get-bills-details-last-3-months
        * @see https://www.okx.com/docs-v5/en/#rest-api-funding-asset-bills-details
        * @param {string|undefined} code unified currency code, default is undefined
        * @param {int|undefined} since timestamp in ms of the earliest ledger entry, default is undefined
        * @param {int|undefined} limit max number of ledger entrys to return, default is undefined
        * @param {object} params extra parameters specific to the okx api endpoint
        * @param {string|undefined} params.marginMode 'cross' or 'isolated'
        * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object options = this.safeValue(this.options, "fetchLedger", new Dictionary<string, object>() {});
        object method = this.safeString(options, "method");
        method = this.safeString(parameters, "method", method);
        parameters = this.omit(parameters, "method");
        object request = new Dictionary<string, object>() {};
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchLedger", parameters);
        marginMode = ((List<object>)marginModeparametersVariable)[0];
        parameters = ((List<object>)marginModeparametersVariable)[1];
        if (isTrue(isEqual(marginMode, null)))
        {
            marginMode = this.safeString(parameters, "mgnMode");
        }
        if (isTrue(!isEqual(method, "privateGetAssetBills")))
        {
            if (isTrue(!isEqual(marginMode, null)))
            {
                ((Dictionary<string, object>)request)["mgnMode"] = marginMode;
            }
        }
        var typequeryVariable = this.handleMarketTypeAndParams("fetchLedger", null, parameters);
        var type = ((List<object>) typequeryVariable)[0];
        var query = ((List<object>) typequeryVariable)[1];
        if (isTrue(!isEqual(type, null)))
        {
            ((Dictionary<string, object>)request)["instType"] = this.convertToInstrumentType(type);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((Dictionary<string, object>)request)["ccy"] = getValue(currency, "id");
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        //
        // privateGetAccountBills, privateGetAccountBillsArchive
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "bal": "0.0000819307998198",
        //                 "balChg": "-664.2679586599999802",
        //                 "billId": "310394313544966151",
        //                 "ccy": "USDT",
        //                 "fee": "0",
        //                 "from": "",
        //                 "instId": "LTC-USDT",
        //                 "instType": "SPOT",
        //                 "mgnMode": "cross",
        //                 "notes": "",
        //                 "ordId": "310394313519800320",
        //                 "pnl": "0",
        //                 "posBal": "0",
        //                 "posBalChg": "0",
        //                 "subType": "2",
        //                 "sz": "664.26795866",
        //                 "to": "",
        //                 "ts": "1620275771196",
        //                 "type": "2"
        //             }
        //         ]
        //     }
        //
        // privateGetAssetBills
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "billId": "12344",
        //                 "ccy": "BTC",
        //                 "balChg": "2",
        //                 "bal": "12",
        //                 "type": "1",
        //                 "ts": "1597026383085"
        //             }
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        return this.parseLedger(data, currency, since, limit);
    }

    public virtual object parseLedgerEntryType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "1", "transfer" },
            { "2", "trade" },
            { "3", "trade" },
            { "4", "rebate" },
            { "5", "trade" },
            { "6", "transfer" },
            { "7", "trade" },
            { "8", "fee" },
            { "9", "trade" },
            { "10", "trade" },
            { "11", "trade" },
        };
        return this.safeString(types, type, type);
    }

    public override object parseLedgerEntry(object item, object currency = null)
    {
        //
        // privateGetAccountBills, privateGetAccountBillsArchive
        //
        //     {
        //         "bal": "0.0000819307998198",
        //         "balChg": "-664.2679586599999802",
        //         "billId": "310394313544966151",
        //         "ccy": "USDT",
        //         "fee": "0",
        //         "from": "",
        //         "instId": "LTC-USDT",
        //         "instType": "SPOT",
        //         "mgnMode": "cross",
        //         "notes": "",
        //         "ordId": "310394313519800320",
        //         "pnl": "0",
        //         "posBal": "0",
        //         "posBalChg": "0",
        //         "subType": "2",
        //         "sz": "664.26795866",
        //         "to": "",
        //         "ts": "1620275771196",
        //         "type": "2"
        //     }
        //
        // privateGetAssetBills
        //
        //     {
        //         "billId": "12344",
        //         "ccy": "BTC",
        //         "balChg": "2",
        //         "bal": "12",
        //         "type": "1",
        //         "ts": "1597026383085"
        //     }
        //
        object id = this.safeString(item, "billId");
        object account = null;
        object referenceId = this.safeString(item, "ordId");
        object referenceAccount = null;
        object type = this.parseLedgerEntryType(this.safeString(item, "type"));
        object code = this.safeCurrencyCode(this.safeString(item, "ccy"), currency);
        object amountString = this.safeString(item, "balChg");
        object amount = this.parseNumber(amountString);
        object timestamp = this.safeInteger(item, "ts");
        object feeCostString = this.safeString(item, "fee");
        object fee = null;
        if (isTrue(!isEqual(feeCostString, null)))
        {
            fee = new Dictionary<string, object>() {
                { "cost", this.parseNumber(Precise.stringNeg(feeCostString)) },
                { "currency", code },
            };
        }
        object before = null;
        object afterString = this.safeString(item, "bal");
        object after = this.parseNumber(afterString);
        object status = "ok";
        object marketId = this.safeString(item, "instId");
        object symbol = this.safeSymbol(marketId, null, "-");
        return new Dictionary<string, object>() {
            { "id", id },
            { "info", item },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "account", account },
            { "referenceId", referenceId },
            { "referenceAccount", referenceAccount },
            { "type", type },
            { "currency", code },
            { "symbol", symbol },
            { "amount", amount },
            { "before", before },
            { "after", after },
            { "status", status },
            { "fee", fee },
        };
    }

    public override object parseDepositAddress(object depositAddress, object currency = null)
    {
        //
        //     {
        //         "addr": "okbtothemoon",
        //         "memo": "971668", // may be missing
        //         "tag":"52055", // may be missing
        //         "pmtId": "", // may be missing
        //         "ccy": "BTC",
        //         "to": "6", // 1 SPOT, 3 FUTURES, 6 FUNDING, 9 SWAP, 12 OPTION, 18 Unified account
        //         "selected": true
        //     }
        //
        //     {
        //         "ccy":"usdt-erc20",
        //         "to":"6",
        //         "addr":"0x696abb81974a8793352cbd33aadcf78eda3cfdfa",
        //         "selected":true
        //     }
        //
        //     {
        //        "chain": "ETH-OKExChain",
        //        "ctAddr": "72315c",
        //        "ccy": "ETH",
        //        "to": "6",
        //        "addr": "0x1c9f2244d1ccaa060bd536827c18925db10db102",
        //        "selected": true
        //     }
        //
        object address = this.safeString(depositAddress, "addr");
        object tag = this.safeString2(depositAddress, "tag", "pmtId");
        tag = this.safeString(depositAddress, "memo", tag);
        object currencyId = this.safeString(depositAddress, "ccy");
        currency = this.safeCurrency(currencyId, currency);
        object code = getValue(currency, "code");
        object chain = this.safeString(depositAddress, "chain");
        object networks = this.safeValue(currency, "networks", new Dictionary<string, object>() {});
        object networksById = this.indexBy(networks, "id");
        object networkData = this.safeValue(networksById, chain);
        // inconsistent naming responses from exchange
        // with respect to network naming provided in currency info vs address chain-names and ids
        //
        // response from address endpoint:
        //      {
        //          "chain": "USDT-Polygon",
        //          "ctAddr": "",
        //          "ccy": "USDT",
        //          "to":"6" ,
        //          "addr": "0x1903441e386cc49d937f6302955b5feb4286dcfa",
        //          "selected": true
        //      }
        // network information from currency['networks'] field:
        // Polygon: {
        //        info: {
        //            canDep: false,
        //            canInternal: false,
        //            canWd: false,
        //            ccy: 'USDT',
        //            chain: 'USDT-Polygon-Bridge',
        //            mainNet: false,
        //            maxFee: '26.879528',
        //            minFee: '13.439764',
        //            minWd: '0.001',
        //            name: ''
        //        },
        //        id: 'USDT-Polygon-Bridge',
        //        network: 'Polygon',
        //        active: false,
        //        deposit: false,
        //        withdraw: false,
        //        fee: 13.439764,
        //        precision: undefined,
        //        limits: {
        //            withdraw: {
        //                min: 0.001,
        //                max: undefined
        //            }
        //        }
        //     },
        //
        if (isTrue(isEqual(chain, "USDT-Polygon")))
        {
            networkData = this.safeValue(networksById, "USDT-Polygon-Bridge");
        }
        object network = this.safeString(networkData, "network");
        this.checkAddress(address);
        return new Dictionary<string, object>() {
            { "currency", code },
            { "address", address },
            { "tag", tag },
            { "network", network },
            { "info", depositAddress },
        };
    }

    public async virtual Task<object> fetchDepositAddressesByNetwork(object code, object parameters = null)
    {
        /**
        * @method
        * @name okx#fetchDepositAddressesByNetwork
        * @description fetch a dictionary of addresses for a currency, indexed by network
        * @param {string} code unified currency code of the currency for the deposit address
        * @param {object} params extra parameters specific to the okx api endpoint
        * @returns {object} a dictionary of [address structures]{@link https://docs.ccxt.com/#/?id=address-structure} indexed by the network
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "ccy", getValue(currency, "id") },
        };
        object response = await this.privateGetAssetDepositAddress(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "addr": "okbtothemoon",
        //                 "memo": "971668", // may be missing
        //                 "tag":"52055", // may be missing
        //                 "pmtId": "", // may be missing
        //                 "ccy": "BTC",
        //                 "to": "6", // 1 SPOT, 3 FUTURES, 6 FUNDING, 9 SWAP, 12 OPTION, 18 Unified account
        //                 "selected": true
        //             },
        //             // {"ccy":"usdt-erc20","to":"6","addr":"0x696abb81974a8793352cbd33aadcf78eda3cfdfa","selected":true},
        //             // {"ccy":"usdt-trc20","to":"6","addr":"TRrd5SiSZrfQVRKm4e9SRSbn2LNTYqCjqx","selected":true},
        //             // {"ccy":"usdt_okexchain","to":"6","addr":"0x696abb81974a8793352cbd33aadcf78eda3cfdfa","selected":true},
        //             // {"ccy":"usdt_kip20","to":"6","addr":"0x696abb81974a8793352cbd33aadcf78eda3cfdfa","selected":true},
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object filtered = this.filterBy(data, "selected", true);
        object parsed = this.parseDepositAddresses(filtered, new List<object>() {getValue(currency, "code")}, false);
        return this.indexBy(parsed, "network");
    }

    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name okx#fetchDepositAddress
        * @description fetch the deposit address for a currency associated with this account
        * @param {string} code unified currency code
        * @param {object} params extra parameters specific to the okx api endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object rawNetwork = this.safeStringUpper(parameters, "network");
        object networks = this.safeValue(this.options, "networks", new Dictionary<string, object>() {});
        object network = this.safeString(networks, rawNetwork, rawNetwork);
        parameters = this.omit(parameters, "network");
        object response = await this.fetchDepositAddressesByNetwork(code, parameters);
        object result = null;
        if (isTrue(isEqual(network, null)))
        {
            result = this.safeValue(response, code);
            if (isTrue(isEqual(result, null)))
            {
                object alias = this.safeString(networks, code, code);
                result = this.safeValue(response, alias);
                if (isTrue(isEqual(result, null)))
                {
                    object defaultNetwork = this.safeString(this.options, "defaultNetwork", "ERC20");
                    result = this.safeValue(response, defaultNetwork);
                    if (isTrue(isEqual(result, null)))
                    {
                        object values = new List<object>(((Dictionary<string,object>)response).Values);
                        result = this.safeValue(values, 0);
                        if (isTrue(isEqual(result, null)))
                        {
                            throw new InvalidAddress ((string)add(add(this.id, " fetchDepositAddress() cannot find deposit address for "), code)) ;
                        }
                    }
                }
            }
            return result;
        }
        result = this.safeValue(response, network);
        if (isTrue(isEqual(result, null)))
        {
            throw new InvalidAddress ((string)add(add(add(add(this.id, " fetchDepositAddress() cannot find "), network), " deposit address for "), code)) ;
        }
        return result;
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name okx#withdraw
        * @description make a withdrawal
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string|undefined} tag
        * @param {object} params extra parameters specific to the okx api endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((List<object>)tagparametersVariable)[0];
        parameters = ((List<object>)tagparametersVariable)[1];
        this.checkAddress(address);
        await this.loadMarkets();
        object currency = this.currency(code);
        if (isTrue(isTrue((!isEqual(tag, null))) && isTrue((isGreaterThan(getArrayLength(tag), 0)))))
        {
            address = add(add(address, ":"), tag);
        }
        object request = new Dictionary<string, object>() {
            { "ccy", getValue(currency, "id") },
            { "toAddr", address },
            { "dest", "4" },
            { "amt", this.numberToString(amount) },
        };
        object network = this.safeString(parameters, "network"); // this line allows the user to specify either ERC20 or ETH
        if (isTrue(!isEqual(network, null)))
        {
            object networks = this.safeValue(this.options, "networks", new Dictionary<string, object>() {});
            network = this.safeString(networks, ((string)network).ToUpper(), network); // handle ETH>ERC20 alias
            ((Dictionary<string, object>)request)["chain"] = add(add(getValue(currency, "id"), "-"), network);
            parameters = this.omit(parameters, "network");
        }
        object fee = this.safeString(parameters, "fee");
        if (isTrue(isEqual(fee, null)))
        {
            object currencies = await this.fetchCurrencies();
            this.currencies = this.deepExtend(this.currencies, currencies);
            object targetNetwork = this.safeValue(getValue(currency, "networks"), this.networkIdToCode(network), new Dictionary<string, object>() {});
            fee = this.safeString(targetNetwork, "fee");
            if (isTrue(isEqual(fee, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " withdraw() requires a \'fee\' string parameter, network transaction fee must be ≥ 0. Withdrawals to OKCoin or OKX are fee-free, please set \'0\'. Withdrawing to external digital asset address requires network transaction fee.")) ;
            }
        }
        ((Dictionary<string, object>)request)["fee"] = this.numberToString(fee); // withdrawals to OKCoin or OKX are fee-free, please set 0
        if (isTrue(((Dictionary<string,object>)parameters).ContainsKey(toStringOrNull("password"))))
        {
            ((Dictionary<string, object>)request)["pwd"] = getValue(parameters, "password");
        } else if (isTrue(((Dictionary<string,object>)parameters).ContainsKey(toStringOrNull("pwd"))))
        {
            ((Dictionary<string, object>)request)["pwd"] = getValue(parameters, "pwd");
        }
        object query = this.omit(parameters, new List<object>() {"fee", "password", "pwd"});
        if (!isTrue((((Dictionary<string,object>)request).ContainsKey(toStringOrNull("pwd")))))
        {
            throw new ExchangeError ((string)add(this.id, " withdraw() requires a password parameter or a pwd parameter, it must be the funding password, not the API passphrase")) ;
        }
        object response = await this.privatePostAssetWithdrawal(this.extend(request, query));
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "amt": "0.1",
        //                 "wdId": "67485",
        //                 "ccy": "BTC"
        //             }
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object transaction = this.safeValue(data, 0);
        return this.parseTransaction(transaction, currency);
    }

    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name okx#fetchDeposits
        * @description fetch all deposits made to an account
        * @see https://www.okx.com/docs-v5/en/#rest-api-funding-get-deposit-history
        * @param {string|undefined} code unified currency code
        * @param {int|undefined} since the earliest time in ms to fetch deposits for
        * @param {int|undefined} limit the maximum number of deposits structures to retrieve
        * @param {object} params extra parameters specific to the okx api endpoint
        * @returns {[object]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((Dictionary<string, object>)request)["ccy"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["before"] = mathMax(subtract(since, 1), 0);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit; // default 100, max 100
        }
        object response = await this.privateGetAssetDepositHistory(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "amt": "0.01044408",
        //                 "txId": "1915737_3_0_0_asset",
        //                 "ccy": "BTC",
        //                 "from": "13801825426",
        //                 "to": "",
        //                 "ts": "1597026383085",
        //                 "state": "2",
        //                 "depId": "4703879"
        //             },
        //             {
        //                 "amt": "491.6784211",
        //                 "txId": "1744594_3_184_0_asset",
        //                 "ccy": "OKB",
        //                 "from": "",
        //                 "to": "",
        //                 "ts": "1597026383085",
        //                 "state": "2",
        //                 "depId": "4703809"
        //             },
        //             {
        //                 "amt": "223.18782496",
        //                 "txId": "6d892c669225b1092c780bf0da0c6f912fc7dc8f6b8cc53b003288624c",
        //                 "ccy": "USDT",
        //                 "from": "",
        //                 "to": "39kK4XvgEuM7rX9frgyHoZkWqx4iKu1spD",
        //                 "ts": "1597026383085",
        //                 "state": "2",
        //                 "depId": "4703779"
        //             }
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        return this.parseTransactions(data, currency, since, limit, parameters);
    }

    public async virtual Task<object> fetchDeposit(object id, object code = null, object parameters = null)
    {
        /**
        * @method
        * @name okx#fetchDeposit
        * @description fetch data on a currency deposit via the deposit id
        * @see https://www.okx.com/docs-v5/en/#rest-api-funding-get-deposit-history
        * @param {string} id deposit id
        * @param {string|undefined} code filter by currency code
        * @param {object} params extra parameters specific to the okx api endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "depId", id },
        };
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((Dictionary<string, object>)request)["ccy"] = getValue(currency, "id");
        }
        object response = await this.privateGetAssetDepositHistory(this.extend(request, parameters));
        object data = this.safeValue(response, "data");
        object deposit = this.safeValue(data, 0, new Dictionary<string, object>() {});
        return this.parseTransaction(deposit, currency);
    }

    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name okx#fetchWithdrawals
        * @description fetch all withdrawals made from an account
        * @see https://www.okx.com/docs-v5/en/#rest-api-funding-get-withdrawal-history
        * @param {string|undefined} code unified currency code
        * @param {int|undefined} since the earliest time in ms to fetch withdrawals for
        * @param {int|undefined} limit the maximum number of withdrawals structures to retrieve
        * @param {object} params extra parameters specific to the okx api endpoint
        * @returns {[object]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((Dictionary<string, object>)request)["ccy"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["before"] = mathMax(subtract(since, 1), 0);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit; // default 100, max 100
        }
        object response = await this.privateGetAssetWithdrawalHistory(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "amt": "0.094",
        //                 "wdId": "4703879",
        //                 "fee": "0.01000000eth",
        //                 "txId": "0x62477bac6509a04512819bb1455e923a60dea5966c7caeaa0b24eb8fb0432b85",
        //                 "ccy": "ETH",
        //                 "from": "13426335357",
        //                 "to": "0xA41446125D0B5b6785f6898c9D67874D763A1519",
        //                 "ts": "1597026383085",
        //                 "state": "2"
        //             },
        //             {
        //                 "amt": "0.01",
        //                 "wdId": "4703879",
        //                 "fee": "0.00000000btc",
        //                 "txId": "",
        //                 "ccy": "BTC",
        //                 "from": "13426335357",
        //                 "to": "13426335357",
        //                 "ts": "1597026383085",
        //                 "state": "2"
        //             }
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        return this.parseTransactions(data, currency, since, limit, parameters);
    }

    public async virtual Task<object> fetchWithdrawal(object id, object code = null, object parameters = null)
    {
        /**
        * @method
        * @name okx#fetchWithdrawal
        * @description fetch data on a currency withdrawal via the withdrawal id
        * @see https://www.okx.com/docs-v5/en/#rest-api-funding-get-withdrawal-history
        * @param {string} id withdrawal id
        * @param {string|undefined} code unified currency code of the currency withdrawn, default is undefined
        * @param {object} params extra parameters specific to the okx api endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "wdId", id },
        };
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((Dictionary<string, object>)request)["ccy"] = getValue(currency, "id");
        }
        object response = await this.privateGetAssetWithdrawalHistory(this.extend(request, parameters));
        //
        //    {
        //        code: '0',
        //        data: [
        //            {
        //                chain: 'USDT-TRC20',
        //                clientId: '',
        //                fee: '0.8',
        //                ccy: 'USDT',
        //                amt: '54.561',
        //                txId: '00cff6ec7fa7c7d7d184bd84e82b9ff36863f07c0421188607f87dfa94e06b70',
        //                from: 'example@email.com',
        //                to: 'TEY6qjnKDyyq5jDc3DJizWLCdUySrpQ4yp',
        //                state: '2',
        //                ts: '1641376485000',
        //                wdId: '25147041'
        //            }
        //        ],
        //        msg: ''
        //    }
        //
        object data = this.safeValue(response, "data");
        object withdrawal = this.safeValue(data, 0, new Dictionary<string, object>() {});
        return this.parseTransaction(withdrawal);
    }

    public virtual object parseTransactionStatus(object status)
    {
        //
        // deposit statuses
        //
        //     {
        //         '0': 'waiting for confirmation',
        //         '1': 'deposit credited',
        //         '2': 'deposit successful'
        //     }
        //
        // withdrawal statuses
        //
        //     {
        //        '-3': 'pending cancel',
        //        '-2': 'canceled',
        //        '-1': 'failed',
        //         '0': 'pending',
        //         '1': 'sending',
        //         '2': 'sent',
        //         '3': 'awaiting email verification',
        //         '4': 'awaiting manual verification',
        //         '5': 'awaiting identity verification'
        //     }
        //
        object statuses = new Dictionary<string, object>() {
            { "-3", "pending" },
            { "-2", "canceled" },
            { "-1", "failed" },
            { "0", "pending" },
            { "1", "pending" },
            { "2", "ok" },
            { "3", "pending" },
            { "4", "pending" },
            { "5", "pending" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // withdraw
        //
        //     {
        //         "amt": "0.1",
        //         "wdId": "67485",
        //         "ccy": "BTC"
        //     }
        //
        // fetchWithdrawals
        //
        //     {
        //         "amt": "0.094",
        //         "wdId": "4703879",
        //         "fee": "0.01000000eth",
        //         "txId": "0x62477bac6509a04512819bb1455e923a60dea5966c7caeaa0b24eb8fb0432b85",
        //         "ccy": "ETH",
        //         "from": "13426335357",
        //         "to": "0xA41446125D0B5b6785f6898c9D67874D763A1519",
        //         'tag',
        //         'pmtId',
        //         'memo',
        //         "ts": "1597026383085",
        //         "state": "2"
        //     }
        //
        // fetchDeposits
        //
        //     {
        //         "amt": "0.01044408",
        //         "txId": "1915737_3_0_0_asset",
        //         "ccy": "BTC",
        //         "from": "13801825426",
        //         "to": "",
        //         "ts": "1597026383085",
        //         "state": "2",
        //         "depId": "4703879"
        //     }
        //
        object type = null;
        object id = null;
        object withdrawalId = this.safeString(transaction, "wdId");
        object addressFrom = this.safeString(transaction, "from");
        object addressTo = this.safeString(transaction, "to");
        object address = addressTo;
        object tagTo = this.safeString2(transaction, "tag", "memo");
        tagTo = this.safeString2(transaction, "pmtId", tagTo);
        if (isTrue(!isEqual(withdrawalId, null)))
        {
            type = "withdrawal";
            id = withdrawalId;
        } else
        {
            // the payment_id will appear on new deposits but appears to be removed from the response after 2 months
            id = this.safeString(transaction, "depId");
            type = "deposit";
        }
        object currencyId = this.safeString(transaction, "ccy");
        object code = this.safeCurrencyCode(currencyId);
        object amount = this.safeNumber(transaction, "amt");
        object status = this.parseTransactionStatus(this.safeString(transaction, "state"));
        object txid = this.safeString(transaction, "txId");
        object timestamp = this.safeInteger(transaction, "ts");
        object feeCost = null;
        if (isTrue(isEqual(type, "deposit")))
        {
            feeCost = 0;
        } else
        {
            feeCost = this.safeNumber(transaction, "fee");
        }
        // todo parse tags
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", id },
            { "currency", code },
            { "amount", amount },
            { "network", null },
            { "addressFrom", addressFrom },
            { "addressTo", addressTo },
            { "address", address },
            { "tagFrom", null },
            { "tagTo", tagTo },
            { "tag", tagTo },
            { "status", status },
            { "type", type },
            { "updated", null },
            { "txid", txid },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "fee", new Dictionary<string, object>() {
                { "currency", code },
                { "cost", feeCost },
            } },
        };
    }

    public async virtual Task<object> fetchLeverage(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name okx#fetchLeverage
        * @description fetch the set leverage for a market
        * @see https://www.okx.com/docs-v5/en/#rest-api-account-get-leverage
        * @param {string} symbol unified market symbol
        * @param {object} params extra parameters specific to the okx api endpoint
        * @param {string} params.marginMode 'cross' or 'isolated'
        * @returns {object} a [leverage structure]{@link https://docs.ccxt.com/#/?id=leverage-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchLeverage", parameters);
        marginMode = ((List<object>)marginModeparametersVariable)[0];
        parameters = ((List<object>)marginModeparametersVariable)[1];
        if (isTrue(isEqual(marginMode, null)))
        {
            marginMode = this.safeString(parameters, "mgnMode", "cross"); // cross as default marginMode
        }
        if (isTrue(isTrue((!isEqual(marginMode, "cross"))) && isTrue((!isEqual(marginMode, "isolated")))))
        {
            throw new BadRequest ((string)add(this.id, " fetchLeverage() requires a marginMode parameter that must be either cross or isolated")) ;
        }
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
            { "mgnMode", marginMode },
        };
        object response = await this.privateGetAccountLeverageInfo(this.extend(request, parameters));
        //
        //     {
        //        "code": "0",
        //        "data": [
        //            {
        //                "instId": "BTC-USDT-SWAP",
        //                "lever": "5.00000000",
        //                "mgnMode": "isolated",
        //                "posSide": "net"
        //            }
        //        ],
        //        "msg": ""
        //     }
        //
        return response;
    }

    public async override Task<object> fetchPosition(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name okx#fetchPosition
        * @description fetch data on a single open contract trade position
        * @see https://www.okx.com/docs-v5/en/#rest-api-account-get-positions
        * @param {string} symbol unified market symbol of the market the position is held in, default is undefined
        * @param {object} params extra parameters specific to the okx api endpoint
        * @param {string|undefined} params.instType MARGIN, SWAP, FUTURES, OPTION
        * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        var typequeryVariable = this.handleMarketTypeAndParams("fetchPosition", market, parameters);
        var type = ((List<object>) typequeryVariable)[0];
        var query = ((List<object>) typequeryVariable)[1];
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
        };
        if (isTrue(!isEqual(type, null)))
        {
            ((Dictionary<string, object>)request)["instType"] = this.convertToInstrumentType(type);
        }
        object response = await this.privateGetAccountPositions(this.extend(request, query));
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "adl": "1",
        //                 "availPos": "1",
        //                 "avgPx": "2566.31",
        //                 "cTime": "1619507758793",
        //                 "ccy": "ETH",
        //                 "deltaBS": "",
        //                 "deltaPA": "",
        //                 "gammaBS": "",
        //                 "gammaPA": "",
        //                 "imr": "",
        //                 "instId": "ETH-USD-210430",
        //                 "instType": "FUTURES",
        //                 "interest": "0",
        //                 "last": "2566.22",
        //                 "lever": "10",
        //                 "liab": "",
        //                 "liabCcy": "",
        //                 "liqPx": "2352.8496681818233",
        //                 "margin": "0.0003896645377994",
        //                 "mgnMode": "isolated",
        //                 "mgnRatio": "11.731726509588816",
        //                 "mmr": "0.0000311811092368",
        //                 "optVal": "",
        //                 "pTime": "1619507761462",
        //                 "pos": "1",
        //                 "posCcy": "",
        //                 "posId": "307173036051017730",
        //                 "posSide": "long",
        //                 "thetaBS": "",
        //                 "thetaPA": "",
        //                 "tradeId": "109844",
        //                 "uTime": "1619507761462",
        //                 "upl": "-0.0000009932766034",
        //                 "uplRatio": "-0.0025490556801078",
        //                 "vegaBS": "",
        //                 "vegaPA": ""
        //             }
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object position = this.safeValue(data, 0);
        if (isTrue(isEqual(position, null)))
        {
            return position;
        }
        return this.parsePosition(position);
    }

    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name okx#fetchPositions
        * @see https://www.okx.com/docs-v5/en/#rest-api-account-get-positions
        * @description fetch all open positions
        * @param {[string]|undefined} symbols list of unified market symbols
        * @param {object} params extra parameters specific to the okx api endpoint
        * @param {string|undefined} params.instType MARGIN, SWAP, FUTURES, OPTION
        * @returns {[object]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbols, null)))
        {
            object marketIds = new List<object>() {};
            for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
            {
                object entry = getValue(symbols, i);
                object market = this.market(entry);
                ((List<object>)marketIds).Add(getValue(market, "id"));
            }
            object marketIdsLength = getArrayLength(marketIds);
            if (isTrue(isGreaterThan(marketIdsLength, 0)))
            {
                ((Dictionary<string, object>)request)["instId"] = String.Join(",", ((List<object>)marketIds).ToArray());
            }
        }
        object fetchPositionsOptions = this.safeValue(this.options, "fetchPositions", new Dictionary<string, object>() {});
        object method = this.safeString(fetchPositionsOptions, "method", "privateGetAccountPositions");
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "adl": "1",
        //                 "availPos": "1",
        //                 "avgPx": "2566.31",
        //                 "cTime": "1619507758793",
        //                 "ccy": "ETH",
        //                 "deltaBS": "",
        //                 "deltaPA": "",
        //                 "gammaBS": "",
        //                 "gammaPA": "",
        //                 "imr": "",
        //                 "instId": "ETH-USD-210430",
        //                 "instType": "FUTURES",
        //                 "interest": "0",
        //                 "last": "2566.22",
        //                 "lever": "10",
        //                 "liab": "",
        //                 "liabCcy": "",
        //                 "liqPx": "2352.8496681818233",
        //                 "margin": "0.0003896645377994",
        //                 "mgnMode": "isolated",
        //                 "mgnRatio": "11.731726509588816",
        //                 "mmr": "0.0000311811092368",
        //                 "optVal": "",
        //                 "pTime": "1619507761462",
        //                 "pos": "1",
        //                 "posCcy": "",
        //                 "posId": "307173036051017730",
        //                 "posSide": "long",
        //                 "thetaBS": "",
        //                 "thetaPA": "",
        //                 "tradeId": "109844",
        //                 "uTime": "1619507761462",
        //                 "upl": "-0.0000009932766034",
        //                 "uplRatio": "-0.0025490556801078",
        //                 "vegaBS": "",
        //                 "vegaPA": ""
        //             }
        //         ]
        //     }
        //
        object positions = this.safeValue(response, "data", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(positions)); postFixIncrement(ref i))
        {
            ((List<object>)result).Add(this.parsePosition(getValue(positions, i)));
        }
        return this.filterByArray(result, "symbol", symbols, false);
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        //     {
        //        "adl": "3",
        //        "availPos": "1",
        //        "avgPx": "34131.1",
        //        "cTime": "1627227626502",
        //        "ccy": "USDT",
        //        "deltaBS": "",
        //        "deltaPA": "",
        //        "gammaBS": "",
        //        "gammaPA": "",
        //        "imr": "170.66093041794787",
        //        "instId": "BTC-USDT-SWAP",
        //        "instType": "SWAP",
        //        "interest": "0",
        //        "last": "34134.4",
        //        "lever": "2",
        //        "liab": "",
        //        "liabCcy": "",
        //        "liqPx": "12608.959083877446",
        //        "markPx": "4786.459271773621",
        //        "margin": "",
        //        "mgnMode": "cross",
        //        "mgnRatio": "140.49930117599155",
        //        "mmr": "1.3652874433435829",
        //        "notionalUsd": "341.5130010779638",
        //        "optVal": "",
        //        "pos": "1",
        //        "posCcy": "",
        //        "posId": "339552508062380036",
        //        "posSide": "long",
        //        "thetaBS": "",
        //        "thetaPA": "",
        //        "tradeId": "98617799",
        //        "uTime": "1627227626502",
        //        "upl": "0.0108608358957281",
        //        "uplRatio": "0.0000636418743944",
        //        "vegaBS": "",
        //        "vegaPA": ""
        //    }
        //
        object marketId = this.safeString(position, "instId");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object pos = this.safeString(position, "pos"); // 'pos' field: One way mode: 0 if position is not open, 1 if open | Two way (hedge) mode: -1 if short, 1 if long, 0 if position is not open
        object contractsAbs = Precise.stringAbs(pos);
        object side = this.safeString(position, "posSide");
        object hedged = !isEqual(side, "net");
        object contracts = this.parseNumber(contractsAbs);
        if (isTrue(getValue(market, "margin")))
        {
            // margin position
            if (isTrue(isEqual(side, "net")))
            {
                object posCcy = this.safeString(position, "posCcy");
                object parsedCurrency = this.safeCurrencyCode(posCcy);
                if (isTrue(!isEqual(parsedCurrency, null)))
                {
                    side = ((bool) isTrue((isEqual(getValue(market, "base"), parsedCurrency)))) ? "long" : "short";
                }
            }
            if (isTrue(isEqual(side, null)))
            {
                side = this.safeString(position, "direction");
            }
        } else
        {
            if (isTrue(!isEqual(pos, null)))
            {
                if (isTrue(isEqual(side, "net")))
                {
                    if (isTrue(Precise.stringGt(pos, "0")))
                    {
                        side = "long";
                    } else if (isTrue(Precise.stringLt(pos, "0")))
                    {
                        side = "short";
                    } else
                    {
                        side = null;
                    }
                }
            }
        }
        object contractSize = this.safeNumber(market, "contractSize");
        object contractSizeString = this.numberToString(contractSize);
        object markPriceString = this.safeString(position, "markPx");
        object notionalString = this.safeString(position, "notionalUsd");
        if (isTrue(getValue(market, "inverse")))
        {
            notionalString = Precise.stringDiv(Precise.stringMul(contractsAbs, contractSizeString), markPriceString);
        }
        object notional = this.parseNumber(notionalString);
        object marginMode = this.safeString(position, "mgnMode");
        object initialMarginString = null;
        object entryPriceString = this.safeString(position, "avgPx");
        object unrealizedPnlString = this.safeString(position, "upl");
        object leverageString = this.safeString(position, "lever");
        object initialMarginPercentage = null;
        object collateralString = null;
        if (isTrue(isEqual(marginMode, "cross")))
        {
            initialMarginString = this.safeString(position, "imr");
            collateralString = Precise.stringAdd(initialMarginString, unrealizedPnlString);
        } else if (isTrue(isEqual(marginMode, "isolated")))
        {
            initialMarginPercentage = Precise.stringDiv("1", leverageString);
            collateralString = this.safeString(position, "margin");
        }
        object maintenanceMarginString = this.safeString(position, "mmr");
        object maintenanceMargin = this.parseNumber(maintenanceMarginString);
        object maintenanceMarginPercentageString = Precise.stringDiv(maintenanceMarginString, notionalString);
        if (isTrue(isEqual(initialMarginPercentage, null)))
        {
            initialMarginPercentage = this.parseNumber(Precise.stringDiv(initialMarginString, notionalString, 4));
        } else if (isTrue(isEqual(initialMarginString, null)))
        {
            initialMarginString = Precise.stringMul(initialMarginPercentage, notionalString);
        }
        object rounder = "0.00005"; // round to closest 0.01%
        object maintenanceMarginPercentage = this.parseNumber(Precise.stringDiv(Precise.stringAdd(maintenanceMarginPercentageString, rounder), "1", 4));
        object liquidationPrice = this.safeNumber(position, "liqPx");
        object percentageString = this.safeString(position, "uplRatio");
        object percentage = this.parseNumber(Precise.stringMul(percentageString, "100"));
        object timestamp = this.safeInteger(position, "uTime");
        object marginRatio = this.parseNumber(Precise.stringDiv(maintenanceMarginString, collateralString, 4));
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", null },
            { "symbol", symbol },
            { "notional", notional },
            { "marginMode", marginMode },
            { "liquidationPrice", liquidationPrice },
            { "entryPrice", this.parseNumber(entryPriceString) },
            { "unrealizedPnl", this.parseNumber(unrealizedPnlString) },
            { "percentage", percentage },
            { "contracts", contracts },
            { "contractSize", contractSize },
            { "markPrice", this.parseNumber(markPriceString) },
            { "lastPrice", null },
            { "side", side },
            { "hedged", hedged },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastUpdateTimestamp", null },
            { "maintenanceMargin", maintenanceMargin },
            { "maintenanceMarginPercentage", maintenanceMarginPercentage },
            { "collateral", this.parseNumber(collateralString) },
            { "initialMargin", this.parseNumber(initialMarginString) },
            { "initialMarginPercentage", this.parseNumber(initialMarginPercentage) },
            { "leverage", this.parseNumber(leverageString) },
            { "marginRatio", marginRatio },
        });
    }

    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        /**
        * @method
        * @name okx#transfer
        * @description transfer currency internally between wallets on the same account
        * @see https://www.okx.com/docs-v5/en/#rest-api-funding-funds-transfer
        * @param {string} code unified currency code
        * @param {float} amount amount to transfer
        * @param {string} fromAccount account to transfer from
        * @param {string} toAccount account to transfer to
        * @param {object} params extra parameters specific to the okx api endpoint
        * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object accountsByType = this.safeValue(this.options, "accountsByType", new Dictionary<string, object>() {});
        object fromId = this.safeString(accountsByType, fromAccount, fromAccount);
        object toId = this.safeString(accountsByType, toAccount, toAccount);
        object request = new Dictionary<string, object>() {
            { "ccy", getValue(currency, "id") },
            { "amt", this.currencyToPrecision(code, amount) },
            { "type", "0" },
            { "from", fromId },
            { "to", toId },
        };
        if (isTrue(isEqual(fromId, "master")))
        {
            ((Dictionary<string, object>)request)["type"] = "1";
            ((Dictionary<string, object>)request)["subAcct"] = toId;
            ((Dictionary<string, object>)request)["from"] = this.safeString(parameters, "from", "6");
            ((Dictionary<string, object>)request)["to"] = this.safeString(parameters, "to", "6");
        } else if (isTrue(isEqual(toId, "master")))
        {
            ((Dictionary<string, object>)request)["type"] = "2";
            ((Dictionary<string, object>)request)["subAcct"] = fromId;
            ((Dictionary<string, object>)request)["from"] = this.safeString(parameters, "from", "6");
            ((Dictionary<string, object>)request)["to"] = this.safeString(parameters, "to", "6");
        }
        object response = await this.privatePostAssetTransfer(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "msg": "",
        //         "data": [
        //             {
        //                 "transId": "754147",
        //                 "ccy": "USDT",
        //                 "from": "6",
        //                 "amt": "0.1",
        //                 "to": "18"
        //             }
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object rawTransfer = this.safeValue(data, 0, new Dictionary<string, object>() {});
        return this.parseTransfer(rawTransfer, currency);
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        //
        // transfer
        //
        //     {
        //         "transId": "754147",
        //         "ccy": "USDT",
        //         "from": "6",
        //         "amt": "0.1",
        //         "to": "18"
        //     }
        //
        // fetchTransfer
        //
        //     {
        //         "amt": "5",
        //         "ccy": "USDT",
        //         "from": "18",
        //         "instId": "",
        //         "state": "success",
        //         "subAcct": "",
        //         "to": "6",
        //         "toInstId": "",
        //         "transId": "464424732",
        //         "type": "0"
        //     }
        //
        object id = this.safeString(transfer, "transId");
        object currencyId = this.safeString(transfer, "ccy");
        object code = this.safeCurrencyCode(currencyId, currency);
        object amount = this.safeNumber(transfer, "amt");
        object fromAccountId = this.safeString(transfer, "from");
        object toAccountId = this.safeString(transfer, "to");
        object accountsById = this.safeValue(this.options, "accountsById", new Dictionary<string, object>() {});
        object fromAccount = this.safeString(accountsById, fromAccountId);
        object toAccount = this.safeString(accountsById, toAccountId);
        object timestamp = this.milliseconds();
        object status = this.safeString(transfer, "state");
        return new Dictionary<string, object>() {
            { "info", transfer },
            { "id", id },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "currency", code },
            { "amount", amount },
            { "fromAccount", fromAccount },
            { "toAccount", toAccount },
            { "status", status },
        };
    }

    public async virtual Task<object> fetchTransfer(object id, object code = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "transId", id },
        };
        object response = await this.privateGetAssetTransferState(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "amt": "5",
        //                 "ccy": "USDT",
        //                 "from": "18",
        //                 "instId": "",
        //                 "state": "success",
        //                 "subAcct": "",
        //                 "to": "6",
        //                 "toInstId": "",
        //                 "transId": "464424732",
        //                 "type": "0"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object transfer = this.safeValue(data, 0);
        return this.parseTransfer(transfer);
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object isArray = (parameters.GetType().IsGenericType && parameters.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)));
        object request = add(add(add("/api/", this.version), "/"), this.implodeParams(path, parameters));
        object query = this.omit(parameters, this.extractParams(path));
        object url = add(this.implodeHostname(getValue(getValue(this.urls, "api"), "rest")), request);
        // const type = this.getPathAuthenticationType (path);
        if (isTrue(isEqual(api, "public")))
        {
            if (isTrue(getArrayLength(new List<object>(((Dictionary<string,object>)query).Keys))))
            {
                url = add(url, add("?", this.urlencode(query)));
            }
        } else if (isTrue(isEqual(api, "private")))
        {
            this.checkRequiredCredentials();
            object timestamp = this.iso8601(this.milliseconds());
            headers = new Dictionary<string, object>() {
                { "OK-ACCESS-KEY", this.apiKey },
                { "OK-ACCESS-PASSPHRASE", this.password },
                { "OK-ACCESS-TIMESTAMP", timestamp },
            };
            object auth = add(add(timestamp, method), request);
            if (isTrue(isEqual(method, "GET")))
            {
                if (isTrue(getArrayLength(new List<object>(((Dictionary<string,object>)query).Keys))))
                {
                    object urlencodedQuery = add("?", this.urlencode(query));
                    url = add(url, urlencodedQuery);
                    auth = add(auth, urlencodedQuery);
                }
            } else
            {
                if (isTrue(isTrue(isArray) || isTrue(getArrayLength(new List<object>(((Dictionary<string,object>)query).Keys)))))
                {
                    body = this.json(query);
                    auth = add(auth, body);
                }
                ((Dictionary<string, object>)headers)["Content-Type"] = "application/json";
            }
            object signature = this.hmac(this.encode(auth), this.encode(this.secret), sha256, "base64");
            ((Dictionary<string, object>)headers)["OK-ACCESS-SIGN"] = signature;
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object parseFundingRate(object contract, object market = null)
    {
        //
        //    {
        //        "fundingRate": "0.00027815",
        //        "fundingTime": "1634256000000",
        //        "instId": "BTC-USD-SWAP",
        //        "instType": "SWAP",
        //        "nextFundingRate": "0.00017",
        //        "nextFundingTime": "1634284800000"
        //    }
        //
        // in the response above nextFundingRate is actually two funding rates from now
        //
        object nextFundingRateTimestamp = this.safeInteger(contract, "nextFundingTime");
        object marketId = this.safeString(contract, "instId");
        object symbol = this.safeSymbol(marketId, market);
        object nextFundingRate = this.safeNumber(contract, "nextFundingRate");
        object fundingTime = this.safeInteger(contract, "fundingTime");
        // https://www.okx.com/support/hc/en-us/articles/360053909272-Ⅸ-Introduction-to-perpetual-swap-funding-fee
        // > The current interest is 0.
        return new Dictionary<string, object>() {
            { "info", contract },
            { "symbol", symbol },
            { "markPrice", null },
            { "indexPrice", null },
            { "interestRate", this.parseNumber("0") },
            { "estimatedSettlePrice", null },
            { "timestamp", null },
            { "datetime", null },
            { "fundingRate", this.safeNumber(contract, "fundingRate") },
            { "fundingTimestamp", fundingTime },
            { "fundingDatetime", this.iso8601(fundingTime) },
            { "nextFundingRate", nextFundingRate },
            { "nextFundingTimestamp", nextFundingRateTimestamp },
            { "nextFundingDatetime", this.iso8601(nextFundingRateTimestamp) },
            { "previousFundingRate", null },
            { "previousFundingTimestamp", null },
            { "previousFundingDatetime", null },
        };
    }

    public async override Task<object> fetchFundingRate(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name okx#fetchFundingRate
        * @description fetch the current funding rate
        * @param {string} symbol unified market symbol
        * @param {object} params extra parameters specific to the okx api endpoint
        * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "swap")))
        {
            throw new ExchangeError ((string)add(this.id, " fetchFundingRate() is only valid for swap markets")) ;
        }
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
        };
        object response = await this.publicGetPublicFundingRate(this.extend(request, parameters));
        //
        //    {
        //        "code": "0",
        //        "data": [
        //            {
        //                "fundingRate": "0.00027815",
        //                "fundingTime": "1634256000000",
        //                "instId": "BTC-USD-SWAP",
        //                "instType": "SWAP",
        //                "nextFundingRate": "0.00017",
        //                "nextFundingTime": "1634284800000"
        //            }
        //        ],
        //        "msg": ""
        //    }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object entry = this.safeValue(data, 0, new Dictionary<string, object>() {});
        return this.parseFundingRate(entry, market);
    }

    public async virtual Task<object> fetchFundingHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name okx#fetchFundingHistory
        * @description fetch the history of funding payments paid and received on this account
        * @param {string|undefined} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch funding history for
        * @param {int|undefined} limit the maximum number of funding history structures to retrieve
        * @param {object} params extra parameters specific to the okx api endpoint
        * @returns {object} a [funding history structure]{@link https://docs.ccxt.com/#/?id=funding-history-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "type", "8" },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = ((object)limit).ToString(); // default 100, max 100
        }
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            symbol = getValue(market, "symbol");
            if (isTrue(getValue(market, "contract")))
            {
                if (isTrue(getValue(market, "linear")))
                {
                    ((Dictionary<string, object>)request)["ctType"] = "linear";
                    ((Dictionary<string, object>)request)["ccy"] = getValue(market, "quoteId");
                } else
                {
                    ((Dictionary<string, object>)request)["ctType"] = "inverse";
                    ((Dictionary<string, object>)request)["ccy"] = getValue(market, "baseId");
                }
            }
        }
        var typequeryVariable = this.handleMarketTypeAndParams("fetchFundingHistory", market, parameters);
        var type = ((List<object>) typequeryVariable)[0];
        var query = ((List<object>) typequeryVariable)[1];
        if (isTrue(isEqual(type, "swap")))
        {
            ((Dictionary<string, object>)request)["instType"] = this.convertToInstrumentType(type);
        }
        // AccountBillsArchive has the same cost as AccountBills but supports three months of data
        object response = await this.privateGetAccountBillsArchive(this.extend(request, query));
        //
        //    {
        //        "bal": "0.0242946200998573",
        //        "balChg": "0.0000148752712240",
        //        "billId": "377970609204146187",
        //        "ccy": "ETH",
        //        "execType": "",
        //        "fee": "0",
        //        "from": "",
        //        "instId": "ETH-USD-SWAP",
        //        "instType": "SWAP",
        //        "mgnMode": "isolated",
        //        "notes": "",
        //        "ordId": "",
        //        "pnl": "0.000014875271224",
        //        "posBal": "0",
        //        "posBalChg": "0",
        //        "subType": "174",
        //        "sz": "9",
        //        "to": "",
        //        "ts": "1636387215588",
        //        "type": "8"
        //    }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object entry = getValue(data, i);
            object timestamp = this.safeInteger(entry, "ts");
            object instId = this.safeString(entry, "instId");
            object marketInner = this.safeMarket(instId);
            object currencyId = this.safeString(entry, "ccy");
            object code = this.safeCurrencyCode(currencyId);
            ((List<object>)result).Add(new Dictionary<string, object>() {
                { "info", entry },
                { "symbol", getValue(marketInner, "symbol") },
                { "code", code },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
                { "id", this.safeString(entry, "billId") },
                { "amount", this.safeNumber(entry, "balChg") },
            });
        }
        object sorted = this.sortBy(result, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, symbol, since, limit);
    }

    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name okx#setLeverage
        * @description set the level of leverage for a market
        * @see https://www.okx.com/docs-v5/en/#rest-api-account-set-leverage
        * @param {float} leverage the rate of leverage
        * @param {string} symbol unified market symbol
        * @param {object} params extra parameters specific to the okx api endpoint
        * @param {string} params.marginMode 'cross' or 'isolated'
        * @param {string|undefined} params.posSide 'long' or 'short' for isolated margin long/short mode on futures and swap markets
        * @returns {object} response from the exchange
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setLeverage() requires a symbol argument")) ;
        }
        // WARNING: THIS WILL INCREASE LIQUIDATION PRICE FOR OPEN ISOLATED LONG POSITIONS
        // AND DECREASE LIQUIDATION PRICE FOR OPEN ISOLATED SHORT POSITIONS
        if (isTrue(isTrue((isLessThan(leverage, 1))) || isTrue((isGreaterThan(leverage, 125)))))
        {
            throw new BadRequest ((string)add(this.id, " setLeverage() leverage should be between 1 and 125")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("setLeverage", parameters);
        marginMode = ((List<object>)marginModeparametersVariable)[0];
        parameters = ((List<object>)marginModeparametersVariable)[1];
        if (isTrue(isEqual(marginMode, null)))
        {
            marginMode = this.safeString(parameters, "mgnMode", "cross"); // cross as default marginMode
        }
        if (isTrue(isTrue((!isEqual(marginMode, "cross"))) && isTrue((!isEqual(marginMode, "isolated")))))
        {
            throw new BadRequest ((string)add(this.id, " setLeverage() requires a marginMode parameter that must be either cross or isolated")) ;
        }
        object request = new Dictionary<string, object>() {
            { "lever", leverage },
            { "mgnMode", marginMode },
            { "instId", getValue(market, "id") },
        };
        object posSide = this.safeString(parameters, "posSide");
        if (isTrue(isEqual(marginMode, "isolated")))
        {
            if (isTrue(isEqual(posSide, null)))
            {
                throw new ArgumentsRequired ((string)add(this.id, " setLeverage() requires a posSide argument for isolated margin")) ;
            }
            if (isTrue(isTrue(isTrue(!isEqual(posSide, "long")) && isTrue(!isEqual(posSide, "short"))) && isTrue(!isEqual(posSide, "net"))))
            {
                throw new BadRequest ((string)add(this.id, " setLeverage() requires the posSide argument to be either \"long\", \"short\" or \"net\"")) ;
            }
        }
        object response = await this.privatePostAccountSetLeverage(this.extend(request, parameters));
        //
        //     {
        //       "code": "0",
        //       "data": [
        //         {
        //           "instId": "BTC-USDT-SWAP",
        //           "lever": "5",
        //           "mgnMode": "isolated",
        //           "posSide": "long"
        //         }
        //       ],
        //       "msg": ""
        //     }
        //
        return response;
    }

    public async virtual Task<object> setPositionMode(object hedged, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name okx#setPositionMode
        * @description set hedged to true or false for a market
        * @param {bool} hedged set to true to use long_short_mode, false for net_mode
        * @param {string|undefined} symbol not used by okx setPositionMode
        * @param {object} params extra parameters specific to the okx api endpoint
        * @returns {object} response from the exchange
        */
        parameters ??= new Dictionary<string, object>();
        object hedgeMode = null;
        if (isTrue(hedged))
        {
            hedgeMode = "long_short_mode";
        } else
        {
            hedgeMode = "net_mode";
        }
        object request = new Dictionary<string, object>() {
            { "posMode", hedgeMode },
        };
        object response = await this.privatePostAccountSetPositionMode(this.extend(request, parameters));
        //
        //    {
        //        "code": "0",
        //        "data": [
        //            {
        //                "posMode": "net_mode"
        //            }
        //        ],
        //        "msg": ""
        //    }
        //
        return response;
    }

    public async virtual Task<object> setMarginMode(object marginMode, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name okx#setMarginMode
        * @description set margin mode to 'cross' or 'isolated'
        * @param {string} marginMode 'cross' or 'isolated'
        * @param {string} symbol unified market symbol
        * @param {object} params extra parameters specific to the okx api endpoint
        * @returns {object} response from the exchange
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setMarginMode() requires a symbol argument")) ;
        }
        // WARNING: THIS WILL INCREASE LIQUIDATION PRICE FOR OPEN ISOLATED LONG POSITIONS
        // AND DECREASE LIQUIDATION PRICE FOR OPEN ISOLATED SHORT POSITIONS
        marginMode = ((string)marginMode).ToLower();
        if (isTrue(isTrue((!isEqual(marginMode, "cross"))) && isTrue((!isEqual(marginMode, "isolated")))))
        {
            throw new BadRequest ((string)add(this.id, " setMarginMode() marginMode must be either cross or isolated")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object lever = this.safeInteger(parameters, "lever");
        if (isTrue(isTrue(isTrue((isEqual(lever, null))) || isTrue((isLessThan(lever, 1)))) || isTrue((isGreaterThan(lever, 125)))))
        {
            throw new BadRequest ((string)add(this.id, " setMarginMode() params[\"lever\"] should be between 1 and 125")) ;
        }
        parameters = this.omit(parameters, new List<object>() {"lever"});
        object request = new Dictionary<string, object>() {
            { "lever", lever },
            { "mgnMode", marginMode },
            { "instId", getValue(market, "id") },
        };
        object response = await this.privatePostAccountSetLeverage(this.extend(request, parameters));
        //
        //     {
        //       "code": "0",
        //       "data": [
        //         {
        //           "instId": "BTC-USDT-SWAP",
        //           "lever": "5",
        //           "mgnMode": "isolated",
        //           "posSide": "long"
        //         }
        //       ],
        //       "msg": ""
        //     }
        //
        return response;
    }

    public async override Task<object> fetchBorrowRates(object parameters = null)
    {
        /**
        * @method
        * @name okx#fetchBorrowRates
        * @description fetch the borrow interest rates of all currencies
        * @param {object} params extra parameters specific to the okx api endpoint
        * @returns {object} a list of [borrow rate structures]{@link https://docs.ccxt.com/#/?id=borrow-rate-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetAccountInterestRate(parameters);
        //
        //    {
        //        "code": "0",
        //        "data": [
        //            {
        //                "ccy": "BTC",
        //                "interestRate": "0.00000833"
        //            }
        //            ...
        //        ],
        //    }
        //
        object timestamp = this.milliseconds();
        object data = this.safeValue(response, "data");
        object rates = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object rate = getValue(data, i);
            object code = this.safeCurrencyCode(this.safeString(rate, "ccy"));
            ((Dictionary<string, object>)rates)[(string)code] = new Dictionary<string, object>() {
                { "currency", code },
                { "rate", this.safeNumber(rate, "interestRate") },
                { "period", 86400000 },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
                { "info", rate },
            };
        }
        return rates;
    }

    public async override Task<object> fetchBorrowRate(object code, object parameters = null)
    {
        /**
        * @method
        * @name okx#fetchBorrowRate
        * @description fetch the rate of interest to borrow a currency for margin trading
        * @param {string} code unified currency code
        * @param {object} params extra parameters specific to the okx api endpoint
        * @returns {object} a [borrow rate structure]{@link https://docs.ccxt.com/#/?id=borrow-rate-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "ccy", getValue(currency, "id") },
        };
        object response = await this.privateGetAccountInterestRate(this.extend(request, parameters));
        //
        //    {
        //        "code": "0",
        //        "data": [
        //             {
        //                "ccy": "USDT",
        //                "interestRate": "0.00002065"
        //             }
        //             ...
        //        ],
        //        "msg": ""
        //    }
        //
        object data = this.safeValue(response, "data");
        object rate = this.safeValue(data, 0);
        return this.parseBorrowRate(rate);
    }

    public virtual object parseBorrowRate(object info, object currency = null)
    {
        //
        //    {
        //        "amt": "992.10341195",
        //        "ccy": "BTC",
        //        "rate": "0.01",
        //        "ts": "1643954400000"
        //    }
        //
        object ccy = this.safeString(info, "ccy");
        object timestamp = this.safeInteger(info, "ts");
        return new Dictionary<string, object>() {
            { "currency", this.safeCurrencyCode(ccy) },
            { "rate", this.safeNumber2(info, "interestRate", "rate") },
            { "period", 86400000 },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", info },
        };
    }

    public virtual object parseBorrowRateHistories(object response, object codes, object since, object limit)
    {
        //
        //    [
        //        {
        //            "amt": "992.10341195",
        //            "ccy": "BTC",
        //            "rate": "0.01",
        //            "ts": "1643954400000"
        //        },
        //        ...
        //    ]
        //
        object borrowRateHistories = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object item = getValue(response, i);
            object code = this.safeCurrencyCode(this.safeString(item, "ccy"));
            if (isTrue(isTrue(isEqual(codes, null)) || isTrue(this.inArray(code, codes))))
            {
                if (!isTrue((((Dictionary<string,object>)borrowRateHistories).ContainsKey(toStringOrNull(code)))))
                {
                    ((Dictionary<string, object>)borrowRateHistories)[(string)code] = new List<object>() {};
                }
                object borrowRateStructure = this.parseBorrowRate(item);
                ((List<object>)getValue(borrowRateHistories, code)).Add(borrowRateStructure);
            }
        }
        object keys = new List<object>(((Dictionary<string,object>)borrowRateHistories).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object code = getValue(keys, i);
            ((Dictionary<string, object>)borrowRateHistories)[(string)code] = this.filterByCurrencySinceLimit(getValue(borrowRateHistories, code), code, since, limit);
        }
        return borrowRateHistories;
    }

    public virtual object parseBorrowRateHistory(object response, object code, object since, object limit)
    {
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object item = getValue(response, i);
            object borrowRate = this.parseBorrowRate(item);
            ((List<object>)result).Add(borrowRate);
        }
        object sorted = this.sortBy(result, "timestamp");
        return this.filterByCurrencySinceLimit(sorted, code, since, limit);
    }

    public async virtual Task<object> fetchBorrowRateHistories(object codes = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name okx#fetchBorrowRateHistories
        * @description retrieves a history of a multiple currencies borrow interest rate at specific time slots, returns all currencies if no symbols passed, default is undefined
        * @param {[string]|undefined} codes list of unified currency codes, default is undefined
        * @param {int|undefined} since timestamp in ms of the earliest borrowRate, default is undefined
        * @param {int|undefined} limit max number of borrow rate prices to return, default is undefined
        * @param {object} params extra parameters specific to the okx api endpoint
        * @returns {object} a dictionary of [borrow rate structures]{@link https://docs.ccxt.com/#/?id=borrow-rate-structure} indexed by the market symbol
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["before"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object response = await this.publicGetFinanceSavingsLendingRateHistory(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "amt": "992.10341195",
        //                 "ccy": "BTC",
        //                 "rate": "0.01",
        //                 "ts": "1643954400000"
        //             },
        //         ],
        //         "msg": ""
        //     }
        //
        object data = this.safeValue(response, "data");
        return this.parseBorrowRateHistories(data, codes, since, limit);
    }

    public async virtual Task<object> fetchBorrowRateHistory(object code, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name okx#fetchBorrowRateHistory
        * @description retrieves a history of a currencies borrow interest rate at specific time slots
        * @param {string} code unified currency code
        * @param {int|undefined} since timestamp for the earliest borrow rate
        * @param {int|undefined} limit the maximum number of [borrow rate structures]{@link https://docs.ccxt.com/#/?id=borrow-rate-structure} to retrieve
        * @param {object} params extra parameters specific to the exchange api endpoint
        * @returns {[object]} an array of [borrow rate structures]{@link https://docs.ccxt.com/#/?id=borrow-rate-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "ccy", getValue(currency, "id") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["before"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object response = await this.publicGetFinanceSavingsLendingRateHistory(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "amt": "992.10341195",
        //                 "ccy": "BTC",
        //                 "rate": "0.01",
        //                 "ts": "1643954400000"
        //             },
        //         ],
        //         "msg": ""
        //     }
        //
        object data = this.safeValue(response, "data");
        return this.parseBorrowRateHistory(data, code, since, limit);
    }

    public async virtual Task<object> modifyMarginHelper(object symbol, object amount, object type, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object posSide = this.safeString(parameters, "posSide", "net");
        parameters = this.omit(parameters, new List<object>() {"posSide"});
        object request = new Dictionary<string, object>() {
            { "instId", getValue(market, "id") },
            { "amt", amount },
            { "type", type },
            { "posSide", posSide },
        };
        object response = await this.privatePostAccountPositionMarginBalance(this.extend(request, parameters));
        //
        //     {
        //       "code": "0",
        //       "data": [
        //         {
        //           "amt": "0.01",
        //           "instId": "ETH-USD-SWAP",
        //           "posSide": "net",
        //           "type": "reduce"
        //         }
        //       ],
        //       "msg": ""
        //     }
        //
        return this.parseMarginModification(response, market);
    }

    public virtual object parseMarginModification(object data, object market = null)
    {
        object innerData = this.safeValue(data, "data", new List<object>() {});
        object entry = this.safeValue(innerData, 0, new Dictionary<string, object>() {});
        object errorCode = this.safeString(data, "code");
        object status = ((bool) isTrue((isEqual(errorCode, "0")))) ? "ok" : "failed";
        object amountRaw = this.safeNumber(entry, "amt");
        object typeRaw = this.safeString(entry, "type");
        object type = ((bool) isTrue((isEqual(typeRaw, "reduce")))) ? "reduce" : "add";
        object marketId = this.safeString(entry, "instId");
        object responseMarket = this.safeMarket(marketId, market);
        object code = ((bool) isTrue(getValue(responseMarket, "inverse"))) ? getValue(responseMarket, "base") : getValue(responseMarket, "quote");
        return new Dictionary<string, object>() {
            { "info", data },
            { "type", type },
            { "amount", amountRaw },
            { "code", code },
            { "symbol", getValue(responseMarket, "symbol") },
            { "status", status },
        };
    }

    public async virtual Task<object> reduceMargin(object symbol, object amount, object parameters = null)
    {
        /**
        * @method
        * @name okx#reduceMargin
        * @description remove margin from a position
        * @param {string} symbol unified market symbol
        * @param {float} amount the amount of margin to remove
        * @param {object} params extra parameters specific to the okx api endpoint
        * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=reduce-margin-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.modifyMarginHelper(symbol, amount, "reduce", parameters);
    }

    public async virtual Task<object> addMargin(object symbol, object amount, object parameters = null)
    {
        /**
        * @method
        * @name okx#addMargin
        * @description add margin
        * @param {string} symbol unified market symbol
        * @param {float} amount amount of margin to add
        * @param {object} params extra parameters specific to the okx api endpoint
        * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=add-margin-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.modifyMarginHelper(symbol, amount, "add", parameters);
    }

    public async override Task<object> fetchMarketLeverageTiers(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name okx#fetchMarketLeverageTiers
        * @description retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes for a single market
        * @see https://www.okx.com/docs-v5/en/#rest-api-public-data-get-position-tiers
        * @param {string} symbol unified market symbol
        * @param {object} params extra parameters specific to the okx api endpoint
        * @param {string} params.marginMode 'cross' or 'isolated'
        * @returns {object} a [leverage tiers structure]{@link https://docs.ccxt.com/#/?id=leverage-tiers-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object type = ((bool) isTrue(getValue(market, "spot"))) ? "MARGIN" : this.convertToInstrumentType(getValue(market, "type"));
        object uly = this.safeString(getValue(market, "info"), "uly");
        if (!isTrue(uly))
        {
            if (isTrue(!isEqual(type, "MARGIN")))
            {
                throw new BadRequest ((string)add(add(this.id, " fetchMarketLeverageTiers() cannot fetch leverage tiers for "), symbol)) ;
            }
        }
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchMarketLeverageTiers", parameters);
        marginMode = ((List<object>)marginModeparametersVariable)[0];
        parameters = ((List<object>)marginModeparametersVariable)[1];
        if (isTrue(isEqual(marginMode, null)))
        {
            marginMode = this.safeString(parameters, "tdMode", "cross"); // cross as default marginMode
        }
        object request = new Dictionary<string, object>() {
            { "instType", type },
            { "tdMode", marginMode },
            { "uly", uly },
        };
        if (isTrue(isEqual(type, "MARGIN")))
        {
            ((Dictionary<string, object>)request)["instId"] = getValue(market, "id");
        }
        object response = await this.publicGetPublicPositionTiers(this.extend(request, parameters));
        //
        //    {
        //        "code": "0",
        //        "data": [
        //            {
        //                "baseMaxLoan": "500",
        //                "imr": "0.1",
        //                "instId": "ETH-USDT",
        //                "maxLever": "10",
        //                "maxSz": "500",
        //                "minSz": "0",
        //                "mmr": "0.03",
        //                "optMgnFactor": "0",
        //                "quoteMaxLoan": "200000",
        //                "tier": "1",
        //                "uly": ""
        //            },
        //            ...
        //        ]
        //    }
        //
        object data = this.safeValue(response, "data");
        return this.parseMarketLeverageTiers(data, market);
    }

    public override object parseMarketLeverageTiers(object info, object market = null)
    {
        /**
         * @ignore
         * @method
         * @param {object} info Exchange response for 1 market
         * @param {object} market CCXT market
         */
        //
        //    [
        //        {
        //            "baseMaxLoan": "500",
        //            "imr": "0.1",
        //            "instId": "ETH-USDT",
        //            "maxLever": "10",
        //            "maxSz": "500",
        //            "minSz": "0",
        //            "mmr": "0.03",
        //            "optMgnFactor": "0",
        //            "quoteMaxLoan": "200000",
        //            "tier": "1",
        //            "uly": ""
        //        },
        //        ...
        //    ]
        //
        object tiers = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(info)); postFixIncrement(ref i))
        {
            object tier = getValue(info, i);
            ((List<object>)tiers).Add(new Dictionary<string, object>() {
                { "tier", this.safeInteger(tier, "tier") },
                { "currency", getValue(market, "quote") },
                { "minNotional", this.safeNumber(tier, "minSz") },
                { "maxNotional", this.safeNumber(tier, "maxSz") },
                { "maintenanceMarginRate", this.safeNumber(tier, "mmr") },
                { "maxLeverage", this.safeNumber(tier, "maxLever") },
                { "info", tier },
            });
        }
        return tiers;
    }

    public async override Task<object> fetchBorrowInterest(object code = null, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name okx#fetchBorrowInterest
        * @description fetch the interest owed by the user for borrowing currency for margin trading
        * @see https://www.okx.com/docs-v5/en/#rest-api-account-get-interest-accrued-data
        * @param {string|undefined} code the unified currency code for the currency of the interest
        * @param {string|undefined} symbol the market symbol of an isolated margin market, if undefined, the interest for cross margin markets is returned
        * @param {int|undefined} since timestamp in ms of the earliest time to receive interest records for
        * @param {int|undefined} limit the number of [borrow interest structures]{@link https://docs.ccxt.com/#/?id=borrow-interest-structure} to retrieve
        * @param {object} params exchange specific parameters
        * @param {int|undefined} params.type Loan type 1 - VIP loans 2 - Market loans *Default is Market loans*
        * @param {string} params.marginMode 'cross' or 'isolated'
        * @returns {[object]} An list of [borrow interest structures]{@link https://docs.ccxt.com/#/?id=borrow-interest-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object marginMode = null;
        var marginModeparametersVariable = this.handleMarginModeAndParams("fetchBorrowInterest", parameters);
        marginMode = ((List<object>)marginModeparametersVariable)[0];
        parameters = ((List<object>)marginModeparametersVariable)[1];
        if (isTrue(isEqual(marginMode, null)))
        {
            marginMode = this.safeString(parameters, "mgnMode", "cross"); // cross as default marginMode
        }
        object request = new Dictionary<string, object>() {
            { "mgnMode", marginMode },
        };
        object market = null;
        if (isTrue(!isEqual(code, null)))
        {
            object currency = this.currency(code);
            ((Dictionary<string, object>)request)["ccy"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["before"] = subtract(since, 1);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((Dictionary<string, object>)request)["instId"] = getValue(market, "id");
        }
        object response = await this.privateGetAccountInterestAccrued(this.extend(request, parameters));
        //
        //    {
        //        "code": "0",
        //        "data": [
        //            {
        //                "ccy": "USDT",
        //                "instId": "",
        //                "interest": "0.0003960833333334",
        //                "interestRate": "0.0000040833333333",
        //                "liab": "97",
        //                "mgnMode": "",
        //                "ts": "1637312400000",
        //                "type": "1"
        //            },
        //            ...
        //        ],
        //        "msg": ""
        //    }
        //
        object data = this.safeValue(response, "data");
        object interest = this.parseBorrowInterests(data);
        return this.filterByCurrencySinceLimit(interest, code, since, limit);
    }

    public override object parseBorrowInterest(object info, object market = null)
    {
        object instId = this.safeString(info, "instId");
        if (isTrue(!isEqual(instId, null)))
        {
            market = this.safeMarket(instId, market);
        }
        object timestamp = this.safeInteger(info, "ts");
        return new Dictionary<string, object>() {
            { "symbol", this.safeString(market, "symbol") },
            { "marginMode", this.safeString(info, "mgnMode") },
            { "currency", this.safeCurrencyCode(this.safeString(info, "ccy")) },
            { "interest", this.safeNumber(info, "interest") },
            { "interestRate", this.safeNumber(info, "interestRate") },
            { "amountBorrowed", this.safeNumber(info, "liab") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", info },
        };
    }

    public async virtual Task<object> borrowMargin(object code, object amount, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name okx#borrowMargin
        * @description create a loan to borrow margin
        * @see https://www.okx.com/docs-v5/en/#rest-api-account-vip-loans-borrow-and-repay
        * @param {string} code unified currency code of the currency to borrow
        * @param {float} amount the amount to borrow
        * @param {string|undefined} symbol not used by okx.borrowMargin ()
        * @param {object} params extra parameters specific to the okx api endpoint
        * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "ccy", getValue(currency, "id") },
            { "amt", this.currencyToPrecision(code, amount) },
            { "side", "borrow" },
        };
        object response = await this.privatePostAccountBorrowRepay(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "amt": "102",
        //                 "availLoan": "97",
        //                 "ccy": "USDT",
        //                 "loanQuota": "6000000",
        //                 "posLoan": "0",
        //                 "side": "borrow",
        //                 "usedLoan": "97"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object loan = this.safeValue(data, 0);
        object transaction = this.parseMarginLoan(loan, currency);
        return this.extend(transaction, new Dictionary<string, object>() {
            { "symbol", symbol },
        });
    }

    public async virtual Task<object> repayMargin(object code, object amount, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name okx#repayMargin
        * @description repay borrowed margin and interest
        * @see https://www.okx.com/docs-v5/en/#rest-api-account-vip-loans-borrow-and-repay
        * @param {string} code unified currency code of the currency to repay
        * @param {float} amount the amount to repay
        * @param {string|undefined} symbol not used by okx.repayMargin ()
        * @param {object} params extra parameters specific to the okx api endpoint
        * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "ccy", getValue(currency, "id") },
            { "amt", this.currencyToPrecision(code, amount) },
            { "side", "repay" },
        };
        object response = await this.privatePostAccountBorrowRepay(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "amt": "102",
        //                 "availLoan": "97",
        //                 "ccy": "USDT",
        //                 "loanQuota": "6000000",
        //                 "posLoan": "0",
        //                 "side": "repay",
        //                 "usedLoan": "97"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object loan = this.safeValue(data, 0);
        object transaction = this.parseMarginLoan(loan, currency);
        return this.extend(transaction, new Dictionary<string, object>() {
            { "symbol", symbol },
        });
    }

    public virtual object parseMarginLoan(object info, object currency = null)
    {
        //
        //     {
        //         "amt": "102",
        //         "availLoan": "97",
        //         "ccy": "USDT",
        //         "loanQuota": "6000000",
        //         "posLoan": "0",
        //         "side": "repay",
        //         "usedLoan": "97"
        //     }
        //
        object currencyId = this.safeString(info, "ccy");
        return new Dictionary<string, object>() {
            { "id", null },
            { "currency", this.safeCurrencyCode(currencyId, currency) },
            { "amount", this.safeNumber(info, "amt") },
            { "symbol", null },
            { "timestamp", null },
            { "datetime", null },
            { "info", info },
        };
    }

    public async override Task<object> fetchOpenInterest(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name okx#fetchOpenInterest
        * @description Retrieves the open interest of a currency
        * @see https://www.okx.com/docs-v5/en/#rest-api-public-data-get-open-interest
        * @param {string} symbol Unified CCXT market symbol
        * @param {object} params exchange specific parameters
        * @returns {object} an open interest structure{@link https://docs.ccxt.com/#/?id=interest-history-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "contract")))
        {
            throw new BadRequest ((string)add(this.id, " fetchOpenInterest() supports contract markets only")) ;
        }
        object type = this.convertToInstrumentType(getValue(market, "type"));
        object uly = this.safeString(getValue(market, "info"), "uly");
        object request = new Dictionary<string, object>() {
            { "instType", type },
            { "uly", uly },
            { "instId", getValue(market, "id") },
        };
        object response = await this.publicGetPublicOpenInterest(this.extend(request, parameters));
        //
        //     {
        //         "code": "0",
        //         "data": [
        //             {
        //                 "instId": "BTC-USDT-SWAP",
        //                 "instType": "SWAP",
        //                 "oi": "2125419",
        //                 "oiCcy": "21254.19",
        //                 "ts": "1664005108969"
        //             }
        //         ],
        //         "msg": ""
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        return this.parseOpenInterest(getValue(data, 0), market);
    }

    public async override Task<object> fetchOpenInterestHistory(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name okx#fetchOpenInterestHistory
        * @description Retrieves the open interest history of a currency
        * @param {string} symbol Unified CCXT currency code instead of a unified symbol
        * @param {string} timeframe "5m", "1h", or "1d"
        * @param {int|undefined} since The time in ms of the earliest record to retrieve as a unix timestamp
        * @param {int|undefined} limit Not used by okx, but parsed internally by CCXT
        * @param {object} params Exchange specific parameters
        * @param {int|undefined} params.until The time in ms of the latest record to retrieve as a unix timestamp
        * @returns An array of [open interest structures]{@link https://docs.ccxt.com/#/?id=interest-history-structure}
        */
        timeframe ??= "5m";
        parameters ??= new Dictionary<string, object>();
        object options = this.safeValue(this.options, "fetchOpenInterestHistory", new Dictionary<string, object>() {});
        object timeframes = this.safeValue(options, "timeframes", new Dictionary<string, object>() {});
        timeframe = this.safeString(timeframes, timeframe, timeframe);
        if (isTrue(isTrue(isTrue(!isEqual(timeframe, "5m")) && isTrue(!isEqual(timeframe, "1H"))) && isTrue(!isEqual(timeframe, "1D"))))
        {
            throw new BadRequest ((string)add(this.id, " fetchOpenInterestHistory cannot only use the 5m, 1h, and 1d timeframe")) ;
        }
        await this.loadMarkets();
        object currency = this.currency(symbol);
        object request = new Dictionary<string, object>() {
            { "ccy", getValue(currency, "id") },
            { "period", timeframe },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["begin"] = since;
        }
        object until = this.safeInteger2(parameters, "till", "until");
        if (isTrue(!isEqual(until, null)))
        {
            ((Dictionary<string, object>)request)["end"] = until;
            parameters = this.omit(parameters, new List<object>() {"until", "till"});
        }
        object response = await this.publicGetRubikStatContractsOpenInterestVolume(this.extend(request, parameters));
        //
        //    {
        //        code: '0',
        //        data: [
        //            [
        //                '1648221300000',  // timestamp
        //                '2183354317.945',  // open interest (USD)
        //                '74285877.617',  // volume (USD)
        //            ],
        //            ...
        //        ],
        //        msg: ''
        //    }
        //
        object data = this.safeValue(response, "data");
        return this.parseOpenInterests(data, null, since, limit);
    }

    public override object parseOpenInterest(object interest, object market = null)
    {
        //
        // fetchOpenInterestHistory
        //
        //    [
        //        '1648221300000',  // timestamp
        //        '2183354317.945',  // open interest (USD)
        //        '74285877.617',  // volume (USD)
        //    ]
        //
        // fetchOpenInterest
        //
        //     {
        //         "instId": "BTC-USDT-SWAP",
        //         "instType": "SWAP",
        //         "oi": "2125419",
        //         "oiCcy": "21254.19",
        //         "ts": "1664005108969"
        //     }
        //
        object id = this.safeString(interest, "instId");
        market = this.safeMarket(id, market);
        object time = this.safeInteger(interest, "ts");
        object timestamp = this.safeNumber(interest, 0, time);
        object numContracts = this.safeNumber(interest, "oi");
        object inCurrency = this.safeNumber(interest, "oiCcy");
        object openInterest = this.safeNumber(interest, 1, inCurrency);
        return new Dictionary<string, object>() {
            { "symbol", this.safeSymbol(id) },
            { "baseVolume", null },
            { "quoteVolume", openInterest },
            { "openInterestAmount", numContracts },
            { "openInterestValue", openInterest },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", interest },
        };
    }

    public override void setSandboxMode(object enable)
    {
        base.setSandboxMode(enable);
        ((Dictionary<string, object>)this.options)["sandboxMode"] = enable;
        if (isTrue(enable))
        {
            ((Dictionary<string, object>)this.headers)["x-simulated-trading"] = "1";
        } else if (isTrue(((Dictionary<string,object>)this.headers).ContainsKey(toStringOrNull("x-simulated-trading"))))
        {
            this.headers = this.omit(this.headers, "x-simulated-trading");
        }
    }

    public async override Task<object> fetchDepositWithdrawFees(object codes = null, object parameters = null)
    {
        /**
        * @method
        * @name okx#fetchDepositWithdrawFees
        * @description fetch deposit and withdraw fees
        * @see https://www.okx.com/docs-v5/en/#rest-api-funding-get-currencies
        * @param {[string]|undefined} codes list of unified currency codes
        * @param {object} params extra parameters specific to the okx api endpoint
        * @returns {[object]} a list of [fees structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetAssetCurrencies(parameters);
        //
        //    {
        //        "code": "0",
        //        "data": [
        //            {
        //                "canDep": true,
        //                "canInternal": false,
        //                "canWd": true,
        //                "ccy": "USDT",
        //                "chain": "USDT-TRC20",
        //                "logoLink": "https://static.coinall.ltd/cdn/assets/imgs/221/5F74EB20302D7761.png",
        //                "mainNet": false,
        //                "maxFee": "1.6",
        //                "maxWd": "8852150",
        //                "minFee": "0.8",
        //                "minWd": "2",
        //                "name": "Tether",
        //                "usedWdQuota": "0",
        //                "wdQuota": "500",
        //                "wdTickSz": "3"
        //            },
        //            {
        //                "canDep": true,
        //                "canInternal": false,
        //                "canWd": true,
        //                "ccy": "USDT",
        //                "chain": "USDT-ERC20",
        //                "logoLink": "https://static.coinall.ltd/cdn/assets/imgs/221/5F74EB20302D7761.png",
        //                "mainNet": false,
        //                "maxFee": "16",
        //                "maxWd": "8852150",
        //                "minFee": "8",
        //                "minWd": "2",
        //                "name": "Tether",
        //                "usedWdQuota": "0",
        //                "wdQuota": "500",
        //                "wdTickSz": "3"
        //            },
        //            ...
        //        ],
        //        "msg": ""
        //    }
        //
        object data = this.safeValue(response, "data");
        return this.parseDepositWithdrawFees(data, codes);
    }

    public override object parseDepositWithdrawFees(object response, object codes = null, object currencyIdKey = null)
    {
        //
        // [
        //   {
        //       "canDep": true,
        //       "canInternal": false,
        //       "canWd": true,
        //       "ccy": "USDT",
        //       "chain": "USDT-TRC20",
        //       "logoLink": "https://static.coinall.ltd/cdn/assets/imgs/221/5F74EB20302D7761.png",
        //       "mainNet": false,
        //       "maxFee": "1.6",
        //       "maxWd": "8852150",
        //       "minFee": "0.8",
        //       "minWd": "2",
        //       "name": "Tether",
        //       "usedWdQuota": "0",
        //       "wdQuota": "500",
        //       "wdTickSz": "3"
        //   }
        // ]
        //
        object depositWithdrawFees = new Dictionary<string, object>() {};
        codes = this.marketCodes(codes);
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object feeInfo = getValue(response, i);
            object currencyId = this.safeString(feeInfo, "ccy");
            object code = this.safeCurrencyCode(currencyId);
            if (isTrue(isTrue((isEqual(codes, null))) || isTrue((this.inArray(code, codes)))))
            {
                object depositWithdrawFee = this.safeValue(depositWithdrawFees, code);
                if (isTrue(isEqual(depositWithdrawFee, null)))
                {
                    ((Dictionary<string, object>)depositWithdrawFees)[(string)code] = this.depositWithdrawFee(new Dictionary<string, object>() {});
                }
                ((Dictionary<string, object>)getValue(getValue(depositWithdrawFees, code), "info"))[(string)currencyId] = feeInfo;
                object chain = this.safeString(feeInfo, "chain");
                object chainSplit = ((string)chain).Split((string)"-").ToList<object>();
                object networkId = this.safeValue(chainSplit, 1);
                object withdrawFee = this.safeNumber(feeInfo, "minFee");
                object withdrawResult = new Dictionary<string, object>() {
                    { "fee", withdrawFee },
                    { "percentage", ((bool) isTrue((!isEqual(withdrawFee, null)))) ? false : null },
                };
                object depositResult = new Dictionary<string, object>() {
                    { "fee", null },
                    { "percentage", null },
                };
                object networkCode = this.networkIdToCode(networkId, code);
                ((Dictionary<string, object>)getValue(getValue(depositWithdrawFees, code), "networks"))[(string)networkCode] = new Dictionary<string, object>() {
                    { "withdraw", withdrawResult },
                    { "deposit", depositResult },
                };
            }
        }
        object depositWithdrawCodes = new List<object>(((Dictionary<string,object>)depositWithdrawFees).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(depositWithdrawCodes)); postFixIncrement(ref i))
        {
            object code = getValue(depositWithdrawCodes, i);
            object currency = this.currency(code);
            ((Dictionary<string, object>)depositWithdrawFees)[(string)code] = this.assignDefaultDepositWithdrawFees(getValue(depositWithdrawFees, code), currency);
        }
        return depositWithdrawFees;
    }

    public override object handleErrors(object httpCode, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (!isTrue(response))
        {
            return null;  // fallback to default error handler
        }
        //
        //    {
        //        "code": "1",
        //        "data": [
        //            {
        //                "clOrdId": "",
        //                "ordId": "",
        //                "sCode": "51119",
        //                "sMsg": "Order placement failed due to insufficient balance. ",
        //                "tag": ""
        //            }
        //        ],
        //        "msg": ""
        //    },
        //    {
        //        "code": "58001",
        //        "data": [],
        //        "msg": "Incorrect trade password"
        //    }
        //
        object code = this.safeString(response, "code");
        if (isTrue(!isEqual(code, "0")))
        {
            object feedback = add(add(this.id, " "), body);
            object data = this.safeValue(response, "data", new List<object>() {});
            for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
            {
                object error = getValue(data, i);
                object errorCode = this.safeString(error, "sCode");
                object message = this.safeString(error, "sMsg");
                this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorCode, feedback);
                this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
            }
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), code, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }
}
