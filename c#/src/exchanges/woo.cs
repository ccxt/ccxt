using ccxt;
namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

partial class woo : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "woo" },
            { "name", "WOO X" },
            { "countries", new List<object>() {"KY"} },
            { "rateLimit", 100 },
            { "version", "v1" },
            { "certified", false },
            { "pro", true },
            { "hostname", "woo.org" },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", true },
                { "swap", true },
                { "future", false },
                { "option", false },
                { "addMargin", false },
                { "borrowMargin", false },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "cancelWithdraw", false },
                { "createDepositAddress", false },
                { "createMarketOrder", false },
                { "createOrder", true },
                { "createReduceOnlyOrder", true },
                { "createStopLimitOrder", false },
                { "createStopMarketOrder", false },
                { "createStopOrder", false },
                { "fetchAccounts", true },
                { "fetchBalance", true },
                { "fetchCanceledOrders", false },
                { "fetchClosedOrder", false },
                { "fetchClosedOrders", false },
                { "fetchCurrencies", true },
                { "fetchDepositAddress", false },
                { "fetchDeposits", true },
                { "fetchFundingHistory", true },
                { "fetchFundingRate", true },
                { "fetchFundingRateHistory", true },
                { "fetchFundingRates", true },
                { "fetchIndexOHLCV", false },
                { "fetchLedger", true },
                { "fetchLeverage", true },
                { "fetchMarginMode", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrder", false },
                { "fetchOpenOrders", false },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrders", true },
                { "fetchOrderTrades", true },
                { "fetchPosition", true },
                { "fetchPositionMode", false },
                { "fetchPositions", true },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchStatus", false },
                { "fetchTicker", false },
                { "fetchTickers", false },
                { "fetchTime", false },
                { "fetchTrades", true },
                { "fetchTradingFee", false },
                { "fetchTradingFees", true },
                { "fetchTransactions", true },
                { "fetchTransfers", true },
                { "fetchWithdrawals", true },
                { "reduceMargin", false },
                { "repayMargin", true },
                { "setLeverage", true },
                { "setMargin", false },
                { "transfer", true },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1m" },
                { "5m", "5m" },
                { "15m", "15m" },
                { "30m", "30m" },
                { "1h", "1h" },
                { "4h", "4h" },
                { "12h", "12h" },
                { "1d", "1d" },
                { "1w", "1w" },
                { "1M", "1mon" },
                { "1y", "1y" },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/1294454/150730761-1a00e5e0-d28c-480f-9e65-089ce3e6ef3b.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "pub", "https://api-pub.woo.org" },
                    { "public", "https://api.{hostname}" },
                    { "private", "https://api.{hostname}" },
                } },
                { "test", new Dictionary<string, object>() {
                    { "pub", "https://api-pub.staging.woo.org" },
                    { "public", "https://api.staging.woo.org" },
                    { "private", "https://api.staging.woo.org" },
                } },
                { "www", "https://woo.org/" },
                { "doc", new List<object>() {"https://docs.woo.org/"} },
                { "fees", new List<object>() {"https://support.woo.org/hc/en-001/articles/4404611795353--Trading-Fees"} },
                { "referral", "https://referral.woo.org/BAJS6oNmZb3vi3RGA" },
            } },
            { "api", new Dictionary<string, object>() {
                { "v1", new Dictionary<string, object>() {
                    { "pub", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "hist/kline", 10 },
                            { "hist/trades", 1 },
                        } },
                    } },
                    { "public", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "info", 1 },
                            { "info/{symbol}", 1 },
                            { "system_info", 1 },
                            { "market_trades", 1 },
                            { "token", 1 },
                            { "token_network", 1 },
                            { "funding_rates", 1 },
                            { "funding_rate/{symbol}", 1 },
                            { "funding_rate_history", 1 },
                            { "futures", 1 },
                            { "futures/{symbol}", 1 },
                            { "orderbook/{symbol}", 1 },
                            { "kline", 1 },
                        } },
                    } },
                    { "private", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "client/token", 1 },
                            { "order/{oid}", 1 },
                            { "client/order/{client_order_id}", 1 },
                            { "orders", 1 },
                            { "client/trade/{tid}", 1 },
                            { "order/{oid}/trades", 1 },
                            { "client/trades", 1 },
                            { "client/info", 60 },
                            { "asset/deposit", 10 },
                            { "asset/history", 60 },
                            { "sub_account/all", 60 },
                            { "sub_account/assets", 60 },
                            { "token_interest", 60 },
                            { "token_interest/{token}", 60 },
                            { "interest/history", 60 },
                            { "interest/repay", 60 },
                            { "funding_fee/history", 30 },
                            { "positions", 3.33 },
                            { "position/{symbol}", 3.33 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "order", 5 },
                            { "asset/main_sub_transfer", 30 },
                            { "asset/withdraw", 30 },
                            { "interest/repay", 60 },
                            { "client/account_mode", 120 },
                            { "client/leverage", 120 },
                        } },
                        { "delete", new Dictionary<string, object>() {
                            { "order", 1 },
                            { "client/order", 1 },
                            { "orders", 1 },
                            { "asset/withdraw", 120 },
                        } },
                    } },
                } },
                { "v2", new Dictionary<string, object>() {
                    { "private", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "client/holding", 1 },
                        } },
                    } },
                } },
                { "v3", new Dictionary<string, object>() {
                    { "private", new Dictionary<string, object>() {
                        { "get", new Dictionary<string, object>() {
                            { "algo/order/{oid}", 1 },
                            { "algo/orders", 1 },
                            { "balances", 1 },
                            { "accountinfo", 60 },
                            { "positions", 3.33 },
                            { "buypower", 1 },
                        } },
                        { "post", new Dictionary<string, object>() {
                            { "algo/order", 5 },
                        } },
                        { "put", new Dictionary<string, object>() {
                            { "order/{oid}", 2 },
                            { "order/client/{client_order_id}", 2 },
                            { "algo/order/{oid}", 2 },
                            { "algo/order/client/{client_order_id}", 2 },
                        } },
                        { "delete", new Dictionary<string, object>() {
                            { "algo/order/{oid}", 1 },
                            { "algo/orders/pending", 1 },
                            { "algo/orders/pending/{symbol}", 1 },
                            { "orders/pending", 1 },
                        } },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "tierBased", true },
                    { "percentage", true },
                    { "maker", this.parseNumber("0.0002") },
                    { "taker", this.parseNumber("0.0005") },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "createMarketBuyOrderRequiresPrice", true },
                { "network-aliases-for-tokens", new Dictionary<string, object>() {
                    { "HT", "ERC20" },
                    { "OMG", "ERC20" },
                    { "UATOM", "ATOM" },
                    { "ZRX", "ZRX" },
                } },
                { "networks", new Dictionary<string, object>() {
                    { "TRX", "TRON" },
                    { "TRC20", "TRON" },
                    { "ERC20", "ETH" },
                    { "BEP20", "BSC" },
                } },
                { "defaultNetworkCodeForCurrencies", new Dictionary<string, object>() {} },
                { "transfer", new Dictionary<string, object>() {
                    { "fillResponseFromRequest", true },
                } },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {} },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "-1000", typeof(ExchangeError) },
                    { "-1001", typeof(AuthenticationError) },
                    { "-1002", typeof(AuthenticationError) },
                    { "-1003", typeof(RateLimitExceeded) },
                    { "-1004", typeof(BadRequest) },
                    { "-1005", typeof(BadRequest) },
                    { "-1006", typeof(BadRequest) },
                    { "-1007", typeof(BadRequest) },
                    { "-1008", typeof(InvalidOrder) },
                    { "-1009", typeof(BadRequest) },
                    { "-1011", typeof(ExchangeError) },
                    { "-1012", typeof(BadRequest) },
                    { "-1101", typeof(InvalidOrder) },
                    { "-1102", typeof(InvalidOrder) },
                    { "-1103", typeof(InvalidOrder) },
                    { "-1104", typeof(InvalidOrder) },
                    { "-1105", typeof(InvalidOrder) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "symbol must not be blank", typeof(BadRequest) },
                    { "The token is not supported", typeof(BadRequest) },
                    { "Your order and symbol are not valid or already canceled", typeof(BadRequest) },
                    { "Insufficient WOO. Please enable margin trading for leverage trading", typeof(BadRequest) },
                } },
            } },
            { "precisionMode", TICK_SIZE },
        });
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name woo#fetchMarkets
        * @description retrieves data on all markets for woo
        * @param {object} params extra parameters specific to the exchange api endpoint
        * @returns {[object]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.v1PublicGetInfo(parameters);
        //
        // {
        //     rows: [
        //         {
        //             symbol: "SPOT_AAVE_USDT",
        //             quote_min: 0,
        //             quote_max: 100000,
        //             quote_tick: 0.01,
        //             base_min: 0.01,
        //             base_max: 7284,
        //             base_tick: 0.0001,
        //             min_notional: 10,
        //             price_range: 0.1,
        //             created_time: "0",
        //             updated_time: "1639107647.988",
        //             is_stable: 0
        //         },
        //         ...
        //     success: true
        // }
        //
        object result = new List<object>() {};
        object data = this.safeValue(response, "rows", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object market = getValue(data, i);
            object marketId = this.safeString(market, "symbol");
            object parts = ((string)marketId).Split((string)"_").ToList<object>();
            object marketType = this.safeStringLower(parts, 0);
            object isSpot = isEqual(marketType, "spot");
            object isSwap = isEqual(marketType, "perp");
            object baseId = this.safeString(parts, 1);
            object quoteId = this.safeString(parts, 2);
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            object settleId = null;
            object settle = null;
            object symbol = add(add(bs, "/"), quote);
            object contractSize = null;
            object linear = null;
            if (isTrue(isSwap))
            {
                settleId = this.safeString(parts, 2);
                settle = this.safeCurrencyCode(settleId);
                symbol = add(add(add(add(bs, "/"), quote), ":"), settle);
                contractSize = this.parseNumber("1");
                marketType = "swap";
                linear = true;
            }
            ((List<object>)result).Add(new Dictionary<string, object>() {
                { "id", marketId },
                { "symbol", symbol },
                { "base", bs },
                { "quote", quote },
                { "settle", settle },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", settleId },
                { "type", marketType },
                { "spot", isSpot },
                { "margin", true },
                { "swap", isSwap },
                { "future", false },
                { "option", false },
                { "active", null },
                { "contract", isSwap },
                { "linear", linear },
                { "inverse", null },
                { "contractSize", contractSize },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", this.safeNumber(market, "base_tick") },
                    { "price", this.safeNumber(market, "quote_tick") },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "base_min") },
                        { "max", this.safeNumber(market, "base_max") },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "quote_min") },
                        { "max", this.safeNumber(market, "quote_max") },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "min_notional") },
                        { "max", null },
                    } },
                } },
                { "info", market },
            });
        }
        return result;
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int|undefined} since timestamp in ms of the earliest trade to fetch
        * @param {int|undefined} limit the maximum amount of trades to fetch
        * @param {object} params extra parameters specific to the woo api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/en/latest/manual.html?#public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchTrades() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object response = await this.v1PublicGetMarketTrades(this.extend(request, parameters));
        //
        // {
        //     success: true,
        //     rows: [
        //         {
        //             symbol: "SPOT_BTC_USDT",
        //             side: "SELL",
        //             executed_price: 46222.35,
        //             executed_quantity: 0.0012,
        //             executed_timestamp: "1641241162.329"
        //         },
        //         {
        //             symbol: "SPOT_BTC_USDT",
        //             side: "SELL",
        //             executed_price: 46222.35,
        //             executed_quantity: 0.0012,
        //             executed_timestamp: "1641241162.329"
        //         },
        //         {
        //             symbol: "SPOT_BTC_USDT",
        //             side: "BUY",
        //             executed_price: 46224.32,
        //             executed_quantity: 0.00039,
        //             executed_timestamp: "1641241162.287"
        //         },
        //         ...
        //      ]
        // }
        //
        object resultResponse = this.safeValue(response, "rows", new Dictionary<string, object>() {});
        return this.parseTrades(resultResponse, market, since, limit);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // public/market_trades
        //
        //     {
        //         symbol: "SPOT_BTC_USDT",
        //         side: "SELL",
        //         executed_price: 46222.35,
        //         executed_quantity: 0.0012,
        //         executed_timestamp: "1641241162.329"
        //     }
        //
        // fetchOrderTrades, fetchOrder
        //
        //     {
        //         id: '99119876',
        //         symbol: 'SPOT_WOO_USDT',
        //         fee: '0.0024',
        //         side: 'BUY',
        //         executed_timestamp: '1641481113.084',
        //         order_id: '87001234',
        //         order_tag: 'default', <-- this param only in "fetchOrderTrades"
        //         executed_price: '1',
        //         executed_quantity: '12',
        //         fee_asset: 'WOO',
        //         is_maker: '1'
        //     }
        //
        object isFromFetchOrder = (((Dictionary<string,object>)trade).ContainsKey(toStringOrNull("id")));
        object timestamp = this.safeTimestamp(trade, "executed_timestamp");
        object marketId = this.safeString(trade, "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object price = this.safeString(trade, "executed_price");
        object amount = this.safeString(trade, "executed_quantity");
        object order_id = this.safeString(trade, "order_id");
        object fee = this.parseTokenAndFeeTemp(trade, "fee_asset", "fee");
        object cost = Precise.stringMul(price, amount);
        object side = this.safeStringLower(trade, "side");
        object id = this.safeString(trade, "id");
        object takerOrMaker = null;
        if (isTrue(isFromFetchOrder))
        {
            object isMaker = isEqual(this.safeString(trade, "is_maker"), "1");
            takerOrMaker = ((bool) isTrue(isMaker)) ? "maker" : "taker";
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", id },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "side", side },
            { "price", price },
            { "amount", amount },
            { "cost", cost },
            { "order", order_id },
            { "takerOrMaker", takerOrMaker },
            { "type", null },
            { "fee", fee },
            { "info", trade },
        }, market);
    }

    public virtual object parseTokenAndFeeTemp(object item, object feeTokenKey, object feeAmountKey)
    {
        object feeCost = this.safeString(item, feeAmountKey);
        object fee = null;
        if (isTrue(!isEqual(feeCost, null)))
        {
            object feeCurrencyId = this.safeString(item, feeTokenKey);
            object feeCurrencyCode = this.safeCurrencyCode(feeCurrencyId);
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", feeCurrencyCode },
            };
        }
        return fee;
    }

    public async override Task<object> fetchTradingFees(object parameters = null)
    {
        /**
        * @method
        * @name woo#fetchTradingFees
        * @description fetch the trading fees for multiple markets
        * @see https://docs.woo.org/#get-account-information-new
        * @param {object} params extra parameters specific to the woo api endpoint
        * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.v3PrivateGetAccountinfo(parameters);
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "applicationId": "dsa",
        //             "account": "dsa",
        //             "alias": "haha",
        //             "accountMode": "MARGIN",
        //             "leverage": 1,
        //             "takerFeeRate": 1,
        //             "makerFeeRate": 1,
        //             "interestRate": 1,
        //             "futuresTakerFeeRate": 1,
        //             "futuresMakerFeeRate": 1,
        //             "otpauth": true,
        //             "marginRatio": 1,
        //             "openMarginRatio": 1,
        //             "initialMarginRatio": 1,
        //             "maintenanceMarginRatio": 1,
        //             "totalCollateral": 1,
        //             "freeCollateral": 1,
        //             "totalAccountValue": 1,
        //             "totalVaultValue": 1,
        //             "totalStakingValue": 1
        //         },
        //         "timestamp": 1673323685109
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object maker = this.safeString(data, "makerFeeRate");
        object taker = this.safeString(data, "takerFeeRate");
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(this.symbols)); postFixIncrement(ref i))
        {
            object symbol = getValue(this.symbols, i);
            ((Dictionary<string, object>)result)[(string)symbol] = new Dictionary<string, object>() {
                { "info", response },
                { "symbol", symbol },
                { "maker", this.parseNumber(Precise.stringDiv(maker, "10000")) },
                { "taker", this.parseNumber(Precise.stringDiv(taker, "10000")) },
                { "percentage", true },
                { "tierBased", true },
            };
        }
        return result;
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name woo#fetchCurrencies
        * @description fetches all available currencies on an exchange
        * @param {object} params extra parameters specific to the woo api endpoint
        * @returns {object} an associative dictionary of currencies
        */
        parameters ??= new Dictionary<string, object>();
        object result = new Dictionary<string, object>() {};
        object tokenResponse = await this.v1PublicGetToken(parameters);
        //
        // {
        //     rows: [
        //         {
        //             token: "ETH_USDT",
        //             fullname: "Tether",
        //             decimals: 6,
        //             balance_token: "USDT",
        //             created_time: "0",
        //             updated_time: "0"
        //         },
        //         {
        //             token: "BSC_USDT",
        //             fullname: "Tether",
        //             decimals: 18,
        //             balance_token: "USDT",
        //             created_time: "0",
        //             updated_time: "0"
        //         },
        //         {
        //             token: "ZEC",
        //             fullname: "ZCash",
        //             decimals: 8,
        //             balance_token: "ZEC",
        //             created_time: "0",
        //             updated_time: "0"
        //         },
        //         ...
        //     ],
        //     success: true
        // }
        //
        // only make one request for currrencies...
        // const tokenNetworkResponse = await this.v1PublicGetTokenNetwork (params);
        //
        // {
        //     rows: [
        //         {
        //             protocol: "ERC20",
        //             token: "USDT",
        //             name: "Ethereum",
        //             minimum_withdrawal: 30,
        //             withdrawal_fee: 25,
        //             allow_deposit: 1,
        //             allow_withdraw: 1
        //         },
        //         {
        //             protocol: "TRC20",
        //             token: "USDT",
        //             name: "Tron",
        //             minimum_withdrawal: 30,
        //             withdrawal_fee: 1,
        //             allow_deposit: 1,
        //             allow_withdraw: 1
        //         },
        //         ...
        //     ],
        //     success: true
        // }
        //
        object tokenRows = this.safeValue(tokenResponse, "rows", new List<object>() {});
        object networksByCurrencyId = this.groupBy(tokenRows, "balance_token");
        object currencyIds = new List<object>(((Dictionary<string,object>)networksByCurrencyId).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(currencyIds)); postFixIncrement(ref i))
        {
            object currencyId = getValue(currencyIds, i);
            object networks = getValue(networksByCurrencyId, currencyId);
            object code = this.safeCurrencyCode(currencyId);
            object name = null;
            object minPrecision = null;
            object resultingNetworks = new Dictionary<string, object>() {};
            for (object j = 0; isLessThan(j, getArrayLength(networks)); postFixIncrement(ref j))
            {
                object network = getValue(networks, j);
                name = this.safeString(network, "fullname");
                object networkId = this.safeString(network, "token");
                object splitted = ((string)networkId).Split((string)"_").ToList<object>();
                object unifiedNetwork = getValue(splitted, 0);
                object precision = this.parsePrecision(this.safeString(network, "decimals"));
                if (isTrue(!isEqual(precision, null)))
                {
                    minPrecision = ((bool) isTrue((isEqual(minPrecision, null)))) ? precision : Precise.stringMin(precision, minPrecision);
                }
                ((Dictionary<string, object>)resultingNetworks)[(string)unifiedNetwork] = new Dictionary<string, object>() {
                    { "id", networkId },
                    { "network", unifiedNetwork },
                    { "limits", new Dictionary<string, object>() {
                        { "withdraw", new Dictionary<string, object>() {
                            { "min", null },
                            { "max", null },
                        } },
                        { "deposit", new Dictionary<string, object>() {
                            { "min", null },
                            { "max", null },
                        } },
                    } },
                    { "active", null },
                    { "deposit", null },
                    { "withdraw", null },
                    { "fee", null },
                    { "precision", this.parseNumber(precision) },
                    { "info", network },
                };
            }
            ((Dictionary<string, object>)result)[(string)code] = new Dictionary<string, object>() {
                { "id", currencyId },
                { "name", name },
                { "code", code },
                { "precision", this.parseNumber(minPrecision) },
                { "active", null },
                { "fee", null },
                { "networks", resultingNetworks },
                { "deposit", null },
                { "withdraw", null },
                { "limits", new Dictionary<string, object>() {
                    { "deposit", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "info", networks },
            };
        }
        return result;
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#createOrder
        * @description create a trade order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float|undefined} price the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} params extra parameters specific to the woo api endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object reduceOnly = this.safeValue(parameters, "reduceOnly");
        object orderType = ((string)type).ToUpper();
        if (isTrue(!isEqual(reduceOnly, null)))
        {
            if (isTrue(!isEqual(orderType, "LIMIT")))
            {
                throw new InvalidOrder ((string)add(this.id, " createOrder() only support reduceOnly for limit orders")) ;
            }
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object orderSide = ((string)side).ToUpper();
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "order_type", orderType },
            { "side", orderSide },
        };
        object isMarket = isEqual(orderType, "MARKET");
        object timeInForce = this.safeStringLower(parameters, "timeInForce");
        object postOnly = this.isPostOnly(isMarket, null, parameters);
        if (isTrue(postOnly))
        {
            ((Dictionary<string, object>)request)["order_type"] = "POST_ONLY";
        } else if (isTrue(isEqual(timeInForce, "fok")))
        {
            ((Dictionary<string, object>)request)["order_type"] = "FOK";
        } else if (isTrue(isEqual(timeInForce, "ioc")))
        {
            ((Dictionary<string, object>)request)["order_type"] = "IOC";
        }
        if (isTrue(reduceOnly))
        {
            ((Dictionary<string, object>)request)["reduce_only"] = reduceOnly;
        }
        if (isTrue(!isEqual(price, null)))
        {
            ((Dictionary<string, object>)request)["order_price"] = this.priceToPrecision(symbol, price);
        }
        if (isTrue(isMarket))
        {
            // for market buy it requires the amount of quote currency to spend
            if (isTrue(isTrue(getValue(market, "spot")) && isTrue(isEqual(orderSide, "BUY"))))
            {
                object cost = this.safeNumber(parameters, "cost");
                if (isTrue(this.safeValue(this.options, "createMarketBuyOrderRequiresPrice", true)))
                {
                    if (isTrue(isEqual(cost, null)))
                    {
                        if (isTrue(isEqual(price, null)))
                        {
                            throw new InvalidOrder ((string)add(this.id, " createOrder() requires the price argument for market buy orders to calculate total order cost. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or alternatively, supply the total cost value in the \'order_amount\' in  exchange-specific parameters")) ;
                        } else
                        {
                            object amountString = this.numberToString(amount);
                            object priceString = this.numberToString(price);
                            object orderAmount = Precise.stringMul(amountString, priceString);
                            ((Dictionary<string, object>)request)["order_amount"] = this.costToPrecision(symbol, orderAmount);
                        }
                    } else
                    {
                        ((Dictionary<string, object>)request)["order_amount"] = this.costToPrecision(symbol, cost);
                    }
                } else
                {
                    ((Dictionary<string, object>)request)["order_amount"] = this.costToPrecision(symbol, amount);
                }
            } else
            {
                ((Dictionary<string, object>)request)["order_quantity"] = this.amountToPrecision(symbol, amount);
            }
        } else
        {
            ((Dictionary<string, object>)request)["order_quantity"] = this.amountToPrecision(symbol, amount);
        }
        object clientOrderId = this.safeString2(parameters, "clOrdID", "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((Dictionary<string, object>)request)["client_order_id"] = clientOrderId;
        }
        parameters = this.omit(parameters, new List<object>() {"clOrdID", "clientOrderId", "postOnly", "timeInForce"});
        object response = await this.v1PrivatePostOrder(this.extend(request, parameters));
        // {
        //     success: true,
        //     timestamp: '1641383206.489',
        //     order_id: '86980774',
        //     order_type: 'LIMIT',
        //     order_price: '1', // null for 'MARKET' order
        //     order_quantity: '12', // null for 'MARKET' order
        //     order_amount: null, // NOT-null for 'MARKET' order
        //     client_order_id: '0'
        // }
        return this.extend(this.parseOrder(response, market), new Dictionary<string, object>() {
            { "type", type },
        });
    }

    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#editOrder
        * @description edit a trade order
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float|undefined} price the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} params extra parameters specific to the woo api endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(price, null)))
        {
            ((Dictionary<string, object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        if (isTrue(!isEqual(amount, null)))
        {
            ((Dictionary<string, object>)request)["quantity"] = this.amountToPrecision(symbol, amount);
        }
        object clientOrderIdUnified = this.safeString2(parameters, "clOrdID", "clientOrderId");
        object clientOrderIdExchangeSpecific = this.safeString(parameters, "client_order_id", clientOrderIdUnified);
        object isByClientOrder = !isEqual(clientOrderIdExchangeSpecific, null);
        object method = null;
        if (isTrue(isByClientOrder))
        {
            method = "v3PrivatePutOrderClientClientOrderId";
            ((Dictionary<string, object>)request)["client_order_id"] = clientOrderIdExchangeSpecific;
            parameters = this.omit(parameters, new List<object>() {"clOrdID", "clientOrderId", "client_order_id"});
        } else
        {
            method = "v3PrivatePutOrderOid";
            ((Dictionary<string, object>)request)["oid"] = id;
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        //     {
        //         "code": 0,
        //         "data": {
        //             "status": "string",
        //             "success": true
        //         },
        //         "message": "string",
        //         "success": true,
        //         "timestamp": 0
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(data, market);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#cancelOrder
        * @description cancels an open order
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} params extra parameters specific to the woo api endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object clientOrderIdUnified = this.safeString2(parameters, "clOrdID", "clientOrderId");
        object clientOrderIdExchangeSpecific = this.safeString(parameters, "client_order_id", clientOrderIdUnified);
        object isByClientOrder = !isEqual(clientOrderIdExchangeSpecific, null);
        object method = null;
        if (isTrue(isByClientOrder))
        {
            method = "v1PrivateDeleteClientOrder";
            ((Dictionary<string, object>)request)["client_order_id"] = clientOrderIdExchangeSpecific;
            parameters = this.omit(parameters, new List<object>() {"clOrdID", "clientOrderId", "client_order_id"});
        } else
        {
            method = "v1PrivateDeleteOrder";
            ((Dictionary<string, object>)request)["order_id"] = id;
        }
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        // { success: true, status: 'CANCEL_SENT' }
        //
        object extendParams = new Dictionary<string, object>() {
            { "symbol", symbol },
        };
        if (isTrue(isByClientOrder))
        {
            ((Dictionary<string, object>)extendParams)["client_order_id"] = clientOrderIdExchangeSpecific;
        } else
        {
            ((Dictionary<string, object>)extendParams)["id"] = id;
        }
        return this.extend(this.parseOrder(response), extendParams);
    }

    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#cancelAllOrders
        * @description cancel all open orders in a market
        * @param {string|undefined} symbol unified market symbol
        * @param {object} params extra parameters specific to the woo api endpoint
        * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " canelOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.v1PrivateDeleteOrders(this.extend(request, parameters));
        //
        //     {
        //         "success":true,
        //         "status":"CANCEL_ALL_SENT"
        //     }
        //
        return response;
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#fetchOrder
        * @description fetches information on an order made by the user
        * @param {string|undefined} symbol unified symbol of the market the order was made in
        * @param {object} params extra parameters specific to the woo api endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = ((bool) isTrue((!isEqual(symbol, null)))) ? this.market(symbol) : null;
        object request = new Dictionary<string, object>() {};
        object clientOrderId = this.safeString2(parameters, "clOrdID", "clientOrderId");
        object chosenSpotMethod = null;
        if (isTrue(clientOrderId))
        {
            chosenSpotMethod = "v1PrivateGetClientOrderClientOrderId";
            ((Dictionary<string, object>)request)["client_order_id"] = clientOrderId;
        } else
        {
            chosenSpotMethod = "v1PrivateGetOrderOid";
            ((Dictionary<string, object>)request)["oid"] = id;
        }
        object response = await ((Task<object>)callDynamically(this, chosenSpotMethod, new object[] { this.extend(request, parameters) }));
        //
        // {
        //     success: true,
        //     symbol: 'SPOT_WOO_USDT',
        //     status: 'FILLED', // FILLED, NEW
        //     side: 'BUY',
        //     created_time: '1641480933.000',
        //     order_id: '87541111',
        //     order_tag: 'default',
        //     price: '1',
        //     type: 'LIMIT',
        //     quantity: '12',
        //     amount: null,
        //     visible: '12',
        //     executed: '12', // or any partial amount
        //     total_fee: '0.0024',
        //     fee_asset: 'WOO',
        //     client_order_id: null,
        //     average_executed_price: '1',
        //     Transactions: [
        //       {
        //         id: '99111647',
        //         symbol: 'SPOT_WOO_USDT',
        //         fee: '0.0024',
        //         side: 'BUY',
        //         executed_timestamp: '1641482113.084',
        //         order_id: '87541111',
        //         executed_price: '1',
        //         executed_quantity: '12',
        //         fee_asset: 'WOO',
        //         is_maker: '1'
        //       }
        //     ]
        // }
        //
        return this.parseOrder(response, market);
    }

    public async override Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#fetchOrders
        * @description fetches information on multiple orders made by the user
        * @param {string|undefined} symbol unified market symbol of the market orders were made in
        * @param {int|undefined} since the earliest time in ms to fetch orders for
        * @param {int|undefined} limit the maximum number of  orde structures to retrieve
        * @param {object} params extra parameters specific to the woo api endpoint
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["start_t"] = since;
        }
        object response = await this.v1PrivateGetOrders(this.extend(request, parameters));
        //
        //     {
        //         "success":true,
        //         "meta":{
        //             "total":1,
        //             "records_per_page":100,
        //             "current_page":1
        //         },
        //         "rows":[
        //             {
        //                 "symbol":"PERP_BTC_USDT",
        //                 "status":"FILLED",
        //                 "side":"SELL",
        //                 "created_time":"1611617776.000",
        //                 "updated_time":"1611617776.000",
        //                 "order_id":52121167,
        //                 "order_tag":"default",
        //                 "price":null,
        //                 "type":"MARKET",
        //                 "quantity":0.002,
        //                 "amount":null,
        //                 "visible":0,
        //                 "executed":0.002,
        //                 "total_fee":0.01732885,
        //                 "fee_asset":"USDT",
        //                 "client_order_id":null,
        //                 "average_executed_price":28881.41
        //             }
        //         ]
        //     }
        //
        object data = this.safeValue(response, "rows");
        return this.parseOrders(data, market, since, limit, parameters);
    }

    public virtual object parseTimeInForce(object timeInForce)
    {
        object timeInForces = new Dictionary<string, object>() {
            { "ioc", "IOC" },
            { "fok", "FOK" },
            { "post_only", "PO" },
        };
        return this.safeString(timeInForces, timeInForce, null);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // Possible input functions:
        // * createOrder
        // * cancelOrder
        // * fetchOrder
        // * fetchOrders
        // const isFromFetchOrder = ('order_tag' in order); TO_DO
        object timestamp = this.safeTimestamp2(order, "timestamp", "created_time");
        object orderId = this.safeString(order, "order_id");
        object clientOrderId = this.safeString(order, "client_order_id"); // Somehow, this always returns 0 for limit order
        object marketId = this.safeString(order, "symbol");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object price = this.safeString2(order, "order_price", "price");
        object amount = this.safeString2(order, "order_quantity", "quantity"); // This is base amount
        object cost = this.safeString2(order, "order_amount", "amount"); // This is quote amount
        object orderType = this.safeStringLower2(order, "order_type", "type");
        object status = this.safeValue(order, "status");
        object side = this.safeStringLower(order, "side");
        object filled = this.safeValue(order, "executed");
        object average = this.safeString(order, "average_executed_price");
        object remaining = Precise.stringSub(cost, filled);
        object fee = this.safeValue(order, "total_fee");
        object feeCurrency = this.safeString(order, "fee_asset");
        object transactions = this.safeValue(order, "Transactions");
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", orderId },
            { "clientOrderId", clientOrderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "status", this.parseOrderStatus(status) },
            { "symbol", symbol },
            { "type", orderType },
            { "timeInForce", this.parseTimeInForce(orderType) },
            { "postOnly", null },
            { "reduceOnly", this.safeValue(order, "reduce_only") },
            { "side", side },
            { "price", price },
            { "stopPrice", null },
            { "triggerPrice", null },
            { "average", average },
            { "amount", amount },
            { "filled", filled },
            { "remaining", remaining },
            { "cost", cost },
            { "trades", transactions },
            { "fee", new Dictionary<string, object>() {
                { "cost", fee },
                { "currency", feeCurrency },
            } },
            { "info", order },
        }, market);
    }

    public virtual object parseOrderStatus(object status)
    {
        if (isTrue(!isEqual(status, null)))
        {
            object statuses = new Dictionary<string, object>() {
                { "NEW", "open" },
                { "FILLED", "closed" },
                { "CANCEL_SENT", "canceled" },
                { "CANCEL_ALL_SENT", "canceled" },
                { "CANCELLED", "canceled" },
                { "PARTIAL_FILLED", "open" },
                { "REJECTED", "rejected" },
                { "INCOMPLETE", "open" },
                { "COMPLETED", "closed" },
            };
            return this.safeString(statuses, status, status);
        }
        return status;
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int|undefined} limit the maximum amount of order book entries to return
        * @param {object} params extra parameters specific to the woo api endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            limit = mathMin(limit, 1000);
            ((Dictionary<string, object>)request)["max_level"] = limit;
        }
        object response = await this.v1PublicGetOrderbookSymbol(this.extend(request, parameters));
        //
        // {
        //   success: true,
        //   timestamp: '1641562961192',
        //   asks: [
        //     { price: '0.921', quantity: '76.01' },
        //     { price: '0.933', quantity: '477.10' },
        //     ...
        //   ],
        //   bids: [
        //     { price: '0.940', quantity: '13502.47' },
        //     { price: '0.932', quantity: '43.91' },
        //     ...
        //   ]
        // }
        //
        object timestamp = this.safeInteger(response, "timestamp");
        return this.parseOrderBook(response, symbol, timestamp, "bids", "asks", "price", "quantity");
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#fetchOHLCV
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int|undefined} since timestamp in ms of the earliest candle to fetch
        * @param {int|undefined} limit the maximum amount of candles to fetch
        * @param {object} params extra parameters specific to the woo api endpoint
        * @returns {[[int]]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "type", this.safeString(this.timeframes, timeframe, timeframe) },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = mathMin(limit, 1000);
        }
        object response = await this.v1PublicGetKline(this.extend(request, parameters));
        // {
        //     success: true,
        //     rows: [
        //       {
        //         open: '0.94238',
        //         close: '0.94271',
        //         low: '0.94238',
        //         high: '0.94296',
        //         volume: '73.55',
        //         amount: '69.32040520',
        //         symbol: 'SPOT_WOO_USDT',
        //         type: '1m',
        //         start_timestamp: '1641584700000',
        //         end_timestamp: '1641584760000'
        //       },
        //       {
        //         open: '0.94186',
        //         close: '0.94186',
        //         low: '0.94186',
        //         high: '0.94186',
        //         volume: '64.00',
        //         amount: '60.27904000',
        //         symbol: 'SPOT_WOO_USDT',
        //         type: '1m',
        //         start_timestamp: '1641584640000',
        //         end_timestamp: '1641584700000'
        //       },
        //       ...
        //     ]
        // }
        object data = this.safeValue(response, "rows", new List<object>() {});
        return this.parseOHLCVs(data, market, timeframe, since, limit);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        // example response in fetchOHLCV
        return new List<object> {this.safeInteger(ohlcv, "start_timestamp"), this.safeNumber(ohlcv, "open"), this.safeNumber(ohlcv, "high"), this.safeNumber(ohlcv, "low"), this.safeNumber(ohlcv, "close"), this.safeNumber(ohlcv, "volume")};
    }

    public async override Task<object> fetchOrderTrades(object id, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#fetchOrderTrades
        * @description fetch all the trades made from a single order
        * @param {string} id order id
        * @param {string|undefined} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch trades for
        * @param {int|undefined} limit the maximum number of trades to retrieve
        * @param {object} params extra parameters specific to the woo api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {
            { "oid", id },
        };
        object response = await this.v1PrivateGetOrderOidTrades(this.extend(request, parameters));
        // {
        //     success: true,
        //     rows: [
        //       {
        //         id: '99111647',
        //         symbol: 'SPOT_WOO_USDT',
        //         fee: '0.0024',
        //         side: 'BUY',
        //         executed_timestamp: '1641482113.084',
        //         order_id: '87541111',
        //         order_tag: 'default',
        //         executed_price: '1',
        //         executed_quantity: '12',
        //         fee_asset: 'WOO',
        //         is_maker: '1'
        //       }
        //     ]
        // }
        object trades = this.safeValue(response, "rows", new List<object>() {});
        return this.parseTrades(trades, market, since, limit, parameters);
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#fetchMyTrades
        * @description fetch all trades made by the user
        * @param {string|undefined} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch trades for
        * @param {int|undefined} limit the maximum number of trades structures to retrieve
        * @param {object} params extra parameters specific to the woo api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["start_t"] = since;
        }
        object response = await this.v1PrivateGetClientTrades(this.extend(request, parameters));
        // {
        //     "success": true,
        //     "meta": {
        //         "records_per_page": 25,
        //         "current_page": 1
        //     },
        //     "rows": [
        //         {
        //             "id": 5,
        //             "symbol": "SPOT_BTC_USDT",
        //             "order_id": 211,
        //             "order_tag": "default",
        //             "executed_price": 10892.84,
        //             "executed_quantity": 0.002,
        //             "is_maker": 0,
        //             "side": "SELL",
        //             "fee": 0,
        //             "fee_asset": "USDT",
        //             "executed_timestamp": "1566264290.250"
        //         },
        //         ...
        //     ]
        // }
        object trades = this.safeValue(response, "rows", new List<object>() {});
        return this.parseTrades(trades, market, since, limit, parameters);
    }

    public async override Task<object> fetchAccounts(object parameters = null)
    {
        /**
        * @method
        * @name woo#fetchAccounts
        * @description fetch all the accounts associated with a profile
        * @param {object} params extra parameters specific to the woo api endpoint
        * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/#/?id=account-structure} indexed by the account type
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.v1PrivateGetSubAccountAssets(parameters);
        //
        //     {
        //         rows: [{
        //                 application_id: '13e4fc34-e2ff-4cb7-b1e4-4c22fee7d365',
        //                 account: 'Main',
        //                 usdt_balance: '4.0'
        //             },
        //             {
        //                 application_id: '432952aa-a401-4e26-aff6-972920aebba3',
        //                 account: 'subaccount',
        //                 usdt_balance: '1.0'
        //             }
        //         ],
        //         success: true
        //     }
        //
        object rows = this.safeValue(response, "rows", new List<object>() {});
        return this.parseAccounts(rows, parameters);
    }

    public override object parseAccount(object account)
    {
        //
        //     {
        //         application_id: '336952aa-a401-4e26-aff6-972920aebba3',
        //         account: 'subaccount',
        //         usdt_balance: '1.0',
        //     }
        //
        object accountId = this.safeString(account, "account");
        return new Dictionary<string, object>() {
            { "info", account },
            { "id", this.safeString(account, "application_id") },
            { "name", accountId },
            { "code", null },
            { "type", ((bool) isTrue(isEqual(accountId, "Main"))) ? "main" : "subaccount" },
        };
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name woo#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @see https://docs.woo.org/#get-current-holding-get-balance-new
        * @param {object} params extra parameters specific to the woo api endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/en/latest/manual.html?#balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.v3PrivateGetBalances(parameters);
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "holding": [
        //                 {
        //                     "token": "0_token",
        //                     "holding": 1,
        //                     "frozen": 0,
        //                     "staked": 0,
        //                     "unbonding": 0,
        //                     "vault": 0,
        //                     "interest": 0,
        //                     "pendingShortQty": 0,
        //                     "pendingLongQty": 0,
        //                     "availableBalance": 0,
        //                     "updatedTime": 312321.121
        //                 }
        //             ]
        //         },
        //         "timestamp": 1673323746259
        //     }
        //
        object data = this.safeValue(response, "data");
        return this.parseBalance(data);
    }

    public virtual object parseBalance(object response)
    {
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        object balances = this.safeValue(response, "holding", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
        {
            object balance = getValue(balances, i);
            object code = this.safeCurrencyCode(this.safeString(balance, "token"));
            object account = this.account();
            ((Dictionary<string, object>)account)["total"] = this.safeString(balance, "holding");
            ((Dictionary<string, object>)account)["free"] = this.safeString(balance, "availableBalance");
            ((Dictionary<string, object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name woo#fetchDepositAddress
        * @description fetch the deposit address for a currency associated with this account
        * @param {string} code unified currency code
        * @param {object} params extra parameters specific to the woo api endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        // this method is TODO because of networks unification
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object networkCodeDefault = this.defaultNetworkCodeForCurrency(code);
        object networkCode = this.safeString(parameters, "network", networkCodeDefault);
        parameters = this.omit(parameters, "network");
        object codeForExchange = add(add(networkCode, "_"), getValue(currency, "code"));
        object request = new Dictionary<string, object>() {
            { "token", codeForExchange },
        };
        object response = await this.v1PrivateGetAssetDeposit(this.extend(request, parameters));
        // {
        //     success: true,
        //     address: '3Jmtjx5544T4smrit9Eroe4PCrRkpDeKjP',
        //     extra: ''
        // }
        object tag = this.safeString(response, "extra");
        object address = this.safeString(response, "address");
        this.checkAddress(address);
        return new Dictionary<string, object>() {
            { "currency", code },
            { "address", address },
            { "tag", tag },
            { "network", networkCode },
            { "info", response },
        };
    }

    public async virtual Task<object> getAssetHistoryRows(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((Dictionary<string, object>)request)["balance_token"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["start_t"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["pageSize"] = limit;
        }
        object transactionType = this.safeString(parameters, "type");
        parameters = this.omit(parameters, "type");
        if (isTrue(!isEqual(transactionType, null)))
        {
            ((Dictionary<string, object>)request)["type"] = transactionType;
        }
        object response = await this.v1PrivateGetAssetHistory(this.extend(request, parameters));
        // {
        //     rows: [
        //       {
        //         id: '22010508193900165',
        //         token: 'TRON_USDT',
        //         extra: '',
        //         amount: '13.75848500',
        //         status: 'COMPLETED',
        //         account: null,
        //         description: null,
        //         user_id: '42222',
        //         application_id: '6ad2b303-f354-45c0-8105-9f5f19d0e335',
        //         external_id: '220105081900134',
        //         target_address: 'TXnyFSnAYad3YCaqtwMw9jvXKkeU39NLnK',
        //         source_address: 'TYDzsYUEpvnYmQk4zGP9sWWcTEd2MiAtW6',
        //         type: 'BALANCE',
        //         token_side: 'DEPOSIT',
        //         tx_id: '35b0004022f6b3ad07f39a0b7af199f6b258c2c3e2c7cdc93c67efa74fd625ee',
        //         fee_token: '',
        //         fee_amount: '0.00000000',
        //         created_time: '1641370779.442',
        //         updated_time: '1641370779.465',
        //         is_new_target_address: null,
        //         confirmed_number: '29',
        //         confirming_threshold: '27',
        //         audit_tag: '1',
        //         audit_result: '0',
        //         balance_token: null, // TODO -write to support, that this seems broken. here should be the token id
        //         network_name: null // TODO -write to support, that this seems broken. here should be the network id
        //       }
        //     ],
        //     meta: { total: '1', records_per_page: '25', current_page: '1' },
        //     success: true
        // }
        return new List<object>() {currency, this.safeValue(response, "rows", new Dictionary<string, object>() {})};
    }

    public async override Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#fetchLedger
        * @description fetch the history of changes, actions done by the user or operations that altered balance of the user
        * @param {string|undefined} code unified currency code, default is undefined
        * @param {int|undefined} since timestamp in ms of the earliest ledger entry, default is undefined
        * @param {int|undefined} limit max number of ledger entrys to return, default is undefined
        * @param {object} params extra parameters specific to the woo api endpoint
        * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger-structure}
        */
        parameters ??= new Dictionary<string, object>();
        var currencyrowsVariable = await this.getAssetHistoryRows(code, since, limit, parameters);
        var currency = ((List<object>) currencyrowsVariable)[0];
        var rows = ((List<object>) currencyrowsVariable)[1];
        return this.parseLedger(rows, currency, since, limit, parameters);
    }

    public override object parseLedgerEntry(object item, object currency = null)
    {
        object networkizedCode = this.safeString(item, "token");
        object currencyDefined = this.getCurrencyFromChaincode(networkizedCode, currency);
        object code = getValue(currencyDefined, "code");
        object amount = this.safeNumber(item, "amount");
        object side = this.safeString(item, "token_side");
        object direction = ((bool) isTrue((isEqual(side, "DEPOSIT")))) ? "in" : "out";
        object timestamp = this.safeTimestamp(item, "created_time");
        object fee = this.parseTokenAndFeeTemp(item, "fee_token", "fee_amount");
        return new Dictionary<string, object>() {
            { "id", this.safeString(item, "id") },
            { "currency", code },
            { "account", this.safeString(item, "account") },
            { "referenceAccount", null },
            { "referenceId", this.safeString(item, "tx_id") },
            { "status", this.parseTransactionStatus(this.safeString(item, "status")) },
            { "amount", amount },
            { "before", null },
            { "after", null },
            { "fee", fee },
            { "direction", direction },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "type", this.parseLedgerEntryType(this.safeString(item, "type")) },
            { "info", item },
        };
    }

    public virtual object parseLedgerEntryType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "BALANCE", "transaction" },
            { "COLLATERAL", "transfer" },
        };
        return this.safeString(types, type, type);
    }

    public virtual object getCurrencyFromChaincode(object networkizedCode, object currency)
    {
        if (isTrue(!isEqual(currency, null)))
        {
            return currency;
        } else
        {
            object parts = ((string)networkizedCode).Split((string)"_").ToList<object>();
            object partsLength = getArrayLength(parts);
            object firstPart = this.safeString(parts, 0);
            object currencyId = this.safeString(parts, 1, firstPart);
            if (isTrue(isGreaterThan(partsLength, 2)))
            {
                currencyId = add(currencyId, add("_", this.safeString(parts, 2)));
            }
            currency = this.safeCurrency(currencyId);
        }
        return currency;
    }

    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#fetchDeposits
        * @description fetch all deposits made to an account
        * @param {string|undefined} code unified currency code
        * @param {int|undefined} since the earliest time in ms to fetch deposits for
        * @param {int|undefined} limit the maximum number of deposits structures to retrieve
        * @param {object} params extra parameters specific to the woo api endpoint
        * @returns {[object]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "token_side", "DEPOSIT" },
        };
        return await this.fetchTransactions(code, since, limit, this.extend(request, parameters));
    }

    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#fetchWithdrawals
        * @description fetch all withdrawals made from an account
        * @param {string|undefined} code unified currency code
        * @param {int|undefined} since the earliest time in ms to fetch withdrawals for
        * @param {int|undefined} limit the maximum number of withdrawals structures to retrieve
        * @param {object} params extra parameters specific to the woo api endpoint
        * @returns {[object]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "token_side", "WITHDRAW" },
        };
        return await this.fetchTransactions(code, since, limit, this.extend(request, parameters));
    }

    public async override Task<object> fetchTransactions(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#fetchTransactions
        * @description fetch history of deposits and withdrawals
        * @param {string|undefined} code unified currency code for the currency of the transactions, default is undefined
        * @param {int|undefined} since timestamp in ms of the earliest transaction, default is undefined
        * @param {int|undefined} limit max number of transactions to return, default is undefined
        * @param {object} params extra parameters specific to the woo api endpoint
        * @returns {object} a list of [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "type", "BALANCE" },
        };
        var currencyrowsVariable = await this.getAssetHistoryRows(code, since, limit, this.extend(request, parameters));
        var currency = ((List<object>) currencyrowsVariable)[0];
        var rows = ((List<object>) currencyrowsVariable)[1];
        //
        //     {
        //         "rows":[],
        //         "meta":{
        //             "total":0,
        //             "records_per_page":25,
        //             "current_page":1
        //         },
        //         "success":true
        //     }
        //
        return this.parseTransactions(rows, currency, since, limit, parameters);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        // example in fetchLedger
        object networkizedCode = this.safeString(transaction, "token");
        object currencyDefined = this.getCurrencyFromChaincode(networkizedCode, currency);
        object code = getValue(currencyDefined, "code");
        object movementDirection = this.safeStringLower(transaction, "token_side");
        if (isTrue(isEqual(movementDirection, "withdraw")))
        {
            movementDirection = "withdrawal";
        }
        object fee = this.parseTokenAndFeeTemp(transaction, "fee_token", "fee_amount");
        object addressTo = this.safeString(transaction, "target_address");
        object addressFrom = this.safeString(transaction, "source_address");
        object timestamp = this.safeTimestamp(transaction, "created_time");
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", this.safeString2(transaction, "id", "withdraw_id") },
            { "txid", this.safeString(transaction, "tx_id") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "address", null },
            { "addressFrom", addressFrom },
            { "addressTo", addressTo },
            { "tag", this.safeString(transaction, "extra") },
            { "tagFrom", null },
            { "tagTo", null },
            { "type", movementDirection },
            { "amount", this.safeNumber(transaction, "amount") },
            { "currency", code },
            { "status", this.parseTransactionStatus(this.safeString(transaction, "status")) },
            { "updated", this.safeTimestamp(transaction, "updated_time") },
            { "comment", null },
            { "fee", fee },
        };
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "NEW", "pending" },
            { "CONFIRMING", "pending" },
            { "PROCESSING", "pending" },
            { "COMPLETED", "ok" },
            { "CANCELED", "canceled" },
        };
        return this.safeString(statuses, status, status);
    }

    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        /**
        * @method
        * @name woo#transfer
        * @description transfer currency internally between wallets on the same account
        * @param {string} code unified currency code
        * @param {float} amount amount to transfer
        * @param {string} fromAccount account to transfer from
        * @param {string} toAccount account to transfer to
        * @param {object} params extra parameters specific to the woo api endpoint
        * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "token", getValue(currency, "id") },
            { "amount", this.parseNumber(amount) },
            { "from_application_id", fromAccount },
            { "to_application_id", toAccount },
        };
        object response = await this.v1PrivatePostAssetMainSubTransfer(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "id": 200
        //     }
        //
        object transfer = this.parseTransfer(response, currency);
        object transferOptions = this.safeValue(this.options, "transfer", new Dictionary<string, object>() {});
        object fillResponseFromRequest = this.safeValue(transferOptions, "fillResponseFromRequest", true);
        if (isTrue(fillResponseFromRequest))
        {
            ((Dictionary<string, object>)transfer)["amount"] = amount;
            ((Dictionary<string, object>)transfer)["fromAccount"] = fromAccount;
            ((Dictionary<string, object>)transfer)["toAccount"] = toAccount;
        }
        return transfer;
    }

    public async virtual Task<object> fetchTransfers(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#fetchTransfers
        * @description fetch a history of internal transfers made on an account
        * @param {string|undefined} code unified currency code of the currency transferred
        * @param {int|undefined} since the earliest time in ms to fetch transfers for
        * @param {int|undefined} limit the maximum number of  transfers structures to retrieve
        * @param {object} params extra parameters specific to the woo api endpoint
        * @returns {[object]} a list of [transfer structures]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "type", "COLLATERAL" },
        };
        var currencyrowsVariable = await this.getAssetHistoryRows(code, since, limit, this.extend(request, parameters));
        var currency = ((List<object>) currencyrowsVariable)[0];
        var rows = ((List<object>) currencyrowsVariable)[1];
        return this.parseTransfers(rows, currency, since, limit, parameters);
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        //
        //    getAssetHistoryRows
        //        {
        //            "created_time": "1579399877.041",  // Unix epoch time in seconds
        //            "updated_time": "1579399877.041",  // Unix epoch time in seconds
        //            "id": "202029292829292",
        //            "external_id": "202029292829292",
        //            "application_id": null,
        //            "token": "ETH",
        //            "target_address": "0x31d64B3230f8baDD91dE1710A65DF536aF8f7cDa",
        //            "source_address": "0x70fd25717f769c7f9a46b319f0f9103c0d887af0",
        //            "extra": "",
        //            "type": "BALANCE",
        //            "token_side": "DEPOSIT",
        //            "amount": 1000,
        //            "tx_id": "0x8a74c517bc104c8ebad0c3c3f64b1f302ed5f8bca598ae4459c63419038106b6",
        //            "fee_token": null,
        //            "fee_amount": null,
        //            "status": "CONFIRMING"
        //        }
        //
        //    v1PrivatePostAssetMainSubTransfer
        //        {
        //            "success": true,
        //            "id": 200
        //        }
        //
        object networkizedCode = this.safeString(transfer, "token");
        object currencyDefined = this.getCurrencyFromChaincode(networkizedCode, currency);
        object code = getValue(currencyDefined, "code");
        object movementDirection = this.safeStringLower(transfer, "token_side");
        if (isTrue(isEqual(movementDirection, "withdraw")))
        {
            movementDirection = "withdrawal";
        }
        object fromAccount = null;
        object toAccount = null;
        if (isTrue(isEqual(movementDirection, "withdraw")))
        {
            fromAccount = null;
            toAccount = "spot";
        } else if (isTrue(isEqual(movementDirection, "deposit")))
        {
            fromAccount = "spot";
            toAccount = null;
        }
        object timestamp = this.safeTimestamp(transfer, "created_time");
        object success = this.safeValue(transfer, "success");
        object status = null;
        if (isTrue(!isEqual(success, null)))
        {
            status = ((bool) isTrue(success)) ? "ok" : "failed";
        }
        return new Dictionary<string, object>() {
            { "id", this.safeString(transfer, "id") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "currency", code },
            { "amount", this.safeNumber(transfer, "amount") },
            { "fromAccount", fromAccount },
            { "toAccount", toAccount },
            { "status", this.parseTransferStatus(this.safeString(transfer, "status", status)) },
            { "info", transfer },
        };
    }

    public virtual object parseTransferStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "NEW", "pending" },
            { "CONFIRMING", "pending" },
            { "PROCESSING", "pending" },
            { "COMPLETED", "ok" },
            { "CANCELED", "canceled" },
        };
        return this.safeString(statuses, status, status);
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#withdraw
        * @description make a withdrawal
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string|undefined} tag
        * @param {object} params extra parameters specific to the woo api endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((List<object>)tagparametersVariable)[0];
        parameters = ((List<object>)tagparametersVariable)[1];
        await this.loadMarkets();
        this.checkAddress(address);
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "amount", amount },
            { "address", address },
        };
        if (isTrue(!isEqual(tag, null)))
        {
            ((Dictionary<string, object>)request)["extra"] = tag;
        }
        object networks = this.safeValue(this.options, "networks", new Dictionary<string, object>() {});
        object currencyNetworks = this.safeValue(currency, "networks", new Dictionary<string, object>() {});
        object network = this.safeStringUpper(parameters, "network");
        object networkId = this.safeString(networks, network, network);
        object coinNetwork = this.safeValue(currencyNetworks, networkId, new Dictionary<string, object>() {});
        object coinNetworkId = this.safeString(coinNetwork, "id");
        if (isTrue(isEqual(coinNetworkId, null)))
        {
            throw new BadRequest ((string)add(this.id, " withdraw() require network parameter")) ;
        }
        ((Dictionary<string, object>)request)["token"] = coinNetworkId;
        object response = await this.v1PrivatePostAssetWithdraw(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "withdraw_id": "20200119145703654"
        //     }
        //
        return this.parseTransaction(response, currency);
    }

    public async virtual Task<object> repayMargin(object code, object amount, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name woo#repayMargin
        * @description repay borrowed margin and interest
        * @see https://docs.woo.org/#repay-interest
        * @param {string} code unified currency code of the currency to repay
        * @param {float} amount the amount to repay
        * @param {string|undefined} symbol not used by woo.repayMargin ()
        * @param {object} params extra parameters specific to the woo api endpoint
        * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            symbol = getValue(market, "symbol");
        }
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "token", getValue(currency, "id") },
            { "amount", this.currencyToPrecision(code, amount) },
        };
        object response = await this.v1PrivatePostInterestRepay(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //     }
        //
        object transaction = this.parseMarginLoan(response, currency);
        return this.extend(transaction, new Dictionary<string, object>() {
            { "amount", amount },
            { "symbol", symbol },
        });
    }

    public virtual object parseMarginLoan(object info, object currency = null)
    {
        //
        //     {
        //         "success": true,
        //     }
        //
        return new Dictionary<string, object>() {
            { "id", null },
            { "currency", this.safeCurrencyCode(null, currency) },
            { "amount", null },
            { "symbol", null },
            { "timestamp", null },
            { "datetime", null },
            { "info", info },
        };
    }

    public override object nonce()
    {
        return this.milliseconds();
    }

    public override object sign(object path, object section = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        section ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object version = getValue(section, 0);
        object access = getValue(section, 1);
        object pathWithParams = this.implodeParams(path, parameters);
        object url = this.implodeHostname(getValue(getValue(this.urls, "api"), access));
        url = add(url, add(add("/", version), "/"));
        parameters = this.omit(parameters, this.extractParams(path));
        parameters = this.keysort(parameters);
        if (isTrue(isEqual(access, "public")))
        {
            url = add(url, add(add(access, "/"), pathWithParams));
            if (isTrue(getArrayLength(new List<object>(((Dictionary<string,object>)parameters).Keys))))
            {
                url = add(url, add("?", this.urlencode(parameters)));
            }
        } else
        {
            this.checkRequiredCredentials();
            object auth = "";
            object ts = ((object)this.nonce()).ToString();
            url = add(url, pathWithParams);
            headers = new Dictionary<string, object>() {
                { "x-api-key", this.apiKey },
                { "x-api-timestamp", ts },
            };
            if (isTrue(isEqual(version, "v3")))
            {
                auth = add(add(add(add(add(ts, method), "/"), version), "/"), pathWithParams);
                if (isTrue(isTrue(isTrue(isEqual(method, "POST")) || isTrue(isEqual(method, "PUT"))) || isTrue(isEqual(method, "DELETE"))))
                {
                    body = this.json(parameters);
                    auth = add(auth, body);
                } else
                {
                    if (isTrue(getArrayLength(new List<object>(((Dictionary<string,object>)parameters).Keys))))
                    {
                        object query = this.urlencode(parameters);
                        url = add(url, add("?", query));
                        auth = add(auth, add("?", query));
                    }
                }
                ((Dictionary<string, object>)headers)["content-type"] = "application/json";
            } else
            {
                auth = this.urlencode(parameters);
                if (isTrue(isTrue(isTrue(isEqual(method, "POST")) || isTrue(isEqual(method, "PUT"))) || isTrue(isEqual(method, "DELETE"))))
                {
                    body = auth;
                } else
                {
                    url = add(url, add("?", auth));
                }
                auth = add(auth, add("|", ts));
                ((Dictionary<string, object>)headers)["content-type"] = "application/x-www-form-urlencoded";
            }
            ((Dictionary<string, object>)headers)["x-api-signature"] = this.hmac(this.encode(auth), this.encode(this.secret), sha256);
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object httpCode, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (!isTrue(response))
        {
            return null;  // fallback to default error handler
        }
        //
        //     400 Bad Request {"success":false,"code":-1012,"message":"Amount is required for buy market orders when margin disabled."}
        //
        object success = this.safeValue(response, "success");
        object errorCode = this.safeString(response, "code");
        if (!isTrue(success))
        {
            object feedback = add(add(this.id, " "), this.json(response));
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), body, feedback);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorCode, feedback);
        }
        return null;
    }

    public override object parseIncome(object income, object market = null)
    {
        //
        //     {
        //         "id":666666,
        //         "symbol":"PERP_BTC_USDT",
        //         "funding_rate":0.00001198,
        //         "mark_price":28941.04000000,
        //         "funding_fee":0.00069343,
        //         "payment_type":"Pay",
        //         "status":"COMPLETED",
        //         "created_time":"1653616000.666",
        //         "updated_time":"1653616000.605"
        //     }
        //
        object marketId = this.safeString(income, "symbol");
        object symbol = this.safeSymbol(marketId, market);
        object amount = this.safeNumber(income, "funding_fee");
        object code = this.safeCurrencyCode("USD");
        object id = this.safeString(income, "id");
        object timestamp = this.safeTimestamp(income, "updated_time");
        object rate = this.safeNumber(income, "funding_rate");
        return new Dictionary<string, object>() {
            { "info", income },
            { "symbol", symbol },
            { "code", code },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "id", id },
            { "amount", amount },
            { "rate", rate },
        };
    }

    public async virtual Task<object> fetchFundingHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["start_t"] = since;
        }
        object response = await this.v1PrivateGetFundingFeeHistory(this.extend(request, parameters));
        //
        //     {
        //         "rows":[
        //             {
        //                 "id":666666,
        //                 "symbol":"PERP_BTC_USDT",
        //                 "funding_rate":0.00001198,
        //                 "mark_price":28941.04000000,
        //                 "funding_fee":0.00069343,
        //                 "payment_type":"Pay",
        //                 "status":"COMPLETED",
        //                 "created_time":"1653616000.666",
        //                 "updated_time":"1653616000.605"
        //             }
        //         ],
        //         "meta":{
        //             "total":235,
        //             "records_per_page":25,
        //             "current_page":1
        //         },
        //         "success":true
        //     }
        //
        object result = this.safeValue(response, "rows", new List<object>() {});
        return this.parseIncomes(result, market, since, limit);
    }

    public override object parseFundingRate(object fundingRate, object market = null)
    {
        //
        //         {
        //             "symbol":"PERP_AAVE_USDT",
        //             "est_funding_rate":-0.00003447,
        //             "est_funding_rate_timestamp":1653633959001,
        //             "last_funding_rate":-0.00002094,
        //             "last_funding_rate_timestamp":1653631200000,
        //             "next_funding_time":1653634800000
        //         }
        //
        //
        object symbol = this.safeString(fundingRate, "symbol");
        market = this.market(symbol);
        object nextFundingTimestamp = this.safeInteger(fundingRate, "next_funding_time");
        object estFundingRateTimestamp = this.safeInteger(fundingRate, "est_funding_rate_timestamp");
        object lastFundingRateTimestamp = this.safeInteger(fundingRate, "last_funding_rate_timestamp");
        return new Dictionary<string, object>() {
            { "info", fundingRate },
            { "symbol", getValue(market, "symbol") },
            { "markPrice", null },
            { "indexPrice", null },
            { "interestRate", this.parseNumber("0") },
            { "estimatedSettlePrice", null },
            { "timestamp", estFundingRateTimestamp },
            { "datetime", this.iso8601(estFundingRateTimestamp) },
            { "fundingRate", this.safeNumber(fundingRate, "est_funding_rate") },
            { "fundingTimestamp", nextFundingTimestamp },
            { "fundingDatetime", this.iso8601(nextFundingTimestamp) },
            { "nextFundingRate", null },
            { "nextFundingTimestamp", null },
            { "nextFundingDatetime", null },
            { "previousFundingRate", this.safeNumber(fundingRate, "last_funding_rate") },
            { "previousFundingTimestamp", lastFundingRateTimestamp },
            { "previousFundingDatetime", this.iso8601(lastFundingRateTimestamp) },
        };
    }

    public async override Task<object> fetchFundingRate(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.v1PublicGetFundingRateSymbol(this.extend(request, parameters));
        //
        //     {
        //         "success":true,
        //         "timestamp":1653640572711,
        //         "symbol":"PERP_BTC_USDT",
        //         "est_funding_rate":0.00000738,
        //         "est_funding_rate_timestamp":1653640559003,
        //         "last_funding_rate":0.00000629,
        //         "last_funding_rate_timestamp":1653638400000,
        //         "next_funding_time":1653642000000
        //     }
        //
        return this.parseFundingRate(response, market);
    }

    public async override Task<object> fetchFundingRates(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object response = await this.v1PublicGetFundingRates(parameters);
        //
        //     {
        //         "success":true,
        //         "rows":[
        //             {
        //                 "symbol":"PERP_AAVE_USDT",
        //                 "est_funding_rate":-0.00003447,
        //                 "est_funding_rate_timestamp":1653633959001,
        //                 "last_funding_rate":-0.00002094,
        //                 "last_funding_rate_timestamp":1653631200000,
        //                 "next_funding_time":1653634800000
        //             }
        //         ],
        //         "timestamp":1653633985646
        //     }
        //
        object rows = this.safeValue(response, "rows", new Dictionary<string, object>() {});
        object result = this.parseFundingRates(rows);
        return this.filterByArray(result, "symbol", symbols);
    }

    public async override Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            object market = this.market(symbol);
            symbol = getValue(market, "symbol");
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["start_t"] = this.parseToInt(divide(since, 1000));
        }
        object response = await this.v1PublicGetFundingRateHistory(this.extend(request, parameters));
        //
        //     {
        //         "success":true,
        //         "meta":{
        //             "total":2464,
        //             "records_per_page":25,
        //             "current_page":1
        //         },
        //         "rows":[
        //             {
        //                 "symbol":"PERP_BTC_USDT",
        //                 "funding_rate":0.00000629,
        //                 "funding_rate_timestamp":1653638400000,
        //                 "next_funding_time":1653642000000
        //             }
        //         ],
        //         "timestamp":1653640814885
        //     }
        //
        object result = this.safeValue(response, "rows");
        object rates = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(result)); postFixIncrement(ref i))
        {
            object entry = getValue(result, i);
            object marketId = this.safeString(entry, "symbol");
            object timestamp = this.safeInteger(entry, "funding_rate_timestamp");
            ((List<object>)rates).Add(new Dictionary<string, object>() {
                { "info", entry },
                { "symbol", this.safeSymbol(marketId) },
                { "fundingRate", this.safeNumber(entry, "funding_rate") },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
            });
        }
        object sorted = this.sortBy(rates, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, symbol, since, limit);
    }

    public async virtual Task<object> fetchLeverage(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.v3PrivateGetAccountinfo(parameters);
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "applicationId": "dsa",
        //             "account": "dsa",
        //             "alias": "haha",
        //             "accountMode": "MARGIN",
        //             "leverage": 1,
        //             "takerFeeRate": 1,
        //             "makerFeeRate": 1,
        //             "interestRate": 1,
        //             "futuresTakerFeeRate": 1,
        //             "futuresMakerFeeRate": 1,
        //             "otpauth": true,
        //             "marginRatio": 1,
        //             "openMarginRatio": 1,
        //             "initialMarginRatio": 1,
        //             "maintenanceMarginRatio": 1,
        //             "totalCollateral": 1,
        //             "freeCollateral": 1,
        //             "totalAccountValue": 1,
        //             "totalVaultValue": 1,
        //             "totalStakingValue": 1
        //         },
        //         "timestamp": 1673323685109
        //     }
        //
        object result = this.safeValue(response, "data");
        object leverage = this.safeNumber(result, "leverage");
        return new Dictionary<string, object>() {
            { "info", response },
            { "leverage", leverage },
        };
    }

    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isTrue((isLessThan(leverage, 1))) || isTrue((isGreaterThan(leverage, 20)))))
        {
            throw new BadRequest ((string)add(this.id, " leverage should be between 1 and 20")) ;
        }
        object request = new Dictionary<string, object>() {
            { "leverage", leverage },
        };
        return await this.v1PrivatePostClientLeverage(this.extend(request, parameters));
    }

    public async override Task<object> fetchPosition(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.v1PrivateGetPositionSymbol(this.extend(request, parameters));
        //
        //     {
        //         "symbol":"PERP_ETC_USDT",
        //         "holding":0.0,
        //         "pnl_24_h":0,
        //         "settle_price":0.0,
        //         "average_open_price":0,
        //         "success":true,
        //         "mark_price":22.6955,
        //         "pending_short_qty":0.0,
        //         "pending_long_qty":0.0,
        //         "fee_24_h":0,
        //         "timestamp":"1652231044.920"
        //     }
        //
        return this.parsePosition(response, market);
    }

    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.v3PrivateGetPositions(parameters);
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "positions": [
        //                 {
        //                     "symbol": "0_symbol",
        //                     "holding": 1,
        //                     "pendingLongQty": 0,
        //                     "pendingShortQty": 1,
        //                     "settlePrice": 1,
        //                     "averageOpenPrice": 1,
        //                     "pnl24H": 1,
        //                     "fee24H": 1,
        //                     "markPrice": 1,
        //                     "estLiqPrice": 1,
        //                     "timestamp": 12321321
        //                 }
        //             ]
        //         },
        //         "timestamp": 1673323880342
        //     }
        //
        object result = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object positions = this.safeValue(result, "positions", new List<object>() {});
        return this.parsePositions(positions, symbols);
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        //     {
        //         "symbol": "0_symbol",
        //         "holding": 1,
        //         "pendingLongQty": 0,
        //         "pendingShortQty": 1,
        //         "settlePrice": 1,
        //         "averageOpenPrice": 1,
        //         "pnl24H": 1,
        //         "fee24H": 1,
        //         "markPrice": 1,
        //         "estLiqPrice": 1,
        //         "timestamp": 12321321
        //     }
        //
        object contract = this.safeString(position, "symbol");
        market = this.safeMarket(contract, market);
        object size = this.safeString(position, "holding");
        object side = null;
        if (isTrue(Precise.stringGt(size, "0")))
        {
            side = "long";
        } else
        {
            side = "short";
        }
        object contractSize = this.safeString(market, "contractSize");
        object markPrice = this.safeString(position, "markPrice");
        object timestamp = this.safeTimestamp(position, "timestamp");
        object entryPrice = this.safeString(position, "averageOpenPrice");
        object priceDifference = Precise.stringSub(markPrice, entryPrice);
        object unrealisedPnl = Precise.stringMul(priceDifference, size);
        size = Precise.stringAbs(size);
        object notional = Precise.stringMul(size, markPrice);
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", null },
            { "symbol", this.safeString(market, "symbol") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastUpdateTimestamp", null },
            { "initialMargin", null },
            { "initialMarginPercentage", null },
            { "maintenanceMargin", null },
            { "maintenanceMarginPercentage", null },
            { "entryPrice", this.parseNumber(entryPrice) },
            { "notional", this.parseNumber(notional) },
            { "leverage", null },
            { "unrealizedPnl", this.parseNumber(unrealisedPnl) },
            { "contracts", this.parseNumber(size) },
            { "contractSize", this.parseNumber(contractSize) },
            { "marginRatio", null },
            { "liquidationPrice", this.safeNumber(position, "estLiqPrice") },
            { "markPrice", this.parseNumber(markPrice) },
            { "lastPrice", null },
            { "collateral", null },
            { "marginMode", "cross" },
            { "marginType", null },
            { "side", side },
            { "percentage", null },
        });
    }

    public virtual object defaultNetworkCodeForCurrency(object code)
    {
        object currencyItem = this.currency(code);
        object networks = getValue(currencyItem, "networks");
        object networkKeys = new List<object>(((Dictionary<string,object>)networks).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(networkKeys)); postFixIncrement(ref i))
        {
            object network = getValue(networkKeys, i);
            if (isTrue(isEqual(network, "ETH")))
            {
                return network;
            }
        }
        // if it was not returned according to above options, then return the first network of currency
        return this.safeValue(networkKeys, 0);
    }
}
