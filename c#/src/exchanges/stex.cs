using ccxt;
namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

partial class stex : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "stex" },
            { "name", "STEX" },
            { "countries", new List<object>() {"EE"} },
            { "rateLimit", divide(1000, 3) },
            { "certified", false },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", false },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "addMargin", false },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "createDepositAddress", true },
                { "createMarketOrder", false },
                { "createOrder", true },
                { "createReduceOnlyOrder", false },
                { "fetchBalance", true },
                { "fetchBorrowRate", false },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchBorrowRates", false },
                { "fetchBorrowRatesPerSymbol", false },
                { "fetchClosedOrder", true },
                { "fetchCurrencies", true },
                { "fetchDeposit", true },
                { "fetchDepositAddress", true },
                { "fetchDeposits", true },
                { "fetchDepositWithdrawFee", "emulated" },
                { "fetchDepositWithdrawFees", true },
                { "fetchFundingHistory", false },
                { "fetchFundingRate", false },
                { "fetchFundingRateHistory", false },
                { "fetchFundingRates", false },
                { "fetchIndexOHLCV", false },
                { "fetchLeverage", false },
                { "fetchLeverageTiers", false },
                { "fetchMarginMode", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrderTrades", true },
                { "fetchPosition", false },
                { "fetchPositionMode", false },
                { "fetchPositions", false },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", true },
                { "fetchTradingFees", false },
                { "fetchTransactionFees", true },
                { "fetchWithdrawal", true },
                { "fetchWithdrawals", true },
                { "reduceMargin", false },
                { "setLeverage", false },
                { "setMarginMode", false },
                { "setPositionMode", false },
                { "transfer", true },
                { "withdraw", true },
            } },
            { "version", "v3" },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/1294454/69680782-03fd0b80-10bd-11ea-909e-7f603500e9cc.jpg" },
                { "api", new Dictionary<string, object>() {
                    { "rest", "https://api3.stex.com" },
                } },
                { "www", "https://www.stex.com" },
                { "doc", new List<object>() {"https://apidocs.stex.com/", "https://help.stex.com/en/collections/1593608-api-v3-documentation"} },
                { "fees", "https://app.stex.com/en/pairs-specification" },
                { "referral", "https://app.stex.com?ref=36416021" },
            } },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", false },
                { "secret", false },
                { "token", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1" },
                { "5m", "5" },
                { "30m", "30" },
                { "1h", "60" },
                { "4h", "240" },
                { "12h", "720" },
                { "1d", "1D" },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "currencies", 1 },
                        { "currencies/{currencyId}", 1 },
                        { "markets", 1 },
                        { "pairs-groups", 1 },
                        { "currency_pairs/list/{code}", 1 },
                        { "currency_pairs/group/{currencyPairGroupId}", 1 },
                        { "currency_pairs/{currencyPairId}", 1 },
                        { "ticker", 1 },
                        { "ticker/{currencyPairId}", 1 },
                        { "trades/{currencyPairId}", 1 },
                        { "orderbook/{currencyPairId}", 1 },
                        { "chart/{currencyPairId}/{candlesType}", 1 },
                        { "deposit-statuses", 1 },
                        { "deposit-statuses/{statusId}", 1 },
                        { "withdrawal-statuses", 1 },
                        { "withdrawal-statuses/{statusId}", 1 },
                        { "ping", 1 },
                        { "mobile-versions", 1 },
                        { "twitter", 1 },
                    } },
                } },
                { "trading", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "fees/{currencyPairId}", 1 },
                        { "orders", 12 },
                        { "orders/{currencyPairId}", 6 },
                        { "order/{orderId}", 12 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "orders/{currencyPairId}", 1.5 },
                        { "orders/bulk/{currencyPairId}", 12 },
                    } },
                    { "delete", new Dictionary<string, object>() {
                        { "orders", 30 },
                        { "orders/{currencyPairId}", 12 },
                        { "order/{orderId}", 1.5 },
                    } },
                } },
                { "reports", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "currencies", 12 },
                        { "currency_pairs", 12 },
                        { "orders", 12 },
                        { "orders/{orderId}", 12 },
                        { "trades/{currencyPairId}", 12 },
                        { "background/{listMode}", 12 },
                        { "background/{id}", 12 },
                        { "background/download/{id}", 12 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "background/create", 12 },
                    } },
                    { "delete", new Dictionary<string, object>() {
                        { "background/{id}", 12 },
                    } },
                } },
                { "profile", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "info", 3 },
                        { "wallets", 3 },
                        { "wallets/{walletId}", 3 },
                        { "wallets/address/{walletId}", 3 },
                        { "deposits", 3 },
                        { "deposits/{id}", 3 },
                        { "rewards", 3 },
                        { "rewards/{id}", 3 },
                        { "addressbook", 3 },
                        { "addressbook/{itemId}", 3 },
                        { "withdrawals", 3 },
                        { "withdrawals/{id}", 3 },
                        { "notifications", 3 },
                        { "notifications/price", 3 },
                        { "favorite/currency_pairs", 3 },
                        { "token-scopes", 3 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "wallets/burn/{walletId}", 3 },
                        { "wallets/{walletId}/hold_amount", 3 },
                        { "wallets/{currencyId}", 3 },
                        { "wallets/address/{walletId}", 3 },
                        { "addressbook/disable_item/{itemId}", 3 },
                        { "addressbook/enable_item/{itemId}", 3 },
                        { "addressbook/enable_strict_wd", 3 },
                        { "addressbook/disable_strict_wd", 3 },
                        { "withdraw", 30 },
                        { "notifications/price", 3 },
                        { "referral/program", 3 },
                        { "referral/insert/{code}", 3 },
                        { "referral/bonus_transfer/{currencyId}", 3 },
                    } },
                    { "put", new Dictionary<string, object>() {
                        { "favorite/currency_pairs/set", 3 },
                    } },
                    { "delete", new Dictionary<string, object>() {
                        { "addressbook/{itemId}", 3 },
                        { "withdraw/{withdrawalId}", 30 },
                        { "notifications/price/{priceAlertId}", 3 },
                    } },
                } },
                { "verification", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "countries", 1 },
                        { "status", 1 },
                        { "fractal/url", 1 },
                        { "smart-id", 1 },
                        { "stex", 1 },
                        { "cryptonomica/code", 1 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "smart-id", 1 },
                        { "stex", 1 },
                        { "cryptonomica", 1 },
                    } },
                } },
                { "settings", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "notifications/{event}", 1 },
                        { "notifications", 1 },
                    } },
                    { "put", new Dictionary<string, object>() {
                        { "notifications", 1 },
                        { "notifications/set", 1 },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "tierBased", false },
                    { "percentage", true },
                    { "taker", this.parseNumber("0.002") },
                    { "maker", this.parseNumber("0.002") },
                } },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "BC", "Bitcoin Confidential" },
                { "BITS", "Bitcoinus" },
                { "BITSW", "BITS" },
                { "BHD", "Bithold" },
                { "BTH", "Bithereum" },
                { "MPH", "Chasyr Token" },
                { "SBTC", "SBTCT" },
            } },
            { "options", new Dictionary<string, object>() {
                { "parseOrderToPrecision", false },
                { "networks", new Dictionary<string, object>() {
                    { "ERC20", 5 },
                    { "ETH", 5 },
                    { "OMNI", 10 },
                    { "XLM", 20 },
                    { "BEP2", 22 },
                    { "TRC20", 24 },
                    { "TRX", 24 },
                    { "SOL", 25 },
                    { "BEP20", 501 },
                } },
                { "accountsByType", new Dictionary<string, object>() {
                    { "spot", "spot" },
                    { "hold", "hold" },
                    { "funding", "funding" },
                    { "referal", "referal" },
                } },
                { "transfer", new Dictionary<string, object>() {
                    { "fillResponseFromRequest", true },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "Wrong parameters", typeof(BadRequest) },
                    { "Unauthenticated.", typeof(AuthenticationError) },
                    { "Server Error", typeof(ExchangeError) },
                    { "This feature is only enabled for users verifies by Cryptonomica", typeof(PermissionDenied) },
                    { "Too Many Attempts.", typeof(DDoSProtection) },
                    { "Selected Pair is disabled", typeof(BadSymbol) },
                    { "Invalid scope(s) provided.", typeof(PermissionDenied) },
                    { "The maximum amount of open orders with the same price cannot exceed 10", typeof(InvalidOrder) },
                    { "Your account not verified!", typeof(AccountSuspended) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "Not enough", typeof(InsufficientFunds) },
                } },
            } },
        });
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name stex#fetchCurrencies
        * @description fetches all available currencies on an exchange
        * @param {object} params extra parameters specific to the stex api endpoint
        * @returns {object} an associative dictionary of currencies
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetCurrencies(parameters);
        //
        //     {
        //         "success":true,
        //         "data":[
        //             {
        //                 "id":1,
        //                 "code":"BTC",
        //                 "name":"Bitcoin",
        //                 "active":true,
        //                 "delisted":false,
        //                 "precision":8,
        //                 "minimum_tx_confirmations":1,
        //                 "minimum_withdrawal_amount":"0.00200000",
        //                 "minimum_deposit_amount":"0.00000000",
        //                 "deposit_fee_currency_id":1,
        //                 "deposit_fee_currency_code":"BTC",
        //                 "deposit_fee_const":"0.00000000",
        //                 "deposit_fee_percent":"0.00000000",
        //                 "withdrawal_fee_currency_id":1,
        //                 "withdrawal_fee_currency_code":"BTC",
        //                 "withdrawal_fee_const":"0.00100000",
        //                 "withdrawal_fee_percent":"0.00000000",
        //                 "block_explorer_url":"https:\/\/blockchain.info\/tx\/",
        //                 "protocol_specific_settings":null
        //             },
        //         ]
        //     }
        //
        object result = new Dictionary<string, object>() {};
        object currencies = this.safeValue(response, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(currencies)); postFixIncrement(ref i))
        {
            object currency = getValue(currencies, i);
            object id = this.safeString(currency, "id");
            object numericId = this.safeInteger(currency, "id");
            // todo: will need to rethink the fees
            // to add support for multiple withdrawal/deposit methods and
            // differentiated fees for each particular method
            object code = this.safeCurrencyCode(this.safeString(currency, "code"));
            object precision = this.parseNumber(this.parsePrecision(this.safeString(currency, "precision")));
            object fee = this.safeNumber(currency, "withdrawal_fee_const"); // todo: redesign
            object active = this.safeValue(currency, "active", true);
            ((Dictionary<string, object>)result)[(string)code] = new Dictionary<string, object>() {
                { "id", id },
                { "numericId", numericId },
                { "code", code },
                { "info", currency },
                { "type", null },
                { "name", this.safeString(currency, "name") },
                { "active", active },
                { "deposit", null },
                { "withdraw", null },
                { "fee", fee },
                { "precision", precision },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", precision },
                        { "max", null },
                    } },
                    { "deposit", new Dictionary<string, object>() {
                        { "min", this.safeNumber(currency, "minimum_deposit_amount") },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", this.safeNumber(currency, "minimum_withdrawal_amount") },
                        { "max", null },
                    } },
                } },
            };
        }
        return result;
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name stex#fetchMarkets
        * @description retrieves data on all markets for stex
        * @param {object} params extra parameters specific to the exchange api endpoint
        * @returns {[object]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "code", "ALL" },
        };
        object response = await this.publicGetCurrencyPairsListCode(this.extend(request, parameters));
        //
        //     {
        //         "success":true,
        //         "data":[
        //             {
        //                 "id":935,
        //                 "currency_id":662,
        //                 "currency_code":"ABET",
        //                 "currency_name":"Altbet",
        //                 "market_currency_id":1,
        //                 "market_code":"BTC",
        //                 "market_name":"Bitcoin",
        //                 "min_order_amount":"0.00000010",
        //                 "min_buy_price":"0.00000001",
        //                 "min_sell_price":"0.00000001",
        //                 "buy_fee_percent":"0.20000000",
        //                 "sell_fee_percent":"0.20000000",
        //                 "active":true,
        //                 "delisted":false,
        //                 "pair_message":"",
        //                 "currency_precision":8,
        //                 "market_precision":8,
        //                 "symbol":"ABET_BTC",
        //                 "group_name":"BTC",
        //                 "group_id":1
        //             }
        //         ]
        //     }
        //
        object result = new List<object>() {};
        object markets = this.safeValue(response, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(markets)); postFixIncrement(ref i))
        {
            object market = getValue(markets, i);
            object id = this.safeString(market, "id");
            object numericId = this.safeInteger(market, "id");
            object baseId = this.safeString(market, "currency_id");
            object quoteId = this.safeString(market, "market_currency_id");
            object baseNumericId = this.safeInteger(market, "currency_id");
            object quoteNumericId = this.safeInteger(market, "market_currency_id");
            object bs = this.safeCurrencyCode(this.safeString(market, "currency_code"));
            object quote = this.safeCurrencyCode(this.safeString(market, "market_code"));
            object minBuyPrice = this.safeString(market, "min_buy_price");
            object minSellPrice = this.safeString(market, "min_sell_price");
            object minPrice = Precise.stringMax(minBuyPrice, minSellPrice);
            object buyFee = Precise.stringDiv(this.safeString(market, "buy_fee_percent"), "100");
            object sellFee = Precise.stringDiv(this.safeString(market, "sell_fee_percent"), "100");
            object fee = Precise.stringMax(buyFee, sellFee);
            ((List<object>)result).Add(new Dictionary<string, object>() {
                { "id", id },
                { "numericId", numericId },
                { "symbol", add(add(bs, "/"), quote) },
                { "base", bs },
                { "quote", quote },
                { "settle", null },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", null },
                { "baseNumericId", baseNumericId },
                { "quoteNumericId", quoteNumericId },
                { "type", "spot" },
                { "spot", true },
                { "margin", false },
                { "swap", false },
                { "future", false },
                { "option", false },
                { "active", this.safeValue(market, "active") },
                { "contract", false },
                { "linear", null },
                { "inverse", null },
                { "taker", fee },
                { "maker", fee },
                { "contractSize", null },
                { "expiry", null },
                { "expiryDatetime", null },
                { "strike", null },
                { "optionType", null },
                { "precision", new Dictionary<string, object>() {
                    { "amount", this.parseNumber(this.parsePrecision(this.safeString(market, "currency_precision"))) },
                    { "price", this.parseNumber(this.parsePrecision(this.safeString(market, "market_precision"))) },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "min_order_amount") },
                        { "max", null },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", minPrice },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "info", market },
            });
        }
        return result;
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name stex#fetchTicker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} params extra parameters specific to the stex api endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "currencyPairId", getValue(market, "id") },
        };
        object response = await this.publicGetTickerCurrencyPairId(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "id": 2,
        //             "amount_multiplier": 1,
        //             "currency_code": "ETH",
        //             "market_code": "BTC",
        //             "currency_name": "Ethereum",
        //             "market_name": "Bitcoin",
        //             "symbol": "ETH_BTC",
        //             "group_name": "BTC",
        //             "group_id": 1,
        //             "ask": "0.02069998",
        //             "bid": "0.02028622",
        //             "last": "0.02049224",
        //             "open": "0.02059605",
        //             "low": "0.01977744",
        //             "high": "0.02097005",
        //             "volume": "480.43248971",
        //             "volumeQuote": "23491.29826130",
        //             "count": "7384",
        //             "fiatsRate": {
        //                 "USD": 7230.86,
        //                 "EUR": 6590.79,
        //                 "UAH": 173402,
        //                 "AUD": 10595.51,
        //                 "IDR": 101568085,
        //                 "CNY": 50752,
        //                 "KRW": 8452295,
        //                 "JPY": 784607,
        //                 "VND": 167315119,
        //                 "INR": 517596,
        //                 "GBP": 5607.25,
        //                 "CAD": 9602.63,
        //                 "BRL": 30472,
        //                 "RUB": 460718
        //             },
        //             "timestamp": 1574698235601
        //         }
        //     }
        //
        object ticker = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseTicker(ticker, market);
    }

    public async override Task<object> fetchTime(object parameters = null)
    {
        /**
        * @method
        * @name stex#fetchTime
        * @description fetches the current integer timestamp in milliseconds from the exchange server
        * @param {object} params extra parameters specific to the stex api endpoint
        * @returns {int} the current integer timestamp in milliseconds from the exchange server
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetPing(parameters);
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "server_datetime": {
        //                 "date": "2019-01-22 15:13:34.233796",
        //                 "timezone_type": 3,
        //                 "timezone": "UTC"
        //             },
        //             "server_timestamp": 1548170014
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object serverDatetime = this.safeValue(data, "server_datetime", new Dictionary<string, object>() {});
        return this.parse8601(this.safeString(serverDatetime, "date"));
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name stex#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int|undefined} limit the maximum amount of order book entries to return
        * @param {object} params extra parameters specific to the stex api endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "currencyPairId", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit_bids"] = limit; // returns all if set to 0, default 100
            ((Dictionary<string, object>)request)["limit_asks"] = limit; // returns all if set to 0, default 100
        }
        object response = await this.publicGetOrderbookCurrencyPairId(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "ask": [
        //                 { "currency_pair_id": 2, "amount": "2.17865373", "price": "0.02062917", "amount2": "0.04494382", "count": 1, "cumulative_amount": 2.17865373 },
        //                 { "currency_pair_id": 2, "amount": "2.27521743", "price": "0.02062918", "amount2": "0.04693587", "count": 1, "cumulative_amount": 4.45387116 },
        //                 { "currency_pair_id": 2, "amount": "1.26980049", "price": "0.02063170", "amount2": "0.02619814", "count": 1, "cumulative_amount": 5.72367165 },
        //             ],
        //             "bid": [
        //                 { "currency_pair_id": 2, "amount": "0.00978005", "price": "0.02057000", "amount2": "0.00020118", "count": 1, "cumulative_amount": 0.00978005 },
        //                 { "currency_pair_id": 2, "amount": "0.00500000", "price": "0.02056000", "amount2": "0.00010280", "count": 1, "cumulative_amount": 0.01478005 },
        //                 { "currency_pair_id": 2, "amount": "0.77679882", "price": "0.02054001", "amount2": "0.01595546", "count": 1, "cumulative_amount": 0.79157887 },
        //             ],
        //             "ask_total_amount": 2555.749174609999,
        //             "bid_total_amount": 29.180037330000005
        //         }
        //     }
        //
        object orderbook = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseOrderBook(orderbook, symbol, null, "bid", "ask", "price", "amount");
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        //     {
        //         "id": 2,
        //         "amount_multiplier": 1,
        //         "currency_code": "ETH",
        //         "market_code": "BTC",
        //         "currency_name": "Ethereum",
        //         "market_name": "Bitcoin",
        //         "symbol": "ETH_BTC",
        //         "group_name": "BTC",
        //         "group_id": 1,
        //         "ask": "0.02069998",
        //         "bid": "0.02028622",
        //         "last": "0.02049224",
        //         "open": "0.02059605",
        //         "low": "0.01977744",
        //         "high": "0.02097005",
        //         "volume": "480.43248971",
        //         "volumeQuote": "23491.29826130",
        //         "count": "7384",
        //         "fiatsRate": {
        //             "USD": 7230.86,
        //             "EUR": 6590.79,
        //             "UAH": 173402,
        //             "AUD": 10595.51,
        //             "IDR": 101568085,
        //             "CNY": 50752,
        //             "KRW": 8452295,
        //             "JPY": 784607,
        //             "VND": 167315119,
        //             "INR": 517596,
        //             "GBP": 5607.25,
        //             "CAD": 9602.63,
        //             "BRL": 30472,
        //             "RUB": 460718
        //         },
        //         "timestamp": 1574698235601
        //     }
        //
        object timestamp = this.safeInteger(ticker, "timestamp");
        object marketId = this.safeString2(ticker, "id", "symbol");
        object symbol = this.safeSymbol(marketId, market, "_");
        object last = this.safeString(ticker, "last");
        object open = this.safeString(ticker, "open");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(ticker, "high") },
            { "low", this.safeString(ticker, "low") },
            { "bid", this.safeString(ticker, "bid") },
            { "bidVolume", null },
            { "ask", this.safeString(ticker, "ask") },
            { "askVolume", null },
            { "vwap", null },
            { "open", open },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", null },
            { "average", null },
            { "baseVolume", this.safeString(ticker, "volumeQuote") },
            { "quoteVolume", this.safeString(ticker, "volume") },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name stex#fetchTickers
        * @description fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
        * @param {[string]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} params extra parameters specific to the stex api endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.publicGetTicker(parameters);
        //
        //     {
        //         "success":true,
        //         "data":[
        //             {
        //                 "id":262,
        //                 "amount_multiplier":1,
        //                 "currency_code":"ARDR",
        //                 "market_code":"BTC",
        //                 "currency_name":"ARDOR",
        //                 "market_name":"Bitcoin",
        //                 "symbol":"ARDR_BTC",
        //                 "group_name":"BTC",
        //                 "group_id":1,
        //                 "ask":"0.00000630",
        //                 "bid":"0.00000613",
        //                 "last":"0.00000617",
        //                 "open":"0.00000620",
        //                 "low":"0.00000614",
        //                 "high":"0.00000630",
        //                 "volume":"30.37795305",
        //                 "volumeQuote":"4911487.01996544",
        //                 "count":"710",
        //                 "fiatsRate":{
        //                     "USD":7230.86,
        //                     "EUR":6590.79,
        //                     "UAH":173402,
        //                     "AUD":10744.52,
        //                     "IDR":101568085,
        //                     "CNY":50752,
        //                     "KRW":8452295,
        //                     "JPY":784607,
        //                     "VND":167315119,
        //                     "INR":517596,
        //                     "GBP":5607.25,
        //                     "CAD":9602.63,
        //                     "BRL":30472,
        //                     "RUB":467358
        //                 },
        //                 "timestamp":1574698617304,
        //                 "group_position":1
        //             },
        //         ]
        //     }
        //
        object tickers = this.safeValue(response, "data", new List<object>() {});
        return this.parseTickers(tickers, symbols);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     {
        //         "time": 1566086400000,
        //         "close": 0.01895,
        //         "open": 0.01812427,
        //         "high": 0.0191588,
        //         "low": 0.01807001,
        //         "volume": 2588.597813750006
        //     }
        //
        return new List<object> {this.safeInteger(ohlcv, "time"), this.safeNumber(ohlcv, "open"), this.safeNumber(ohlcv, "high"), this.safeNumber(ohlcv, "low"), this.safeNumber(ohlcv, "close"), this.safeNumber(ohlcv, "volume")};
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name stex#fetchOHLCV
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int|undefined} since timestamp in ms of the earliest candle to fetch
        * @param {int|undefined} limit the maximum amount of candles to fetch
        * @param {object} params extra parameters specific to the stex api endpoint
        * @returns {[[int]]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "currencyPairId", getValue(market, "id") },
            { "candlesType", this.safeString(this.timeframes, timeframe, timeframe) },
        };
        if (isTrue(isEqual(limit, null)))
        {
            limit = 100;
        } else
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object duration = this.parseTimeframe(timeframe);
        object timerange = multiply(limit, duration);
        if (isTrue(isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["timeEnd"] = this.seconds();
            ((Dictionary<string, object>)request)["timeStart"] = subtract(getValue(request, "timeEnd"), timerange);
        } else
        {
            ((Dictionary<string, object>)request)["timeStart"] = this.parseToInt(divide(since, 1000));
            ((Dictionary<string, object>)request)["timeEnd"] = this.sum(getValue(request, "timeStart"), timerange);
        }
        object response = await this.publicGetChartCurrencyPairIdCandlesType(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "data": [
        //             {
        //                 "time": 1566086400000,
        //                 "close": 0.01895,
        //                 "open": 0.01812427,
        //                 "high": 0.0191588,
        //                 "low": 0.01807001,
        //                 "volume": 2588.597813750006
        //             },
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        return this.parseOHLCVs(data, market, timeframe, since, limit);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // public fetchTrades
        //
        //     {
        //         "id": 35989317,
        //         "price": "0.02033813",
        //         "amount": "3.60000000",
        //         "type": "BUY",
        //         "timestamp": "1574713503"
        //     }
        //
        // private fetchMyTrades, fetchClosedOrder, fetchOrderTrades
        //
        //     {
        //         "id": 658745,
        //         "buy_order_id": 6587453,
        //         "sell_order_id": 6587459,
        //         "price": 0.012285,
        //         "amount": 6.35,
        //         "trade_type": "SELL",
        //         "timestamp": "1538737692"
        //     }
        //
        object id = this.safeString(trade, "id");
        object timestamp = this.safeTimestamp(trade, "timestamp");
        object priceString = this.safeString(trade, "price");
        object amountString = this.safeString(trade, "amount");
        object symbol = null;
        if (isTrue(isTrue((isEqual(symbol, null))) && isTrue((!isEqual(market, null)))))
        {
            symbol = getValue(market, "symbol");
        }
        object side = this.safeStringLower2(trade, "type", "trade_type");
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "id", id },
            { "order", null },
            { "type", null },
            { "takerOrMaker", null },
            { "side", side },
            { "price", priceString },
            { "amount", amountString },
            { "cost", null },
            { "fee", null },
        }, market);
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name stex#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int|undefined} since timestamp in ms of the earliest trade to fetch
        * @param {int|undefined} limit the maximum amount of trades to fetch
        * @param {object} params extra parameters specific to the stex api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/en/latest/manual.html?#public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "currencyPairId", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit; // currently limited to 100 or fewer
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["sort"] = "ASC"; // needed to make the from param work
            ((Dictionary<string, object>)request)["from"] = this.parseToInt(divide(since, 1000));
        }
        object response = await this.publicGetTradesCurrencyPairId(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "data": [
        //             {
        //                 "id": 35989317,
        //                 "price": "0.02033813",
        //                 "amount": "3.60000000",
        //                 "type": "BUY",
        //                 "timestamp": "1574713503"
        //             },
        //         ]
        //     }
        //
        object trades = this.safeValue(response, "data", new List<object>() {});
        return this.parseTrades(trades, market, since, limit);
    }

    public async override Task<object> fetchTradingFee(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name stex#fetchTradingFee
        * @description fetch the trading fees for a market
        * @param {string} symbol unified market symbol
        * @param {object} params extra parameters specific to the stex api endpoint
        * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "currencyPairId", getValue(market, "id") },
        };
        object response = await this.tradingGetFeesCurrencyPairId(this.extend(request, parameters));
        //
        //     {
        //         success: true,
        //         data: { buy_fee: '0.00200000', sell_fee: '0.00200000' },
        //         unified_message: { message_id: 'operation_successful', substitutions: [] }
        //      }
        //
        object data = this.safeValue(response, "data");
        return new Dictionary<string, object>() {
            { "info", response },
            { "symbol", getValue(market, "symbol") },
            { "maker", this.safeNumber(data, "sell_fee") },
            { "taker", this.safeNumber(data, "buy_fee") },
            { "percentage", true },
            { "tierBased", true },
        };
    }

    public virtual object parseBalance(object response)
    {
        object result = new Dictionary<string, object>() {
            { "info", response },
            { "timestamp", null },
            { "datetime", null },
        };
        object balances = this.safeValue(response, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
        {
            object balance = getValue(balances, i);
            object code = this.safeCurrencyCode(this.safeString(balance, "currency_id"));
            object account = this.account();
            ((Dictionary<string, object>)account)["free"] = this.safeString(balance, "balance");
            ((Dictionary<string, object>)account)["used"] = this.safeString(balance, "frozen_balance");
            ((Dictionary<string, object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name stex#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @param {object} params extra parameters specific to the stex api endpoint
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/en/latest/manual.html?#balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        // await this.loadAccounts ();
        object response = await this.profileGetWallets(parameters);
        //
        //     {
        //         "success": true,
        //         "data": [
        //             {
        //                 "id": null,
        //                 "currency_id": 665,
        //                 "delisted": false,
        //                 "disabled": false,
        //                 "disable_deposits": false,
        //                 "currency_code": "ORM",
        //                 "currency_name": "Orium",
        //                 "currency_type_id": 5,
        //                 "balance": "0",
        //                 "frozen_balance": "0",
        //                 "bonus_balance": "0",
        //                 "total_balance": "0",
        //                 "protocol_specific_settings": null,
        //                 "rates": { "BTC": "0.00000000020", "USD": "0.00000147" },
        //             },
        //             {
        //                 "id": null,
        //                 "currency_id": 272,
        //                 "delisted": false,
        //                 "disabled": false,
        //                 "disable_deposits": false,
        //                 "currency_code": "USDT",
        //                 "currency_name": "TetherUSD",
        //                 "currency_type_id": 23,
        //                 "balance": "0",
        //                 "frozen_balance": "0",
        //                 "bonus_balance": "0",
        //                 "total_balance": "0",
        //                 "protocol_specific_settings": [
        //                     { "protocol_name": "OMNI", "protocol_id": 10, "active": true, "withdrawal_fee_currency_id": 272, "withdrawal_fee_const": 10, "withdrawal_fee_percent": 0, "block_explorer_url": "https://omniexplorer.info/search/" },
        //                     { "protocol_name": "ERC20", "protocol_id": 5, "active": true, "withdrawal_fee_const": 1.2, "withdrawal_fee_percent": 0, "block_explorer_url": "https://etherscan.io/tx/" },
        //                     { "protocol_name": "TRON", "protocol_id": 24, "active": true, "withdrawal_fee_currency_id": 272, "withdrawal_fee_const": 0.2, "withdrawal_fee_percent": 0, "block_explorer_url": "https://tronscan.org/#/transaction/" }
        //                 ],
        //                 "rates": { "BTC": "0.00013893", "USD": "1" },
        //             },
        //         ]
        //     }
        //
        return this.parseBalance(response);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "PROCESSING", "open" },
            { "PENDING", "open" },
            { "PARTIAL", "open" },
            { "FINISHED", "closed" },
            { "CANCELLED", "canceled" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // createOrder, fetchOpenOrders, fetchClosedOrders, cancelOrder, fetchOrder, fetchClosedOrder
        //
        //     {
        //         "id": 828680665,
        //         "currency_pair_id": 1,
        //         "currency_pair_name": "NXT_BTC",
        //         "price": "0.011384",
        //         "trigger_price": 0.011385,
        //         "initial_amount": "13.942",
        //         "processed_amount": "3.724", // missing in fetchClosedOrder
        //         "type": "SELL",
        //         "original_type": "STOP_LIMIT_SELL",
        //         "created": "2019-01-17 10:14:48",
        //         "timestamp": "1547720088",
        //         "status": "PARTIAL"
        //         // fetchClosedOrder only
        //         "trades": [
        //             {
        //                 "id": 658745,
        //                 "buy_order_id": 658745,
        //                 "sell_order_id": 828680665,
        //                 "price": 0.012285,
        //                 "amount": 6.35,
        //                 "trade_type": "SELL",
        //                 "timestamp": "1538737692"
        //             }
        //         ],
        //         // fetchClosedOrder only
        //         "fees": [
        //             {
        //                 "id": 1234567,
        //                 "currency_id": 1,
        //                 "amount": 0.00025,
        //                 "timestamp": "1548149238"
        //             }
        //         ]
        //     }
        //
        object id = this.safeString(order, "id");
        object status = this.parseOrderStatus(this.safeString(order, "status"));
        object marketId = this.safeString2(order, "currency_pair_id", "currency_pair_name");
        object symbol = this.safeSymbol(marketId, market, "_");
        object timestamp = this.safeTimestamp(order, "timestamp");
        object price = this.safeString(order, "price");
        object amount = this.safeString(order, "initial_amount");
        object filled = this.safeString(order, "processed_amount");
        object remaining = null;
        object cost = null;
        if (isTrue(!isEqual(filled, null)))
        {
            if (isTrue(!isEqual(amount, null)))
            {
                remaining = Precise.stringSub(amount, filled);
                if (isTrue(getValue(this.options, "parseOrderToPrecision")))
                {
                    remaining = this.amountToPrecision(symbol, remaining);
                }
                remaining = Precise.stringMax(remaining, "0.0");
            }
            if (isTrue(!isEqual(price, null)))
            {
                if (isTrue(isEqual(cost, null)))
                {
                    cost = Precise.stringMul(price, filled);
                }
            }
        }
        object type = this.safeString(order, "original_type");
        if (isTrue(isTrue((isEqual(type, "BUY"))) || isTrue((isEqual(type, "SELL")))))
        {
            type = null;
        }
        object side = this.safeStringLower(order, "type");
        object trades = this.safeValue(order, "trades");
        object stopPrice = this.safeNumber(order, "trigger_price");
        object result = new Dictionary<string, object>() {
            { "info", order },
            { "id", id },
            { "clientOrderId", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "symbol", symbol },
            { "type", type },
            { "timeInForce", null },
            { "postOnly", null },
            { "side", side },
            { "price", price },
            { "stopPrice", stopPrice },
            { "triggerPrice", stopPrice },
            { "amount", amount },
            { "cost", cost },
            { "average", null },
            { "filled", filled },
            { "remaining", remaining },
            { "status", status },
            { "trades", trades },
        };
        object fees = this.safeValue(order, "fees");
        if (isTrue(isEqual(fees, null)))
        {
            ((Dictionary<string, object>)result)["fee"] = null;
        } else
        {
            object numFees = getArrayLength(fees);
            if (isTrue(isGreaterThan(numFees, 0)))
            {
                ((Dictionary<string, object>)result)["fees"] = new List<object>() {};
                for (object i = 0; isLessThan(i, getArrayLength(fees)); postFixIncrement(ref i))
                {
                    object feeCost = this.safeString(getValue(fees, i), "amount");
                    if (isTrue(!isEqual(feeCost, null)))
                    {
                        object feeCurrencyId = this.safeString(getValue(fees, i), "currency_id");
                        object feeCurrencyCode = this.safeCurrencyCode(feeCurrencyId);
                        ((List<object>)getValue(result, "fees")).Add(new Dictionary<string, object>() {
                            { "cost", feeCost },
                            { "currency", feeCurrencyCode },
                        });
                    }
                }
            } else
            {
                ((Dictionary<string, object>)result)["fee"] = null;
            }
        }
        return this.safeOrder(result, market);
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name stex#createOrder
        * @description create a trade order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float|undefined} price the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} params extra parameters specific to the stex api endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(type, "market")))
        {
            throw new ExchangeError ((string)add(this.id, " createOrder() allows limit orders only")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        if (isTrue(isEqual(type, "limit")))
        {
            type = side;
        }
        object request = new Dictionary<string, object>() {
            { "currencyPairId", getValue(market, "id") },
            { "type", ((string)type).ToUpper() },
            { "amount", parseFloat(this.amountToPrecision(symbol, amount)) },
            { "price", parseFloat(this.priceToPrecision(symbol, price)) },
        };
        object response = await this.tradingPostOrdersCurrencyPairId(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "id": 828680665,
        //             "currency_pair_id": 1,
        //             "currency_pair_name": "NXT_BTC",
        //             "price": "0.011384",
        //             "trigger_price": 0.011385,
        //             "initial_amount": "13.942",
        //             "processed_amount": "3.724",
        //             "type": "SELL",
        //             "original_type": "STOP_LIMIT_SELL",
        //             "created": "2019-01-17 10:14:48",
        //             "timestamp": "1547720088",
        //             "status": "PARTIAL"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(data, market);
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name stex#fetchOrder
        * @description fetches information on an order made by the user
        * @param {string|undefined} symbol unified symbol of the market the order was made in
        * @param {object} params extra parameters specific to the stex api endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "orderId", id },
        };
        object response = await this.tradingGetOrderOrderId(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "id": 828680665,
        //             "currency_pair_id": 1,
        //             "currency_pair_name": "NXT_BTC",
        //             "price": "0.011384",
        //             "trigger_price": 0.011385,
        //             "initial_amount": "13.942",
        //             "processed_amount": "3.724",
        //             "type": "SELL",
        //             "original_type": "STOP_LIMIT_SELL",
        //             "created": "2019-01-17 10:14:48",
        //             "timestamp": "1547720088",
        //             "status": "PARTIAL"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        return this.parseOrder(data, market);
    }

    public async virtual Task<object> fetchClosedOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name stex#fetchClosedOrder
        * @description fetch an open order by it's id
        * @param {string} id order id
        * @param {string|undefined} symbol unified market symbol, default is undefined
        * @param {object} params extra parameters specific to the stex api endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "orderId", id },
        };
        object response = await this.reportsGetOrdersOrderId(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "id": 5478965,
        //             "currency_pair_id": 1,
        //             "currency_pair_name": "NXT_BTC",
        //             "price": "0.00013800",
        //             "initial_amount": "1.00000000",
        //             "type": "BUY",
        //             "created": "2019-01-22 09:27:17",
        //             "timestamp": 1548149237,
        //             "status": "FINISHED",
        //             "trades": [
        //                 {
        //                     "id": 658745,
        //                     "buy_order_id": 6587453,
        //                     "sell_order_id": 6587459,
        //                     "price": 0.012285,
        //                     "amount": 6.35,
        //                     "trade_type": "SELL",
        //                     "timestamp": "1538737692"
        //                 }
        //             ],
        //             "fees": [
        //                 {
        //                     "id": 1234567,
        //                     "currency_id": 1,
        //                     "amount": 0.00025,
        //                     "timestamp": "1548149238"
        //                 }
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        return this.parseOrder(data, market);
    }

    public async override Task<object> fetchOrderTrades(object id, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name stex#fetchOrderTrades
        * @description fetch all the trades made from a single order
        * @param {string} id order id
        * @param {string|undefined} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch trades for
        * @param {int|undefined} limit the maximum number of trades to retrieve
        * @param {object} params extra parameters specific to the stex api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object order = await this.fetchClosedOrder(id, symbol, parameters);
        return getValue(order, "trades");
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name stex#fetchOpenOrders
        * @description fetch all unfilled currently open orders
        * @param {string|undefined} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch open orders for
        * @param {int|undefined} limit the maximum number of  open orders structures to retrieve
        * @param {object} params extra parameters specific to the stex api endpoint
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object method = "tradingGetOrders";
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            method = "tradingGetOrdersCurrencyPairId";
            market = this.market(symbol);
            ((Dictionary<string, object>)request)["currencyPairId"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        //     {
        //         "success": true,
        //         "data": [
        //             {
        //                 "id": 828680665,
        //                 "currency_pair_id": 1,
        //                 "currency_pair_name": "NXT_BTC",
        //                 "price": "0.011384",
        //                 "trigger_price": 0.011385,
        //                 "initial_amount": "13.942",
        //                 "processed_amount": "3.724",
        //                 "type": "SELL",
        //                 "original_type": "STOP_LIMIT_SELL",
        //                 "created": "2019-01-17 10:14:48",
        //                 "timestamp": "1547720088",
        //                 "status": "PARTIAL"
        //             }
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        return this.parseOrders(data, market, since, limit);
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name stex#cancelOrder
        * @description cancels an open order
        * @param {string} id order id
        * @param {string|undefined} symbol not used by stex cancelOrder ()
        * @param {object} params extra parameters specific to the stex api endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "orderId", id },
        };
        object response = await this.tradingDeleteOrderOrderId(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "put_into_processing_queue": [
        //                 {
        //                     "id": 828680665,
        //                     "currency_pair_id": 1,
        //                     "currency_pair_name": "NXT_BTC",
        //                     "price": "0.011384",
        //                     "trigger_price": 0.011385,
        //                     "initial_amount": "13.942",
        //                     "processed_amount": "3.724",
        //                     "type": "SELL",
        //                     "original_type": "STOP_LIMIT_SELL",
        //                     "created": "2019-01-17 10:14:48",
        //                     "timestamp": "1547720088",
        //                     "status": "PARTIAL"
        //                 }
        //             ],
        //             "not_put_into_processing_queue": [
        //                 {
        //                     "id": 828680665,
        //                     "currency_pair_id": 1,
        //                     "currency_pair_name": "NXT_BTC",
        //                     "price": "0.011384",
        //                     "trigger_price": 0.011385,
        //                     "initial_amount": "13.942",
        //                     "processed_amount": "3.724",
        //                     "type": "SELL",
        //                     "original_type": "STOP_LIMIT_SELL",
        //                     "created": "2019-01-17 10:14:48",
        //                     "timestamp": "1547720088",
        //                     "status": "PARTIAL"
        //                 }
        //             ],
        //             "message": "string"
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object acceptedOrders = this.safeValue(data, "put_into_processing_queue", new List<object>() {});
        object rejectedOrders = this.safeValue(data, "not_put_into_processing_queue", new List<object>() {});
        object numAcceptedOrders = getArrayLength(acceptedOrders);
        object numRejectedOrders = getArrayLength(rejectedOrders);
        if (isTrue(isLessThan(numAcceptedOrders, 1)))
        {
            if (isTrue(isLessThan(numRejectedOrders, 1)))
            {
                throw new OrderNotFound ((string)add(add(this.id, " cancelOrder() received an empty response: "), this.json(response))) ;
            } else
            {
                return this.parseOrder(getValue(rejectedOrders, 0));
            }
        } else
        {
            if (isTrue(isLessThan(numRejectedOrders, 1)))
            {
                return this.parseOrder(getValue(acceptedOrders, 0));
            } else
            {
                throw new OrderNotFound ((string)add(add(this.id, " cancelOrder() received an empty response: "), this.json(response))) ;
            }
        }
    }

    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name stex#cancelAllOrders
        * @description cancel all open orders
        * @param {string|undefined} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
        * @param {object} params extra parameters specific to the stex api endpoint
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object method = "tradingDeleteOrders";
        if (isTrue(!isEqual(symbol, null)))
        {
            object market = this.market(symbol);
            ((Dictionary<string, object>)request)["currencyPairId"] = getValue(market, "id");
            method = "tradingDeleteOrdersCurrencyPairId";
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        //     {
        //         "success":true,
        //         "data":{
        //             "put_into_processing_queue":[],
        //             "not_put_into_processing_queue":[],
        //             "message":"Orders operations are handled in processing queue, therefore cancelling is not immediate."
        //         }
        //     }
        //
        return response;
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name stex#fetchMyTrades
        * @description fetch all trades made by the user
        * @param {string} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch trades for
        * @param {int|undefined} limit the maximum number of trades structures to retrieve
        * @param {object} params extra parameters specific to the stex api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchMyTrades() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "currencyPairId", getValue(market, "id") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["timeStart"] = this.iso8601(since);
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object response = await this.reportsGetTradesCurrencyPairId(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "data": [
        //             {
        //                 "id": 658745,
        //                 "buy_order_id": 6587453,
        //                 "sell_order_id": 6587459,
        //                 "price": 0.012285,
        //                 "amount": 6.35,
        //                 "trade_type": "SELL",
        //                 "timestamp": "1538737692"
        //             }
        //         ]
        //     }
        //
        object trades = this.safeValue(response, "data", new List<object>() {});
        return this.parseTrades(trades, market, since, limit);
    }

    public async override Task<object> createDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name stex#createDepositAddress
        * @description create a currency deposit address
        * @param {string} code unified currency code of the currency for the deposit address
        * @param {object} params extra parameters specific to the stex api endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currencyId", getValue(currency, "id") },
        };
        object response = await this.profilePostWalletsCurrencyId(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "id": 45875,
        //             "currency_id": 1,
        //             "delisted": false,
        //             "disabled": false,
        //             "disable_deposits": false,
        //             "code": "BTC",
        //             "balance": "0.198752",
        //             "frozen_balance": "1.5784",
        //             "bonus_balance": "0.000",
        //             "deposit_address": {
        //                 "address": "0X12WERTYUIIJHGFVBNMJHGDFGHJ765SDFGHJ",
        //                 "address_name": "Address",
        //                 "additional_address_parameter": "qwertyuiopasdfghjkl",
        //                 "additional_address_parameter_name": "Destination Tag",
        //                 "notification": "",
        //                 "protocol_id": 10,
        //                 "protocol_name": "Tether OMNI",
        //                 "supports_new_address_creation": false
        //                 },
        //             "multi_deposit_addresses": [
        //                 {
        //                     "address": "0X12WERTYUIIJHGFVBNMJHGDFGHJ765SDFGHJ",
        //                     "address_name": "Address",
        //                     "additional_address_parameter": "qwertyuiopasdfghjkl",
        //                     "additional_address_parameter_name": "Destination Tag",
        //                     "notification": "",
        //                     "protocol_id": 10,
        //                     "protocol_name": "Tether OMNI",
        //                     "supports_new_address_creation": false
        //                 }
        //             ],
        //             "withdrawal_additional_field_name": "Payment ID (optional)",
        //             "rates": { "BTC": 0.000001 },
        //             "protocol_specific_settings": [
        //                 {
        //                     "protocol_name": "Tether OMNI",
        //                     "protocol_id": 10,
        //                     "active": true,
        //                     "withdrawal_fee_currency_id": 1,
        //                     "withdrawal_fee_const": 0.002,
        //                     "withdrawal_fee_percent": 0,
        //                     "block_explorer_url": "https://omniexplorer.info/search/"
        //                 }
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object depositAddress = this.safeValue(data, "deposit_address", new Dictionary<string, object>() {});
        object address = this.safeString(depositAddress, "address");
        object tag = this.safeString(depositAddress, "additional_address_parameter");
        this.checkAddress(address);
        return new Dictionary<string, object>() {
            { "currency", code },
            { "address", address },
            { "tag", tag },
            { "info", response },
        };
    }

    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name stex#fetchDepositAddress
        * @description fetch the deposit address for a currency associated with this account
        * @param {string} code unified currency code
        * @param {object} params extra parameters specific to the stex api endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object balance = await this.fetchBalance();
        object wallets = this.safeValue(getValue(balance, "info"), "data", new List<object>() {});
        object walletsByCurrencyId = this.indexBy(wallets, "currency_id");
        object currency = this.currency(code);
        object wallet = this.safeValue(walletsByCurrencyId, getValue(currency, "id"));
        if (isTrue(isEqual(wallet, null)))
        {
            throw new ExchangeError ((string)add(add(add(this.id, " fetchDepositAddress() could not find the wallet id for currency code "), code), ", try to call createDepositAddress() first")) ;
        }
        object walletId = this.safeInteger(wallet, "id");
        if (isTrue(isEqual(walletId, null)))
        {
            throw new ExchangeError ((string)add(add(add(this.id, " fetchDepositAddress() could not find the wallet id for currency code "), code), ", try to call createDepositAddress() first")) ;
        }
        object request = new Dictionary<string, object>() {
            { "walletId", walletId },
        };
        object response = await this.profileGetWalletsWalletId(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "id": 45875,
        //             "currency_id": 1,
        //             "delisted": false,
        //             "disabled": false,
        //             "disable_deposits": false,
        //             "code": "BTC",
        //             "balance": "0.198752",
        //             "frozen_balance": "1.5784",
        //             "bonus_balance": "0.000",
        //             "deposit_address": {
        //                 "address": "0X12WERTYUIIJHGFVBNMJHGDFGHJ765SDFGHJ",
        //                 "address_name": "Address",
        //                 "additional_address_parameter": "qwertyuiopasdfghjkl",
        //                 "additional_address_parameter_name": "Destination Tag",
        //                 "notification": "",
        //                 "protocol_id": 10,
        //                 "protocol_name": "Tether OMNI",
        //                 "supports_new_address_creation": false
        //             },
        //             "multi_deposit_addresses": [
        //                 {
        //                     "address": "0X12WERTYUIIJHGFVBNMJHGDFGHJ765SDFGHJ",
        //                     "address_name": "Address",
        //                     "additional_address_parameter": "qwertyuiopasdfghjkl",
        //                     "additional_address_parameter_name": "Destination Tag",
        //                     "notification": "",
        //                     "protocol_id": 10,
        //                     "protocol_name": "Tether OMNI",
        //                     "supports_new_address_creation": false
        //                 }
        //             ],
        //             "withdrawal_additional_field_name": "Payment ID (optional)",
        //             "rates": { "BTC": 0.000001 },
        //             "protocol_specific_settings": [
        //                 {
        //                     "protocol_name": "Tether OMNI",
        //                     "protocol_id": 10,
        //                     "active": true,
        //                     "withdrawal_fee_currency_id": 1,
        //                     "withdrawal_fee_const": 0.002,
        //                     "withdrawal_fee_percent": 0,
        //                     "block_explorer_url": "https://omniexplorer.info/search/"
        //                 }
        //             ]
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new List<object>() {});
        object depositAddress = this.safeValue(data, "deposit_address", new Dictionary<string, object>() {});
        object address = this.safeString(depositAddress, "address");
        object tag = this.safeString(depositAddress, "additional_address_parameter");
        this.checkAddress(address);
        return new Dictionary<string, object>() {
            { "currency", code },
            { "address", address },
            { "tag", tag },
            { "network", null },
            { "info", response },
        };
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object url = add(add(add(add(getValue(getValue(this.urls, "api"), "rest"), "/"), api), "/"), this.implodeParams(path, parameters));
        object query = this.omit(parameters, this.extractParams(path));
        if (isTrue(isEqual(api, "public")))
        {
            if (isTrue(getArrayLength(new List<object>(((Dictionary<string,object>)query).Keys))))
            {
                url = add(url, add("?", this.urlencode(query)));
            }
        } else
        {
            this.checkRequiredCredentials();
            headers = new Dictionary<string, object>() {
                { "Authorization", add("Bearer ", this.token) },
            };
            if (isTrue(isTrue(isEqual(method, "GET")) || isTrue(isEqual(method, "DELETE"))))
            {
                if (isTrue(getArrayLength(new List<object>(((Dictionary<string,object>)query).Keys))))
                {
                    url = add(url, add("?", this.urlencode(query)));
                }
            } else
            {
                body = this.json(query);
                if (isTrue(getArrayLength(new List<object>(((Dictionary<string,object>)query).Keys))))
                {
                    ((Dictionary<string, object>)headers)["Content-Type"] = "application/json";
                }
            }
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public virtual object parseTransactionStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "processing", "pending" },
            { "checking by system", "pending" },
            { "hodl", "pending" },
            { "amount too low", "failed" },
            { "not confirmed", "pending" },
            { "cancelled by user", "canceled" },
            { "approved", "pending" },
            { "finished", "ok" },
            { "withdrawal error", "failed" },
            { "deposit error", "failed" },
            { "cancelled by admin", "canceled" },
            { "awaiting", "pending" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // fetchDeposit & fetchDeposits
        //
        //     {
        //         "id": 123654789,
        //         "currency_id": 1,
        //         "currency_code": "BTC",
        //         "deposit_fee_currency_id": 1,
        //         "deposit_fee_currency_code": "BTC",
        //         "amount": 0.25,
        //         "fee": 0.00025,
        //         "txid": "qwertyuhgfdsasdfgh",
        //         "protocol_id": 0,
        //         "deposit_status_id": 1,
        //         "status": "PROCESSING",
        //         "status_color": "#BC3D51",
        //         "created_at": "2018-11-28 12:32:08",
        //         "timestamp": "1543409389",
        //         "confirmations": "1 of 2"
        //     }
        //
        // fetchWithdrawal && fetchWithdrawals
        //
        //     {
        //         "id": 65899,
        //         "amount": "0.00600000",
        //         "currency_id": 1,
        //         "currency_code": "BTC",
        //         "fee": "0.00400000",
        //         "fee_currency_id": 1,
        //         "fee_currency_code": "BTC",
        //         "withdrawal_status_id": 1,
        //         "status": "Not Confirmed",
        //         "status_color": "#BC3D51",
        //         "created_at": "2019-01-21 09:36:05",
        //         "created_ts": "1548063365",
        //         "updated_at": "2019-01-21 09:36:05",
        //         "updated_ts": "1548063365",
        //         "txid": null,
        //         "protocol_id": 0,
        //         "withdrawal_address": {
        //             "address": "0X12WERTYUIIJHGFVBNMJHGDFGHJ765SDFGHJ",
        //             "address_name": "Address",
        //             "additional_address_parameter": "qwertyuiopasdfghjkl",
        //             "additional_address_parameter_name": "Destination Tag",
        //             "notification": "",
        //             "protocol_id": 10,
        //             "protocol_name": "Tether OMNI",
        //             "supports_new_address_creation": false
        //         }
        //     }
        //
        object id = this.safeString(transaction, "id");
        object withdrawalAddress = this.safeValue(transaction, "withdrawal_address", new Dictionary<string, object>() {});
        object address = this.safeString(withdrawalAddress, "address");
        object tag = this.safeString(withdrawalAddress, "additional_address_parameter");
        object currencyId = this.safeString(transaction, "currency_id");
        object code = null;
        if (isTrue(((Dictionary<string,object>)this.currencies_by_id).ContainsKey(toStringOrNull(currencyId))))
        {
            currency = getValue(this.currencies_by_id, currencyId);
        } else
        {
            code = this.commonCurrencyCode(this.safeString(transaction, "currency_code"));
        }
        if (isTrue(isTrue((isEqual(code, null))) && isTrue((!isEqual(currency, null)))))
        {
            code = getValue(currency, "code");
        }
        object type = ((bool) isTrue((((Dictionary<string,object>)transaction).ContainsKey(toStringOrNull("deposit_status_id"))))) ? "deposit" : "withdrawal";
        object amount = this.safeNumber(transaction, "amount");
        object status = this.parseTransactionStatus(this.safeStringLower(transaction, "status"));
        object timestamp = this.safeTimestamp2(transaction, "timestamp", "created_ts");
        object updated = this.safeTimestamp(transaction, "updated_ts");
        object txid = this.safeString(transaction, "txid");
        object fee = null;
        object feeCost = this.safeNumber(transaction, "fee");
        if (isTrue(!isEqual(feeCost, null)))
        {
            object feeCurrencyId = this.safeString2(transaction, "fee_currency_id", "deposit_fee_currency_id");
            object feeCurrencyCode = this.safeCurrencyCode(feeCurrencyId);
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", feeCurrencyCode },
            };
        }
        object network = this.safeString(withdrawalAddress, "protocol_name");
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", id },
            { "txid", txid },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "network", network },
            { "addressFrom", null },
            { "address", address },
            { "addressTo", address },
            { "tagFrom", null },
            { "tag", tag },
            { "tagTo", tag },
            { "type", type },
            { "amount", amount },
            { "currency", code },
            { "status", status },
            { "updated", updated },
            { "fee", fee },
        };
    }

    public async virtual Task<object> fetchDeposit(object id, object code = null, object parameters = null)
    {
        /**
        * @method
        * @name stex#fetchDeposit
        * @description fetch information on a deposit
        * @param {string} id deposit id
        * @param {string|undefined} code not used by stex fetchDeposit ()
        * @param {object} params extra parameters specific to the stex api endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "id", id },
        };
        object response = await this.profileGetDepositsId(this.extend(request, parameters));
        //
        //     {
        //         success: true,
        //         data: {
        //             id: '21974074',
        //             currency_id: '272',
        //             block_explorer_url: 'https://omniexplorer.info/search/',
        //             currency_code: 'USDT',
        //             deposit_fee_currency_id: '272',
        //             deposit_fee_currency_code: 'USDT',
        //             amount: '11.00000000',
        //             fee: '0.00000000',
        //             deposit_status_id: '3',
        //             status: 'FINISHED',
        //             status_color: '#00BE75',
        //             txid: '15b50da4600a5021dbddaed8f4a71de093bf206ea66eb4ab2f151e3e9e2fed71',
        //             protocol_id: '24',
        //             confirmations: '129 of 20',
        //             created_at: '2022-05-16 16:38:40',
        //             timestamp: '1652719120',
        //             protocol_specific_settings: [{
        //                 protocol_name: 'TRON',
        //                 protocol_id: '24',
        //                 block_explorer_url: 'https://tronscan.org/#/transaction/'
        //             }]
        //         },
        //         unified_message: {
        //             message_id: 'operation_successful',
        //             substitutions: []
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseTransaction(data);
    }

    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name stex#fetchDeposits
        * @description fetch all deposits made to an account
        * @param {string|undefined} code unified currency code
        * @param {int|undefined} since the earliest time in ms to fetch deposits for
        * @param {int|undefined} limit the maximum number of deposits structures to retrieve
        * @param {object} params extra parameters specific to the stex api endpoint
        * @returns {[object]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((Dictionary<string, object>)request)["currencyId"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["timeStart"] = since;
        }
        object response = await this.profileGetDeposits(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "data": [
        //             {
        //                 "id": 123654789,
        //                 "currency_id": 1,
        //                 "currency_code": "BTC",
        //                 "deposit_fee_currency_id": 1,
        //                 "deposit_fee_currency_code": "BTC",
        //                 "amount": 0.25,
        //                 "fee": 0.00025,
        //                 "txid": "qwertyuhgfdsasdfgh",
        //                 "protocol_id": 0,
        //                 "deposit_status_id": 1,
        //                 "status": "PROCESSING",
        //                 "status_color": "#BC3D51",
        //                 "created_at": "2018-11-28 12:32:08",
        //                 "timestamp": "1543409389",
        //                 "confirmations": "1 of 2",
        //                 "protocol_specific_settings": {
        //                     "protocol_name": "Tether OMNI",
        //                     "protocol_id": 10,
        //                     "block_explorer_url": "https://omniexplorer.info/search/"
        //                 }
        //             }
        //         ]
        //     }
        //
        object deposits = this.safeValue(response, "data", new List<object>() {});
        return this.parseTransactions(deposits, currency, since, limit);
    }

    public async virtual Task<object> fetchWithdrawal(object id, object code = null, object parameters = null)
    {
        /**
        * @method
        * @name stex#fetchWithdrawal
        * @description fetch data on a currency withdrawal via the withdrawal id
        * @param {string} id withdrawal id
        * @param {string|undefined} code not used by stex.fetchWithdrawal
        * @param {object} params extra parameters specific to the stex api endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "id", id },
        };
        object response = await this.profileGetWithdrawalsId(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "id": 65899,
        //             "amount": "0.00600000",
        //             "currency_id": 1,
        //             "currency_code": "BTC",
        //             "fee": "0.00400000",
        //             "fee_currency_id": 1,
        //             "fee_currency_code": "BTC",
        //             "withdrawal_status_id": 1,
        //             "status": "Not Confirmed",
        //             "status_color": "#BC3D51",
        //             "created_at": "2019-01-21 09:36:05",
        //             "created_ts": "1548063365",
        //             "updated_at": "2019-01-21 09:36:05",
        //             "updated_ts": "1548063365",
        //             "reason": "string",
        //             "txid": null,
        //             "protocol_id": 0,
        //             "withdrawal_address": {
        //                 "address": "0X12WERTYUIIJHGFVBNMJHGDFGHJ765SDFGHJ",
        //                 "address_name": "Address",
        //                 "additional_address_parameter": "qwertyuiopasdfghjkl",
        //                 "additional_address_parameter_name": "Destination Tag",
        //                 "notification": "",
        //                 "protocol_id": 10,
        //                 "protocol_name": "Tether OMNI",
        //                 "supports_new_address_creation": false
        //             },
        //             "protocol_specific_settings": {
        //                 "protocol_name": "Tether OMNI",
        //                 "protocol_id": 10,
        //                 "block_explorer_url": "https://omniexplorer.info/search/"
        //             }
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseTransaction(data);
    }

    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name stex#fetchWithdrawals
        * @description fetch all withdrawals made from an account
        * @param {string|undefined} code unified currency code
        * @param {int|undefined} since the earliest time in ms to fetch withdrawals for
        * @param {int|undefined} limit the maximum number of withdrawals structures to retrieve
        * @param {object} params extra parameters specific to the stex api endpoint
        * @returns {[object]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((Dictionary<string, object>)request)["currencyId"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["timeStart"] = since;
        }
        object response = await this.profileGetWithdrawals(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "data": [
        //             {
        //                 "id": 65899,
        //                 "amount": "0.00600000",
        //                 "currency_id": 1,
        //                 "currency_code": "BTC",
        //                 "fee": "0.00400000",
        //                 "fee_currency_id": 1,
        //                 "fee_currency_code": "BTC",
        //                 "withdrawal_status_id": 1,
        //                 "status": "Not Confirmed",
        //                 "status_color": "#BC3D51",
        //                 "created_at": "2019-01-21 09:36:05",
        //                 "created_ts": "1548063365",
        //                 "updated_at": "2019-01-21 09:36:05",
        //                 "updated_ts": "1548063365",
        //                 "txid": null,
        //                 "protocol_id": 0,
        //                 "withdrawal_address": {
        //                     "address": "0X12WERTYUIIJHGFVBNMJHGDFGHJ765SDFGHJ",
        //                     "address_name": "Address",
        //                     "additional_address_parameter": "qwertyuiopasdfghjkl",
        //                     "additional_address_parameter_name": "Destination Tag",
        //                     "notification": "",
        //                     "protocol_id": 10,
        //                     "protocol_name": "Tether OMNI",
        //                     "supports_new_address_creation": false
        //                 },
        //                 "protocol_specific_settings": {
        //                     "protocol_name": "Tether OMNI",
        //                     "protocol_id": 10,
        //                     "block_explorer_url": "https://omniexplorer.info/search/"
        //                 }
        //             }
        //         ]
        //     }
        //
        object withdrawals = this.safeValue(response, "data", new List<object>() {});
        return this.parseTransactions(withdrawals, currency, since, limit);
    }

    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        /**
        * @method
        * @name stex#transfer
        * @description transfer currency internally between wallets on the same account
        * @param {string} code unified currency code
        * @param {float} amount amount to transfer
        * @param {string} fromAccount account to transfer from
        * @param {string} toAccount account to transfer to
        * @param {object} params extra parameters specific to the stex api endpoint
        * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object method = null;
        object request = new Dictionary<string, object>() {};
        if (isTrue(isTrue(isEqual(fromAccount, "referal")) && isTrue(isEqual(toAccount, "spot"))))
        {
            ((Dictionary<string, object>)request)["currencyId"] = getValue(currency, "id");
            method = "profilePostReferralBonusTransferCurrencyId";
        } else if (isTrue(isEqual(toAccount, "hold")))
        {
            ((Dictionary<string, object>)request)["walletId"] = fromAccount;
            amount = this.currencyToPrecision(code, amount);
            amount = Precise.stringNeg(amount);
            ((Dictionary<string, object>)request)["amount"] = amount;
            method = "profilePostWalletsWalletIdHoldAmount";
        } else if (isTrue(isEqual(fromAccount, "hold")))
        {
            ((Dictionary<string, object>)request)["walletId"] = toAccount;
            ((Dictionary<string, object>)request)["amount"] = amount;
            method = "profilePostWalletsWalletIdHoldAmount";
        } else
        {
            throw new ExchangeError ((string)add(this.id, " transfer() only allows transfers of referal to spot and between a walletId and funding")) ;
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        //  profilePostReferralBonusTransferCurrencyId
        //     {
        //         "success": true,
        //         "data": ""
        //     }
        //
        //  profilePostWalletsWalletIdHoldAmount
        //     {
        //         success: true,
        //         data: {
        //             id: '4055802',
        //             currency_id: '272',
        //             currency_code: 'USDT',
        //             currency_name: 'TetherUSD',
        //             balance: '10.00000000',
        //             frozen_balance: '0.00000000',
        //             bonus_balance: '0.00000000',
        //             hold_balance: '1.00000000',
        //             total_balance: '11.00000000',
        //             disable_deposits: false,
        //             disable_withdrawals: false,
        //             withdrawal_limit: '0.00000000',
        //             delisted: false,
        //             disabled: false,
        //             deposit_address: null,
        //             multi_deposit_addresses: [{
        //                 address: 'TYzhabfHWMLgLnMW46ZyUHkUVJPXaDgdxK',
        //                 address_name: 'Deposit Address',
        //                 additional_address_parameter: null,
        //                 additional_address_parameter_name: null,
        //                 notification: '',
        //                 protocol_id: '24',
        //                 protocol_name: 'TRON',
        //                 supports_new_address_creation: false
        //             }],
        //             contract_or_asset_id: '31',
        //             contract_field_name: null,
        //             withdrawal_additional_field_name: null,
        //             depo_message: '',
        //             wd_message: '',
        //             currency_type_id: '23',
        //             protocol_specific_settings: [{
        //                 {
        //                     protocol_name: 'ERC20',
        //                     protocol_id: '5',
        //                     active: true,
        //                     disable_deposits: false,
        //                     disable_withdrawals: false,
        //                     withdrawal_limit: '0',
        //                     deposit_fee_currency_id: '272',
        //                     deposit_fee_currency_code: 'USDT',
        //                     deposit_fee_percent: '0',
        //                     deposit_fee_const: '0',
        //                     withdrawal_fee_currency_id: '272',
        //                     withdrawal_fee_currency_code: 'USDT',
        //                     withdrawal_fee_const: '10',
        //                     withdrawal_fee_percent: '0',
        //                     block_explorer_url: 'https://etherscan.io/tx/',
        //                     contract_or_asset_id: '0xdac17f958d2ee523a2206206994597c13d831ec7',
        //                     contract_field_name: '',
        //                     withdrawal_additional_field_name: '',
        //                     depo_message: '',
        //                     wd_message: ''
        //                 },
        //                 ...
        //             ],
        //             coin_info: {
        //                 twitter: 'https://twitter.com/Tether_to',
        //                 version: '',
        //                 facebook: 'https://www.facebook.com/tether.to',
        //                 telegram: '',
        //                 icon_large: 'https://app-coin-images.stex.com/large/usdt.png',
        //                 icon_small: 'https://app-coin-images.stex.com/small/usdt.png',
        //                 description: 'Tether (USDT) is a cryptocurrency with a value meant to mirror the value of the U.S. dollar. The idea was to create a stable cryptocurrency that can be used like digital dollars. Coins that serve this purpose of being a stable dollar substitute are called stable coins. Tether is the most popular stable coin and even acts as a dollar replacement on many popular exchanges! According to their site, Tether converts cash into digital currency, to anchor or tether the value of the coin to the price of national currencies like the US dollar, the Euro, and the Yen. Like other cryptos it uses blockchain. Unlike other cryptos, it is [according to the official Tether site] 100% backed by USD (USD is held in reserve). The primary use of Tether is that it offers some stability to the otherwise volatile crypto space and offers liquidity to exchanges who cant deal in dollars and with banks (for example to the sometimes controversial but leading exchange Bitfinex).The digital coins are issued by a company called Tether Limited that is governed by the laws of the British Virgin Islands, according to the legal part of its website. It is incorporated in Hong Kong. It has emerged that Jan Ludovicus van der Velde is the CEO of cryptocurrency exchange Bitfinex, which has been accused of being involved in the price manipulation of bitcoin, as well as tether. Many people trading on exchanges, including Bitfinex, will use tether to buy other cryptocurrencies like bitcoin. Tether Limited argues that using this method to buy virtual currencies allows users to move fiat in and out of an exchange more quickly and cheaply. Also, exchanges typically have rocky relationships with banks, and using Tether is a way to circumvent that.USDT is fairly simple to use. Once on exchanges like Poloniex or Bittrex, it can be used to purchase Bitcoin and other cryptocurrencies. It can be easily transferred from an exchange to any Omni Layer enabled wallet. Tether has no transaction fees, although external wallets and exchanges may charge one. In order to convert USDT to USD and vise versa through the Tether.to Platform, users must pay a small fee. Buying and selling Tether for Bitcoin can be done through a variety of exchanges like the ones mentioned previously or through the Tether.to platform, which also allows the conversion between USD to and from your bank account.',
        //                 official_site: 'https://tether.to/',
        //                 official_block_explorer: 'https://etherscan.io/token/0xdac17f958d2ee523a2206206994597c13d831ec7'
        //             },
        //             rates: {
        //                 BTC: '0.00003372',
        //                 USD: '1'
        //             }
        //         },
        //         unified_message: {
        //             message_id: 'operation_successful',
        //             substitutions: []
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        object transfer = this.parseTransfer(data, currency);
        object transferOptions = this.safeValue(this.options, "transfer", new Dictionary<string, object>() {});
        object fillResponseFromRequest = this.safeValue(transferOptions, "fillResponseFromRequest", true);
        if (isTrue(fillResponseFromRequest))
        {
            ((Dictionary<string, object>)transfer)["fromAccount"] = fromAccount;
            ((Dictionary<string, object>)transfer)["toAccount"] = toAccount;
            if (isTrue(isTrue(((amount).GetType() == typeof(string))) && isTrue(Precise.stringLt(amount, "0"))))
            {
                amount = this.parseNumber(Precise.stringNeg(amount));
            }
            ((Dictionary<string, object>)transfer)["amount"] = amount;
            if (isTrue(isEqual(getValue(transfer, "currency"), null)))
            {
                ((Dictionary<string, object>)transfer)["currency"] = code;
            }
        }
        return transfer;
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        //
        //     {
        //         "id": 45875,
        //         "currency_id": 1,
        //         "currency_code": "USDT",
        //         "currency_name": "TetherUSD",
        //         "balance": "0.198752",
        //         "frozen_balance": "1.5784",
        //         "bonus_balance": "0.000",
        //         "hold_balance": "0.000",
        //         "total_balance": "1.777152",
        //         "disable_deposits": false,
        //         "disable_withdrawals": false,
        //         "withdrawal_limit": "string",
        //         "delisted": false,
        //         "disabled": false,
        //         "deposit_address": {
        //             "address": "0X12WERTYUIIJHGFVBNMJHGDFGHJ765SDFGHJ",
        //             "address_name": "Address",
        //             "additional_address_parameter": "qwertyuiopasdfghjkl",
        //             "additional_address_parameter_name": "Destination Tag",
        //             "notification": "",
        //             "protocol_id": 10,
        //             "protocol_name": "Tether OMNI",
        //             "supports_new_address_creation": false
        //         },
        //         "multi_deposit_addresses": [{
        //             "address": "0X12WERTYUIIJHGFVBNMJHGDFGHJ765SDFGHJ",
        //             "address_name": "Address",
        //             "additional_address_parameter": "qwertyuiopasdfghjkl",
        //             "additional_address_parameter_name": "Destination Tag",
        //             "notification": "",
        //             "protocol_id": 10,
        //             "protocol_name": "Tether OMNI",
        //             "supports_new_address_creation": false
        //         }],
        //         "withdrawal_additional_field_name": "Payment ID (optional)",
        //         "currency_type_id": 23,
        //         "protocol_specific_settings": [{
        //             "protocol_name": "Tether OMNI",
        //             "protocol_id": 10,
        //             "active": true,
        //             "disable_deposits": false,
        //             "disable_withdrawals": false,
        //             "withdrawal_limit": 0,
        //             "deposit_fee_currency_id": 272,
        //             "deposit_fee_currency_code": "USDT",
        //             "deposit_fee_percent": 0,
        //             "deposit_fee_const": 0,
        //             "withdrawal_fee_currency_id": 1,
        //             "withdrawal_fee_currency_code": "USDT",
        //             "withdrawal_fee_const": 0.002,
        //             "withdrawal_fee_percent": 0,
        //             "block_explorer_url": "https://omniexplorer.info/search/",
        //             "withdrawal_additional_field_name": ""
        //         }],
        //         "coin_info": {
        //             "twitter": "https://twitter.com/btc",
        //             "version": "",
        //             "facebook": "https://www.facebook.com/bitcoins",
        //             "telegram": "",
        //             "icon_large": "https://app-coin-images.stex.com/large/btc.png",
        //             "icon_small": "https://app-coin-images.stex.com/small/btc.png",
        //             "description": "Bitcoin is the first successful internet money based on peer-to-peer technology;....",
        //             "official_site": "http://www.bitcoin.org",
        //             "official_block_explorer": "https://blockchair.com/bitcoin/"
        //         },
        //         "rates": {
        //             "BTC": 0.000001
        //         }
        //     }
        //
        object currencyId = this.safeString(transfer, "currency_id");
        object code = null;
        if (isTrue(((Dictionary<string,object>)this.currencies_by_id).ContainsKey(toStringOrNull(currencyId))))
        {
            currency = getValue(this.currencies_by_id, currencyId);
        } else
        {
            code = this.commonCurrencyCode(this.safeString(transfer, "currency_code"));
        }
        if (isTrue(isEqual(code, null)))
        {
            code = this.safeValue(currency, "code");
        }
        return new Dictionary<string, object>() {
            { "info", transfer },
            { "id", this.safeString(transfer, "id") },
            { "timestamp", null },
            { "datetime", null },
            { "currency", code },
            { "amount", null },
            { "fromAccount", null },
            { "toAccount", null },
            { "status", null },
        };
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name stex#withdraw
        * @description make a withdrawal
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string|undefined} tag
        * @param {object} params extra parameters specific to the stex api endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((List<object>)tagparametersVariable)[0];
        parameters = ((List<object>)tagparametersVariable)[1];
        this.checkAddress(address);
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "currency_id", getValue(currency, "id") },
            { "amount", parseFloat(this.currencyToPrecision(code, amount)) },
            { "address", address },
        };
        if (isTrue(!isEqual(tag, null)))
        {
            ((Dictionary<string, object>)request)["additional_address_parameter"] = tag;
        }
        object networks = this.safeValue(this.options, "networks", new Dictionary<string, object>() {});
        object networkRaw = this.safeStringUpper(parameters, "network"); // this line allows the user to specify either ERC20 or ETH
        object network = this.safeInteger(networks, networkRaw, this.parseToInt(networkRaw)); // handle ERC20>ETH alias
        if (isTrue(!isEqual(network, null)))
        {
            ((Dictionary<string, object>)request)["protocol_id"] = network;
            parameters = this.omit(parameters, "network");
        }
        object response = await this.profilePostWithdraw(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "id": 65899,
        //             "amount": "0.00600000",
        //             "currency_id": 1,
        //             "currency_code": "BTC",
        //             "fee": "0.00400000",
        //             "fee_currency_id": 1,
        //             "fee_currency_code": "BTC",
        //             "withdrawal_status_id": 1,
        //             "status": "Not Confirmed",
        //             "status_color": "#BC3D51",
        //             "created_at": "2019-01-21 09:36:05",
        //             "created_ts": "1548063365",
        //             "updated_at": "2019-01-21 09:36:05",
        //             "updated_ts": "1548063365",
        //             "txid": null,
        //             "protocol_id": 0,
        //             "withdrawal_address": {
        //                 "address": "0X12WERTYUIIJHGFVBNMJHGDFGHJ765SDFGHJ",
        //                 "address_name": "Address",
        //                 "additional_address_parameter": "qwertyuiopasdfghjkl",
        //                 "additional_address_parameter_name": "Destination Tag",
        //                 "notification": "",
        //                 "protocol_id": 10,
        //                 "protocol_name": "Tether OMNI",
        //                 "supports_new_address_creation": false
        //             }
        //         }
        //     }
        //
        object data = this.safeValue(response, "data", new Dictionary<string, object>() {});
        return this.parseTransaction(data, currency);
    }

    public async override Task<object> fetchTransactionFees(object codes = null, object parameters = null)
    {
        /**
        * @method
        * @name stex#fetchTransactionFees
        * @description *DEPRECATED* please use fetchDepositWithdrawFees instead
        * @see https://apidocs.stex.com/#tag/Public/paths/~1public~1currencies/get
        * @param {[string]|undefined} codes list of unified currency codes
        * @param {object} params extra parameters specific to the stex api endpoint
        * @returns {object} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        //
        //     {
        //         "success": true,
        //         "data": [
        //             {
        //                 "id": 1,
        //                 "code": "BTC",
        //                 "name": "Bitcoin",
        //                 "active": true,
        //                 "delisted": false,
        //                 "precision": 8,
        //                 "minimum_tx_confirmations": 24,
        //                 "minimum_withdrawal_amount": "0.009",
        //                 "minimum_deposit_amount": "0.000003",
        //                 "deposit_fee_currency_id": 1,
        //                 "deposit_fee_currency_code": "ETH",
        //                 "deposit_fee_const": "0.00001",
        //                 "deposit_fee_percent": "0",
        //                 "withdrawal_fee_currency_id": 1,
        //                 "withdrawal_fee_currency_code": "ETH",
        //                 "withdrawal_fee_const": "0.0015",
        //                 "withdrawal_fee_percent": "0",
        //                 "withdrawal_limit": "string",
        //                 "block_explorer_url": "https://blockchain.info/tx/",
        //                 "protocol_specific_settings": [
        //                     {
        //                         "protocol_name": "Tether OMNI",
        //                         "protocol_id": 10,
        //                         "active": true,
        //                         "withdrawal_fee_currency_id": 1,
        //                         "withdrawal_fee_const": 0.002,
        //                         "withdrawal_fee_percent": 0,
        //                         "block_explorer_url": "https://omniexplorer.info/search/"
        //                     }
        //                 ]
        //             }
        //         ]
        //     }
        //
        object currencyKeys = new List<object>(((Dictionary<string,object>)this.currencies).Keys);
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(currencyKeys)); postFixIncrement(ref i))
        {
            object code = getValue(currencyKeys, i);
            object currency = getValue(this.currencies, code);
            if (isTrue(isTrue(!isEqual(codes, null)) && !isTrue(this.inArray(code, codes))))
            {

            }
            object info = this.safeValue(currency, "info");
            ((Dictionary<string, object>)result)[(string)code] = new Dictionary<string, object>() {
                { "withdraw", this.safeNumber(currency, "fee") },
                { "deposit", this.safeNumber(info, "deposit_fee_const") },
                { "info", info },
            };
        }
        return result;
    }

    public async override Task<object> fetchDepositWithdrawFees(object codes = null, object parameters = null)
    {
        /**
        * @method
        * @name stex#fetchDepositWithdrawFees
        * @description fetch deposit and withdraw fees
        * @see https://apidocs.stex.com/#tag/Public/paths/~1public~1currencies/get
        * @param {[string]|undefined} codes list of unified currency codes
        * @param {object} params extra parameters specific to the stex api endpoint
        * @returns {object} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.publicGetCurrencies(parameters);
        //
        //     {
        //         "success": true,
        //         "data": [
        //             {
        //                 "id": 1,
        //                 "code": "BTC",
        //                 "name": "Bitcoin",
        //                 "active": true,
        //                 "delisted": false,
        //                 "precision": 8,
        //                 "minimum_tx_confirmations": 24,
        //                 "minimum_withdrawal_amount": "0.009",
        //                 "minimum_deposit_amount": "0.000003",
        //                 "deposit_fee_currency_id": 1,
        //                 "deposit_fee_currency_code": "ETH",
        //                 "deposit_fee_const": "0.00001",
        //                 "deposit_fee_percent": "0",
        //                 "withdrawal_fee_currency_id": 1,
        //                 "withdrawal_fee_currency_code": "ETH",
        //                 "withdrawal_fee_const": "0.0015",
        //                 "withdrawal_fee_percent": "0",
        //                 "withdrawal_limit": "string",
        //                 "block_explorer_url": "https://blockchain.info/tx/",
        //                 "protocol_specific_settings": [
        //                     {
        //                         "protocol_name": "Tether OMNI",
        //                         "protocol_id": 10,
        //                         "active": true,
        //                         "withdrawal_fee_currency_id": 1,
        //                         "withdrawal_fee_const": 0.002,
        //                         "withdrawal_fee_percent": 0,
        //                         "block_explorer_url": "https://omniexplorer.info/search/"
        //                     }
        //                 ]
        //             }
        //             ...
        //         ]
        //     }
        //
        object data = this.safeValue(response, "data");
        return this.parseDepositWithdrawFees(data, codes, "code");
    }

    public override object parseDepositWithdrawFee(object fee, object currency = null)
    {
        //
        //    {
        //        "id": 1,
        //        "code": "BTC",
        //        "name": "Bitcoin",
        //        "active": true,
        //        "delisted": false,
        //        "precision": 8,
        //        "minimum_tx_confirmations": 24,
        //        "minimum_withdrawal_amount": "0.009",
        //        "minimum_deposit_amount": "0.000003",
        //        "deposit_fee_currency_id": 1,
        //        "deposit_fee_currency_code": "ETH",
        //        "deposit_fee_const": "0.00001",
        //        "deposit_fee_percent": "0",
        //        "withdrawal_fee_currency_id": 1,
        //        "withdrawal_fee_currency_code": "ETH",
        //        "withdrawal_fee_const": "0.0015",
        //        "withdrawal_fee_percent": "0",
        //        "withdrawal_limit": "string",
        //        "block_explorer_url": "https://blockchain.info/tx/",
        //        "protocol_specific_settings": [
        //            {
        //                "protocol_name": "Tether OMNI",
        //                "protocol_id": 10,
        //                "active": true,
        //                "withdrawal_fee_currency_id": 1,
        //                "withdrawal_fee_const": 0.002,
        //                "withdrawal_fee_percent": 0,
        //                "block_explorer_url": "https://omniexplorer.info/search/"
        //            }
        //        ]
        //    }
        //
        object result = new Dictionary<string, object>() {
            { "withdraw", new Dictionary<string, object>() {
                { "fee", this.safeNumber(fee, "withdrawal_fee_const") },
                { "percentage", false },
            } },
            { "deposit", new Dictionary<string, object>() {
                { "fee", this.safeNumber(fee, "deposit_fee_const") },
                { "percentage", false },
            } },
            { "networks", new Dictionary<string, object>() {} },
        };
        object networks = this.safeValue(fee, "protocol_specific_settings", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(networks)); postFixIncrement(ref i))
        {
            object network = getValue(networks, i);
            object networkId = this.safeString(network, "protocol_name");
            object networkCode = this.networkIdToCode(networkId);
            ((Dictionary<string, object>)getValue(result, "networks"))[(string)networkCode] = new Dictionary<string, object>() {
                { "withdraw", new Dictionary<string, object>() {
                    { "fee", this.safeNumber(network, "withdrawal_fee_const") },
                    { "percentage", false },
                } },
                { "deposit", new Dictionary<string, object>() {
                    { "fee", null },
                    { "percentage", null },
                } },
            };
        }
        return result;
    }

    public override object handleErrors(object httpCode, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;  // fallback to default error handler
        }
        //
        //     {"success":false,"message":"Wrong parameters","errors":{"candleType":["Invalid Candle Type!"]}}
        //     {"success":false,"message":"Wrong parameters","errors":{"time":["timeStart or timeEnd is less then 1"]}}
        //     {"success":false,"message":"Not enough  ETH"}
        //
        object success = this.safeValue(response, "success", false);
        if (!isTrue(success))
        {
            object message = this.safeString(response, "message");
            object feedback = add(add(this.id, " "), body);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), message, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }
}
