using ccxt;
namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

partial class binance : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "binance" },
            { "name", "Binance" },
            { "countries", new List<object>() {"JP", "MT"} },
            { "rateLimit", 50 },
            { "certified", true },
            { "pro", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", true },
                { "swap", true },
                { "future", true },
                { "option", null },
                { "addMargin", true },
                { "borrowMargin", true },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "cancelOrders", null },
                { "createDepositAddress", false },
                { "createOrder", true },
                { "createPostOnlyOrder", true },
                { "createReduceOnlyOrder", true },
                { "createStopLimitOrder", true },
                { "createStopMarketOrder", false },
                { "createStopOrder", true },
                { "editOrder", true },
                { "fetchAccounts", null },
                { "fetchBalance", true },
                { "fetchBidsAsks", true },
                { "fetchBorrowInterest", true },
                { "fetchBorrowRate", true },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", true },
                { "fetchBorrowRates", false },
                { "fetchBorrowRatesPerSymbol", false },
                { "fetchCanceledOrders", false },
                { "fetchClosedOrder", false },
                { "fetchClosedOrders", "emulated" },
                { "fetchCurrencies", true },
                { "fetchDeposit", false },
                { "fetchDepositAddress", true },
                { "fetchDepositAddresses", false },
                { "fetchDepositAddressesByNetwork", false },
                { "fetchDeposits", true },
                { "fetchDepositWithdrawFee", "emulated" },
                { "fetchDepositWithdrawFees", true },
                { "fetchFundingHistory", true },
                { "fetchFundingRate", true },
                { "fetchFundingRateHistory", true },
                { "fetchFundingRates", true },
                { "fetchIndexOHLCV", true },
                { "fetchL3OrderBook", null },
                { "fetchLastPrices", true },
                { "fetchLedger", true },
                { "fetchLeverage", false },
                { "fetchLeverageTiers", true },
                { "fetchMarketLeverageTiers", "emulated" },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", true },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterest", true },
                { "fetchOpenInterestHistory", true },
                { "fetchOpenOrder", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrderBooks", false },
                { "fetchOrders", true },
                { "fetchOrderTrades", true },
                { "fetchPosition", null },
                { "fetchPositions", true },
                { "fetchPositionsRisk", true },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchSettlementHistory", true },
                { "fetchStatus", true },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTradingFee", true },
                { "fetchTradingFees", true },
                { "fetchTradingLimits", null },
                { "fetchTransactionFee", null },
                { "fetchTransactionFees", true },
                { "fetchTransactions", false },
                { "fetchTransfers", true },
                { "fetchWithdrawal", false },
                { "fetchWithdrawals", true },
                { "fetchWithdrawalWhitelist", false },
                { "reduceMargin", true },
                { "repayMargin", true },
                { "setLeverage", true },
                { "setMargin", false },
                { "setMarginMode", true },
                { "setPositionMode", true },
                { "signIn", false },
                { "transfer", true },
                { "withdraw", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1s", "1s" },
                { "1m", "1m" },
                { "3m", "3m" },
                { "5m", "5m" },
                { "15m", "15m" },
                { "30m", "30m" },
                { "1h", "1h" },
                { "2h", "2h" },
                { "4h", "4h" },
                { "6h", "6h" },
                { "8h", "8h" },
                { "12h", "12h" },
                { "1d", "1d" },
                { "3d", "3d" },
                { "1w", "1w" },
                { "1M", "1M" },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/1294454/29604020-d5483cdc-87ee-11e7-94c7-d1a8d9169293.jpg" },
                { "test", new Dictionary<string, object>() {
                    { "dapiPublic", "https://testnet.binancefuture.com/dapi/v1" },
                    { "dapiPrivate", "https://testnet.binancefuture.com/dapi/v1" },
                    { "dapiPrivateV2", "https://testnet.binancefuture.com/dapi/v2" },
                    { "fapiPublic", "https://testnet.binancefuture.com/fapi/v1" },
                    { "fapiPrivate", "https://testnet.binancefuture.com/fapi/v1" },
                    { "fapiPrivateV2", "https://testnet.binancefuture.com/fapi/v2" },
                    { "public", "https://testnet.binance.vision/api/v3" },
                    { "private", "https://testnet.binance.vision/api/v3" },
                    { "v1", "https://testnet.binance.vision/api/v1" },
                } },
                { "api", new Dictionary<string, object>() {
                    { "wapi", "https://api.binance.com/wapi/v3" },
                    { "sapi", "https://api.binance.com/sapi/v1" },
                    { "sapiV2", "https://api.binance.com/sapi/v2" },
                    { "sapiV3", "https://api.binance.com/sapi/v3" },
                    { "sapiV4", "https://api.binance.com/sapi/v4" },
                    { "dapiPublic", "https://dapi.binance.com/dapi/v1" },
                    { "dapiPrivate", "https://dapi.binance.com/dapi/v1" },
                    { "eapiPublic", "https://eapi.binance.com/eapi/v1" },
                    { "eapiPrivate", "https://eapi.binance.com/eapi/v1" },
                    { "dapiPrivateV2", "https://dapi.binance.com/dapi/v2" },
                    { "dapiData", "https://dapi.binance.com/futures/data" },
                    { "fapiPublic", "https://fapi.binance.com/fapi/v1" },
                    { "fapiPrivate", "https://fapi.binance.com/fapi/v1" },
                    { "fapiData", "https://fapi.binance.com/futures/data" },
                    { "fapiPrivateV2", "https://fapi.binance.com/fapi/v2" },
                    { "public", "https://api.binance.com/api/v3" },
                    { "private", "https://api.binance.com/api/v3" },
                    { "v1", "https://api.binance.com/api/v1" },
                } },
                { "www", "https://www.binance.com" },
                { "referral", new Dictionary<string, object>() {
                    { "url", "https://accounts.binance.com/en/register?ref=D7YA7CLY" },
                    { "discount", 0.1 },
                } },
                { "doc", new List<object>() {"https://binance-docs.github.io/apidocs/spot/en"} },
                { "api_management", "https://www.binance.com/en/usercenter/settings/api-management" },
                { "fees", "https://www.binance.com/en/fee/schedule" },
            } },
            { "api", new Dictionary<string, object>() {
                { "sapi", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "system/status", 0.1 },
                        { "accountSnapshot", 240 },
                        { "margin/asset", 1 },
                        { "margin/pair", 1 },
                        { "margin/allAssets", 0.1 },
                        { "margin/allPairs", 0.1 },
                        { "margin/priceIndex", 1 },
                        { "asset/assetDividend", 1 },
                        { "asset/dribblet", 0.1 },
                        { "asset/transfer", 0.1 },
                        { "asset/assetDetail", 0.1 },
                        { "asset/tradeFee", 0.1 },
                        { "asset/ledger-transfer/cloud-mining/queryByPage", 4 },
                        { "asset/convert-transfer/queryByPage", 0.033335 },
                        { "margin/loan", 1 },
                        { "margin/repay", 1 },
                        { "margin/account", 1 },
                        { "margin/transfer", 0.1 },
                        { "margin/interestHistory", 0.1 },
                        { "margin/forceLiquidationRec", 0.1 },
                        { "margin/order", 1 },
                        { "margin/openOrders", 1 },
                        { "margin/allOrders", 20 },
                        { "margin/myTrades", 1 },
                        { "margin/maxBorrowable", 5 },
                        { "margin/maxTransferable", 5 },
                        { "margin/tradeCoeff", 1 },
                        { "margin/isolated/transfer", 0.1 },
                        { "margin/isolated/account", 1 },
                        { "margin/isolated/pair", 1 },
                        { "margin/isolated/allPairs", 1 },
                        { "margin/isolated/accountLimit", 0.1 },
                        { "margin/interestRateHistory", 0.1 },
                        { "margin/orderList", 1 },
                        { "margin/allOrderList", 20 },
                        { "margin/openOrderList", 1 },
                        { "margin/crossMarginData", new Dictionary<string, object>() {
                            { "cost", 0.1 },
                            { "noCoin", 0.5 },
                        } },
                        { "margin/isolatedMarginData", new Dictionary<string, object>() {
                            { "cost", 0.1 },
                            { "noCoin", 1 },
                        } },
                        { "margin/isolatedMarginTier", 0.1 },
                        { "margin/rateLimit/order", 2 },
                        { "margin/dribblet", 0.1 },
                        { "margin/crossMarginCollateralRatio", 10 },
                        { "margin/exchange-small-liability", 0.6667 },
                        { "margin/exchange-small-liability-history", 0.6667 },
                        { "margin/next-hourly-interest-rate", 0.6667 },
                        { "loan/income", 40 },
                        { "loan/ongoing/orders", 40 },
                        { "loan/ltv/adjustment/history", 40 },
                        { "loan/borrow/history", 40 },
                        { "loan/repay/history", 40 },
                        { "loan/loanable/data", 40 },
                        { "loan/collateral/data", 40 },
                        { "loan/repay/collateral/rate", 600 },
                        { "loan/vip/ongoing/orders", 40 },
                        { "loan/vip/repay/history", 40 },
                        { "loan/vip/collateral/account", 600 },
                        { "fiat/orders", 600.03 },
                        { "fiat/payments", 0.1 },
                        { "futures/transfer", 1 },
                        { "futures/loan/borrow/history", 1 },
                        { "futures/loan/repay/history", 1 },
                        { "futures/loan/wallet", 1 },
                        { "futures/loan/adjustCollateral/history", 1 },
                        { "futures/loan/liquidationHistory", 1 },
                        { "rebate/taxQuery", 20.001 },
                        { "capital/config/getall", 1 },
                        { "capital/deposit/address", 1 },
                        { "capital/deposit/hisrec", 0.1 },
                        { "capital/deposit/subAddress", 0.1 },
                        { "capital/deposit/subHisrec", 0.1 },
                        { "capital/withdraw/history", 0.1 },
                        { "capital/contract/convertible-coins", 4.0002 },
                        { "convert/tradeFlow", 0.6667 },
                        { "convert/exchangeInfo", 50 },
                        { "convert/assetInfo", 10 },
                        { "convert/orderStatus", 0.6667 },
                        { "account/status", 0.1 },
                        { "account/apiTradingStatus", 0.1 },
                        { "account/apiRestrictions/ipRestriction", 0.1 },
                        { "bnbBurn", 0.1 },
                        { "sub-account/futures/account", 1 },
                        { "sub-account/futures/accountSummary", 0.1 },
                        { "sub-account/futures/positionRisk", 1 },
                        { "sub-account/futures/internalTransfer", 0.1 },
                        { "sub-account/list", 0.1 },
                        { "sub-account/margin/account", 1 },
                        { "sub-account/margin/accountSummary", 1 },
                        { "sub-account/spotSummary", 0.1 },
                        { "sub-account/status", 1 },
                        { "sub-account/sub/transfer/history", 0.1 },
                        { "sub-account/transfer/subUserHistory", 0.1 },
                        { "sub-account/universalTransfer", 0.1 },
                        { "sub-account/apiRestrictions/ipRestriction/thirdPartyList", 1 },
                        { "sub-account/transaction-tatistics", 0.4 },
                        { "managed-subaccount/asset", 0.1 },
                        { "managed-subaccount/accountSnapshot", 240 },
                        { "managed-subaccount/queryTransLogForInvestor", 0.1 },
                        { "managed-subaccount/queryTransLogForTradeParent", 0.1 },
                        { "managed-subaccount/fetch-future-asset", 0.1 },
                        { "managed-subaccount/marginAsset", 0.1 },
                        { "managed-subaccount/info", 0.4 },
                        { "lending/daily/product/list", 0.1 },
                        { "lending/daily/userLeftQuota", 0.1 },
                        { "lending/daily/userRedemptionQuota", 0.1 },
                        { "lending/daily/token/position", 0.1 },
                        { "lending/union/account", 0.1 },
                        { "lending/union/purchaseRecord", 0.1 },
                        { "lending/union/redemptionRecord", 0.1 },
                        { "lending/union/interestHistory", 0.1 },
                        { "lending/project/list", 0.1 },
                        { "lending/project/position/list", 0.1 },
                        { "mining/pub/algoList", 0.1 },
                        { "mining/pub/coinList", 0.1 },
                        { "mining/worker/detail", 0.5 },
                        { "mining/worker/list", 0.5 },
                        { "mining/payment/list", 0.5 },
                        { "mining/statistics/user/status", 0.5 },
                        { "mining/statistics/user/list", 0.5 },
                        { "mining/payment/uid", 0.5 },
                        { "bswap/pools", 0.1 },
                        { "bswap/liquidity", new Dictionary<string, object>() {
                            { "cost", 0.1 },
                            { "noPoolId", 1 },
                        } },
                        { "bswap/liquidityOps", 20.001 },
                        { "bswap/quote", 1.00005 },
                        { "bswap/swap", 20.001 },
                        { "bswap/poolConfigure", 1.00005 },
                        { "bswap/addLiquidityPreview", 1.00005 },
                        { "bswap/removeLiquidityPreview", 1.00005 },
                        { "bswap/unclaimedRewards", 6.667 },
                        { "bswap/claimedHistory", 6.667 },
                        { "blvt/tokenInfo", 0.1 },
                        { "blvt/subscribe/record", 0.1 },
                        { "blvt/redeem/record", 0.1 },
                        { "blvt/userLimit", 0.1 },
                        { "apiReferral/ifNewUser", 1 },
                        { "apiReferral/customization", 1 },
                        { "apiReferral/userCustomization", 1 },
                        { "apiReferral/rebate/recentRecord", 1 },
                        { "apiReferral/rebate/historicalRecord", 1 },
                        { "apiReferral/kickback/recentRecord", 1 },
                        { "apiReferral/kickback/historicalRecord", 1 },
                        { "broker/subAccountApi", 1 },
                        { "broker/subAccount", 1 },
                        { "broker/subAccountApi/commission/futures", 1 },
                        { "broker/subAccountApi/commission/coinFutures", 1 },
                        { "broker/info", 1 },
                        { "broker/transfer", 1 },
                        { "broker/transfer/futures", 1 },
                        { "broker/rebate/recentRecord", 1 },
                        { "broker/rebate/historicalRecord", 1 },
                        { "broker/subAccount/bnbBurn/status", 1 },
                        { "broker/subAccount/depositHist", 1 },
                        { "broker/subAccount/spotSummary", 1 },
                        { "broker/subAccount/marginSummary", 1 },
                        { "broker/subAccount/futuresSummary", 1 },
                        { "broker/rebate/futures/recentRecord", 1 },
                        { "broker/subAccountApi/ipRestriction", 1 },
                        { "broker/universalTransfer", 1 },
                        { "account/apiRestrictions", 0.1 },
                        { "c2c/orderMatch/listUserOrderHistory", 0.1 },
                        { "nft/history/transactions", 20.001 },
                        { "nft/history/deposit", 20.001 },
                        { "nft/history/withdraw", 20.001 },
                        { "nft/user/getAsset", 20.001 },
                        { "pay/transactions", 20.001 },
                        { "giftcard/verify", 0.1 },
                        { "giftcard/cryptography/rsa-public-key", 0.1 },
                        { "giftcard/buyCode/token-limit", 0.1 },
                        { "algo/futures/openOrders", 0.1 },
                        { "algo/futures/historicalOrders", 0.1 },
                        { "algo/futures/subOrders", 0.1 },
                        { "portfolio/account", 0.1 },
                        { "portfolio/collateralRate", 5 },
                        { "portfolio/pmLoan", 3.3335 },
                        { "portfolio/interest-history", 0.6667 },
                        { "portfolio/interest-rate", 0.6667 },
                        { "staking/productList", 0.1 },
                        { "staking/position", 0.1 },
                        { "staking/stakingRecord", 0.1 },
                        { "staking/personalLeftQuota", 0.1 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "asset/dust", 1 },
                        { "asset/dust-btc", 0.1 },
                        { "asset/transfer", 0.1 },
                        { "asset/get-funding-asset", 0.1 },
                        { "asset/convert-transfer", 0.033335 },
                        { "account/disableFastWithdrawSwitch", 0.1 },
                        { "account/enableFastWithdrawSwitch", 0.1 },
                        { "capital/withdraw/apply", 4.0002 },
                        { "capital/contract/convertible-coins", 4.0002 },
                        { "margin/transfer", 1 },
                        { "margin/loan", 20.001 },
                        { "margin/repay", 20.001 },
                        { "margin/order", 0.040002 },
                        { "margin/order/oco", 0.040002 },
                        { "margin/exchange-small-liability", 20.001 },
                        { "margin/isolated/transfer", 4.0002 },
                        { "margin/isolated/account", 2.0001 },
                        { "bnbBurn", 0.1 },
                        { "sub-account/virtualSubAccount", 0.1 },
                        { "sub-account/margin/transfer", 4.0002 },
                        { "sub-account/margin/enable", 0.1 },
                        { "sub-account/futures/enable", 0.1 },
                        { "sub-account/futures/transfer", 0.1 },
                        { "sub-account/futures/internalTransfer", 0.1 },
                        { "sub-account/transfer/subToSub", 0.1 },
                        { "sub-account/transfer/subToMaster", 0.1 },
                        { "sub-account/universalTransfer", 0.1 },
                        { "managed-subaccount/deposit", 0.1 },
                        { "managed-subaccount/withdraw", 0.1 },
                        { "userDataStream", 0.1 },
                        { "userDataStream/isolated", 0.1 },
                        { "futures/transfer", 0.1 },
                        { "lending/customizedFixed/purchase", 0.1 },
                        { "lending/daily/purchase", 0.1 },
                        { "lending/daily/redeem", 0.1 },
                        { "bswap/liquidityAdd", 60 },
                        { "bswap/liquidityRemove", 60 },
                        { "bswap/swap", 60 },
                        { "bswap/claimRewards", 6.667 },
                        { "blvt/subscribe", 0.1 },
                        { "blvt/redeem", 0.1 },
                        { "apiReferral/customization", 1 },
                        { "apiReferral/userCustomization", 1 },
                        { "apiReferral/rebate/historicalRecord", 1 },
                        { "apiReferral/kickback/historicalRecord", 1 },
                        { "broker/subAccount", 1 },
                        { "broker/subAccount/margin", 1 },
                        { "broker/subAccount/futures", 1 },
                        { "broker/subAccountApi", 1 },
                        { "broker/subAccountApi/permission", 1 },
                        { "broker/subAccountApi/commission", 1 },
                        { "broker/subAccountApi/commission/futures", 1 },
                        { "broker/subAccountApi/commission/coinFutures", 1 },
                        { "broker/transfer", 1 },
                        { "broker/transfer/futures", 1 },
                        { "broker/rebate/historicalRecord", 1 },
                        { "broker/subAccount/bnbBurn/spot", 1 },
                        { "broker/subAccount/bnbBurn/marginInterest", 1 },
                        { "broker/subAccount/blvt", 1 },
                        { "broker/subAccountApi/ipRestriction", 1 },
                        { "broker/subAccountApi/ipRestriction/ipList", 1 },
                        { "broker/universalTransfer", 1 },
                        { "broker/subAccountApi/permission/universalTransfer", 1 },
                        { "broker/subAccountApi/permission/vanillaOptions", 1 },
                        { "giftcard/createCode", 0.1 },
                        { "giftcard/redeemCode", 0.1 },
                        { "giftcard/buyCode", 0.1 },
                        { "algo/futures/newOrderVp", 20.001 },
                        { "algo/futures/newOrderTwap", 20.001 },
                        { "staking/purchase", 0.1 },
                        { "staking/redeem", 0.1 },
                        { "staking/setAutoStaking", 0.1 },
                        { "portfolio/repay", 20.001 },
                        { "loan/borrow", 40 },
                        { "loan/repay", 40 },
                        { "loan/adjust/ltv", 40 },
                        { "loan/customize/margin_call", 40 },
                        { "loan/vip/repay", 40 },
                        { "convert/getQuote", 20.001 },
                        { "convert/acceptQuote", 3.3335 },
                    } },
                    { "put", new Dictionary<string, object>() {
                        { "userDataStream", 0.1 },
                        { "userDataStream/isolated", 0.1 },
                    } },
                    { "delete", new Dictionary<string, object>() {
                        { "margin/openOrders", 0.1 },
                        { "margin/order", 0.0066667 },
                        { "margin/orderList", 0.0066667 },
                        { "margin/isolated/account", 2.0001 },
                        { "userDataStream", 0.1 },
                        { "userDataStream/isolated", 0.1 },
                        { "broker/subAccountApi", 1 },
                        { "broker/subAccountApi/ipRestriction/ipList", 1 },
                        { "algo/futures/order", 0.1 },
                    } },
                } },
                { "sapiV2", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "sub-account/futures/account", 0.1 },
                        { "sub-account/futures/positionRisk", 0.1 },
                    } },
                } },
                { "sapiV3", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "sub-account/assets", 1 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "asset/getUserAsset", 0.5 },
                    } },
                } },
                { "sapiV4", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "sub-account/assets", 1 },
                    } },
                } },
                { "wapi", new Dictionary<string, object>() {
                    { "post", new Dictionary<string, object>() {
                        { "withdraw", 1 },
                        { "sub-account/transfer", 1 },
                    } },
                    { "get", new Dictionary<string, object>() {
                        { "depositHistory", 1 },
                        { "withdrawHistory", 1 },
                        { "depositAddress", 1 },
                        { "accountStatus", 1 },
                        { "systemStatus", 1 },
                        { "apiTradingStatus", 1 },
                        { "userAssetDribbletLog", 1 },
                        { "tradeFee", 1 },
                        { "assetDetail", 1 },
                        { "sub-account/list", 1 },
                        { "sub-account/transfer/history", 1 },
                        { "sub-account/assets", 1 },
                    } },
                } },
                { "dapiPublic", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "ping", 1 },
                        { "time", 1 },
                        { "exchangeInfo", 1 },
                        { "depth", new Dictionary<string, object>() {
                            { "cost", 2 },
                            { "byLimit", new List<object>() {new List<object>() {50, 2}, new List<object>() {100, 5}, new List<object>() {500, 10}, new List<object>() {1000, 20}} },
                        } },
                        { "trades", 5 },
                        { "historicalTrades", 20 },
                        { "aggTrades", 20 },
                        { "premiumIndex", 10 },
                        { "fundingRate", 1 },
                        { "klines", new Dictionary<string, object>() {
                            { "cost", 1 },
                            { "byLimit", new List<object>() {new List<object>() {99, 1}, new List<object>() {499, 2}, new List<object>() {1000, 5}, new List<object>() {10000, 10}} },
                        } },
                        { "continuousKlines", new Dictionary<string, object>() {
                            { "cost", 1 },
                            { "byLimit", new List<object>() {new List<object>() {99, 1}, new List<object>() {499, 2}, new List<object>() {1000, 5}, new List<object>() {10000, 10}} },
                        } },
                        { "indexPriceKlines", new Dictionary<string, object>() {
                            { "cost", 1 },
                            { "byLimit", new List<object>() {new List<object>() {99, 1}, new List<object>() {499, 2}, new List<object>() {1000, 5}, new List<object>() {10000, 10}} },
                        } },
                        { "markPriceKlines", new Dictionary<string, object>() {
                            { "cost", 1 },
                            { "byLimit", new List<object>() {new List<object>() {99, 1}, new List<object>() {499, 2}, new List<object>() {1000, 5}, new List<object>() {10000, 10}} },
                        } },
                        { "ticker/24hr", new Dictionary<string, object>() {
                            { "cost", 1 },
                            { "noSymbol", 40 },
                        } },
                        { "ticker/price", new Dictionary<string, object>() {
                            { "cost", 1 },
                            { "noSymbol", 2 },
                        } },
                        { "ticker/bookTicker", new Dictionary<string, object>() {
                            { "cost", 1 },
                            { "noSymbol", 2 },
                        } },
                        { "openInterest", 1 },
                        { "pmExchangeInfo", 1 },
                    } },
                } },
                { "dapiData", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "openInterestHist", 1 },
                        { "topLongShortAccountRatio", 1 },
                        { "topLongShortPositionRatio", 1 },
                        { "globalLongShortAccountRatio", 1 },
                        { "takerBuySellVol", 1 },
                        { "basis", 1 },
                    } },
                } },
                { "dapiPrivate", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "positionSide/dual", 30 },
                        { "order", 1 },
                        { "openOrder", 1 },
                        { "openOrders", new Dictionary<string, object>() {
                            { "cost", 1 },
                            { "noSymbol", 5 },
                        } },
                        { "allOrders", new Dictionary<string, object>() {
                            { "cost", 20 },
                            { "noSymbol", 40 },
                        } },
                        { "balance", 1 },
                        { "account", 5 },
                        { "positionMargin/history", 1 },
                        { "positionRisk", 1 },
                        { "userTrades", new Dictionary<string, object>() {
                            { "cost", 20 },
                            { "noSymbol", 40 },
                        } },
                        { "income", 20 },
                        { "leverageBracket", 1 },
                        { "forceOrders", new Dictionary<string, object>() {
                            { "cost", 20 },
                            { "noSymbol", 50 },
                        } },
                        { "adlQuantile", 5 },
                        { "orderAmendment", 1 },
                        { "pmAccountInfo", 5 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "positionSide/dual", 1 },
                        { "order", 4 },
                        { "batchOrders", 5 },
                        { "countdownCancelAll", 10 },
                        { "leverage", 1 },
                        { "marginType", 1 },
                        { "positionMargin", 1 },
                        { "listenKey", 1 },
                    } },
                    { "put", new Dictionary<string, object>() {
                        { "listenKey", 1 },
                        { "order", 1 },
                        { "batchOrders", 5 },
                    } },
                    { "delete", new Dictionary<string, object>() {
                        { "order", 1 },
                        { "allOpenOrders", 1 },
                        { "batchOrders", 5 },
                        { "listenKey", 1 },
                    } },
                } },
                { "dapiPrivateV2", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "leverageBracket", 1 },
                    } },
                } },
                { "fapiPublic", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "ping", 1 },
                        { "time", 1 },
                        { "exchangeInfo", 1 },
                        { "depth", new Dictionary<string, object>() {
                            { "cost", 2 },
                            { "byLimit", new List<object>() {new List<object>() {50, 2}, new List<object>() {100, 5}, new List<object>() {500, 10}, new List<object>() {1000, 20}} },
                        } },
                        { "trades", 5 },
                        { "historicalTrades", 20 },
                        { "aggTrades", 20 },
                        { "klines", new Dictionary<string, object>() {
                            { "cost", 1 },
                            { "byLimit", new List<object>() {new List<object>() {99, 1}, new List<object>() {499, 2}, new List<object>() {1000, 5}, new List<object>() {10000, 10}} },
                        } },
                        { "continuousKlines", new Dictionary<string, object>() {
                            { "cost", 1 },
                            { "byLimit", new List<object>() {new List<object>() {99, 1}, new List<object>() {499, 2}, new List<object>() {1000, 5}, new List<object>() {10000, 10}} },
                        } },
                        { "markPriceKlines", new Dictionary<string, object>() {
                            { "cost", 1 },
                            { "byLimit", new List<object>() {new List<object>() {99, 1}, new List<object>() {499, 2}, new List<object>() {1000, 5}, new List<object>() {10000, 10}} },
                        } },
                        { "indexPriceKlines", new Dictionary<string, object>() {
                            { "cost", 1 },
                            { "byLimit", new List<object>() {new List<object>() {99, 1}, new List<object>() {499, 2}, new List<object>() {1000, 5}, new List<object>() {10000, 10}} },
                        } },
                        { "fundingRate", 1 },
                        { "premiumIndex", 1 },
                        { "ticker/24hr", new Dictionary<string, object>() {
                            { "cost", 1 },
                            { "noSymbol", 40 },
                        } },
                        { "ticker/price", new Dictionary<string, object>() {
                            { "cost", 1 },
                            { "noSymbol", 2 },
                        } },
                        { "ticker/bookTicker", new Dictionary<string, object>() {
                            { "cost", 1 },
                            { "noSymbol", 2 },
                        } },
                        { "openInterest", 1 },
                        { "indexInfo", 1 },
                        { "apiTradingStatus", new Dictionary<string, object>() {
                            { "cost", 1 },
                            { "noSymbol", 10 },
                        } },
                        { "lvtKlines", 1 },
                        { "pmExchangeInfo", 1 },
                    } },
                } },
                { "fapiData", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "openInterestHist", 1 },
                        { "topLongShortAccountRatio", 1 },
                        { "topLongShortPositionRatio", 1 },
                        { "globalLongShortAccountRatio", 1 },
                        { "takerlongshortRatio", 1 },
                    } },
                } },
                { "fapiPrivate", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "forceOrders", new Dictionary<string, object>() {
                            { "cost", 20 },
                            { "noSymbol", 50 },
                        } },
                        { "allOrders", 5 },
                        { "openOrder", 1 },
                        { "openOrders", 1 },
                        { "order", 1 },
                        { "account", 5 },
                        { "balance", 5 },
                        { "leverageBracket", 1 },
                        { "positionMargin/history", 1 },
                        { "positionRisk", 5 },
                        { "positionSide/dual", 30 },
                        { "userTrades", 5 },
                        { "income", 30 },
                        { "commissionRate", 20 },
                        { "apiTradingStatus", 1 },
                        { "multiAssetsMargin", 30 },
                        { "apiReferral/ifNewUser", 1 },
                        { "apiReferral/customization", 1 },
                        { "apiReferral/userCustomization", 1 },
                        { "apiReferral/traderNum", 1 },
                        { "apiReferral/overview", 1 },
                        { "apiReferral/tradeVol", 1 },
                        { "apiReferral/rebateVol", 1 },
                        { "apiReferral/traderSummary", 1 },
                        { "adlQuantile", 5 },
                        { "pmAccountInfo", 5 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "batchOrders", 5 },
                        { "positionSide/dual", 1 },
                        { "positionMargin", 1 },
                        { "marginType", 1 },
                        { "order", 4 },
                        { "leverage", 1 },
                        { "listenKey", 1 },
                        { "countdownCancelAll", 10 },
                        { "multiAssetsMargin", 1 },
                        { "apiReferral/customization", 1 },
                        { "apiReferral/userCustomization", 1 },
                    } },
                    { "put", new Dictionary<string, object>() {
                        { "listenKey", 1 },
                    } },
                    { "delete", new Dictionary<string, object>() {
                        { "batchOrders", 1 },
                        { "order", 1 },
                        { "allOpenOrders", 1 },
                        { "listenKey", 1 },
                    } },
                } },
                { "fapiPrivateV2", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "account", 1 },
                        { "balance", 1 },
                        { "positionRisk", 1 },
                    } },
                } },
                { "eapiPublic", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "ping", 1 },
                        { "time", 1 },
                        { "exchangeInfo", 1 },
                        { "index", 1 },
                        { "ticker", 5 },
                        { "mark", 5 },
                        { "depth", 1 },
                        { "klines", 1 },
                        { "trades", 5 },
                        { "historicalTrades", 20 },
                        { "exerciseHistory", 3 },
                        { "openInterest", 3 },
                    } },
                } },
                { "eapiPrivate", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "account", 3 },
                        { "position", 5 },
                        { "openOrders", new Dictionary<string, object>() {
                            { "cost", 1 },
                            { "noSymbol", 40 },
                        } },
                        { "historyOrders", 3 },
                        { "userTrades", 5 },
                        { "exerciseRecord", 5 },
                        { "bill", 1 },
                        { "marginAccount", 3 },
                        { "mmp", 1 },
                        { "countdownCancelAll", 1 },
                        { "order", 1 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "order", 1 },
                        { "batchOrders", 5 },
                        { "listenKey", 1 },
                        { "mmpSet", 1 },
                        { "mmpReset", 1 },
                        { "countdownCancelAll", 1 },
                        { "countdownCancelAllHeartBeat", 10 },
                    } },
                    { "put", new Dictionary<string, object>() {
                        { "listenKey", 1 },
                    } },
                    { "delete", new Dictionary<string, object>() {
                        { "order", 1 },
                        { "batchOrders", 1 },
                        { "allOpenOrders", 1 },
                        { "allOpenOrdersByUnderlying", 1 },
                        { "listenKey", 1 },
                    } },
                } },
                { "public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "ping", 1 },
                        { "time", 1 },
                        { "depth", new Dictionary<string, object>() {
                            { "cost", 1 },
                            { "byLimit", new List<object>() {new List<object>() {100, 1}, new List<object>() {500, 5}, new List<object>() {1000, 10}, new List<object>() {5000, 50}} },
                        } },
                        { "trades", 1 },
                        { "aggTrades", 1 },
                        { "historicalTrades", 5 },
                        { "klines", 1 },
                        { "ticker/24hr", new Dictionary<string, object>() {
                            { "cost", 1 },
                            { "noSymbol", 40 },
                        } },
                        { "ticker/price", new Dictionary<string, object>() {
                            { "cost", 1 },
                            { "noSymbol", 2 },
                        } },
                        { "ticker/bookTicker", new Dictionary<string, object>() {
                            { "cost", 1 },
                            { "noSymbol", 2 },
                        } },
                        { "exchangeInfo", 10 },
                    } },
                    { "put", new Dictionary<string, object>() {
                        { "userDataStream", 1 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "userDataStream", 1 },
                    } },
                    { "delete", new Dictionary<string, object>() {
                        { "userDataStream", 1 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "allOrderList", 10 },
                        { "openOrderList", 3 },
                        { "orderList", 2 },
                        { "order", 2 },
                        { "openOrders", new Dictionary<string, object>() {
                            { "cost", 3 },
                            { "noSymbol", 40 },
                        } },
                        { "allOrders", 10 },
                        { "account", 10 },
                        { "myTrades", 10 },
                        { "rateLimit/order", 20 },
                        { "myPreventedMatches", 1 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "order/oco", 1 },
                        { "order", 1 },
                        { "order/cancelReplace", 1 },
                        { "order/test", 1 },
                    } },
                    { "delete", new Dictionary<string, object>() {
                        { "openOrders", 1 },
                        { "orderList", 1 },
                        { "order", 1 },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "feeSide", "get" },
                    { "tierBased", false },
                    { "percentage", true },
                    { "taker", this.parseNumber("0.001") },
                    { "maker", this.parseNumber("0.001") },
                } },
                { "linear", new Dictionary<string, object>() {
                    { "trading", new Dictionary<string, object>() {
                        { "feeSide", "quote" },
                        { "tierBased", true },
                        { "percentage", true },
                        { "taker", this.parseNumber("0.000400") },
                        { "maker", this.parseNumber("0.000200") },
                        { "tiers", new Dictionary<string, object>() {
                            { "taker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.000400")}, new List<object> {this.parseNumber("250"), this.parseNumber("0.000400")}, new List<object> {this.parseNumber("2500"), this.parseNumber("0.000350")}, new List<object> {this.parseNumber("7500"), this.parseNumber("0.000320")}, new List<object> {this.parseNumber("22500"), this.parseNumber("0.000300")}, new List<object> {this.parseNumber("50000"), this.parseNumber("0.000270")}, new List<object> {this.parseNumber("100000"), this.parseNumber("0.000250")}, new List<object> {this.parseNumber("200000"), this.parseNumber("0.000220")}, new List<object> {this.parseNumber("400000"), this.parseNumber("0.000200")}, new List<object> {this.parseNumber("750000"), this.parseNumber("0.000170")}} },
                            { "maker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.000200")}, new List<object> {this.parseNumber("250"), this.parseNumber("0.000160")}, new List<object> {this.parseNumber("2500"), this.parseNumber("0.000140")}, new List<object> {this.parseNumber("7500"), this.parseNumber("0.000120")}, new List<object> {this.parseNumber("22500"), this.parseNumber("0.000100")}, new List<object> {this.parseNumber("50000"), this.parseNumber("0.000080")}, new List<object> {this.parseNumber("100000"), this.parseNumber("0.000060")}, new List<object> {this.parseNumber("200000"), this.parseNumber("0.000040")}, new List<object> {this.parseNumber("400000"), this.parseNumber("0.000020")}, new List<object> {this.parseNumber("750000"), this.parseNumber("0")}} },
                        } },
                    } },
                } },
                { "inverse", new Dictionary<string, object>() {
                    { "trading", new Dictionary<string, object>() {
                        { "feeSide", "base" },
                        { "tierBased", true },
                        { "percentage", true },
                        { "taker", this.parseNumber("0.000500") },
                        { "maker", this.parseNumber("0.000100") },
                        { "tiers", new Dictionary<string, object>() {
                            { "taker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.000500")}, new List<object> {this.parseNumber("250"), this.parseNumber("0.000450")}, new List<object> {this.parseNumber("2500"), this.parseNumber("0.000400")}, new List<object> {this.parseNumber("7500"), this.parseNumber("0.000300")}, new List<object> {this.parseNumber("22500"), this.parseNumber("0.000250")}, new List<object> {this.parseNumber("50000"), this.parseNumber("0.000240")}, new List<object> {this.parseNumber("100000"), this.parseNumber("0.000240")}, new List<object> {this.parseNumber("200000"), this.parseNumber("0.000240")}, new List<object> {this.parseNumber("400000"), this.parseNumber("0.000240")}, new List<object> {this.parseNumber("750000"), this.parseNumber("0.000240")}} },
                            { "maker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.000100")}, new List<object> {this.parseNumber("250"), this.parseNumber("0.000080")}, new List<object> {this.parseNumber("2500"), this.parseNumber("0.000050")}, new List<object> {this.parseNumber("7500"), this.parseNumber("0.0000030")}, new List<object> {this.parseNumber("22500"), this.parseNumber("0")}, new List<object> {this.parseNumber("50000"), this.parseNumber("-0.000050")}, new List<object> {this.parseNumber("100000"), this.parseNumber("-0.000060")}, new List<object> {this.parseNumber("200000"), this.parseNumber("-0.000070")}, new List<object> {this.parseNumber("400000"), this.parseNumber("-0.000080")}, new List<object> {this.parseNumber("750000"), this.parseNumber("-0.000090")}} },
                        } },
                    } },
                } },
                { "option", new Dictionary<string, object>() {} },
            } },
            { "commonCurrencies", new Dictionary<string, object>() {
                { "BCC", "BCC" },
                { "YOYO", "YOYOW" },
            } },
            { "precisionMode", DECIMAL_PLACES },
            { "options", new Dictionary<string, object>() {
                { "sandboxMode", false },
                { "fetchMarkets", new List<object>() {"spot", "linear", "inverse"} },
                { "fetchCurrencies", true },
                { "defaultTimeInForce", "GTC" },
                { "defaultType", "spot" },
                { "defaultSubType", null },
                { "hasAlreadyAuthenticatedSuccessfully", false },
                { "warnOnFetchOpenOrdersWithoutSymbol", true },
                { "throwMarginModeAlreadySet", false },
                { "fetchPositions", "positionRisk" },
                { "recvWindow", multiply(10, 1000) },
                { "timeDifference", 0 },
                { "adjustForTimeDifference", false },
                { "newOrderRespType", new Dictionary<string, object>() {
                    { "market", "FULL" },
                    { "limit", "FULL" },
                } },
                { "quoteOrderQty", true },
                { "broker", new Dictionary<string, object>() {
                    { "spot", "x-R4BD3S82" },
                    { "margin", "x-R4BD3S82" },
                    { "future", "x-xcKtGhcu" },
                    { "delivery", "x-xcKtGhcu" },
                } },
                { "accountsByType", new Dictionary<string, object>() {
                    { "main", "MAIN" },
                    { "spot", "MAIN" },
                    { "funding", "FUNDING" },
                    { "margin", "MARGIN" },
                    { "cross", "MARGIN" },
                    { "future", "UMFUTURE" },
                    { "delivery", "CMFUTURE" },
                    { "linear", "UMFUTURE" },
                    { "inverse", "CMFUTURE" },
                } },
                { "accountsById", new Dictionary<string, object>() {
                    { "MAIN", "spot" },
                    { "FUNDING", "funding" },
                    { "MARGIN", "margin" },
                    { "UMFUTURE", "linear" },
                    { "CMFUTURE", "inverse" },
                } },
                { "networks", new Dictionary<string, object>() {
                    { "ERC20", "ETH" },
                    { "TRC20", "TRX" },
                    { "BEP2", "BNB" },
                    { "BEP20", "BSC" },
                    { "OMNI", "OMNI" },
                    { "EOS", "EOS" },
                    { "SPL", "SOL" },
                } },
                { "reverseNetworks", new Dictionary<string, object>() {
                    { "tronscan.org", "TRC20" },
                    { "etherscan.io", "ERC20" },
                    { "bscscan.com", "BSC" },
                    { "explorer.binance.org", "BEP2" },
                    { "bithomp.com", "XRP" },
                    { "bloks.io", "EOS" },
                    { "stellar.expert", "XLM" },
                    { "blockchair.com/bitcoin", "BTC" },
                    { "blockchair.com/bitcoin-cash", "BCH" },
                    { "blockchair.com/ecash", "XEC" },
                    { "explorer.litecoin.net", "LTC" },
                    { "explorer.avax.network", "AVAX" },
                    { "solscan.io", "SOL" },
                    { "polkadot.subscan.io", "DOT" },
                    { "dashboard.internetcomputer.org", "ICP" },
                    { "explorer.chiliz.com", "CHZ" },
                    { "cardanoscan.io", "ADA" },
                    { "mainnet.theoan.com", "AION" },
                    { "algoexplorer.io", "ALGO" },
                    { "explorer.ambrosus.com", "AMB" },
                    { "viewblock.io/zilliqa", "ZIL" },
                    { "viewblock.io/arweave", "AR" },
                    { "explorer.ark.io", "ARK" },
                    { "atomscan.com", "ATOM" },
                    { "www.mintscan.io", "CTK" },
                    { "explorer.bitcoindiamond.org", "BCD" },
                    { "btgexplorer.com", "BTG" },
                    { "bts.ai", "BTS" },
                    { "explorer.celo.org", "CELO" },
                    { "explorer.nervos.org", "CKB" },
                    { "cerebro.cortexlabs.ai", "CTXC" },
                    { "chainz.cryptoid.info", "VIA" },
                    { "explorer.dcrdata.org", "DCR" },
                    { "digiexplorer.info", "DGB" },
                    { "dock.subscan.io", "DOCK" },
                    { "dogechain.info", "DOGE" },
                    { "explorer.elrond.com", "EGLD" },
                    { "blockscout.com", "ETC" },
                    { "explore-fetchhub.fetch.ai", "FET" },
                    { "filfox.info", "FIL" },
                    { "fio.bloks.io", "FIO" },
                    { "explorer.firo.org", "FIRO" },
                    { "neoscan.io", "NEO" },
                    { "ftmscan.com", "FTM" },
                    { "explorer.gochain.io", "GO" },
                    { "block.gxb.io", "GXS" },
                    { "hash-hash.info", "HBAR" },
                    { "www.hiveblockexplorer.com", "HIVE" },
                    { "explorer.helium.com", "HNT" },
                    { "tracker.icon.foundation", "ICX" },
                    { "www.iostabc.com", "IOST" },
                    { "explorer.iota.org", "IOTA" },
                    { "iotexscan.io", "IOTX" },
                    { "irishub.iobscan.io", "IRIS" },
                    { "kava.mintscan.io", "KAVA" },
                    { "scope.klaytn.com", "KLAY" },
                    { "kmdexplorer.io", "KMD" },
                    { "kusama.subscan.io", "KSM" },
                    { "explorer.lto.network", "LTO" },
                    { "polygonscan.com", "POLYGON" },
                    { "explorer.ont.io", "ONT" },
                    { "minaexplorer.com", "MINA" },
                    { "nanolooker.com", "NANO" },
                    { "explorer.nebulas.io", "NAS" },
                    { "explorer.nbs.plus", "NBS" },
                    { "explorer.nebl.io", "NEBL" },
                    { "nulscan.io", "NULS" },
                    { "nxscan.com", "NXS" },
                    { "explorer.harmony.one", "ONE" },
                    { "explorer.poa.network", "POA" },
                    { "qtum.info", "QTUM" },
                    { "explorer.rsk.co", "RSK" },
                    { "www.oasisscan.com", "ROSE" },
                    { "ravencoin.network", "RVN" },
                    { "sc.tokenview.com", "SC" },
                    { "secretnodes.com", "SCRT" },
                    { "explorer.skycoin.com", "SKY" },
                    { "steemscan.com", "STEEM" },
                    { "explorer.stacks.co", "STX" },
                    { "www.thetascan.io", "THETA" },
                    { "scan.tomochain.com", "TOMO" },
                    { "explore.vechain.org", "VET" },
                    { "explorer.vite.net", "VITE" },
                    { "www.wanscan.org", "WAN" },
                    { "wavesexplorer.com", "WAVES" },
                    { "wax.eosx.io", "WAXP" },
                    { "waltonchain.pro", "WTC" },
                    { "chain.nem.ninja", "XEM" },
                    { "verge-blockchain.info", "XVG" },
                    { "explorer.yoyow.org", "YOYOW" },
                    { "explorer.zcha.in", "ZEC" },
                    { "explorer.zensystem.io", "ZEN" },
                } },
                { "networksById", new Dictionary<string, object>() {
                    { "tronscan.org", "TRC20" },
                    { "etherscan.io", "ERC20" },
                    { "bscscan.com", "BSC" },
                    { "explorer.binance.org", "BEP2" },
                    { "bithomp.com", "XRP" },
                    { "bloks.io", "EOS" },
                    { "stellar.expert", "XLM" },
                    { "blockchair.com/bitcoin", "BTC" },
                    { "blockchair.com/bitcoin-cash", "BCH" },
                    { "blockchair.com/ecash", "XEC" },
                    { "explorer.litecoin.net", "LTC" },
                    { "explorer.avax.network", "AVAX" },
                    { "solscan.io", "SOL" },
                    { "polkadot.subscan.io", "DOT" },
                    { "dashboard.internetcomputer.org", "ICP" },
                    { "explorer.chiliz.com", "CHZ" },
                    { "cardanoscan.io", "ADA" },
                    { "mainnet.theoan.com", "AION" },
                    { "algoexplorer.io", "ALGO" },
                    { "explorer.ambrosus.com", "AMB" },
                    { "viewblock.io/zilliqa", "ZIL" },
                    { "viewblock.io/arweave", "AR" },
                    { "explorer.ark.io", "ARK" },
                    { "atomscan.com", "ATOM" },
                    { "www.mintscan.io", "CTK" },
                    { "explorer.bitcoindiamond.org", "BCD" },
                    { "btgexplorer.com", "BTG" },
                    { "bts.ai", "BTS" },
                    { "explorer.celo.org", "CELO" },
                    { "explorer.nervos.org", "CKB" },
                    { "cerebro.cortexlabs.ai", "CTXC" },
                    { "chainz.cryptoid.info", "VIA" },
                    { "explorer.dcrdata.org", "DCR" },
                    { "digiexplorer.info", "DGB" },
                    { "dock.subscan.io", "DOCK" },
                    { "dogechain.info", "DOGE" },
                    { "explorer.elrond.com", "EGLD" },
                    { "blockscout.com", "ETC" },
                    { "explore-fetchhub.fetch.ai", "FET" },
                    { "filfox.info", "FIL" },
                    { "fio.bloks.io", "FIO" },
                    { "explorer.firo.org", "FIRO" },
                    { "neoscan.io", "NEO" },
                    { "ftmscan.com", "FTM" },
                    { "explorer.gochain.io", "GO" },
                    { "block.gxb.io", "GXS" },
                    { "hash-hash.info", "HBAR" },
                    { "www.hiveblockexplorer.com", "HIVE" },
                    { "explorer.helium.com", "HNT" },
                    { "tracker.icon.foundation", "ICX" },
                    { "www.iostabc.com", "IOST" },
                    { "explorer.iota.org", "IOTA" },
                    { "iotexscan.io", "IOTX" },
                    { "irishub.iobscan.io", "IRIS" },
                    { "kava.mintscan.io", "KAVA" },
                    { "scope.klaytn.com", "KLAY" },
                    { "kmdexplorer.io", "KMD" },
                    { "kusama.subscan.io", "KSM" },
                    { "explorer.lto.network", "LTO" },
                    { "polygonscan.com", "POLYGON" },
                    { "explorer.ont.io", "ONT" },
                    { "minaexplorer.com", "MINA" },
                    { "nanolooker.com", "NANO" },
                    { "explorer.nebulas.io", "NAS" },
                    { "explorer.nbs.plus", "NBS" },
                    { "explorer.nebl.io", "NEBL" },
                    { "nulscan.io", "NULS" },
                    { "nxscan.com", "NXS" },
                    { "explorer.harmony.one", "ONE" },
                    { "explorer.poa.network", "POA" },
                    { "qtum.info", "QTUM" },
                    { "explorer.rsk.co", "RSK" },
                    { "www.oasisscan.com", "ROSE" },
                    { "ravencoin.network", "RVN" },
                    { "sc.tokenview.com", "SC" },
                    { "secretnodes.com", "SCRT" },
                    { "explorer.skycoin.com", "SKY" },
                    { "steemscan.com", "STEEM" },
                    { "explorer.stacks.co", "STX" },
                    { "www.thetascan.io", "THETA" },
                    { "scan.tomochain.com", "TOMO" },
                    { "explore.vechain.org", "VET" },
                    { "explorer.vite.net", "VITE" },
                    { "www.wanscan.org", "WAN" },
                    { "wavesexplorer.com", "WAVES" },
                    { "wax.eosx.io", "WAXP" },
                    { "waltonchain.pro", "WTC" },
                    { "chain.nem.ninja", "XEM" },
                    { "verge-blockchain.info", "XVG" },
                    { "explorer.yoyow.org", "YOYOW" },
                    { "explorer.zcha.in", "ZEC" },
                    { "explorer.zensystem.io", "ZEN" },
                } },
                { "impliedNetworks", new Dictionary<string, object>() {
                    { "ETH", new Dictionary<string, object>() {
                        { "ERC20", "ETH" },
                    } },
                    { "TRX", new Dictionary<string, object>() {
                        { "TRC20", "TRX" },
                    } },
                } },
                { "legalMoney", new Dictionary<string, object>() {
                    { "MXN", true },
                    { "UGX", true },
                    { "SEK", true },
                    { "CHF", true },
                    { "VND", true },
                    { "AED", true },
                    { "DKK", true },
                    { "KZT", true },
                    { "HUF", true },
                    { "PEN", true },
                    { "PHP", true },
                    { "USD", true },
                    { "TRY", true },
                    { "EUR", true },
                    { "NGN", true },
                    { "PLN", true },
                    { "BRL", true },
                    { "ZAR", true },
                    { "KES", true },
                    { "ARS", true },
                    { "RUB", true },
                    { "AUD", true },
                    { "NOK", true },
                    { "CZK", true },
                    { "GBP", true },
                    { "UAH", true },
                    { "GHS", true },
                    { "HKD", true },
                    { "CAD", true },
                    { "INR", true },
                    { "JPY", true },
                    { "NZD", true },
                } },
                { "legalMoneyCurrenciesById", new Dictionary<string, object>() {
                    { "BUSD", "USD" },
                } },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "System is under maintenance.", typeof(OnMaintenance) },
                    { "System abnormality", typeof(ExchangeError) },
                    { "You are not authorized to execute this request.", typeof(PermissionDenied) },
                    { "API key does not exist", typeof(AuthenticationError) },
                    { "Order would trigger immediately.", typeof(OrderImmediatelyFillable) },
                    { "Stop price would trigger immediately.", typeof(OrderImmediatelyFillable) },
                    { "Order would immediately match and take.", typeof(OrderImmediatelyFillable) },
                    { "Account has insufficient balance for requested action.", typeof(InsufficientFunds) },
                    { "Rest API trading is not enabled.", typeof(ExchangeNotAvailable) },
                    { "You don\'t have permission.", typeof(PermissionDenied) },
                    { "Market is closed.", typeof(ExchangeNotAvailable) },
                    { "Too many requests. Please try again later.", typeof(DDoSProtection) },
                    { "This action is disabled on this account.", typeof(AccountSuspended) },
                    { "This type of sub-account exceeds the maximum number limit", typeof(BadRequest) },
                    { "This symbol is not permitted for this account.", typeof(PermissionDenied) },
                    { "-1000", typeof(ExchangeNotAvailable) },
                    { "-1001", typeof(ExchangeNotAvailable) },
                    { "-1002", typeof(AuthenticationError) },
                    { "-1003", typeof(RateLimitExceeded) },
                    { "-1004", typeof(DDoSProtection) },
                    { "-1005", typeof(PermissionDenied) },
                    { "-1006", typeof(BadResponse) },
                    { "-1007", typeof(RequestTimeout) },
                    { "-1010", typeof(BadResponse) },
                    { "-1011", typeof(PermissionDenied) },
                    { "-1013", typeof(InvalidOrder) },
                    { "-1014", typeof(InvalidOrder) },
                    { "-1015", typeof(RateLimitExceeded) },
                    { "-1016", typeof(ExchangeNotAvailable) },
                    { "-1020", typeof(BadRequest) },
                    { "-1021", typeof(InvalidNonce) },
                    { "-1022", typeof(AuthenticationError) },
                    { "-1023", typeof(BadRequest) },
                    { "-1099", typeof(AuthenticationError) },
                    { "-1100", typeof(BadRequest) },
                    { "-1101", typeof(BadRequest) },
                    { "-1102", typeof(BadRequest) },
                    { "-1103", typeof(BadRequest) },
                    { "-1104", typeof(BadRequest) },
                    { "-1105", typeof(BadRequest) },
                    { "-1106", typeof(BadRequest) },
                    { "-1108", typeof(BadRequest) },
                    { "-1109", typeof(AuthenticationError) },
                    { "-1110", typeof(BadRequest) },
                    { "-1111", typeof(BadRequest) },
                    { "-1112", typeof(InvalidOrder) },
                    { "-1113", typeof(BadRequest) },
                    { "-1114", typeof(BadRequest) },
                    { "-1115", typeof(BadRequest) },
                    { "-1116", typeof(BadRequest) },
                    { "-1117", typeof(BadRequest) },
                    { "-1118", typeof(BadRequest) },
                    { "-1119", typeof(BadRequest) },
                    { "-1120", typeof(BadRequest) },
                    { "-1121", typeof(BadSymbol) },
                    { "-1125", typeof(AuthenticationError) },
                    { "-1127", typeof(BadRequest) },
                    { "-1128", typeof(BadRequest) },
                    { "-1130", typeof(BadRequest) },
                    { "-1131", typeof(BadRequest) },
                    { "-1135", typeof(BadRequest) },
                    { "-1136", typeof(BadRequest) },
                    { "-2008", typeof(AuthenticationError) },
                    { "-2010", typeof(ExchangeError) },
                    { "-2011", typeof(OrderNotFound) },
                    { "-2013", typeof(OrderNotFound) },
                    { "-2014", typeof(AuthenticationError) },
                    { "-2015", typeof(AuthenticationError) },
                    { "-2016", typeof(BadRequest) },
                    { "-2018", typeof(InsufficientFunds) },
                    { "-2019", typeof(InsufficientFunds) },
                    { "-2020", typeof(OrderNotFillable) },
                    { "-2021", typeof(OrderImmediatelyFillable) },
                    { "-2022", typeof(InvalidOrder) },
                    { "-2023", typeof(InsufficientFunds) },
                    { "-2024", typeof(InsufficientFunds) },
                    { "-2025", typeof(InvalidOrder) },
                    { "-2026", typeof(InvalidOrder) },
                    { "-2027", typeof(InvalidOrder) },
                    { "-2028", typeof(InsufficientFunds) },
                    { "-3000", typeof(ExchangeError) },
                    { "-3001", typeof(AuthenticationError) },
                    { "-3002", typeof(BadSymbol) },
                    { "-3003", typeof(BadRequest) },
                    { "-3004", typeof(ExchangeError) },
                    { "-3005", typeof(InsufficientFunds) },
                    { "-3006", typeof(InsufficientFunds) },
                    { "-3007", typeof(ExchangeError) },
                    { "-3008", typeof(InsufficientFunds) },
                    { "-3009", typeof(BadRequest) },
                    { "-3010", typeof(BadRequest) },
                    { "-3011", typeof(BadRequest) },
                    { "-3012", typeof(InsufficientFunds) },
                    { "-3013", typeof(BadRequest) },
                    { "-3014", typeof(AccountSuspended) },
                    { "-3015", typeof(BadRequest) },
                    { "-3016", typeof(BadRequest) },
                    { "-3017", typeof(ExchangeError) },
                    { "-3018", typeof(AccountSuspended) },
                    { "-3019", typeof(AccountSuspended) },
                    { "-3020", typeof(InsufficientFunds) },
                    { "-3021", typeof(BadRequest) },
                    { "-3022", typeof(AccountSuspended) },
                    { "-3023", typeof(BadRequest) },
                    { "-3024", typeof(ExchangeError) },
                    { "-3025", typeof(BadRequest) },
                    { "-3026", typeof(BadRequest) },
                    { "-3027", typeof(BadSymbol) },
                    { "-3028", typeof(BadSymbol) },
                    { "-3029", typeof(ExchangeError) },
                    { "-3036", typeof(AccountSuspended) },
                    { "-3037", typeof(ExchangeError) },
                    { "-3038", typeof(BadRequest) },
                    { "-3041", typeof(InsufficientFunds) },
                    { "-3042", typeof(BadRequest) },
                    { "-3043", typeof(BadRequest) },
                    { "-3044", typeof(DDoSProtection) },
                    { "-3045", typeof(ExchangeError) },
                    { "-3999", typeof(ExchangeError) },
                    { "-4001", typeof(BadRequest) },
                    { "-4002", typeof(BadRequest) },
                    { "-4003", typeof(BadRequest) },
                    { "-4004", typeof(AuthenticationError) },
                    { "-4005", typeof(RateLimitExceeded) },
                    { "-4006", typeof(BadRequest) },
                    { "-4007", typeof(BadRequest) },
                    { "-4008", typeof(BadRequest) },
                    { "-4010", typeof(BadRequest) },
                    { "-4011", typeof(BadRequest) },
                    { "-4012", typeof(BadRequest) },
                    { "-4013", typeof(AuthenticationError) },
                    { "-4014", typeof(PermissionDenied) },
                    { "-4015", typeof(ExchangeError) },
                    { "-4016", typeof(PermissionDenied) },
                    { "-4017", typeof(PermissionDenied) },
                    { "-4018", typeof(BadSymbol) },
                    { "-4019", typeof(BadSymbol) },
                    { "-4021", typeof(BadRequest) },
                    { "-4022", typeof(BadRequest) },
                    { "-4023", typeof(ExchangeError) },
                    { "-4024", typeof(InsufficientFunds) },
                    { "-4025", typeof(InsufficientFunds) },
                    { "-4026", typeof(InsufficientFunds) },
                    { "-4027", typeof(ExchangeError) },
                    { "-4028", typeof(BadRequest) },
                    { "-4029", typeof(BadRequest) },
                    { "-4030", typeof(ExchangeError) },
                    { "-4031", typeof(ExchangeError) },
                    { "-4032", typeof(ExchangeError) },
                    { "-4033", typeof(BadRequest) },
                    { "-4034", typeof(ExchangeError) },
                    { "-4035", typeof(PermissionDenied) },
                    { "-4036", typeof(BadRequest) },
                    { "-4037", typeof(ExchangeError) },
                    { "-4038", typeof(ExchangeError) },
                    { "-4039", typeof(BadRequest) },
                    { "-4040", typeof(BadRequest) },
                    { "-4041", typeof(ExchangeError) },
                    { "-4042", typeof(ExchangeError) },
                    { "-4043", typeof(BadRequest) },
                    { "-4044", typeof(BadRequest) },
                    { "-4045", typeof(ExchangeError) },
                    { "-4046", typeof(AuthenticationError) },
                    { "-4047", typeof(BadRequest) },
                    { "-5001", typeof(BadRequest) },
                    { "-5002", typeof(InsufficientFunds) },
                    { "-5003", typeof(InsufficientFunds) },
                    { "-5004", typeof(BadRequest) },
                    { "-5005", typeof(InsufficientFunds) },
                    { "-5006", typeof(BadRequest) },
                    { "-5007", typeof(BadRequest) },
                    { "-5008", typeof(InsufficientFunds) },
                    { "-5009", typeof(BadRequest) },
                    { "-5010", typeof(ExchangeError) },
                    { "-5011", typeof(BadRequest) },
                    { "-5012", typeof(ExchangeError) },
                    { "-5013", typeof(InsufficientFunds) },
                    { "-5021", typeof(BadRequest) },
                    { "-6001", typeof(BadRequest) },
                    { "-6003", typeof(BadRequest) },
                    { "-6004", typeof(ExchangeError) },
                    { "-6005", typeof(InvalidOrder) },
                    { "-6006", typeof(BadRequest) },
                    { "-6007", typeof(BadRequest) },
                    { "-6008", typeof(BadRequest) },
                    { "-6009", typeof(RateLimitExceeded) },
                    { "-6011", typeof(BadRequest) },
                    { "-6012", typeof(InsufficientFunds) },
                    { "-6013", typeof(ExchangeError) },
                    { "-6014", typeof(BadRequest) },
                    { "-6015", typeof(BadRequest) },
                    { "-6016", typeof(BadRequest) },
                    { "-6017", typeof(BadRequest) },
                    { "-6018", typeof(BadRequest) },
                    { "-6019", typeof(AuthenticationError) },
                    { "-6020", typeof(BadRequest) },
                    { "-7001", typeof(BadRequest) },
                    { "-7002", typeof(BadRequest) },
                    { "-9000", typeof(InsufficientFunds) },
                    { "-10017", typeof(BadRequest) },
                    { "-11008", typeof(InsufficientFunds) },
                    { "-12014", typeof(RateLimitExceeded) },
                    { "-13000", typeof(BadRequest) },
                    { "-13001", typeof(BadRequest) },
                    { "-13002", typeof(BadRequest) },
                    { "-13003", typeof(BadRequest) },
                    { "-13004", typeof(BadRequest) },
                    { "-13005", typeof(BadRequest) },
                    { "-13006", typeof(InvalidOrder) },
                    { "-13007", typeof(AuthenticationError) },
                    { "-21001", typeof(BadRequest) },
                    { "-21002", typeof(BadRequest) },
                    { "-21003", typeof(BadRequest) },
                    { "100001003", typeof(AuthenticationError) },
                    { "200003903", typeof(AuthenticationError) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "has no operation privilege", typeof(PermissionDenied) },
                    { "MAX_POSITION", typeof(InvalidOrder) },
                } },
            } },
        });
    }

    public virtual object isInverse(object type, object subType = null)
    {
        if (isTrue(isEqual(subType, null)))
        {
            return isEqual(type, "delivery");
        } else
        {
            return isEqual(subType, "inverse");
        }
    }

    public virtual object isLinear(object type, object subType = null)
    {
        if (isTrue(isEqual(subType, null)))
        {
            return isTrue((isEqual(type, "future"))) || isTrue((isEqual(type, "swap")));
        } else
        {
            return isEqual(subType, "linear");
        }
    }

    public override void setSandboxMode(object enable)
    {
        base.setSandboxMode(enable);
        ((Dictionary<string, object>)this.options)["sandboxMode"] = enable;
    }

    public virtual object convertExpireDate(object date)
    {
        // parse YYMMDD to timestamp
        object year = ((string)date).Substring((int)0, (int)2);
        object month = ((string)date).Substring((int)2, (int)4);
        object day = ((string)date).Substring((int)4, (int)6);
        object reconstructedDate = add(add(add(add(add(add("20", year), "-"), month), "-"), day), "T00:00:00Z");
        return reconstructedDate;
    }

    public virtual object createExpiredOptionMarket(object symbol)
    {
        // support expired option contracts
        object settle = "USDT";
        object optionParts = ((string)symbol).Split((string)"-").ToList<object>();
        object symbolBase = ((string)symbol).Split((string)"/").ToList<object>();
        object bs = null;
        if (isTrue(isGreaterThan(getIndexOf(symbol, "/"), -1)))
        {
            bs = this.safeString(symbolBase, 0);
        } else
        {
            bs = this.safeString(optionParts, 0);
        }
        object expiry = this.safeString(optionParts, 1);
        object strike = this.safeInteger(optionParts, 2);
        object strikeAsString = this.safeString(optionParts, 2);
        object optionType = this.safeString(optionParts, 3);
        object datetime = this.convertExpireDate(expiry);
        object timestamp = this.parse8601(datetime);
        return new Dictionary<string, object>() {
            { "id", add(add(add(add(add(add(bs, "-"), expiry), "-"), strikeAsString), "-"), optionType) },
            { "symbol", add(add(add(add(add(add(add(add(add(add(bs, "/"), settle), ":"), settle), "-"), expiry), "-"), strikeAsString), "-"), optionType) },
            { "base", bs },
            { "quote", settle },
            { "baseId", bs },
            { "quoteId", settle },
            { "active", null },
            { "type", "option" },
            { "linear", null },
            { "inverse", null },
            { "spot", false },
            { "swap", false },
            { "future", false },
            { "option", true },
            { "margin", false },
            { "contract", true },
            { "contractSize", null },
            { "expiry", timestamp },
            { "expiryDatetime", datetime },
            { "optionType", ((bool) isTrue((isEqual(optionType, "C")))) ? "call" : "put" },
            { "strike", strike },
            { "settle", settle },
            { "settleId", settle },
            { "precision", new Dictionary<string, object>() {
                { "amount", null },
                { "price", null },
            } },
            { "limits", new Dictionary<string, object>() {
                { "amount", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
            } },
            { "info", null },
        };
    }

    public override object market(object symbol)
    {
        if (isTrue(isEqual(this.markets, null)))
        {
            throw new ExchangeError ((string)add(this.id, " markets not loaded")) ;
        }
        // defaultType has legacy support on binance
        object defaultType = this.safeString(this.options, "defaultType");
        object defaultSubType = this.safeString(this.options, "defaultSubType");
        object isLegacyLinear = isEqual(defaultType, "future");
        object isLegacyInverse = isEqual(defaultType, "delivery");
        object isLegacy = isTrue(isLegacyLinear) || isTrue(isLegacyInverse);
        if (isTrue(((symbol).GetType() == typeof(string))))
        {
            if (isTrue(((Dictionary<string,object>)this.markets).ContainsKey(toStringOrNull(symbol))))
            {
                object market = getValue(this.markets, symbol);
                // begin diff
                if (isTrue(isTrue(isLegacy) && isTrue(getValue(market, "spot"))))
                {
                    object settle = ((bool) isTrue(isLegacyLinear)) ? getValue(market, "quote") : getValue(market, "base");
                    object futuresSymbol = add(add(symbol, ":"), settle);
                    if (isTrue(((Dictionary<string,object>)this.markets).ContainsKey(toStringOrNull(futuresSymbol))))
                    {
                        return getValue(this.markets, futuresSymbol);
                    }
                } else
                {
                    return market;
                }
            } else if (isTrue(((Dictionary<string,object>)this.markets_by_id).ContainsKey(toStringOrNull(symbol))))
            {
                object markets = getValue(this.markets_by_id, symbol);
                // begin diff
                if (isTrue(isLegacyLinear))
                {
                    defaultType = "linear";
                } else if (isTrue(isLegacyInverse))
                {
                    defaultType = "inverse";
                } else if (isTrue(isEqual(defaultType, null)))
                {
                    defaultType = defaultSubType;
                }
                // end diff
                for (object i = 0; isLessThan(i, getArrayLength(markets)); postFixIncrement(ref i))
                {
                    object market = getValue(markets, i);
                    if (isTrue(getValue(market, defaultType)))
                    {
                        return market;
                    }
                }
                return getValue(markets, 0);
            } else if (isTrue(isTrue((isGreaterThan(getIndexOf(symbol, "/"), -1))) && isTrue((isLessThan(getIndexOf(symbol, ":"), 0)))))
            {
                // support legacy symbols
                var bsquoteVariable = ((string)symbol).Split((string)"/").ToList<object>();
                var bs = ((List<object>) bsquoteVariable)[0];
                var quote = ((List<object>) bsquoteVariable)[1];
                object settle = ((bool) isTrue((isEqual(quote, "USD")))) ? bs : quote;
                object futuresSymbol = add(add(symbol, ":"), settle);
                if (isTrue(((Dictionary<string,object>)this.markets).ContainsKey(toStringOrNull(futuresSymbol))))
                {
                    return getValue(this.markets, futuresSymbol);
                }
            } else if (isTrue(isTrue((isGreaterThan(getIndexOf(symbol, "-C"), -1))) || isTrue((isGreaterThan(getIndexOf(symbol, "-P"), -1)))))
            {
                return this.createExpiredOptionMarket(symbol);
            }
        }
        throw new BadSymbol ((string)add(add(this.id, " does not have market symbol "), symbol)) ;
    }

    public override object safeMarket(object marketId = null, object market = null, object delimiter = null, object marketType = null)
    {
        object isOption = isTrue((!isEqual(marketId, null))) && isTrue((isTrue((isGreaterThan(getIndexOf(marketId, "-C"), -1))) || isTrue((isGreaterThan(getIndexOf(marketId, "-P"), -1)))));
        if (isTrue(isTrue(isOption) && !isTrue((((Dictionary<string,object>)this.markets_by_id).ContainsKey(toStringOrNull(marketId))))))
        {
            // handle expired option contracts
            return this.createExpiredOptionMarket(marketId);
        }
        return base.safeMarket(marketId, market, delimiter, marketType);
    }

    public override object costToPrecision(object symbol, object cost)
    {
        return this.decimalToPrecision(cost, TRUNCATE, getValue(getValue(getValue(this.markets, symbol), "precision"), "quote"), this.precisionMode, this.paddingMode);
    }

    public override object currencyToPrecision(object code, object fee, object networkCode = null)
    {
        // info is available in currencies only if the user has configured his api keys
        if (isTrue(!isEqual(this.safeValue(getValue(this.currencies, code), "precision"), null)))
        {
            return this.decimalToPrecision(fee, TRUNCATE, getValue(getValue(this.currencies, code), "precision"), this.precisionMode, this.paddingMode);
        } else
        {
            return this.numberToString(fee);
        }
    }

    public override object nonce()
    {
        return subtract(this.milliseconds(), getValue(this.options, "timeDifference"));
    }

    public async override Task<object> fetchTime(object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchTime
        * @description fetches the current integer timestamp in milliseconds from the exchange server
        * @see https://binance-docs.github.io/apidocs/spot/en/#check-server-time       // spot
        * @see https://binance-docs.github.io/apidocs/futures/en/#check-server-time    // swap
        * @see https://binance-docs.github.io/apidocs/delivery/en/#check-server-time   // future
        * @param {object} params extra parameters specific to the binance api endpoint
        * @returns {int} the current integer timestamp in milliseconds from the exchange server
        */
        parameters ??= new Dictionary<string, object>();
        object defaultType = this.safeString2(this.options, "fetchTime", "defaultType", "spot");
        object type = this.safeString(parameters, "type", defaultType);
        object query = this.omit(parameters, "type");
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchTime", null, parameters);
        subType = ((List<object>)subTypeparametersVariable)[0];
        parameters = ((List<object>)subTypeparametersVariable)[1];
        object method = "publicGetTime";
        if (isTrue(this.isLinear(type, subType)))
        {
            method = "fapiPublicGetTime";
        } else if (isTrue(this.isInverse(type, subType)))
        {
            method = "dapiPublicGetTime";
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { query }));
        return this.safeInteger(response, "serverTime");
    }

    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchCurrencies
        * @description fetches all available currencies on an exchange
        * @see https://binance-docs.github.io/apidocs/spot/en/#all-coins-39-information-user_data
        * @param {object} params extra parameters specific to the binance api endpoint
        * @returns {object} an associative dictionary of currencies
        */
        parameters ??= new Dictionary<string, object>();
        object fetchCurrenciesEnabled = this.safeValue(this.options, "fetchCurrencies");
        if (!isTrue(fetchCurrenciesEnabled))
        {
            return null;
        }
        // this endpoint requires authentication
        // while fetchCurrencies is a public API method by design
        // therefore we check the keys here
        // and fallback to generating the currencies from the markets
        if (!isTrue(this.checkRequiredCredentials(false)))
        {
            return null;
        }
        // sandbox/testnet does not support sapi endpoints
        object apiBackup = this.safeString(this.urls, "apiBackup");
        if (isTrue(!isEqual(apiBackup, null)))
        {
            return null;
        }
        object response = await this.sapiGetCapitalConfigGetall(parameters);
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            //
            //    {
            //        "coin": "LINK",
            //        "depositAllEnable": true,
            //        "withdrawAllEnable": true,
            //        "name": "ChainLink",
            //        "free": "0",
            //        "locked": "0",
            //        "freeze": "0",
            //        "withdrawing": "0",
            //        "ipoing": "0",
            //        "ipoable": "0",
            //        "storage": "0",
            //        "isLegalMoney": false,
            //        "trading": true,
            //        "networkList": [
            //            {
            //                "network": "BSC",
            //                "coin": "LINK",
            //                "withdrawIntegerMultiple": "0.00000001",
            //                "isDefault": false,
            //                "depositEnable": true,
            //                "withdrawEnable": true,
            //                "depositDesc": "",
            //                "withdrawDesc": "",
            //                "specialTips": "",
            //                "specialWithdrawTips": "The network you have selected is BSC. Please ensure that the withdrawal address supports the Binance Smart Chain network. You will lose your assets if the chosen platform does not support retrievals.",
            //                "name": "BNB Smart Chain (BEP20)",
            //                "resetAddressStatus": false,
            //                "addressRegex": "^(0x)[0-9A-Fa-f]{40}$",
            //                "addressRule": "",
            //                "memoRegex": "",
            //                "withdrawFee": "0.012",
            //                "withdrawMin": "0.024",
            //                "withdrawMax": "9999999999.99999999",
            //                "minConfirm": "15",
            //                "unLockConfirm": "0",
            //                "sameAddress": false,
            //                "estimatedArrivalTime": "5",
            //                "busy": false,
            //                "country": "AE,BINANCE_BAHRAIN_BSC"
            //            },
            //            {
            //                "network": "BNB",
            //                "coin": "LINK",
            //                "withdrawIntegerMultiple": "0.00000001",
            //                "isDefault": false,
            //                "depositEnable": true,
            //                "withdrawEnable": true,
            //                "depositDesc": "",
            //                "withdrawDesc": "",
            //                "specialTips": "Both a MEMO and an Address are required to successfully deposit your LINK BEP2 tokens to Binance.",
            //                "specialWithdrawTips": "",
            //                "name": "BNB Beacon Chain (BEP2)",
            //                "resetAddressStatus": false,
            //                "addressRegex": "^(bnb1)[0-9a-z]{38}$",
            //                "addressRule": "",
            //                "memoRegex": "^[0-9A-Za-z\\-_]{1,120}$",
            //                "withdrawFee": "0.002",
            //                "withdrawMin": "0.01",
            //                "withdrawMax": "10000000000",
            //                "minConfirm": "1",
            //                "unLockConfirm": "0",
            //                "sameAddress": true,
            //                "estimatedArrivalTime": "5",
            //                "busy": false,
            //                "country": "AE,BINANCE_BAHRAIN_BSC"
            //            },
            //            {
            //                "network": "ETH",
            //                "coin": "LINK",
            //                "withdrawIntegerMultiple": "0.00000001",
            //                "isDefault": true,
            //                "depositEnable": true,
            //                "withdrawEnable": true,
            //                "depositDesc": "",
            //                "withdrawDesc": "",
            //                "name": "Ethereum (ERC20)",
            //                "resetAddressStatus": false,
            //                "addressRegex": "^(0x)[0-9A-Fa-f]{40}$",
            //                "addressRule": "",
            //                "memoRegex": "",
            //                "withdrawFee": "0.55",
            //                "withdrawMin": "1.1",
            //                "withdrawMax": "10000000000",
            //                "minConfirm": "12",
            //                "unLockConfirm": "0",
            //                "sameAddress": false,
            //                "estimatedArrivalTime": "5",
            //                "busy": false,
            //                "country": "AE,BINANCE_BAHRAIN_BSC"
            //            }
            //        ]
            //    }
            //
            object entry = getValue(response, i);
            object id = this.safeString(entry, "coin");
            object name = this.safeString(entry, "name");
            object code = this.safeCurrencyCode(id);
            object minPrecision = null;
            object isWithdrawEnabled = true;
            object isDepositEnabled = true;
            object networkList = this.safeValue(entry, "networkList", new List<object>() {});
            object fees = new Dictionary<string, object>() {};
            object fee = null;
            for (object j = 0; isLessThan(j, getArrayLength(networkList)); postFixIncrement(ref j))
            {
                object networkItem = getValue(networkList, j);
                object network = this.safeString(networkItem, "network");
                // const name = this.safeString (networkItem, 'name');
                object withdrawFee = this.safeNumber(networkItem, "withdrawFee");
                object depositEnable = this.safeValue(networkItem, "depositEnable");
                object withdrawEnable = this.safeValue(networkItem, "withdrawEnable");
                isDepositEnabled = isTrue(isDepositEnabled) || isTrue(depositEnable);
                isWithdrawEnabled = isTrue(isWithdrawEnabled) || isTrue(withdrawEnable);
                ((Dictionary<string, object>)fees)[(string)network] = withdrawFee;
                object isDefault = this.safeValue(networkItem, "isDefault");
                if (isTrue(isTrue(isDefault) || isTrue((isEqual(fee, null)))))
                {
                    fee = withdrawFee;
                }
                object precisionTick = this.safeString(networkItem, "withdrawIntegerMultiple");
                // avoid zero values, which are mostly from fiat or leveraged tokens : https://github.com/ccxt/ccxt/pull/14902#issuecomment-1271636731
                // so, when there is zero instead of i.e. 0.001, then we skip those cases, because we don't know the precision - it might be because of network is suspended or other reasons
                if (!isTrue(Precise.stringEq(precisionTick, "0")))
                {
                    minPrecision = ((bool) isTrue((isEqual(minPrecision, null)))) ? precisionTick : Precise.stringMin(minPrecision, precisionTick);
                }
            }
            object trading = this.safeValue(entry, "trading");
            object active = (isTrue(isTrue(isWithdrawEnabled) && isTrue(isDepositEnabled)) && isTrue(trading));
            object maxDecimalPlaces = null;
            if (isTrue(!isEqual(minPrecision, null)))
            {
                maxDecimalPlaces = parseInt(this.numberToString(this.precisionFromString(minPrecision)));
            }
            ((Dictionary<string, object>)result)[(string)code] = new Dictionary<string, object>() {
                { "id", id },
                { "name", name },
                { "code", code },
                { "precision", maxDecimalPlaces },
                { "info", entry },
                { "active", active },
                { "deposit", isDepositEnabled },
                { "withdraw", isWithdrawEnabled },
                { "networks", networkList },
                { "fee", fee },
                { "fees", fees },
                { "limits", this.limits },
            };
        }
        return result;
    }

    public async override Task<object> fetchMarkets(object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchMarkets
        * @description retrieves data on all markets for binance
        * @see https://binance-docs.github.io/apidocs/spot/en/#exchange-information         // spot
        * @see https://binance-docs.github.io/apidocs/futures/en/#exchange-information      // swap
        * @see https://binance-docs.github.io/apidocs/delivery/en/#exchange-information     // future
        * @see https://binance-docs.github.io/apidocs/voptions/en/#exchange-information     // option
        * @param {object} params extra parameters specific to the exchange api endpoint
        * @returns {[object]} an array of objects representing market data
        */
        parameters ??= new Dictionary<string, object>();
        object promisesRaw = new List<object>() {};
        object rawFetchMarkets = this.safeValue(this.options, "fetchMarkets", new List<object>() {"spot", "linear", "inverse"});
        object sandboxMode = this.safeValue(this.options, "sandboxMode", false);
        object fetchMarkets = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(rawFetchMarkets)); postFixIncrement(ref i))
        {
            object type = getValue(rawFetchMarkets, i);
            if (isTrue(isTrue(isEqual(type, "option")) && isTrue(sandboxMode)))
            {

            }
            ((List<object>)fetchMarkets).Add(type);
        }
        for (object i = 0; isLessThan(i, getArrayLength(fetchMarkets)); postFixIncrement(ref i))
        {
            object marketType = getValue(fetchMarkets, i);
            if (isTrue(isEqual(marketType, "spot")))
            {
                ((List<object>)promisesRaw).Add(this.publicGetExchangeInfo(parameters));
            } else if (isTrue(isEqual(marketType, "linear")))
            {
                ((List<object>)promisesRaw).Add(this.fapiPublicGetExchangeInfo(parameters));
            } else if (isTrue(isEqual(marketType, "inverse")))
            {
                ((List<object>)promisesRaw).Add(this.dapiPublicGetExchangeInfo(parameters));
            } else if (isTrue(isEqual(marketType, "option")))
            {
                ((List<object>)promisesRaw).Add(this.eapiPublicGetExchangeInfo(parameters));
            } else
            {
                throw new ExchangeError ((string)add(add(add(this.id, " fetchMarkets() this.options fetchMarkets \""), marketType), "\" is not a supported market type")) ;
            }
        }
        object promises = await promiseAll(promisesRaw);
        object spotMarkets = this.safeValue(this.safeValue(promises, 0), "symbols", new List<object>() {});
        object futureMarkets = this.safeValue(this.safeValue(promises, 1), "symbols", new List<object>() {});
        object deliveryMarkets = this.safeValue(this.safeValue(promises, 2), "symbols", new List<object>() {});
        object optionMarkets = this.safeValue(this.safeValue(promises, 3), "optionSymbols", new List<object>() {});
        object markets = spotMarkets;
        markets = this.arrayConcat(markets, futureMarkets);
        markets = this.arrayConcat(markets, deliveryMarkets);
        markets = this.arrayConcat(markets, optionMarkets);
        //
        // spot / margin
        //
        //     {
        //         "timezone":"UTC",
        //         "serverTime":1575416692969,
        //         "rateLimits":[
        //             {"rateLimitType":"REQUEST_WEIGHT","interval":"MINUTE","intervalNum":1,"limit":1200},
        //             {"rateLimitType":"ORDERS","interval":"SECOND","intervalNum":10,"limit":100},
        //             {"rateLimitType":"ORDERS","interval":"DAY","intervalNum":1,"limit":200000}
        //         ],
        //         "exchangeFilters":[],
        //         "symbols":[
        //             {
        //                 "symbol":"ETHBTC",
        //                 "status":"TRADING",
        //                 "baseAsset":"ETH",
        //                 "baseAssetPrecision":8,
        //                 "quoteAsset":"BTC",
        //                 "quotePrecision":8,
        //                 "baseCommissionPrecision":8,
        //                 "quoteCommissionPrecision":8,
        //                 "orderTypes":["LIMIT","LIMIT_MAKER","MARKET","STOP_LOSS_LIMIT","TAKE_PROFIT_LIMIT"],
        //                 "icebergAllowed":true,
        //                 "ocoAllowed":true,
        //                 "quoteOrderQtyMarketAllowed":true,
        //                 "allowTrailingStop":false,
        //                 "isSpotTradingAllowed":true,
        //                 "isMarginTradingAllowed":true,
        //                 "filters":[
        //                     {"filterType":"PRICE_FILTER","minPrice":"0.00000100","maxPrice":"100000.00000000","tickSize":"0.00000100"},
        //                     {"filterType":"PERCENT_PRICE","multiplierUp":"5","multiplierDown":"0.2","avgPriceMins":5},
        //                     {"filterType":"LOT_SIZE","minQty":"0.00100000","maxQty":"100000.00000000","stepSize":"0.00100000"},
        //                     {"filterType":"MIN_NOTIONAL","minNotional":"0.00010000","applyToMarket":true,"avgPriceMins":5},
        //                     {"filterType":"ICEBERG_PARTS","limit":10},
        //                     {"filterType":"MARKET_LOT_SIZE","minQty":"0.00000000","maxQty":"63100.00000000","stepSize":"0.00000000"},
        //                     {"filterType":"MAX_NUM_ORDERS","maxNumOrders":200},
        //                     {"filterType":"MAX_NUM_ALGO_ORDERS","maxNumAlgoOrders":5}
        //                 ],
        //                 "permissions":["SPOT","MARGIN"]}
        //             },
        //         ],
        //     }
        //
        // futures/usdt-margined (fapi)
        //
        //     {
        //         "timezone":"UTC",
        //         "serverTime":1575417244353,
        //         "rateLimits":[
        //             {"rateLimitType":"REQUEST_WEIGHT","interval":"MINUTE","intervalNum":1,"limit":1200},
        //             {"rateLimitType":"ORDERS","interval":"MINUTE","intervalNum":1,"limit":1200}
        //         ],
        //         "exchangeFilters":[],
        //         "symbols":[
        //             {
        //                 "symbol":"BTCUSDT",
        //                 "status":"TRADING",
        //                 "maintMarginPercent":"2.5000",
        //                 "requiredMarginPercent":"5.0000",
        //                 "baseAsset":"BTC",
        //                 "quoteAsset":"USDT",
        //                 "pricePrecision":2,
        //                 "quantityPrecision":3,
        //                 "baseAssetPrecision":8,
        //                 "quotePrecision":8,
        //                 "filters":[
        //                     {"minPrice":"0.01","maxPrice":"100000","filterType":"PRICE_FILTER","tickSize":"0.01"},
        //                     {"stepSize":"0.001","filterType":"LOT_SIZE","maxQty":"1000","minQty":"0.001"},
        //                     {"stepSize":"0.001","filterType":"MARKET_LOT_SIZE","maxQty":"1000","minQty":"0.001"},
        //                     {"limit":200,"filterType":"MAX_NUM_ORDERS"},
        //                     {"multiplierDown":"0.8500","multiplierUp":"1.1500","multiplierDecimal":"4","filterType":"PERCENT_PRICE"}
        //                 ],
        //                 "orderTypes":["LIMIT","MARKET","STOP"],
        //                 "timeInForce":["GTC","IOC","FOK","GTX"]
        //             }
        //         ]
        //     }
        //
        // delivery/coin-margined (dapi)
        //
        //     {
        //         "timezone": "UTC",
        //         "serverTime": 1597667052958,
        //         "rateLimits": [
        //             {"rateLimitType":"REQUEST_WEIGHT","interval":"MINUTE","intervalNum":1,"limit":6000},
        //             {"rateLimitType":"ORDERS","interval":"MINUTE","intervalNum":1,"limit":6000}
        //         ],
        //         "exchangeFilters": [],
        //         "symbols": [
        //             {
        //                 "symbol": "BTCUSD_200925",
        //                 "pair": "BTCUSD",
        //                 "contractType": "CURRENT_QUARTER",
        //                 "deliveryDate": 1601020800000,
        //                 "onboardDate": 1590739200000,
        //                 "contractStatus": "TRADING",
        //                 "contractSize": 100,
        //                 "marginAsset": "BTC",
        //                 "maintMarginPercent": "2.5000",
        //                 "requiredMarginPercent": "5.0000",
        //                 "baseAsset": "BTC",
        //                 "quoteAsset": "USD",
        //                 "pricePrecision": 1,
        //                 "quantityPrecision": 0,
        //                 "baseAssetPrecision": 8,
        //                 "quotePrecision": 8,
        //                 "equalQtyPrecision": 4,
        //                 "filters": [
        //                     {"minPrice":"0.1","maxPrice":"100000","filterType":"PRICE_FILTER","tickSize":"0.1"},
        //                     {"stepSize":"1","filterType":"LOT_SIZE","maxQty":"100000","minQty":"1"},
        //                     {"stepSize":"0","filterType":"MARKET_LOT_SIZE","maxQty":"100000","minQty":"1"},
        //                     {"limit":200,"filterType":"MAX_NUM_ORDERS"},
        //                     {"multiplierDown":"0.9500","multiplierUp":"1.0500","multiplierDecimal":"4","filterType":"PERCENT_PRICE"}
        //                 ],
        //                 "orderTypes": ["LIMIT","MARKET","STOP","STOP_MARKET","TAKE_PROFIT","TAKE_PROFIT_MARKET","TRAILING_STOP_MARKET"],
        //                 "timeInForce": ["GTC","IOC","FOK","GTX"]
        //             },
        //             {
        //                 "symbol": "BTCUSD_PERP",
        //                 "pair": "BTCUSD",
        //                 "contractType": "PERPETUAL",
        //                 "deliveryDate": 4133404800000,
        //                 "onboardDate": 1596006000000,
        //                 "contractStatus": "TRADING",
        //                 "contractSize": 100,
        //                 "marginAsset": "BTC",
        //                 "maintMarginPercent": "2.5000",
        //                 "requiredMarginPercent": "5.0000",
        //                 "baseAsset": "BTC",
        //                 "quoteAsset": "USD",
        //                 "pricePrecision": 1,
        //                 "quantityPrecision": 0,
        //                 "baseAssetPrecision": 8,
        //                 "quotePrecision": 8,
        //                 "equalQtyPrecision": 4,
        //                 "filters": [
        //                     {"minPrice":"0.1","maxPrice":"100000","filterType":"PRICE_FILTER","tickSize":"0.1"},
        //                     {"stepSize":"1","filterType":"LOT_SIZE","maxQty":"100000","minQty":"1"},
        //                     {"stepSize":"1","filterType":"MARKET_LOT_SIZE","maxQty":"100000","minQty":"1"},
        //                     {"limit":200,"filterType":"MAX_NUM_ORDERS"},
        //                     {"multiplierDown":"0.8500","multiplierUp":"1.1500","multiplierDecimal":"4","filterType":"PERCENT_PRICE"}
        //                 ],
        //                 "orderTypes": ["LIMIT","MARKET","STOP","STOP_MARKET","TAKE_PROFIT","TAKE_PROFIT_MARKET","TRAILING_STOP_MARKET"],
        //                 "timeInForce": ["GTC","IOC","FOK","GTX"]
        //             }
        //         ]
        //     }
        //
        // options (eapi)
        //
        //     {
        //         "timezone": "UTC",
        //         "serverTime": 1675912490405,
        //         "optionContracts": [
        //             {
        //                 "id": 1,
        //                 "baseAsset": "SOL",
        //                 "quoteAsset": "USDT",
        //                 "underlying": "SOLUSDT",
        //                 "settleAsset": "USDT"
        //             },
        //             ...
        //         ],
        //         "optionAssets": [
        //             {"id":1,"name":"USDT"}
        //         ],
        //         "optionSymbols": [
        //             {
        //                 "contractId": 3,
        //                 "expiryDate": 1677225600000,
        //                 "filters": [
        //                     {"filterType":"PRICE_FILTER","minPrice":"724.6","maxPrice":"919.2","tickSize":"0.1"},
        //                     {"filterType":"LOT_SIZE","minQty":"0.01","maxQty":"1000","stepSize":"0.01"}
        //                 ],
        //                 "id": 2474,
        //                 "symbol": "ETH-230224-800-C",
        //                 "side": "CALL",
        //                 "strikePrice": "800.00000000",
        //                 "underlying": "ETHUSDT",
        //                 "unit": 1,
        //                 "makerFeeRate": "0.00020000",
        //                 "takerFeeRate": "0.00020000",
        //                 "minQty": "0.01",
        //                 "maxQty": "1000",
        //                 "initialMargin": "0.15000000",
        //                 "maintenanceMargin": "0.07500000",
        //                 "minInitialMargin": "0.10000000",
        //                 "minMaintenanceMargin": "0.05000000",
        //                 "priceScale": 1,
        //                 "quantityScale": 2,
        //                 "quoteAsset": "USDT"
        //             },
        //             ...
        //         ],
        //         "rateLimits": [
        //             {"rateLimitType":"REQUEST_WEIGHT","interval":"MINUTE","intervalNum":1,"limit":400},
        //             {"rateLimitType":"ORDERS","interval":"MINUTE","intervalNum":1,"limit":100},
        //             {"rateLimitType":"ORDERS","interval":"SECOND","intervalNum":10,"limit":30}
        //         ]
        //     }
        //
        if (isTrue(getValue(this.options, "adjustForTimeDifference")))
        {
            await this.loadTimeDifference();
        }
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(markets)); postFixIncrement(ref i))
        {
            ((List<object>)result).Add(this.parseMarket(getValue(markets, i)));
        }
        return result;
    }

    public virtual object parseMarket(object market)
    {
        object swap = false;
        object future = false;
        object option = false;
        object underlying = this.safeString(market, "underlying");
        object id = this.safeString(market, "symbol");
        object optionParts = ((string)id).Split((string)"-").ToList<object>();
        object optionBase = this.safeString(optionParts, 0);
        object lowercaseId = this.safeStringLower(market, "symbol");
        object baseId = this.safeString(market, "baseAsset", optionBase);
        object quoteId = this.safeString(market, "quoteAsset");
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object contractType = this.safeString(market, "contractType");
        object contract = (((Dictionary<string,object>)market).ContainsKey(toStringOrNull("contractType")));
        object expiry = this.safeInteger2(market, "deliveryDate", "expiryDate");
        object settleId = this.safeString(market, "marginAsset");
        if (isTrue(isTrue((isEqual(contractType, "PERPETUAL"))) || isTrue((isEqual(expiry, 4133404800000)))))
        {
            expiry = null;
            swap = true;
        } else if (isTrue(!isEqual(underlying, null)))
        {
            contract = true;
            option = true;
            settleId = ((bool) isTrue((isEqual(settleId, null)))) ? "USDT" : settleId;
        } else if (isTrue(!isEqual(expiry, null)))
        {
            future = true;
        }
        object settle = this.safeCurrencyCode(settleId);
        object spot = !isTrue(contract);
        object filters = this.safeValue(market, "filters", new List<object>() {});
        object filtersByType = this.indexBy(filters, "filterType");
        object status = this.safeString2(market, "status", "contractStatus");
        object contractSize = null;
        object fees = this.fees;
        object linear = null;
        object inverse = null;
        object strike = this.safeInteger(market, "strikePrice");
        object symbol = add(add(bs, "/"), quote);
        if (isTrue(contract))
        {
            if (isTrue(swap))
            {
                symbol = add(add(symbol, ":"), settle);
            } else if (isTrue(future))
            {
                symbol = add(add(add(add(symbol, ":"), settle), "-"), this.yymmdd(expiry));
            } else if (isTrue(option))
            {
                symbol = add(add(add(add(add(add(add(add(symbol, ":"), settle), "-"), this.yymmdd(expiry)), "-"), this.numberToString(strike)), "-"), this.safeString(optionParts, 3));
            }
            contractSize = this.safeNumber2(market, "contractSize", "unit", this.parseNumber("1"));
            linear = isEqual(settle, quote);
            inverse = isEqual(settle, bs);
            object feesType = ((bool) isTrue(linear)) ? "linear" : "inverse";
            fees = this.safeValue(this.fees, feesType, new Dictionary<string, object>() {});
        }
        object active = (isEqual(status, "TRADING"));
        if (isTrue(spot))
        {
            object permissions = this.safeValue(market, "permissions", new List<object>() {});
            for (object j = 0; isLessThan(j, getArrayLength(permissions)); postFixIncrement(ref j))
            {
                if (isTrue(isEqual(getValue(permissions, j), "TRD_GRP_003")))
                {
                    active = false;
                    break;
                }
            }
        }
        object isMarginTradingAllowed = this.safeValue(market, "isMarginTradingAllowed", false);
        object unifiedType = null;
        if (isTrue(spot))
        {
            unifiedType = "spot";
        } else if (isTrue(swap))
        {
            unifiedType = "swap";
        } else if (isTrue(future))
        {
            unifiedType = "future";
        } else if (isTrue(option))
        {
            unifiedType = "option";
            active = null;
        }
        object entry = new Dictionary<string, object>() {
            { "id", id },
            { "lowercaseId", lowercaseId },
            { "symbol", symbol },
            { "base", bs },
            { "quote", quote },
            { "settle", settle },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settleId", settleId },
            { "type", unifiedType },
            { "spot", spot },
            { "margin", isTrue(spot) && isTrue(isMarginTradingAllowed) },
            { "swap", swap },
            { "future", future },
            { "option", option },
            { "active", active },
            { "contract", contract },
            { "linear", linear },
            { "inverse", inverse },
            { "taker", getValue(getValue(fees, "trading"), "taker") },
            { "maker", getValue(getValue(fees, "trading"), "maker") },
            { "contractSize", contractSize },
            { "expiry", expiry },
            { "expiryDatetime", this.iso8601(expiry) },
            { "strike", strike },
            { "optionType", this.safeStringLower(market, "side") },
            { "precision", new Dictionary<string, object>() {
                { "amount", this.safeInteger2(market, "quantityPrecision", "quantityScale") },
                { "price", this.safeInteger2(market, "pricePrecision", "priceScale") },
                { "base", this.safeInteger(market, "baseAssetPrecision") },
                { "quote", this.safeInteger(market, "quotePrecision") },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", this.safeNumber(market, "minQty") },
                    { "max", this.safeNumber(market, "maxQty") },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
            } },
            { "info", market },
        };
        if (isTrue(((Dictionary<string,object>)filtersByType).ContainsKey(toStringOrNull("PRICE_FILTER"))))
        {
            object filter = this.safeValue(filtersByType, "PRICE_FILTER", new Dictionary<string, object>() {});
            // PRICE_FILTER reports zero values for maxPrice
            // since they updated filter types in November 2018
            // https://github.com/ccxt/ccxt/issues/4286
            // therefore limits['price']['max'] doesn't have any meaningful value except undefined
            ((Dictionary<string, object>)getValue(entry, "limits"))["price"] = new Dictionary<string, object>() {
                { "min", this.safeNumber(filter, "minPrice") },
                { "max", this.safeNumber(filter, "maxPrice") },
            };
            ((Dictionary<string, object>)getValue(entry, "precision"))["price"] = this.precisionFromString(getValue(filter, "tickSize"));
        }
        if (isTrue(((Dictionary<string,object>)filtersByType).ContainsKey(toStringOrNull("LOT_SIZE"))))
        {
            object filter = this.safeValue(filtersByType, "LOT_SIZE", new Dictionary<string, object>() {});
            object stepSize = this.safeString(filter, "stepSize");
            ((Dictionary<string, object>)getValue(entry, "precision"))["amount"] = this.precisionFromString(stepSize);
            ((Dictionary<string, object>)getValue(entry, "limits"))["amount"] = new Dictionary<string, object>() {
                { "min", this.safeNumber(filter, "minQty") },
                { "max", this.safeNumber(filter, "maxQty") },
            };
        }
        if (isTrue(((Dictionary<string,object>)filtersByType).ContainsKey(toStringOrNull("MARKET_LOT_SIZE"))))
        {
            object filter = this.safeValue(filtersByType, "MARKET_LOT_SIZE", new Dictionary<string, object>() {});
            ((Dictionary<string, object>)getValue(entry, "limits"))["market"] = new Dictionary<string, object>() {
                { "min", this.safeNumber(filter, "minQty") },
                { "max", this.safeNumber(filter, "maxQty") },
            };
        }
        if (isTrue(isTrue((((Dictionary<string,object>)filtersByType).ContainsKey(toStringOrNull("MIN_NOTIONAL")))) || isTrue((((Dictionary<string,object>)filtersByType).ContainsKey(toStringOrNull("NOTIONAL"))))))
        {
            object filter = this.safeValue2(filtersByType, "MIN_NOTIONAL", "NOTIONAL", new Dictionary<string, object>() {});
            ((Dictionary<string, object>)getValue(getValue(entry, "limits"), "cost"))["min"] = this.safeNumber2(filter, "minNotional", "notional");
            ((Dictionary<string, object>)getValue(getValue(entry, "limits"), "cost"))["max"] = this.safeNumber(filter, "maxNotional");
        }
        return entry;
    }

    public virtual object parseBalanceHelper(object entry)
    {
        object account = this.account();
        ((Dictionary<string, object>)account)["used"] = this.safeString(entry, "locked");
        ((Dictionary<string, object>)account)["free"] = this.safeString(entry, "free");
        object interest = this.safeString(entry, "interest");
        object debt = this.safeString(entry, "borrowed");
        ((Dictionary<string, object>)account)["debt"] = Precise.stringAdd(debt, interest);
        return account;
    }

    public virtual object parseBalance(object response, object type = null, object marginMode = null)
    {
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        object timestamp = null;
        object isolated = isEqual(marginMode, "isolated");
        object cross = isTrue((isEqual(type, "margin"))) || isTrue((isEqual(marginMode, "cross")));
        if (isTrue(!isTrue(isolated) && isTrue((isTrue((isEqual(type, "spot"))) || isTrue(cross)))))
        {
            timestamp = this.safeInteger(response, "updateTime");
            object balances = this.safeValue2(response, "balances", "userAssets", new List<object>() {});
            for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
            {
                object balance = getValue(balances, i);
                object currencyId = this.safeString(balance, "asset");
                object code = this.safeCurrencyCode(currencyId);
                object account = this.account();
                ((Dictionary<string, object>)account)["free"] = this.safeString(balance, "free");
                ((Dictionary<string, object>)account)["used"] = this.safeString(balance, "locked");
                if (isTrue(cross))
                {
                    object debt = this.safeString(balance, "borrowed");
                    object interest = this.safeString(balance, "interest");
                    ((Dictionary<string, object>)account)["debt"] = Precise.stringAdd(debt, interest);
                }
                ((Dictionary<string, object>)result)[(string)code] = account;
            }
        } else if (isTrue(isolated))
        {
            object assets = this.safeValue(response, "assets");
            for (object i = 0; isLessThan(i, getArrayLength(assets)); postFixIncrement(ref i))
            {
                object asset = getValue(assets, i);
                object marketId = this.safeValue(asset, "symbol");
                object symbol = this.safeSymbol(marketId, null, null, "spot");
                object bs = this.safeValue(asset, "baseAsset", new Dictionary<string, object>() {});
                object quote = this.safeValue(asset, "quoteAsset", new Dictionary<string, object>() {});
                object baseCode = this.safeCurrencyCode(this.safeString(bs, "asset"));
                object quoteCode = this.safeCurrencyCode(this.safeString(quote, "asset"));
                object subResult = new Dictionary<string, object>() {};
                ((Dictionary<string, object>)subResult)[(string)baseCode] = this.parseBalanceHelper(bs);
                ((Dictionary<string, object>)subResult)[(string)quoteCode] = this.parseBalanceHelper(quote);
                ((Dictionary<string, object>)result)[(string)symbol] = this.safeBalance(subResult);
            }
        } else if (isTrue(isEqual(type, "savings")))
        {
            object positionAmountVos = this.safeValue(response, "positionAmountVos", new List<object>() {});
            for (object i = 0; isLessThan(i, getArrayLength(positionAmountVos)); postFixIncrement(ref i))
            {
                object entry = getValue(positionAmountVos, i);
                object currencyId = this.safeString(entry, "asset");
                object code = this.safeCurrencyCode(currencyId);
                object account = this.account();
                object usedAndTotal = this.safeString(entry, "amount");
                ((Dictionary<string, object>)account)["total"] = usedAndTotal;
                ((Dictionary<string, object>)account)["used"] = usedAndTotal;
                ((Dictionary<string, object>)result)[(string)code] = account;
            }
        } else if (isTrue(isEqual(type, "funding")))
        {
            for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
            {
                object entry = getValue(response, i);
                object account = this.account();
                object currencyId = this.safeString(entry, "asset");
                object code = this.safeCurrencyCode(currencyId);
                ((Dictionary<string, object>)account)["free"] = this.safeString(entry, "free");
                object frozen = this.safeString(entry, "freeze");
                object withdrawing = this.safeString(entry, "withdrawing");
                object locked = this.safeString(entry, "locked");
                ((Dictionary<string, object>)account)["used"] = Precise.stringAdd(frozen, Precise.stringAdd(locked, withdrawing));
                ((Dictionary<string, object>)result)[(string)code] = account;
            }
        } else
        {
            object balances = response;
            if (!isTrue((response.GetType().IsGenericType && response.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))
            {
                balances = this.safeValue(response, "assets", new List<object>() {});
            }
            for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
            {
                object balance = getValue(balances, i);
                object currencyId = this.safeString(balance, "asset");
                object code = this.safeCurrencyCode(currencyId);
                object account = this.account();
                ((Dictionary<string, object>)account)["free"] = this.safeString(balance, "availableBalance");
                ((Dictionary<string, object>)account)["used"] = this.safeString(balance, "initialMargin");
                ((Dictionary<string, object>)account)["total"] = this.safeString2(balance, "marginBalance", "balance");
                ((Dictionary<string, object>)result)[(string)code] = account;
            }
        }
        ((Dictionary<string, object>)result)["timestamp"] = timestamp;
        ((Dictionary<string, object>)result)["datetime"] = this.iso8601(timestamp);
        return ((bool) isTrue(isolated)) ? result : this.safeBalance(result);
    }

    public async override Task<object> fetchBalance(object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchBalance
        * @description query for balance and get the amount of funds available for trading or funds locked in orders
        * @see https://binance-docs.github.io/apidocs/spot/en/#account-information-user_data                  // spot
        * @see https://binance-docs.github.io/apidocs/spot/en/#query-cross-margin-account-details-user_data   // cross margin
        * @see https://binance-docs.github.io/apidocs/spot/en/#query-isolated-margin-account-info-user_data   // isolated margin
        * @see https://binance-docs.github.io/apidocs/spot/en/#lending-account-user_data                      // lending
        * @see https://binance-docs.github.io/apidocs/spot/en/#funding-wallet-user_data                       // funding
        * @see https://binance-docs.github.io/apidocs/futures/en/#account-information-v2-user_data            // swap
        * @see https://binance-docs.github.io/apidocs/delivery/en/#account-information-user_data              // future
        * @see https://binance-docs.github.io/apidocs/voptions/en/#option-account-information-trade           // option
        * @param {object} params extra parameters specific to the binance api endpoint
        * @param {string|undefined} params.type 'future', 'delivery', 'savings', 'funding', or 'spot'
        * @param {string|undefined} params.marginMode 'cross' or 'isolated', for margin trading, uses this.options.defaultMarginMode if not passed, defaults to undefined/None/null
        * @param {[string]|undefined} params.symbols unified market symbols, only used in isolated margin mode
        * @returns {object} a [balance structure]{@link https://docs.ccxt.com/en/latest/manual.html?#balance-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object defaultType = this.safeString2(this.options, "fetchBalance", "defaultType", "spot");
        object type = this.safeString(parameters, "type", defaultType);
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchBalance", null, parameters);
        subType = ((List<object>)subTypeparametersVariable)[0];
        parameters = ((List<object>)subTypeparametersVariable)[1];
        var marginModequeryVariable = this.handleMarginModeAndParams("fetchBalance", parameters);
        var marginMode = ((List<object>) marginModequeryVariable)[0];
        var query = ((List<object>) marginModequeryVariable)[1];
        object method = "privateGetAccount";
        object request = new Dictionary<string, object>() {};
        if (isTrue(this.isLinear(type, subType)))
        {
            object options = this.safeValue(this.options, type, new Dictionary<string, object>() {});
            object fetchBalanceOptions = this.safeValue(options, "fetchBalance", new Dictionary<string, object>() {});
            method = this.safeString(fetchBalanceOptions, "method", "fapiPrivateV2GetAccount");
            type = "linear";
        } else if (isTrue(this.isInverse(type, subType)))
        {
            object options = this.safeValue(this.options, type, new Dictionary<string, object>() {});
            object fetchBalanceOptions = this.safeValue(options, "fetchBalance", new Dictionary<string, object>() {});
            method = this.safeString(fetchBalanceOptions, "method", "dapiPrivateGetAccount");
            type = "inverse";
        } else if (isTrue(isEqual(marginMode, "isolated")))
        {
            method = "sapiGetMarginIsolatedAccount";
            object paramSymbols = this.safeValue(parameters, "symbols");
            if (isTrue(!isEqual(paramSymbols, null)))
            {
                object symbols = "";
                if (isTrue((paramSymbols.GetType().IsGenericType && paramSymbols.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))
                {
                    symbols = this.marketId(getValue(paramSymbols, 0));
                    for (object i = 1; isLessThan(i, getArrayLength(paramSymbols)); postFixIncrement(ref i))
                    {
                        object symbol = getValue(paramSymbols, i);
                        object id = this.marketId(symbol);
                        symbols = add(symbols, add(",", id));
                    }
                } else
                {
                    symbols = paramSymbols;
                }
                ((Dictionary<string, object>)request)["symbols"] = symbols;
            }
        } else if (isTrue(isTrue((isEqual(type, "margin"))) || isTrue((isEqual(marginMode, "cross")))))
        {
            method = "sapiGetMarginAccount";
        } else if (isTrue(isEqual(type, "savings")))
        {
            method = "sapiGetLendingUnionAccount";
        } else if (isTrue(isEqual(type, "funding")))
        {
            method = "sapiPostAssetGetFundingAsset";
        }
        object requestParams = this.omit(query, new List<object>() {"type", "symbols"});
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, requestParams) }));
        //
        // spot
        //
        //     {
        //         makerCommission: 10,
        //         takerCommission: 10,
        //         buyerCommission: 0,
        //         sellerCommission: 0,
        //         canTrade: true,
        //         canWithdraw: true,
        //         canDeposit: true,
        //         updateTime: 1575357359602,
        //         accountType: "MARGIN",
        //         balances: [
        //             { asset: "BTC", free: "0.00219821", locked: "0.00000000"  },
        //         ]
        //     }
        //
        // margin (cross)
        //
        //     {
        //         "borrowEnabled":true,
        //         "marginLevel":"999.00000000",
        //         "totalAssetOfBtc":"0.00000000",
        //         "totalLiabilityOfBtc":"0.00000000",
        //         "totalNetAssetOfBtc":"0.00000000",
        //         "tradeEnabled":true,
        //         "transferEnabled":true,
        //         "userAssets":[
        //             {"asset":"MATIC","borrowed":"0.00000000","free":"0.00000000","interest":"0.00000000","locked":"0.00000000","netAsset":"0.00000000"},
        //             {"asset":"VET","borrowed":"0.00000000","free":"0.00000000","interest":"0.00000000","locked":"0.00000000","netAsset":"0.00000000"},
        //             {"asset":"USDT","borrowed":"0.00000000","free":"0.00000000","interest":"0.00000000","locked":"0.00000000","netAsset":"0.00000000"}
        //         ],
        //     }
        //
        // margin (isolated)
        //
        //    {
        //        info: {
        //            assets: [
        //                {
        //                    baseAsset: {
        //                        asset: '1INCH',
        //                        borrowEnabled: true,
        //                        borrowed: '0',
        //                        free: '0',
        //                        interest: '0',
        //                        locked: '0',
        //                        netAsset: '0',
        //                        netAssetOfBtc: '0',
        //                        repayEnabled: true,
        //                        totalAsset: '0'
        //                    },
        //                    quoteAsset: {
        //                        asset: 'USDT',
        //                        borrowEnabled: true,
        //                        borrowed: '0',
        //                        free: '11',
        //                        interest: '0',
        //                        locked: '0',
        //                        netAsset: '11',
        //                        netAssetOfBtc: '0.00054615',
        //                        repayEnabled: true,
        //                        totalAsset: '11'
        //                    },
        //                    symbol: '1INCHUSDT',
        //                    isolatedCreated: true,
        //                    marginLevel: '999',
        //                    marginLevelStatus: 'EXCESSIVE',
        //                    marginRatio: '5',
        //                    indexPrice: '0.59184331',
        //                    liquidatePrice: '0',
        //                    liquidateRate: '0',
        //                    tradeEnabled: true,
        //                    enabled: true
        //                },
        //            ]
        //        }
        //    }
        //
        // futures (fapi)
        //
        //     fapiPrivateGetAccount
        //
        //     {
        //         "feeTier":0,
        //         "canTrade":true,
        //         "canDeposit":true,
        //         "canWithdraw":true,
        //         "updateTime":0,
        //         "totalInitialMargin":"0.00000000",
        //         "totalMaintMargin":"0.00000000",
        //         "totalWalletBalance":"4.54000000",
        //         "totalUnrealizedProfit":"0.00000000",
        //         "totalMarginBalance":"4.54000000",
        //         "totalPositionInitialMargin":"0.00000000",
        //         "totalOpenOrderInitialMargin":"0.00000000",
        //         "maxWithdrawAmount":"4.54000000",
        //         "assets":[
        //             {
        //                 "asset":"USDT",
        //                 "walletBalance":"4.54000000",
        //                 "unrealizedProfit":"0.00000000",
        //                 "marginBalance":"4.54000000",
        //                 "maintMargin":"0.00000000",
        //                 "initialMargin":"0.00000000",
        //                 "positionInitialMargin":"0.00000000",
        //                 "openOrderInitialMargin":"0.00000000",
        //                 "maxWithdrawAmount":"4.54000000"
        //             }
        //         ],
        //         "positions":[
        //             {
        //                 "symbol":"BTCUSDT",
        //                 "initialMargin":"0.00000",
        //                 "maintMargin":"0.00000",
        //                 "unrealizedProfit":"0.00000000",
        //                 "positionInitialMargin":"0.00000",
        //                 "openOrderInitialMargin":"0.00000"
        //             }
        //         ]
        //     }
        //
        //     fapiPrivateV2GetAccount
        //
        //     {
        //         "feeTier":0,
        //         "canTrade":true,
        //         "canDeposit":true,
        //         "canWithdraw":true,
        //         "updateTime":0,
        //         "totalInitialMargin":"0.00000000",
        //         "totalMaintMargin":"0.00000000",
        //         "totalWalletBalance":"0.00000000",
        //         "totalUnrealizedProfit":"0.00000000",
        //         "totalMarginBalance":"0.00000000",
        //         "totalPositionInitialMargin":"0.00000000",
        //         "totalOpenOrderInitialMargin":"0.00000000",
        //         "totalCrossWalletBalance":"0.00000000",
        //         "totalCrossUnPnl":"0.00000000",
        //         "availableBalance":"0.00000000",
        //         "maxWithdrawAmount":"0.00000000",
        //         "assets":[
        //             {
        //                 "asset":"BNB",
        //                 "walletBalance":"0.01000000",
        //                 "unrealizedProfit":"0.00000000",
        //                 "marginBalance":"0.01000000",
        //                 "maintMargin":"0.00000000",
        //                 "initialMargin":"0.00000000",
        //                 "positionInitialMargin":"0.00000000",
        //                 "openOrderInitialMargin":"0.00000000",
        //                 "maxWithdrawAmount":"0.01000000",
        //                 "crossWalletBalance":"0.01000000",
        //                 "crossUnPnl":"0.00000000",
        //                 "availableBalance":"0.01000000"
        //             }
        //         ],
        //         "positions":[
        //             {
        //                 "symbol":"BTCUSDT",
        //                 "initialMargin":"0",
        //                 "maintMargin":"0",
        //                 "unrealizedProfit":"0.00000000",
        //                 "positionInitialMargin":"0",
        //                 "openOrderInitialMargin":"0",
        //                 "leverage":"20",
        //                 "isolated":false,
        //                 "entryPrice":"0.00000",
        //                 "maxNotional":"5000000",
        //                 "positionSide":"BOTH"
        //             },
        //         ]
        //     }
        //
        //     fapiPrivateV2GetBalance
        //
        //     [
        //         {
        //             "accountAlias":"FzFzXquXXqoC",
        //             "asset":"BNB",
        //             "balance":"0.01000000",
        //             "crossWalletBalance":"0.01000000",
        //             "crossUnPnl":"0.00000000",
        //             "availableBalance":"0.01000000",
        //             "maxWithdrawAmount":"0.01000000"
        //         }
        //     ]
        //
        // savings
        //
        //     {
        //       "totalAmountInBTC": "0.3172",
        //       "totalAmountInUSDT": "10000",
        //       "totalFixedAmountInBTC": "0.3172",
        //       "totalFixedAmountInUSDT": "10000",
        //       "totalFlexibleInBTC": "0",
        //       "totalFlexibleInUSDT": "0",
        //       "positionAmountVos": [
        //         {
        //           "asset": "USDT",
        //           "amount": "10000",
        //           "amountInBTC": "0.3172",
        //           "amountInUSDT": "10000"
        //         },
        //         {
        //           "asset": "BUSD",
        //           "amount": "0",
        //           "amountInBTC": "0",
        //           "amountInUSDT": "0"
        //         }
        //       ]
        //     }
        //
        // binance pay
        //
        //     [
        //       {
        //         "asset": "BUSD",
        //         "free": "1129.83",
        //         "locked": "0",
        //         "freeze": "0",
        //         "withdrawing": "0"
        //       }
        //     ]
        //
        return this.parseBalance(response, type, marginMode);
    }

    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchOrderBook
        * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
        * @see https://binance-docs.github.io/apidocs/spot/en/#order-book      // spot
        * @see https://binance-docs.github.io/apidocs/futures/en/#order-book   // swap
        * @see https://binance-docs.github.io/apidocs/delivery/en/#order-book  // future
        * @see https://binance-docs.github.io/apidocs/voptions/en/#order-book  // option
        * @param {string} symbol unified symbol of the market to fetch the order book for
        * @param {int|undefined} limit the maximum amount of order book entries to return
        * @param {object} params extra parameters specific to the binance api endpoint
        * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit; // default 100, max 5000, see https://github.com/binance/binance-spot-api-docs/blob/master/rest-api.md#order-book
        }
        object method = "publicGetDepth";
        if (isTrue(getValue(market, "option")))
        {
            method = "eapiPublicGetDepth";
        } else if (isTrue(getValue(market, "linear")))
        {
            method = "fapiPublicGetDepth";
        } else if (isTrue(getValue(market, "inverse")))
        {
            method = "dapiPublicGetDepth";
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        // future
        //
        //     {
        //         "lastUpdateId":333598053905,
        //         "E":1618631511986,
        //         "T":1618631511964,
        //         "bids":[
        //             ["2493.56","20.189"],
        //             ["2493.54","1.000"],
        //             ["2493.51","0.005"]
        //         ],
        //         "asks":[
        //             ["2493.57","0.877"],
        //             ["2493.62","0.063"],
        //             ["2493.71","12.054"],
        //         ]
        //     }
        //
        // options (eapi)
        //
        //     {
        //         "bids": [
        //             ["108.7","16.08"],
        //             ["106","21.29"],
        //             ["82.4","0.02"]
        //         ],
        //         "asks": [
        //             ["111.4","19.52"],
        //             ["119.9","17.6"],
        //             ["141.2","31"]
        //         ],
        //         "T": 1676771382078,
        //         "u": 1015939
        //     }
        //
        object timestamp = this.safeInteger(response, "T");
        object orderbook = this.parseOrderBook(response, symbol, timestamp);
        ((Dictionary<string, object>)orderbook)["nonce"] = this.safeInteger2(response, "lastUpdateId", "u");
        return orderbook;
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        //     {
        //         symbol: 'ETHBTC',
        //         priceChange: '0.00068700',
        //         priceChangePercent: '2.075',
        //         weightedAvgPrice: '0.03342681',
        //         prevClosePrice: '0.03310300',
        //         lastPrice: '0.03378900',
        //         lastQty: '0.07700000',
        //         bidPrice: '0.03378900',
        //         bidQty: '7.16800000',
        //         askPrice: '0.03379000',
        //         askQty: '24.00000000',
        //         openPrice: '0.03310200',
        //         highPrice: '0.03388900',
        //         lowPrice: '0.03306900',
        //         volume: '205478.41000000',
        //         quoteVolume: '6868.48826294',
        //         openTime: 1601469986932,
        //         closeTime: 1601556386932,
        //         firstId: 196098772,
        //         lastId: 196186315,
        //         count: 87544
        //     }
        //
        // coinm
        //     {
        //         baseVolume: '214549.95171161',
        //         closeTime: '1621965286847',
        //         count: '1283779',
        //         firstId: '152560106',
        //         highPrice: '39938.3',
        //         lastId: '153843955',
        //         lastPrice: '37993.4',
        //         lastQty: '1',
        //         lowPrice: '36457.2',
        //         openPrice: '37783.4',
        //         openTime: '1621878840000',
        //         pair: 'BTCUSD',
        //         priceChange: '210.0',
        //         priceChangePercent: '0.556',
        //         symbol: 'BTCUSD_PERP',
        //         volume: '81990451',
        //         weightedAvgPrice: '38215.08713747'
        //     }
        // spot bidsAsks
        //     {
        //         "symbol":"ETHBTC",
        //         "bidPrice":"0.07466800",
        //         "bidQty":"5.31990000",
        //         "askPrice":"0.07466900",
        //         "askQty":"10.93540000"
        //     }
        // usdm bidsAsks
        //     {
        //         "symbol":"BTCUSDT",
        //         "bidPrice":"21321.90",
        //         "bidQty":"33.592",
        //         "askPrice":"21322.00",
        //         "askQty":"1.427",
        //         "time":"1673899207538"
        //     }
        // coinm bidsAsks
        //     {
        //         "symbol":"BTCUSD_PERP",
        //         "pair":"BTCUSD",
        //         "bidPrice":"21301.2",
        //         "bidQty":"188",
        //         "askPrice":"21301.3",
        //         "askQty":"10302",
        //         "time":"1673899278514"
        //     }
        //
        object timestamp = this.safeInteger(ticker, "closeTime");
        object marketType = null;
        if (isTrue((((Dictionary<string,object>)ticker).ContainsKey(toStringOrNull("time")))))
        {
            marketType = "contract";
        }
        if (isTrue(isEqual(marketType, null)))
        {
            marketType = ((bool) isTrue((((Dictionary<string,object>)ticker).ContainsKey(toStringOrNull("bidQty"))))) ? "spot" : "contract";
        }
        object marketId = this.safeString(ticker, "symbol");
        object symbol = this.safeSymbol(marketId, market, null, marketType);
        object last = this.safeString(ticker, "lastPrice");
        object isCoinm = (((Dictionary<string,object>)ticker).ContainsKey(toStringOrNull("baseVolume")));
        object baseVolume = null;
        object quoteVolume = null;
        if (isTrue(isCoinm))
        {
            baseVolume = this.safeString(ticker, "baseVolume");
            quoteVolume = this.safeString(ticker, "volume");
        } else
        {
            baseVolume = this.safeString(ticker, "volume");
            quoteVolume = this.safeString(ticker, "quoteVolume");
        }
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(ticker, "highPrice") },
            { "low", this.safeString(ticker, "lowPrice") },
            { "bid", this.safeString(ticker, "bidPrice") },
            { "bidVolume", this.safeString(ticker, "bidQty") },
            { "ask", this.safeString(ticker, "askPrice") },
            { "askVolume", this.safeString(ticker, "askQty") },
            { "vwap", this.safeString(ticker, "weightedAvgPrice") },
            { "open", this.safeString(ticker, "openPrice") },
            { "close", last },
            { "last", last },
            { "previousClose", this.safeString(ticker, "prevClosePrice") },
            { "change", this.safeString(ticker, "priceChange") },
            { "percentage", this.safeString(ticker, "priceChangePercent") },
            { "average", null },
            { "baseVolume", baseVolume },
            { "quoteVolume", quoteVolume },
            { "info", ticker },
        }, market);
    }

    public async override Task<object> fetchStatus(object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchStatus
        * @description the latest known information on the availability of the exchange API
        * @see https://binance-docs.github.io/apidocs/spot/en/#system-status-system
        * @param {object} params extra parameters specific to the binance api endpoint
        * @returns {object} a [status structure]{@link https://docs.ccxt.com/#/?id=exchange-status-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object response = await this.sapiGetSystemStatus(parameters);
        //
        //     {
        //         "status": 0,              // 0: normal1system maintenance
        //         "msg": "normal"           // "normal", "system_maintenance"
        //     }
        //
        object statusRaw = this.safeString(response, "status");
        return new Dictionary<string, object>() {
            { "status", this.safeString(new Dictionary<string, object>() {
                { "0", "ok" },
                { "1", "maintenance" },
            }, statusRaw, statusRaw) },
            { "updated", null },
            { "eta", null },
            { "url", null },
            { "info", response },
        };
    }

    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchTicker
        * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        * @see https://binance-docs.github.io/apidocs/spot/en/#24hr-ticker-price-change-statistics         // spot
        * @see https://binance-docs.github.io/apidocs/futures/en/#24hr-ticker-price-change-statistics      // swap
        * @see https://binance-docs.github.io/apidocs/delivery/en/#24hr-ticker-price-change-statistics     // future
        * @param {string} symbol unified symbol of the market to fetch the ticker for
        * @param {object} params extra parameters specific to the binance api endpoint
        * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object method = "publicGetTicker24hr";
        if (isTrue(getValue(market, "linear")))
        {
            method = "fapiPublicGetTicker24hr";
        } else if (isTrue(getValue(market, "inverse")))
        {
            method = "dapiPublicGetTicker24hr";
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        if (isTrue((response.GetType().IsGenericType && response.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))
        {
            object firstTicker = this.safeValue(response, 0, new Dictionary<string, object>() {});
            return this.parseTicker(firstTicker, market);
        }
        return this.parseTicker(response, market);
    }

    public async override Task<object> fetchBidsAsks(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchBidsAsks
        * @description fetches the bid and ask price and volume for multiple markets
        * @see https://binance-docs.github.io/apidocs/spot/en/#symbol-order-book-ticker        // spot
        * @see https://binance-docs.github.io/apidocs/futures/en/#symbol-order-book-ticker     // swap
        * @see https://binance-docs.github.io/apidocs/delivery/en/#symbol-order-book-ticker    // future
        * @param {[string]|undefined} symbols unified symbols of the markets to fetch the bids and asks for, all markets are returned if not assigned
        * @param {object} params extra parameters specific to the binance api endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object market = null;
        if (isTrue(!isEqual(symbols, null)))
        {
            object first = this.safeString(symbols, 0);
            market = this.market(first);
        }
        object type = null;
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchBidsAsks", market, parameters);
        subType = ((List<object>)subTypeparametersVariable)[0];
        parameters = ((List<object>)subTypeparametersVariable)[1];
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchBidsAsks", market, parameters);
        type = ((List<object>)typeparametersVariable)[0];
        parameters = ((List<object>)typeparametersVariable)[1];
        object method = null;
        if (isTrue(this.isLinear(type, subType)))
        {
            method = "fapiPublicGetTickerBookTicker";
        } else if (isTrue(this.isInverse(type, subType)))
        {
            method = "dapiPublicGetTickerBookTicker";
        } else
        {
            method = "publicGetTickerBookTicker";
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { parameters }));
        return this.parseTickers(response, symbols);
    }

    public async override Task<object> fetchLastPrices(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchLastPrices
        * @description fetches the last price for multiple markets
        * @see https://binance-docs.github.io/apidocs/spot/en/#symbol-price-ticker         // spot
        * @see https://binance-docs.github.io/apidocs/future/en/#symbol-price-ticker       // swap
        * @see https://binance-docs.github.io/apidocs/delivery/en/#symbol-price-ticker     // future
        * @param {[string]|undefined} symbols unified symbols of the markets to fetch the last prices
        * @param {object} params extra parameters specific to the binance api endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.getMarketFromSymbols(symbols);
        var marketTypequeryVariable = this.handleMarketTypeAndParams("fetchLastPrices", market, parameters);
        var marketType = ((List<object>) marketTypequeryVariable)[0];
        var query = ((List<object>) marketTypequeryVariable)[1];
        object method = null;
        if (isTrue(isEqual(marketType, "future")))
        {
            method = "fapiPublicGetTickerPrice";
        } else if (isTrue(isEqual(marketType, "delivery")))
        {
            method = "dapiPublicGetTickerPrice";
        } else if (isTrue(isEqual(marketType, "spot")))
        {
            method = "publicGetTickerPrice";
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchLastPrices() does not support "), marketType), " markets yet")) ;
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { query }));
        return this.parseLastPrices(response, symbols);
    }

    public override object parseLastPrice(object info, object market = null)
    {
        //
        // spot
        //
        //     {
        //         "symbol": "LTCBTC",
        //         "price": "4.00000200"
        //     }
        //
        // usdm (swap/future)
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "price": "6000.01",
        //         "time": 1589437530011   // Transaction time
        //     }
        //
        //
        // coinm (swap/future)
        //
        //     {
        //         "symbol": "BTCUSD_200626", // symbol ("BTCUSD_200626", "BTCUSD_PERP", etc..)
        //         "ps": "BTCUSD", // pair
        //         "price": "9647.8",
        //         "time": 1591257246176
        //     }
        //
        object marketId = this.safeString(info, "symbol");
        object defaultType = this.safeString(this.options, "defaultType", "spot");
        market = this.safeMarket(marketId, market, null, defaultType);
        object timestamp = this.safeInteger(info, "time");
        object price = this.safeNumber(info, "price");
        return new Dictionary<string, object>() {
            { "symbol", getValue(market, "symbol") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "price", price },
            { "side", null },
            { "baseVolume", null },
            { "quoteVolume", null },
            { "info", info },
        };
    }

    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchTickers
        * @description fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
        * @see https://binance-docs.github.io/apidocs/spot/en/#24hr-ticker-price-change-statistics         // spot
        * @see https://binance-docs.github.io/apidocs/futures/en/#24hr-ticker-price-change-statistics      // swap
        * @see https://binance-docs.github.io/apidocs/delivery/en/#24hr-ticker-price-change-statistics     // future
        * @param {[string]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        * @param {object} params extra parameters specific to the binance api endpoint
        * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object defaultType = this.safeString2(this.options, "fetchTickers", "defaultType", "spot");
        object type = this.safeString(parameters, "type", defaultType);
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchTickers", null, parameters);
        subType = ((List<object>)subTypeparametersVariable)[0];
        parameters = ((List<object>)subTypeparametersVariable)[1];
        object query = this.omit(parameters, "type");
        object defaultMethod = null;
        if (isTrue(this.isLinear(type, subType)))
        {
            defaultMethod = "fapiPublicGetTicker24hr";
        } else if (isTrue(this.isInverse(type, subType)))
        {
            defaultMethod = "dapiPublicGetTicker24hr";
        } else
        {
            defaultMethod = "publicGetTicker24hr";
        }
        object method = this.safeString(this.options, "fetchTickersMethod", defaultMethod);
        object response = await ((Task<object>)callDynamically(this, method, new object[] { query }));
        return this.parseTickers(response, symbols);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        // when api method = publicGetKlines || fapiPublicGetKlines || dapiPublicGetKlines
        //     [
        //         1591478520000, // open time
        //         "0.02501300",  // open
        //         "0.02501800",  // high
        //         "0.02500000",  // low
        //         "0.02500000",  // close
        //         "22.19000000", // volume
        //         1591478579999, // close time
        //         "0.55490906",  // quote asset volume, base asset volume for dapi
        //         40,            // number of trades
        //         "10.92900000", // taker buy base asset volume
        //         "0.27336462",  // taker buy quote asset volume
        //         "0"            // ignore
        //     ]
        //
        //  when api method = fapiPublicGetMarkPriceKlines || fapiPublicGetIndexPriceKlines
        //     [
        //         [
        //         1591256460000,          // Open time
        //         "9653.29201333",        // Open
        //         "9654.56401333",        // High
        //         "9653.07367333",        // Low
        //         "9653.07367333",        // Close (or latest price)
        //         "0",                    // Ignore
        //         1591256519999,          // Close time
        //         "0",                    // Ignore
        //         60,                     // Number of bisic data
        //         "0",                    // Ignore
        //         "0",                    // Ignore
        //         "0"                     // Ignore
        //         ]
        //     ]
        //
        // options
        //
        //     {
        //         "open": "32.2",
        //         "high": "32.2",
        //         "low": "32.2",
        //         "close": "32.2",
        //         "volume": "0",
        //         "interval": "5m",
        //         "tradeCount": 0,
        //         "takerVolume": "0",
        //         "takerAmount": "0",
        //         "amount": "0",
        //         "openTime": 1677096900000,
        //         "closeTime": 1677097200000
        //     }
        //
        object volumeIndex = ((bool) isTrue((getValue(market, "inverse")))) ? 7 : 5;
        return new List<object> {this.safeInteger2(ohlcv, 0, "closeTime"), this.safeNumber2(ohlcv, 1, "open"), this.safeNumber2(ohlcv, 2, "high"), this.safeNumber2(ohlcv, 3, "low"), this.safeNumber2(ohlcv, 4, "close"), this.safeNumber2(ohlcv, volumeIndex, "volume")};
    }

    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchOHLCV
        * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int|undefined} since timestamp in ms of the earliest candle to fetch
        * @param {int|undefined} limit the maximum amount of candles to fetch
        * @param {object} params extra parameters specific to the binance api endpoint
        * @param {string|undefined} params.price "mark" or "index" for mark price and index price candles
        * @param {int|undefined} params.until timestamp in ms of the latest candle to fetch
        * @returns {[[int]]} A list of candles ordered as timestamp, open, high, low, close, volume
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        // binance docs say that the default limit 500, max 1500 for futures, max 1000 for spot markets
        // the reality is that the time range wider than 500 candles won't work right
        object defaultLimit = 500;
        object maxLimit = 1500;
        object price = this.safeString(parameters, "price");
        object until = this.safeInteger(parameters, "until");
        parameters = this.omit(parameters, new List<object>() {"price", "until"});
        limit = ((bool) isTrue((isEqual(limit, null)))) ? defaultLimit : mathMin(limit, maxLimit);
        object request = new Dictionary<string, object>() {
            { "interval", this.safeString(this.timeframes, timeframe, timeframe) },
            { "limit", limit },
        };
        if (isTrue(isEqual(price, "index")))
        {
            ((Dictionary<string, object>)request)["pair"] = getValue(market, "id"); // Index price takes this argument instead of symbol
        } else
        {
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
        }
        // const duration = this.parseTimeframe (timeframe);
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["startTime"] = since;
            //
            // It didn't work before without the endTime
            // https://github.com/ccxt/ccxt/issues/8454
            //
            if (isTrue(getValue(market, "inverse")))
            {
                if (isTrue(isGreaterThan(since, 0)))
                {
                    object duration = this.parseTimeframe(timeframe);
                    object endTime = this.sum(since, subtract(multiply(multiply(limit, duration), 1000), 1));
                    object now = this.milliseconds();
                    ((Dictionary<string, object>)request)["endTime"] = mathMin(now, endTime);
                }
            }
        }
        if (isTrue(!isEqual(until, null)))
        {
            ((Dictionary<string, object>)request)["endTime"] = until;
        }
        object method = "publicGetKlines";
        if (isTrue(getValue(market, "option")))
        {
            method = "eapiPublicGetKlines";
        } else if (isTrue(isEqual(price, "mark")))
        {
            if (isTrue(getValue(market, "inverse")))
            {
                method = "dapiPublicGetMarkPriceKlines";
            } else
            {
                method = "fapiPublicGetMarkPriceKlines";
            }
        } else if (isTrue(isEqual(price, "index")))
        {
            if (isTrue(getValue(market, "inverse")))
            {
                method = "dapiPublicGetIndexPriceKlines";
            } else
            {
                method = "fapiPublicGetIndexPriceKlines";
            }
        } else if (isTrue(getValue(market, "linear")))
        {
            method = "fapiPublicGetKlines";
        } else if (isTrue(getValue(market, "inverse")))
        {
            method = "dapiPublicGetKlines";
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        //     [
        //         [1591478520000,"0.02501300","0.02501800","0.02500000","0.02500000","22.19000000",1591478579999,"0.55490906",40,"10.92900000","0.27336462","0"],
        //         [1591478580000,"0.02499600","0.02500900","0.02499400","0.02500300","21.34700000",1591478639999,"0.53370468",24,"7.53800000","0.18850725","0"],
        //         [1591478640000,"0.02500800","0.02501100","0.02500300","0.02500800","154.14200000",1591478699999,"3.85405839",97,"5.32300000","0.13312641","0"],
        //     ]
        //
        // options (eapi)
        //
        //     [
        //         {
        //             "open": "32.2",
        //             "high": "32.2",
        //             "low": "32.2",
        //             "close": "32.2",
        //             "volume": "0",
        //             "interval": "5m",
        //             "tradeCount": 0,
        //             "takerVolume": "0",
        //             "takerAmount": "0",
        //             "amount": "0",
        //             "openTime": 1677096900000,
        //             "closeTime": 1677097200000
        //         }
        //     ]
        //
        return this.parseOHLCVs(response, market, timeframe, since, limit);
    }

    public override object parseTrade(object trade, object market = null)
    {
        if (isTrue(((Dictionary<string,object>)trade).ContainsKey(toStringOrNull("isDustTrade"))))
        {
            return this.parseDustTrade(trade, market);
        }
        //
        // aggregate trades
        // https://github.com/binance-exchange/binance-official-api-docs/blob/master/rest-api.md#compressedaggregate-trades-list
        //
        //     {
        //         "a": 26129,         // Aggregate tradeId
        //         "p": "0.01633102",  // Price
        //         "q": "4.70443515",  // Quantity
        //         "f": 27781,         // First tradeId
        //         "l": 27781,         // Last tradeId
        //         "T": 1498793709153, // Timestamp
        //         "m": true,          // Was the buyer the maker?
        //         "M": true           // Was the trade the best price match?
        //     }
        //
        // recent public trades and old public trades
        // https://github.com/binance-exchange/binance-official-api-docs/blob/master/rest-api.md#recent-trades-list
        // https://github.com/binance-exchange/binance-official-api-docs/blob/master/rest-api.md#old-trade-lookup-market_data
        //
        //     {
        //         "id": 28457,
        //         "price": "4.00000100",
        //         "qty": "12.00000000",
        //         "time": 1499865549590,
        //         "isBuyerMaker": true,
        //         "isBestMatch": true
        //     }
        //
        // private trades
        // https://github.com/binance-exchange/binance-official-api-docs/blob/master/rest-api.md#account-trade-list-user_data
        //
        //     {
        //         "symbol": "BNBBTC",
        //         "id": 28457,
        //         "orderId": 100234,
        //         "price": "4.00000100",
        //         "qty": "12.00000000",
        //         "commission": "10.10000000",
        //         "commissionAsset": "BNB",
        //         "time": 1499865549590,
        //         "isBuyer": true,
        //         "isMaker": false,
        //         "isBestMatch": true
        //     }
        //
        // futures trades
        // https://binance-docs.github.io/apidocs/futures/en/#account-trade-list-user_data
        //
        //     {
        //       "accountId": 20,
        //       "buyer": False,
        //       "commission": "-0.07819010",
        //       "commissionAsset": "USDT",
        //       "counterPartyId": 653,
        //       "id": 698759,
        //       "maker": False,
        //       "orderId": 25851813,
        //       "price": "7819.01",
        //       "qty": "0.002",
        //       "quoteQty": "0.01563",
        //       "realizedPnl": "-0.91539999",
        //       "side": "SELL",
        //       "symbol": "BTCUSDT",
        //       "time": 1569514978020
        //     }
        //     {
        //       "symbol": "BTCUSDT",
        //       "id": 477128891,
        //       "orderId": 13809777875,
        //       "side": "SELL",
        //       "price": "38479.55",
        //       "qty": "0.001",
        //       "realizedPnl": "-0.00009534",
        //       "marginAsset": "USDT",
        //       "quoteQty": "38.47955",
        //       "commission": "-0.00076959",
        //       "commissionAsset": "USDT",
        //       "time": 1612733566708,
        //       "positionSide": "BOTH",
        //       "maker": true,
        //       "buyer": false
        //     }
        //
        // { respType: FULL }
        //
        //     {
        //       "price": "4000.00000000",
        //       "qty": "1.00000000",
        //       "commission": "4.00000000",
        //       "commissionAsset": "USDT",
        //       "tradeId": "1234",
        //     }
        //
        // options: fetchMyTrades
        //
        //     {
        //         "id": 1125899906844226012,
        //         "tradeId": 73,
        //         "orderId": 4638761100843040768,
        //         "symbol": "ETH-230211-1500-C",
        //         "price": "18.70000000",
        //         "quantity": "-0.57000000",
        //         "fee": "0.17305890",
        //         "realizedProfit": "-3.53400000",
        //         "side": "SELL",
        //         "type": "LIMIT",
        //         "volatility": "0.30000000",
        //         "liquidity": "MAKER",
        //         "time": 1676085216845,
        //         "priceScale": 1,
        //         "quantityScale": 2,
        //         "optionSide": "CALL",
        //         "quoteAsset": "USDT"
        //     }
        //
        // options: fetchTrades
        //
        //     {
        //         "id": 1,
        //         "symbol": "ETH-230216-1500-C",
        //         "price": "35.5",
        //         "qty": "0.03",
        //         "quoteQty": "1.065",
        //         "side": 1,
        //         "time": 1676366446072
        //     }
        //
        object timestamp = this.safeInteger2(trade, "T", "time");
        object price = this.safeString2(trade, "p", "price");
        object amount = this.safeString2(trade, "q", "qty");
        amount = this.safeString(trade, "quantity", amount);
        object cost = this.safeString2(trade, "quoteQty", "baseQty"); // inverse futures
        object marketId = this.safeString(trade, "symbol");
        object isSpotTrade = isTrue(isTrue((((Dictionary<string,object>)trade).ContainsKey(toStringOrNull("isIsolated")))) || isTrue((((Dictionary<string,object>)trade).ContainsKey(toStringOrNull("M"))))) || isTrue((((Dictionary<string,object>)trade).ContainsKey(toStringOrNull("orderListId"))));
        object marketType = ((bool) isTrue(isSpotTrade)) ? "spot" : "contract";
        market = this.safeMarket(marketId, market, null, marketType);
        object symbol = getValue(market, "symbol");
        object id = this.safeString2(trade, "t", "a");
        id = this.safeString2(trade, "tradeId", "id", id);
        object side = null;
        object orderId = this.safeString(trade, "orderId");
        object buyerMaker = this.safeValue2(trade, "m", "isBuyerMaker");
        object takerOrMaker = null;
        if (isTrue(!isEqual(buyerMaker, null)))
        {
            side = ((bool) isTrue(buyerMaker)) ? "sell" : "buy"; // this is reversed intentionally
        } else if (isTrue(((Dictionary<string,object>)trade).ContainsKey(toStringOrNull("side"))))
        {
            side = this.safeStringLower(trade, "side");
        } else
        {
            if (isTrue(((Dictionary<string,object>)trade).ContainsKey(toStringOrNull("isBuyer"))))
            {
                side = ((bool) isTrue(getValue(trade, "isBuyer"))) ? "buy" : "sell"; // this is a true side
            }
        }
        object fee = null;
        if (isTrue(((Dictionary<string,object>)trade).ContainsKey(toStringOrNull("commission"))))
        {
            fee = new Dictionary<string, object>() {
                { "cost", this.safeString(trade, "commission") },
                { "currency", this.safeCurrencyCode(this.safeString(trade, "commissionAsset")) },
            };
        }
        if (isTrue(((Dictionary<string,object>)trade).ContainsKey(toStringOrNull("isMaker"))))
        {
            takerOrMaker = ((bool) isTrue(getValue(trade, "isMaker"))) ? "maker" : "taker";
        }
        if (isTrue(((Dictionary<string,object>)trade).ContainsKey(toStringOrNull("maker"))))
        {
            takerOrMaker = ((bool) isTrue(getValue(trade, "maker"))) ? "maker" : "taker";
        }
        if (isTrue(isTrue((((Dictionary<string,object>)trade).ContainsKey(toStringOrNull("optionSide")))) || isTrue(getValue(market, "option"))))
        {
            object settle = this.safeCurrencyCode(this.safeString(trade, "quoteAsset", "USDT"));
            takerOrMaker = this.safeStringLower(trade, "liquidity");
            if (isTrue(((Dictionary<string,object>)trade).ContainsKey(toStringOrNull("fee"))))
            {
                fee = new Dictionary<string, object>() {
                    { "cost", this.safeString(trade, "fee") },
                    { "currency", settle },
                };
            }
            if (isTrue(isTrue((!isEqual(side, "buy"))) && isTrue((!isEqual(side, "sell")))))
            {
                side = ((bool) isTrue((isEqual(side, "1")))) ? "buy" : "sell";
            }
            if (isTrue(((Dictionary<string,object>)trade).ContainsKey(toStringOrNull("optionSide"))))
            {
                if (isTrue(!isEqual(side, "buy")))
                {
                    amount = Precise.stringMul("-1", amount);
                }
            }
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "info", trade },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "id", id },
            { "order", orderId },
            { "type", this.safeStringLower(trade, "type") },
            { "side", side },
            { "takerOrMaker", takerOrMaker },
            { "price", price },
            { "amount", amount },
            { "cost", cost },
            { "fee", fee },
        }, market);
    }

    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchTrades
        * @description get the list of most recent trades for a particular symbol
        * Default fetchTradesMethod
        * @see https://binance-docs.github.io/apidocs/spot/en/#compressed-aggregate-trades-list        // publicGetAggTrades (spot)
        * @see https://binance-docs.github.io/apidocs/futures/en/#compressed-aggregate-trades-list     // fapiPublicGetAggTrades (swap)
        * @see https://binance-docs.github.io/apidocs/delivery/en/#compressed-aggregate-trades-list    // dapiPublicGetAggTrades (future)
        * @see https://binance-docs.github.io/apidocs/voptions/en/#recent-trades-list                  // eapiPublicGetTrades (option)
        * Other fetchTradesMethod
        * @see https://binance-docs.github.io/apidocs/spot/en/#recent-trades-list                      // publicGetTrades (spot)
        * @see https://binance-docs.github.io/apidocs/futures/en/#recent-trades-list                   // fapiPublicGetTrades (swap)
        * @see https://binance-docs.github.io/apidocs/delivery/en/#recent-trades-list                  // dapiPublicGetTrades (future)
        * @see https://binance-docs.github.io/apidocs/spot/en/#old-trade-lookup-market_data            // publicGetHistoricalTrades (spot)
        * @see https://binance-docs.github.io/apidocs/future/en/#old-trade-lookup-market_data          // fapiPublicGetHistoricalTrades (swap)
        * @see https://binance-docs.github.io/apidocs/delivery/en/#old-trade-lookup-market_data        // dapiPublicGetHistoricalTrades (future)
        * @see https://binance-docs.github.io/apidocs/voptions/en/#old-trade-lookup-market_data        // eapiPublicGetHistoricalTrades (option)
        * @param {string} symbol unified symbol of the market to fetch trades for
        * @param {int|undefined} since only used when fetchTradesMethod is 'publicGetAggTrades', 'fapiPublicGetAggTrades', or 'dapiPublicGetAggTrades'
        * @param {int|undefined} limit default 500, max 1000
        * @param {object} params extra parameters specific to the binance api endpoint
        * @param {int|undefined} params.until only used when fetchTradesMethod is 'publicGetAggTrades', 'fapiPublicGetAggTrades', or 'dapiPublicGetAggTrades'
        * @param {int|undefined} params.fetchTradesMethod 'publicGetAggTrades' (spot default), 'fapiPublicGetAggTrades' (swap default), 'dapiPublicGetAggTrades' (future default), 'eapiPublicGetTrades' (option default), 'publicGetTrades', 'fapiPublicGetTrades', 'dapiPublicGetTrades', 'publicGetHistoricalTrades', 'fapiPublicGetHistoricalTrades', 'dapiPublicGetHistoricalTrades', 'eapiPublicGetHistoricalTrades'
        *
        * EXCHANGE SPECIFIC PARAMETERS
        * @param {int|undefined} params.fromId trade id to fetch from, default gets most recent trades, not used when fetchTradesMethod is 'publicGetTrades', 'fapiPublicGetTrades', 'dapiPublicGetTrades', or 'eapiPublicGetTrades'
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/en/latest/manual.html?#public-trades}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object method = this.safeString(this.options, "fetchTradesMethod");
        method = this.safeString2(parameters, "fetchTradesMethod", "method", method);
        if (isTrue(isEqual(method, null)))
        {
            if (isTrue(getValue(market, "option")))
            {
                method = "eapiPublicGetTrades";
            } else if (isTrue(getValue(market, "linear")))
            {
                method = "fapiPublicGetAggTrades";
            } else if (isTrue(getValue(market, "inverse")))
            {
                method = "dapiPublicGetAggTrades";
            } else
            {
                method = "publicGetAggTrades";
            }
        }
        if (!isTrue(getValue(market, "option")))
        {
            if (isTrue(!isEqual(since, null)))
            {
                ((Dictionary<string, object>)request)["startTime"] = since;
                // https://github.com/ccxt/ccxt/issues/6400
                // https://github.com/binance-exchange/binance-official-api-docs/blob/master/rest-api.md#compressedaggregate-trades-list
                ((Dictionary<string, object>)request)["endTime"] = this.sum(since, 3600000);
            }
            object until = this.safeInteger(parameters, "until");
            if (isTrue(!isEqual(until, null)))
            {
                ((Dictionary<string, object>)request)["endTime"] = until;
            }
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit; // default = 500, maximum = 1000
        }
        parameters = this.omit(parameters, new List<object>() {"until", "fetchTradesMethod"});
        //
        // Caveats:
        // - default limit (500) applies only if no other parameters set, trades up
        //   to the maximum limit may be returned to satisfy other parameters
        // - if both limit and time window is set and time window contains more
        //   trades than the limit then the last trades from the window are returned
        // - 'tradeId' accepted and returned by this method is "aggregate" trade id
        //   which is different from actual trade id
        // - setting both fromId and time window results in error
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        // aggregate trades
        //
        //     [
        //         {
        //             "a": 26129,         // Aggregate tradeId
        //             "p": "0.01633102",  // Price
        //             "q": "4.70443515",  // Quantity
        //             "f": 27781,         // First tradeId
        //             "l": 27781,         // Last tradeId
        //             "T": 1498793709153, // Timestamp
        //             "m": true,          // Was the buyer the maker?
        //             "M": true           // Was the trade the best price match?
        //         }
        //     ]
        //
        // recent public trades and historical public trades
        //
        //     [
        //         {
        //             "id": 28457,
        //             "price": "4.00000100",
        //             "qty": "12.00000000",
        //             "time": 1499865549590,
        //             "isBuyerMaker": true,
        //             "isBestMatch": true
        //         }
        //     ]
        //
        // options (eapi)
        //
        //     [
        //         {
        //             "id": 1,
        //             "symbol": "ETH-230216-1500-C",
        //             "price": "35.5",
        //             "qty": "0.03",
        //             "quoteQty": "1.065",
        //             "side": 1,
        //             "time": 1676366446072
        //         },
        //     ]
        //
        return this.parseTrades(response, market, since, limit);
    }

    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#editOrder
        * @description edit a trade order
        * @see https://binance-docs.github.io/apidocs/spot/en/#cancel-an-existing-order-and-send-a-new-order-trade
        * @param {string} id cancel order id
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float|undefined} price the price at which the order is to be fullfilled, in units of the base currency, ignored in market orders
        * @param {object} params extra parameters specific to the binance api endpoint
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(add(add(this.id, " editOrder() does not support "), getValue(market, "type")), " orders, only spot orders are accepted")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "side", ((string)side).ToUpper() },
            { "cancelReplaceMode", "STOP_ON_FAILURE" },
        };
        object cancelId = this.safeString2(parameters, "cancelNewClientOrderId", "cancelOrigClientOrderId");
        if (isTrue(isEqual(cancelId, null)))
        {
            ((Dictionary<string, object>)request)["cancelOrderId"] = id; // user can provide either cancelOrderId, cancelOrigClientOrderId or cancelOrigClientOrderId
        }
        object clientOrderId = this.safeString2(parameters, "newClientOrderId", "clientOrderId");
        object initialUppercaseType = ((string)type).ToUpper();
        object uppercaseType = initialUppercaseType;
        object postOnly = this.isPostOnly(isEqual(initialUppercaseType, "MARKET"), isEqual(initialUppercaseType, "LIMIT_MAKER"), parameters);
        if (isTrue(postOnly))
        {
            uppercaseType = "LIMIT_MAKER";
        }
        ((Dictionary<string, object>)request)["type"] = uppercaseType;
        object stopPrice = this.safeNumber(parameters, "stopPrice");
        if (isTrue(!isEqual(stopPrice, null)))
        {
            if (isTrue(isEqual(uppercaseType, "MARKET")))
            {
                uppercaseType = "STOP_LOSS";
            } else if (isTrue(isEqual(uppercaseType, "LIMIT")))
            {
                uppercaseType = "STOP_LOSS_LIMIT";
            }
        }
        object validOrderTypes = this.safeValue(getValue(market, "info"), "orderTypes");
        if (!isTrue(this.inArray(uppercaseType, validOrderTypes)))
        {
            if (isTrue(!isEqual(initialUppercaseType, uppercaseType)))
            {
                throw new InvalidOrder ((string)add(add(add(add(add(this.id, " stopPrice parameter is not allowed for "), symbol), " "), type), " orders")) ;
            } else
            {
                throw new InvalidOrder ((string)add(add(add(add(add(this.id, " "), type), " is not a valid order type for the "), symbol), " market")) ;
            }
        }
        if (isTrue(isEqual(clientOrderId, null)))
        {
            object broker = this.safeValue(this.options, "broker");
            if (isTrue(!isEqual(broker, null)))
            {
                object brokerId = this.safeString(broker, "spot");
                if (isTrue(!isEqual(brokerId, null)))
                {
                    ((Dictionary<string, object>)request)["newClientOrderId"] = add(brokerId, this.uuid22());
                }
            }
        } else
        {
            ((Dictionary<string, object>)request)["newClientOrderId"] = clientOrderId;
        }
        ((Dictionary<string, object>)request)["newOrderRespType"] = this.safeValue(getValue(this.options, "newOrderRespType"), type, "RESULT"); // 'ACK' for order id, 'RESULT' for full order or 'FULL' for order with fills
        object timeInForceIsRequired = false;
        object priceIsRequired = false;
        object stopPriceIsRequired = false;
        object quantityIsRequired = false;
        if (isTrue(isEqual(uppercaseType, "MARKET")))
        {
            object quoteOrderQty = this.safeValue(this.options, "quoteOrderQty", true);
            if (isTrue(quoteOrderQty))
            {
                object quoteOrderQtyNew = this.safeValue2(parameters, "quoteOrderQty", "cost");
                object precision = getValue(getValue(market, "precision"), "price");
                if (isTrue(!isEqual(quoteOrderQtyNew, null)))
                {
                    ((Dictionary<string, object>)request)["quoteOrderQty"] = this.decimalToPrecision(quoteOrderQtyNew, TRUNCATE, precision, this.precisionMode);
                } else if (isTrue(!isEqual(price, null)))
                {
                    object amountString = this.numberToString(amount);
                    object priceString = this.numberToString(price);
                    object quoteOrderQuantity = Precise.stringMul(amountString, priceString);
                    ((Dictionary<string, object>)request)["quoteOrderQty"] = this.decimalToPrecision(quoteOrderQuantity, TRUNCATE, precision, this.precisionMode);
                } else
                {
                    quantityIsRequired = true;
                }
            } else
            {
                quantityIsRequired = true;
            }
        } else if (isTrue(isEqual(uppercaseType, "LIMIT")))
        {
            priceIsRequired = true;
            timeInForceIsRequired = true;
            quantityIsRequired = true;
        } else if (isTrue(isTrue((isEqual(uppercaseType, "STOP_LOSS"))) || isTrue((isEqual(uppercaseType, "TAKE_PROFIT")))))
        {
            stopPriceIsRequired = true;
            quantityIsRequired = true;
        } else if (isTrue(isTrue((isEqual(uppercaseType, "STOP_LOSS_LIMIT"))) || isTrue((isEqual(uppercaseType, "TAKE_PROFIT_LIMIT")))))
        {
            quantityIsRequired = true;
            stopPriceIsRequired = true;
            priceIsRequired = true;
            timeInForceIsRequired = true;
        } else if (isTrue(isEqual(uppercaseType, "LIMIT_MAKER")))
        {
            priceIsRequired = true;
            quantityIsRequired = true;
        }
        if (isTrue(quantityIsRequired))
        {
            ((Dictionary<string, object>)request)["quantity"] = this.amountToPrecision(symbol, amount);
        }
        if (isTrue(priceIsRequired))
        {
            if (isTrue(isEqual(price, null)))
            {
                throw new InvalidOrder ((string)add(add(add(this.id, " editOrder() requires a price argument for a "), type), " order")) ;
            }
            ((Dictionary<string, object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        if (isTrue(timeInForceIsRequired))
        {
            ((Dictionary<string, object>)request)["timeInForce"] = getValue(this.options, "defaultTimeInForce"); // 'GTC' = Good To Cancel (default), 'IOC' = Immediate Or Cancel
        }
        if (isTrue(stopPriceIsRequired))
        {
            if (isTrue(isEqual(stopPrice, null)))
            {
                throw new InvalidOrder ((string)add(add(add(this.id, " editOrder() requires a stopPrice extra param for a "), type), " order")) ;
            } else
            {
                ((Dictionary<string, object>)request)["stopPrice"] = this.priceToPrecision(symbol, stopPrice);
            }
        }
        // remove timeInForce from params because PO is only used by this.isPostOnly and it's not a valid value for Binance
        if (isTrue(isEqual(this.safeString(parameters, "timeInForce"), "PO")))
        {
            parameters = this.omit(parameters, new List<object>() {"timeInForce"});
        }
        object requestParams = this.omit(parameters, new List<object>() {"quoteOrderQty", "cost", "stopPrice", "newClientOrderId", "clientOrderId", "postOnly"});
        object response = await this.privatePostOrderCancelReplace(this.extend(request, requestParams));
        //
        //     {
        //         "cancelResult": "SUCCESS",
        //         "newOrderResult": "SUCCESS",
        //         "cancelResponse": {
        //             "symbol": "BTCUSDT",
        //             "origClientOrderId": "web_3f6286480b194b079870ac75fb6978b7",
        //             "orderId": 16383156620,
        //             "orderListId": -1,
        //             "clientOrderId": "Azt6foVTTgHPNhqBf41TTt",
        //             "price": "14000.00000000",
        //             "origQty": "0.00110000",
        //             "executedQty": "0.00000000",
        //             "cummulativeQuoteQty": "0.00000000",
        //             "status": "CANCELED",
        //             "timeInForce": "GTC",
        //             "type": "LIMIT",
        //             "side": "BUY"
        //         },
        //         "newOrderResponse": {
        //             "symbol": "BTCUSDT",
        //             "orderId": 16383176297,
        //             "orderListId": -1,
        //             "clientOrderId": "x-R4BD3S8222ecb58eb9074fb1be018c",
        //             "transactTime": 1670891847932,
        //             "price": "13500.00000000",
        //             "origQty": "0.00085000",
        //             "executedQty": "0.00000000",
        //             "cummulativeQuoteQty": "0.00000000",
        //             "status": "NEW",
        //             "timeInForce": "GTC",
        //             "type": "LIMIT",
        //             "side": "BUY",
        //             "fills": []
        //         }
        //     }
        //
        object data = this.safeValue(response, "newOrderResponse");
        return this.parseOrder(data, market);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "NEW", "open" },
            { "PARTIALLY_FILLED", "open" },
            { "ACCEPTED", "open" },
            { "FILLED", "closed" },
            { "CANCELED", "canceled" },
            { "CANCELLED", "canceled" },
            { "PENDING_CANCEL", "canceling" },
            { "REJECTED", "rejected" },
            { "EXPIRED", "expired" },
            { "EXPIRED_IN_MATCH", "expired" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // spot
        //
        //     {
        //         "symbol": "LTCBTC",
        //         "orderId": 1,
        //         "clientOrderId": "myOrder1",
        //         "price": "0.1",
        //         "origQty": "1.0",
        //         "executedQty": "0.0",
        //         "cummulativeQuoteQty": "0.0",
        //         "status": "NEW",
        //         "timeInForce": "GTC",
        //         "type": "LIMIT",
        //         "side": "BUY",
        //         "stopPrice": "0.0",
        //         "icebergQty": "0.0",
        //         "time": 1499827319559,
        //         "updateTime": 1499827319559,
        //         "isWorking": true
        //     }
        //
        // spot: editOrder
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "orderId": 16383176297,
        //         "orderListId": -1,
        //         "clientOrderId": "x-R4BD3S8222ecb58eb9074fb1be018c",
        //         "transactTime": 1670891847932,
        //         "price": "13500.00000000",
        //         "origQty": "0.00085000",
        //         "executedQty": "0.00000000",
        //         "cummulativeQuoteQty": "0.00000000",
        //         "status": "NEW",
        //         "timeInForce": "GTC",
        //         "type": "LIMIT",
        //         "side": "BUY",
        //         "fills": []
        //     }
        //
        // futures
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "orderId": 1,
        //         "clientOrderId": "myOrder1",
        //         "price": "0.1",
        //         "origQty": "1.0",
        //         "executedQty": "1.0",
        //         "cumQuote": "10.0",
        //         "status": "NEW",
        //         "timeInForce": "GTC",
        //         "type": "LIMIT",
        //         "side": "BUY",
        //         "stopPrice": "0.0",
        //         "updateTime": 1499827319559
        //     }
        //
        // createOrder with { "newOrderRespType": "FULL" }
        //
        //     {
        //       "symbol": "BTCUSDT",
        //       "orderId": 5403233939,
        //       "orderListId": -1,
        //       "clientOrderId": "x-R4BD3S825e669e75b6c14f69a2c43e",
        //       "transactTime": 1617151923742,
        //       "price": "0.00000000",
        //       "origQty": "0.00050000",
        //       "executedQty": "0.00050000",
        //       "cummulativeQuoteQty": "29.47081500",
        //       "status": "FILLED",
        //       "timeInForce": "GTC",
        //       "type": "MARKET",
        //       "side": "BUY",
        //       "fills": [
        //         {
        //           "price": "58941.63000000",
        //           "qty": "0.00050000",
        //           "commission": "0.00007050",
        //           "commissionAsset": "BNB",
        //           "tradeId": 737466631
        //         }
        //       ]
        //     }
        //
        // delivery
        //
        //     {
        //       "orderId": "18742727411",
        //       "symbol": "ETHUSD_PERP",
        //       "pair": "ETHUSD",
        //       "status": "FILLED",
        //       "clientOrderId": "x-xcKtGhcu3e2d1503fdd543b3b02419",
        //       "price": "0",
        //       "avgPrice": "4522.14",
        //       "origQty": "1",
        //       "executedQty": "1",
        //       "cumBase": "0.00221134",
        //       "timeInForce": "GTC",
        //       "type": "MARKET",
        //       "reduceOnly": false,
        //       "closePosition": false,
        //       "side": "SELL",
        //       "positionSide": "BOTH",
        //       "stopPrice": "0",
        //       "workingType": "CONTRACT_PRICE",
        //       "priceProtect": false,
        //       "origType": "MARKET",
        //       "time": "1636061952660",
        //       "updateTime": "1636061952660"
        //     }
        //
        // option: createOrder, fetchOrder, fetchOpenOrders, fetchOrders
        //
        //     {
        //         "orderId": 4728833085436977152,
        //         "symbol": "ETH-230211-1500-C",
        //         "price": "10.0",
        //         "quantity": "1.00",
        //         "executedQty": "0.00",
        //         "fee": "0",
        //         "side": "BUY",
        //         "type": "LIMIT",
        //         "timeInForce": "GTC",
        //         "reduceOnly": false,
        //         "postOnly": false,
        //         "createTime": 1676083034462,
        //         "updateTime": 1676083034462,
        //         "status": "ACCEPTED",
        //         "avgPrice": "0",
        //         "source": "API",
        //         "clientOrderId": "",
        //         "priceScale": 1,
        //         "quantityScale": 2,
        //         "optionSide": "CALL",
        //         "quoteAsset": "USDT",
        //         "lastTrade": {"id":"69","time":"1676084430567","price":"24.9","qty":"1.00"},
        //         "mmp": false
        //     }
        //
        object status = this.parseOrderStatus(this.safeString(order, "status"));
        object marketId = this.safeString(order, "symbol");
        object marketType = ((bool) isTrue((((Dictionary<string,object>)order).ContainsKey(toStringOrNull("closePosition"))))) ? "contract" : "spot";
        object symbol = this.safeSymbol(marketId, market, null, marketType);
        object filled = this.safeString(order, "executedQty", "0");
        object timestamp = null;
        object lastTradeTimestamp = null;
        if (isTrue(((Dictionary<string,object>)order).ContainsKey(toStringOrNull("time"))))
        {
            timestamp = this.safeInteger(order, "time");
        } else if (isTrue(((Dictionary<string,object>)order).ContainsKey(toStringOrNull("workingTime"))))
        {
            lastTradeTimestamp = this.safeInteger(order, "transactTime");
            timestamp = this.safeInteger(order, "workingTime");
        } else if (isTrue(((Dictionary<string,object>)order).ContainsKey(toStringOrNull("transactTime"))))
        {
            lastTradeTimestamp = this.safeInteger(order, "transactTime");
            timestamp = this.safeInteger(order, "transactTime");
        } else if (isTrue(((Dictionary<string,object>)order).ContainsKey(toStringOrNull("createTime"))))
        {
            lastTradeTimestamp = this.safeInteger(order, "updateTime");
            timestamp = this.safeInteger(order, "createTime");
        } else if (isTrue(((Dictionary<string,object>)order).ContainsKey(toStringOrNull("updateTime"))))
        {
            if (isTrue(isEqual(status, "open")))
            {
                if (isTrue(Precise.stringGt(filled, "0")))
                {
                    lastTradeTimestamp = this.safeInteger(order, "updateTime");
                } else
                {
                    timestamp = this.safeInteger(order, "updateTime");
                }
            }
        }
        object average = this.safeString(order, "avgPrice");
        object price = this.safeString(order, "price");
        object amount = this.safeString2(order, "origQty", "quantity");
        // - Spot/Margin market: cummulativeQuoteQty
        // - Futures market: cumQuote.
        //   Note this is not the actual cost, since Binance futures uses leverage to calculate margins.
        object cost = this.safeString2(order, "cummulativeQuoteQty", "cumQuote");
        cost = this.safeString(order, "cumBase", cost);
        object id = this.safeString(order, "orderId");
        object type = this.safeStringLower(order, "type");
        object side = this.safeStringLower(order, "side");
        object fills = this.safeValue(order, "fills", new List<object>() {});
        object clientOrderId = this.safeString(order, "clientOrderId");
        object timeInForce = this.safeString(order, "timeInForce");
        if (isTrue(isEqual(timeInForce, "GTX")))
        {
            // GTX means "Good Till Crossing" and is an equivalent way of saying Post Only
            timeInForce = "PO";
        }
        object postOnly = isTrue((isEqual(type, "limit_maker"))) || isTrue((isEqual(timeInForce, "PO")));
        if (isTrue(isEqual(type, "limit_maker")))
        {
            type = "limit";
        }
        object stopPriceString = this.safeString(order, "stopPrice");
        object stopPrice = this.parseNumber(this.omitZero(stopPriceString));
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", id },
            { "clientOrderId", clientOrderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", lastTradeTimestamp },
            { "symbol", symbol },
            { "type", type },
            { "timeInForce", timeInForce },
            { "postOnly", postOnly },
            { "reduceOnly", this.safeValue(order, "reduceOnly") },
            { "side", side },
            { "price", price },
            { "triggerPrice", stopPrice },
            { "amount", amount },
            { "cost", cost },
            { "average", average },
            { "filled", filled },
            { "remaining", null },
            { "status", status },
            { "fee", new Dictionary<string, object>() {
                { "currency", this.safeString(order, "quoteAsset") },
                { "cost", this.safeNumber(order, "fee") },
                { "rate", null },
            } },
            { "trades", fills },
        }, market);
    }

    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#createOrder
        * @description create a trade order
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market' or 'limit'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float|undefined} price the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        * @param {object} params extra parameters specific to the binance api endpoint
        * @param {string|undefined} params.marginMode 'cross' or 'isolated', for spot margin trading
        * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object marketType = this.safeString(parameters, "type", getValue(market, "type"));
        object clientOrderId = this.safeString2(parameters, "newClientOrderId", "clientOrderId");
        object initialUppercaseType = ((string)type).ToUpper();
        object isMarketOrder = isEqual(initialUppercaseType, "MARKET");
        object isLimitOrder = isEqual(initialUppercaseType, "LIMIT");
        object postOnly = this.isPostOnly(isMarketOrder, isEqual(initialUppercaseType, "LIMIT_MAKER"), parameters);
        object triggerPrice = this.safeValue2(parameters, "triggerPrice", "stopPrice");
        object stopLossPrice = this.safeValue(parameters, "stopLossPrice", triggerPrice); // fallback to stopLoss
        object takeProfitPrice = this.safeValue(parameters, "takeProfitPrice");
        object isStopLoss = !isEqual(stopLossPrice, null);
        object isTakeProfit = !isEqual(takeProfitPrice, null);
        parameters = this.omit(parameters, new List<object>() {"type", "newClientOrderId", "clientOrderId", "postOnly", "stopLossPrice", "takeProfitPrice", "stopPrice", "triggerPrice"});
        var marginModequeryVariable = this.handleMarginModeAndParams("createOrder", parameters);
        var marginMode = ((List<object>) marginModequeryVariable)[0];
        var query = ((List<object>) marginModequeryVariable)[1];
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "side", ((string)side).ToUpper() },
        };
        object method = "privatePostOrder";
        if (isTrue(getValue(market, "linear")))
        {
            method = "fapiPrivatePostOrder";
        } else if (isTrue(getValue(market, "inverse")))
        {
            method = "dapiPrivatePostOrder";
        } else if (isTrue(isTrue(isEqual(marketType, "margin")) || isTrue(!isEqual(marginMode, null))))
        {
            method = "sapiPostMarginOrder";
            object reduceOnly = this.safeValue(parameters, "reduceOnly");
            if (isTrue(reduceOnly))
            {
                ((Dictionary<string, object>)request)["sideEffectType"] = "AUTO_REPAY";
                parameters = this.omit(parameters, "reduceOnly");
            }
        }
        if (isTrue(isTrue(getValue(market, "spot")) || isTrue(isEqual(marketType, "margin"))))
        {
            // support for testing orders
            object test = this.safeValue(query, "test", false);
            if (isTrue(test))
            {
                method = add(method, "Test");
            }
            // only supported for spot/margin api (all margin markets are spot markets)
            if (isTrue(postOnly))
            {
                type = "LIMIT_MAKER";
            }
        }
        object uppercaseType = ((string)type).ToUpper();
        object stopPrice = null;
        if (isTrue(isStopLoss))
        {
            stopPrice = stopLossPrice;
            if (isTrue(isMarketOrder))
            {
                // spot STOP_LOSS market orders are not a valid order type
                uppercaseType = ((bool) isTrue(getValue(market, "contract"))) ? "STOP_MARKET" : "STOP_LOSS";
            } else if (isTrue(isLimitOrder))
            {
                uppercaseType = ((bool) isTrue(getValue(market, "contract"))) ? "STOP" : "STOP_LOSS_LIMIT";
            }
        } else if (isTrue(isTakeProfit))
        {
            stopPrice = takeProfitPrice;
            if (isTrue(isMarketOrder))
            {
                // spot TAKE_PROFIT market orders are not a valid order type
                uppercaseType = ((bool) isTrue(getValue(market, "contract"))) ? "TAKE_PROFIT_MARKET" : "TAKE_PROFIT";
            } else if (isTrue(isLimitOrder))
            {
                uppercaseType = ((bool) isTrue(getValue(market, "contract"))) ? "TAKE_PROFIT" : "TAKE_PROFIT_LIMIT";
            }
        }
        if (isTrue(isEqual(marginMode, "isolated")))
        {
            ((Dictionary<string, object>)request)["isIsolated"] = true;
        }
        if (isTrue(isEqual(clientOrderId, null)))
        {
            object broker = this.safeValue(this.options, "broker");
            if (isTrue(!isEqual(broker, null)))
            {
                object brokerId = this.safeString(broker, marketType);
                if (isTrue(!isEqual(brokerId, null)))
                {
                    ((Dictionary<string, object>)request)["newClientOrderId"] = add(brokerId, this.uuid22());
                }
            }
        } else
        {
            ((Dictionary<string, object>)request)["newClientOrderId"] = clientOrderId;
        }
        if (isTrue(isTrue((isEqual(marketType, "spot"))) || isTrue((isEqual(marketType, "margin")))))
        {
            ((Dictionary<string, object>)request)["newOrderRespType"] = this.safeValue(getValue(this.options, "newOrderRespType"), type, "RESULT"); // 'ACK' for order id, 'RESULT' for full order or 'FULL' for order with fills
        } else
        {
            // swap, futures and options
            ((Dictionary<string, object>)request)["newOrderRespType"] = "RESULT"; // "ACK", "RESULT", default "ACK"
        }
        if (isTrue(getValue(market, "option")))
        {
            if (isTrue(isEqual(type, "market")))
            {
                throw new InvalidOrder ((string)add(add(add(add(add(this.id, " "), type), " is not a valid order type for the "), symbol), " market")) ;
            }
            method = "eapiPrivatePostOrder";
        } else
        {
            object validOrderTypes = this.safeValue(getValue(market, "info"), "orderTypes");
            if (!isTrue(this.inArray(uppercaseType, validOrderTypes)))
            {
                if (isTrue(!isEqual(initialUppercaseType, uppercaseType)))
                {
                    throw new InvalidOrder ((string)add(add(add(add(add(this.id, " stopPrice parameter is not allowed for "), symbol), " "), type), " orders")) ;
                } else
                {
                    throw new InvalidOrder ((string)add(add(add(add(add(this.id, " "), type), " is not a valid order type for the "), symbol), " market")) ;
                }
            }
        }
        ((Dictionary<string, object>)request)["type"] = uppercaseType;
        // additional required fields depending on the order type
        object timeInForceIsRequired = false;
        object priceIsRequired = false;
        object stopPriceIsRequired = false;
        object quantityIsRequired = false;
        //
        // spot/margin
        //
        //     LIMIT                timeInForce, quantity, price
        //     MARKET               quantity or quoteOrderQty
        //     STOP_LOSS            quantity, stopPrice
        //     STOP_LOSS_LIMIT      timeInForce, quantity, price, stopPrice
        //     TAKE_PROFIT          quantity, stopPrice
        //     TAKE_PROFIT_LIMIT    timeInForce, quantity, price, stopPrice
        //     LIMIT_MAKER          quantity, price
        //
        // futures
        //
        //     LIMIT                timeInForce, quantity, price
        //     MARKET               quantity
        //     STOP/TAKE_PROFIT     quantity, price, stopPrice
        //     STOP_MARKET          stopPrice
        //     TAKE_PROFIT_MARKET   stopPrice
        //     TRAILING_STOP_MARKET callbackRate
        //
        if (isTrue(isEqual(uppercaseType, "MARKET")))
        {
            if (isTrue(getValue(market, "spot")))
            {
                object quoteOrderQty = this.safeValue(this.options, "quoteOrderQty", true);
                if (isTrue(quoteOrderQty))
                {
                    object quoteOrderQtyNew = this.safeValue2(query, "quoteOrderQty", "cost");
                    object precision = getValue(getValue(market, "precision"), "price");
                    if (isTrue(!isEqual(quoteOrderQtyNew, null)))
                    {
                        ((Dictionary<string, object>)request)["quoteOrderQty"] = this.decimalToPrecision(quoteOrderQtyNew, TRUNCATE, precision, this.precisionMode);
                    } else if (isTrue(!isEqual(price, null)))
                    {
                        object amountString = this.numberToString(amount);
                        object priceString = this.numberToString(price);
                        object quoteOrderQuantity = Precise.stringMul(amountString, priceString);
                        ((Dictionary<string, object>)request)["quoteOrderQty"] = this.decimalToPrecision(quoteOrderQuantity, TRUNCATE, precision, this.precisionMode);
                    } else
                    {
                        quantityIsRequired = true;
                    }
                } else
                {
                    quantityIsRequired = true;
                }
            } else
            {
                quantityIsRequired = true;
            }
        } else if (isTrue(isEqual(uppercaseType, "LIMIT")))
        {
            priceIsRequired = true;
            timeInForceIsRequired = true;
            quantityIsRequired = true;
        } else if (isTrue(isTrue((isEqual(uppercaseType, "STOP_LOSS"))) || isTrue((isEqual(uppercaseType, "TAKE_PROFIT")))))
        {
            stopPriceIsRequired = true;
            quantityIsRequired = true;
            if (isTrue(isTrue(getValue(market, "linear")) || isTrue(getValue(market, "inverse"))))
            {
                priceIsRequired = true;
            }
        } else if (isTrue(isTrue((isEqual(uppercaseType, "STOP_LOSS_LIMIT"))) || isTrue((isEqual(uppercaseType, "TAKE_PROFIT_LIMIT")))))
        {
            quantityIsRequired = true;
            stopPriceIsRequired = true;
            priceIsRequired = true;
            timeInForceIsRequired = true;
        } else if (isTrue(isEqual(uppercaseType, "LIMIT_MAKER")))
        {
            priceIsRequired = true;
            quantityIsRequired = true;
        } else if (isTrue(isEqual(uppercaseType, "STOP")))
        {
            quantityIsRequired = true;
            stopPriceIsRequired = true;
            priceIsRequired = true;
        } else if (isTrue(isTrue((isEqual(uppercaseType, "STOP_MARKET"))) || isTrue((isEqual(uppercaseType, "TAKE_PROFIT_MARKET")))))
        {
            object closePosition = this.safeValue(query, "closePosition");
            if (isTrue(isEqual(closePosition, null)))
            {
                quantityIsRequired = true;
            }
            stopPriceIsRequired = true;
        } else if (isTrue(isEqual(uppercaseType, "TRAILING_STOP_MARKET")))
        {
            quantityIsRequired = true;
            object callbackRate = this.safeNumber(query, "callbackRate");
            if (isTrue(isEqual(callbackRate, null)))
            {
                throw new InvalidOrder ((string)add(add(add(this.id, " createOrder() requires a callbackRate extra param for a "), type), " order")) ;
            }
        }
        if (isTrue(quantityIsRequired))
        {
            ((Dictionary<string, object>)request)["quantity"] = this.amountToPrecision(symbol, amount);
        }
        if (isTrue(priceIsRequired))
        {
            if (isTrue(isEqual(price, null)))
            {
                throw new InvalidOrder ((string)add(add(add(this.id, " createOrder() requires a price argument for a "), type), " order")) ;
            }
            ((Dictionary<string, object>)request)["price"] = this.priceToPrecision(symbol, price);
        }
        if (isTrue(timeInForceIsRequired))
        {
            ((Dictionary<string, object>)request)["timeInForce"] = getValue(this.options, "defaultTimeInForce"); // 'GTC' = Good To Cancel (default), 'IOC' = Immediate Or Cancel
        }
        if (isTrue(isTrue(getValue(market, "contract")) && isTrue(postOnly)))
        {
            ((Dictionary<string, object>)request)["timeInForce"] = "GTX";
        }
        if (isTrue(stopPriceIsRequired))
        {
            if (isTrue(getValue(market, "contract")))
            {
                if (isTrue(isEqual(stopPrice, null)))
                {
                    throw new InvalidOrder ((string)add(add(add(this.id, " createOrder() requires a stopPrice extra param for a "), type), " order")) ;
                }
            } else
            {
                // check for delta price as well
                object trailingDelta = this.safeValue(parameters, "trailingDelta");
                if (isTrue(isTrue(isEqual(trailingDelta, null)) && isTrue(isEqual(stopPrice, null))))
                {
                    throw new InvalidOrder ((string)add(add(add(this.id, " createOrder() requires a stopPrice or trailingDelta param for a "), type), " order")) ;
                }
            }
            if (isTrue(!isEqual(stopPrice, null)))
            {
                ((Dictionary<string, object>)request)["stopPrice"] = this.priceToPrecision(symbol, stopPrice);
            }
        }
        // remove timeInForce from params because PO is only used by this.isPostOnly and it's not a valid value for Binance
        if (isTrue(isEqual(this.safeString(parameters, "timeInForce"), "PO")))
        {
            parameters = this.omit(parameters, new List<object>() {"timeInForce"});
        }
        object requestParams = this.omit(parameters, new List<object>() {"quoteOrderQty", "cost", "stopPrice", "test", "type", "newClientOrderId", "clientOrderId", "postOnly"});
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, requestParams) }));
        return this.parseOrder(response, market);
    }

    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchOrder
        * @description fetches information on an order made by the user
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} params extra parameters specific to the binance api endpoint
        * @param {string|undefined} params.marginMode 'cross' or 'isolated', for spot margin trading
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredSymbol("fetchOrder", symbol);
        await this.loadMarkets();
        object market = this.market(symbol);
        object defaultType = this.safeString2(this.options, "fetchOrder", "defaultType", "spot");
        object type = this.safeString(parameters, "type", defaultType);
        var marginModequeryVariable = this.handleMarginModeAndParams("fetchOrder", parameters);
        var marginMode = ((List<object>) marginModequeryVariable)[0];
        var query = ((List<object>) marginModequeryVariable)[1];
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object method = "privateGetOrder";
        if (isTrue(getValue(market, "option")))
        {
            method = "eapiPrivateGetOrder";
        } else if (isTrue(getValue(market, "linear")))
        {
            method = "fapiPrivateGetOrder";
        } else if (isTrue(getValue(market, "inverse")))
        {
            method = "dapiPrivateGetOrder";
        } else if (isTrue(isTrue(isEqual(type, "margin")) || isTrue(!isEqual(marginMode, null))))
        {
            method = "sapiGetMarginOrder";
            if (isTrue(isEqual(marginMode, "isolated")))
            {
                ((Dictionary<string, object>)request)["isIsolated"] = true;
            }
        }
        object clientOrderId = this.safeValue2(parameters, "origClientOrderId", "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            if (isTrue(getValue(market, "option")))
            {
                ((Dictionary<string, object>)request)["clientOrderId"] = clientOrderId;
            } else
            {
                ((Dictionary<string, object>)request)["origClientOrderId"] = clientOrderId;
            }
        } else
        {
            ((Dictionary<string, object>)request)["orderId"] = id;
        }
        object requestParams = this.omit(query, new List<object>() {"type", "clientOrderId", "origClientOrderId"});
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, requestParams) }));
        return this.parseOrder(response, market);
    }

    public async override Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchOrders
        * @description fetches information on multiple orders made by the user
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int|undefined} since the earliest time in ms to fetch orders for
        * @param {int|undefined} limit the maximum number of  orde structures to retrieve
        * @param {object} params extra parameters specific to the binance api endpoint
        * @param {string|undefined} params.marginMode 'cross' or 'isolated', for spot margin trading
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredSymbol("fetchOrders", symbol);
        await this.loadMarkets();
        object market = this.market(symbol);
        object defaultType = this.safeString2(this.options, "fetchOrders", "defaultType", "spot");
        object type = this.safeString(parameters, "type", defaultType);
        var marginModequeryVariable = this.handleMarginModeAndParams("fetchOrders", parameters);
        var marginMode = ((List<object>) marginModequeryVariable)[0];
        var query = ((List<object>) marginModequeryVariable)[1];
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object method = "privateGetAllOrders";
        if (isTrue(getValue(market, "option")))
        {
            method = "eapiPrivateGetHistoryOrders";
        } else if (isTrue(getValue(market, "linear")))
        {
            method = "fapiPrivateGetAllOrders";
        } else if (isTrue(getValue(market, "inverse")))
        {
            method = "dapiPrivateGetAllOrders";
        } else if (isTrue(isTrue(isEqual(type, "margin")) || isTrue(!isEqual(marginMode, null))))
        {
            method = "sapiGetMarginAllOrders";
            if (isTrue(isEqual(marginMode, "isolated")))
            {
                ((Dictionary<string, object>)request)["isIsolated"] = true;
            }
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        //
        //  spot
        //
        //     [
        //         {
        //             "symbol": "LTCBTC",
        //             "orderId": 1,
        //             "clientOrderId": "myOrder1",
        //             "price": "0.1",
        //             "origQty": "1.0",
        //             "executedQty": "0.0",
        //             "cummulativeQuoteQty": "0.0",
        //             "status": "NEW",
        //             "timeInForce": "GTC",
        //             "type": "LIMIT",
        //             "side": "BUY",
        //             "stopPrice": "0.0",
        //             "icebergQty": "0.0",
        //             "time": 1499827319559,
        //             "updateTime": 1499827319559,
        //             "isWorking": true
        //         }
        //     ]
        //
        //  futures
        //
        //     [
        //         {
        //             "symbol": "BTCUSDT",
        //             "orderId": 1,
        //             "clientOrderId": "myOrder1",
        //             "price": "0.1",
        //             "origQty": "1.0",
        //             "executedQty": "1.0",
        //             "cumQuote": "10.0",
        //             "status": "NEW",
        //             "timeInForce": "GTC",
        //             "type": "LIMIT",
        //             "side": "BUY",
        //             "stopPrice": "0.0",
        //             "updateTime": 1499827319559
        //         }
        //     ]
        //
        // options
        //
        //     [
        //         {
        //             "orderId": 4728833085436977152,
        //             "symbol": "ETH-230211-1500-C",
        //             "price": "10.0",
        //             "quantity": "1.00",
        //             "executedQty": "0.00",
        //             "fee": "0",
        //             "side": "BUY",
        //             "type": "LIMIT",
        //             "timeInForce": "GTC",
        //             "reduceOnly": false,
        //             "postOnly": false,
        //             "createTime": 1676083034462,
        //             "updateTime": 1676083034462,
        //             "status": "ACCEPTED",
        //             "avgPrice": "0",
        //             "source": "API",
        //             "clientOrderId": "",
        //             "priceScale": 1,
        //             "quantityScale": 2,
        //             "optionSide": "CALL",
        //             "quoteAsset": "USDT",
        //             "lastTrade": {"id":"69","time":"1676084430567","price":"24.9","qty":"1.00"},
        //             "mmp": false
        //         }
        //     ]
        //
        return this.parseOrders(response, market, since, limit);
    }

    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchOpenOrders
        * @description fetch all unfilled currently open orders
        * @param {string|undefined} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch open orders for
        * @param {int|undefined} limit the maximum number of  open orders structures to retrieve
        * @param {object} params extra parameters specific to the binance api endpoint
        * @param {string|undefined} params.marginMode 'cross' or 'isolated', for spot margin trading
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object type = null;
        object request = new Dictionary<string, object>() {};
        object marginMode = null;
        object query = null;
        var marginModequeryVariable = this.handleMarginModeAndParams("fetchOpenOrders", parameters);
        marginMode = ((List<object>)marginModequeryVariable)[0];
        query = ((List<object>)marginModequeryVariable)[1];
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
            object defaultType = this.safeString2(this.options, "fetchOpenOrders", "defaultType", "spot");
            object marketType = ((bool) isTrue((((Dictionary<string,object>)market).ContainsKey(toStringOrNull("type"))))) ? getValue(market, "type") : defaultType;
            type = this.safeString(query, "type", marketType);
        } else if (isTrue(getValue(this.options, "warnOnFetchOpenOrdersWithoutSymbol")))
        {
            object symbols = this.symbols;
            object numSymbols = getArrayLength(symbols);
            object fetchOpenOrdersRateLimit = this.parseToInt(divide(numSymbols, 2));
            throw new ExchangeError ((string)add(add(add(add(add(this.id, " fetchOpenOrders() WARNING: fetching open orders without specifying a symbol is rate-limited to one call per "), ((object)fetchOpenOrdersRateLimit).ToString()), " seconds. Do not call this method frequently to avoid ban. Set "), this.id), ".options[\"warnOnFetchOpenOrdersWithoutSymbol\"] = false to suppress this warning message.")) ;
        } else
        {
            object defaultType = this.safeString2(this.options, "fetchOpenOrders", "defaultType", "spot");
            type = this.safeString(query, "type", defaultType);
        }
        object subType = null;
        var subTypequeryVariable = this.handleSubTypeAndParams("fetchOpenOrders", market, query);
        subType = ((List<object>)subTypequeryVariable)[0];
        query = ((List<object>)subTypequeryVariable)[1];
        object requestParams = this.omit(query, "type");
        object method = "privateGetOpenOrders";
        if (isTrue(isEqual(type, "option")))
        {
            method = "eapiPrivateGetOpenOrders";
            if (isTrue(!isEqual(since, null)))
            {
                ((Dictionary<string, object>)request)["startTime"] = since;
            }
            if (isTrue(!isEqual(limit, null)))
            {
                ((Dictionary<string, object>)request)["limit"] = limit;
            }
        } else if (isTrue(this.isLinear(type, subType)))
        {
            method = "fapiPrivateGetOpenOrders";
        } else if (isTrue(this.isInverse(type, subType)))
        {
            method = "dapiPrivateGetOpenOrders";
        } else if (isTrue(isTrue(isEqual(type, "margin")) || isTrue(!isEqual(marginMode, null))))
        {
            method = "sapiGetMarginOpenOrders";
            if (isTrue(isEqual(marginMode, "isolated")))
            {
                ((Dictionary<string, object>)request)["isIsolated"] = true;
                if (isTrue(isEqual(symbol, null)))
                {
                    throw new ArgumentsRequired ((string)add(this.id, " fetchOpenOrders() requires a symbol argument for isolated markets")) ;
                }
            }
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, requestParams) }));
        return this.parseOrders(response, market, since, limit);
    }

    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchClosedOrders
        * @description fetches information on multiple closed orders made by the user
        * @param {string} symbol unified market symbol of the market orders were made in
        * @param {int|undefined} since the earliest time in ms to fetch orders for
        * @param {int|undefined} limit the maximum number of  orde structures to retrieve
        * @param {object} params extra parameters specific to the binance api endpoint
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object orders = await this.fetchOrders(symbol, since, limit, parameters);
        return this.filterBy(orders, "status", "closed");
    }

    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#cancelOrder
        * @description cancels an open order
        * @param {string} id order id
        * @param {string} symbol unified symbol of the market the order was made in
        * @param {object} params extra parameters specific to the binance api endpoint
        * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredSymbol("cancelOrder", symbol);
        await this.loadMarkets();
        object market = this.market(symbol);
        object defaultType = this.safeString2(this.options, "cancelOrder", "defaultType", "spot");
        object type = this.safeString(parameters, "type", defaultType);
        var marginModequeryVariable = this.handleMarginModeAndParams("cancelOrder", parameters);
        var marginMode = ((List<object>) marginModequeryVariable)[0];
        var query = ((List<object>) marginModequeryVariable)[1];
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object clientOrderId = this.safeValue2(parameters, "origClientOrderId", "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            if (isTrue(getValue(market, "option")))
            {
                ((Dictionary<string, object>)request)["clientOrderId"] = clientOrderId;
            } else
            {
                ((Dictionary<string, object>)request)["origClientOrderId"] = clientOrderId;
            }
        } else
        {
            ((Dictionary<string, object>)request)["orderId"] = id;
        }
        object method = "privateDeleteOrder";
        if (isTrue(getValue(market, "option")))
        {
            method = "eapiPrivateDeleteOrder";
        } else if (isTrue(getValue(market, "linear")))
        {
            method = "fapiPrivateDeleteOrder";
        } else if (isTrue(getValue(market, "inverse")))
        {
            method = "dapiPrivateDeleteOrder";
        } else if (isTrue(isTrue(isEqual(type, "margin")) || isTrue(!isEqual(marginMode, null))))
        {
            method = "sapiDeleteMarginOrder";
            if (isTrue(isEqual(marginMode, "isolated")))
            {
                ((Dictionary<string, object>)request)["isIsolated"] = true;
            }
        }
        object requestParams = this.omit(query, new List<object>() {"type", "origClientOrderId", "clientOrderId"});
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, requestParams) }));
        return this.parseOrder(response, market);
    }

    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#cancelAllOrders
        * @description cancel all open orders in a market
        * @param {string} symbol unified market symbol of the market to cancel orders in
        * @param {object} params extra parameters specific to the binance api endpoint
        * @param {string|undefined} params.marginMode 'cross' or 'isolated', for spot margin trading
        * @returns {[object]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
        */
        parameters ??= new Dictionary<string, object>();
        this.checkRequiredSymbol("cancelAllOrders", symbol);
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object type = this.safeString(parameters, "type", getValue(market, "type"));
        parameters = this.omit(parameters, new List<object>() {"type"});
        var marginModequeryVariable = this.handleMarginModeAndParams("cancelAllOrders", parameters);
        var marginMode = ((List<object>) marginModequeryVariable)[0];
        var query = ((List<object>) marginModequeryVariable)[1];
        object method = "privateDeleteOpenOrders";
        if (isTrue(getValue(market, "option")))
        {
            method = "eapiPrivateDeleteAllOpenOrders";
        } else if (isTrue(getValue(market, "linear")))
        {
            method = "fapiPrivateDeleteAllOpenOrders";
        } else if (isTrue(getValue(market, "inverse")))
        {
            method = "dapiPrivateDeleteAllOpenOrders";
        } else if (isTrue(isTrue((isEqual(type, "margin"))) || isTrue((!isEqual(marginMode, null)))))
        {
            method = "sapiDeleteMarginOpenOrders";
            if (isTrue(isEqual(marginMode, "isolated")))
            {
                ((Dictionary<string, object>)request)["isIsolated"] = true;
            }
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, query) }));
        if (isTrue((response.GetType().IsGenericType && response.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))
        {
            return this.parseOrders(response, market);
        } else
        {
            return response;
        }
    }

    public async override Task<object> fetchOrderTrades(object id, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchOrderTrades
        * @description fetch all the trades made from a single order
        * @param {string} id order id
        * @param {string} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch trades for
        * @param {int|undefined} limit the maximum number of trades to retrieve
        * @param {object} params extra parameters specific to the binance api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " fetchOrderTrades() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object type = this.safeString(parameters, "type", getValue(market, "type"));
        parameters = this.omit(parameters, "type");
        if (isTrue(!isEqual(type, "spot")))
        {
            throw new NotSupported ((string)add(this.id, " fetchOrderTrades() supports spot markets only")) ;
        }
        object request = new Dictionary<string, object>() {
            { "orderId", id },
        };
        return await this.fetchMyTrades(symbol, since, limit, this.extend(request, parameters));
    }

    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchMyTrades
        * @description fetch all trades made by the user
        * @param {string} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch trades for
        * @param {int|undefined} limit the maximum number of trades structures to retrieve
        * @param {object} params extra parameters specific to the binance api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        object type = null;
        object method = null;
        object marginMode = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
        }
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchMyTrades", market, parameters);
        type = ((List<object>)typeparametersVariable)[0];
        parameters = ((List<object>)typeparametersVariable)[1];
        if (isTrue(isEqual(type, "option")))
        {
            method = "eapiPrivateGetUserTrades";
        } else
        {
            this.checkRequiredSymbol("fetchMyTrades", symbol);
            var marginModeparametersVariable = this.handleMarginModeAndParams("fetchMyTrades", parameters);
            marginMode = ((List<object>)marginModeparametersVariable)[0];
            parameters = ((List<object>)marginModeparametersVariable)[1];
            if (isTrue(isTrue(isEqual(type, "spot")) || isTrue(isEqual(type, "margin"))))
            {
                method = "privateGetMyTrades";
                if (isTrue(isTrue((isEqual(type, "margin"))) || isTrue((!isEqual(marginMode, null)))))
                {
                    method = "sapiGetMarginMyTrades";
                    if (isTrue(isEqual(marginMode, "isolated")))
                    {
                        ((Dictionary<string, object>)request)["isIsolated"] = true;
                    }
                }
            } else if (isTrue(getValue(market, "linear")))
            {
                method = "fapiPrivateGetUserTrades";
            } else if (isTrue(getValue(market, "inverse")))
            {
                method = "dapiPrivateGetUserTrades";
            }
        }
        object endTime = this.safeInteger2(parameters, "until", "endTime");
        if (isTrue(!isEqual(since, null)))
        {
            object startTime = since;
            ((Dictionary<string, object>)request)["startTime"] = startTime;
            // https://binance-docs.github.io/apidocs/futures/en/#account-trade-list-user_data
            // If startTime and endTime are both not sent, then the last 7 days' data will be returned.
            // The time between startTime and endTime cannot be longer than 7 days.
            // The parameter fromId cannot be sent with startTime or endTime.
            object currentTimestamp = this.milliseconds();
            object oneWeek = multiply(multiply(multiply(multiply(7, 24), 60), 60), 1000);
            if (isTrue(isGreaterThanOrEqual((subtract(currentTimestamp, startTime)), oneWeek)))
            {
                if (isTrue(isTrue((isEqual(endTime, null))) && isTrue(getValue(market, "linear"))))
                {
                    endTime = this.sum(startTime, oneWeek);
                    endTime = mathMin(endTime, currentTimestamp);
                }
            }
        }
        if (isTrue(!isEqual(endTime, null)))
        {
            ((Dictionary<string, object>)request)["endTime"] = endTime;
            parameters = this.omit(parameters, new List<object>() {"endTime", "until"});
        }
        if (isTrue(!isEqual(limit, null)))
        {
            if (isTrue(isTrue((isEqual(type, "option"))) || isTrue(getValue(market, "contract"))))
            {
                limit = mathMin(limit, 1000); // above 1000, returns error
            }
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        // spot trade
        //
        //     [
        //         {
        //             "symbol": "BNBBTC",
        //             "id": 28457,
        //             "orderId": 100234,
        //             "price": "4.00000100",
        //             "qty": "12.00000000",
        //             "commission": "10.10000000",
        //             "commissionAsset": "BNB",
        //             "time": 1499865549590,
        //             "isBuyer": true,
        //             "isMaker": false,
        //             "isBestMatch": true,
        //         }
        //     ]
        //
        // futures trade
        //
        //     [
        //         {
        //             "accountId": 20,
        //             "buyer": False,
        //             "commission": "-0.07819010",
        //             "commissionAsset": "USDT",
        //             "counterPartyId": 653,
        //             "id": 698759,
        //             "maker": False,
        //             "orderId": 25851813,
        //             "price": "7819.01",
        //             "qty": "0.002",
        //             "quoteQty": "0.01563",
        //             "realizedPnl": "-0.91539999",
        //             "side": "SELL",
        //             "symbol": "BTCUSDT",
        //             "time": 1569514978020
        //         }
        //     ]
        //
        // options (eapi)
        //
        //     [
        //         {
        //             "id": 1125899906844226012,
        //             "tradeId": 73,
        //             "orderId": 4638761100843040768,
        //             "symbol": "ETH-230211-1500-C",
        //             "price": "18.70000000",
        //             "quantity": "-0.57000000",
        //             "fee": "0.17305890",
        //             "realizedProfit": "-3.53400000",
        //             "side": "SELL",
        //             "type": "LIMIT",
        //             "volatility": "0.30000000",
        //             "liquidity": "MAKER",
        //             "time": 1676085216845,
        //             "priceScale": 1,
        //             "quantityScale": 2,
        //             "optionSide": "CALL",
        //             "quoteAsset": "USDT"
        //         }
        //     ]
        //
        return this.parseTrades(response, market, since, limit);
    }

    public async virtual Task<object> fetchMyDustTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchMyDustTrades
        * @description fetch all dust trades made by the user
        * @param {string|undefined} symbol not used by binance fetchMyDustTrades ()
        * @param {int|undefined} since the earliest time in ms to fetch my dust trades for
        * @param {int|undefined} limit the maximum number of dust trades to retrieve
        * @param {object} params extra parameters specific to the binance api endpoint
        * @returns {[object]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
        */
        //
        // Binance provides an opportunity to trade insignificant (i.e. non-tradable and non-withdrawable)
        // token leftovers (of any asset) into `BNB` coin which in turn can be used to pay trading fees with it.
        // The corresponding trades history is called the `Dust Log` and can be requested via the following end-point:
        // https://github.com/binance-exchange/binance-official-api-docs/blob/master/wapi-api.md#dustlog-user_data
        //
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["startTime"] = since;
            ((Dictionary<string, object>)request)["endTime"] = this.sum(since, 7776000000);
        }
        object response = await this.sapiGetAssetDribblet(this.extend(request, parameters));
        //     {
        //       "total": "4",
        //       "userAssetDribblets": [
        //         {
        //           "operateTime": "1627575731000",
        //           "totalServiceChargeAmount": "0.00001453",
        //           "totalTransferedAmount": "0.00072693",
        //           "transId": "70899815863",
        //           "userAssetDribbletDetails": [
        //             {
        //               "fromAsset": "LTC",
        //               "amount": "0.000006",
        //               "transferedAmount": "0.00000267",
        //               "serviceChargeAmount": "0.00000005",
        //               "operateTime": "1627575731000",
        //               "transId": "70899815863"
        //             },
        //             {
        //               "fromAsset": "GBP",
        //               "amount": "0.15949157",
        //               "transferedAmount": "0.00072426",
        //               "serviceChargeAmount": "0.00001448",
        //               "operateTime": "1627575731000",
        //               "transId": "70899815863"
        //             }
        //           ]
        //         },
        //       ]
        //     }
        object results = this.safeValue(response, "userAssetDribblets", new List<object>() {});
        object rows = this.safeInteger(response, "total", 0);
        object data = new List<object>() {};
        for (object i = 0; isLessThan(i, rows); postFixIncrement(ref i))
        {
            object logs = this.safeValue(getValue(results, i), "userAssetDribbletDetails", new List<object>() {});
            for (object j = 0; isLessThan(j, getArrayLength(logs)); postFixIncrement(ref j))
            {
                ((Dictionary<string, object>)getValue(logs, j))["isDustTrade"] = true;
                ((List<object>)data).Add(getValue(logs, j));
            }
        }
        object trades = this.parseTrades(data, null, since, limit);
        return this.filterBySinceLimit(trades, since, limit);
    }

    public virtual object parseDustTrade(object trade, object market = null)
    {
        //
        //     {
        //       "fromAsset": "USDT",
        //       "amount": "0.009669",
        //       "transferedAmount": "0.00002992",
        //       "serviceChargeAmount": "0.00000059",
        //       "operateTime": "1628076010000",
        //       "transId": "71416578712",
        //       "isDustTrade": true
        //     }
        //
        object orderId = this.safeString(trade, "transId");
        object timestamp = this.safeInteger(trade, "operateTime");
        object currencyId = this.safeString(trade, "fromAsset");
        object tradedCurrency = this.safeCurrencyCode(currencyId);
        object bnb = this.currency("BNB");
        object earnedCurrency = getValue(bnb, "code");
        object applicantSymbol = add(add(earnedCurrency, "/"), tradedCurrency);
        object tradedCurrencyIsQuote = false;
        if (isTrue(((Dictionary<string,object>)this.markets).ContainsKey(toStringOrNull(applicantSymbol))))
        {
            tradedCurrencyIsQuote = true;
        }
        object feeCostString = this.safeString(trade, "serviceChargeAmount");
        object fee = new Dictionary<string, object>() {
            { "currency", earnedCurrency },
            { "cost", this.parseNumber(feeCostString) },
        };
        object symbol = null;
        object amountString = null;
        object costString = null;
        object side = null;
        if (isTrue(tradedCurrencyIsQuote))
        {
            symbol = applicantSymbol;
            amountString = this.safeString(trade, "transferedAmount");
            costString = this.safeString(trade, "amount");
            side = "buy";
        } else
        {
            symbol = add(add(tradedCurrency, "/"), earnedCurrency);
            amountString = this.safeString(trade, "amount");
            costString = this.safeString(trade, "transferedAmount");
            side = "sell";
        }
        object priceString = null;
        if (isTrue(!isEqual(costString, null)))
        {
            if (isTrue(amountString))
            {
                priceString = Precise.stringDiv(costString, amountString);
            }
        }
        object id = null;
        object amount = this.parseNumber(amountString);
        object price = this.parseNumber(priceString);
        object cost = this.parseNumber(costString);
        object type = null;
        object takerOrMaker = null;
        return new Dictionary<string, object>() {
            { "id", id },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "order", orderId },
            { "type", type },
            { "takerOrMaker", takerOrMaker },
            { "side", side },
            { "amount", amount },
            { "price", price },
            { "cost", cost },
            { "fee", fee },
            { "info", trade },
        };
    }

    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchDeposits
        * @description fetch all deposits made to an account
        * @param {string|undefined} code unified currency code
        * @param {int|undefined} since the earliest time in ms to fetch deposits for
        * @param {int|undefined} limit the maximum number of deposits structures to retrieve
        * @param {object} params extra parameters specific to the binance api endpoint
        * @param {bool} params.fiat if true, only fiat deposits will be returned
        * @param {int|undefined} params.until the latest time in ms to fetch deposits for
        * @returns {[object]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = null;
        object response = null;
        object request = new Dictionary<string, object>() {};
        object legalMoney = this.safeValue(this.options, "legalMoney", new Dictionary<string, object>() {});
        object fiatOnly = this.safeValue(parameters, "fiat", false);
        parameters = this.omit(parameters, "fiatOnly");
        object until = this.safeInteger(parameters, "until");
        if (isTrue(isTrue(fiatOnly) || isTrue((((Dictionary<string,object>)legalMoney).ContainsKey(toStringOrNull(code))))))
        {
            if (isTrue(!isEqual(code, null)))
            {
                currency = this.currency(code);
            }
            ((Dictionary<string, object>)request)["transactionType"] = 0;
            if (isTrue(!isEqual(since, null)))
            {
                ((Dictionary<string, object>)request)["beginTime"] = since;
            }
            if (isTrue(!isEqual(until, null)))
            {
                ((Dictionary<string, object>)request)["endTime"] = until;
            }
            object raw = await this.sapiGetFiatOrders(this.extend(request, parameters));
            response = this.safeValue(raw, "data");
        } else
        {
            if (isTrue(!isEqual(code, null)))
            {
                currency = this.currency(code);
                ((Dictionary<string, object>)request)["coin"] = getValue(currency, "id");
            }
            if (isTrue(!isEqual(since, null)))
            {
                ((Dictionary<string, object>)request)["startTime"] = since;
                // max 3 months range https://github.com/ccxt/ccxt/issues/6495
                object endTime = this.sum(since, 7776000000);
                if (isTrue(!isEqual(until, null)))
                {
                    endTime = mathMin(endTime, until);
                }
                ((Dictionary<string, object>)request)["endTime"] = endTime;
            }
            if (isTrue(!isEqual(limit, null)))
            {
                ((Dictionary<string, object>)request)["limit"] = limit;
            }
            response = await this.sapiGetCapitalDepositHisrec(this.extend(request, parameters));
        }
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            ((Dictionary<string, object>)getValue(response, i))["type"] = "deposit";
        }
        return this.parseTransactions(response, currency, since, limit);
    }

    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchWithdrawals
        * @description fetch all withdrawals made from an account
        * @param {string|undefined} code unified currency code
        * @param {int|undefined} since the earliest time in ms to fetch withdrawals for
        * @param {int|undefined} limit the maximum number of withdrawals structures to retrieve
        * @param {object} params extra parameters specific to the binance api endpoint
        * @param {bool} params.fiat if true, only fiat withdrawals will be returned
        * @returns {[object]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object legalMoney = this.safeValue(this.options, "legalMoney", new Dictionary<string, object>() {});
        object fiatOnly = this.safeValue(parameters, "fiat", false);
        parameters = this.omit(parameters, "fiatOnly");
        object request = new Dictionary<string, object>() {};
        object response = null;
        object currency = null;
        if (isTrue(isTrue(fiatOnly) || isTrue((((Dictionary<string,object>)legalMoney).ContainsKey(toStringOrNull(code))))))
        {
            if (isTrue(!isEqual(code, null)))
            {
                currency = this.currency(code);
            }
            ((Dictionary<string, object>)request)["transactionType"] = 1;
            if (isTrue(!isEqual(since, null)))
            {
                ((Dictionary<string, object>)request)["beginTime"] = since;
            }
            object raw = await this.sapiGetFiatOrders(this.extend(request, parameters));
            response = this.safeValue(raw, "data");
        } else
        {
            if (isTrue(!isEqual(code, null)))
            {
                currency = this.currency(code);
                ((Dictionary<string, object>)request)["coin"] = getValue(currency, "id");
            }
            if (isTrue(!isEqual(since, null)))
            {
                ((Dictionary<string, object>)request)["startTime"] = since;
                // max 3 months range https://github.com/ccxt/ccxt/issues/6495
                ((Dictionary<string, object>)request)["endTime"] = this.sum(since, 7776000000);
            }
            if (isTrue(!isEqual(limit, null)))
            {
                ((Dictionary<string, object>)request)["limit"] = limit;
            }
            response = await this.sapiGetCapitalWithdrawHistory(this.extend(request, parameters));
        }
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            ((Dictionary<string, object>)getValue(response, i))["type"] = "withdrawal";
        }
        return this.parseTransactions(response, currency, since, limit);
    }

    public virtual object parseTransactionStatusByType(object status, object type = null)
    {
        object statusesByType = new Dictionary<string, object>() {
            { "deposit", new Dictionary<string, object>() {
                { "0", "pending" },
                { "1", "ok" },
                { "6", "ok" },
                { "Processing", "pending" },
                { "Failed", "failed" },
                { "Successful", "ok" },
                { "Refunding", "canceled" },
                { "Refunded", "canceled" },
                { "Refund Failed", "failed" },
            } },
            { "withdrawal", new Dictionary<string, object>() {
                { "0", "pending" },
                { "1", "canceled" },
                { "2", "pending" },
                { "3", "failed" },
                { "4", "pending" },
                { "5", "failed" },
                { "6", "ok" },
                { "Processing", "pending" },
                { "Failed", "failed" },
                { "Successful", "ok" },
                { "Refunding", "canceled" },
                { "Refunded", "canceled" },
                { "Refund Failed", "failed" },
            } },
        };
        object statuses = this.safeValue(statusesByType, type, new Dictionary<string, object>() {});
        return this.safeString(statuses, status, status);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        // fetchDeposits
        //
        //     {
        //       "amount": "4500",
        //       "coin": "USDT",
        //       "network": "BSC",
        //       "status": 1,
        //       "address": "0xc9c923c87347ca0f3451d6d308ce84f691b9f501",
        //       "addressTag": "",
        //       "txId": "Internal transfer 51376627901",
        //       "insertTime": 1618394381000,
        //       "transferType": 1,
        //       "confirmTimes": "1/15"
        //     }
        //
        // fetchWithdrawals
        //
        //     {
        //       "id": "69e53ad305124b96b43668ceab158a18",
        //       "amount": "28.75",
        //       "transactionFee": "0.25",
        //       "coin": "XRP",
        //       "status": 6,
        //       "address": "r3T75fuLjX51mmfb5Sk1kMNuhBgBPJsjza",
        //       "addressTag": "101286922",
        //       "txId": "19A5B24ED0B697E4F0E9CD09FCB007170A605BC93C9280B9E6379C5E6EF0F65A",
        //       "applyTime": "2021-04-15 12:09:16",
        //       "network": "XRP",
        //       "transferType": 0
        //     }
        //
        // fiat transaction
        // withdraw
        //     {
        //       "orderNo": "CJW684897551397171200",
        //       "fiatCurrency": "GBP",
        //       "indicatedAmount": "29.99",
        //       "amount": "28.49",
        //       "totalFee": "1.50",
        //       "method": "bank transfer",
        //       "status": "Successful",
        //       "createTime": 1614898701000,
        //       "updateTime": 1614898820000
        //     }
        //
        // deposit
        //     {
        //       "orderNo": "25ced37075c1470ba8939d0df2316e23",
        //       "fiatCurrency": "EUR",
        //       "transactionType": 0,
        //       "indicatedAmount": "15.00",
        //       "amount": "15.00",
        //       "totalFee": "0.00",
        //       "method": "card",
        //       "status": "Failed",
        //       "createTime": "1627501026000",
        //       "updateTime": "1627501027000"
        //     }
        //
        // withdraw
        //
        //    { id: '9a67628b16ba4988ae20d329333f16bc' }
        //
        object id = this.safeString2(transaction, "id", "orderNo");
        object address = this.safeString(transaction, "address");
        object tag = this.safeString(transaction, "addressTag"); // set but unused
        if (isTrue(!isEqual(tag, null)))
        {
            if (isTrue(isLessThan(((string)tag).Length, 1)))
            {
                tag = null;
            }
        }
        object txid = this.safeString(transaction, "txId");
        if (isTrue(isTrue((!isEqual(txid, null))) && isTrue((isGreaterThanOrEqual(getIndexOf(txid, "Internal transfer "), 0)))))
        {
            txid = ((string)txid).Substring((int)18);
        }
        object currencyId = this.safeString2(transaction, "coin", "fiatCurrency");
        object code = this.safeCurrencyCode(currencyId, currency);
        object timestamp = null;
        timestamp = this.safeInteger2(transaction, "insertTime", "createTime");
        if (isTrue(isEqual(timestamp, null)))
        {
            timestamp = this.parse8601(this.safeString(transaction, "applyTime"));
        }
        object updated = this.safeInteger2(transaction, "successTime", "updateTime");
        object type = this.safeString(transaction, "type");
        if (isTrue(isEqual(type, null)))
        {
            object txType = this.safeString(transaction, "transactionType");
            if (isTrue(!isEqual(txType, null)))
            {
                type = ((bool) isTrue((isEqual(txType, "0")))) ? "deposit" : "withdrawal";
            }
            object legalMoneyCurrenciesById = this.safeValue(this.options, "legalMoneyCurrenciesById");
            code = this.safeString(legalMoneyCurrenciesById, code, code);
        }
        object status = this.parseTransactionStatusByType(this.safeString(transaction, "status"), type);
        object amount = this.safeNumber(transaction, "amount");
        object feeCost = this.safeNumber2(transaction, "transactionFee", "totalFee");
        object fee = null;
        if (isTrue(!isEqual(feeCost, null)))
        {
            fee = new Dictionary<string, object>() {
                { "currency", code },
                { "cost", feeCost },
            };
        }
        object intern = this.safeInteger(transaction, "transferType");
        if (isTrue(!isEqual(intern, null)))
        {
            intern = ((bool) isTrue(intern)) ? true : ((object)false);
        }
        object network = this.safeString(transaction, "network");
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", id },
            { "txid", txid },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "network", network },
            { "address", address },
            { "addressTo", address },
            { "addressFrom", null },
            { "tag", tag },
            { "tagTo", tag },
            { "tagFrom", null },
            { "type", type },
            { "amount", amount },
            { "currency", code },
            { "status", status },
            { "updated", updated },
            { "internal", intern },
            { "fee", fee },
        };
    }

    public virtual object parseTransferStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "CONFIRMED", "ok" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        //
        // transfer
        //
        //     {
        //         "tranId":13526853623
        //     }
        //
        // fetchTransfers
        //
        //     {
        //         timestamp: 1614640878000,
        //         asset: 'USDT',
        //         amount: '25',
        //         type: 'MAIN_UMFUTURE',
        //         status: 'CONFIRMED',
        //         tranId: 43000126248
        //     }
        //
        object id = this.safeString(transfer, "tranId");
        object currencyId = this.safeString(transfer, "asset");
        object code = this.safeCurrencyCode(currencyId, currency);
        object amount = this.safeNumber(transfer, "amount");
        object type = this.safeString(transfer, "type");
        object fromAccount = null;
        object toAccount = null;
        object accountsById = this.safeValue(this.options, "accountsById", new Dictionary<string, object>() {});
        if (isTrue(!isEqual(type, null)))
        {
            object parts = ((string)type).Split((string)"_").ToList<object>();
            fromAccount = this.safeValue(parts, 0);
            toAccount = this.safeValue(parts, 1);
            fromAccount = this.safeString(accountsById, fromAccount, fromAccount);
            toAccount = this.safeString(accountsById, toAccount, toAccount);
        }
        object timestamp = this.safeInteger(transfer, "timestamp");
        object status = this.parseTransferStatus(this.safeString(transfer, "status"));
        return new Dictionary<string, object>() {
            { "info", transfer },
            { "id", id },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "currency", code },
            { "amount", amount },
            { "fromAccount", fromAccount },
            { "toAccount", toAccount },
            { "status", status },
        };
    }

    public override object parseIncome(object income, object market = null)
    {
        //
        //     {
        //       "symbol": "ETHUSDT",
        //       "incomeType": "FUNDING_FEE",
        //       "income": "0.00134317",
        //       "asset": "USDT",
        //       "time": "1621584000000",
        //       "info": "FUNDING_FEE",
        //       "tranId": "4480321991774044580",
        //       "tradeId": ""
        //     }
        //
        object marketId = this.safeString(income, "symbol");
        object symbol = this.safeSymbol(marketId, market, null, "swap");
        object amount = this.safeNumber(income, "income");
        object currencyId = this.safeString(income, "asset");
        object code = this.safeCurrencyCode(currencyId);
        object id = this.safeString(income, "tranId");
        object timestamp = this.safeInteger(income, "time");
        return new Dictionary<string, object>() {
            { "info", income },
            { "symbol", symbol },
            { "code", code },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "id", id },
            { "amount", amount },
        };
    }

    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        /**
        * @method
        * @name binance#transfer
        * @description transfer currency internally between wallets on the same account
        * @see https://binance-docs.github.io/apidocs/spot/en/#user-universal-transfer-user_data
        * @see https://binance-docs.github.io/apidocs/spot/en/#isolated-margin-account-transfer-margin
        * @param {string} code unified currency code
        * @param {float} amount amount to transfer
        * @param {string} fromAccount account to transfer from
        * @param {string} toAccount account to transfer to
        * @param {object} params extra parameters specific to the binance api endpoint
        * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "asset", getValue(currency, "id") },
            { "amount", this.currencyToPrecision(code, amount) },
        };
        ((Dictionary<string, object>)request)["type"] = this.safeString(parameters, "type");
        object method = "sapiPostAssetTransfer";
        if (isTrue(isEqual(getValue(request, "type"), null)))
        {
            object symbol = this.safeString(parameters, "symbol");
            if (isTrue(!isEqual(symbol, null)))
            {
                parameters = this.omit(parameters, "symbol");
            }
            object fromId = ((string)this.convertTypeToAccount(fromAccount)).ToUpper();
            object toId = ((string)this.convertTypeToAccount(toAccount)).ToUpper();
            if (isTrue(isEqual(fromId, "ISOLATED")))
            {
                if (isTrue(isEqual(symbol, null)))
                {
                    throw new ArgumentsRequired ((string)add(add(this.id, " transfer () requires params[\"symbol\"] when fromAccount is "), fromAccount)) ;
                } else
                {
                    fromId = this.marketId(symbol);
                }
            }
            if (isTrue(isEqual(toId, "ISOLATED")))
            {
                if (isTrue(isEqual(symbol, null)))
                {
                    throw new ArgumentsRequired ((string)add(add(this.id, " transfer () requires params[\"symbol\"] when toAccount is "), toAccount)) ;
                } else
                {
                    toId = this.marketId(symbol);
                }
            }
            object accountsById = this.safeValue(this.options, "accountsById", new Dictionary<string, object>() {});
            object fromIsolated = !isTrue((((Dictionary<string,object>)accountsById).ContainsKey(toStringOrNull(fromId))));
            object toIsolated = !isTrue((((Dictionary<string,object>)accountsById).ContainsKey(toStringOrNull(toId))));
            if (isTrue(isTrue(fromIsolated) || isTrue(toIsolated)))
            {
                object fromFuture = isTrue(isEqual(fromId, "UMFUTURE")) || isTrue(isEqual(fromId, "CMFUTURE"));
                object toFuture = isTrue(isEqual(toId, "UMFUTURE")) || isTrue(isEqual(toId, "CMFUTURE"));
                object fromSpot = isEqual(fromId, "MAIN");
                object toSpot = isEqual(toId, "MAIN");
                object funding = isTrue(isEqual(fromId, "FUNDING")) || isTrue(isEqual(toId, "FUNDING"));
                object mining = isTrue(isEqual(fromId, "MINING")) || isTrue(isEqual(toId, "MINING"));
                object prohibitedWithIsolated = isTrue(isTrue(isTrue(fromFuture) || isTrue(toFuture)) || isTrue(mining)) || isTrue(funding);
                if (isTrue(isTrue((isTrue(fromIsolated) || isTrue(toIsolated))) && isTrue(prohibitedWithIsolated)))
                {
                    throw new BadRequest ((string)add(add(add(add(this.id, " transfer () does not allow transfers between "), fromAccount), " and "), toAccount)) ;
                } else if (isTrue(isTrue(toSpot) && isTrue(fromIsolated)))
                {
                    method = "sapiPostMarginIsolatedTransfer";
                    ((Dictionary<string, object>)request)["transFrom"] = "ISOLATED_MARGIN";
                    ((Dictionary<string, object>)request)["transTo"] = "SPOT";
                    ((Dictionary<string, object>)request)["symbol"] = fromId;
                } else if (isTrue(isTrue(fromSpot) && isTrue(toIsolated)))
                {
                    method = "sapiPostMarginIsolatedTransfer";
                    ((Dictionary<string, object>)request)["transFrom"] = "SPOT";
                    ((Dictionary<string, object>)request)["transTo"] = "ISOLATED_MARGIN";
                    ((Dictionary<string, object>)request)["symbol"] = toId;
                } else
                {
                    if (isTrue(fromIsolated))
                    {
                        ((Dictionary<string, object>)request)["fromSymbol"] = fromId;
                        fromId = "ISOLATEDMARGIN";
                    }
                    if (isTrue(toIsolated))
                    {
                        ((Dictionary<string, object>)request)["toSymbol"] = toId;
                        toId = "ISOLATEDMARGIN";
                    }
                    ((Dictionary<string, object>)request)["type"] = add(add(fromId, "_"), toId);
                }
            } else
            {
                ((Dictionary<string, object>)request)["type"] = add(add(fromId, "_"), toId);
            }
        }
        parameters = this.omit(parameters, "type");
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        //     {
        //         "tranId":13526853623
        //     }
        //
        return this.parseTransfer(response, currency);
    }

    public async virtual Task<object> fetchTransfers(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchTransfers
        * @description fetch a history of internal transfers made on an account
        * @param {string|undefined} code unified currency code of the currency transferred
        * @param {int|undefined} since the earliest time in ms to fetch transfers for
        * @param {int|undefined} limit the maximum number of  transfers structures to retrieve
        * @param {object} params extra parameters specific to the binance api endpoint
        * @returns {[object]} a list of [transfer structures]{@link https://docs.ccxt.com/#/?id=transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
        }
        object defaultType = this.safeString2(this.options, "fetchTransfers", "defaultType", "spot");
        object fromAccount = this.safeString(parameters, "fromAccount", defaultType);
        object defaultTo = ((bool) isTrue((isEqual(fromAccount, "future")))) ? "spot" : "future";
        object toAccount = this.safeString(parameters, "toAccount", defaultTo);
        object type = this.safeString(parameters, "type");
        object accountsByType = this.safeValue(this.options, "accountsByType", new Dictionary<string, object>() {});
        object fromId = this.safeString(accountsByType, fromAccount);
        object toId = this.safeString(accountsByType, toAccount);
        if (isTrue(isEqual(type, null)))
        {
            if (isTrue(isEqual(fromId, null)))
            {
                object keys = new List<object>(((Dictionary<string,object>)accountsByType).Keys);
                throw new ExchangeError ((string)add(add(this.id, " fromAccount parameter must be one of "), String.Join(", ", ((List<object>)keys).ToArray()))) ;
            }
            if (isTrue(isEqual(toId, null)))
            {
                object keys = new List<object>(((Dictionary<string,object>)accountsByType).Keys);
                throw new ExchangeError ((string)add(add(this.id, " toAccount parameter must be one of "), String.Join(", ", ((List<object>)keys).ToArray()))) ;
            }
            type = add(add(fromId, "_"), toId);
        }
        object request = new Dictionary<string, object>() {
            { "type", type },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["size"] = limit;
        }
        object response = await this.sapiGetAssetTransfer(this.extend(request, parameters));
        //
        //     {
        //         total: 3,
        //         rows: [
        //             {
        //                 timestamp: 1614640878000,
        //                 asset: 'USDT',
        //                 amount: '25',
        //                 type: 'MAIN_UMFUTURE',
        //                 status: 'CONFIRMED',
        //                 tranId: 43000126248
        //             },
        //         ]
        //     }
        //
        object rows = this.safeValue(response, "rows", new List<object>() {});
        return this.parseTransfers(rows, currency, since, limit);
    }

    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchDepositAddress
        * @description fetch the deposit address for a currency associated with this account
        * @param {string} code unified currency code
        * @param {object} params extra parameters specific to the binance api endpoint
        * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "id") },
        };
        object networks = this.safeValue(this.options, "networks", new Dictionary<string, object>() {});
        object network = this.safeStringUpper(parameters, "network"); // this line allows the user to specify either ERC20 or ETH
        network = this.safeString(networks, network, network); // handle ERC20>ETH alias
        if (isTrue(!isEqual(network, null)))
        {
            ((Dictionary<string, object>)request)["network"] = network;
            parameters = this.omit(parameters, "network");
        }
        // has support for the 'network' parameter
        // https://binance-docs.github.io/apidocs/spot/en/#deposit-address-supporting-network-user_data
        object response = await this.sapiGetCapitalDepositAddress(this.extend(request, parameters));
        //
        //     {
        //         currency: 'XRP',
        //         address: 'rEb8TK3gBgk5auZkwc6sHnwrGVJH8DuaLh',
        //         tag: '108618262',
        //         info: {
        //             coin: 'XRP',
        //             address: 'rEb8TK3gBgk5auZkwc6sHnwrGVJH8DuaLh',
        //             tag: '108618262',
        //             url: 'https://bithomp.com/explorer/rEb8TK3gBgk5auZkwc6sHnwrGVJH8DuaLh'
        //         }
        //     }
        //
        object address = this.safeString(response, "address");
        object url = this.safeString(response, "url");
        object impliedNetwork = null;
        if (isTrue(!isEqual(url, null)))
        {
            object reverseNetworks = this.safeValue(this.options, "reverseNetworks", new Dictionary<string, object>() {});
            object parts = ((string)url).Split((string)"/").ToList<object>();
            object topLevel = this.safeString(parts, 2);
            if (isTrue(isTrue((isEqual(topLevel, "blockchair.com"))) || isTrue((isEqual(topLevel, "viewblock.io")))))
            {
                object subLevel = this.safeString(parts, 3);
                if (isTrue(!isEqual(subLevel, null)))
                {
                    topLevel = add(add(topLevel, "/"), subLevel);
                }
            }
            impliedNetwork = this.safeString(reverseNetworks, topLevel);
            object impliedNetworks = this.safeValue(this.options, "impliedNetworks", new Dictionary<string, object>() {
                { "ETH", new Dictionary<string, object>() {
                    { "ERC20", "ETH" },
                } },
                { "TRX", new Dictionary<string, object>() {
                    { "TRC20", "TRX" },
                } },
            });
            if (isTrue(((Dictionary<string,object>)impliedNetworks).ContainsKey(toStringOrNull(code))))
            {
                object conversion = this.safeValue(impliedNetworks, code, new Dictionary<string, object>() {});
                impliedNetwork = this.safeString(conversion, impliedNetwork, impliedNetwork);
            }
        }
        object tag = this.safeString(response, "tag", "");
        if (isTrue(isEqual(((string)tag).Length, 0)))
        {
            tag = null;
        }
        this.checkAddress(address);
        return new Dictionary<string, object>() {
            { "currency", code },
            { "address", address },
            { "tag", tag },
            { "network", impliedNetwork },
            { "info", response },
        };
    }

    public async override Task<object> fetchTransactionFees(object codes = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchTransactionFees
        * @description *DEPRECATED* please use fetchDepositWithdrawFees instead
        * @param {[string]|undefined} codes not used by binance fetchTransactionFees ()
        * @param {object} params extra parameters specific to the binance api endpoint
        * @returns {[object]} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.sapiGetCapitalConfigGetall(parameters);
        //
        //  [
        //     {
        //       coin: 'BAT',
        //       depositAllEnable: true,
        //       withdrawAllEnable: true,
        //       name: 'Basic Attention Token',
        //       free: '0',
        //       locked: '0',
        //       freeze: '0',
        //       withdrawing: '0',
        //       ipoing: '0',
        //       ipoable: '0',
        //       storage: '0',
        //       isLegalMoney: false,
        //       trading: true,
        //       networkList: [
        //         {
        //           network: 'BNB',
        //           coin: 'BAT',
        //           withdrawIntegerMultiple: '0.00000001',
        //           isDefault: false,
        //           depositEnable: true,
        //           withdrawEnable: true,
        //           depositDesc: '',
        //           withdrawDesc: '',
        //           specialTips: 'The name of this asset is Basic Attention Token (BAT). Both a MEMO and an Address are required to successfully deposit your BEP2 tokens to Binance.',
        //           name: 'BEP2',
        //           resetAddressStatus: false,
        //           addressRegex: '^(bnb1)[0-9a-z]{38}$',
        //           memoRegex: '^[0-9A-Za-z\\-_]{1,120}$',
        //           withdrawFee: '0.27',
        //           withdrawMin: '0.54',
        //           withdrawMax: '10000000000',
        //           minConfirm: '1',
        //           unLockConfirm: '0'
        //         },
        //         {
        //           network: 'BSC',
        //           coin: 'BAT',
        //           withdrawIntegerMultiple: '0.00000001',
        //           isDefault: false,
        //           depositEnable: true,
        //           withdrawEnable: true,
        //           depositDesc: '',
        //           withdrawDesc: '',
        //           specialTips: 'The name of this asset is Basic Attention Token. Please ensure you are depositing Basic Attention Token (BAT) tokens under the contract address ending in 9766e.',
        //           name: 'BEP20 (BSC)',
        //           resetAddressStatus: false,
        //           addressRegex: '^(0x)[0-9A-Fa-f]{40}$',
        //           memoRegex: '',
        //           withdrawFee: '0.27',
        //           withdrawMin: '0.54',
        //           withdrawMax: '10000000000',
        //           minConfirm: '15',
        //           unLockConfirm: '0'
        //         },
        //         {
        //           network: 'ETH',
        //           coin: 'BAT',
        //           withdrawIntegerMultiple: '0.00000001',
        //           isDefault: true,
        //           depositEnable: true,
        //           withdrawEnable: true,
        //           depositDesc: '',
        //           withdrawDesc: '',
        //           specialTips: 'The name of this asset is Basic Attention Token. Please ensure you are depositing Basic Attention Token (BAT) tokens under the contract address ending in 887ef.',
        //           name: 'ERC20',
        //           resetAddressStatus: false,
        //           addressRegex: '^(0x)[0-9A-Fa-f]{40}$',
        //           memoRegex: '',
        //           withdrawFee: '27',
        //           withdrawMin: '54',
        //           withdrawMax: '10000000000',
        //           minConfirm: '12',
        //           unLockConfirm: '0'
        //         }
        //       ]
        //     }
        //  ]
        //
        object withdrawFees = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object entry = getValue(response, i);
            object currencyId = this.safeString(entry, "coin");
            object code = this.safeCurrencyCode(currencyId);
            object networkList = this.safeValue(entry, "networkList", new List<object>() {});
            ((Dictionary<string, object>)withdrawFees)[(string)code] = new Dictionary<string, object>() {};
            for (object j = 0; isLessThan(j, getArrayLength(networkList)); postFixIncrement(ref j))
            {
                object networkEntry = getValue(networkList, j);
                object networkId = this.safeString(networkEntry, "network");
                object networkCode = this.safeCurrencyCode(networkId);
                object fee = this.safeNumber(networkEntry, "withdrawFee");
                ((Dictionary<string, object>)getValue(withdrawFees, code))[(string)networkCode] = fee;
            }
        }
        return new Dictionary<string, object>() {
            { "withdraw", withdrawFees },
            { "deposit", new Dictionary<string, object>() {} },
            { "info", response },
        };
    }

    public async override Task<object> fetchDepositWithdrawFees(object codes = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchDepositWithdrawFees
        * @description fetch deposit and withdraw fees
        * @param {[string]|undefined} codes not used by binance fetchDepositWithdrawFees ()
        * @param {object} params extra parameters specific to the binance api endpoint
        * @returns {[object]} a list of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.sapiGetCapitalConfigGetall(parameters);
        //
        //    [
        //        {
        //            coin: 'BAT',
        //            depositAllEnable: true,
        //            withdrawAllEnable: true,
        //            name: 'Basic Attention Token',
        //            free: '0',
        //            locked: '0',
        //            freeze: '0',
        //            withdrawing: '0',
        //            ipoing: '0',
        //            ipoable: '0',
        //            storage: '0',
        //            isLegalMoney: false,
        //            trading: true,
        //            networkList: [
        //                {
        //                    network: 'BNB',
        //                    coin: 'BAT',
        //                    withdrawIntegerMultiple: '0.00000001',
        //                    isDefault: false,
        //                    depositEnable: true,
        //                    withdrawEnable: true,
        //                    depositDesc: '',
        //                    withdrawDesc: '',
        //                    specialTips: 'The name of this asset is Basic Attention Token (BAT). Both a MEMO and an Address are required to successfully deposit your BEP2 tokens to Binance.',
        //                    name: 'BEP2',
        //                    resetAddressStatus: false,
        //                    addressRegex: '^(bnb1)[0-9a-z]{38}$',
        //                    memoRegex: '^[0-9A-Za-z\\-_]{1,120}$',
        //                    withdrawFee: '0.27',
        //                    withdrawMin: '0.54',
        //                    withdrawMax: '10000000000',
        //                    minConfirm: '1',
        //                    unLockConfirm: '0'
        //                },
        //                ...
        //            ]
        //        }
        //    ]
        //
        return this.parseDepositWithdrawFees(response, codes, "coin");
    }

    public override object parseDepositWithdrawFee(object fee, object currency = null)
    {
        //
        //    {
        //        coin: 'BAT',
        //        depositAllEnable: true,
        //        withdrawAllEnable: true,
        //        name: 'Basic Attention Token',
        //        free: '0',
        //        locked: '0',
        //        freeze: '0',
        //        withdrawing: '0',
        //        ipoing: '0',
        //        ipoable: '0',
        //        storage: '0',
        //        isLegalMoney: false,
        //        trading: true,
        //        networkList: [
        //            {
        //                network: 'BNB',
        //                coin: 'BAT',
        //                withdrawIntegerMultiple: '0.00000001',
        //                isDefault: false,
        //                depositEnable: true,
        //                withdrawEnable: true,
        //                depositDesc: '',
        //                withdrawDesc: '',
        //                specialTips: 'The name of this asset is Basic Attention Token (BAT). Both a MEMO and an Address are required to successfully deposit your BEP2 tokens to Binance.',
        //                name: 'BEP2',
        //                resetAddressStatus: false,
        //                addressRegex: '^(bnb1)[0-9a-z]{38}$',
        //                memoRegex: '^[0-9A-Za-z\\-_]{1,120}$',
        //                withdrawFee: '0.27',
        //                withdrawMin: '0.54',
        //                withdrawMax: '10000000000',
        //                minConfirm: '1',
        //                unLockConfirm: '0'
        //            },
        //            ...
        //        ]
        //    }
        //
        object networkList = this.safeValue(fee, "networkList", new List<object>() {});
        object result = this.depositWithdrawFee(fee);
        for (object j = 0; isLessThan(j, getArrayLength(networkList)); postFixIncrement(ref j))
        {
            object networkEntry = getValue(networkList, j);
            object networkId = this.safeString(networkEntry, "network");
            object networkCode = this.networkIdToCode(networkId);
            object withdrawFee = this.safeNumber(networkEntry, "withdrawFee");
            object isDefault = this.safeValue(networkEntry, "isDefault");
            if (isTrue(isEqual(isDefault, true)))
            {
                ((Dictionary<string, object>)result)["withdraw"] = new Dictionary<string, object>() {
                    { "fee", withdrawFee },
                    { "percentage", null },
                };
            }
            ((Dictionary<string, object>)getValue(result, "networks"))[(string)networkCode] = new Dictionary<string, object>() {
                { "withdraw", new Dictionary<string, object>() {
                    { "fee", withdrawFee },
                    { "percentage", null },
                } },
                { "deposit", new Dictionary<string, object>() {
                    { "fee", null },
                    { "percentage", null },
                } },
            };
        }
        return result;
    }

    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#withdraw
        * @description make a withdrawal
        * @param {string} code unified currency code
        * @param {float} amount the amount to withdraw
        * @param {string} address the address to withdraw to
        * @param {string|undefined} tag
        * @param {object} params extra parameters specific to the binance api endpoint
        * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((List<object>)tagparametersVariable)[0];
        parameters = ((List<object>)tagparametersVariable)[1];
        this.checkAddress(address);
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "coin", getValue(currency, "id") },
            { "address", address },
            { "amount", amount },
        };
        if (isTrue(!isEqual(tag, null)))
        {
            ((Dictionary<string, object>)request)["addressTag"] = tag;
        }
        object networks = this.safeValue(this.options, "networks", new Dictionary<string, object>() {});
        object network = this.safeStringUpper(parameters, "network"); // this line allows the user to specify either ERC20 or ETH
        network = this.safeString(networks, network, network); // handle ERC20>ETH alias
        if (isTrue(!isEqual(network, null)))
        {
            ((Dictionary<string, object>)request)["network"] = network;
            parameters = this.omit(parameters, "network");
        }
        object response = await this.sapiPostCapitalWithdrawApply(this.extend(request, parameters));
        //     { id: '9a67628b16ba4988ae20d329333f16bc' }
        return this.parseTransaction(response, currency);
    }

    public virtual object parseTradingFee(object fee, object market = null)
    {
        //
        //     {
        //         "symbol": "ADABNB",
        //         "makerCommission": 0.001,
        //         "takerCommission": 0.001
        //     }
        //
        object marketId = this.safeString(fee, "symbol");
        object symbol = this.safeSymbol(marketId, market, null, "spot");
        return new Dictionary<string, object>() {
            { "info", fee },
            { "symbol", symbol },
            { "maker", this.safeNumber(fee, "makerCommission") },
            { "taker", this.safeNumber(fee, "takerCommission") },
        };
    }

    public async override Task<object> fetchTradingFee(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchTradingFee
        * @description fetch the trading fees for a market
        * @param {string} symbol unified market symbol
        * @param {object} params extra parameters specific to the binance api endpoint
        * @returns {object} a [fee structure]{@link https://docs.ccxt.com/#/?id=fee-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.sapiGetAssetTradeFee(this.extend(request, parameters));
        //
        //     [
        //       {
        //         "symbol": "BTCUSDT",
        //         "makerCommission": "0.001",
        //         "takerCommission": "0.001"
        //       }
        //     ]
        //
        object first = this.safeValue(response, 0, new Dictionary<string, object>() {});
        return this.parseTradingFee(first);
    }

    public async override Task<object> fetchTradingFees(object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchTradingFees
        * @description fetch the trading fees for multiple markets
        * @param {object} params extra parameters specific to the binance api endpoint
        * @returns {object} a dictionary of [fee structures]{@link https://docs.ccxt.com/#/?id=fee-structure} indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object method = null;
        object defaultType = this.safeString2(this.options, "fetchTradingFees", "defaultType", "linear");
        object type = this.safeString(parameters, "type", defaultType);
        parameters = this.omit(parameters, "type");
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchTradingFees", null, parameters);
        subType = ((List<object>)subTypeparametersVariable)[0];
        parameters = ((List<object>)subTypeparametersVariable)[1];
        object isSpotOrMargin = isTrue((isEqual(type, "spot"))) || isTrue((isEqual(type, "margin")));
        object isLinear = this.isLinear(type, subType);
        object isInverse = this.isInverse(type, subType);
        if (isTrue(isSpotOrMargin))
        {
            method = "sapiGetAssetTradeFee";
        } else if (isTrue(isLinear))
        {
            method = "fapiPrivateGetAccount";
        } else if (isTrue(isInverse))
        {
            method = "dapiPrivateGetAccount";
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { parameters }));
        //
        // sapi / spot
        //
        //    [
        //       {
        //         "symbol": "ZRXBNB",
        //         "makerCommission": "0.001",
        //         "takerCommission": "0.001"
        //       },
        //       {
        //         "symbol": "ZRXBTC",
        //         "makerCommission": "0.001",
        //         "takerCommission": "0.001"
        //       },
        //    ]
        //
        // fapi / future / linear
        //
        //     {
        //         "feeTier": 0,       // account commisssion tier
        //         "canTrade": true,   // if can trade
        //         "canDeposit": true,     // if can transfer in asset
        //         "canWithdraw": true,    // if can transfer out asset
        //         "updateTime": 0,
        //         "totalInitialMargin": "0.00000000",    // total initial margin required with current mark price (useless with isolated positions), only for USDT asset
        //         "totalMaintMargin": "0.00000000",     // total maintenance margin required, only for USDT asset
        //         "totalWalletBalance": "23.72469206",     // total wallet balance, only for USDT asset
        //         "totalUnrealizedProfit": "0.00000000",   // total unrealized profit, only for USDT asset
        //         "totalMarginBalance": "23.72469206",     // total margin balance, only for USDT asset
        //         "totalPositionInitialMargin": "0.00000000",    // initial margin required for positions with current mark price, only for USDT asset
        //         "totalOpenOrderInitialMargin": "0.00000000",   // initial margin required for open orders with current mark price, only for USDT asset
        //         "totalCrossWalletBalance": "23.72469206",      // crossed wallet balance, only for USDT asset
        //         "totalCrossUnPnl": "0.00000000",      // unrealized profit of crossed positions, only for USDT asset
        //         "availableBalance": "23.72469206",       // available balance, only for USDT asset
        //         "maxWithdrawAmount": "23.72469206"     // maximum amount for transfer out, only for USDT asset
        //         ...
        //     }
        //
        // dapi / delivery / inverse
        //
        //     {
        //         "canDeposit": true,
        //         "canTrade": true,
        //         "canWithdraw": true,
        //         "feeTier": 2,
        //         "updateTime": 0
        //     }
        //
        if (isTrue(isSpotOrMargin))
        {
            //
            //    [
            //       {
            //         "symbol": "ZRXBNB",
            //         "makerCommission": "0.001",
            //         "takerCommission": "0.001"
            //       },
            //       {
            //         "symbol": "ZRXBTC",
            //         "makerCommission": "0.001",
            //         "takerCommission": "0.001"
            //       },
            //    ]
            //
            object result = new Dictionary<string, object>() {};
            for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
            {
                object fee = this.parseTradingFee(getValue(response, i));
                object symbol = getValue(fee, "symbol");
                ((Dictionary<string, object>)result)[(string)symbol] = fee;
            }
            return result;
        } else if (isTrue(isLinear))
        {
            //
            //     {
            //         "feeTier": 0,       // account commisssion tier
            //         "canTrade": true,   // if can trade
            //         "canDeposit": true,     // if can transfer in asset
            //         "canWithdraw": true,    // if can transfer out asset
            //         "updateTime": 0,
            //         "totalInitialMargin": "0.00000000",    // total initial margin required with current mark price (useless with isolated positions), only for USDT asset
            //         "totalMaintMargin": "0.00000000",     // total maintenance margin required, only for USDT asset
            //         "totalWalletBalance": "23.72469206",     // total wallet balance, only for USDT asset
            //         "totalUnrealizedProfit": "0.00000000",   // total unrealized profit, only for USDT asset
            //         "totalMarginBalance": "23.72469206",     // total margin balance, only for USDT asset
            //         "totalPositionInitialMargin": "0.00000000",    // initial margin required for positions with current mark price, only for USDT asset
            //         "totalOpenOrderInitialMargin": "0.00000000",   // initial margin required for open orders with current mark price, only for USDT asset
            //         "totalCrossWalletBalance": "23.72469206",      // crossed wallet balance, only for USDT asset
            //         "totalCrossUnPnl": "0.00000000",      // unrealized profit of crossed positions, only for USDT asset
            //         "availableBalance": "23.72469206",       // available balance, only for USDT asset
            //         "maxWithdrawAmount": "23.72469206"     // maximum amount for transfer out, only for USDT asset
            //         ...
            //     }
            //
            object symbols = new List<object>(((Dictionary<string,object>)this.markets).Keys);
            object result = new Dictionary<string, object>() {};
            object feeTier = this.safeInteger(response, "feeTier");
            object feeTiers = getValue(getValue(getValue(this.fees, "linear"), "trading"), "tiers");
            object maker = getValue(getValue(getValue(feeTiers, "maker"), feeTier), 1);
            object taker = getValue(getValue(getValue(feeTiers, "taker"), feeTier), 1);
            for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
            {
                object symbol = getValue(symbols, i);
                object market = getValue(this.markets, symbol);
                if (isTrue(getValue(market, "linear")))
                {
                    ((Dictionary<string, object>)result)[(string)symbol] = new Dictionary<string, object>() {
                        { "info", new Dictionary<string, object>() {
                            { "feeTier", feeTier },
                        } },
                        { "symbol", symbol },
                        { "maker", maker },
                        { "taker", taker },
                    };
                }
            }
            return result;
        } else if (isTrue(isInverse))
        {
            //
            //     {
            //         "canDeposit": true,
            //         "canTrade": true,
            //         "canWithdraw": true,
            //         "feeTier": 2,
            //         "updateTime": 0
            //     }
            //
            object symbols = new List<object>(((Dictionary<string,object>)this.markets).Keys);
            object result = new Dictionary<string, object>() {};
            object feeTier = this.safeInteger(response, "feeTier");
            object feeTiers = getValue(getValue(getValue(this.fees, "inverse"), "trading"), "tiers");
            object maker = getValue(getValue(getValue(feeTiers, "maker"), feeTier), 1);
            object taker = getValue(getValue(getValue(feeTiers, "taker"), feeTier), 1);
            for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
            {
                object symbol = getValue(symbols, i);
                object market = getValue(this.markets, symbol);
                if (isTrue(getValue(market, "inverse")))
                {
                    ((Dictionary<string, object>)result)[(string)symbol] = new Dictionary<string, object>() {
                        { "info", new Dictionary<string, object>() {
                            { "feeTier", feeTier },
                        } },
                        { "symbol", symbol },
                        { "maker", maker },
                        { "taker", taker },
                    };
                }
            }
            return result;
        }
        return null;
    }

    public async virtual Task<object> futuresTransfer(object code, object amount, object type, object parameters = null)
    {
        /**
        * @method
        * @name binance#futuresTransfer
        * @description transfer between futures account
        * @param {string} code unified currency code
        * @param {float} amount the amount to transfer
        * @param {string} type 1 - transfer from spot account to USDT- futures account, 2 - transfer from USDT- futures account to spot account, 3 - transfer from spot account to COIN- futures account, 4 - transfer from COIN- futures account to spot account
        * @param {object} params extra parameters specific to the binance api endpoint
        * @param {float|undefined} params.recvWindow
        * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=futures-transfer-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isTrue((isLessThan(type, 1))) || isTrue((isGreaterThan(type, 4)))))
        {
            throw new ArgumentsRequired ((string)add(this.id, " type must be between 1 and 4")) ;
        }
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "asset", getValue(currency, "id") },
            { "amount", amount },
            { "type", type },
        };
        object response = await this.sapiPostFuturesTransfer(this.extend(request, parameters));
        //
        //   {
        //       "tranId": 100000001
        //   }
        //
        return this.parseTransfer(response, currency);
    }

    public async override Task<object> fetchFundingRate(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchFundingRate
        * @description fetch the current funding rate
        * @param {string} symbol unified market symbol
        * @param {object} params extra parameters specific to the binance api endpoint
        * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object method = null;
        if (isTrue(getValue(market, "linear")))
        {
            method = "fapiPublicGetPremiumIndex";
        } else if (isTrue(getValue(market, "inverse")))
        {
            method = "dapiPublicGetPremiumIndex";
        } else
        {
            throw new NotSupported ((string)add(this.id, " fetchFundingRate() supports linear and inverse contracts only")) ;
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        if (isTrue(getValue(market, "inverse")))
        {
            response = getValue(response, 0);
        }
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "markPrice": "45802.81129892",
        //         "indexPrice": "45745.47701915",
        //         "estimatedSettlePrice": "45133.91753671",
        //         "lastFundingRate": "0.00063521",
        //         "interestRate": "0.00010000",
        //         "nextFundingTime": "1621267200000",
        //         "time": "1621252344001"
        //     }
        //
        return this.parseFundingRate(response, market);
    }

    public async override Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchFundingRateHistory
        * @description fetches historical funding rate prices
        * @param {string|undefined} symbol unified symbol of the market to fetch the funding rate history for
        * @param {int|undefined} since timestamp in ms of the earliest funding rate to fetch
        * @param {int|undefined} limit the maximum amount of [funding rate structures]{@link https://docs.ccxt.com/en/latest/manual.html?#funding-rate-history-structure} to fetch
        * @param {object} params extra parameters specific to the binance api endpoint
        * @param {int|undefined} params.until timestamp in ms of the latest funding rate
        * @returns {[object]} a list of [funding rate structures]{@link https://docs.ccxt.com/en/latest/manual.html?#funding-rate-history-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object method = null;
        object defaultType = this.safeString2(this.options, "fetchFundingRateHistory", "defaultType", "future");
        object type = this.safeString(parameters, "type", defaultType);
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            symbol = getValue(market, "symbol");
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
        }
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchFundingRateHistory", market, parameters, "linear");
        subType = ((List<object>)subTypeparametersVariable)[0];
        parameters = ((List<object>)subTypeparametersVariable)[1];
        parameters = this.omit(parameters, "type");
        if (isTrue(this.isLinear(type, subType)))
        {
            method = "fapiPublicGetFundingRate";
        } else if (isTrue(this.isInverse(type, subType)))
        {
            method = "dapiPublicGetFundingRate";
        }
        if (isTrue(isEqual(method, null)))
        {
            throw new NotSupported ((string)add(add(add(this.id, " fetchFundingRateHistory() is not supported for "), type), " markets")) ;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["startTime"] = since;
        }
        object until = this.safeInteger2(parameters, "until", "till"); // unified in milliseconds
        object endTime = this.safeInteger(parameters, "endTime", until); // exchange-specific in milliseconds
        parameters = this.omit(parameters, new List<object>() {"endTime", "till", "until"});
        if (isTrue(!isEqual(endTime, null)))
        {
            ((Dictionary<string, object>)request)["endTime"] = endTime;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        //     {
        //         "symbol": "BTCUSDT",
        //         "fundingRate": "0.00063521",
        //         "fundingTime": "1621267200000",
        //     }
        //
        object rates = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object entry = getValue(response, i);
            object timestamp = this.safeInteger(entry, "fundingTime");
            ((List<object>)rates).Add(new Dictionary<string, object>() {
                { "info", entry },
                { "symbol", this.safeSymbol(this.safeString(entry, "symbol"), null, null, "swap") },
                { "fundingRate", this.safeNumber(entry, "fundingRate") },
                { "timestamp", timestamp },
                { "datetime", this.iso8601(timestamp) },
            });
        }
        object sorted = this.sortBy(rates, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, symbol, since, limit);
    }

    public async override Task<object> fetchFundingRates(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchFundingRates
        * @description fetch the funding rate for multiple markets
        * @param {[string]|undefined} symbols list of unified market symbols
        * @param {object} params extra parameters specific to the binance api endpoint
        * @returns {object} a dictionary of [funding rates structures]{@link https://docs.ccxt.com/#/?id=funding-rates-structure}, indexe by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object method = null;
        object defaultType = this.safeString2(this.options, "fetchFundingRates", "defaultType", "future");
        object type = this.safeString(parameters, "type", defaultType);
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchFundingRates", null, parameters, "linear");
        subType = ((List<object>)subTypeparametersVariable)[0];
        parameters = ((List<object>)subTypeparametersVariable)[1];
        object query = this.omit(parameters, "type");
        if (isTrue(this.isLinear(type, subType)))
        {
            method = "fapiPublicGetPremiumIndex";
        } else if (isTrue(this.isInverse(type, subType)))
        {
            method = "dapiPublicGetPremiumIndex";
        } else
        {
            throw new NotSupported ((string)add(this.id, " fetchFundingRates() supports linear and inverse contracts only")) ;
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { query }));
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object entry = getValue(response, i);
            object parsed = this.parseFundingRate(entry);
            ((List<object>)result).Add(parsed);
        }
        return this.filterByArray(result, "symbol", symbols);
    }

    public override object parseFundingRate(object contract, object market = null)
    {
        // ensure it matches with https://www.binance.com/en/futures/funding-history/0
        //
        //   {
        //     "symbol": "BTCUSDT",
        //     "markPrice": "45802.81129892",
        //     "indexPrice": "45745.47701915",
        //     "estimatedSettlePrice": "45133.91753671",
        //     "lastFundingRate": "0.00063521",
        //     "interestRate": "0.00010000",
        //     "nextFundingTime": "1621267200000",
        //     "time": "1621252344001"
        //  }
        //
        object timestamp = this.safeInteger(contract, "time");
        object marketId = this.safeString(contract, "symbol");
        object symbol = this.safeSymbol(marketId, market, null, "contract");
        object markPrice = this.safeNumber(contract, "markPrice");
        object indexPrice = this.safeNumber(contract, "indexPrice");
        object interestRate = this.safeNumber(contract, "interestRate");
        object estimatedSettlePrice = this.safeNumber(contract, "estimatedSettlePrice");
        object fundingRate = this.safeNumber(contract, "lastFundingRate");
        object fundingTime = this.safeInteger(contract, "nextFundingTime");
        return new Dictionary<string, object>() {
            { "info", contract },
            { "symbol", symbol },
            { "markPrice", markPrice },
            { "indexPrice", indexPrice },
            { "interestRate", interestRate },
            { "estimatedSettlePrice", estimatedSettlePrice },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "fundingRate", fundingRate },
            { "fundingTimestamp", fundingTime },
            { "fundingDatetime", this.iso8601(fundingTime) },
            { "nextFundingRate", null },
            { "nextFundingTimestamp", null },
            { "nextFundingDatetime", null },
            { "previousFundingRate", null },
            { "previousFundingTimestamp", null },
            { "previousFundingDatetime", null },
        };
    }

    public virtual object parseAccountPositions(object account)
    {
        object positions = this.safeValue(account, "positions");
        object assets = this.safeValue(account, "assets", new List<object>() {});
        object balances = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(assets)); postFixIncrement(ref i))
        {
            object entry = getValue(assets, i);
            object currencyId = this.safeString(entry, "asset");
            object code = this.safeCurrencyCode(currencyId);
            object crossWalletBalance = this.safeString(entry, "crossWalletBalance");
            object crossUnPnl = this.safeString(entry, "crossUnPnl");
            ((Dictionary<string, object>)balances)[(string)code] = new Dictionary<string, object>() {
                { "crossMargin", Precise.stringAdd(crossWalletBalance, crossUnPnl) },
                { "crossWalletBalance", crossWalletBalance },
            };
        }
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(positions)); postFixIncrement(ref i))
        {
            object position = getValue(positions, i);
            object marketId = this.safeString(position, "symbol");
            object market = this.safeMarket(marketId, null, null, "contract");
            object code = ((bool) isTrue(getValue(market, "linear"))) ? getValue(market, "quote") : getValue(market, "base");
            // sometimes not all the codes are correctly returned...
            if (isTrue(((Dictionary<string,object>)balances).ContainsKey(toStringOrNull(code))))
            {
                object parsed = this.parseAccountPosition(this.extend(position, new Dictionary<string, object>() {
                    { "crossMargin", getValue(getValue(balances, code), "crossMargin") },
                    { "crossWalletBalance", getValue(getValue(balances, code), "crossWalletBalance") },
                }), market);
                ((List<object>)result).Add(parsed);
            }
        }
        return result;
    }

    public virtual object parseAccountPosition(object position, object market = null)
    {
        //
        // usdm
        //    {
        //       "symbol": "BTCBUSD",
        //       "initialMargin": "0",
        //       "maintMargin": "0",
        //       "unrealizedProfit": "0.00000000",
        //       "positionInitialMargin": "0",
        //       "openOrderInitialMargin": "0",
        //       "leverage": "20",
        //       "isolated": false,
        //       "entryPrice": "0.0000",
        //       "maxNotional": "100000",
        //       "positionSide": "BOTH",
        //       "positionAmt": "0.000",
        //       "notional": "0",
        //       "isolatedWallet": "0",
        //       "updateTime": "0",
        //       "crossMargin": "100.93634809",
        //     }
        //
        // coinm
        //     {
        //       "symbol": "BTCUSD_210625",
        //       "initialMargin": "0.00024393",
        //       "maintMargin": "0.00002439",
        //       "unrealizedProfit": "-0.00000163",
        //       "positionInitialMargin": "0.00024393",
        //       "openOrderInitialMargin": "0",
        //       "leverage": "10",
        //       "isolated": false,
        //       "positionSide": "BOTH",
        //       "entryPrice": "41021.20000069",
        //       "maxQty": "100",
        //       "notionalValue": "0.00243939",
        //       "isolatedWallet": "0",
        //       "crossMargin": "0.314"
        //       "crossWalletBalance": "34",
        //     }
        //
        object marketId = this.safeString(position, "symbol");
        market = this.safeMarket(marketId, market, null, "contract");
        object symbol = this.safeString(market, "symbol");
        object leverageString = this.safeString(position, "leverage");
        object leverage = parseInt(leverageString);
        object initialMarginString = this.safeString(position, "initialMargin");
        object initialMargin = this.parseNumber(initialMarginString);
        object initialMarginPercentageString = Precise.stringDiv("1", leverageString, 8);
        object rational = isEqual((mod(1000, leverage)), 0);
        if (!isTrue(rational))
        {
            initialMarginPercentageString = Precise.stringDiv(Precise.stringAdd(initialMarginPercentageString, "1e-8"), "1", 8);
        }
        // as oppose to notionalValue
        object usdm = (((Dictionary<string,object>)position).ContainsKey(toStringOrNull("notional")));
        object maintenanceMarginString = this.safeString(position, "maintMargin");
        object maintenanceMargin = this.parseNumber(maintenanceMarginString);
        object entryPriceString = this.safeString(position, "entryPrice");
        object entryPrice = this.parseNumber(entryPriceString);
        object notionalString = this.safeString2(position, "notional", "notionalValue");
        object notionalStringAbs = Precise.stringAbs(notionalString);
        object notional = this.parseNumber(notionalStringAbs);
        object contractsString = this.safeString(position, "positionAmt");
        object contractsStringAbs = Precise.stringAbs(contractsString);
        if (isTrue(isEqual(contractsString, null)))
        {
            object entryNotional = Precise.stringMul(Precise.stringMul(leverageString, initialMarginString), entryPriceString);
            object contractSizeNew = this.safeString(market, "contractSize");
            contractsString = Precise.stringDiv(entryNotional, contractSizeNew);
            contractsStringAbs = Precise.stringDiv(Precise.stringAdd(contractsString, "0.5"), "1", 0);
        }
        object contracts = this.parseNumber(contractsStringAbs);
        object leverageBrackets = this.safeValue(this.options, "leverageBrackets", new Dictionary<string, object>() {});
        object leverageBracket = this.safeValue(leverageBrackets, symbol, new List<object>() {});
        object maintenanceMarginPercentageString = null;
        for (object i = 0; isLessThan(i, getArrayLength(leverageBracket)); postFixIncrement(ref i))
        {
            object bracket = getValue(leverageBracket, i);
            if (isTrue(Precise.stringLt(notionalStringAbs, getValue(bracket, 0))))
            {
                break;
            }
            maintenanceMarginPercentageString = getValue(bracket, 1);
        }
        object maintenanceMarginPercentage = this.parseNumber(maintenanceMarginPercentageString);
        object unrealizedPnlString = this.safeString(position, "unrealizedProfit");
        object unrealizedPnl = this.parseNumber(unrealizedPnlString);
        object timestamp = this.safeInteger(position, "updateTime");
        if (isTrue(isEqual(timestamp, 0)))
        {
            timestamp = null;
        }
        object isolated = this.safeValue(position, "isolated");
        object marginMode = null;
        object collateralString = null;
        object walletBalance = null;
        if (isTrue(isolated))
        {
            marginMode = "isolated";
            walletBalance = this.safeString(position, "isolatedWallet");
            collateralString = Precise.stringAdd(walletBalance, unrealizedPnlString);
        } else
        {
            marginMode = "cross";
            walletBalance = this.safeString(position, "crossWalletBalance");
            collateralString = this.safeString(position, "crossMargin");
        }
        object collateral = this.parseNumber(collateralString);
        object marginRatio = null;
        object side = null;
        object percentage = null;
        object liquidationPriceStringRaw = null;
        object liquidationPrice = null;
        object contractSize = this.safeValue(market, "contractSize");
        object contractSizeString = this.numberToString(contractSize);
        if (isTrue(Precise.stringEquals(notionalString, "0")))
        {
            entryPrice = null;
        } else
        {
            side = ((bool) isTrue(Precise.stringLt(notionalString, "0"))) ? "short" : "long";
            marginRatio = this.parseNumber(Precise.stringDiv(Precise.stringAdd(Precise.stringDiv(maintenanceMarginString, collateralString), "5e-5"), "1", 4));
            percentage = this.parseNumber(Precise.stringMul(Precise.stringDiv(unrealizedPnlString, initialMarginString, 4), "100"));
            if (isTrue(usdm))
            {
                // calculate liquidation price
                //
                // liquidationPrice = (walletBalance / (contracts * (1 + mmp))) + (entryPrice / (1 + mmp))
                //
                // mmp = maintenanceMarginPercentage
                // where  is negative for long and positive for short
                // TODO: calculate liquidation price for coinm contracts
                object onePlusMaintenanceMarginPercentageString = null;
                object entryPriceSignString = entryPriceString;
                if (isTrue(isEqual(side, "short")))
                {
                    onePlusMaintenanceMarginPercentageString = Precise.stringAdd("1", maintenanceMarginPercentageString);
                } else
                {
                    onePlusMaintenanceMarginPercentageString = Precise.stringAdd("-1", maintenanceMarginPercentageString);
                    entryPriceSignString = Precise.stringMul("-1", entryPriceSignString);
                }
                object leftSide = Precise.stringDiv(walletBalance, Precise.stringMul(contractsStringAbs, onePlusMaintenanceMarginPercentageString));
                object rightSide = Precise.stringDiv(entryPriceSignString, onePlusMaintenanceMarginPercentageString);
                liquidationPriceStringRaw = Precise.stringAdd(leftSide, rightSide);
            } else
            {
                // calculate liquidation price
                //
                // liquidationPrice = (contracts * contractSize(1 - mmp)) / (1/entryPrice * contracts * contractSize - walletBalance)
                //
                object onePlusMaintenanceMarginPercentageString = null;
                object entryPriceSignString = entryPriceString;
                if (isTrue(isEqual(side, "short")))
                {
                    onePlusMaintenanceMarginPercentageString = Precise.stringSub("1", maintenanceMarginPercentageString);
                } else
                {
                    onePlusMaintenanceMarginPercentageString = Precise.stringSub("-1", maintenanceMarginPercentageString);
                    entryPriceSignString = Precise.stringMul("-1", entryPriceSignString);
                }
                object size = Precise.stringMul(contractsStringAbs, contractSizeString);
                object leftSide = Precise.stringMul(size, onePlusMaintenanceMarginPercentageString);
                object rightSide = Precise.stringSub(Precise.stringMul(Precise.stringDiv("1", entryPriceSignString), size), walletBalance);
                liquidationPriceStringRaw = Precise.stringDiv(leftSide, rightSide);
            }
            object pricePrecision = getValue(getValue(market, "precision"), "price");
            object pricePrecisionPlusOne = add(pricePrecision, 1);
            object pricePrecisionPlusOneString = ((object)pricePrecisionPlusOne).ToString();
            // round half up
            var rounder = new Precise(add("5e-", pricePrecisionPlusOneString));
            object rounderString = ((object)rounder).ToString();
            object liquidationPriceRoundedString = Precise.stringAdd(rounderString, liquidationPriceStringRaw);
            object truncatedLiquidationPrice = Precise.stringDiv(liquidationPriceRoundedString, "1", pricePrecision);
            if (isTrue(isEqual(getValue(truncatedLiquidationPrice, 0), "-")))
            {
                // user cannot be liquidated
                // since he has more collateral than the size of the position
                truncatedLiquidationPrice = null;
            }
            liquidationPrice = this.parseNumber(truncatedLiquidationPrice);
        }
        object positionSide = this.safeString(position, "positionSide");
        object hedged = !isEqual(positionSide, "BOTH");
        return new Dictionary<string, object>() {
            { "info", position },
            { "id", null },
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "initialMargin", initialMargin },
            { "initialMarginPercentage", this.parseNumber(initialMarginPercentageString) },
            { "maintenanceMargin", maintenanceMargin },
            { "maintenanceMarginPercentage", maintenanceMarginPercentage },
            { "entryPrice", entryPrice },
            { "notional", notional },
            { "leverage", this.parseNumber(leverageString) },
            { "unrealizedPnl", unrealizedPnl },
            { "contracts", contracts },
            { "contractSize", contractSize },
            { "marginRatio", marginRatio },
            { "liquidationPrice", liquidationPrice },
            { "markPrice", null },
            { "collateral", collateral },
            { "marginMode", marginMode },
            { "side", side },
            { "hedged", hedged },
            { "percentage", percentage },
        };
    }

    public virtual object parsePositionRisk(object position, object market = null)
    {
        //
        // usdm
        //     {
        //       "symbol": "BTCUSDT",
        //       "positionAmt": "0.001",
        //       "entryPrice": "43578.07000",
        //       "markPrice": "43532.30000000",
        //       "unRealizedProfit": "-0.04577000",
        //       "liquidationPrice": "21841.24993976",
        //       "leverage": "2",
        //       "maxNotionalValue": "300000000",
        //       "marginType": "isolated",
        //       "isolatedMargin": "21.77841506",
        //       "isAutoAddMargin": "false",
        //       "positionSide": "BOTH",
        //       "notional": "43.53230000",
        //       "isolatedWallet": "21.82418506",
        //       "updateTime": "1621358023886"
        //     }
        //
        // coinm
        //     {
        //       "symbol": "BTCUSD_PERP",
        //       "positionAmt": "2",
        //       "entryPrice": "37643.10000021",
        //       "markPrice": "38103.05510455",
        //       "unRealizedProfit": "0.00006413",
        //       "liquidationPrice": "25119.97445760",
        //       "leverage": "2",
        //       "maxQty": "1500",
        //       "marginType": "isolated",
        //       "isolatedMargin": "0.00274471",
        //       "isAutoAddMargin": "false",
        //       "positionSide": "BOTH",
        //       "notionalValue": "0.00524892",
        //       "isolatedWallet": "0.00268058"
        //     }
        //
        object marketId = this.safeString(position, "symbol");
        market = this.safeMarket(marketId, market, null, "contract");
        object symbol = this.safeString(market, "symbol");
        object leverageBrackets = this.safeValue(this.options, "leverageBrackets", new Dictionary<string, object>() {});
        object leverageBracket = this.safeValue(leverageBrackets, symbol, new List<object>() {});
        object notionalString = this.safeString2(position, "notional", "notionalValue");
        object notionalStringAbs = Precise.stringAbs(notionalString);
        object maintenanceMarginPercentageString = null;
        for (object i = 0; isLessThan(i, getArrayLength(leverageBracket)); postFixIncrement(ref i))
        {
            object bracket = getValue(leverageBracket, i);
            if (isTrue(Precise.stringLt(notionalStringAbs, getValue(bracket, 0))))
            {
                break;
            }
            maintenanceMarginPercentageString = getValue(bracket, 1);
        }
        object notional = this.parseNumber(notionalStringAbs);
        object contractsAbs = Precise.stringAbs(this.safeString(position, "positionAmt"));
        object contracts = this.parseNumber(contractsAbs);
        object unrealizedPnlString = this.safeString(position, "unRealizedProfit");
        object unrealizedPnl = this.parseNumber(unrealizedPnlString);
        object leverageString = this.safeString(position, "leverage");
        object leverage = parseInt(leverageString);
        object liquidationPriceString = this.omitZero(this.safeString(position, "liquidationPrice"));
        object liquidationPrice = this.parseNumber(liquidationPriceString);
        object collateralString = null;
        object marginMode = this.safeString(position, "marginType");
        object side = null;
        if (isTrue(Precise.stringGt(notionalString, "0")))
        {
            side = "long";
        } else if (isTrue(Precise.stringLt(notionalString, "0")))
        {
            side = "short";
        }
        object entryPriceString = this.safeString(position, "entryPrice");
        object entryPrice = this.parseNumber(entryPriceString);
        object contractSize = this.safeValue(market, "contractSize");
        object contractSizeString = this.numberToString(contractSize);
        // as oppose to notionalValue
        object linear = (((Dictionary<string,object>)position).ContainsKey(toStringOrNull("notional")));
        if (isTrue(isEqual(marginMode, "cross")))
        {
            // calculate collateral
            object precision = this.safeValue(market, "precision", new Dictionary<string, object>() {});
            if (isTrue(linear))
            {
                // walletBalance = (liquidationPrice * (1 + mmp)  entryPrice) * contracts
                object onePlusMaintenanceMarginPercentageString = null;
                object entryPriceSignString = entryPriceString;
                if (isTrue(isEqual(side, "short")))
                {
                    onePlusMaintenanceMarginPercentageString = Precise.stringAdd("1", maintenanceMarginPercentageString);
                    entryPriceSignString = Precise.stringMul("-1", entryPriceSignString);
                } else
                {
                    onePlusMaintenanceMarginPercentageString = Precise.stringAdd("-1", maintenanceMarginPercentageString);
                }
                object inner = Precise.stringMul(liquidationPriceString, onePlusMaintenanceMarginPercentageString);
                object leftSide = Precise.stringAdd(inner, entryPriceSignString);
                object pricePrecision = this.safeInteger(precision, "price");
                object quotePrecision = this.safeInteger(precision, "quote", pricePrecision);
                if (isTrue(!isEqual(quotePrecision, null)))
                {
                    collateralString = Precise.stringDiv(Precise.stringMul(leftSide, contractsAbs), "1", quotePrecision);
                }
            } else
            {
                // walletBalance = (contracts * contractSize) * (1/entryPrice - (1 - mmp) / liquidationPrice)
                object onePlusMaintenanceMarginPercentageString = null;
                object entryPriceSignString = entryPriceString;
                if (isTrue(isEqual(side, "short")))
                {
                    onePlusMaintenanceMarginPercentageString = Precise.stringSub("1", maintenanceMarginPercentageString);
                } else
                {
                    onePlusMaintenanceMarginPercentageString = Precise.stringSub("-1", maintenanceMarginPercentageString);
                    entryPriceSignString = Precise.stringMul("-1", entryPriceSignString);
                }
                object leftSide = Precise.stringMul(contractsAbs, contractSizeString);
                object rightSide = Precise.stringSub(Precise.stringDiv("1", entryPriceSignString), Precise.stringDiv(onePlusMaintenanceMarginPercentageString, liquidationPriceString));
                object basePrecision = this.safeInteger(precision, "base");
                if (isTrue(!isEqual(basePrecision, null)))
                {
                    collateralString = Precise.stringDiv(Precise.stringMul(leftSide, rightSide), "1", basePrecision);
                }
            }
        } else
        {
            collateralString = this.safeString(position, "isolatedMargin");
        }
        collateralString = ((bool) isTrue((isEqual(collateralString, null)))) ? "0" : collateralString;
        object collateral = this.parseNumber(collateralString);
        object markPrice = this.parseNumber(this.omitZero(this.safeString(position, "markPrice")));
        object timestamp = this.safeInteger(position, "updateTime");
        if (isTrue(isEqual(timestamp, 0)))
        {
            timestamp = null;
        }
        object maintenanceMarginPercentage = this.parseNumber(maintenanceMarginPercentageString);
        object maintenanceMarginString = Precise.stringMul(maintenanceMarginPercentageString, notionalStringAbs);
        object maintenanceMargin = this.parseNumber(maintenanceMarginString);
        object initialMarginPercentageString = Precise.stringDiv("1", leverageString, 8);
        object rational = isEqual((mod(1000, leverage)), 0);
        if (!isTrue(rational))
        {
            initialMarginPercentageString = Precise.stringAdd(initialMarginPercentageString, "1e-8");
        }
        object initialMarginString = Precise.stringDiv(Precise.stringMul(notionalStringAbs, initialMarginPercentageString), "1", 8);
        object initialMargin = this.parseNumber(initialMarginString);
        object marginRatio = null;
        object percentage = null;
        if (!isTrue(Precise.stringEquals(collateralString, "0")))
        {
            marginRatio = this.parseNumber(Precise.stringDiv(Precise.stringAdd(Precise.stringDiv(maintenanceMarginString, collateralString), "5e-5"), "1", 4));
            percentage = this.parseNumber(Precise.stringMul(Precise.stringDiv(unrealizedPnlString, initialMarginString, 4), "100"));
        }
        object positionSide = this.safeString(position, "positionSide");
        object hedged = !isEqual(positionSide, "BOTH");
        return new Dictionary<string, object>() {
            { "info", position },
            { "id", null },
            { "symbol", symbol },
            { "contracts", contracts },
            { "contractSize", contractSize },
            { "unrealizedPnl", unrealizedPnl },
            { "leverage", this.parseNumber(leverageString) },
            { "liquidationPrice", liquidationPrice },
            { "collateral", collateral },
            { "notional", notional },
            { "markPrice", markPrice },
            { "entryPrice", entryPrice },
            { "timestamp", timestamp },
            { "initialMargin", initialMargin },
            { "initialMarginPercentage", this.parseNumber(initialMarginPercentageString) },
            { "maintenanceMargin", maintenanceMargin },
            { "maintenanceMarginPercentage", maintenanceMarginPercentage },
            { "marginRatio", marginRatio },
            { "datetime", this.iso8601(timestamp) },
            { "marginMode", marginMode },
            { "marginType", marginMode },
            { "side", side },
            { "hedged", hedged },
            { "percentage", percentage },
        };
    }

    public async virtual Task<object> loadLeverageBrackets(object reload = null, object parameters = null)
    {
        reload ??= false;
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        // by default cache the leverage bracket
        // it contains useful stuff like the maintenance margin and initial margin for positions
        object leverageBrackets = this.safeValue(this.options, "leverageBrackets");
        if (isTrue(isTrue((isEqual(leverageBrackets, null))) || isTrue((reload))))
        {
            object method = null;
            object defaultType = this.safeString(this.options, "defaultType", "future");
            object type = this.safeString(parameters, "type", defaultType);
            object query = this.omit(parameters, "type");
            object subType = null;
            var subTypeparametersVariable = this.handleSubTypeAndParams("loadLeverageBrackets", null, parameters, "linear");
            subType = ((List<object>)subTypeparametersVariable)[0];
            parameters = ((List<object>)subTypeparametersVariable)[1];
            if (isTrue(this.isLinear(type, subType)))
            {
                method = "fapiPrivateGetLeverageBracket";
            } else if (isTrue(this.isInverse(type, subType)))
            {
                method = "dapiPrivateV2GetLeverageBracket";
            } else
            {
                throw new NotSupported ((string)add(this.id, " loadLeverageBrackets() supports linear and inverse contracts only")) ;
            }
            object response = await ((Task<object>)callDynamically(this, method, new object[] { query }));
            ((Dictionary<string, object>)this.options)["leverageBrackets"] = new Dictionary<string, object>() {};
            for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
            {
                object entry = getValue(response, i);
                object marketId = this.safeString(entry, "symbol");
                object symbol = this.safeSymbol(marketId, null, null, "contract");
                object brackets = this.safeValue(entry, "brackets", new List<object>() {});
                object result = new List<object>() {};
                for (object j = 0; isLessThan(j, getArrayLength(brackets)); postFixIncrement(ref j))
                {
                    object bracket = getValue(brackets, j);
                    object floorValue = this.safeString2(bracket, "notionalFloor", "qtyFloor");
                    object maintenanceMarginPercentage = this.safeString(bracket, "maintMarginRatio");
                    ((List<object>)result).Add(new List<object>() {floorValue, maintenanceMarginPercentage});
                }
                ((Dictionary<string, object>)getValue(this.options, "leverageBrackets"))[(string)symbol] = result;
            }
        }
        return getValue(this.options, "leverageBrackets");
    }

    public async override Task<object> fetchLeverageTiers(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchLeverageTiers
        * @description retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes
        * @param {[string]|undefined} symbols list of unified market symbols
        * @param {object} params extra parameters specific to the binance api endpoint
        * @returns {object} a dictionary of [leverage tiers structures]{@link https://docs.ccxt.com/#/?id=leverage-tiers-structure}, indexed by market symbols
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        var typequeryVariable = this.handleMarketTypeAndParams("fetchLeverageTiers", null, parameters);
        var type = ((List<object>) typequeryVariable)[0];
        var query = ((List<object>) typequeryVariable)[1];
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchLeverageTiers", null, query, "linear");
        subType = ((List<object>)subTypeparametersVariable)[0];
        parameters = ((List<object>)subTypeparametersVariable)[1];
        object method = null;
        if (isTrue(this.isLinear(type, subType)))
        {
            method = "fapiPrivateGetLeverageBracket";
        } else if (isTrue(this.isInverse(type, subType)))
        {
            method = "dapiPrivateV2GetLeverageBracket";
        } else
        {
            throw new NotSupported ((string)add(this.id, " fetchLeverageTiers() supports linear and inverse contracts only")) ;
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { query }));
        //
        // usdm
        //
        //    [
        //        {
        //            "symbol": "SUSHIUSDT",
        //            "brackets": [
        //                {
        //                    "bracket": 1,
        //                    "initialLeverage": 50,
        //                    "notionalCap": 50000,
        //                    "notionalFloor": 0,
        //                    "maintMarginRatio": 0.01,
        //                    "cum": 0.0
        //                },
        //                ...
        //            ]
        //        }
        //    ]
        //
        // coinm
        //
        //     [
        //         {
        //             "symbol":"XRPUSD_210326",
        //             "brackets":[
        //                 {
        //                     "bracket":1,
        //                     "initialLeverage":20,
        //                     "qtyCap":500000,
        //                     "qtyFloor":0,
        //                     "maintMarginRatio":0.0185,
        //                     "cum":0.0
        //                 }
        //             ]
        //         }
        //     ]
        //
        return this.parseLeverageTiers(response, symbols, "symbol");
    }

    public override object parseMarketLeverageTiers(object info, object market = null)
    {
        /**
         * @ignore
         * @method
         * @param {object} info Exchange response for 1 market
         * @param {object} market CCXT market
         */
        //
        //    {
        //        "symbol": "SUSHIUSDT",
        //        "brackets": [
        //            {
        //                "bracket": 1,
        //                "initialLeverage": 50,
        //                "notionalCap": 50000,
        //                "notionalFloor": 0,
        //                "maintMarginRatio": 0.01,
        //                "cum": 0.0
        //            },
        //            ...
        //        ]
        //    }
        //
        object marketId = this.safeString(info, "symbol");
        market = this.safeMarket(marketId, market, null, "contract");
        object brackets = this.safeValue(info, "brackets", new List<object>() {});
        object tiers = new List<object>() {};
        for (object j = 0; isLessThan(j, getArrayLength(brackets)); postFixIncrement(ref j))
        {
            object bracket = getValue(brackets, j);
            ((List<object>)tiers).Add(new Dictionary<string, object>() {
                { "tier", this.safeNumber(bracket, "bracket") },
                { "currency", getValue(market, "quote") },
                { "minNotional", this.safeNumber2(bracket, "notionalFloor", "qtyFloor") },
                { "maxNotional", this.safeNumber2(bracket, "notionalCap", "qtyCap") },
                { "maintenanceMarginRate", this.safeNumber(bracket, "maintMarginRatio") },
                { "maxLeverage", this.safeNumber(bracket, "initialLeverage") },
                { "info", bracket },
            });
        }
        return tiers;
    }

    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchPositions
        * @description fetch all open positions
        * @param {[string]|undefined} symbols list of unified market symbols
        * @param {object} params extra parameters specific to the binance api endpoint
        * @returns {[object]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
        */
        parameters ??= new Dictionary<string, object>();
        object defaultMethod = this.safeString(this.options, "fetchPositions", "positionRisk");
        if (isTrue(isEqual(defaultMethod, "positionRisk")))
        {
            return await this.fetchPositionsRisk(symbols, parameters);
        } else if (isTrue(isEqual(defaultMethod, "account")))
        {
            return await this.fetchAccountPositions(symbols, parameters);
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, ".options[\"fetchPositions\"] = \""), defaultMethod), "\" is invalid, please choose between \"account\" and \"positionRisk\"")) ;
        }
    }

    public async virtual Task<object> fetchAccountPositions(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchAccountPositions
        * @description fetch account positions
        * @param {[string]|undefined} symbols list of unified market symbols
        * @param {object} params extra parameters specific to the binance api endpoint
        * @returns {object} data on account positions
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(!isEqual(symbols, null)))
        {
            if (!isTrue((symbols.GetType().IsGenericType && symbols.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchPositions() requires an array argument for symbols")) ;
            }
        }
        await this.loadMarkets();
        await this.loadLeverageBrackets(false, parameters);
        object method = null;
        object defaultType = this.safeString(this.options, "defaultType", "future");
        object type = this.safeString(parameters, "type", defaultType);
        object query = this.omit(parameters, "type");
        object subType = null;
        var subTypequeryVariable = this.handleSubTypeAndParams("fetchAccountPositions", null, parameters, "linear");
        subType = ((List<object>)subTypequeryVariable)[0];
        query = ((List<object>)subTypequeryVariable)[1];
        if (isTrue(this.isLinear(type, subType)))
        {
            method = "fapiPrivateGetAccount";
        } else if (isTrue(this.isInverse(type, subType)))
        {
            method = "dapiPrivateGetAccount";
        } else
        {
            throw new NotSupported ((string)add(this.id, " fetchPositions() supports linear and inverse contracts only")) ;
        }
        object account = await ((Task<object>)callDynamically(this, method, new object[] { query }));
        object result = this.parseAccountPositions(account);
        symbols = this.marketSymbols(symbols);
        return this.filterByArray(result, "symbol", symbols, false);
    }

    public async override Task<object> fetchPositionsRisk(object symbols = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchPositionsRisk
        * @description fetch positions risk
        * @param {[string]|undefined} symbols list of unified market symbols
        * @param {object} params extra parameters specific to the binance api endpoint
        * @returns {object} data on the positions risk
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(!isEqual(symbols, null)))
        {
            if (!isTrue((symbols.GetType().IsGenericType && symbols.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))
            {
                throw new ArgumentsRequired ((string)add(this.id, " fetchPositionsRisk() requires an array argument for symbols")) ;
            }
        }
        await this.loadMarkets();
        await this.loadLeverageBrackets(false, parameters);
        object request = new Dictionary<string, object>() {};
        object method = null;
        object defaultType = "future";
        defaultType = this.safeString(this.options, "defaultType", defaultType);
        object type = this.safeString(parameters, "type", defaultType);
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchPositionsRisk", null, parameters, "linear");
        subType = ((List<object>)subTypeparametersVariable)[0];
        parameters = ((List<object>)subTypeparametersVariable)[1];
        parameters = this.omit(parameters, "type");
        if (isTrue(this.isLinear(type, subType)))
        {
            method = "fapiPrivateGetPositionRisk";
        } else if (isTrue(this.isInverse(type, subType)))
        {
            method = "dapiPrivateGetPositionRisk";
        } else
        {
            throw new NotSupported ((string)add(this.id, " fetchPositionsRisk() supports linear and inverse contracts only")) ;
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object parsed = this.parsePositionRisk(getValue(response, i));
            ((List<object>)result).Add(parsed);
        }
        symbols = this.marketSymbols(symbols);
        return this.filterByArray(result, "symbol", symbols, false);
    }

    public async virtual Task<object> fetchFundingHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchFundingHistory
        * @description fetch the history of funding payments paid and received on this account
        * @param {string|undefined} symbol unified market symbol
        * @param {int|undefined} since the earliest time in ms to fetch funding history for
        * @param {int|undefined} limit the maximum number of funding history structures to retrieve
        * @param {object} params extra parameters specific to the binance api endpoint
        * @returns {object} a [funding history structure]{@link https://docs.ccxt.com/#/?id=funding-history-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        object method = null;
        object request = new Dictionary<string, object>() {
            { "incomeType", "FUNDING_FEE" },
        };
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
            if (!isTrue(getValue(market, "swap")))
            {
                throw new NotSupported ((string)add(this.id, " fetchFundingHistory() supports swap contracts only")) ;
            }
        }
        object subType = null;
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchFundingHistory", market, parameters, "linear");
        subType = ((List<object>)subTypeparametersVariable)[0];
        parameters = ((List<object>)subTypeparametersVariable)[1];
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object defaultType = this.safeString2(this.options, "fetchFundingHistory", "defaultType", "future");
        object type = this.safeString(parameters, "type", defaultType);
        parameters = this.omit(parameters, "type");
        if (isTrue(this.isLinear(type, subType)))
        {
            method = "fapiPrivateGetIncome";
        } else if (isTrue(this.isInverse(type, subType)))
        {
            method = "dapiPrivateGetIncome";
        } else
        {
            throw new NotSupported ((string)add(this.id, " fetchFundingHistory() supports linear and inverse contracts only")) ;
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        return this.parseIncomes(response, market, since, limit);
    }

    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#setLeverage
        * @description set the level of leverage for a market
        * @param {float} leverage the rate of leverage
        * @param {string} symbol unified market symbol
        * @param {object} params extra parameters specific to the binance api endpoint
        * @returns {object} response from the exchange
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setLeverage() requires a symbol argument")) ;
        }
        // WARNING: THIS WILL INCREASE LIQUIDATION PRICE FOR OPEN ISOLATED LONG POSITIONS
        // AND DECREASE LIQUIDATION PRICE FOR OPEN ISOLATED SHORT POSITIONS
        if (isTrue(isTrue((isLessThan(leverage, 1))) || isTrue((isGreaterThan(leverage, 125)))))
        {
            throw new BadRequest ((string)add(this.id, " leverage should be between 1 and 125")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object method = null;
        if (isTrue(getValue(market, "linear")))
        {
            method = "fapiPrivatePostLeverage";
        } else if (isTrue(getValue(market, "inverse")))
        {
            method = "dapiPrivatePostLeverage";
        } else
        {
            throw new NotSupported ((string)add(this.id, " setLeverage() supports linear and inverse contracts only")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "leverage", leverage },
        };
        return await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
    }

    public async virtual Task<object> setMarginMode(object marginMode, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#setMarginMode
        * @description set margin mode to 'cross' or 'isolated'
        * @param {string} marginMode 'cross' or 'isolated'
        * @param {string} symbol unified market symbol
        * @param {object} params extra parameters specific to the binance api endpoint
        * @returns {object} response from the exchange
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setMarginMode() requires a symbol argument")) ;
        }
        //
        // { "code": -4048 , "msg": "Margin type cannot be changed if there exists position." }
        //
        // or
        //
        // { "code": 200, "msg": "success" }
        //
        marginMode = ((string)marginMode).ToUpper();
        if (isTrue(isEqual(marginMode, "CROSS")))
        {
            marginMode = "CROSSED";
        }
        if (isTrue(isTrue((!isEqual(marginMode, "ISOLATED"))) && isTrue((!isEqual(marginMode, "CROSSED")))))
        {
            throw new BadRequest ((string)add(this.id, " marginMode must be either isolated or cross")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object method = null;
        if (isTrue(getValue(market, "linear")))
        {
            method = "fapiPrivatePostMarginType";
        } else if (isTrue(getValue(market, "inverse")))
        {
            method = "dapiPrivatePostMarginType";
        } else
        {
            throw new NotSupported ((string)add(this.id, " setMarginMode() supports linear and inverse contracts only")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
            { "marginType", marginMode },
        };
        object response = null;
        try
        {
            response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        } catch(Exception e)
        {
            // not an error
            // https://github.com/ccxt/ccxt/issues/11268
            // https://github.com/ccxt/ccxt/pull/11624
            // POST https://fapi.binance.com/fapi/v1/marginType 400 Bad Request
            // binanceusdm
            if (isTrue(e is MarginModeAlreadySet))
            {
                object throwMarginModeAlreadySet = this.safeValue(this.options, "throwMarginModeAlreadySet", false);
                if (isTrue(throwMarginModeAlreadySet))
                {
                    throw e;
                } else
                {
                    response = new Dictionary<string, object>() {
                        { "code", -4046 },
                        { "msg", "No need to change margin type." },
                    };
                }
            } else
            {
                throw e;
            }
        }
        return response;
    }

    public async virtual Task<object> setPositionMode(object hedged, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#setPositionMode
        * @description set hedged to true or false for a market
        * @param {bool} hedged set to true to use dualSidePosition
        * @param {string|undefined} symbol not used by binance setPositionMode ()
        * @param {object} params extra parameters specific to the binance api endpoint
        * @returns {object} response from the exchange
        */
        parameters ??= new Dictionary<string, object>();
        object defaultType = this.safeString(this.options, "defaultType", "future");
        object type = this.safeString(parameters, "type", defaultType);
        parameters = this.omit(parameters, new List<object>() {"type"});
        object dualSidePosition = null;
        if (isTrue(hedged))
        {
            dualSidePosition = "true";
        } else
        {
            dualSidePosition = "false";
        }
        object request = new Dictionary<string, object>() {
            { "dualSidePosition", dualSidePosition },
        };
        object method = null;
        if (isTrue(this.isInverse(type)))
        {
            method = "dapiPrivatePostPositionSideDual";
        } else
        {
            // default to future
            method = "fapiPrivatePostPositionSideDual";
        }
        //
        //     {
        //       "code": 200,
        //       "msg": "success"
        //     }
        //
        return await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
    }

    public async virtual Task<object> fetchSettlementHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchSettlementHistory
        * @description fetches historical settlement records
        * @see https://binance-docs.github.io/apidocs/voptions/en/#historical-exercise-records
        * @param {string} symbol unified market symbol of the settlement history
        * @param {int} since timestamp in ms
        * @param {int} limit number of records, default 100, max 100
        * @param {object} params exchange specific params
        * @returns {[object]} a list of [settlement history objects]
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = ((bool) isTrue((isEqual(symbol, null)))) ? null : this.market(symbol);
        object type = null;
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchSettlementHistory", market, parameters);
        type = ((List<object>)typeparametersVariable)[0];
        parameters = ((List<object>)typeparametersVariable)[1];
        if (isTrue(!isEqual(type, "option")))
        {
            throw new NotSupported ((string)add(this.id, " fetchSettlementHistory() supports option markets only")) ;
        }
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            symbol = getValue(market, "symbol");
            ((Dictionary<string, object>)request)["underlying"] = add(getValue(market, "baseId"), getValue(market, "quoteId"));
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object response = await this.eapiPublicGetExerciseHistory(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "symbol": "ETH-230223-1900-P",
        //             "strikePrice": "1900",
        //             "realStrikePrice": "1665.5897334",
        //             "expiryDate": 1677139200000,
        //             "strikeResult": "REALISTIC_VALUE_STRICKEN"
        //         }
        //     ]
        //
        object settlements = this.parseSettlements(response, market);
        object sorted = this.sortBy(settlements, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, symbol, since, limit);
    }

    public virtual object parseSettlement(object settlement, object market)
    {
        //
        //     {
        //         "symbol": "ETH-230223-1900-P",
        //         "strikePrice": "1900",
        //         "realStrikePrice": "1665.5897334",
        //         "expiryDate": 1677139200000,
        //         "strikeResult": "REALISTIC_VALUE_STRICKEN"
        //     }
        //
        object timestamp = this.safeInteger(settlement, "expiryDate");
        object marketId = this.safeString(settlement, "symbol");
        return new Dictionary<string, object>() {
            { "info", settlement },
            { "symbol", this.safeSymbol(marketId, market) },
            { "price", this.safeNumber(settlement, "realStrikePrice") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
        };
    }

    public virtual object parseSettlements(object settlements, object market)
    {
        //
        //     [
        //         {
        //             "symbol": "ETH-230223-1900-P",
        //             "strikePrice": "1900",
        //             "realStrikePrice": "1665.5897334",
        //             "expiryDate": 1677139200000,
        //             "strikeResult": "EXTRINSIC_VALUE_EXPIRED"
        //         }
        //     ]
        //
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(settlements)); postFixIncrement(ref i))
        {
            ((List<object>)result).Add(this.parseSettlement(getValue(settlements, i), market));
        }
        return result;
    }

    public async override Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchLedger
        * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
        * @see https://binance-docs.github.io/apidocs/voptions/en/#account-funding-flow-user_data
        * @see https://binance-docs.github.io/apidocs/futures/en/#get-income-history-user_data
        * @see https://binance-docs.github.io/apidocs/delivery/en/#get-income-history-user_data
        * @param {string|undefined} code unified currency code
        * @param {int|undefined} since timestamp in ms of the earliest ledger entry
        * @param {int|undefined} limit max number of ledger entrys to return
        * @param {object} params extra parameters specific to the binance api endpoint
        * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object type = null;
        object subType = null;
        object currency = null;
        object method = null;
        object request = new Dictionary<string, object>() {};
        var typeparametersVariable = this.handleMarketTypeAndParams("fetchLedger", null, parameters);
        type = ((List<object>)typeparametersVariable)[0];
        parameters = ((List<object>)typeparametersVariable)[1];
        var subTypeparametersVariable = this.handleSubTypeAndParams("fetchLedger", null, parameters);
        subType = ((List<object>)subTypeparametersVariable)[0];
        parameters = ((List<object>)subTypeparametersVariable)[1];
        if (isTrue(isEqual(type, "option")))
        {
            this.checkRequiredArgument("fetchLedger", code, "code");
            currency = this.currency(code);
            ((Dictionary<string, object>)request)["currency"] = getValue(currency, "id");
            method = "eapiPrivateGetBill";
        } else if (isTrue(this.isLinear(type, subType)))
        {
            method = "fapiPrivateGetIncome";
        } else if (isTrue(this.isInverse(type, subType)))
        {
            method = "dapiPrivateGetIncome";
        } else
        {
            throw new NotSupported ((string)add(this.id, " fetchLedger() supports contract wallets only")) ;
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        // options (eapi)
        //
        //     [
        //         {
        //             "id": "1125899906845701870",
        //             "asset": "USDT",
        //             "amount": "-0.16518203",
        //             "type": "FEE",
        //             "createDate": 1676621042489
        //         }
        //     ]
        //
        // futures (fapi, dapi)
        //
        //     [
        //         {
        //             "symbol": "",
        //             "incomeType": "TRANSFER",
        //             "income": "10.00000000",
        //             "asset": "USDT",
        //             "time": 1677645250000,
        //             "info": "TRANSFER",
        //             "tranId": 131001573082,
        //             "tradeId": ""
        //         }
        //     ]
        //
        return this.parseLedger(response, currency, since, limit);
    }

    public override object parseLedgerEntry(object item, object currency = null)
    {
        //
        // options (eapi)
        //
        //     {
        //         "id": "1125899906845701870",
        //         "asset": "USDT",
        //         "amount": "-0.16518203",
        //         "type": "FEE",
        //         "createDate": 1676621042489
        //     }
        //
        // futures (fapi, dapi)
        //
        //     {
        //         "symbol": "",
        //         "incomeType": "TRANSFER",
        //         "income": "10.00000000",
        //         "asset": "USDT",
        //         "time": 1677645250000,
        //         "info": "TRANSFER",
        //         "tranId": 131001573082,
        //         "tradeId": ""
        //     }
        //
        object amount = this.safeString2(item, "amount", "income");
        object direction = null;
        if (isTrue(Precise.stringLe(amount, "0")))
        {
            direction = "out";
            amount = Precise.stringMul("-1", amount);
        } else
        {
            direction = "in";
        }
        object currencyId = this.safeString(item, "asset");
        object timestamp = this.safeInteger2(item, "createDate", "time");
        object type = this.safeString2(item, "type", "incomeType");
        return new Dictionary<string, object>() {
            { "id", this.safeString2(item, "id", "tranId") },
            { "direction", direction },
            { "account", null },
            { "referenceAccount", null },
            { "referenceId", this.safeString(item, "tradeId") },
            { "type", this.parseLedgerEntryType(type) },
            { "currency", this.safeCurrencyCode(currencyId, currency) },
            { "amount", this.parseNumber(amount) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "before", null },
            { "after", null },
            { "status", null },
            { "fee", null },
            { "info", item },
        };
    }

    public virtual object parseLedgerEntryType(object type)
    {
        object ledgerType = new Dictionary<string, object>() {
            { "FEE", "fee" },
            { "FUNDING_FEE", "fee" },
            { "OPTIONS_PREMIUM_FEE", "fee" },
            { "POSITION_LIMIT_INCREASE_FEE", "fee" },
            { "CONTRACT", "trade" },
            { "REALIZED_PNL", "trade" },
            { "TRANSFER", "transfer" },
            { "CROSS_COLLATERAL_TRANSFER", "transfer" },
            { "INTERNAL_TRANSFER", "transfer" },
            { "COIN_SWAP_DEPOSIT", "deposit" },
            { "COIN_SWAP_WITHDRAW", "withdrawal" },
            { "OPTIONS_SETTLE_PROFIT", "settlement" },
            { "DELIVERED_SETTELMENT", "settlement" },
            { "WELCOME_BONUS", "cashback" },
            { "CONTEST_REWARD", "cashback" },
            { "COMMISSION_REBATE", "rebate" },
            { "API_REBATE", "rebate" },
            { "REFERRAL_KICKBACK", "referral" },
            { "COMMISSION", "commission" },
        };
        return this.safeString(ledgerType, type, type);
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object urls = ((object)this.urls);
        if (!isTrue((((Dictionary<string,object>)getValue(urls, "api")).ContainsKey(toStringOrNull(api)))))
        {
            throw new NotSupported ((string)add(add(add(this.id, " does not have a testnet/sandbox URL for "), api), " endpoints")) ;
        }
        object url = getValue(getValue(this.urls, "api"), api);
        url = add(url, add("/", path));
        if (isTrue(isEqual(api, "wapi")))
        {
            url = add(url, ".html");
        }
        if (isTrue(isEqual(path, "historicalTrades")))
        {
            if (isTrue(this.apiKey))
            {
                headers = new Dictionary<string, object>() {
                    { "X-MBX-APIKEY", this.apiKey },
                };
            } else
            {
                throw new AuthenticationError ((string)add(this.id, " historicalTrades endpoint requires `apiKey` credential")) ;
            }
        }
        object userDataStream = isTrue((isEqual(path, "userDataStream"))) || isTrue((isEqual(path, "listenKey")));
        if (isTrue(userDataStream))
        {
            if (isTrue(this.apiKey))
            {
                // v1 special case for userDataStream
                headers = new Dictionary<string, object>() {
                    { "X-MBX-APIKEY", this.apiKey },
                    { "Content-Type", "application/x-www-form-urlencoded" },
                };
                if (isTrue(!isEqual(method, "GET")))
                {
                    body = this.urlencode(parameters);
                }
            } else
            {
                throw new AuthenticationError ((string)add(this.id, " userDataStream endpoint requires `apiKey` credential")) ;
            }
        } else if (isTrue(isTrue(isTrue(isTrue(isTrue(isTrue(isTrue(isTrue(isTrue(isTrue(isTrue((isEqual(api, "private"))) || isTrue((isEqual(api, "eapiPrivate")))) || isTrue((isTrue(isEqual(api, "sapi")) && isTrue(!isEqual(path, "system/status"))))) || isTrue((isEqual(api, "sapiV2")))) || isTrue((isEqual(api, "sapiV3")))) || isTrue((isEqual(api, "sapiV4")))) || isTrue((isTrue(isEqual(api, "wapi")) && isTrue(!isEqual(path, "systemStatus"))))) || isTrue((isEqual(api, "dapiPrivate")))) || isTrue((isEqual(api, "dapiPrivateV2")))) || isTrue((isEqual(api, "fapiPrivate")))) || isTrue((isEqual(api, "fapiPrivateV2")))))
        {
            this.checkRequiredCredentials();
            object query = null;
            object defaultRecvWindow = this.safeInteger(this.options, "recvWindow");
            object extendedParams = this.extend(new Dictionary<string, object>() {
                { "timestamp", this.nonce() },
            }, parameters);
            if (isTrue(!isEqual(defaultRecvWindow, null)))
            {
                ((Dictionary<string, object>)extendedParams)["recvWindow"] = defaultRecvWindow;
            }
            object recvWindow = this.safeInteger(parameters, "recvWindow");
            if (isTrue(!isEqual(recvWindow, null)))
            {
                ((Dictionary<string, object>)extendedParams)["recvWindow"] = recvWindow;
            }
            if (isTrue(isTrue((isEqual(api, "sapi"))) && isTrue((isEqual(path, "asset/dust")))))
            {
                query = this.urlencodeWithArrayRepeat(extendedParams);
            } else if (isTrue(isTrue(isTrue(isTrue((isEqual(path, "batchOrders"))) || isTrue((isGreaterThanOrEqual(getIndexOf(path, "sub-account"), 0)))) || isTrue((isEqual(path, "capital/withdraw/apply")))) || isTrue((isGreaterThanOrEqual(getIndexOf(path, "staking"), 0)))))
            {
                query = this.rawencode(extendedParams);
            } else
            {
                query = this.urlencode(extendedParams);
            }
            object signature = null;
            if (isTrue(isGreaterThan(getIndexOf(this.secret, "PRIVATE KEY"), -1)))
            {
                signature = this.encodeURIComponent(rsa(query, this.secret, sha256));
            } else
            {
                signature = this.hmac(this.encode(query), this.encode(this.secret), sha256);
            }
            query = add(query, add(add("&", "signature="), signature));
            headers = new Dictionary<string, object>() {
                { "X-MBX-APIKEY", this.apiKey },
            };
            if (isTrue(isTrue(isTrue((isEqual(method, "GET"))) || isTrue((isEqual(method, "DELETE")))) || isTrue((isEqual(api, "wapi")))))
            {
                url = add(url, add("?", query));
            } else
            {
                body = query;
                ((Dictionary<string, object>)headers)["Content-Type"] = "application/x-www-form-urlencoded";
            }
        } else
        {
            if (isTrue(getArrayLength(new List<object>(((Dictionary<string,object>)parameters).Keys))))
            {
                url = add(url, add("?", this.urlencode(parameters)));
            }
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isTrue((isEqual(code, 418))) || isTrue((isEqual(code, 429)))))
        {
            throw new DDoSProtection ((string)add(add(add(add(add(add(this.id, " "), ((object)code).ToString()), " "), reason), " "), body)) ;
        }
        // error response in a form: { "code": -1013, "msg": "Invalid quantity." }
        // following block cointains legacy checks against message patterns in "msg" property
        // will switch "code" checks eventually, when we know all of them
        if (isTrue(isGreaterThanOrEqual(code, 400)))
        {
            if (isTrue(isGreaterThanOrEqual(getIndexOf(body, "Price * QTY is zero or less"), 0)))
            {
                throw new InvalidOrder ((string)add(add(this.id, " order cost = amount * price is zero or less "), body)) ;
            }
            if (isTrue(isGreaterThanOrEqual(getIndexOf(body, "LOT_SIZE"), 0)))
            {
                throw new InvalidOrder ((string)add(add(this.id, " order amount should be evenly divisible by lot size "), body)) ;
            }
            if (isTrue(isGreaterThanOrEqual(getIndexOf(body, "PRICE_FILTER"), 0)))
            {
                throw new InvalidOrder ((string)add(add(this.id, " order price is invalid, i.e. exceeds allowed price precision, exceeds min price or max price limits or is invalid value in general, use this.priceToPrecision (symbol, amount) "), body)) ;
            }
        }
        if (isTrue(isEqual(response, null)))
        {
            return null;  // fallback to default error handler
        }
        // check success value for wapi endpoints
        // response in format {'msg': 'The coin does not exist.', 'success': true/false}
        object success = this.safeValue(response, "success", true);
        if (!isTrue(success))
        {
            object messageNew = this.safeString(response, "msg");
            object parsedMessage = null;
            if (isTrue(!isEqual(messageNew, null)))
            {
                try
                {
                    parsedMessage = parseJson(messageNew);
                } catch(Exception e)
                {
                    // do nothing
                    parsedMessage = null;
                }
                if (isTrue(!isEqual(parsedMessage, null)))
                {
                    response = parsedMessage;
                }
            }
        }
        object message = this.safeString(response, "msg");
        if (isTrue(!isEqual(message, null)))
        {
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), message, add(add(this.id, " "), message));
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), message, add(add(this.id, " "), message));
        }
        // checks against error codes
        object error = this.safeString(response, "code");
        if (isTrue(!isEqual(error, null)))
        {
            // https://github.com/ccxt/ccxt/issues/6501
            // https://github.com/ccxt/ccxt/issues/7742
            if (isTrue(isTrue((isEqual(error, "200"))) || isTrue(Precise.stringEquals(error, "0"))))
            {
                return null;
            }
            // a workaround for {"code":-2015,"msg":"Invalid API-key, IP, or permissions for action."}
            // despite that their message is very confusing, it is raised by Binance
            // on a temporary ban, the API key is valid, but disabled for a while
            if (isTrue(isTrue((isEqual(error, "-2015"))) && isTrue(getValue(this.options, "hasAlreadyAuthenticatedSuccessfully"))))
            {
                throw new DDoSProtection ((string)add(add(this.id, " "), body)) ;
            }
            object feedback = add(add(this.id, " "), body);
            if (isTrue(isEqual(message, "No need to change margin type.")))
            {
                throw new MarginModeAlreadySet ((string)feedback) ;
            }
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), error, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        if (!isTrue(success))
        {
            throw new ExchangeError ((string)add(add(this.id, " "), body)) ;
        }
        return null;
    }

    public override object calculateRateLimiterCost(object api, object method, object path, object parameters, object config = null, object context = null)
    {
        config ??= new Dictionary<string, object>();
        context ??= new Dictionary<string, object>();
        if (isTrue(isTrue((((Dictionary<string,object>)config).ContainsKey(toStringOrNull("noCoin")))) && !isTrue((((Dictionary<string,object>)parameters).ContainsKey(toStringOrNull("coin"))))))
        {
            return getValue(config, "noCoin");
        } else if (isTrue(isTrue((((Dictionary<string,object>)config).ContainsKey(toStringOrNull("noSymbol")))) && !isTrue((((Dictionary<string,object>)parameters).ContainsKey(toStringOrNull("symbol"))))))
        {
            return getValue(config, "noSymbol");
        } else if (isTrue(isTrue((((Dictionary<string,object>)config).ContainsKey(toStringOrNull("noPoolId")))) && !isTrue((((Dictionary<string,object>)parameters).ContainsKey(toStringOrNull("poolId"))))))
        {
            return getValue(config, "noPoolId");
        } else if (isTrue(isTrue((((Dictionary<string,object>)config).ContainsKey(toStringOrNull("byLimit")))) && isTrue((((Dictionary<string,object>)parameters).ContainsKey(toStringOrNull("limit"))))))
        {
            object limit = getValue(parameters, "limit");
            object byLimit = ((object)getValue(config, "byLimit"));
            for (object i = 0; isLessThan(i, getArrayLength(byLimit)); postFixIncrement(ref i))
            {
                object entry = getValue(byLimit, i);
                if (isTrue(isLessThanOrEqual(limit, getValue(entry, 0))))
                {
                    return getValue(entry, 1);
                }
            }
        }
        return this.safeValue(config, "cost", 1);
    }

    public async override Task<object> request(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null, object config = null, object context = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        config ??= new Dictionary<string, object>();
        context ??= new Dictionary<string, object>();
        object response = await this.fetch2(path, api, method, parameters, headers, body, config, context);
        // a workaround for {"code":-2015,"msg":"Invalid API-key, IP, or permissions for action."}
        if (isTrue(isTrue((isEqual(api, "private"))) || isTrue((isEqual(api, "wapi")))))
        {
            ((Dictionary<string, object>)this.options)["hasAlreadyAuthenticatedSuccessfully"] = true;
        }
        return response;
    }

    public async virtual Task<object> modifyMarginHelper(object symbol, object amount, object addOrReduce, object parameters = null)
    {
        // used to modify isolated positions
        parameters ??= new Dictionary<string, object>();
        object defaultType = this.safeString(this.options, "defaultType", "future");
        if (isTrue(isEqual(defaultType, "spot")))
        {
            defaultType = "future";
        }
        object type = this.safeString(parameters, "type", defaultType);
        if (isTrue(isTrue((isEqual(type, "margin"))) || isTrue((isEqual(type, "spot")))))
        {
            throw new NotSupported ((string)add(this.id, " add / reduce margin only supported with type future or delivery")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        amount = this.amountToPrecision(symbol, amount);
        object request = new Dictionary<string, object>() {
            { "type", addOrReduce },
            { "symbol", getValue(market, "id") },
            { "amount", amount },
        };
        object method = null;
        object code = null;
        if (isTrue(getValue(market, "linear")))
        {
            method = "fapiPrivatePostPositionMargin";
            code = getValue(market, "quote");
        } else
        {
            method = "dapiPrivatePostPositionMargin";
            code = getValue(market, "base");
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        //     {
        //         "code": 200,
        //         "msg": "Successfully modify position margin.",
        //         "amount": 0.001,
        //         "type": 1
        //     }
        //
        return this.extend(this.parseMarginModification(response, market), new Dictionary<string, object>() {
            { "code", code },
        });
    }

    public virtual object parseMarginModification(object data, object market = null)
    {
        object rawType = this.safeInteger(data, "type");
        object resultType = ((bool) isTrue((isEqual(rawType, 1)))) ? "add" : "reduce";
        object resultAmount = this.safeNumber(data, "amount");
        object errorCode = this.safeString(data, "code");
        object status = ((bool) isTrue((isEqual(errorCode, "200")))) ? "ok" : "failed";
        return new Dictionary<string, object>() {
            { "info", data },
            { "type", resultType },
            { "amount", resultAmount },
            { "code", null },
            { "symbol", getValue(market, "symbol") },
            { "status", status },
        };
    }

    public async virtual Task<object> reduceMargin(object symbol, object amount, object parameters = null)
    {
        /**
        * @method
        * @name binance#reduceMargin
        * @description remove margin from a position
        * @param {string} symbol unified market symbol
        * @param {float} amount the amount of margin to remove
        * @param {object} params extra parameters specific to the binance api endpoint
        * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=reduce-margin-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.modifyMarginHelper(symbol, amount, 2, parameters);
    }

    public async virtual Task<object> addMargin(object symbol, object amount, object parameters = null)
    {
        /**
        * @method
        * @name binance#addMargin
        * @description add margin
        * @param {string} symbol unified market symbol
        * @param {float} amount amount of margin to add
        * @param {object} params extra parameters specific to the binance api endpoint
        * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=add-margin-structure}
        */
        parameters ??= new Dictionary<string, object>();
        return await this.modifyMarginHelper(symbol, amount, 1, parameters);
    }

    public async override Task<object> fetchBorrowRate(object code, object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchBorrowRate
        * @description fetch the rate of interest to borrow a currency for margin trading
        * @param {string} code unified currency code
        * @param {object} params extra parameters specific to the binance api endpoint
        * @returns {object} a [borrow rate structure]{@link https://docs.ccxt.com/#/?id=borrow-rate-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "asset", getValue(currency, "id") },
        };
        object response = await this.sapiGetMarginInterestRateHistory(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "asset": "USDT",
        //             "timestamp": 1638230400000,
        //             "dailyInterestRate": "0.0006",
        //             "vipLevel": 0
        //         },
        //     ]
        //
        object rate = this.safeValue(response, 0);
        return this.parseBorrowRate(rate);
    }

    public async virtual Task<object> fetchBorrowRateHistory(object code, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchBorrowRateHistory
        * @description retrieves a history of a currencies borrow interest rate at specific time slots
        * @param {string} code unified currency code
        * @param {int|undefined} since timestamp for the earliest borrow rate
        * @param {int|undefined} limit the maximum number of [borrow rate structures]{@link https://docs.ccxt.com/#/?id=borrow-rate-structure} to retrieve
        * @param {object} params extra parameters specific to the exchange api endpoint
        * @returns {[object]} an array of [borrow rate structures]{@link https://docs.ccxt.com/#/?id=borrow-rate-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (isTrue(isEqual(limit, null)))
        {
            limit = 93;
        } else if (isTrue(isGreaterThan(limit, 93)))
        {
            throw new BadRequest ((string)add(this.id, " fetchBorrowRateHistory() limit parameter cannot exceed 92")) ;
        }
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "asset", getValue(currency, "id") },
            { "limit", limit },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["startTime"] = since;
            object endTime = subtract(this.sum(since, multiply(limit, 86400000)), 1); // required when startTime is further than 93 days in the past
            object now = this.milliseconds();
            ((Dictionary<string, object>)request)["endTime"] = mathMin(endTime, now); // cannot have an endTime later than current time
        }
        object response = await this.sapiGetMarginInterestRateHistory(this.extend(request, parameters));
        //
        //     [
        //         {
        //             "asset": "USDT",
        //             "timestamp": 1638230400000,
        //             "dailyInterestRate": "0.0006",
        //             "vipLevel": 0
        //         },
        //     ]
        //
        return this.parseBorrowRateHistory(response, code, since, limit);
    }

    public virtual object parseBorrowRateHistory(object response, object code, object since, object limit)
    {
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object item = getValue(response, i);
            object borrowRate = this.parseBorrowRate(item);
            ((List<object>)result).Add(borrowRate);
        }
        object sorted = this.sortBy(result, "timestamp");
        return this.filterByCurrencySinceLimit(sorted, code, since, limit);
    }

    public virtual object parseBorrowRate(object info, object currency = null)
    {
        //
        //    {
        //        "asset": "USDT",
        //        "timestamp": 1638230400000,
        //        "dailyInterestRate": "0.0006",
        //        "vipLevel": 0
        //    }
        //
        object timestamp = this.safeNumber(info, "timestamp");
        currency = this.safeString(info, "asset");
        return new Dictionary<string, object>() {
            { "currency", this.safeCurrencyCode(currency) },
            { "rate", this.safeNumber(info, "dailyInterestRate") },
            { "period", 86400000 },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", info },
        };
    }

    public async virtual Task<object> createGiftCode(object code, object amount, object parameters = null)
    {
        /**
        * @method
        * @name binance#createGiftCode
        * @description create gift code
        * @param {string} code gift code
        * @param {float} amount amount of currency for the gift
        * @param {object} params extra parameters specific to the binance api endpoint
        * @returns {object} The gift code id, code, currency and amount
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        // ensure you have enough token in your funding account before calling this code
        object request = new Dictionary<string, object>() {
            { "token", getValue(currency, "id") },
            { "amount", amount },
        };
        object response = await this.sapiPostGiftcardCreateCode(this.extend(request, parameters));
        //
        //     {
        //         code: '000000',
        //         message: 'success',
        //         data: { referenceNo: '0033002404219823', code: 'AP6EXTLKNHM6CEX7' },
        //         success: true
        //     }
        //
        object data = this.safeValue(response, "data");
        object giftcardCode = this.safeString(data, "code");
        object id = this.safeString(data, "referenceNo");
        return new Dictionary<string, object>() {
            { "info", response },
            { "id", id },
            { "code", giftcardCode },
            { "currency", code },
            { "amount", amount },
        };
    }

    public async virtual Task<object> redeemGiftCode(object giftcardCode, object parameters = null)
    {
        /**
        * @method
        * @name binance#redeemGiftCode
        * @description redeem gift code
        * @param {string} giftcardCode
        * @param {object} params extra parameters specific to the binance api endpoint
        * @returns {object} response from the exchange
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "code", giftcardCode },
        };
        object response = await this.sapiPostGiftcardRedeemCode(this.extend(request, parameters));
        //
        //     {
        //         code: '000000',
        //         message: 'success',
        //         data: {
        //             referenceNo: '0033002404219823',
        //             identityNo: '10316431732801474560'
        //         },
        //         success: true
        //     }
        //
        return response;
    }

    public async virtual Task<object> verifyGiftCode(object id, object parameters = null)
    {
        /**
        * @method
        * @name binance#verifyGiftCode
        * @description verify gift code
        * @param {string} id reference number id
        * @param {object} params extra parameters specific to the binance api endpoint
        * @returns {object} response from the exchange
        */
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {
            { "referenceNo", id },
        };
        object response = await this.sapiGetGiftcardVerify(this.extend(request, parameters));
        //
        //     {
        //         code: '000000',
        //         message: 'success',
        //         data: { valid: true },
        //         success: true
        //     }
        //
        return response;
    }

    public async override Task<object> fetchBorrowInterest(object code = null, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchBorrowInterest
        * @description fetch the interest owed by the user for borrowing currency for margin trading
        * @param {string|undefined} code unified currency code
        * @param {string|undefined} symbol unified market symbol when fetch interest in isolated markets
        * @param {int|undefined} since the earliest time in ms to fetch borrrow interest for
        * @param {int|undefined} limit the maximum number of structures to retrieve
        * @param {object} params extra parameters specific to the binance api endpoint
        * @returns {[object]} a list of [borrow interest structures]{@link https://docs.ccxt.com/#/?id=borrow-interest-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(code, null)))
        {
            object currency = this.currency(code);
            ((Dictionary<string, object>)request)["asset"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["size"] = limit;
        }
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((Dictionary<string, object>)request)["isolatedSymbol"] = getValue(market, "id");
        }
        object response = await this.sapiGetMarginInterestHistory(this.extend(request, parameters));
        //
        //     {
        //         "rows":[
        //             {
        //                 "isolatedSymbol": "BNBUSDT", // isolated symbol, will not be returned for crossed margin
        //                 "asset": "BNB",
        //                 "interest": "0.02414667",
        //                 "interestAccuredTime": 1566813600000,
        //                 "interestRate": "0.01600000",
        //                 "principal": "36.22000000",
        //                 "type": "ON_BORROW"
        //             }
        //         ],
        //         "total": 1
        //     }
        //
        object rows = this.safeValue(response, "rows");
        object interest = this.parseBorrowInterests(rows, market);
        return this.filterByCurrencySinceLimit(interest, code, since, limit);
    }

    public override object parseBorrowInterest(object info, object market = null)
    {
        object symbol = this.safeString(info, "isolatedSymbol");
        object timestamp = this.safeNumber(info, "interestAccuredTime");
        object marginMode = ((bool) isTrue((isEqual(symbol, null)))) ? "cross" : "isolated";
        return new Dictionary<string, object>() {
            { "account", ((bool) isTrue((isEqual(symbol, null)))) ? "cross" : symbol },
            { "symbol", symbol },
            { "marginMode", marginMode },
            { "currency", this.safeCurrencyCode(this.safeString(info, "asset")) },
            { "interest", this.safeNumber(info, "interest") },
            { "interestRate", this.safeNumber(info, "interestRate") },
            { "amountBorrowed", this.safeNumber(info, "principal") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", info },
        };
    }

    public async virtual Task<object> repayMargin(object code, object amount, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#repayMargin
        * @description repay borrowed margin and interest
        * @see https://binance-docs.github.io/apidocs/spot/en/#margin-account-repay-margin
        * @param {string} code unified currency code of the currency to repay
        * @param {float} amount the amount to repay
        * @param {string|undefined} symbol unified market symbol, required for isolated margin
        * @param {object} params extra parameters specific to the binance api endpoint
        * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
        */
        parameters ??= new Dictionary<string, object>();
        var marginModequeryVariable = this.handleMarginModeAndParams("repayMargin", parameters);
        var marginMode = ((List<object>) marginModequeryVariable)[0];
        var query = ((List<object>) marginModequeryVariable)[1]; // cross or isolated
        this.checkRequiredMarginArgument("repayMargin", symbol, marginMode);
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "asset", getValue(currency, "id") },
            { "amount", this.currencyToPrecision(code, amount) },
        };
        if (isTrue(!isEqual(symbol, null)))
        {
            object market = this.market(symbol);
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
            ((Dictionary<string, object>)request)["isIsolated"] = "TRUE";
        }
        object response = await this.sapiPostMarginRepay(this.extend(request, query));
        //
        //     {
        //         "tranId": 108988250265,
        //         "clientTag":""
        //     }
        //
        return this.parseMarginLoan(response, currency);
    }

    public async virtual Task<object> borrowMargin(object code, object amount, object symbol = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#borrowMargin
        * @description create a loan to borrow margin
        * @see https://binance-docs.github.io/apidocs/spot/en/#margin-account-borrow-margin
        * @param {string} code unified currency code of the currency to borrow
        * @param {float} amount the amount to borrow
        * @param {string|undefined} symbol unified market symbol, required for isolated margin
        * @param {object} params extra parameters specific to the binance api endpoint
        * @returns {object} a [margin loan structure]{@link https://docs.ccxt.com/#/?id=margin-loan-structure}
        */
        parameters ??= new Dictionary<string, object>();
        var marginModequeryVariable = this.handleMarginModeAndParams("borrowMargin", parameters);
        var marginMode = ((List<object>) marginModequeryVariable)[0];
        var query = ((List<object>) marginModequeryVariable)[1]; // cross or isolated
        this.checkRequiredMarginArgument("borrowMargin", symbol, marginMode);
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "asset", getValue(currency, "id") },
            { "amount", this.currencyToPrecision(code, amount) },
        };
        if (isTrue(!isEqual(symbol, null)))
        {
            object market = this.market(symbol);
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
            ((Dictionary<string, object>)request)["isIsolated"] = "TRUE";
        }
        object response = await this.sapiPostMarginLoan(this.extend(request, query));
        //
        //     {
        //         "tranId": 108988250265,
        //         "clientTag":""
        //     }
        //
        return this.parseMarginLoan(response, currency);
    }

    public virtual object parseMarginLoan(object info, object currency = null)
    {
        //
        //     {
        //         "tranId": 108988250265,
        //         "clientTag":""
        //     }
        //
        return new Dictionary<string, object>() {
            { "id", this.safeInteger(info, "tranId") },
            { "currency", this.safeCurrencyCode(null, currency) },
            { "amount", null },
            { "symbol", null },
            { "timestamp", null },
            { "datetime", null },
            { "info", info },
        };
    }

    public async override Task<object> fetchOpenInterestHistory(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchOpenInterestHistory
        * @description Retrieves the open interest history of a currency
        * @param {string} symbol Unified CCXT market symbol
        * @param {string} timeframe "5m","15m","30m","1h","2h","4h","6h","12h", or "1d"
        * @param {int|undefined} since the time(ms) of the earliest record to retrieve as a unix timestamp
        * @param {int|undefined} limit default 30, max 500
        * @param {object} params exchange specific parameters
        * @param {int|undefined} params.until the time(ms) of the latest record to retrieve as a unix timestamp
        * @returns {object} an array of [open interest history structure]{@link https://docs.ccxt.com/#/?id=interest-history-structure}
        */
        timeframe ??= "5m";
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(timeframe, "1m")))
        {
            throw new BadRequest ((string)add(this.id, "fetchOpenInterestHistory cannot use the 1m timeframe")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "period", this.safeString(this.timeframes, timeframe, timeframe) },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((Dictionary<string, object>)request)["limit"] = limit;
        }
        object symbolKey = ((bool) isTrue(getValue(market, "linear"))) ? "symbol" : "pair";
        ((Dictionary<string, object>)request)[(string)symbolKey] = getValue(market, "id");
        if (isTrue(getValue(market, "inverse")))
        {
            ((Dictionary<string, object>)request)["contractType"] = this.safeString(parameters, "contractType", "CURRENT_QUARTER");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((Dictionary<string, object>)request)["startTime"] = since;
        }
        object until = this.safeInteger2(parameters, "until", "till"); // unified in milliseconds
        object endTime = this.safeInteger(parameters, "endTime", until); // exchange-specific in milliseconds
        parameters = this.omit(parameters, new List<object>() {"endTime", "until", "till"});
        if (isTrue(endTime))
        {
            ((Dictionary<string, object>)request)["endTime"] = endTime;
        } else if (isTrue(since))
        {
            if (isTrue(isEqual(limit, null)))
            {
                limit = 30; // Exchange default
            }
            object duration = this.parseTimeframe(timeframe);
            ((Dictionary<string, object>)request)["endTime"] = this.sum(since, multiply(multiply(duration, limit), 1000));
        }
        object method = "fapiDataGetOpenInterestHist";
        if (isTrue(getValue(market, "inverse")))
        {
            method = "dapiDataGetOpenInterestHist";
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        //  [
        //      {
        //          "symbol":"BTCUSDT",
        //          "sumOpenInterest":"75375.61700000",
        //          "sumOpenInterestValue":"3248828883.71251440",
        //          "timestamp":1642179900000
        //      },
        //      ...
        //  ]
        //
        return this.parseOpenInterests(response, market, since, limit);
    }

    public async override Task<object> fetchOpenInterest(object symbol, object parameters = null)
    {
        /**
        * @method
        * @name binance#fetchOpenInterest
        * @description retrieves the open interest of a contract trading pair
        * @see https://binance-docs.github.io/apidocs/futures/en/#open-interest
        * @see https://binance-docs.github.io/apidocs/delivery/en/#open-interest
        * @see https://binance-docs.github.io/apidocs/voptions/en/#open-interest
        * @param {string} symbol unified CCXT market symbol
        * @param {object} params exchange specific parameters
        * @returns {object} an open interest structure{@link https://docs.ccxt.com/#/?id=interest-history-structure}
        */
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {};
        if (isTrue(getValue(market, "option")))
        {
            ((Dictionary<string, object>)request)["underlyingAsset"] = getValue(market, "baseId");
            ((Dictionary<string, object>)request)["expiration"] = this.yymmdd(getValue(market, "expiry"));
        } else
        {
            ((Dictionary<string, object>)request)["symbol"] = getValue(market, "id");
        }
        object method = "fapiPublicGetOpenInterest";
        if (isTrue(getValue(market, "option")))
        {
            method = "eapiPublicGetOpenInterest";
        } else if (isTrue(getValue(market, "inverse")))
        {
            method = "dapiPublicGetOpenInterest";
        }
        object response = await ((Task<object>)callDynamically(this, method, new object[] { this.extend(request, parameters) }));
        //
        // futures (fapi)
        //
        //     {
        //         "symbol": "ETHUSDT_230331",
        //         "openInterest": "23581.677",
        //         "time": 1677356872265
        //     }
        //
        // futures (dapi)
        //
        //     {
        //         "symbol": "ETHUSD_PERP",
        //         "pair": "ETHUSD",
        //         "openInterest": "26542436",
        //         "contractType": "PERPETUAL",
        //         "time": 1677360272224
        //     }
        //
        // options (eapi)
        //
        //     [
        //         {
        //             "symbol": "ETH-230225-1625-C",
        //             "sumOpenInterest": "460.50",
        //             "sumOpenInterestUsd": "734957.4358092150",
        //             "timestamp": "1677304860000"
        //         }
        //     ]
        //
        if (isTrue(getValue(market, "option")))
        {
            return this.parseOpenInterests(response, market);
        } else
        {
            return this.parseOpenInterest(response, market);
        }
    }

    public override object parseOpenInterest(object interest, object market = null)
    {
        object timestamp = this.safeInteger2(interest, "timestamp", "time");
        object id = this.safeString(interest, "symbol");
        object amount = this.safeNumber2(interest, "sumOpenInterest", "openInterest");
        object value = this.safeNumber2(interest, "sumOpenInterestValue", "sumOpenInterestUsd");
        // Inverse returns the number of contracts different from the base or quote volume in this case
        // compared with https://www.binance.com/en/futures/funding-history/quarterly/4
        return new Dictionary<string, object>() {
            { "symbol", this.safeSymbol(id, market, null, "contract") },
            { "baseVolume", ((bool) isTrue(getValue(market, "inverse"))) ? null : amount },
            { "quoteVolume", value },
            { "openInterestAmount", amount },
            { "openInterestValue", value },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", interest },
        };
    }
}
