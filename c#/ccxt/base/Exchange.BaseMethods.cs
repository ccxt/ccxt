using ccxt;
namespace ccxt;
// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class Exchange
{


    public virtual void handleDeltas(object orderbook, object deltas)
    {
        for (object i = 0; isLessThan(i, getArrayLength(deltas)); postFixIncrement(ref i))
        {
            this.handleDelta(orderbook, getValue(deltas, i));
        }
    }

    public virtual void handleDelta(object bookside, object delta)
    {
        throw new NotSupported ((string)add(this.id, " handleDelta not supported yet")) ;
    }

    public virtual object getCacheIndex(object orderbook, object deltas)
    {
        // return the first index of the cache that can be applied to the orderbook or -1 if not possible
        return -1;
    }

    public virtual object findTimeframe(object timeframe, object timeframes = null)
    {
        if (isTrue(isEqual(timeframes, null)))
        {
            timeframes = this.timeframes;
        }
        object keys = new List<object>(((Dictionary<string,object>)timeframes).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object key = getValue(keys, i);
            if (isTrue(isEqual(getValue(timeframes, key), timeframe)))
            {
                return key;
            }
        }
        return null;
    }

    public virtual object checkProxySettings(object url, object method, object headers, object body)
    {
        object proxyUrl = ((bool) isTrue((!isEqual(this.proxyUrl, null)))) ? this.proxyUrl : this.proxy_url;
        object proxyUrlCallback = ((bool) isTrue((!isEqual(this.proxyUrlCallback, null)))) ? this.proxyUrlCallback : this.proxy_url_callback;
        if (isTrue(!isEqual(proxyUrlCallback, null)))
        {
            proxyUrl = callDynamically(this, "proxyUrlCallback", new object[] { url, method, headers, body });
        }
        // backwards-compatibility
        if (isTrue(!isEqual(this.proxy, null)))
        {
            if (isTrue(((this.proxy).GetType() == typeof(Delegate))))
            {
                proxyUrl = callDynamically(this, "proxy", new object[] { url, method, headers, body });
            } else
            {
                proxyUrl = this.proxy;
            }
        }
        object httpProxy = ((bool) isTrue((!isEqual(this.httpProxy, null)))) ? this.httpProxy : this.http_proxy;
        object httpProxyCallback = ((bool) isTrue((!isEqual(this.httpProxyCallback, null)))) ? this.httpProxyCallback : this.http_proxy_callback;
        if (isTrue(!isEqual(httpProxyCallback, null)))
        {
            httpProxy = callDynamically(this, "httpProxyCallback", new object[] { url, method, headers, body });
        }
        object httpsProxy = ((bool) isTrue((!isEqual(this.httpsProxy, null)))) ? this.httpsProxy : this.https_proxy;
        object httpsProxyCallback = ((bool) isTrue((!isEqual(this.httpsProxyCallback, null)))) ? this.httpsProxyCallback : this.https_proxy_callback;
        if (isTrue(!isEqual(this.httpsProxyCallback, null)))
        {
            httpsProxy = callDynamically(this, "httpsProxyCallback", new object[] { url, method, headers, body });
        }
        object socksProxy = ((bool) isTrue((!isEqual(this.socksProxy, null)))) ? this.socksProxy : this.socks_proxy;
        object socksProxyCallback = ((bool) isTrue((!isEqual(this.socksProxyCallback, null)))) ? this.socksProxyCallback : this.socks_proxy_callback;
        if (isTrue(!isEqual(socksProxyCallback, null)))
        {
            socksProxy = callDynamically(this, "socksProxyCallback", new object[] { url, method, headers, body });
        }
        object val = 0;
        if (isTrue(!isEqual(proxyUrl, null)))
        {
            val = add(val, 1);
        }
        if (isTrue(!isEqual(proxyUrlCallback, null)))
        {
            val = add(val, 1);
        }
        if (isTrue(!isEqual(httpProxy, null)))
        {
            val = add(val, 1);
        }
        if (isTrue(!isEqual(httpProxyCallback, null)))
        {
            val = add(val, 1);
        }
        if (isTrue(!isEqual(httpsProxy, null)))
        {
            val = add(val, 1);
        }
        if (isTrue(!isEqual(httpsProxyCallback, null)))
        {
            val = add(val, 1);
        }
        if (isTrue(!isEqual(socksProxy, null)))
        {
            val = add(val, 1);
        }
        if (isTrue(!isEqual(socksProxyCallback, null)))
        {
            val = add(val, 1);
        }
        if (isTrue(isGreaterThan(val, 1)))
        {
            throw new ExchangeError ((string)add(this.id, " you have multiple conflicting proxy settings, please use only one from : proxyUrl, httpProxy, httpsProxy, socksProxy, userAgent")) ;
        }
        return new List<object>() {proxyUrl, httpProxy, httpsProxy, socksProxy};
    }

    public virtual object findMessageHashes(object futures, object element)
    {
        object result = new List<object>() {};
        object messageHashes = new List<object>(((Dictionary<string,object>)futures).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(messageHashes)); postFixIncrement(ref i))
        {
            object messageHash = getValue(messageHashes, i);
            if (isTrue(isGreaterThanOrEqual(getIndexOf(messageHash, element), 0)))
            {
                ((List<object>)result).Add(messageHash);
            }
        }
        return result;
    }

    public virtual object filterByLimit(object array, object limit = null, object key = null)
    {
        key ??= "timestamp";
        if (isTrue(this.valueIsDefined(limit)))
        {
            object arrayLength = getArrayLength(array);
            if (isTrue(isGreaterThan(arrayLength, 0)))
            {
                object ascending = true;
                if (isTrue((inOp(getValue(array, 0), key))))
                {
                    object first = getValue(getValue(array, 0), key);
                    object last = getValue(getValue(array, subtract(arrayLength, 1)), key);
                    if (isTrue(isTrue(!isEqual(first, null)) && isTrue(!isEqual(last, null))))
                    {
                        ascending = isLessThanOrEqual(first, last); // true if array is sorted in ascending order based on 'timestamp'
                    }
                }
                array = ((bool) isTrue(ascending)) ? this.arraySlice(array, prefixUnaryNeg(ref limit)) : this.arraySlice(array, 0, limit);
            }
        }
        return array;
    }

    public virtual object filterBySinceLimit(object array, object since = null, object limit = null, object key = null, object tail = null)
    {
        key ??= "timestamp";
        tail ??= false;
        object sinceIsDefined = this.valueIsDefined(since);
        object parsedArray = ((object)this.toArray(array));
        object result = parsedArray;
        if (isTrue(sinceIsDefined))
        {
            result = new List<object>() {};
            for (object i = 0; isLessThan(i, getArrayLength(parsedArray)); postFixIncrement(ref i))
            {
                object entry = getValue(parsedArray, i);
                object value = this.safeValue(entry, key);
                if (isTrue(isTrue(value) && isTrue((isGreaterThanOrEqual(value, since)))))
                {
                    ((List<object>)result).Add(entry);
                }
            }
        }
        if (isTrue(isTrue(tail) && isTrue(!isEqual(limit, null))))
        {
            return this.arraySlice(result, prefixUnaryNeg(ref limit));
        }
        return this.filterByLimit(result, limit, key);
    }

    public virtual object filterByValueSinceLimit(object array, object field, object value = null, object since = null, object limit = null, object key = null, object tail = null)
    {
        key ??= "timestamp";
        tail ??= false;
        object valueIsDefined = this.valueIsDefined(value);
        object sinceIsDefined = this.valueIsDefined(since);
        object parsedArray = ((object)this.toArray(array));
        object result = parsedArray;
        // single-pass filter for both symbol and since
        if (isTrue(isTrue(valueIsDefined) || isTrue(sinceIsDefined)))
        {
            result = new List<object>() {};
            for (object i = 0; isLessThan(i, getArrayLength(parsedArray)); postFixIncrement(ref i))
            {
                object entry = getValue(parsedArray, i);
                object entryFiledEqualValue = isEqual(getValue(entry, field), value);
                object firstCondition = ((bool) isTrue(valueIsDefined)) ? entryFiledEqualValue : true;
                object entryKeyValue = this.safeValue(entry, key);
                object entryKeyGESince = isTrue(isTrue((entryKeyValue)) && isTrue(since)) && isTrue((isGreaterThanOrEqual(entryKeyValue, since)));
                object secondCondition = ((bool) isTrue(sinceIsDefined)) ? entryKeyGESince : true;
                if (isTrue(isTrue(firstCondition) && isTrue(secondCondition)))
                {
                    ((List<object>)result).Add(entry);
                }
            }
        }
        if (isTrue(isTrue(tail) && isTrue(!isEqual(limit, null))))
        {
            return this.arraySlice(result, prefixUnaryNeg(ref limit));
        }
        return this.filterByLimit(result, limit, key);
    }

    public virtual void setSandboxMode(object enabled)
    {
        if (isTrue(enabled))
        {
            if (isTrue(inOp(this.urls, "test")))
            {
                if (isTrue(((getValue(this.urls, "api")).GetType() == typeof(string))))
                {
                    ((Dictionary<string, object>)this.urls)["apiBackup"] = getValue(this.urls, "api");
                    ((Dictionary<string, object>)this.urls)["api"] = getValue(this.urls, "test");
                } else
                {
                    ((Dictionary<string, object>)this.urls)["apiBackup"] = this.clone(getValue(this.urls, "api"));
                    ((Dictionary<string, object>)this.urls)["api"] = this.clone(getValue(this.urls, "test"));
                }
            } else
            {
                throw new NotSupported ((string)add(this.id, " does not have a sandbox URL")) ;
            }
        } else if (isTrue(inOp(this.urls, "apiBackup")))
        {
            if (isTrue(((getValue(this.urls, "api")).GetType() == typeof(string))))
            {
                ((Dictionary<string, object>)this.urls)["api"] = ((object)getValue(this.urls, "apiBackup"));
            } else
            {
                ((Dictionary<string, object>)this.urls)["api"] = this.clone(getValue(this.urls, "apiBackup"));
            }
            object newUrls = this.omit(this.urls, "apiBackup");
            this.urls = newUrls;
        }
    }

    public virtual object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        return new Dictionary<string, object>() {};
    }

    public async virtual Task<object> fetchAccounts(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchAccounts() is not supported yet")) ;
    }

    public async virtual Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchTrades() is not supported yet")) ;
    }

    public async virtual Task<object> fetchTradesWs(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchTradesWs() is not supported yet")) ;
    }

    public async virtual Task<object> watchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " watchTrades() is not supported yet")) ;
    }

    public async virtual Task<object> fetchDepositAddresses(object codes = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchDepositAddresses() is not supported yet")) ;
    }

    public async virtual Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchOrderBook() is not supported yet")) ;
    }

    public async virtual Task<object> fetchRestOrderBookSafe(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object fetchSnapshotMaxRetries = this.handleOption("watchOrderBook", "maxRetries", 3);
        for (object i = 0; isLessThan(i, fetchSnapshotMaxRetries); postFixIncrement(ref i))
        {
            try
            {
                object orderBook = await this.fetchOrderBook(symbol, limit, parameters);
                return orderBook;
            } catch(Exception e)
            {
                if (isTrue(isEqual((add(i, 1)), fetchSnapshotMaxRetries)))
                {
                    throw e;
                }
            }
        }
        return null;
    }

    public async virtual Task<object> watchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " watchOrderBook() is not supported yet")) ;
    }

    public async virtual Task<object> fetchTime(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchTime() is not supported yet")) ;
    }

    public async virtual Task<object> fetchTradingLimits(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchTradingLimits() is not supported yet")) ;
    }

    public virtual object parseTicker(object ticker, object market = null)
    {
        throw new NotSupported ((string)add(this.id, " parseTicker() is not supported yet")) ;
    }

    public virtual object parseDepositAddress(object depositAddress, object currency = null)
    {
        throw new NotSupported ((string)add(this.id, " parseDepositAddress() is not supported yet")) ;
    }

    public virtual object parseTrade(object trade, object market = null)
    {
        throw new NotSupported ((string)add(this.id, " parseTrade() is not supported yet")) ;
    }

    public virtual object parseTransaction(object transaction, object currency = null)
    {
        throw new NotSupported ((string)add(this.id, " parseTransaction() is not supported yet")) ;
    }

    public virtual object parseTransfer(object transfer, object currency = null)
    {
        throw new NotSupported ((string)add(this.id, " parseTransfer() is not supported yet")) ;
    }

    public virtual object parseAccount(object account)
    {
        throw new NotSupported ((string)add(this.id, " parseAccount() is not supported yet")) ;
    }

    public virtual object parseLedgerEntry(object item, object currency = null)
    {
        throw new NotSupported ((string)add(this.id, " parseLedgerEntry() is not supported yet")) ;
    }

    public virtual object parseOrder(object order, object market = null)
    {
        throw new NotSupported ((string)add(this.id, " parseOrder() is not supported yet")) ;
    }

    public async virtual Task<object> fetchBorrowRates(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchBorrowRates() is not supported yet")) ;
    }

    public virtual object parseMarketLeverageTiers(object info, object market = null)
    {
        throw new NotSupported ((string)add(this.id, " parseMarketLeverageTiers() is not supported yet")) ;
    }

    public async virtual Task<object> fetchLeverageTiers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchLeverageTiers() is not supported yet")) ;
    }

    public virtual object parsePosition(object position, object market = null)
    {
        throw new NotSupported ((string)add(this.id, " parsePosition() is not supported yet")) ;
    }

    public virtual object parseFundingRateHistory(object info, object market = null)
    {
        throw new NotSupported ((string)add(this.id, " parseFundingRateHistory() is not supported yet")) ;
    }

    public virtual object parseBorrowInterest(object info, object market = null)
    {
        throw new NotSupported ((string)add(this.id, " parseBorrowInterest() is not supported yet")) ;
    }

    public virtual object parseWsTrade(object trade, object market = null)
    {
        throw new NotSupported ((string)add(this.id, " parseWsTrade() is not supported yet")) ;
    }

    public virtual object parseWsOrder(object order, object market = null)
    {
        throw new NotSupported ((string)add(this.id, " parseWsOrder() is not supported yet")) ;
    }

    public virtual object parseWsOrderTrade(object trade, object market = null)
    {
        throw new NotSupported ((string)add(this.id, " parseWsOrderTrade() is not supported yet")) ;
    }

    public virtual object parseWsOHLCV(object ohlcv, object market = null)
    {
        return this.parseOHLCV(ohlcv, market);
    }

    public async virtual Task<object> fetchFundingRates(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchFundingRates() is not supported yet")) ;
    }

    public async virtual Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " transfer() is not supported yet")) ;
    }

    public async virtual Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " withdraw() is not supported yet")) ;
    }

    public async virtual Task<object> createDepositAddress(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " createDepositAddress() is not supported yet")) ;
    }

    public async virtual Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " setLeverage() is not supported yet")) ;
    }

    public async virtual Task<object> fetchOpenInterestHistory(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1h";
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchOpenInterestHistory() is not supported yet")) ;
    }

    public async virtual Task<object> fetchOpenInterest(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchOpenInterest() is not supported yet")) ;
    }

    public async virtual Task<object> signIn(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " signIn() is not supported yet")) ;
    }

    public virtual object parseToInt(object number)
    {
        // Solve Common parseInt misuse ex: parseInt ((since / 1000).toString ())
        // using a number as parameter which is not valid in ts
        object stringifiedNumber = ((object)number).ToString();
        object convertedNumber = ((object)parseFloat(stringifiedNumber));
        return parseInt(convertedNumber);
    }

    public virtual void afterConstruct()
    {
        this.createNetworksByIdObject();
    }

    public virtual void createNetworksByIdObject()
    {
        // automatically generate network-id-to-code mappings
        object networkIdsToCodesGenerated = this.invertFlatStringDictionary(this.safeValue(this.options, "networks", new Dictionary<string, object>() {})); // invert defined networks dictionary
        ((Dictionary<string, object>)this.options)["networksById"] = this.extend(networkIdsToCodesGenerated, this.safeValue(this.options, "networksById", new Dictionary<string, object>() {})); // support manually overriden "networksById" dictionary too
    }

    public virtual object getDefaultOptions()
    {
        return new Dictionary<string, object>() {
            { "defaultNetworkCodeReplacements", new Dictionary<string, object>() {
                { "ETH", new Dictionary<string, object>() {
                    { "ERC20", "ETH" },
                } },
                { "TRX", new Dictionary<string, object>() {
                    { "TRC20", "TRX" },
                } },
                { "CRO", new Dictionary<string, object>() {
                    { "CRC20", "CRONOS" },
                } },
            } },
        };
    }

    public virtual object safeLedgerEntry(object entry, object currency = null)
    {
        currency = this.safeCurrency(null, currency);
        object direction = this.safeString(entry, "direction");
        object before = this.safeString(entry, "before");
        object after = this.safeString(entry, "after");
        object amount = this.safeString(entry, "amount");
        if (isTrue(!isEqual(amount, null)))
        {
            if (isTrue(isTrue(isEqual(before, null)) && isTrue(!isEqual(after, null))))
            {
                before = Precise.stringSub(after, amount);
            } else if (isTrue(isTrue(!isEqual(before, null)) && isTrue(isEqual(after, null))))
            {
                after = Precise.stringAdd(before, amount);
            }
        }
        if (isTrue(isTrue(!isEqual(before, null)) && isTrue(!isEqual(after, null))))
        {
            if (isTrue(isEqual(direction, null)))
            {
                if (isTrue(Precise.stringGt(before, after)))
                {
                    direction = "out";
                }
                if (isTrue(Precise.stringGt(after, before)))
                {
                    direction = "in";
                }
            }
        }
        object fee = this.safeValue(entry, "fee");
        if (isTrue(!isEqual(fee, null)))
        {
            ((Dictionary<string, object>)fee)["cost"] = this.safeNumber(fee, "cost");
        }
        object timestamp = this.safeInteger(entry, "timestamp");
        return new Dictionary<string, object>() {
            { "id", this.safeString(entry, "id") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "direction", direction },
            { "account", this.safeString(entry, "account") },
            { "referenceId", this.safeString(entry, "referenceId") },
            { "referenceAccount", this.safeString(entry, "referenceAccount") },
            { "type", this.safeString(entry, "type") },
            { "currency", getValue(currency, "code") },
            { "amount", this.parseNumber(amount) },
            { "before", this.parseNumber(before) },
            { "after", this.parseNumber(after) },
            { "status", this.safeString(entry, "status") },
            { "fee", fee },
            { "info", entry },
        };
    }

    public virtual object safeCurrencyStructure(object currency)
    {
        return this.extend(new Dictionary<string, object>() {
            { "info", null },
            { "id", null },
            { "numericId", null },
            { "code", null },
            { "precision", null },
            { "type", null },
            { "name", null },
            { "active", null },
            { "deposit", null },
            { "withdraw", null },
            { "fee", null },
            { "fees", new Dictionary<string, object>() {} },
            { "networks", new Dictionary<string, object>() {} },
            { "limits", new Dictionary<string, object>() {
                { "deposit", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "withdraw", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
            } },
        }, currency);
    }

    public virtual object setMarkets(object markets, object currencies = null)
    {
        object values = new List<object>() {};
        this.markets_by_id = new Dictionary<string, object>() {};
        // handle marketId conflicts
        // we insert spot markets first
        object marketValues = this.sortBy(this.toArray(markets), "spot", true);
        for (object i = 0; isLessThan(i, getArrayLength(marketValues)); postFixIncrement(ref i))
        {
            object value = getValue(marketValues, i);
            if (isTrue(inOp(this.markets_by_id, getValue(value, "id"))))
            {
                ((List<object>)((object)getValue(this.markets_by_id, getValue(value, "id")))).Add(value);
            } else
            {
                ((Dictionary<string, object>)this.markets_by_id)[(string)getValue(value, "id")] = ((object)new List<object>() {value});
            }
            object market = this.deepExtend(this.safeMarket(), new Dictionary<string, object>() {
                { "precision", this.precision },
                { "limits", this.limits },
            }, getValue(this.fees, "trading"), value);
            ((List<object>)values).Add(market);
        }
        this.markets = ((object)this.indexBy(values, "symbol"));
        object marketsSortedBySymbol = this.keysort(this.markets);
        object marketsSortedById = this.keysort(this.markets_by_id);
        this.symbols = new List<object>(((Dictionary<string,object>)marketsSortedBySymbol).Keys);
        this.ids = new List<object>(((Dictionary<string,object>)marketsSortedById).Keys);
        if (isTrue(!isEqual(currencies, null)))
        {
            // currencies is always undefined when called in constructor but not when called from loadMarkets
            this.currencies = this.deepExtend(this.currencies, currencies);
        } else
        {
            object baseCurrencies = new List<object>() {};
            object quoteCurrencies = new List<object>() {};
            for (object i = 0; isLessThan(i, getArrayLength(values)); postFixIncrement(ref i))
            {
                object market = getValue(values, i);
                object defaultCurrencyPrecision = ((bool) isTrue((isEqual(this.precisionMode, DECIMAL_PLACES)))) ? 8 : this.parseNumber("1e-8");
                object marketPrecision = this.safeValue(market, "precision", new Dictionary<string, object>() {});
                if (isTrue(inOp(market, "base")))
                {
                    object currency = this.safeCurrencyStructure(new Dictionary<string, object>() {
                        { "id", this.safeString2(market, "baseId", "base") },
                        { "numericId", this.safeInteger(market, "baseNumericId") },
                        { "code", this.safeString(market, "base") },
                        { "precision", this.safeValue2(marketPrecision, "base", "amount", defaultCurrencyPrecision) },
                    });
                    ((List<object>)baseCurrencies).Add(currency);
                }
                if (isTrue(inOp(market, "quote")))
                {
                    object currency = this.safeCurrencyStructure(new Dictionary<string, object>() {
                        { "id", this.safeString2(market, "quoteId", "quote") },
                        { "numericId", this.safeInteger(market, "quoteNumericId") },
                        { "code", this.safeString(market, "quote") },
                        { "precision", this.safeValue2(marketPrecision, "quote", "price", defaultCurrencyPrecision) },
                    });
                    ((List<object>)quoteCurrencies).Add(currency);
                }
            }
            baseCurrencies = this.sortBy(baseCurrencies, "code");
            quoteCurrencies = this.sortBy(quoteCurrencies, "code");
            this.baseCurrencies = this.indexBy(baseCurrencies, "code");
            this.quoteCurrencies = this.indexBy(quoteCurrencies, "code");
            object allCurrencies = this.arrayConcat(baseCurrencies, quoteCurrencies);
            object groupedCurrencies = this.groupBy(allCurrencies, "code");
            object codes = new List<object>(((Dictionary<string,object>)groupedCurrencies).Keys);
            object resultingCurrencies = new List<object>() {};
            for (object i = 0; isLessThan(i, getArrayLength(codes)); postFixIncrement(ref i))
            {
                object code = getValue(codes, i);
                object groupedCurrenciesCode = this.safeValue(groupedCurrencies, code, new List<object>() {});
                object highestPrecisionCurrency = this.safeValue(groupedCurrenciesCode, 0);
                for (object j = 1; isLessThan(j, getArrayLength(groupedCurrenciesCode)); postFixIncrement(ref j))
                {
                    object currentCurrency = getValue(groupedCurrenciesCode, j);
                    if (isTrue(isEqual(this.precisionMode, TICK_SIZE)))
                    {
                        highestPrecisionCurrency = ((bool) isTrue((isLessThan(getValue(currentCurrency, "precision"), getValue(highestPrecisionCurrency, "precision"))))) ? currentCurrency : highestPrecisionCurrency;
                    } else
                    {
                        highestPrecisionCurrency = ((bool) isTrue((isGreaterThan(getValue(currentCurrency, "precision"), getValue(highestPrecisionCurrency, "precision"))))) ? currentCurrency : highestPrecisionCurrency;
                    }
                }
                ((List<object>)resultingCurrencies).Add(highestPrecisionCurrency);
            }
            object sortedCurrencies = this.sortBy(resultingCurrencies, "code");
            this.currencies = this.deepExtend(this.currencies, this.indexBy(sortedCurrencies, "code"));
        }
        this.currencies_by_id = this.indexBy(this.currencies, "id");
        object currenciesSortedByCode = this.keysort(this.currencies);
        this.codes = new List<object>(((Dictionary<string,object>)currenciesSortedByCode).Keys);
        return this.markets;
    }

    public virtual object safeBalance(object balance)
    {
        object balances = this.omit(balance, new List<object>() {"info", "timestamp", "datetime", "free", "used", "total"});
        object codes = new List<object>(((Dictionary<string,object>)balances).Keys);
        ((Dictionary<string, object>)balance)["free"] = new Dictionary<string, object>() {};
        ((Dictionary<string, object>)balance)["used"] = new Dictionary<string, object>() {};
        ((Dictionary<string, object>)balance)["total"] = new Dictionary<string, object>() {};
        object debtBalance = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(codes)); postFixIncrement(ref i))
        {
            object code = getValue(codes, i);
            object total = this.safeString(getValue(balance, code), "total");
            object free = this.safeString(getValue(balance, code), "free");
            object used = this.safeString(getValue(balance, code), "used");
            object debt = this.safeString(getValue(balance, code), "debt");
            if (isTrue(isTrue(isTrue((isEqual(total, null))) && isTrue((!isEqual(free, null)))) && isTrue((!isEqual(used, null)))))
            {
                total = Precise.stringAdd(free, used);
            }
            if (isTrue(isTrue(isTrue((isEqual(free, null))) && isTrue((!isEqual(total, null)))) && isTrue((!isEqual(used, null)))))
            {
                free = Precise.stringSub(total, used);
            }
            if (isTrue(isTrue(isTrue((isEqual(used, null))) && isTrue((!isEqual(total, null)))) && isTrue((!isEqual(free, null)))))
            {
                used = Precise.stringSub(total, free);
            }
            ((Dictionary<string, object>)getValue(balance, code))["free"] = this.parseNumber(free);
            ((Dictionary<string, object>)getValue(balance, code))["used"] = this.parseNumber(used);
            ((Dictionary<string, object>)getValue(balance, code))["total"] = this.parseNumber(total);
            ((Dictionary<string, object>)getValue(balance, "free"))[(string)code] = getValue(getValue(balance, code), "free");
            ((Dictionary<string, object>)getValue(balance, "used"))[(string)code] = getValue(getValue(balance, code), "used");
            ((Dictionary<string, object>)getValue(balance, "total"))[(string)code] = getValue(getValue(balance, code), "total");
            if (isTrue(!isEqual(debt, null)))
            {
                ((Dictionary<string, object>)getValue(balance, code))["debt"] = this.parseNumber(debt);
                ((Dictionary<string, object>)debtBalance)[(string)code] = getValue(getValue(balance, code), "debt");
            }
        }
        object debtBalanceArray = new List<object>(((Dictionary<string,object>)debtBalance).Keys);
        object length = getArrayLength(debtBalanceArray);
        if (isTrue(length))
        {
            ((Dictionary<string, object>)balance)["debt"] = debtBalance;
        }
        return ((object)balance);
    }

    public virtual object safeOrder(object order, object market = null)
    {
        // parses numbers as strings
        // * it is important pass the trades as unparsed rawTrades
        object amount = this.omitZero(this.safeString(order, "amount"));
        object remaining = this.safeString(order, "remaining");
        object filled = this.safeString(order, "filled");
        object cost = this.safeString(order, "cost");
        object average = this.omitZero(this.safeString(order, "average"));
        object price = this.omitZero(this.safeString(order, "price"));
        object lastTradeTimeTimestamp = this.safeInteger(order, "lastTradeTimestamp");
        object symbol = this.safeString(order, "symbol");
        object side = this.safeString(order, "side");
        object status = this.safeString(order, "status");
        object parseFilled = (isEqual(filled, null));
        object parseCost = (isEqual(cost, null));
        object parseLastTradeTimeTimestamp = (isEqual(lastTradeTimeTimestamp, null));
        object fee = this.safeValue(order, "fee");
        object parseFee = (isEqual(fee, null));
        object parseFees = isEqual(this.safeValue(order, "fees"), null);
        object parseSymbol = isEqual(symbol, null);
        object parseSide = isEqual(side, null);
        object shouldParseFees = isTrue(parseFee) || isTrue(parseFees);
        object fees = this.safeValue(order, "fees", new List<object>() {});
        object trades = new List<object>() {};
        if (isTrue(isTrue(isTrue(parseFilled) || isTrue(parseCost)) || isTrue(shouldParseFees)))
        {
            object rawTrades = this.safeValue(order, "trades", trades);
            object oldNumber = this.number;
            // we parse trades as strings here!
            this.number = typeof(String);
            trades = this.parseTrades(rawTrades, market);
            this.number = oldNumber;
            object tradesLength = 0;
            object isArray = (trades.GetType().IsGenericType && trades.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)));
            if (isTrue(isArray))
            {
                tradesLength = getArrayLength(trades);
            }
            if (isTrue(isTrue(isArray) && isTrue((isGreaterThan(tradesLength, 0)))))
            {
                // move properties that are defined in trades up into the order
                if (isTrue(isEqual(getValue(order, "symbol"), null)))
                {
                    ((Dictionary<string, object>)order)["symbol"] = getValue(getValue(trades, 0), "symbol");
                }
                if (isTrue(isEqual(getValue(order, "side"), null)))
                {
                    ((Dictionary<string, object>)order)["side"] = getValue(getValue(trades, 0), "side");
                }
                if (isTrue(isEqual(getValue(order, "type"), null)))
                {
                    ((Dictionary<string, object>)order)["type"] = getValue(getValue(trades, 0), "type");
                }
                if (isTrue(isEqual(getValue(order, "id"), null)))
                {
                    ((Dictionary<string, object>)order)["id"] = getValue(getValue(trades, 0), "order");
                }
                if (isTrue(parseFilled))
                {
                    filled = "0";
                }
                if (isTrue(parseCost))
                {
                    cost = "0";
                }
                for (object i = 0; isLessThan(i, getArrayLength(trades)); postFixIncrement(ref i))
                {
                    object trade = getValue(trades, i);
                    object tradeAmount = this.safeString(trade, "amount");
                    if (isTrue(isTrue(parseFilled) && isTrue((!isEqual(tradeAmount, null)))))
                    {
                        filled = Precise.stringAdd(filled, tradeAmount);
                    }
                    object tradeCost = this.safeString(trade, "cost");
                    if (isTrue(isTrue(parseCost) && isTrue((!isEqual(tradeCost, null)))))
                    {
                        cost = Precise.stringAdd(cost, tradeCost);
                    }
                    if (isTrue(parseSymbol))
                    {
                        symbol = this.safeString(trade, "symbol");
                    }
                    if (isTrue(parseSide))
                    {
                        side = this.safeString(trade, "side");
                    }
                    object tradeTimestamp = this.safeValue(trade, "timestamp");
                    if (isTrue(isTrue(parseLastTradeTimeTimestamp) && isTrue((!isEqual(tradeTimestamp, null)))))
                    {
                        if (isTrue(isEqual(lastTradeTimeTimestamp, null)))
                        {
                            lastTradeTimeTimestamp = tradeTimestamp;
                        } else
                        {
                            lastTradeTimeTimestamp = mathMax(lastTradeTimeTimestamp, tradeTimestamp);
                        }
                    }
                    if (isTrue(shouldParseFees))
                    {
                        object tradeFees = this.safeValue(trade, "fees");
                        if (isTrue(!isEqual(tradeFees, null)))
                        {
                            for (object j = 0; isLessThan(j, getArrayLength(tradeFees)); postFixIncrement(ref j))
                            {
                                object tradeFee = getValue(tradeFees, j);
                                ((List<object>)fees).Add(this.extend(new Dictionary<string, object>() {}, tradeFee));
                            }
                        } else
                        {
                            object tradeFee = this.safeValue(trade, "fee");
                            if (isTrue(!isEqual(tradeFee, null)))
                            {
                                ((List<object>)fees).Add(this.extend(new Dictionary<string, object>() {}, tradeFee));
                            }
                        }
                    }
                }
            }
        }
        if (isTrue(shouldParseFees))
        {
            object reducedFees = ((bool) isTrue(this.reduceFees)) ? this.reduceFeesByCurrency(fees) : fees;
            object reducedLength = getArrayLength(reducedFees);
            for (object i = 0; isLessThan(i, reducedLength); postFixIncrement(ref i))
            {
                ((Dictionary<string, object>)getValue(reducedFees, i))["cost"] = this.safeNumber(getValue(reducedFees, i), "cost");
                if (isTrue(inOp(getValue(reducedFees, i), "rate")))
                {
                    ((Dictionary<string, object>)getValue(reducedFees, i))["rate"] = this.safeNumber(getValue(reducedFees, i), "rate");
                }
            }
            if (isTrue(!isTrue(parseFee) && isTrue((isEqual(reducedLength, 0)))))
            {
                ((Dictionary<string, object>)fee)["cost"] = this.safeNumber(fee, "cost");
                if (isTrue(inOp(fee, "rate")))
                {
                    ((Dictionary<string, object>)fee)["rate"] = this.safeNumber(fee, "rate");
                }
                ((List<object>)reducedFees).Add(fee);
            }
            ((Dictionary<string, object>)order)["fees"] = reducedFees;
            if (isTrue(isTrue(parseFee) && isTrue((isEqual(reducedLength, 1)))))
            {
                ((Dictionary<string, object>)order)["fee"] = getValue(reducedFees, 0);
            }
        }
        if (isTrue(isEqual(amount, null)))
        {
            // ensure amount = filled + remaining
            if (isTrue(isTrue(!isEqual(filled, null)) && isTrue(!isEqual(remaining, null))))
            {
                amount = Precise.stringAdd(filled, remaining);
            } else if (isTrue(isEqual(status, "closed")))
            {
                amount = filled;
            }
        }
        if (isTrue(isEqual(filled, null)))
        {
            if (isTrue(isTrue(!isEqual(amount, null)) && isTrue(!isEqual(remaining, null))))
            {
                filled = Precise.stringSub(amount, remaining);
            } else if (isTrue(isTrue(isEqual(status, "closed")) && isTrue(!isEqual(amount, null))))
            {
                filled = amount;
            }
        }
        if (isTrue(isEqual(remaining, null)))
        {
            if (isTrue(isTrue(!isEqual(amount, null)) && isTrue(!isEqual(filled, null))))
            {
                remaining = Precise.stringSub(amount, filled);
            } else if (isTrue(isEqual(status, "closed")))
            {
                remaining = "0";
            }
        }
        // ensure that the average field is calculated correctly
        object inverse = this.safeValue(market, "inverse", false);
        object contractSize = this.numberToString(this.safeValue(market, "contractSize", 1));
        // inverse
        // price = filled * contract size / cost
        //
        // linear
        // price = cost / (filled * contract size)
        if (isTrue(isEqual(average, null)))
        {
            if (isTrue(isTrue(isTrue((!isEqual(filled, null))) && isTrue((!isEqual(cost, null)))) && isTrue(Precise.stringGt(filled, "0"))))
            {
                object filledTimesContractSize = Precise.stringMul(filled, contractSize);
                if (isTrue(inverse))
                {
                    average = Precise.stringDiv(filledTimesContractSize, cost);
                } else
                {
                    average = Precise.stringDiv(cost, filledTimesContractSize);
                }
            }
        }
        // similarly
        // inverse
        // cost = filled * contract size / price
        //
        // linear
        // cost = filled * contract size * price
        object costPriceExists = isTrue((!isEqual(average, null))) || isTrue((!isEqual(price, null)));
        if (isTrue(isTrue(isTrue(parseCost) && isTrue((!isEqual(filled, null)))) && isTrue(costPriceExists)))
        {
            object multiplyPrice = null;
            if (isTrue(isEqual(average, null)))
            {
                multiplyPrice = price;
            } else
            {
                multiplyPrice = average;
            }
            // contract trading
            object filledTimesContractSize = Precise.stringMul(filled, contractSize);
            if (isTrue(inverse))
            {
                cost = Precise.stringDiv(filledTimesContractSize, multiplyPrice);
            } else
            {
                cost = Precise.stringMul(filledTimesContractSize, multiplyPrice);
            }
        }
        // support for market orders
        object orderType = this.safeValue(order, "type");
        object emptyPrice = isTrue((isEqual(price, null))) || isTrue(Precise.stringEquals(price, "0"));
        if (isTrue(isTrue(emptyPrice) && isTrue((isEqual(orderType, "market")))))
        {
            price = average;
        }
        // we have trades with string values at this point so we will mutate them
        for (object i = 0; isLessThan(i, getArrayLength(trades)); postFixIncrement(ref i))
        {
            object entry = getValue(trades, i);
            ((Dictionary<string, object>)entry)["amount"] = this.safeNumber(entry, "amount");
            ((Dictionary<string, object>)entry)["price"] = this.safeNumber(entry, "price");
            ((Dictionary<string, object>)entry)["cost"] = this.safeNumber(entry, "cost");
            object feeNew = this.safeValue(entry, "fee", new Dictionary<string, object>() {});
            ((Dictionary<string, object>)feeNew)["cost"] = this.safeNumber(feeNew, "cost");
            if (isTrue(inOp(feeNew, "rate")))
            {
                ((Dictionary<string, object>)feeNew)["rate"] = this.safeNumber(feeNew, "rate");
            }
            ((Dictionary<string, object>)entry)["fee"] = feeNew;
        }
        object timeInForce = this.safeString(order, "timeInForce");
        object postOnly = this.safeValue(order, "postOnly");
        // timeInForceHandling
        if (isTrue(isEqual(timeInForce, null)))
        {
            if (isTrue(isEqual(this.safeString(order, "type"), "market")))
            {
                timeInForce = "IOC";
            }
            // allow postOnly override
            if (isTrue(postOnly))
            {
                timeInForce = "PO";
            }
        } else if (isTrue(isEqual(postOnly, null)))
        {
            // timeInForce is not undefined here
            postOnly = isEqual(timeInForce, "PO");
        }
        object timestamp = this.safeInteger(order, "timestamp");
        object lastUpdateTimestamp = this.safeInteger(order, "lastUpdateTimestamp");
        object datetime = this.safeString(order, "datetime");
        if (isTrue(isEqual(datetime, null)))
        {
            datetime = this.iso8601(timestamp);
        }
        object triggerPrice = this.parseNumber(this.safeString2(order, "triggerPrice", "stopPrice"));
        object takeProfitPrice = this.parseNumber(this.safeString(order, "takeProfitPrice"));
        object stopLossPrice = this.parseNumber(this.safeString(order, "stopLossPrice"));
        return this.extend(order, new Dictionary<string, object>() {
            { "id", this.safeString(order, "id") },
            { "clientOrderId", this.safeString(order, "clientOrderId") },
            { "timestamp", timestamp },
            { "datetime", datetime },
            { "symbol", symbol },
            { "type", this.safeString(order, "type") },
            { "side", side },
            { "lastTradeTimestamp", lastTradeTimeTimestamp },
            { "lastUpdateTimestamp", lastUpdateTimestamp },
            { "price", this.parseNumber(price) },
            { "amount", this.parseNumber(amount) },
            { "cost", this.parseNumber(cost) },
            { "average", this.parseNumber(average) },
            { "filled", this.parseNumber(filled) },
            { "remaining", this.parseNumber(remaining) },
            { "timeInForce", timeInForce },
            { "postOnly", postOnly },
            { "trades", trades },
            { "reduceOnly", this.safeValue(order, "reduceOnly") },
            { "stopPrice", triggerPrice },
            { "triggerPrice", triggerPrice },
            { "takeProfitPrice", takeProfitPrice },
            { "stopLossPrice", stopLossPrice },
            { "status", status },
            { "fee", this.safeValue(order, "fee") },
        });
    }

    public virtual object parseOrders(object orders, object market = null, object since = null, object limit = null, object parameters = null)
    {
        //
        // the value of orders is either a dict or a list
        //
        // dict
        //
        //     {
        //         'id1': { ... },
        //         'id2': { ... },
        //         'id3': { ... },
        //         ...
        //     }
        //
        // list
        //
        //     [
        //         { 'id': 'id1', ... },
        //         { 'id': 'id2', ... },
        //         { 'id': 'id3', ... },
        //         ...
        //     ]
        //
        parameters ??= new Dictionary<string, object>();
        object results = new List<object>() {};
        if (isTrue((orders.GetType().IsGenericType && orders.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))
        {
            for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
            {
                object order = this.extend(this.parseOrder(getValue(orders, i), market), parameters);
                ((List<object>)results).Add(order);
            }
        } else
        {
            object ids = new List<object>(((Dictionary<string,object>)orders).Keys);
            for (object i = 0; isLessThan(i, getArrayLength(ids)); postFixIncrement(ref i))
            {
                object id = getValue(ids, i);
                object order = this.extend(this.parseOrder(this.extend(new Dictionary<string, object>() {
                    { "id", id },
                }, getValue(orders, id)), market), parameters);
                ((List<object>)results).Add(order);
            }
        }
        results = this.sortBy(results, "timestamp");
        object symbol = ((bool) isTrue((!isEqual(market, null)))) ? getValue(market, "symbol") : null;
        return this.filterBySymbolSinceLimit(results, symbol, since, limit);
    }

    public virtual object calculateFee(object symbol, object type, object side, object amount, object price, object takerOrMaker = null, object parameters = null)
    {
        takerOrMaker ??= "taker";
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isTrue(isEqual(type, "market")) && isTrue(isEqual(takerOrMaker, "maker"))))
        {
            throw new ArgumentsRequired ((string)add(this.id, " calculateFee() - you have provided incompatible arguments - \"market\" type order can not be \"maker\". Change either the \"type\" or the \"takerOrMaker\" argument to calculate the fee.")) ;
        }
        object market = getValue(this.markets, symbol);
        object feeSide = this.safeString(market, "feeSide", "quote");
        object useQuote = null;
        if (isTrue(isEqual(feeSide, "get")))
        {
            // the fee is always in the currency you get
            useQuote = isEqual(side, "sell");
        } else if (isTrue(isEqual(feeSide, "give")))
        {
            // the fee is always in the currency you give
            useQuote = isEqual(side, "buy");
        } else
        {
            // the fee is always in feeSide currency
            useQuote = isEqual(feeSide, "quote");
        }
        object cost = this.numberToString(amount);
        object key = null;
        if (isTrue(useQuote))
        {
            object priceString = this.numberToString(price);
            cost = Precise.stringMul(cost, priceString);
            key = "quote";
        } else
        {
            key = "base";
        }
        // for derivatives, the fee is in 'settle' currency
        if (!isTrue(getValue(market, "spot")))
        {
            key = "settle";
        }
        // even if `takerOrMaker` argument was set to 'maker', for 'market' orders we should forcefully override it to 'taker'
        if (isTrue(isEqual(type, "market")))
        {
            takerOrMaker = "taker";
        }
        object rate = this.safeString(market, takerOrMaker);
        cost = Precise.stringMul(cost, rate);
        return new Dictionary<string, object>() {
            { "type", takerOrMaker },
            { "currency", getValue(market, key) },
            { "rate", this.parseNumber(rate) },
            { "cost", this.parseNumber(cost) },
        };
    }

    public virtual object safeTrade(object trade, object market = null)
    {
        object amount = this.safeString(trade, "amount");
        object price = this.safeString(trade, "price");
        object cost = this.safeString(trade, "cost");
        if (isTrue(isEqual(cost, null)))
        {
            // contract trading
            object contractSize = this.safeString(market, "contractSize");
            object multiplyPrice = price;
            if (isTrue(!isEqual(contractSize, null)))
            {
                object inverse = this.safeValue(market, "inverse", false);
                if (isTrue(inverse))
                {
                    multiplyPrice = Precise.stringDiv("1", price);
                }
                multiplyPrice = Precise.stringMul(multiplyPrice, contractSize);
            }
            cost = Precise.stringMul(multiplyPrice, amount);
        }
        object parseFee = isEqual(this.safeValue(trade, "fee"), null);
        object parseFees = isEqual(this.safeValue(trade, "fees"), null);
        object shouldParseFees = isTrue(parseFee) || isTrue(parseFees);
        object fees = new List<object>() {};
        object fee = this.safeValue(trade, "fee");
        if (isTrue(shouldParseFees))
        {
            object reducedFees = ((bool) isTrue(this.reduceFees)) ? this.reduceFeesByCurrency(fees) : fees;
            object reducedLength = getArrayLength(reducedFees);
            for (object i = 0; isLessThan(i, reducedLength); postFixIncrement(ref i))
            {
                ((Dictionary<string, object>)getValue(reducedFees, i))["cost"] = this.safeNumber(getValue(reducedFees, i), "cost");
                if (isTrue(inOp(getValue(reducedFees, i), "rate")))
                {
                    ((Dictionary<string, object>)getValue(reducedFees, i))["rate"] = this.safeNumber(getValue(reducedFees, i), "rate");
                }
            }
            if (isTrue(!isTrue(parseFee) && isTrue((isEqual(reducedLength, 0)))))
            {
                ((Dictionary<string, object>)fee)["cost"] = this.safeNumber(fee, "cost");
                if (isTrue(inOp(fee, "rate")))
                {
                    ((Dictionary<string, object>)fee)["rate"] = this.safeNumber(fee, "rate");
                }
                ((List<object>)reducedFees).Add(fee);
            }
            if (isTrue(parseFees))
            {
                ((Dictionary<string, object>)trade)["fees"] = reducedFees;
            }
            if (isTrue(isTrue(parseFee) && isTrue((isEqual(reducedLength, 1)))))
            {
                ((Dictionary<string, object>)trade)["fee"] = getValue(reducedFees, 0);
            }
            object tradeFee = this.safeValue(trade, "fee");
            if (isTrue(!isEqual(tradeFee, null)))
            {
                ((Dictionary<string, object>)tradeFee)["cost"] = this.safeNumber(tradeFee, "cost");
                if (isTrue(inOp(tradeFee, "rate")))
                {
                    ((Dictionary<string, object>)tradeFee)["rate"] = this.safeNumber(tradeFee, "rate");
                }
                ((Dictionary<string, object>)trade)["fee"] = tradeFee;
            }
        }
        ((Dictionary<string, object>)trade)["amount"] = this.parseNumber(amount);
        ((Dictionary<string, object>)trade)["price"] = this.parseNumber(price);
        ((Dictionary<string, object>)trade)["cost"] = this.parseNumber(cost);
        return trade;
    }

    public virtual object invertFlatStringDictionary(object dict)
    {
        object reversed = new Dictionary<string, object>() {};
        object keys = new List<object>(((Dictionary<string,object>)dict).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object key = getValue(keys, i);
            object value = getValue(dict, key);
            if (isTrue(((value).GetType() == typeof(string))))
            {
                ((Dictionary<string, object>)reversed)[(string)value] = key;
            }
        }
        return reversed;
    }

    public virtual object reduceFeesByCurrency(object fees)
    {
        //
        // this function takes a list of fee structures having the following format
        //
        //     string = true
        //
        //     [
        //         { 'currency': 'BTC', 'cost': '0.1' },
        //         { 'currency': 'BTC', 'cost': '0.2'  },
        //         { 'currency': 'BTC', 'cost': '0.2', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.4', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.5', 'rate': '0.00456' },
        //         { 'currency': 'USDT', 'cost': '12.3456' },
        //     ]
        //
        //     string = false
        //
        //     [
        //         { 'currency': 'BTC', 'cost': 0.1 },
        //         { 'currency': 'BTC', 'cost': 0.2 },
        //         { 'currency': 'BTC', 'cost': 0.2, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.4, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.5, 'rate': 0.00456 },
        //         { 'currency': 'USDT', 'cost': 12.3456 },
        //     ]
        //
        // and returns a reduced fee list, where fees are summed per currency and rate (if any)
        //
        //     string = true
        //
        //     [
        //         { 'currency': 'BTC', 'cost': '0.3'  },
        //         { 'currency': 'BTC', 'cost': '0.6', 'rate': '0.00123' },
        //         { 'currency': 'BTC', 'cost': '0.5', 'rate': '0.00456' },
        //         { 'currency': 'USDT', 'cost': '12.3456' },
        //     ]
        //
        //     string  = false
        //
        //     [
        //         { 'currency': 'BTC', 'cost': 0.3  },
        //         { 'currency': 'BTC', 'cost': 0.6, 'rate': 0.00123 },
        //         { 'currency': 'BTC', 'cost': 0.5, 'rate': 0.00456 },
        //         { 'currency': 'USDT', 'cost': 12.3456 },
        //     ]
        //
        object reduced = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(fees)); postFixIncrement(ref i))
        {
            object fee = getValue(fees, i);
            object feeCurrencyCode = this.safeString(fee, "currency");
            if (isTrue(!isEqual(feeCurrencyCode, null)))
            {
                object rate = this.safeString(fee, "rate");
                object cost = this.safeValue(fee, "cost");
                if (isTrue(Precise.stringEq(cost, "0")))
                {
                    continue;
                }
                if (!isTrue((inOp(reduced, feeCurrencyCode))))
                {
                    ((Dictionary<string, object>)reduced)[(string)feeCurrencyCode] = new Dictionary<string, object>() {};
                }
                object rateKey = ((bool) isTrue((isEqual(rate, null)))) ? "" : rate;
                if (isTrue(inOp(getValue(reduced, feeCurrencyCode), rateKey)))
                {
                    ((Dictionary<string, object>)getValue(getValue(reduced, feeCurrencyCode), rateKey))["cost"] = Precise.stringAdd(getValue(getValue(getValue(reduced, feeCurrencyCode), rateKey), "cost"), cost);
                } else
                {
                    ((Dictionary<string, object>)getValue(reduced, feeCurrencyCode))[(string)rateKey] = new Dictionary<string, object>() {
                        { "currency", feeCurrencyCode },
                        { "cost", cost },
                    };
                    if (isTrue(!isEqual(rate, null)))
                    {
                        ((Dictionary<string, object>)getValue(getValue(reduced, feeCurrencyCode), rateKey))["rate"] = rate;
                    }
                }
            }
        }
        object result = new List<object>() {};
        object feeValues = new List<object>(((Dictionary<string,object>)reduced).Values);
        for (object i = 0; isLessThan(i, getArrayLength(feeValues)); postFixIncrement(ref i))
        {
            object reducedFeeValues = new List<object>(((Dictionary<string,object>)getValue(feeValues, i)).Values);
            result = this.arrayConcat(result, reducedFeeValues);
        }
        return result;
    }

    public virtual object safeTicker(object ticker, object market = null)
    {
        object open = this.safeValue(ticker, "open");
        object close = this.safeValue(ticker, "close");
        object last = this.safeValue(ticker, "last");
        object change = this.safeValue(ticker, "change");
        object percentage = this.safeValue(ticker, "percentage");
        object average = this.safeValue(ticker, "average");
        object vwap = this.safeValue(ticker, "vwap");
        object baseVolume = this.safeString(ticker, "baseVolume");
        object quoteVolume = this.safeString(ticker, "quoteVolume");
        if (isTrue(isEqual(vwap, null)))
        {
            vwap = Precise.stringDiv(quoteVolume, baseVolume);
        }
        if (isTrue(isTrue((!isEqual(last, null))) && isTrue((isEqual(close, null)))))
        {
            close = last;
        } else if (isTrue(isTrue((isEqual(last, null))) && isTrue((!isEqual(close, null)))))
        {
            last = close;
        }
        if (isTrue(isTrue((!isEqual(last, null))) && isTrue((!isEqual(open, null)))))
        {
            if (isTrue(isEqual(change, null)))
            {
                change = Precise.stringSub(last, open);
            }
            if (isTrue(isEqual(average, null)))
            {
                average = Precise.stringDiv(Precise.stringAdd(last, open), "2");
            }
        }
        if (isTrue(isTrue(isTrue(isTrue((isEqual(percentage, null))) && isTrue((!isEqual(change, null)))) && isTrue((!isEqual(open, null)))) && isTrue(Precise.stringGt(open, "0"))))
        {
            percentage = Precise.stringMul(Precise.stringDiv(change, open), "100");
        }
        if (isTrue(isTrue(isTrue((isEqual(change, null))) && isTrue((!isEqual(percentage, null)))) && isTrue((!isEqual(open, null)))))
        {
            change = Precise.stringDiv(Precise.stringMul(percentage, open), "100");
        }
        if (isTrue(isTrue(isTrue((isEqual(open, null))) && isTrue((!isEqual(last, null)))) && isTrue((!isEqual(change, null)))))
        {
            open = Precise.stringSub(last, change);
        }
        // timestamp and symbol operations don't belong in safeTicker
        // they should be done in the derived classes
        return this.extend(ticker, new Dictionary<string, object>() {
            { "bid", this.omitZero(this.safeNumber(ticker, "bid")) },
            { "bidVolume", this.safeNumber(ticker, "bidVolume") },
            { "ask", this.omitZero(this.safeNumber(ticker, "ask")) },
            { "askVolume", this.safeNumber(ticker, "askVolume") },
            { "high", this.omitZero(this.safeNumber(ticker, "high")) },
            { "low", this.omitZero(this.safeNumber(ticker, "low")) },
            { "open", this.omitZero(this.parseNumber(open)) },
            { "close", this.omitZero(this.parseNumber(close)) },
            { "last", this.omitZero(this.parseNumber(last)) },
            { "change", this.parseNumber(change) },
            { "percentage", this.parseNumber(percentage) },
            { "average", this.omitZero(this.parseNumber(average)) },
            { "vwap", this.omitZero(this.parseNumber(vwap)) },
            { "baseVolume", this.parseNumber(baseVolume) },
            { "quoteVolume", this.parseNumber(quoteVolume) },
            { "previousClose", this.safeNumber(ticker, "previousClose") },
        });
    }

    public async virtual Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        object message = "";
        if (isTrue(getValue(this.has, "fetchTrades")))
        {
            message = ". If you want to build OHLCV candles from trade executions data, visit https://github.com/ccxt/ccxt/tree/master/examples/ and see \"build-ohlcv-bars\" file";
        }
        throw new NotSupported ((string)add(add(this.id, " fetchOHLCV() is not supported yet"), message)) ;
    }

    public async virtual Task<object> watchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " watchOHLCV() is not supported yet")) ;
    }

    public virtual object convertTradingViewToOHLCV(object ohlcvs, object timestamp = null, object open = null, object high = null, object low = null, object close = null, object volume = null, object ms = null)
    {
        timestamp ??= "t";
        open ??= "o";
        high ??= "h";
        low ??= "l";
        close ??= "c";
        volume ??= "v";
        ms ??= false;
        object result = new List<object>() {};
        object timestamps = this.safeValue(ohlcvs, timestamp, new List<object>() {});
        object opens = this.safeValue(ohlcvs, open, new List<object>() {});
        object highs = this.safeValue(ohlcvs, high, new List<object>() {});
        object lows = this.safeValue(ohlcvs, low, new List<object>() {});
        object closes = this.safeValue(ohlcvs, close, new List<object>() {});
        object volumes = this.safeValue(ohlcvs, volume, new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(timestamps)); postFixIncrement(ref i))
        {
            ((List<object>)result).Add(new List<object>() {((bool) isTrue(ms)) ? this.safeInteger(timestamps, i) : this.safeTimestamp(timestamps, i), this.safeValue(opens, i), this.safeValue(highs, i), this.safeValue(lows, i), this.safeValue(closes, i), this.safeValue(volumes, i)});
        }
        return result;
    }

    public virtual object convertOHLCVToTradingView(object ohlcvs, object timestamp = null, object open = null, object high = null, object low = null, object close = null, object volume = null, object ms = null)
    {
        timestamp ??= "t";
        open ??= "o";
        high ??= "h";
        low ??= "l";
        close ??= "c";
        volume ??= "v";
        ms ??= false;
        object result = new Dictionary<string, object>() {};
        ((Dictionary<string, object>)result)[(string)timestamp] = new List<object>() {};
        ((Dictionary<string, object>)result)[(string)open] = new List<object>() {};
        ((Dictionary<string, object>)result)[(string)high] = new List<object>() {};
        ((Dictionary<string, object>)result)[(string)low] = new List<object>() {};
        ((Dictionary<string, object>)result)[(string)close] = new List<object>() {};
        ((Dictionary<string, object>)result)[(string)volume] = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(ohlcvs)); postFixIncrement(ref i))
        {
            object ts = ((bool) isTrue(ms)) ? getValue(getValue(ohlcvs, i), 0) : this.parseToInt(divide(getValue(getValue(ohlcvs, i), 0), 1000));
            ((List<object>)getValue(result, timestamp)).Add(ts);
            ((List<object>)getValue(result, open)).Add(getValue(getValue(ohlcvs, i), 1));
            ((List<object>)getValue(result, high)).Add(getValue(getValue(ohlcvs, i), 2));
            ((List<object>)getValue(result, low)).Add(getValue(getValue(ohlcvs, i), 3));
            ((List<object>)getValue(result, close)).Add(getValue(getValue(ohlcvs, i), 4));
            ((List<object>)getValue(result, volume)).Add(getValue(getValue(ohlcvs, i), 5));
        }
        return result;
    }

    public async virtual Task<object> fetchWebEndpoint(object method, object endpointMethod, object returnAsJson, object startRegex = null, object endRegex = null)
    {
        object errorMessage = "";
        object options = this.safeValue(this.options, method, new Dictionary<string, object>() {});
        object muteOnFailure = this.safeValue(options, "webApiMuteFailure", true);
        try
        {
            // if it was not explicitly disabled, then don't fetch
            if (isTrue(!isEqual(this.safeValue(options, "webApiEnable", true), true)))
            {
                return null;
            }
            object maxRetries = this.safeValue(options, "webApiRetries", 10);
            object response = null;
            object retry = 0;
            while (isLessThan(retry, maxRetries))
            {
                try
                {
                    response = await ((Task<object>)callDynamically(this, endpointMethod, new object[] { new Dictionary<string, object>() {} }));
                    break;
                } catch(Exception e)
                {
                    retry = add(retry, 1);
                    if (isTrue(isEqual(retry, maxRetries)))
                    {
                        throw e;
                    }
                }
            }
            object content = response;
            if (isTrue(!isEqual(startRegex, null)))
            {
                object splitted_by_start = ((string)content).Split(new [] {((string)startRegex)}, StringSplitOptions.None).ToList<object>();
                content = getValue(splitted_by_start, 1); // we need second part after start
            }
            if (isTrue(!isEqual(endRegex, null)))
            {
                object splitted_by_end = ((string)content).Split(new [] {((string)endRegex)}, StringSplitOptions.None).ToList<object>();
                content = getValue(splitted_by_end, 0); // we need first part after start
            }
            if (isTrue(isTrue(returnAsJson) && isTrue((((content).GetType() == typeof(string))))))
            {
                object jsoned = this.parseJson(((string)content).Trim()); // content should be trimmed before json parsing
                if (isTrue(jsoned))
                {
                    return jsoned;  // if parsing was not successfull, exception should be thrown
                } else
                {
                    throw new BadResponse ((string)"could not parse the response into json") ;
                }
            } else
            {
                return content;
            }
        } catch(Exception e)
        {
            errorMessage = add(add(add(this.id, " "), method), "() failed to fetch correct data from website. Probably webpage markup has been changed, breaking the page custom parser.");
        }
        if (isTrue(muteOnFailure))
        {
            return null;
        } else
        {
            throw new BadResponse ((string)errorMessage) ;
        }
    }

    public virtual object marketIds(object symbols)
    {
        if (isTrue(isEqual(symbols, null)))
        {
            return symbols;
        }
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            ((List<object>)result).Add(this.marketId(getValue(symbols, i)));
        }
        return result;
    }

    public virtual object marketSymbols(object symbols, object type = null)
    {
        if (isTrue(isEqual(symbols, null)))
        {
            return symbols;
        }
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object market = this.market(getValue(symbols, i));
            if (isTrue(isTrue(!isEqual(type, null)) && isTrue(!isEqual(getValue(market, "type"), type))))
            {
                throw new BadRequest ((string)add(add(add(this.id, " symbols must be of same type "), type), ". If the type is incorrect you can change it in options or the params of the request")) ;
            }
            object symbol = this.safeString(market, "symbol", getValue(symbols, i));
            ((List<object>)result).Add(symbol);
        }
        return result;
    }

    public virtual object marketCodes(object codes)
    {
        if (isTrue(isEqual(codes, null)))
        {
            return codes;
        }
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(codes)); postFixIncrement(ref i))
        {
            ((List<object>)result).Add(this.commonCurrencyCode(getValue(codes, i)));
        }
        return result;
    }

    public virtual object parseBidsAsks(object bidasks, object priceKey = null, object amountKey = null)
    {
        priceKey ??= 0;
        amountKey ??= 1;
        bidasks = this.toArray(bidasks);
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(bidasks)); postFixIncrement(ref i))
        {
            ((List<object>)result).Add(this.parseBidAsk(getValue(bidasks, i), priceKey, amountKey));
        }
        return result;
    }

    public async virtual Task<object> fetchL2OrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object orderbook = await this.fetchOrderBook(symbol, limit, parameters);
        return this.extend(orderbook, new Dictionary<string, object>() {
            { "asks", this.sortBy(this.aggregate(getValue(orderbook, "asks")), 0) },
            { "bids", this.sortBy(this.aggregate(getValue(orderbook, "bids")), 0, true) },
        });
    }

    public virtual object filterBySymbol(object objects, object symbol = null)
    {
        if (isTrue(isEqual(symbol, null)))
        {
            return objects;
        }
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(objects)); postFixIncrement(ref i))
        {
            object objectSymbol = this.safeString(getValue(objects, i), "symbol");
            if (isTrue(isEqual(objectSymbol, symbol)))
            {
                ((List<object>)result).Add(getValue(objects, i));
            }
        }
        return result;
    }

    public virtual object parseOHLCV(object ohlcv, object market = null)
    {
        if (isTrue((ohlcv.GetType().IsGenericType && ohlcv.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))
        {
            return new List<object> {this.safeInteger(ohlcv, 0), this.safeNumber(ohlcv, 1), this.safeNumber(ohlcv, 2), this.safeNumber(ohlcv, 3), this.safeNumber(ohlcv, 4), this.safeNumber(ohlcv, 5)};
        }
        return ohlcv;
    }

    public virtual object networkCodeToId(object networkCode, object currencyCode = null)
    {
        /**
         * @ignore
         * @method
         * @name exchange#networkCodeToId
         * @description tries to convert the provided networkCode (which is expected to be an unified network code) to a network id. In order to achieve this, derived class needs to have 'options->networks' defined.
         * @param {string} networkCode unified network code
         * @param {string} currencyCode unified currency code, but this argument is not required by default, unless there is an exchange (like huobi) that needs an override of the method to be able to pass currencyCode argument additionally
         * @returns {string|undefined} exchange-specific network id
         */
        object networkIdsByCodes = this.safeValue(this.options, "networks", new Dictionary<string, object>() {});
        object networkId = this.safeString(networkIdsByCodes, networkCode);
        // for example, if 'ETH' is passed for networkCode, but 'ETH' key not defined in `options->networks` object
        if (isTrue(isEqual(networkId, null)))
        {
            if (isTrue(isEqual(currencyCode, null)))
            {
                // if currencyCode was not provided, then we just set passed value to networkId
                networkId = networkCode;
            } else
            {
                // if currencyCode was provided, then we try to find if that currencyCode has a replacement (i.e. ERC20 for ETH)
                object defaultNetworkCodeReplacements = this.safeValue(this.options, "defaultNetworkCodeReplacements", new Dictionary<string, object>() {});
                if (isTrue(inOp(defaultNetworkCodeReplacements, currencyCode)))
                {
                    // if there is a replacement for the passed networkCode, then we use it to find network-id in `options->networks` object
                    object replacementObject = getValue(defaultNetworkCodeReplacements, currencyCode); // i.e. { 'ERC20': 'ETH' }
                    object keys = new List<object>(((Dictionary<string,object>)replacementObject).Keys);
                    for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
                    {
                        object key = getValue(keys, i);
                        object value = getValue(replacementObject, key);
                        // if value matches to provided unified networkCode, then we use it's key to find network-id in `options->networks` object
                        if (isTrue(isEqual(value, networkCode)))
                        {
                            networkId = this.safeString(networkIdsByCodes, key);
                            break;
                        }
                    }
                }
                // if it wasn't found, we just set the provided value to network-id
                if (isTrue(isEqual(networkId, null)))
                {
                    networkId = networkCode;
                }
            }
        }
        return networkId;
    }

    public virtual object networkIdToCode(object networkId, object currencyCode = null)
    {
        /**
         * @ignore
         * @method
         * @name exchange#networkIdToCode
         * @description tries to convert the provided exchange-specific networkId to an unified network Code. In order to achieve this, derived class needs to have "options['networksById']" defined.
         * @param {string} networkId exchange specific network id/title, like: TRON, Trc-20, usdt-erc20, etc
         * @param {string|undefined} currencyCode unified currency code, but this argument is not required by default, unless there is an exchange (like huobi) that needs an override of the method to be able to pass currencyCode argument additionally
         * @returns {string|undefined} unified network code
         */
        object networkCodesByIds = this.safeValue(this.options, "networksById", new Dictionary<string, object>() {});
        object networkCode = this.safeString(networkCodesByIds, networkId, networkId);
        // replace mainnet network-codes (i.e. ERC20->ETH)
        if (isTrue(!isEqual(currencyCode, null)))
        {
            object defaultNetworkCodeReplacements = this.safeValue(this.options, "defaultNetworkCodeReplacements", new Dictionary<string, object>() {});
            if (isTrue(inOp(defaultNetworkCodeReplacements, currencyCode)))
            {
                object replacementObject = this.safeValue(defaultNetworkCodeReplacements, currencyCode, new Dictionary<string, object>() {});
                networkCode = this.safeString(replacementObject, networkCode, networkCode);
            }
        }
        return networkCode;
    }

    public virtual object handleNetworkCodeAndParams(object parameters)
    {
        object networkCodeInParams = this.safeString2(parameters, "networkCode", "network");
        if (isTrue(!isEqual(networkCodeInParams, null)))
        {
            parameters = this.omit(parameters, new List<object>() {"networkCode", "network"});
        }
        // if it was not defined by user, we should not set it from 'defaultNetworks', because handleNetworkCodeAndParams is for only request-side and thus we do not fill it with anything. We can only use 'defaultNetworks' after parsing response-side
        return new List<object>() {networkCodeInParams, parameters};
    }

    public virtual object defaultNetworkCode(object currencyCode)
    {
        object defaultNetworkCode = null;
        object defaultNetworks = this.safeValue(this.options, "defaultNetworks", new Dictionary<string, object>() {});
        if (isTrue(inOp(defaultNetworks, currencyCode)))
        {
            // if currency had set its network in "defaultNetworks", use it
            defaultNetworkCode = getValue(defaultNetworks, currencyCode);
        } else
        {
            // otherwise, try to use the global-scope 'defaultNetwork' value (even if that network is not supported by currency, it doesn't make any problem, this will be just used "at first" if currency supports this network at all)
            object defaultNetwork = this.safeValue(this.options, "defaultNetwork");
            if (isTrue(!isEqual(defaultNetwork, null)))
            {
                defaultNetworkCode = defaultNetwork;
            }
        }
        return defaultNetworkCode;
    }

    public virtual object selectNetworkCodeFromUnifiedNetworks(object currencyCode, object networkCode, object indexedNetworkEntries)
    {
        return this.selectNetworkKeyFromNetworks(currencyCode, networkCode, indexedNetworkEntries, true);
    }

    public virtual object selectNetworkIdFromRawNetworks(object currencyCode, object networkCode, object indexedNetworkEntries)
    {
        return this.selectNetworkKeyFromNetworks(currencyCode, networkCode, indexedNetworkEntries, false);
    }

    public virtual object selectNetworkKeyFromNetworks(object currencyCode, object networkCode, object indexedNetworkEntries, object isIndexedByUnifiedNetworkCode = null)
    {
        // this method is used against raw & unparse network entries, which are just indexed by network id
        isIndexedByUnifiedNetworkCode ??= false;
        object chosenNetworkId = null;
        object availableNetworkIds = new List<object>(((Dictionary<string,object>)indexedNetworkEntries).Keys);
        object responseNetworksLength = getArrayLength(availableNetworkIds);
        if (isTrue(!isEqual(networkCode, null)))
        {
            if (isTrue(isEqual(responseNetworksLength, 0)))
            {
                throw new NotSupported ((string)add(add(add(add(this.id, " - "), networkCode), " network did not return any result for "), currencyCode)) ;
            } else
            {
                // if networkCode was provided by user, we should check it after response, as the referenced exchange doesn't support network-code during request
                object networkId = ((bool) isTrue(isIndexedByUnifiedNetworkCode)) ? networkCode : this.networkCodeToId(networkCode, currencyCode);
                if (isTrue(inOp(indexedNetworkEntries, networkId)))
                {
                    chosenNetworkId = networkId;
                } else
                {
                    throw new NotSupported ((string)add(add(add(add(add(add(this.id, " - "), networkId), " network was not found for "), currencyCode), ", use one of "), String.Join(", ", ((List<object>)availableNetworkIds).ToArray()))) ;
                }
            }
        } else
        {
            if (isTrue(isEqual(responseNetworksLength, 0)))
            {
                throw new NotSupported ((string)add(add(this.id, " - no networks were returned for "), currencyCode)) ;
            } else
            {
                // if networkCode was not provided by user, then we try to use the default network (if it was defined in "defaultNetworks"), otherwise, we just return the first network entry
                object defaultNetworkCode = this.defaultNetworkCode(currencyCode);
                object defaultNetworkId = ((bool) isTrue(isIndexedByUnifiedNetworkCode)) ? defaultNetworkCode : this.networkCodeToId(defaultNetworkCode, currencyCode);
                chosenNetworkId = ((bool) isTrue((inOp(indexedNetworkEntries, defaultNetworkId)))) ? defaultNetworkId : getValue(availableNetworkIds, 0);
            }
        }
        return chosenNetworkId;
    }

    public virtual object safeNumber2(object dictionary, object key1, object key2, object d = null)
    {
        object value = this.safeString2(dictionary, key1, key2);
        return this.parseNumber(value, d);
    }

    public virtual object parseOrderBook(object orderbook, object symbol, object timestamp = null, object bidsKey = null, object asksKey = null, object priceKey = null, object amountKey = null)
    {
        bidsKey ??= "bids";
        asksKey ??= "asks";
        priceKey ??= 0;
        amountKey ??= 1;
        object bids = this.parseBidsAsks(this.safeValue(orderbook, bidsKey, new List<object>() {}), priceKey, amountKey);
        object asks = this.parseBidsAsks(this.safeValue(orderbook, asksKey, new List<object>() {}), priceKey, amountKey);
        return ((object)new Dictionary<string, object>() {
            { "symbol", symbol },
            { "bids", this.sortBy(bids, 0, true) },
            { "asks", this.sortBy(asks, 0) },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "nonce", null },
        });
    }

    public virtual object parseOHLCVs(object ohlcvs, object market = null, object timeframe = null, object since = null, object limit = null)
    {
        timeframe ??= "1m";
        object results = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(ohlcvs)); postFixIncrement(ref i))
        {
            ((List<object>)results).Add(this.parseOHLCV(getValue(ohlcvs, i), market));
        }
        object sorted = this.sortBy(results, 0);
        return ((object)this.filterBySinceLimit(sorted, since, limit, 0));
    }

    public virtual object parseLeverageTiers(object response, object symbols = null, object marketIdKey = null)
    {
        // marketIdKey should only be undefined when response is a dictionary
        symbols = this.marketSymbols(symbols);
        object tiers = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object item = getValue(response, i);
            object id = this.safeString(item, marketIdKey);
            object market = this.safeMarket(id, null, null, this.safeString(this.options, "defaultType"));
            object symbol = getValue(market, "symbol");
            object contract = this.safeValue(market, "contract", false);
            if (isTrue(isTrue(contract) && isTrue((isTrue((isEqual(symbols, null))) || isTrue(this.inArray(symbol, symbols))))))
            {
                ((Dictionary<string, object>)tiers)[(string)symbol] = this.parseMarketLeverageTiers(item, market);
            }
        }
        return tiers;
    }

    public async virtual Task<object> loadTradingLimits(object symbols = null, object reload = null, object parameters = null)
    {
        reload ??= false;
        parameters ??= new Dictionary<string, object>();
        if (isTrue(getValue(this.has, "fetchTradingLimits")))
        {
            if (isTrue(isTrue(reload) || !isTrue((inOp(this.options, "limitsLoaded")))))
            {
                object response = await this.fetchTradingLimits(symbols);
                for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
                {
                    object symbol = getValue(symbols, i);
                    ((Dictionary<string, object>)this.markets)[(string)symbol] = this.deepExtend(getValue(this.markets, symbol), getValue(response, symbol));
                }
                ((Dictionary<string, object>)this.options)["limitsLoaded"] = this.milliseconds();
            }
        }
        return this.markets;
    }

    public virtual object safePosition(object position)
    {
        // simplified version of: /pull/12765/
        object unrealizedPnlString = this.safeString(position, "unrealisedPnl");
        object initialMarginString = this.safeString(position, "initialMargin");
        //
        // PERCENTAGE
        //
        object percentage = this.safeValue(position, "percentage");
        if (isTrue(isTrue(isTrue((isEqual(percentage, null))) && isTrue((!isEqual(unrealizedPnlString, null)))) && isTrue((!isEqual(initialMarginString, null)))))
        {
            // as it was done in all implementations ( aax, btcex, bybit, deribit, ftx, gate, kucoinfutures, phemex )
            object percentageString = Precise.stringMul(Precise.stringDiv(unrealizedPnlString, initialMarginString, 4), "100");
            ((Dictionary<string, object>)position)["percentage"] = this.parseNumber(percentageString);
        }
        return ((object)position);
    }

    public virtual object parsePositions(object positions, object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        symbols = this.marketSymbols(symbols);
        positions = this.toArray(positions);
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(positions)); postFixIncrement(ref i))
        {
            object position = this.extend(this.parsePosition(getValue(positions, i), null), parameters);
            ((List<object>)result).Add(position);
        }
        return this.filterByArrayPositions(result, "symbol", symbols, false);
    }

    public virtual object parseAccounts(object accounts, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        accounts = this.toArray(accounts);
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(accounts)); postFixIncrement(ref i))
        {
            object account = this.extend(this.parseAccount(getValue(accounts, i)), parameters);
            ((List<object>)result).Add(account);
        }
        return result;
    }

    public virtual object parseTrades(object trades, object market = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        trades = this.toArray(trades);
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(trades)); postFixIncrement(ref i))
        {
            object trade = this.extend(this.parseTrade(getValue(trades, i), market), parameters);
            ((List<object>)result).Add(trade);
        }
        result = this.sortBy2(result, "timestamp", "id");
        object symbol = ((bool) isTrue((!isEqual(market, null)))) ? getValue(market, "symbol") : null;
        return this.filterBySymbolSinceLimit(result, symbol, since, limit);
    }

    public virtual object parseTransactions(object transactions, object currency = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        transactions = this.toArray(transactions);
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(transactions)); postFixIncrement(ref i))
        {
            object transaction = this.extend(this.parseTransaction(getValue(transactions, i), currency), parameters);
            ((List<object>)result).Add(transaction);
        }
        result = this.sortBy(result, "timestamp");
        object code = ((bool) isTrue((!isEqual(currency, null)))) ? getValue(currency, "code") : null;
        return this.filterByCurrencySinceLimit(result, code, since, limit);
    }

    public virtual object parseTransfers(object transfers, object currency = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        transfers = this.toArray(transfers);
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(transfers)); postFixIncrement(ref i))
        {
            object transfer = this.extend(this.parseTransfer(getValue(transfers, i), currency), parameters);
            ((List<object>)result).Add(transfer);
        }
        result = this.sortBy(result, "timestamp");
        object code = ((bool) isTrue((!isEqual(currency, null)))) ? getValue(currency, "code") : null;
        return this.filterByCurrencySinceLimit(result, code, since, limit);
    }

    public virtual object parseLedger(object data, object currency = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object result = new List<object>() {};
        object arrayData = this.toArray(data);
        for (object i = 0; isLessThan(i, getArrayLength(arrayData)); postFixIncrement(ref i))
        {
            object itemOrItems = this.parseLedgerEntry(getValue(arrayData, i), currency);
            if (isTrue((itemOrItems.GetType().IsGenericType && itemOrItems.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))
            {
                for (object j = 0; isLessThan(j, getArrayLength(itemOrItems)); postFixIncrement(ref j))
                {
                    ((List<object>)result).Add(this.extend(getValue(itemOrItems, j), parameters));
                }
            } else
            {
                ((List<object>)result).Add(this.extend(itemOrItems, parameters));
            }
        }
        result = this.sortBy(result, "timestamp");
        object code = ((bool) isTrue((!isEqual(currency, null)))) ? getValue(currency, "code") : null;
        return this.filterByCurrencySinceLimit(result, code, since, limit);
    }

    public virtual object nonce()
    {
        return this.seconds();
    }

    public virtual object setHeaders(object headers)
    {
        return headers;
    }

    public virtual object marketId(object symbol)
    {
        object market = this.market(symbol);
        if (isTrue(!isEqual(market, null)))
        {
            return getValue(market, "id");
        }
        return symbol;
    }

    public virtual object symbol(object symbol)
    {
        object market = this.market(symbol);
        return this.safeString(market, "symbol", symbol);
    }

    public virtual object resolvePath(object path, object parameters)
    {
        return new List<object> {this.implodeParams(path, parameters), this.omit(parameters, this.extractParams(path))};
    }

    public virtual object filterByArray(object objects, object key, object values = null, object indexed = null)
    {
        indexed ??= true;
        objects = this.toArray(objects);
        // return all of them if no values were passed
        if (isTrue(isTrue(isEqual(values, null)) || !isTrue(values)))
        {
            return ((bool) isTrue(indexed)) ? this.indexBy(objects, key) : objects;
        }
        object results = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(objects)); postFixIncrement(ref i))
        {
            if (isTrue(this.inArray(getValue(getValue(objects, i), key), values)))
            {
                ((List<object>)results).Add(getValue(objects, i));
            }
        }
        return ((bool) isTrue(indexed)) ? this.indexBy(results, key) : results;
    }

    public async virtual Task<object> fetch2(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null, object config = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        config ??= new Dictionary<string, object>();
        if (isTrue(this.enableRateLimit))
        {
            object cost = this.calculateRateLimiterCost(api, method, path, parameters, config);
            await this.throttle(cost);
        }
        this.lastRestRequestTimestamp = this.milliseconds();
        object request = this.sign(path, api, method, parameters, headers, body);
        return await this.fetch(getValue(request, "url"), getValue(request, "method"), getValue(request, "headers"), getValue(request, "body"));
    }

    public async virtual Task<object> request(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null, object config = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        config ??= new Dictionary<string, object>();
        return await this.fetch2(path, api, method, parameters, headers, body, config);
    }

    public async virtual Task<object> loadAccounts(object reload = null, object parameters = null)
    {
        reload ??= false;
        parameters ??= new Dictionary<string, object>();
        if (isTrue(reload))
        {
            this.accounts = await this.fetchAccounts(parameters);
        } else
        {
            if (isTrue(this.accounts))
            {
                return this.accounts;
            } else
            {
                this.accounts = await this.fetchAccounts(parameters);
            }
        }
        this.accountsById = ((object)this.indexBy(this.accounts, "id"));
        return this.accounts;
    }

    public virtual object buildOHLCVC(object trades, object timeframe = null, object since = null, object limit = null)
    {
        // given a sorted arrays of trades (recent last) and a timeframe builds an array of OHLCV candles
        // note, default limit value (2147483647) is max int32 value
        timeframe ??= "1m";
        since ??= 0;
        limit ??= 2147483647;
        object ms = multiply(this.parseTimeframe(timeframe), 1000);
        object ohlcvs = new List<object>() {};
        object i_timestamp = 0;
        // const open = 1;
        object i_high = 2;
        object i_low = 3;
        object i_close = 4;
        object i_volume = 5;
        object i_count = 6;
        object tradesLength = getArrayLength(trades);
        object oldest = mathMin(tradesLength, limit);
        for (object i = 0; isLessThan(i, oldest); postFixIncrement(ref i))
        {
            object trade = getValue(trades, i);
            object ts = getValue(trade, "timestamp");
            if (isTrue(isLessThan(ts, since)))
            {
                continue;
            }
            object openingTime = multiply((Math.Floor(Double.Parse((divide(ts, ms)).ToString()))), ms); // shift to the edge of m/h/d (but not M)
            if (isTrue(isLessThan(openingTime, since)))
            {
                continue;
            }
            object ohlcv_length = getArrayLength(ohlcvs);
            object candle = subtract(ohlcv_length, 1);
            if (isTrue(isTrue((isEqual(candle, -1))) || isTrue((isGreaterThanOrEqual(openingTime, this.sum(getValue(getValue(ohlcvs, candle), i_timestamp), ms))))))
            {
                // moved to a new timeframe -> create a new candle from opening trade
                ((List<object>)ohlcvs).Add(new List<object>() {openingTime, getValue(trade, "price"), getValue(trade, "price"), getValue(trade, "price"), getValue(trade, "price"), getValue(trade, "amount"), 1});
            } else
            {
                // still processing the same timeframe -> update opening trade
                ((List<object>)getValue(ohlcvs, candle))[(int)i_high] = mathMax(getValue(getValue(ohlcvs, candle), i_high), getValue(trade, "price"));
                ((List<object>)getValue(ohlcvs, candle))[(int)i_low] = mathMin(getValue(getValue(ohlcvs, candle), i_low), getValue(trade, "price"));
                ((List<object>)getValue(ohlcvs, candle))[(int)i_close] = getValue(trade, "price");
                ((List<object>)getValue(ohlcvs, candle))[(int)i_volume] = this.sum(getValue(getValue(ohlcvs, candle), i_volume), getValue(trade, "amount"));
                ((List<object>)getValue(ohlcvs, candle))[(int)i_count] = this.sum(getValue(getValue(ohlcvs, candle), i_count), 1);
            }
        }
        return ohlcvs;
    }

    public virtual object parseTradingViewOHLCV(object ohlcvs, object market = null, object timeframe = null, object since = null, object limit = null)
    {
        timeframe ??= "1m";
        object result = this.convertTradingViewToOHLCV(ohlcvs);
        return this.parseOHLCVs(result, market, timeframe, since, limit);
    }

    public async virtual Task<object> editLimitBuyOrder(object id, object symbol, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.editLimitOrder(id, symbol, "buy", amount, price, parameters);
    }

    public async virtual Task<object> editLimitSellOrder(object id, object symbol, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.editLimitOrder(id, symbol, "sell", amount, price, parameters);
    }

    public async virtual Task<object> editLimitOrder(object id, object symbol, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.editOrder(id, symbol, "limit", side, amount, price, parameters);
    }

    public async virtual Task<object> editOrder(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.cancelOrder(id, symbol);
        return await this.createOrder(symbol, type, side, amount, price, parameters);
    }

    public async virtual Task<object> editOrderWs(object id, object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.cancelOrderWs(id, symbol);
        return await this.createOrderWs(symbol, type, side, amount, price, parameters);
    }

    public async virtual Task<object> fetchPermissions(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchPermissions() is not supported yet")) ;
    }

    public async virtual Task<object> fetchPosition(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchPosition() is not supported yet")) ;
    }

    public async virtual Task<object> fetchPositionsBySymbol(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchPositionsBySymbol() is not supported yet")) ;
    }

    public async virtual Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchPositions() is not supported yet")) ;
    }

    public async virtual Task<object> fetchPositionsRisk(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchPositionsRisk() is not supported yet")) ;
    }

    public async virtual Task<object> fetchBidsAsks(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchBidsAsks() is not supported yet")) ;
    }

    public async virtual Task<object> fetchBorrowInterest(object code = null, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchBorrowInterest() is not supported yet")) ;
    }

    public async virtual Task<object> fetchOrderBooks(object symbols = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchOrderBooks() is not supported yet")) ;
    }

    public async virtual Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchFundingRateHistory() is not supported yet")) ;
    }

    public async virtual Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchLedger() is not supported yet")) ;
    }

    public async virtual Task<object> fetchLedgerEntry(object id, object code = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchLedgerEntry() is not supported yet")) ;
    }

    public virtual object parseBidAsk(object bidask, object priceKey = null, object amountKey = null)
    {
        priceKey ??= 0;
        amountKey ??= 1;
        object price = this.safeNumber(bidask, priceKey);
        object amount = this.safeNumber(bidask, amountKey);
        return new List<object>() {price, amount};
    }

    public virtual object safeCurrency(object currencyId, object currency = null)
    {
        if (isTrue(isTrue(isEqual(currencyId, null)) && isTrue(isEqual(currency, null))))
        {
            return new Dictionary<string, object>() {
                { "id", null },
                { "code", null },
            };
        }
        if (isTrue(isTrue((isEqual(currencyId, null))) && isTrue((!isEqual(currency, null)))))
        {
            return currency;
        }
        if (isTrue(isTrue(isTrue((!isEqual(this.currencies_by_id, null))) && isTrue((inOp(this.currencies_by_id, currencyId)))) && isTrue((!isEqual(getValue(this.currencies_by_id, currencyId), null)))))
        {
            return getValue(this.currencies_by_id, currencyId);
        }
        object code = currencyId;
        if (isTrue(!isEqual(currencyId, null)))
        {
            code = this.commonCurrencyCode(((string)currencyId).ToUpper());
        }
        return new Dictionary<string, object>() {
            { "id", currencyId },
            { "code", code },
        };
    }

    public virtual object safeMarket(object marketId = null, object market = null, object delimiter = null, object marketType = null)
    {
        object result = new Dictionary<string, object>() {
            { "id", marketId },
            { "symbol", marketId },
            { "base", null },
            { "quote", null },
            { "baseId", null },
            { "quoteId", null },
            { "active", null },
            { "type", null },
            { "linear", null },
            { "inverse", null },
            { "spot", false },
            { "swap", false },
            { "future", false },
            { "option", false },
            { "margin", false },
            { "contract", false },
            { "contractSize", null },
            { "expiry", null },
            { "expiryDatetime", null },
            { "optionType", null },
            { "strike", null },
            { "settle", null },
            { "settleId", null },
            { "precision", new Dictionary<string, object>() {
                { "amount", null },
                { "price", null },
            } },
            { "limits", new Dictionary<string, object>() {
                { "amount", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
            } },
            { "info", null },
        };
        if (isTrue(!isEqual(marketId, null)))
        {
            if (isTrue(isTrue((!isEqual(this.markets_by_id, null))) && isTrue((inOp(this.markets_by_id, marketId)))))
            {
                object markets = getValue(this.markets_by_id, marketId);
                object numMarkets = getArrayLength(markets);
                if (isTrue(isEqual(numMarkets, 1)))
                {
                    return getValue(markets, 0);
                } else
                {
                    if (isTrue(isTrue((isEqual(marketType, null))) && isTrue((isEqual(market, null)))))
                    {
                        throw new ArgumentsRequired ((string)add(add(add(this.id, " safeMarket() requires a fourth argument for "), marketId), " to disambiguate between different markets with the same market id")) ;
                    }
                    object inferredMarketType = ((bool) isTrue((isEqual(marketType, null)))) ? getValue(market, "type") : marketType;
                    for (object i = 0; isLessThan(i, getArrayLength(markets)); postFixIncrement(ref i))
                    {
                        object marketInner = getValue(markets, i);
                        if (isTrue(getValue(marketInner, inferredMarketType)))
                        {
                            return marketInner;
                        }
                    }
                }
            } else if (isTrue(!isEqual(delimiter, null)))
            {
                object parts = ((string)marketId).Split(new [] {((string)delimiter)}, StringSplitOptions.None).ToList<object>();
                object partsLength = getArrayLength(parts);
                if (isTrue(isEqual(partsLength, 2)))
                {
                    ((Dictionary<string, object>)result)["baseId"] = this.safeString(parts, 0);
                    ((Dictionary<string, object>)result)["quoteId"] = this.safeString(parts, 1);
                    ((Dictionary<string, object>)result)["base"] = this.safeCurrencyCode(getValue(result, "baseId"));
                    ((Dictionary<string, object>)result)["quote"] = this.safeCurrencyCode(getValue(result, "quoteId"));
                    ((Dictionary<string, object>)result)["symbol"] = add(add(getValue(result, "base"), "/"), getValue(result, "quote"));
                    return result;
                } else
                {
                    return result;
                }
            }
        }
        if (isTrue(!isEqual(market, null)))
        {
            return market;
        }
        return result;
    }

    public virtual object checkRequiredCredentials(object error = null)
    {
        error ??= true;
        object keys = new List<object>(((Dictionary<string,object>)this.requiredCredentials).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object key = getValue(keys, i);
            if (isTrue(isTrue(getValue(this.requiredCredentials, key)) && !isTrue(getValue(this, key))))
            {
                if (isTrue(error))
                {
                    throw new AuthenticationError ((string)add(add(add(this.id, " requires \""), key), "\" credential")) ;
                } else
                {
                    return false;
                }
            }
        }
        return true;
    }

    public virtual object oath()
    {
        if (isTrue(!isEqual(this.twofa, null)))
        {
            return totp(this.twofa);
        } else
        {
            throw new ExchangeError ((string)add(this.id, " exchange.twofa has not been set for 2FA Two-Factor Authentication")) ;
        }
    }

    public async virtual Task<object> fetchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchBalance() is not supported yet")) ;
    }

    public async virtual Task<object> fetchBalanceWs(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchBalanceWs() is not supported yet")) ;
    }

    public virtual object parseBalance(object response)
    {
        throw new NotSupported ((string)add(this.id, " parseBalance() is not supported yet")) ;
    }

    public async virtual Task<object> watchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " watchBalance() is not supported yet")) ;
    }

    public async virtual Task<object> fetchPartialBalance(object part, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object balance = await this.fetchBalance(parameters);
        return getValue(balance, part);
    }

    public async virtual Task<object> fetchFreeBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.fetchPartialBalance("free", parameters);
    }

    public async virtual Task<object> fetchUsedBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.fetchPartialBalance("used", parameters);
    }

    public async virtual Task<object> fetchTotalBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.fetchPartialBalance("total", parameters);
    }

    public async virtual Task<object> fetchStatus(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(getValue(this.has, "fetchTime")))
        {
            object time = await this.fetchTime(parameters);
            this.status = this.extend(this.status, new Dictionary<string, object>() {
                { "updated", time },
                { "info", time },
            });
        }
        if (!isTrue((inOp(this.status, "info"))))
        {
            ((Dictionary<string, object>)this.status)["info"] = null;
        }
        return this.status;
    }

    public async virtual Task<object> fetchFundingFee(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object warnOnFetchFundingFee = this.safeValue(this.options, "warnOnFetchFundingFee", true);
        if (isTrue(warnOnFetchFundingFee))
        {
            throw new NotSupported ((string)add(this.id, " fetchFundingFee() method is deprecated, it will be removed in July 2022, please, use fetchTransactionFee() or set exchange.options[\"warnOnFetchFundingFee\"] = false to suppress this warning")) ;
        }
        return await this.fetchTransactionFee(code, parameters);
    }

    public async virtual Task<object> fetchFundingFees(object codes = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object warnOnFetchFundingFees = this.safeValue(this.options, "warnOnFetchFundingFees", true);
        if (isTrue(warnOnFetchFundingFees))
        {
            throw new NotSupported ((string)add(this.id, " fetchFundingFees() method is deprecated, it will be removed in July 2022. Please, use fetchTransactionFees() or set exchange.options[\"warnOnFetchFundingFees\"] = false to suppress this warning")) ;
        }
        return await this.fetchTransactionFees(codes, parameters);
    }

    public async virtual Task<object> fetchTransactionFee(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (!isTrue(getValue(this.has, "fetchTransactionFees")))
        {
            throw new NotSupported ((string)add(this.id, " fetchTransactionFee() is not supported yet")) ;
        }
        return await this.fetchTransactionFees(new List<object>() {code}, parameters);
    }

    public async virtual Task<object> fetchTransactionFees(object codes = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchTransactionFees() is not supported yet")) ;
    }

    public async virtual Task<object> fetchDepositWithdrawFees(object codes = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchDepositWithdrawFees() is not supported yet")) ;
    }

    public async virtual Task<object> fetchDepositWithdrawFee(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (!isTrue(getValue(this.has, "fetchDepositWithdrawFees")))
        {
            throw new NotSupported ((string)add(this.id, " fetchDepositWithdrawFee() is not supported yet")) ;
        }
        object fees = await this.fetchDepositWithdrawFees(new List<object>() {code}, parameters);
        return this.safeValue(fees, code);
    }

    public virtual object getSupportedMapping(object key, object mapping = null)
    {
        mapping ??= new Dictionary<string, object>();
        if (isTrue(inOp(mapping, key)))
        {
            return getValue(mapping, key);
        } else
        {
            throw new NotSupported ((string)add(add(add(this.id, " "), key), " does not have a value in mapping")) ;
        }
    }

    public async virtual Task<object> fetchBorrowRate(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        if (!isTrue(getValue(this.has, "fetchBorrowRates")))
        {
            throw new NotSupported ((string)add(this.id, " fetchBorrowRate() is not supported yet")) ;
        }
        object borrowRates = await this.fetchBorrowRates(parameters);
        object rate = this.safeValue(borrowRates, code);
        if (isTrue(isEqual(rate, null)))
        {
            throw new ExchangeError ((string)add(add(this.id, " fetchBorrowRate() could not find the borrow rate for currency code "), code)) ;
        }
        return rate;
    }

    public virtual object handleOptionAndParams(object parameters, object methodName, object optionName, object defaultValue = null)
    {
        // This method can be used to obtain method specific properties, i.e: this.handleOptionAndParams (params, 'fetchPosition', 'marginMode', 'isolated')
        object defaultOptionName = add("default", this.capitalize(optionName)); // we also need to check the 'defaultXyzWhatever'
        // check if params contain the key
        object value = this.safeValue2(parameters, optionName, defaultOptionName);
        if (isTrue(!isEqual(value, null)))
        {
            parameters = this.omit(parameters, new List<object>() {optionName, defaultOptionName});
        } else
        {
            // check if exchange has properties for this method
            object exchangeWideMethodOptions = this.safeValue(this.options, methodName);
            if (isTrue(!isEqual(exchangeWideMethodOptions, null)))
            {
                // check if the option is defined inside this method's props
                value = this.safeValue2(exchangeWideMethodOptions, optionName, defaultOptionName);
            }
            if (isTrue(isEqual(value, null)))
            {
                // if it's still undefined, check if global exchange-wide option exists
                value = this.safeValue2(this.options, optionName, defaultOptionName);
            }
            // if it's still undefined, use the default value
            value = ((bool) isTrue((!isEqual(value, null)))) ? value : defaultValue;
        }
        return new List<object>() {value, parameters};
    }

    public virtual object handleOption(object methodName, object optionName, object defaultValue = null)
    {
        // eslint-disable-next-line no-unused-vars
        var resultemptyVariable = this.handleOptionAndParams(new Dictionary<string, object>() {}, methodName, optionName, defaultValue);
        var result = ((List<object>) resultemptyVariable)[0];
        var empty = ((List<object>) resultemptyVariable)[1];
        return result;
    }

    public virtual object handleMarketTypeAndParams(object methodName, object market = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object defaultType = this.safeString2(this.options, "defaultType", "type", "spot");
        object methodOptions = this.safeValue(this.options, methodName);
        object methodType = defaultType;
        if (isTrue(!isEqual(methodOptions, null)))
        {
            if (isTrue(((methodOptions).GetType() == typeof(string))))
            {
                methodType = methodOptions;
            } else
            {
                methodType = this.safeString2(methodOptions, "defaultType", "type", methodType);
            }
        }
        object marketType = ((bool) isTrue((isEqual(market, null)))) ? methodType : getValue(market, "type");
        object type = this.safeString2(parameters, "defaultType", "type", marketType);
        parameters = this.omit(parameters, new List<object>() {"defaultType", "type"});
        return new List<object>() {type, parameters};
    }

    public virtual object handleSubTypeAndParams(object methodName, object market = null, object parameters = null, object defaultValue = null)
    {
        parameters ??= new Dictionary<string, object>();
        object subType = null;
        // if set in params, it takes precedence
        object subTypeInParams = this.safeString2(parameters, "subType", "defaultSubType");
        // avoid omitting if it's not present
        if (isTrue(!isEqual(subTypeInParams, null)))
        {
            subType = subTypeInParams;
            parameters = this.omit(parameters, new List<object>() {"subType", "defaultSubType"});
        } else
        {
            // at first, check from market object
            if (isTrue(!isEqual(market, null)))
            {
                if (isTrue(getValue(market, "linear")))
                {
                    subType = "linear";
                } else if (isTrue(getValue(market, "inverse")))
                {
                    subType = "inverse";
                }
            }
            // if it was not defined in market object
            if (isTrue(isEqual(subType, null)))
            {
                object values = this.handleOptionAndParams(null, methodName, "subType", defaultValue); // no need to re-test params here
                subType = getValue(values, 0);
            }
        }
        return new List<object>() {subType, parameters};
    }

    public virtual object handleMarginModeAndParams(object methodName, object parameters = null, object defaultValue = null)
    {
        /**
        * @ignore
        * @method
        * @param {object} [params] extra parameters specific to the exchange api endpoint
        * @returns {Array} the marginMode in lowercase as specified by params["marginMode"], params["defaultMarginMode"] this.options["marginMode"] or this.options["defaultMarginMode"]
        */
        parameters ??= new Dictionary<string, object>();
        return this.handleOptionAndParams(parameters, methodName, "marginMode", defaultValue);
    }

    public virtual void throwExactlyMatchedException(object exact, object str, object message)
    {
        if (isTrue(isEqual(str, null)))
        {
            return;
        }
        if (isTrue(inOp(exact, str)))
        {
            throwDynamicException(getValue(exact, str), message);
        }
    }

    public virtual void throwBroadlyMatchedException(object broad, object str, object message)
    {
        object broadKey = this.findBroadlyMatchedKey(broad, str);
        if (isTrue(!isEqual(broadKey, null)))
        {
            throwDynamicException(getValue(broad, broadKey), message);
        }
    }

    public virtual object findBroadlyMatchedKey(object broad, object str)
    {
        // a helper for matching error strings exactly vs broadly
        object keys = new List<object>(((Dictionary<string,object>)broad).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object key = getValue(keys, i);
            if (isTrue(!isEqual(str, null)))
            {
                if (isTrue(isGreaterThanOrEqual(getIndexOf(str, key), 0)))
                {
                    return key;
                }
            }
        }
        return null;
    }

    public virtual object handleErrors(object statusCode, object statusText, object url, object method, object responseHeaders, object responseBody, object response, object requestHeaders, object requestBody)
    {
        // it is a stub method that must be overrided in the derived exchange classes
        // throw new NotSupported (this.id + ' handleErrors() not implemented yet');
        return null;
    }

    public virtual object calculateRateLimiterCost(object api, object method, object path, object parameters, object config = null)
    {
        config ??= new Dictionary<string, object>();
        return this.safeValue(config, "cost", 1);
    }

    public async virtual Task<object> fetchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(getValue(this.has, "fetchTickers")))
        {
            await this.loadMarkets();
            object market = this.market(symbol);
            symbol = getValue(market, "symbol");
            object tickers = await this.fetchTickers(new List<object>() {symbol}, parameters);
            object ticker = this.safeValue(tickers, symbol);
            if (isTrue(isEqual(ticker, null)))
            {
                throw new NullResponse ((string)add(add(this.id, " fetchTickers() could not find a ticker for "), symbol)) ;
            } else
            {
                return ticker;
            }
        } else
        {
            throw new NotSupported ((string)add(this.id, " fetchTicker() is not supported yet")) ;
        }
    }

    public async virtual Task<object> watchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " watchTicker() is not supported yet")) ;
    }

    public async virtual Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchTickers() is not supported yet")) ;
    }

    public async virtual Task<object> watchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " watchTickers() is not supported yet")) ;
    }

    public async virtual Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchOrder() is not supported yet")) ;
    }

    public async virtual Task<object> fetchOrderWs(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchOrderWs() is not supported yet")) ;
    }

    public async virtual Task<object> fetchOrderStatus(object id, object symbol = null, object parameters = null)
    {
        // TODO: TypeScript: change method signature by replacing
        // Promise<string> with Promise<Order['status']>.
        parameters ??= new Dictionary<string, object>();
        object order = await this.fetchOrder(id, symbol, parameters);
        return getValue(order, "status");
    }

    public async virtual Task<object> fetchUnifiedOrder(object order, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.fetchOrder(this.safeValue(order, "id"), this.safeValue(order, "symbol"), parameters);
    }

    public async virtual Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " createOrder() is not supported yet")) ;
    }

    public async virtual Task<object> createOrderWs(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " createOrderWs() is not supported yet")) ;
    }

    public async virtual Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " cancelOrder() is not supported yet")) ;
    }

    public async virtual Task<object> cancelOrderWs(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " cancelOrderWs() is not supported yet")) ;
    }

    public async virtual Task<object> cancelOrdersWs(object ids, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " cancelOrdersWs() is not supported yet")) ;
    }

    public async virtual Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " cancelAllOrders() is not supported yet")) ;
    }

    public async virtual Task<object> cancelAllOrdersWs(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " cancelAllOrdersWs() is not supported yet")) ;
    }

    public async virtual Task<object> cancelUnifiedOrder(object order, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return this.cancelOrder(this.safeValue(order, "id"), this.safeValue(order, "symbol"), parameters);
    }

    public async virtual Task<object> fetchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchOrders() is not supported yet")) ;
    }

    public async virtual Task<object> fetchOrderTrades(object id, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchOrderTrades() is not supported yet")) ;
    }

    public async virtual Task<object> watchOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " watchOrders() is not supported yet")) ;
    }

    public async virtual Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchOpenOrders() is not supported yet")) ;
    }

    public async virtual Task<object> fetchOpenOrdersWs(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchOpenOrdersWs() is not supported yet")) ;
    }

    public async virtual Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchClosedOrders() is not supported yet")) ;
    }

    public async virtual Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchMyTrades() is not supported yet")) ;
    }

    public async virtual Task<object> fetchMyTradesWs(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchMyTradesWs() is not supported yet")) ;
    }

    public async virtual Task<object> watchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " watchMyTrades() is not supported yet")) ;
    }

    public async virtual Task<object> fetchOHLCVWs(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchOHLCVWs() is not supported yet")) ;
    }

    public async virtual Task<object> fetchDepositsWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchDepositsWithdrawals() is not supported yet")) ;
    }

    public async virtual Task<object> fetchDeposits(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchDeposits() is not supported yet")) ;
    }

    public async virtual Task<object> fetchWithdrawals(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchWithdrawals() is not supported yet")) ;
    }

    public virtual object parseLastPrice(object price, object market = null)
    {
        throw new NotSupported ((string)add(this.id, " parseLastPrice() is not supported yet")) ;
    }

    public async virtual Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(getValue(this.has, "fetchDepositAddresses")))
        {
            object depositAddresses = await this.fetchDepositAddresses(new List<object>() {code}, parameters);
            object depositAddress = this.safeValue(depositAddresses, code);
            if (isTrue(isEqual(depositAddress, null)))
            {
                throw new InvalidAddress ((string)add(add(add(this.id, " fetchDepositAddress() could not find a deposit address for "), code), ", make sure you have created a corresponding deposit address in your wallet on the exchange website")) ;
            } else
            {
                return depositAddress;
            }
        } else
        {
            throw new NotSupported ((string)add(this.id, " fetchDepositAddress() is not supported yet")) ;
        }
    }

    public virtual object account()
    {
        return new Dictionary<string, object>() {
            { "free", null },
            { "used", null },
            { "total", null },
        };
    }

    public virtual object commonCurrencyCode(object currency)
    {
        if (!isTrue(this.substituteCommonCurrencyCodes))
        {
            return currency;
        }
        return this.safeString(this.commonCurrencies, currency, currency);
    }

    public virtual object currency(object code)
    {
        if (isTrue(isEqual(this.currencies, null)))
        {
            throw new ExchangeError ((string)add(this.id, " currencies not loaded")) ;
        }
        if (isTrue(((code).GetType() == typeof(string))))
        {
            if (isTrue(inOp(this.currencies, code)))
            {
                return getValue(this.currencies, code);
            } else if (isTrue(inOp(this.currencies_by_id, code)))
            {
                return getValue(this.currencies_by_id, code);
            }
        }
        throw new ExchangeError ((string)add(add(this.id, " does not have currency code "), code)) ;
    }

    public virtual object market(object symbol)
    {
        if (isTrue(isEqual(this.markets, null)))
        {
            throw new ExchangeError ((string)add(this.id, " markets not loaded")) ;
        }
        if (isTrue(((symbol).GetType() == typeof(string))))
        {
            if (isTrue(inOp(this.markets, symbol)))
            {
                return getValue(this.markets, symbol);
            } else if (isTrue(inOp(this.markets_by_id, symbol)))
            {
                object markets = getValue(this.markets_by_id, symbol);
                object defaultType = this.safeString2(this.options, "defaultType", "defaultSubType", "spot");
                for (object i = 0; isLessThan(i, getArrayLength(markets)); postFixIncrement(ref i))
                {
                    object market = getValue(markets, i);
                    if (isTrue(getValue(market, defaultType)))
                    {
                        return market;
                    }
                }
                return getValue(markets, 0);
            }
        }
        throw new BadSymbol ((string)add(add(this.id, " does not have market symbol "), symbol)) ;
    }

    public virtual object handleWithdrawTagAndParams(object tag, object parameters)
    {
        if (isTrue(((tag).GetType() == typeof(Dictionary<string, object>))))
        {
            parameters = this.extend(tag, parameters);
            tag = null;
        }
        if (isTrue(isEqual(tag, null)))
        {
            tag = this.safeString(parameters, "tag");
            if (isTrue(!isEqual(tag, null)))
            {
                parameters = this.omit(parameters, "tag");
            }
        }
        return new List<object>() {tag, parameters};
    }

    public async virtual Task<object> createLimitOrder(object symbol, object side, object amount, object price, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.createOrder(symbol, "limit", side, amount, price, parameters);
    }

    public async virtual Task<object> createMarketOrder(object symbol, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.createOrder(symbol, "market", side, amount, price, parameters);
    }

    public async virtual Task<object> createLimitBuyOrder(object symbol, object amount, object price, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.createOrder(symbol, "limit", "buy", amount, price, parameters);
    }

    public async virtual Task<object> createLimitSellOrder(object symbol, object amount, object price, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.createOrder(symbol, "limit", "sell", amount, price, parameters);
    }

    public async virtual Task<object> createMarketBuyOrder(object symbol, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.createOrder(symbol, "market", "buy", amount, null, parameters);
    }

    public async virtual Task<object> createMarketSellOrder(object symbol, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.createOrder(symbol, "market", "sell", amount, null, parameters);
    }

    public virtual object costToPrecision(object symbol, object cost)
    {
        object market = this.market(symbol);
        return this.decimalToPrecision(cost, TRUNCATE, getValue(getValue(market, "precision"), "price"), this.precisionMode, this.paddingMode);
    }

    public virtual object priceToPrecision(object symbol, object price)
    {
        object market = this.market(symbol);
        object result = this.decimalToPrecision(price, ROUND, getValue(getValue(market, "precision"), "price"), this.precisionMode, this.paddingMode);
        if (isTrue(isEqual(result, "0")))
        {
            throw new InvalidOrder ((string)add(add(add(add(this.id, " price of "), getValue(market, "symbol")), " must be greater than minimum price precision of "), this.numberToString(getValue(getValue(market, "precision"), "price")))) ;
        }
        return result;
    }

    public virtual object amountToPrecision(object symbol, object amount)
    {
        object market = this.market(symbol);
        object result = this.decimalToPrecision(amount, TRUNCATE, getValue(getValue(market, "precision"), "amount"), this.precisionMode, this.paddingMode);
        if (isTrue(isEqual(result, "0")))
        {
            throw new InvalidOrder ((string)add(add(add(add(this.id, " amount of "), getValue(market, "symbol")), " must be greater than minimum amount precision of "), this.numberToString(getValue(getValue(market, "precision"), "amount")))) ;
        }
        return result;
    }

    public virtual object feeToPrecision(object symbol, object fee)
    {
        object market = this.market(symbol);
        return this.decimalToPrecision(fee, ROUND, getValue(getValue(market, "precision"), "price"), this.precisionMode, this.paddingMode);
    }

    public virtual object currencyToPrecision(object code, object fee, object networkCode = null)
    {
        object currency = getValue(this.currencies, code);
        object precision = this.safeValue(currency, "precision");
        if (isTrue(!isEqual(networkCode, null)))
        {
            object networks = this.safeValue(currency, "networks", new Dictionary<string, object>() {});
            object networkItem = this.safeValue(networks, networkCode, new Dictionary<string, object>() {});
            precision = this.safeValue(networkItem, "precision", precision);
        }
        if (isTrue(isEqual(precision, null)))
        {
            return this.forceString(fee);
        } else
        {
            return this.decimalToPrecision(fee, ROUND, precision, this.precisionMode, this.paddingMode);
        }
    }

    public virtual object forceString(object value)
    {
        if (isTrue(!((value).GetType() == typeof(string))))
        {
            return this.numberToString(value);
        }
        return value;
    }

    public virtual object isTickPrecision()
    {
        return isEqual(this.precisionMode, TICK_SIZE);
    }

    public virtual object isDecimalPrecision()
    {
        return isEqual(this.precisionMode, DECIMAL_PLACES);
    }

    public virtual object isSignificantPrecision()
    {
        return isEqual(this.precisionMode, SIGNIFICANT_DIGITS);
    }

    public virtual object safeNumber(object obj, object key, object defaultNumber = null)
    {
        object value = this.safeString(obj, key);
        return this.parseNumber(value, defaultNumber);
    }

    public virtual object safeNumberN(object obj, object arr, object defaultNumber = null)
    {
        object value = this.safeStringN(obj, arr);
        return this.parseNumber(value, defaultNumber);
    }

    public virtual object parsePrecision(object precision)
    {
        /**
         * @ignore
         * @method
         * @param {string} precision The number of digits to the right of the decimal
         * @returns {string} a string number equal to 1e-precision
         */
        if (isTrue(isEqual(precision, null)))
        {
            return null;
        }
        object precisionNumber = parseInt(precision);
        if (isTrue(isEqual(precisionNumber, 0)))
        {
            return "1";
        }
        object parsedPrecision = "0.";
        for (object i = 0; isLessThan(i, subtract(precisionNumber, 1)); postFixIncrement(ref i))
        {
            parsedPrecision = add(parsedPrecision, "0");
        }
        return add(parsedPrecision, "1");
    }

    public async virtual Task<object> loadTimeDifference(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object serverTime = await this.fetchTime(parameters);
        object after = this.milliseconds();
        ((Dictionary<string, object>)this.options)["timeDifference"] = subtract(after, serverTime);
        return getValue(this.options, "timeDifference");
    }

    public virtual object implodeHostname(object url)
    {
        return this.implodeParams(url, new Dictionary<string, object>() {
            { "hostname", this.hostname },
        });
    }

    public async virtual Task<object> fetchMarketLeverageTiers(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(getValue(this.has, "fetchLeverageTiers")))
        {
            object market = this.market(symbol);
            if (!isTrue(getValue(market, "contract")))
            {
                throw new BadSymbol ((string)add(this.id, " fetchMarketLeverageTiers() supports contract markets only")) ;
            }
            object tiers = await this.fetchLeverageTiers(new List<object>() {symbol});
            return this.safeValue(tiers, symbol);
        } else
        {
            throw new NotSupported ((string)add(this.id, " fetchMarketLeverageTiers() is not supported yet")) ;
        }
    }

    public async virtual Task<object> createPostOnlyOrder(object symbol, object type, object side, object amount, object price, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (!isTrue(getValue(this.has, "createPostOnlyOrder")))
        {
            throw new NotSupported ((string)add(this.id, "createPostOnlyOrder() is not supported yet")) ;
        }
        object query = this.extend(parameters, new Dictionary<string, object>() {
            { "postOnly", true },
        });
        return await this.createOrder(symbol, type, side, amount, price, query);
    }

    public async virtual Task<object> createReduceOnlyOrder(object symbol, object type, object side, object amount, object price, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (!isTrue(getValue(this.has, "createReduceOnlyOrder")))
        {
            throw new NotSupported ((string)add(this.id, "createReduceOnlyOrder() is not supported yet")) ;
        }
        object query = this.extend(parameters, new Dictionary<string, object>() {
            { "reduceOnly", true },
        });
        return await this.createOrder(symbol, type, side, amount, price, query);
    }

    public async virtual Task<object> createStopOrder(object symbol, object type, object side, object amount, object price = null, object stopPrice = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (!isTrue(getValue(this.has, "createStopOrder")))
        {
            throw new NotSupported ((string)add(this.id, " createStopOrder() is not supported yet")) ;
        }
        if (isTrue(isEqual(stopPrice, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " create_stop_order() requires a stopPrice argument")) ;
        }
        object query = this.extend(parameters, new Dictionary<string, object>() {
            { "stopPrice", stopPrice },
        });
        return await this.createOrder(symbol, type, side, amount, price, query);
    }

    public async virtual Task<object> createStopLimitOrder(object symbol, object side, object amount, object price, object stopPrice, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (!isTrue(getValue(this.has, "createStopLimitOrder")))
        {
            throw new NotSupported ((string)add(this.id, " createStopLimitOrder() is not supported yet")) ;
        }
        object query = this.extend(parameters, new Dictionary<string, object>() {
            { "stopPrice", stopPrice },
        });
        return await this.createOrder(symbol, "limit", side, amount, price, query);
    }

    public async virtual Task<object> createStopMarketOrder(object symbol, object side, object amount, object stopPrice, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (!isTrue(getValue(this.has, "createStopMarketOrder")))
        {
            throw new NotSupported ((string)add(this.id, " createStopMarketOrder() is not supported yet")) ;
        }
        object query = this.extend(parameters, new Dictionary<string, object>() {
            { "stopPrice", stopPrice },
        });
        return await this.createOrder(symbol, "market", side, amount, null, query);
    }

    public virtual object safeCurrencyCode(object currencyId, object currency = null)
    {
        currency = this.safeCurrency(currencyId, currency);
        return getValue(currency, "code");
    }

    public virtual object filterBySymbolSinceLimit(object array, object symbol = null, object since = null, object limit = null, object tail = null)
    {
        tail ??= false;
        return this.filterByValueSinceLimit(array, "symbol", symbol, since, limit, "timestamp", tail);
    }

    public virtual object filterByCurrencySinceLimit(object array, object code = null, object since = null, object limit = null, object tail = null)
    {
        tail ??= false;
        return this.filterByValueSinceLimit(array, "currency", code, since, limit, "timestamp", tail);
    }

    public virtual object parseLastPrices(object pricesData, object symbols = null, object parameters = null)
    {
        //
        // the value of tickers is either a dict or a list
        //
        // dict
        //
        //     {
        //         'marketId1': { ... },
        //         'marketId2': { ... },
        //         ...
        //     }
        //
        // list
        //
        //     [
        //         { 'market': 'marketId1', ... },
        //         { 'market': 'marketId2', ... },
        //         ...
        //     ]
        //
        parameters ??= new Dictionary<string, object>();
        object results = new List<object>() {};
        if (isTrue((pricesData.GetType().IsGenericType && pricesData.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))
        {
            for (object i = 0; isLessThan(i, getArrayLength(pricesData)); postFixIncrement(ref i))
            {
                object priceData = this.extend(this.parseLastPrice(getValue(pricesData, i)), parameters);
                ((List<object>)results).Add(priceData);
            }
        } else
        {
            object marketIds = new List<object>(((Dictionary<string,object>)pricesData).Keys);
            for (object i = 0; isLessThan(i, getArrayLength(marketIds)); postFixIncrement(ref i))
            {
                object marketId = getValue(marketIds, i);
                object market = this.safeMarket(marketId);
                object priceData = this.extend(this.parseLastPrice(getValue(pricesData, marketId), market), parameters);
                ((List<object>)results).Add(priceData);
            }
        }
        symbols = this.marketSymbols(symbols);
        return this.filterByArray(results, "symbol", symbols);
    }

    public virtual object parseTickers(object tickers, object symbols = null, object parameters = null)
    {
        //
        // the value of tickers is either a dict or a list
        //
        // dict
        //
        //     {
        //         'marketId1': { ... },
        //         'marketId2': { ... },
        //         'marketId3': { ... },
        //         ...
        //     }
        //
        // list
        //
        //     [
        //         { 'market': 'marketId1', ... },
        //         { 'market': 'marketId2', ... },
        //         { 'market': 'marketId3', ... },
        //         ...
        //     ]
        //
        parameters ??= new Dictionary<string, object>();
        object results = new List<object>() {};
        if (isTrue((tickers.GetType().IsGenericType && tickers.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))))
        {
            for (object i = 0; isLessThan(i, getArrayLength(tickers)); postFixIncrement(ref i))
            {
                object ticker = this.extend(this.parseTicker(getValue(tickers, i)), parameters);
                ((List<object>)results).Add(ticker);
            }
        } else
        {
            object marketIds = new List<object>(((Dictionary<string,object>)tickers).Keys);
            for (object i = 0; isLessThan(i, getArrayLength(marketIds)); postFixIncrement(ref i))
            {
                object marketId = getValue(marketIds, i);
                object market = this.safeMarket(marketId);
                object ticker = this.extend(this.parseTicker(getValue(tickers, marketId), market), parameters);
                ((List<object>)results).Add(ticker);
            }
        }
        symbols = this.marketSymbols(symbols);
        return this.filterByArray(results, "symbol", symbols);
    }

    public virtual object parseDepositAddresses(object addresses, object codes = null, object indexed = null, object parameters = null)
    {
        indexed ??= true;
        parameters ??= new Dictionary<string, object>();
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(addresses)); postFixIncrement(ref i))
        {
            object address = this.extend(this.parseDepositAddress(getValue(addresses, i)), parameters);
            ((List<object>)result).Add(address);
        }
        if (isTrue(!isEqual(codes, null)))
        {
            result = this.filterByArray(result, "currency", codes, false);
        }
        if (isTrue(indexed))
        {
            return this.indexBy(result, "currency");
        }
        return result;
    }

    public virtual object parseBorrowInterests(object response, object market = null)
    {
        object interests = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object row = getValue(response, i);
            ((List<object>)interests).Add(this.parseBorrowInterest(row, market));
        }
        return interests;
    }

    public virtual object parseFundingRateHistories(object response, object market = null, object since = null, object limit = null)
    {
        object rates = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object entry = getValue(response, i);
            ((List<object>)rates).Add(this.parseFundingRateHistory(entry, market));
        }
        object sorted = this.sortBy(rates, "timestamp");
        object symbol = ((bool) isTrue((isEqual(market, null)))) ? null : getValue(market, "symbol");
        return this.filterBySymbolSinceLimit(sorted, symbol, since, limit);
    }

    public virtual object safeSymbol(object marketId, object market = null, object delimiter = null, object marketType = null)
    {
        market = this.safeMarket(marketId, market, delimiter, marketType);
        return getValue(market, "symbol");
    }

    public virtual object parseFundingRate(object contract, object market = null)
    {
        throw new NotSupported ((string)add(this.id, " parseFundingRate() is not supported yet")) ;
    }

    public virtual object parseFundingRates(object response, object market = null)
    {
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object parsed = this.parseFundingRate(getValue(response, i), market);
            ((Dictionary<string, object>)result)[(string)getValue(parsed, "symbol")] = parsed;
        }
        return result;
    }

    public virtual object isTriggerOrder(object parameters)
    {
        object isTrigger = this.safeValue2(parameters, "trigger", "stop");
        if (isTrue(isTrigger))
        {
            parameters = this.omit(parameters, new List<object>() {"trigger", "stop"});
        }
        return new List<object>() {isTrigger, parameters};
    }

    public virtual object isPostOnly(object isMarketOrder, object exchangeSpecificParam, object parameters = null)
    {
        /**
        * @ignore
        * @method
        * @param {string} type Order type
        * @param {boolean} exchangeSpecificParam exchange specific postOnly
        * @param {object} [params] exchange specific params
        * @returns {boolean} true if a post only order, false otherwise
        */
        parameters ??= new Dictionary<string, object>();
        object timeInForce = this.safeStringUpper(parameters, "timeInForce");
        object postOnly = this.safeValue2(parameters, "postOnly", "post_only", false);
        // we assume timeInForce is uppercase from safeStringUpper (params, 'timeInForce')
        object ioc = isEqual(timeInForce, "IOC");
        object fok = isEqual(timeInForce, "FOK");
        object timeInForcePostOnly = isEqual(timeInForce, "PO");
        postOnly = isTrue(isTrue(postOnly) || isTrue(timeInForcePostOnly)) || isTrue(exchangeSpecificParam);
        if (isTrue(postOnly))
        {
            if (isTrue(isTrue(ioc) || isTrue(fok)))
            {
                throw new InvalidOrder ((string)add(add(this.id, " postOnly orders cannot have timeInForce equal to "), timeInForce)) ;
            } else if (isTrue(isMarketOrder))
            {
                throw new InvalidOrder ((string)add(this.id, " market orders cannot be postOnly")) ;
            } else
            {
                return true;
            }
        } else
        {
            return false;
        }
    }

    public virtual object handlePostOnly(object isMarketOrder, object exchangeSpecificPostOnlyOption, object parameters = null)
    {
        /**
        * @ignore
        * @method
        * @param {string} type Order type
        * @param {boolean} exchangeSpecificBoolean exchange specific postOnly
        * @param {object} [params] exchange specific params
        * @returns {Array}
        */
        parameters ??= new Dictionary<string, object>();
        object timeInForce = this.safeStringUpper(parameters, "timeInForce");
        object postOnly = this.safeValue(parameters, "postOnly", false);
        object ioc = isEqual(timeInForce, "IOC");
        object fok = isEqual(timeInForce, "FOK");
        object po = isEqual(timeInForce, "PO");
        postOnly = isTrue(isTrue(postOnly) || isTrue(po)) || isTrue(exchangeSpecificPostOnlyOption);
        if (isTrue(postOnly))
        {
            if (isTrue(isTrue(ioc) || isTrue(fok)))
            {
                throw new InvalidOrder ((string)add(add(this.id, " postOnly orders cannot have timeInForce equal to "), timeInForce)) ;
            } else if (isTrue(isMarketOrder))
            {
                throw new InvalidOrder ((string)add(this.id, " market orders cannot be postOnly")) ;
            } else
            {
                if (isTrue(po))
                {
                    parameters = this.omit(parameters, "timeInForce");
                }
                parameters = this.omit(parameters, "postOnly");
                return new List<object>() {true, parameters};
            }
        }
        return new List<object>() {false, parameters};
    }

    public async virtual Task<object> fetchLastPrices(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchLastPrices() is not supported yet")) ;
    }

    public async virtual Task<object> fetchTradingFees(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        throw new NotSupported ((string)add(this.id, " fetchTradingFees() is not supported yet")) ;
    }

    public async virtual Task<object> fetchTradingFee(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (!isTrue(getValue(this.has, "fetchTradingFees")))
        {
            throw new NotSupported ((string)add(this.id, " fetchTradingFee() is not supported yet")) ;
        }
        return await this.fetchTradingFees(parameters);
    }

    public virtual object parseOpenInterest(object interest, object market = null)
    {
        throw new NotSupported ((string)add(this.id, " parseOpenInterest () is not supported yet")) ;
    }

    public virtual object parseOpenInterests(object response, object market = null, object since = null, object limit = null)
    {
        object interests = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
        {
            object entry = getValue(response, i);
            object interest = this.parseOpenInterest(entry, market);
            ((List<object>)interests).Add(interest);
        }
        object sorted = this.sortBy(interests, "timestamp");
        object symbol = this.safeString(market, "symbol");
        return this.filterBySymbolSinceLimit(sorted, symbol, since, limit);
    }

    public async virtual Task<object> fetchFundingRate(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(getValue(this.has, "fetchFundingRates")))
        {
            await this.loadMarkets();
            object market = this.market(symbol);
            symbol = getValue(market, "symbol");
            if (!isTrue(getValue(market, "contract")))
            {
                throw new BadSymbol ((string)add(this.id, " fetchFundingRate() supports contract markets only")) ;
            }
            object rates = await this.fetchFundingRates(new List<object>() {symbol}, parameters);
            object rate = this.safeValue(rates, symbol);
            if (isTrue(isEqual(rate, null)))
            {
                throw new NullResponse ((string)add(add(this.id, " fetchFundingRate () returned no data for "), symbol)) ;
            } else
            {
                return rate;
            }
        } else
        {
            throw new NotSupported ((string)add(this.id, " fetchFundingRate () is not supported yet")) ;
        }
    }

    public async virtual Task<object> fetchMarkOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name exchange#fetchMarkOHLCV
        * @description fetches historical mark price candlestick data containing the open, high, low, and close price of a market
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange api endpoint
        * @returns {float[][]} A list of candles ordered as timestamp, open, high, low, close, undefined
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        if (isTrue(getValue(this.has, "fetchMarkOHLCV")))
        {
            object request = new Dictionary<string, object>() {
                { "price", "mark" },
            };
            return await this.fetchOHLCV(symbol, timeframe, since, limit, this.extend(request, parameters));
        } else
        {
            throw new NotSupported ((string)add(this.id, " fetchMarkOHLCV () is not supported yet")) ;
        }
    }

    public async virtual Task<object> fetchIndexOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name exchange#fetchIndexOHLCV
        * @description fetches historical index price candlestick data containing the open, high, low, and close price of a market
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange api endpoint
        * @returns {} A list of candles ordered as timestamp, open, high, low, close, undefined
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        if (isTrue(getValue(this.has, "fetchIndexOHLCV")))
        {
            object request = new Dictionary<string, object>() {
                { "price", "index" },
            };
            return await this.fetchOHLCV(symbol, timeframe, since, limit, this.extend(request, parameters));
        } else
        {
            throw new NotSupported ((string)add(this.id, " fetchIndexOHLCV () is not supported yet")) ;
        }
    }

    public async virtual Task<object> fetchPremiumIndexOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name exchange#fetchPremiumIndexOHLCV
        * @description fetches historical premium index price candlestick data containing the open, high, low, and close price of a market
        * @param {string} symbol unified symbol of the market to fetch OHLCV data for
        * @param {string} timeframe the length of time each candle represents
        * @param {int} [since] timestamp in ms of the earliest candle to fetch
        * @param {int} [limit] the maximum amount of candles to fetch
        * @param {object} [params] extra parameters specific to the exchange api endpoint
        * @returns {float[][]} A list of candles ordered as timestamp, open, high, low, close, undefined
        */
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        if (isTrue(getValue(this.has, "fetchPremiumIndexOHLCV")))
        {
            object request = new Dictionary<string, object>() {
                { "price", "premiumIndex" },
            };
            return await this.fetchOHLCV(symbol, timeframe, since, limit, this.extend(request, parameters));
        } else
        {
            throw new NotSupported ((string)add(this.id, " fetchPremiumIndexOHLCV () is not supported yet")) ;
        }
    }

    public virtual object handleTimeInForce(object parameters = null)
    {
        /**
        * @ignore
        * @method
        * * Must add timeInForce to this.options to use this method
        * @return {string} returns the exchange specific value for timeInForce
        */
        parameters ??= new Dictionary<string, object>();
        object timeInForce = this.safeStringUpper(parameters, "timeInForce"); // supported values GTC, IOC, PO
        if (isTrue(!isEqual(timeInForce, null)))
        {
            object exchangeValue = this.safeString(getValue(this.options, "timeInForce"), timeInForce);
            if (isTrue(isEqual(exchangeValue, null)))
            {
                throw new ExchangeError ((string)add(add(add(this.id, " does not support timeInForce \""), timeInForce), "\"")) ;
            }
            return exchangeValue;
        }
        return null;
    }

    public virtual object convertTypeToAccount(object account)
    {
        /**
         * @ignore
         * @method
         * * Must add accountsByType to this.options to use this method
         * @param {string} account key for account name in this.options['accountsByType']
         * @returns the exchange specific account name or the isolated margin id for transfers
         */
        object accountsByType = this.safeValue(this.options, "accountsByType", new Dictionary<string, object>() {});
        object lowercaseAccount = ((string)account).ToLower();
        if (isTrue(inOp(accountsByType, lowercaseAccount)))
        {
            return getValue(accountsByType, lowercaseAccount);
        } else if (isTrue(isTrue((inOp(this.markets, account))) || isTrue((inOp(this.markets_by_id, account)))))
        {
            object market = this.market(account);
            return getValue(market, "id");
        } else
        {
            return account;
        }
    }

    public virtual void checkRequiredArgument(object methodName, object argument, object argumentName, object options = null)
    {
        /**
        * @ignore
        * @method
        * @param {string} methodName the name of the method that the argument is being checked for
        * @param {string} argument the argument's actual value provided
        * @param {string} argumentName the name of the argument being checked (for logging purposes)
        * @param {string[]} options a list of options that the argument can be
        * @returns {undefined}
        */
        options ??= new List<object>();
        object optionsLength = getArrayLength(options);
        if (isTrue(isTrue((isEqual(argument, null))) || isTrue((isTrue((isGreaterThan(optionsLength, 0))) && isTrue((!isTrue((this.inArray(argument, options)))))))))
        {
            object messageOptions = String.Join(", ", ((List<object>)options).ToArray());
            object message = add(add(add(add(add(this.id, " "), methodName), "() requires a "), argumentName), " argument");
            if (isTrue(!isEqual(messageOptions, "")))
            {
                message = add(message, add(add(add(", one of ", "("), messageOptions), ")"));
            }
            throw new ArgumentsRequired ((string)message) ;
        }
    }

    public virtual void checkRequiredMarginArgument(object methodName, object symbol, object marginMode)
    {
        /**
         * @ignore
         * @method
         * @param {string} symbol unified symbol of the market
         * @param {string} methodName name of the method that requires a symbol
         * @param {string} marginMode is either 'isolated' or 'cross'
         */
        if (isTrue(isTrue((isEqual(marginMode, "isolated"))) && isTrue((isEqual(symbol, null)))))
        {
            throw new ArgumentsRequired ((string)add(add(add(this.id, " "), methodName), "() requires a symbol argument for isolated margin")) ;
        } else if (isTrue(isTrue((isEqual(marginMode, "cross"))) && isTrue((!isEqual(symbol, null)))))
        {
            throw new ArgumentsRequired ((string)add(add(add(this.id, " "), methodName), "() cannot have a symbol argument for cross margin")) ;
        }
    }

    public virtual void checkRequiredSymbol(object methodName, object symbol)
    {
        /**
         * @ignore
         * @method
         * @param {string} symbol unified symbol of the market
         * @param {string} methodName name of the method that requires a symbol
         */
        this.checkRequiredArgument(methodName, symbol, "symbol");
    }

    public virtual object parseDepositWithdrawFees(object response, object codes = null, object currencyIdKey = null)
    {
        /**
         * @ignore
         * @method
         * @param {object[]|object} response unparsed response from the exchange
         * @param {string[]|undefined} codes the unified currency codes to fetch transactions fees for, returns all currencies when undefined
         * @param {str} currencyIdKey *should only be undefined when response is a dictionary* the object key that corresponds to the currency id
         * @returns {object} objects with withdraw and deposit fees, indexed by currency codes
         */
        object depositWithdrawFees = new Dictionary<string, object>() {};
        codes = this.marketCodes(codes);
        object isArray = (response.GetType().IsGenericType && response.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)));
        object responseKeys = response;
        if (!isTrue(isArray))
        {
            responseKeys = new List<object>(((Dictionary<string,object>)response).Keys);
        }
        for (object i = 0; isLessThan(i, getArrayLength(responseKeys)); postFixIncrement(ref i))
        {
            object entry = getValue(responseKeys, i);
            object dictionary = ((bool) isTrue(isArray)) ? entry : getValue(response, entry);
            object currencyId = ((bool) isTrue(isArray)) ? this.safeString(dictionary, currencyIdKey) : entry;
            object currency = this.safeValue(this.currencies_by_id, currencyId);
            object code = this.safeString(currency, "code", currencyId);
            if (isTrue(isTrue((isEqual(codes, null))) || isTrue((this.inArray(code, codes)))))
            {
                ((Dictionary<string, object>)depositWithdrawFees)[(string)code] = this.parseDepositWithdrawFee(dictionary, currency);
            }
        }
        return depositWithdrawFees;
    }

    public virtual object parseDepositWithdrawFee(object fee, object currency = null)
    {
        throw new NotSupported ((string)add(this.id, " parseDepositWithdrawFee() is not supported yet")) ;
    }

    public virtual object depositWithdrawFee(object info)
    {
        return new Dictionary<string, object>() {
            { "info", info },
            { "withdraw", new Dictionary<string, object>() {
                { "fee", null },
                { "percentage", null },
            } },
            { "deposit", new Dictionary<string, object>() {
                { "fee", null },
                { "percentage", null },
            } },
            { "networks", new Dictionary<string, object>() {} },
        };
    }

    public virtual object assignDefaultDepositWithdrawFees(object fee, object currency = null)
    {
        /**
         * @ignore
         * @method
         * @description Takes a depositWithdrawFee structure and assigns the default values for withdraw and deposit
         * @param {object} fee A deposit withdraw fee structure
         * @param {object} currency A currency structure, the response from this.currency ()
         * @returns {object} A deposit withdraw fee structure
         */
        object networkKeys = new List<object>(((Dictionary<string,object>)getValue(fee, "networks")).Keys);
        object numNetworks = getArrayLength(networkKeys);
        if (isTrue(isEqual(numNetworks, 1)))
        {
            ((Dictionary<string, object>)fee)["withdraw"] = getValue(getValue(getValue(fee, "networks"), getValue(networkKeys, 0)), "withdraw");
            ((Dictionary<string, object>)fee)["deposit"] = getValue(getValue(getValue(fee, "networks"), getValue(networkKeys, 0)), "deposit");
            return fee;
        }
        object currencyCode = this.safeString(currency, "code");
        for (object i = 0; isLessThan(i, numNetworks); postFixIncrement(ref i))
        {
            object network = getValue(networkKeys, i);
            if (isTrue(isEqual(network, currencyCode)))
            {
                ((Dictionary<string, object>)fee)["withdraw"] = getValue(getValue(getValue(fee, "networks"), getValue(networkKeys, i)), "withdraw");
                ((Dictionary<string, object>)fee)["deposit"] = getValue(getValue(getValue(fee, "networks"), getValue(networkKeys, i)), "deposit");
            }
        }
        return fee;
    }

    public virtual object parseIncome(object info, object market = null)
    {
        throw new NotSupported ((string)add(this.id, " parseIncome () is not supported yet")) ;
    }

    public virtual object parseIncomes(object incomes, object market = null, object since = null, object limit = null)
    {
        /**
         * @ignore
         * @method
         * @description parses funding fee info from exchange response
         * @param {object[]} incomes each item describes once instance of currency being received or paid
         * @param {object} market ccxt market
         * @param {int} [since] when defined, the response items are filtered to only include items after this timestamp
         * @param {int} [limit] limits the number of items in the response
         * @returns {object[]} an array of [funding history structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#funding-history-structure}
         */
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(incomes)); postFixIncrement(ref i))
        {
            object entry = getValue(incomes, i);
            object parsed = this.parseIncome(entry, market);
            ((List<object>)result).Add(parsed);
        }
        object sorted = this.sortBy(result, "timestamp");
        return this.filterBySinceLimit(sorted, since, limit);
    }

    public virtual object getMarketFromSymbols(object symbols = null)
    {
        if (isTrue(isEqual(symbols, null)))
        {
            return null;
        }
        object firstMarket = this.safeString(symbols, 0);
        object market = this.market(firstMarket);
        return market;
    }

    public virtual object parseWsOHLCVs(object ohlcvs, object market = null, object timeframe = null, object since = null, object limit = null)
    {
        timeframe ??= "1m";
        object results = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(ohlcvs)); postFixIncrement(ref i))
        {
            ((List<object>)results).Add(this.parseWsOHLCV(getValue(ohlcvs, i), market));
        }
        return results;
    }

    public async virtual Task<object> fetchTransactions(object code = null, object since = null, object limit = null, object parameters = null)
    {
        /**
        * @method
        * @name exchange#fetchTransactions
        * @deprecated
        * @description *DEPRECATED* use fetchDepositsWithdrawals instead
        * @param {string} code unified currency code for the currency of the deposit/withdrawals, default is undefined
        * @param {int} [since] timestamp in ms of the earliest deposit/withdrawal, default is undefined
        * @param {int} [limit] max number of deposit/withdrawals to return, default is undefined
        * @param {object} [params] extra parameters specific to the exchange api endpoint
        * @returns {object} a list of [transaction structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#transaction-structure}
        */
        parameters ??= new Dictionary<string, object>();
        if (isTrue(getValue(this.has, "fetchDepositsWithdrawals")))
        {
            return await this.fetchDepositsWithdrawals(code, since, limit, parameters);
        } else
        {
            throw new NotSupported ((string)add(this.id, " fetchTransactions () is not supported yet")) ;
        }
    }

    public virtual object filterByArrayPositions(object objects, object key, object values = null, object indexed = null)
    {
        /**
        * @ignore
        * @method
        * @description Typed wrapper for filterByArray that returns a list of positions
        */
        indexed ??= true;
        return this.filterByArray(objects, key, values, indexed);
    }
}

