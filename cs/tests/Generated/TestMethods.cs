using ccxt;
namespace Tests;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class testMainClass : BaseTest
{
    public virtual void parseCliArgs()
    {
        this.responseTests = getCliArgValue("--responseTests");
        this.idTests = getCliArgValue("--idTests");
        this.requestTests = getCliArgValue("--requestTests");
        this.info = getCliArgValue("--info");
        this.verbose = getCliArgValue("--verbose");
        this.debug = getCliArgValue("--debug");
        this.privateTest = getCliArgValue("--private");
        this.privateTestOnly = getCliArgValue("--privateOnly");
        this.sandbox = getCliArgValue("--sandbox");
        this.loadKeys = getCliArgValue("--loadKeys");
        this.wsTests = getCliArgValue("--ws");
    }

    public async virtual Task init(object exchangeId, object symbolArgv, object methodArgv)
    {
        this.parseCliArgs();
        if (isTrue(isTrue(this.requestTests) && isTrue(this.responseTests)))
        {
            await this.runStaticRequestTests(exchangeId, symbolArgv);
            await this.runStaticResponseTests(exchangeId, symbolArgv);
            return;
        }
        if (isTrue(this.responseTests))
        {
            await this.runStaticResponseTests(exchangeId, symbolArgv);
            return;
        }
        if (isTrue(this.requestTests))
        {
            await this.runStaticRequestTests(exchangeId, symbolArgv); // symbol here is the testname
            return;
        }
        if (isTrue(this.idTests))
        {
            await this.runBrokerIdTests();
            return;
        }
        dump(add(add(add(add(this.newLine, ""), this.newLine), ""), "[INFO] TESTING "), this.ext, new Dictionary<string, object>() {
            { "exchange", exchangeId },
            { "symbol", symbolArgv },
            { "method", methodArgv },
            { "isWs", this.wsTests },
        }, this.newLine);
        object exchangeArgs = new Dictionary<string, object>() {
            { "verbose", this.verbose },
            { "debug", this.debug },
            { "enableRateLimit", true },
            { "timeout", 30000 },
        };
        Exchange exchange = initExchange(exchangeId, exchangeArgs, this.wsTests);
        if (isTrue(exchange.alias))
        {
            exitScript(0);
        }
        await this.importFiles(exchange);
        assert(isGreaterThan(getArrayLength(new List<object>(((IDictionary<string,object>)this.testFiles).Keys)), 0), "Test files were not loaded"); // ensure test files are found & filled
        this.expandSettings(exchange);
        this.checkIfSpecificTestIsChosen(methodArgv);
        await this.startTest(exchange, symbolArgv);
        exitScript(0); // needed to be explicitly finished for WS tests
    }

    public virtual void checkIfSpecificTestIsChosen(object methodArgv)
    {
        if (isTrue(!isEqual(methodArgv, null)))
        {
            object testFileNames = new List<object>(((IDictionary<string,object>)this.testFiles).Keys);
            object possibleMethodNames = ((string)methodArgv).Split(new [] {((string)",")}, StringSplitOptions.None).ToList<object>(); // i.e. `test.ts binance fetchBalance,fetchDeposits`
            if (isTrue(isGreaterThanOrEqual(getArrayLength(possibleMethodNames), 1)))
            {
                for (object i = 0; isLessThan(i, getArrayLength(testFileNames)); postFixIncrement(ref i))
                {
                    object testFileName = getValue(testFileNames, i);
                    for (object j = 0; isLessThan(j, getArrayLength(possibleMethodNames)); postFixIncrement(ref j))
                    {
                        object methodName = getValue(possibleMethodNames, j);
                        methodName = ((string)methodName).Replace((string)"()", (string)"");
                        if (isTrue(isEqual(testFileName, methodName)))
                        {
                            ((IList<object>)this.onlySpecificTests).Add(testFileName);
                        }
                    }
                }
            }
        }
    }

    public async virtual Task importFiles(Exchange exchange)
    {
        object properties = new List<object>(((IDictionary<string,object>)exchange.has).Keys);
        ((IList<object>)properties).Add("loadMarkets");
        this.testFiles = await getTestFiles(properties, this.wsTests);
    }

    public virtual void loadCredentialsFromEnv(Exchange exchange)
    {
        object exchangeId = exchange.id;
        object reqCreds = getExchangeProp(exchange, add("re", "quiredCredentials")); // dont glue the r-e-q-u-i-r-e phrase, because leads to messed up transpilation
        object objkeys = new List<object>(((IDictionary<string,object>)reqCreds).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(objkeys)); postFixIncrement(ref i))
        {
            object credential = getValue(objkeys, i);
            object isRequired = getValue(reqCreds, credential);
            if (isTrue(isTrue(isRequired) && isTrue(isEqual(getExchangeProp(exchange, credential), null))))
            {
                object fullKey = add(add(exchangeId, "_"), credential);
                object credentialEnvName = ((string)fullKey).ToUpper(); // example: KRAKEN_APIKEY
                object credentialValue = ((bool) isTrue((inOp(this.envVars, credentialEnvName)))) ? getValue(this.envVars, credentialEnvName) : null;
                if (isTrue(credentialValue))
                {
                    setExchangeProp(exchange, credential, credentialValue);
                }
            }
        }
    }

    public virtual void expandSettings(Exchange exchange)
    {
        object exchangeId = exchange.id;
        object keysGlobal = add(this.rootDir, "keys.json");
        object keysLocal = add(this.rootDir, "keys.local.json");
        object keysGlobalExists = ioFileExists(keysGlobal);
        object keysLocalExists = ioFileExists(keysLocal);
        object globalSettings = ((bool) isTrue(keysGlobalExists)) ? ioFileRead(keysGlobal) : new Dictionary<string, object>() {};
        object localSettings = ((bool) isTrue(keysLocalExists)) ? ioFileRead(keysLocal) : new Dictionary<string, object>() {};
        object allSettings = exchange.deepExtend(globalSettings, localSettings);
        object exchangeSettings = exchange.safeValue(allSettings, exchangeId, new Dictionary<string, object>() {});
        if (isTrue(exchangeSettings))
        {
            object settingKeys = new List<object>(((IDictionary<string,object>)exchangeSettings).Keys);
            for (object i = 0; isLessThan(i, getArrayLength(settingKeys)); postFixIncrement(ref i))
            {
                object key = getValue(settingKeys, i);
                if (isTrue(getValue(exchangeSettings, key)))
                {
                    object finalValue = null;
                    if (isTrue((getValue(exchangeSettings, key) is IDictionary<string, object>)))
                    {
                        object existing = getExchangeProp(exchange, key, new Dictionary<string, object>() {});
                        finalValue = exchange.deepExtend(existing, getValue(exchangeSettings, key));
                    } else
                    {
                        finalValue = getValue(exchangeSettings, key);
                    }
                    setExchangeProp(exchange, key, finalValue);
                }
            }
        }
        // credentials
        if (isTrue(this.loadKeys))
        {
            this.loadCredentialsFromEnv(exchange);
        }
        // skipped tests
        object skippedFile = add(this.rootDirForSkips, "skip-tests.json");
        object skippedSettings = ioFileRead(skippedFile);
        this.skippedSettingsForExchange = exchange.safeValue(skippedSettings, exchangeId, new Dictionary<string, object>() {});
        object skippedSettingsForExchange = this.skippedSettingsForExchange;
        // others
        object timeout = exchange.safeValue(skippedSettingsForExchange, "timeout");
        if (isTrue(!isEqual(timeout, null)))
        {
            exchange.timeout = exchange.parseToInt(timeout);
        }
        if (isTrue(getCliArgValue("--useProxy")))
        {
            exchange.httpProxy = exchange.safeString(skippedSettingsForExchange, "httpProxy");
            exchange.httpsProxy = exchange.safeString(skippedSettingsForExchange, "httpsProxy");
            exchange.wsProxy = exchange.safeString(skippedSettingsForExchange, "wsProxy");
            exchange.wssProxy = exchange.safeString(skippedSettingsForExchange, "wssProxy");
        }
        this.skippedMethods = exchange.safeValue(skippedSettingsForExchange, "skipMethods", new Dictionary<string, object>() {});
        this.checkedPublicTests = new Dictionary<string, object>() {};
    }

    public virtual object addPadding(object message, object size)
    {
        // has to be transpilable
        object res = "";
        object messageLength = ((string)message).Length; // avoid php transpilation issue
        object missingSpace = subtract(subtract(size, messageLength), 0); // - 0 is added just to trick transpile to treat the .length as a string for php
        if (isTrue(isGreaterThan(missingSpace, 0)))
        {
            for (object i = 0; isLessThan(i, missingSpace); postFixIncrement(ref i))
            {
                res = add(res, " ");
            }
        }
        return add(message, res);
    }

    public virtual object exchangeHint(Exchange exchange, object market = null)
    {
        object marketType = exchange.safeString2(exchange.options, "defaultType", "type", "");
        object marketSubType = exchange.safeString2(exchange.options, "defaultSubType", "subType");
        if (isTrue(!isEqual(market, null)))
        {
            marketType = getValue(market, "type");
            if (isTrue(getValue(market, "linear")))
            {
                marketSubType = "linear";
            } else if (isTrue(getValue(market, "inverse")))
            {
                marketSubType = "inverse";
            } else if (isTrue(isEqual(exchange.safeValue(market, "quanto"), true)))
            {
                marketSubType = "quanto";
            }
        }
        object isWs = (inOp(exchange.has, "ws"));
        object wsFlag = ((bool) isTrue(isWs)) ? "(WS)" : "";
        object result = add(add(add(add(exchange.id, " "), wsFlag), " "), marketType);
        if (isTrue(!isEqual(marketSubType, null)))
        {
            result = add(add(add(result, " [subType: "), marketSubType), "] ");
        }
        return result;
    }

    public async virtual Task testMethod(object methodName, Exchange exchange, object args, object isPublic)
    {
        // todo: temporary skip for c#
        if (isTrue(isTrue(isGreaterThanOrEqual(getIndexOf(methodName, "OrderBook"), 0)) && isTrue(isEqual(this.ext, "cs"))))
        {
            ((IDictionary<string,object>)exchange.options)["checksum"] = false;
        }
        // todo: temporary skip for php
        if (isTrue(isTrue(isGreaterThanOrEqual(getIndexOf(methodName, "OrderBook"), 0)) && isTrue(isEqual(this.ext, "php"))))
        {
            return;
        }
        object skippedPropertiesForMethod = this.getSkips(exchange, methodName);
        object isLoadMarkets = (isEqual(methodName, "loadMarkets"));
        object isFetchCurrencies = (isEqual(methodName, "fetchCurrencies"));
        object isProxyTest = (isEqual(methodName, this.proxyTestFileName));
        // if this is a private test, and the implementation was already tested in public, then no need to re-test it in private test (exception is fetchCurrencies, because our approach in base exchange)
        if (isTrue(isTrue(!isTrue(isPublic) && isTrue((inOp(this.checkedPublicTests, methodName)))) && !isTrue(isFetchCurrencies)))
        {
            return;
        }
        object skipMessage = null;
        object supportedByExchange = isTrue((inOp(exchange.has, methodName))) && isTrue(getValue(exchange.has, methodName));
        if (isTrue(!isTrue(isLoadMarkets) && isTrue((isTrue(isGreaterThan(getArrayLength(this.onlySpecificTests), 0)) && !isTrue(exchange.inArray(methodName, this.onlySpecificTests))))))
        {
            skipMessage = "[INFO] IGNORED_TEST";
        } else if (isTrue(isTrue(!isTrue(isLoadMarkets) && !isTrue(supportedByExchange)) && !isTrue(isProxyTest)))
        {
            skipMessage = "[INFO] UNSUPPORTED_TEST"; // keep it aligned with the longest message
        } else if (isTrue((skippedPropertiesForMethod is string)))
        {
            skipMessage = "[INFO] SKIPPED_TEST";
        } else if (!isTrue((inOp(this.testFiles, methodName))))
        {
            skipMessage = "[INFO] UNIMPLEMENTED_TEST";
        }
        // exceptionally for `loadMarkets` call, we call it before it's even checked for "skip" as we need it to be called anyway (but can skip "test.loadMarket" for it)
        if (isTrue(isLoadMarkets))
        {
            await exchange.loadMarkets(true);
        }
        if (isTrue(skipMessage))
        {
            if (isTrue(this.info))
            {
                dump(this.addPadding(skipMessage, 25), this.exchangeHint(exchange), methodName);
            }
            return;
        }
        if (isTrue(this.info))
        {
            object argsStringified = add(add("(", String.Join(",", ((IList<object>)args).ToArray())), ")");
            dump(this.addPadding("[INFO] TESTING", 25), this.exchangeHint(exchange), methodName, argsStringified);
        }
        await callMethod(this.testFiles, methodName, exchange, skippedPropertiesForMethod, args);
        // if it was passed successfully, add to the list of successfull tests
        if (isTrue(isPublic))
        {
            ((IDictionary<string,object>)this.checkedPublicTests)[(string)methodName] = true;
        }
        return;
    }

    public virtual object getSkips(Exchange exchange, object methodName)
    {
        object finalSkips = new Dictionary<string, object>() {};
        // check the exact method (i.e. `fetchTrades`) and language-specific (i.e. `fetchTrades.php`)
        object methodNames = new List<object>() {methodName, add(add(methodName, "."), this.ext)};
        for (object i = 0; isLessThan(i, getArrayLength(methodNames)); postFixIncrement(ref i))
        {
            object mName = getValue(methodNames, i);
            if (isTrue(inOp(this.skippedMethods, mName)))
            {
                // if whole method is skipped, by assigning a string to it, i.e. "fetchOrders":"blabla"
                if (isTrue((getValue(this.skippedMethods, mName) is string)))
                {
                    return getValue(this.skippedMethods, mName);
                } else
                {
                    finalSkips = exchange.deepExtend(finalSkips, getValue(this.skippedMethods, mName));
                }
            }
        }
        // get "object-specific" skips
        object objectSkips = new Dictionary<string, object>() {
            { "orderBook", new List<object>() {"fetchOrderBook", "fetchOrderBooks", "fetchL2OrderBook", "watchOrderBook", "watchOrderBookForSymbols"} },
            { "ticker", new List<object>() {"fetchTicker", "fetchTickers", "watchTicker", "watchTickers"} },
            { "trade", new List<object>() {"fetchTrades", "watchTrades", "watchTradesForSymbols"} },
            { "ohlcv", new List<object>() {"fetchOHLCV", "watchOHLCV", "watchOHLCVForSymbols"} },
            { "ledger", new List<object>() {"fetchLedger", "fetchLedgerEntry"} },
            { "depositWithdraw", new List<object>() {"fetchDepositsWithdrawals", "fetchDeposits", "fetchWithdrawals"} },
            { "depositWithdrawFee", new List<object>() {"fetchDepositWithdrawFee", "fetchDepositWithdrawFees"} },
        };
        object objectNames = new List<object>(((IDictionary<string,object>)objectSkips).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(objectNames)); postFixIncrement(ref i))
        {
            object objectName = getValue(objectNames, i);
            object objectMethods = getValue(objectSkips, objectName);
            if (isTrue(exchange.inArray(methodName, objectMethods)))
            {
                // if whole object is skipped, by assigning a string to it, i.e. "orderBook":"blabla"
                if (isTrue(isTrue((inOp(this.skippedMethods, objectName))) && isTrue(((getValue(this.skippedMethods, objectName) is string)))))
                {
                    return getValue(this.skippedMethods, objectName);
                }
                object extraSkips = exchange.safeDict(this.skippedMethods, objectName, new Dictionary<string, object>() {});
                finalSkips = exchange.deepExtend(finalSkips, extraSkips);
            }
        }
        // extend related skips
        // - if 'timestamp' is skipped, we should do so for 'datetime' too
        // - if 'bid' is skipped, skip 'ask' too
        if (isTrue(isTrue((inOp(finalSkips, "timestamp"))) && !isTrue((inOp(finalSkips, "datetime")))))
        {
            ((IDictionary<string,object>)finalSkips)["datetime"] = getValue(finalSkips, "timestamp");
        }
        if (isTrue(isTrue((inOp(finalSkips, "bid"))) && !isTrue((inOp(finalSkips, "ask")))))
        {
            ((IDictionary<string,object>)finalSkips)["ask"] = getValue(finalSkips, "bid");
        }
        if (isTrue(isTrue((inOp(finalSkips, "baseVolume"))) && !isTrue((inOp(finalSkips, "quoteVolume")))))
        {
            ((IDictionary<string,object>)finalSkips)["quoteVolume"] = getValue(finalSkips, "baseVolume");
        }
        return finalSkips;
    }

    public async virtual Task<object> testSafe(object methodName, Exchange exchange, object args = null, object isPublic = null)
    {
        // `testSafe` method does not throw an exception, instead mutes it. The reason we
        // mute the thrown exceptions here is because we don't want to stop the whole
        // tests queue if any single test-method fails. Instead, they are echoed with
        // formatted message "[TEST_FAILURE] ..." and that output is then regex-matched by
        // run-tests.js, so the exceptions are still printed out to console from there.
        args ??= new List<object>();
        isPublic ??= false;
        object maxRetries = 3;
        object argsStringified = exchange.json(args); // args.join() breaks when we provide a list of symbols | "args.toString()" breaks bcz of "array to string conversion"
        for (object i = 0; isLessThan(i, maxRetries); postFixIncrement(ref i))
        {
            try
            {
                await this.testMethod(methodName, exchange, args, isPublic);
                return true;
            } catch(Exception e)
            {
                object isLoadMarkets = (isEqual(methodName, "loadMarkets"));
                object isAuthError = (e is AuthenticationError);
                object isNotSupported = (e is NotSupported);
                object isOperationFailed = (e is OperationFailed); // includes "DDoSProtection", "RateLimitExceeded", "RequestTimeout", "ExchangeNotAvailable", "OperationFailed", "InvalidNonce", ...
                if (isTrue(isOperationFailed))
                {
                    // if last retry was gone with same `tempFailure` error, then let's eventually return false
                    if (isTrue(isEqual(i, subtract(maxRetries, 1))))
                    {
                        object isOnMaintenance = (e is OnMaintenance);
                        object isExchangeNotAvailable = (e is ExchangeNotAvailable);
                        object shouldFail = null;
                        object returnSuccess = null;
                        if (isTrue(isLoadMarkets))
                        {
                            // if "loadMarkets" does not succeed, we must return "false" to caller method, to stop tests continual
                            returnSuccess = false;
                            // we might not break exchange tests, if exchange is on maintenance at this moment
                            if (isTrue(isOnMaintenance))
                            {
                                shouldFail = false;
                            } else
                            {
                                shouldFail = true;
                            }
                        } else
                        {
                            // for any other method tests:
                            if (isTrue(isTrue(isExchangeNotAvailable) && !isTrue(isOnMaintenance)))
                            {
                                // break exchange tests if "ExchangeNotAvailable" exception is thrown, but it's not maintenance
                                shouldFail = true;
                                returnSuccess = false;
                            } else
                            {
                                // in all other cases of OperationFailed, show Warning, but don't mark test as failed
                                shouldFail = false;
                                returnSuccess = true;
                            }
                        }
                        // output the message
                        object failType = ((bool) isTrue(shouldFail)) ? "[TEST_FAILURE]" : "[TEST_WARNING]";
                        dump(failType, "Method could not be tested due to a repeated Network/Availability issues", " | ", this.exchangeHint(exchange), methodName, argsStringified, exceptionMessage(e));
                        return returnSuccess;
                    } else
                    {
                        // wait and retry again
                        // (increase wait time on every retry)
                        await exchange.sleep(multiply(i, 1000));
                        continue;
                    }
                } else
                {
                    // if it's loadMarkets, then fail test, because it's mandatory for tests
                    if (isTrue(isLoadMarkets))
                    {
                        dump("[TEST_FAILURE]", "Exchange can not load markets", exceptionMessage(e), this.exchangeHint(exchange), methodName, argsStringified);
                        return false;
                    }
                    // if the specific arguments to the test method throws "NotSupported" exception
                    // then let's don't fail the test
                    if (isTrue(isNotSupported))
                    {
                        if (isTrue(this.info))
                        {
                            dump("[INFO] NOT_SUPPORTED", exceptionMessage(e), this.exchangeHint(exchange), methodName, argsStringified);
                        }
                        return true;
                    }
                    // If public test faces authentication error, we don't break (see comments under `testSafe` method)
                    if (isTrue(isTrue(isPublic) && isTrue(isAuthError)))
                    {
                        if (isTrue(this.info))
                        {
                            dump("[INFO]", "Authentication problem for public method", exceptionMessage(e), this.exchangeHint(exchange), methodName, argsStringified);
                        }
                        return true;
                    } else
                    {
                        dump("[TEST_FAILURE]", exceptionMessage(e), this.exchangeHint(exchange), methodName, argsStringified);
                        return false;
                    }
                }
            }
        }
        return true;
    }

    public async virtual Task runPublicTests(Exchange exchange, object symbol)
    {
        object tests = new Dictionary<string, object>() {
            { "fetchCurrencies", new List<object>() {} },
            { "fetchTicker", new List<object>() {symbol} },
            { "fetchTickers", new List<object>() {symbol} },
            { "fetchLastPrices", new List<object>() {symbol} },
            { "fetchOHLCV", new List<object>() {symbol} },
            { "fetchTrades", new List<object>() {symbol} },
            { "fetchOrderBook", new List<object>() {symbol} },
            { "fetchL2OrderBook", new List<object>() {symbol} },
            { "fetchOrderBooks", new List<object>() {} },
            { "fetchBidsAsks", new List<object>() {} },
            { "fetchStatus", new List<object>() {} },
            { "fetchTime", new List<object>() {} },
        };
        if (isTrue(this.wsTests))
        {
            tests = new Dictionary<string, object>() {
                { "watchOHLCV", new List<object>() {symbol} },
                { "watchOHLCVForSymbols", new List<object>() {symbol} },
                { "watchTicker", new List<object>() {symbol} },
                { "watchTickers", new List<object>() {symbol} },
                { "watchBidsAsks", new List<object>() {symbol} },
                { "watchOrderBook", new List<object>() {symbol} },
                { "watchOrderBookForSymbols", new List<object>() {new List<object>() {symbol}} },
                { "watchTrades", new List<object>() {symbol} },
                { "watchTradesForSymbols", new List<object>() {new List<object>() {symbol}} },
            };
        }
        object market = exchange.market(symbol);
        object isSpot = getValue(market, "spot");
        if (!isTrue(this.wsTests))
        {
            if (isTrue(isSpot))
            {
                ((IDictionary<string,object>)tests)["fetchCurrencies"] = new List<object>() {};
            } else
            {
                ((IDictionary<string,object>)tests)["fetchFundingRates"] = new List<object>() {symbol};
                ((IDictionary<string,object>)tests)["fetchFundingRate"] = new List<object>() {symbol};
                ((IDictionary<string,object>)tests)["fetchFundingRateHistory"] = new List<object>() {symbol};
                ((IDictionary<string,object>)tests)["fetchIndexOHLCV"] = new List<object>() {symbol};
                ((IDictionary<string,object>)tests)["fetchMarkOHLCV"] = new List<object>() {symbol};
                ((IDictionary<string,object>)tests)["fetchPremiumIndexOHLCV"] = new List<object>() {symbol};
            }
        }
        this.publicTests = tests;
        await this.runTests(exchange, tests, true);
    }

    public async virtual Task runTests(Exchange exchange, object tests, object isPublicTest)
    {
        object testNames = new List<object>(((IDictionary<string,object>)tests).Keys);
        object promises = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(testNames)); postFixIncrement(ref i))
        {
            object testName = getValue(testNames, i);
            object testArgs = getValue(tests, testName);
            ((IList<object>)promises).Add(this.testSafe(testName, exchange, testArgs, isPublicTest));
        }
        // todo - not yet ready in other langs too
        // promises.push (testThrottle ());
        object results = await promiseAll(promises);
        // now count which test-methods retuned `false` from "testSafe" and dump that info below
        object failedMethods = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(testNames)); postFixIncrement(ref i))
        {
            object testName = getValue(testNames, i);
            object testReturnedValue = getValue(results, i);
            if (!isTrue(testReturnedValue))
            {
                ((IList<object>)failedMethods).Add(testName);
            }
        }
        object testPrefixString = ((bool) isTrue(isPublicTest)) ? "PUBLIC_TESTS" : "PRIVATE_TESTS";
        if (isTrue(getArrayLength(failedMethods)))
        {
            object errorsString = String.Join(", ", ((IList<object>)failedMethods).ToArray());
            dump("[TEST_FAILURE]", this.exchangeHint(exchange), testPrefixString, add("Failed methods : ", errorsString));
        }
        if (isTrue(this.info))
        {
            dump(this.addPadding(add(add(add("[INFO] END ", testPrefixString), " "), this.exchangeHint(exchange)), 25));
        }
    }

    public async virtual Task<object> loadExchange(Exchange exchange)
    {
        object result = await this.testSafe("loadMarkets", exchange, new List<object>() {}, true);
        if (!isTrue(result))
        {
            return false;
        }
        object exchangeSymbolsLength = getArrayLength(exchange.symbols);
        dump("[INFO:MAIN] Exchange loaded", exchangeSymbolsLength, "symbols");
        return true;
    }

    public virtual object getTestSymbol(Exchange exchange, object isSpot, object symbols)
    {
        object symbol = null;
        object preferredSpotSymbol = exchange.safeString(this.skippedSettingsForExchange, "preferredSpotSymbol");
        object preferredSwapSymbol = exchange.safeString(this.skippedSettingsForExchange, "preferredSwapSymbol");
        if (isTrue(isTrue(isSpot) && isTrue(preferredSpotSymbol)))
        {
            return preferredSpotSymbol;
        } else if (isTrue(!isTrue(isSpot) && isTrue(preferredSwapSymbol)))
        {
            return preferredSwapSymbol;
        }
        for (object i = 0; isLessThan(i, getArrayLength(symbols)); postFixIncrement(ref i))
        {
            object s = getValue(symbols, i);
            object market = exchange.safeValue(exchange.markets, s);
            if (isTrue(!isEqual(market, null)))
            {
                object active = exchange.safeValue(market, "active");
                if (isTrue(isTrue(active) || isTrue((isEqual(active, null)))))
                {
                    symbol = s;
                    break;
                }
            }
        }
        return symbol;
    }

    public virtual object getExchangeCode(Exchange exchange, object codes = null)
    {
        if (isTrue(isEqual(codes, null)))
        {
            codes = new List<object>() {"BTC", "ETH", "XRP", "LTC", "BCH", "EOS", "BNB", "BSV", "USDT"};
        }
        object code = getValue(codes, 0);
        for (object i = 0; isLessThan(i, getArrayLength(codes)); postFixIncrement(ref i))
        {
            if (isTrue(inOp(exchange.currencies, getValue(codes, i))))
            {
                return getValue(codes, i);
            }
        }
        return code;
    }

    public virtual object getMarketsFromExchange(Exchange exchange, object spot = null)
    {
        spot ??= true;
        object res = new Dictionary<string, object>() {};
        object markets = exchange.markets;
        object keys = new List<object>(((IDictionary<string,object>)markets).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object key = getValue(keys, i);
            object market = getValue(markets, key);
            if (isTrue(isTrue(spot) && isTrue(getValue(market, "spot"))))
            {
                ((IDictionary<string,object>)res)[(string)getValue(market, "symbol")] = market;
            } else if (isTrue(!isTrue(spot) && !isTrue(getValue(market, "spot"))))
            {
                ((IDictionary<string,object>)res)[(string)getValue(market, "symbol")] = market;
            }
        }
        return res;
    }

    public virtual object getValidSymbol(Exchange exchange, object spot = null)
    {
        spot ??= true;
        object currentTypeMarkets = this.getMarketsFromExchange(exchange, spot);
        object codes = new List<object>() {"BTC", "ETH", "XRP", "LTC", "BNB", "DASH", "DOGE", "ETC", "TRX", "USDT", "USDC", "USD", "EUR", "TUSD", "CNY", "JPY", "BRL"};
        object spotSymbols = new List<object>() {"BTC/USDT", "BTC/USDC", "BTC/USD", "BTC/CNY", "BTC/EUR", "BTC/AUD", "BTC/BRL", "BTC/JPY", "ETH/USDT", "ETH/USDC", "ETH/USD", "ETH/CNY", "ETH/EUR", "ETH/AUD", "ETH/BRL", "ETH/JPY", "EUR/USDT", "EUR/USD", "EUR/USDC", "USDT/EUR", "USD/EUR", "USDC/EUR", "BTC/ETH", "ETH/BTC"};
        object swapSymbols = new List<object>() {"BTC/USDT:USDT", "BTC/USDC:USDC", "BTC/USD:USD", "ETH/USDT:USDT", "ETH/USDC:USDC", "ETH/USD:USD", "BTC/USD:BTC", "ETH/USD:ETH"};
        object targetSymbols = ((bool) isTrue(spot)) ? spotSymbols : swapSymbols;
        object symbol = this.getTestSymbol(exchange, spot, targetSymbols);
        // if symbols wasn't found from above hardcoded list, then try to locate any symbol which has our target hardcoded 'base' code
        if (isTrue(isEqual(symbol, null)))
        {
            for (object i = 0; isLessThan(i, getArrayLength(codes)); postFixIncrement(ref i))
            {
                object currentCode = getValue(codes, i);
                object marketsArrayForCurrentCode = exchange.filterBy(currentTypeMarkets, "base", currentCode);
                object indexedMkts = exchange.indexBy(marketsArrayForCurrentCode, "symbol");
                object symbolsArrayForCurrentCode = new List<object>(((IDictionary<string,object>)indexedMkts).Keys);
                object symbolsLength = getArrayLength(symbolsArrayForCurrentCode);
                if (isTrue(symbolsLength))
                {
                    symbol = this.getTestSymbol(exchange, spot, symbolsArrayForCurrentCode);
                    break;
                }
            }
        }
        // if there wasn't found any symbol with our hardcoded 'base' code, then just try to find symbols that are 'active'
        if (isTrue(isEqual(symbol, null)))
        {
            object activeMarkets = exchange.filterBy(currentTypeMarkets, "active", true);
            object activeSymbols = new List<object>() {};
            for (object i = 0; isLessThan(i, getArrayLength(activeMarkets)); postFixIncrement(ref i))
            {
                ((IList<object>)activeSymbols).Add(getValue(getValue(activeMarkets, i), "symbol"));
            }
            symbol = this.getTestSymbol(exchange, spot, activeSymbols);
        }
        if (isTrue(isEqual(symbol, null)))
        {
            object values = new List<object>(((IDictionary<string,object>)currentTypeMarkets).Values);
            object valuesLength = getArrayLength(values);
            if (isTrue(isGreaterThan(valuesLength, 0)))
            {
                object first = getValue(values, 0);
                if (isTrue(!isEqual(first, null)))
                {
                    symbol = getValue(first, "symbol");
                }
            }
        }
        return symbol;
    }

    public async virtual Task testExchange(Exchange exchange, object providedSymbol = null)
    {
        object spotSymbol = null;
        object swapSymbol = null;
        if (isTrue(!isEqual(providedSymbol, null)))
        {
            object market = exchange.market(providedSymbol);
            if (isTrue(getValue(market, "spot")))
            {
                spotSymbol = providedSymbol;
            } else
            {
                swapSymbol = providedSymbol;
            }
        } else
        {
            if (isTrue(getValue(exchange.has, "spot")))
            {
                spotSymbol = this.getValidSymbol(exchange, true);
            }
            if (isTrue(getValue(exchange.has, "swap")))
            {
                swapSymbol = this.getValidSymbol(exchange, false);
            }
        }
        if (isTrue(!isEqual(spotSymbol, null)))
        {
            dump("[INFO:MAIN] Selected SPOT SYMBOL:", spotSymbol);
        }
        if (isTrue(!isEqual(swapSymbol, null)))
        {
            dump("[INFO:MAIN] Selected SWAP SYMBOL:", swapSymbol);
        }
        if (!isTrue(this.privateTestOnly))
        {
            // note, spot & swap tests should run sequentially, because of conflicting `exchange.options['defaultType']` setting
            if (isTrue(isTrue(getValue(exchange.has, "spot")) && isTrue(!isEqual(spotSymbol, null))))
            {
                if (isTrue(this.info))
                {
                    dump("[INFO] ### SPOT TESTS ###");
                }
                ((IDictionary<string,object>)exchange.options)["defaultType"] = "spot";
                await this.runPublicTests(exchange, spotSymbol);
            }
            if (isTrue(isTrue(getValue(exchange.has, "swap")) && isTrue(!isEqual(swapSymbol, null))))
            {
                if (isTrue(this.info))
                {
                    dump("[INFO] ### SWAP TESTS ###");
                }
                ((IDictionary<string,object>)exchange.options)["defaultType"] = "swap";
                await this.runPublicTests(exchange, swapSymbol);
            }
        }
        if (isTrue(isTrue(this.privateTest) || isTrue(this.privateTestOnly)))
        {
            if (isTrue(isTrue(getValue(exchange.has, "spot")) && isTrue(!isEqual(spotSymbol, null))))
            {
                ((IDictionary<string,object>)exchange.options)["defaultType"] = "spot";
                await this.runPrivateTests(exchange, spotSymbol);
            }
            if (isTrue(isTrue(getValue(exchange.has, "swap")) && isTrue(!isEqual(swapSymbol, null))))
            {
                ((IDictionary<string,object>)exchange.options)["defaultType"] = "swap";
                await this.runPrivateTests(exchange, swapSymbol);
            }
        }
    }

    public async virtual Task runPrivateTests(Exchange exchange, object symbol)
    {
        if (!isTrue(exchange.checkRequiredCredentials(false)))
        {
            dump("[INFO] Skipping private tests", "Keys not found");
            return;
        }
        object code = this.getExchangeCode(exchange);
        // if (exchange.deepExtendedTest) {
        //     await test ('InvalidNonce', exchange, symbol);
        //     await test ('OrderNotFound', exchange, symbol);
        //     await test ('InvalidOrder', exchange, symbol);
        //     await test ('InsufficientFunds', exchange, symbol, balance); // danger zone - won't execute with non-empty balance
        // }
        object tests = new Dictionary<string, object>() {
            { "signIn", new List<object>() {} },
            { "fetchBalance", new List<object>() {} },
            { "fetchAccounts", new List<object>() {} },
            { "fetchTransactionFees", new List<object>() {} },
            { "fetchTradingFees", new List<object>() {} },
            { "fetchStatus", new List<object>() {} },
            { "fetchOrders", new List<object>() {symbol} },
            { "fetchOpenOrders", new List<object>() {symbol} },
            { "fetchClosedOrders", new List<object>() {symbol} },
            { "fetchMyTrades", new List<object>() {symbol} },
            { "fetchLeverageTiers", new List<object>() {new List<object>() {symbol}} },
            { "fetchLedger", new List<object>() {code} },
            { "fetchTransactions", new List<object>() {code} },
            { "fetchDeposits", new List<object>() {code} },
            { "fetchWithdrawals", new List<object>() {code} },
            { "fetchBorrowInterest", new List<object>() {code, symbol} },
            { "cancelAllOrders", new List<object>() {symbol} },
            { "fetchCanceledOrders", new List<object>() {symbol} },
            { "fetchMarginModes", new List<object>() {symbol} },
            { "fetchPosition", new List<object>() {symbol} },
            { "fetchDeposit", new List<object>() {code} },
            { "createDepositAddress", new List<object>() {code} },
            { "fetchDepositAddress", new List<object>() {code} },
            { "fetchDepositAddresses", new List<object>() {code} },
            { "fetchDepositAddressesByNetwork", new List<object>() {code} },
            { "fetchBorrowRateHistory", new List<object>() {code} },
            { "fetchLedgerEntry", new List<object>() {code} },
        };
        if (isTrue(this.wsTests))
        {
            tests = new Dictionary<string, object>() {
                { "watchBalance", new List<object>() {code} },
                { "watchMyTrades", new List<object>() {symbol} },
                { "watchOrders", new List<object>() {symbol} },
                { "watchPosition", new List<object>() {symbol} },
                { "watchPositions", new List<object>() {symbol} },
            };
        }
        object market = exchange.market(symbol);
        object isSpot = getValue(market, "spot");
        if (!isTrue(this.wsTests))
        {
            if (isTrue(isSpot))
            {
                ((IDictionary<string,object>)tests)["fetchCurrencies"] = new List<object>() {};
            } else
            {
                // derivatives only
                ((IDictionary<string,object>)tests)["fetchPositions"] = new List<object>() {symbol}; // this test fetches all positions for 1 symbol
                ((IDictionary<string,object>)tests)["fetchPosition"] = new List<object>() {symbol};
                ((IDictionary<string,object>)tests)["fetchPositionRisk"] = new List<object>() {symbol};
                ((IDictionary<string,object>)tests)["setPositionMode"] = new List<object>() {symbol};
                ((IDictionary<string,object>)tests)["setMarginMode"] = new List<object>() {symbol};
                ((IDictionary<string,object>)tests)["fetchOpenInterestHistory"] = new List<object>() {symbol};
                ((IDictionary<string,object>)tests)["fetchFundingRateHistory"] = new List<object>() {symbol};
                ((IDictionary<string,object>)tests)["fetchFundingHistory"] = new List<object>() {symbol};
            }
        }
        // const combinedTests = exchange.deepExtend (this.publicTests, privateTests);
        await this.runTests(exchange, tests, false);
    }

    public async virtual Task testProxies(Exchange exchange)
    {
        // these tests should be synchronously executed, because of conflicting nature of proxy settings
        object proxyTestName = this.proxyTestFileName;
        // todo: temporary skip for sync py
        if (isTrue(isTrue(isEqual(this.ext, "py")) && isTrue(this.isSynchronous)))
        {
            return;
        }
        // try proxy several times
        object maxRetries = 3;
        object exception = null;
        for (object j = 0; isLessThan(j, maxRetries); postFixIncrement(ref j))
        {
            try
            {
                await this.testMethod(proxyTestName, exchange, new List<object>() {}, true);
                break; // if successfull, then break
            } catch(Exception e)
            {
                exception = e;
            }
        }
        // if exception was set, then throw it
        if (isTrue(exception))
        {
            object errorMessage = add(add(add("[TEST_FAILURE] Failed ", proxyTestName), " : "), exceptionMessage(exception));
            throw new ExchangeError (((object)errorMessage).ToString()) ;
        }
    }

    public async virtual Task startTest(Exchange exchange, object symbol)
    {
        // we do not need to test aliases
        if (isTrue(exchange.alias))
        {
            return;
        }
        if (isTrue(isTrue(this.sandbox) || isTrue(getExchangeProp(exchange, "sandbox"))))
        {
            exchange.setSandboxMode(true);
        }
        try
        {
            object result = await this.loadExchange(exchange);
            if (!isTrue(result))
            {
                await close(exchange);
                return;
            }
            // if (exchange.id === 'binance') {
            //     // we test proxies functionality just for one random exchange on each build, because proxy functionality is not exchange-specific, instead it's all done from base methods, so just one working sample would mean it works for all ccxt exchanges
            //     // await this.testProxies (exchange);
            // }
            await this.testExchange(exchange, symbol);
            await close(exchange);
        } catch(Exception e)
        {
            await close(exchange);
            throw e;
        }
    }

    public virtual void assertStaticError(object cond, object message, object calculatedOutput, object storedOutput, object key = null)
    {
        //  -----------------------------------------------------------------------------
        //  --- Init of static tests functions------------------------------------------
        //  -----------------------------------------------------------------------------
        object calculatedString = jsonStringify(calculatedOutput);
        object storedString = jsonStringify(storedOutput);
        object errorMessage = add(add(add(add(message, " computed "), storedString), " stored: "), calculatedString);
        if (isTrue(!isEqual(key, null)))
        {
            errorMessage = add(add(add(add(add(add(" | ", key), " | "), "computed value: "), storedString), " stored value: "), calculatedString);
        }
        assert(cond, errorMessage);
    }

    public virtual object loadMarketsFromFile(object id)
    {
        // load markets from file
        // to make this test as fast as possible
        // and basically independent from the exchange
        // so we can run it offline
        object filename = add(add(add(this.rootDir, "./ts/src/test/static/markets/"), id), ".json");
        object content = ioFileRead(filename);
        return content;
    }

    public virtual object loadCurrenciesFromFile(object id)
    {
        object filename = add(add(add(this.rootDir, "./ts/src/test/static/currencies/"), id), ".json");
        object content = ioFileRead(filename);
        return content;
    }

    public virtual object loadStaticData(object folder, object targetExchange = null)
    {
        object result = new Dictionary<string, object>() {};
        if (isTrue(targetExchange))
        {
            // read a single exchange
            object path = add(add(folder, targetExchange), ".json");
            if (!isTrue(ioFileExists(path)))
            {
                dump(add("[WARN] tests not found: ", path));
                return null;
            }
            ((IDictionary<string,object>)result)[(string)targetExchange] = ioFileRead(path);
            return result;
        }
        object files = ioDirRead(folder);
        for (object i = 0; isLessThan(i, getArrayLength(files)); postFixIncrement(ref i))
        {
            object file = getValue(files, i);
            object exchangeName = ((string)file).Replace((string)".json", (string)"");
            object content = ioFileRead(add(folder, file));
            ((IDictionary<string,object>)result)[(string)exchangeName] = content;
        }
        return result;
    }

    public virtual object removeHostnamefromUrl(object url)
    {
        if (isTrue(isEqual(url, null)))
        {
            return null;
        }
        object urlParts = ((string)url).Split(new [] {((string)"/")}, StringSplitOptions.None).ToList<object>();
        object res = "";
        for (object i = 0; isLessThan(i, getArrayLength(urlParts)); postFixIncrement(ref i))
        {
            if (isTrue(isGreaterThan(i, 2)))
            {
                object current = getValue(urlParts, i);
                if (isTrue(isGreaterThan(getIndexOf(current, "?"), -1)))
                {
                    // handle urls like this: /v1/account/accounts?AccessK
                    object currentParts = ((string)current).Split(new [] {((string)"?")}, StringSplitOptions.None).ToList<object>();
                    res = add(res, "/");
                    res = add(res, getValue(currentParts, 0));
                    break;
                }
                res = add(res, "/");
                res = add(res, current);
            }
        }
        return res;
    }

    public virtual object urlencodedToDict(object url)
    {
        object result = new Dictionary<string, object>() {};
        object parts = ((string)url).Split(new [] {((string)"&")}, StringSplitOptions.None).ToList<object>();
        for (object i = 0; isLessThan(i, getArrayLength(parts)); postFixIncrement(ref i))
        {
            object part = getValue(parts, i);
            object keyValue = ((string)part).Split(new [] {((string)"=")}, StringSplitOptions.None).ToList<object>();
            object keysLength = getArrayLength(keyValue);
            if (isTrue(!isEqual(keysLength, 2)))
            {
                continue;
            }
            object key = getValue(keyValue, 0);
            object value = getValue(keyValue, 1);
            if (isTrue(isTrue((!isEqual(value, null))) && isTrue((isTrue((((string)value).StartsWith(((string)"[")))) || isTrue((((string)value).StartsWith(((string)"{"))))))))
            {
                // some exchanges might return something like this: timestamp=1699382693405&batchOrders=[{\"symbol\":\"LTCUSDT\",\"side\":\"BUY\",\"newClientOrderI
                value = jsonParse(value);
            }
            ((IDictionary<string,object>)result)[(string)key] = value;
        }
        return result;
    }

    public virtual object assertNewAndStoredOutput(Exchange exchange, object skipKeys, object newOutput, object storedOutput, object strictTypeCheck = null, object assertingKey = null)
    {
        strictTypeCheck ??= true;
        if (isTrue(isTrue(isNullValue(newOutput)) && isTrue(isNullValue(storedOutput))))
        {
            return true;
        }
        if (isTrue(!isTrue(newOutput) && !isTrue(storedOutput)))
        {
            return true;
        }
        if (isTrue(isTrue(((storedOutput is IDictionary<string, object>))) && isTrue(((newOutput is IDictionary<string, object>)))))
        {
            object storedOutputKeys = new List<object>(((IDictionary<string,object>)storedOutput).Keys);
            object newOutputKeys = new List<object>(((IDictionary<string,object>)newOutput).Keys);
            object storedKeysLength = getArrayLength(storedOutputKeys);
            object newKeysLength = getArrayLength(newOutputKeys);
            this.assertStaticError(isEqual(storedKeysLength, newKeysLength), "output length mismatch", storedOutput, newOutput);
            // iterate over the keys
            for (object i = 0; isLessThan(i, getArrayLength(storedOutputKeys)); postFixIncrement(ref i))
            {
                object key = getValue(storedOutputKeys, i);
                if (isTrue(exchange.inArray(key, skipKeys)))
                {
                    continue;
                }
                if (!isTrue((exchange.inArray(key, newOutputKeys))))
                {
                    this.assertStaticError(false, add("output key missing: ", key), storedOutput, newOutput);
                }
                object storedValue = getValue(storedOutput, key);
                object newValue = getValue(newOutput, key);
                this.assertNewAndStoredOutput(exchange, skipKeys, newValue, storedValue, strictTypeCheck, key);
            }
        } else if (isTrue(isTrue(((storedOutput is IList<object>) || (storedOutput.GetType().IsGenericType && storedOutput.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))) && isTrue((((newOutput is IList<object>) || (newOutput.GetType().IsGenericType && newOutput.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))))
        {
            object storedArrayLength = getArrayLength(storedOutput);
            object newArrayLength = getArrayLength(newOutput);
            this.assertStaticError(isEqual(storedArrayLength, newArrayLength), "output length mismatch", storedOutput, newOutput);
            for (object i = 0; isLessThan(i, getArrayLength(storedOutput)); postFixIncrement(ref i))
            {
                object storedItem = getValue(storedOutput, i);
                object newItem = getValue(newOutput, i);
                this.assertNewAndStoredOutput(exchange, skipKeys, newItem, storedItem, strictTypeCheck);
            }
        } else
        {
            // built-in types like strings, numbers, booleans
            object sanitizedNewOutput = ((bool) isTrue((!isTrue(newOutput)))) ? null : newOutput; // we store undefined as nulls in the json file so we need to convert it back
            object sanitizedStoredOutput = ((bool) isTrue((!isTrue(storedOutput)))) ? null : storedOutput;
            object newOutputString = ((bool) isTrue(sanitizedNewOutput)) ? ((object)sanitizedNewOutput).ToString() : "undefined";
            object storedOutputString = ((bool) isTrue(sanitizedStoredOutput)) ? ((object)sanitizedStoredOutput).ToString() : "undefined";
            object messageError = add(add(add("output value mismatch:", newOutputString), " != "), storedOutputString);
            if (isTrue(isTrue(strictTypeCheck) && isTrue((!isEqual(this.lang, "C#")))))
            {
                // upon building the request we want strict type check to make sure all the types are correct
                // when comparing the response we want to allow some flexibility, because a 50.0 can be equal to 50 after saving it to the json file
                this.assertStaticError(isEqual(sanitizedNewOutput, sanitizedStoredOutput), messageError, storedOutput, newOutput, assertingKey);
            } else
            {
                object isBoolean = isTrue(((sanitizedNewOutput is bool))) || isTrue(((sanitizedStoredOutput is bool)));
                object isString = isTrue(((sanitizedNewOutput is string))) || isTrue(((sanitizedStoredOutput is string)));
                object isUndefined = isTrue((isEqual(sanitizedNewOutput, null))) || isTrue((isEqual(sanitizedStoredOutput, null))); // undefined is a perfetly valid value
                if (isTrue(isTrue(isTrue(isBoolean) || isTrue(isString)) || isTrue(isUndefined)))
                {
                    if (isTrue(isEqual(this.lang, "C#")))
                    {
                        // tmp c# number comparsion
                        object isNumber = false;
                        try
                        {
                            exchange.parseToNumeric(sanitizedNewOutput);
                            isNumber = true;
                        } catch(Exception e)
                        {
                            // if we can't parse it to number, then it's not a number
                            isNumber = false;
                        }
                        if (isTrue(isNumber))
                        {
                            this.assertStaticError(isEqual(exchange.parseToNumeric(sanitizedNewOutput), exchange.parseToNumeric(sanitizedStoredOutput)), messageError, storedOutput, newOutput, assertingKey);
                            return true;
                        } else
                        {
                            this.assertStaticError(isEqual(convertAscii(newOutputString), convertAscii(storedOutputString)), messageError, storedOutput, newOutput, assertingKey);
                            return true;
                        }
                    } else
                    {
                        this.assertStaticError(isEqual(convertAscii(newOutputString), convertAscii(storedOutputString)), messageError, storedOutput, newOutput, assertingKey);
                        return true;
                    }
                } else
                {
                    if (isTrue(isEqual(this.lang, "C#")))
                    {
                        object stringifiedNewOutput = exchange.numberToString(sanitizedNewOutput);
                        object stringifiedStoredOutput = exchange.numberToString(sanitizedStoredOutput);
                        this.assertStaticError(isEqual(((object)stringifiedNewOutput).ToString(), ((object)stringifiedStoredOutput).ToString()), messageError, storedOutput, newOutput, assertingKey);
                    } else
                    {
                        object numericNewOutput = exchange.parseToNumeric(newOutputString);
                        object numericStoredOutput = exchange.parseToNumeric(storedOutputString);
                        this.assertStaticError(isEqual(numericNewOutput, numericStoredOutput), messageError, storedOutput, newOutput, assertingKey);
                    }
                }
            }
        }
        return true;  // c# requ
    }

    public virtual void assertStaticRequestOutput(Exchange exchange, object type, object skipKeys, object storedUrl, object requestUrl, object storedOutput, object newOutput)
    {
        if (isTrue(!isEqual(storedUrl, requestUrl)))
        {
            // remove the host part from the url
            object firstPath = this.removeHostnamefromUrl(storedUrl);
            object secondPath = this.removeHostnamefromUrl(requestUrl);
            this.assertStaticError(isEqual(firstPath, secondPath), "url mismatch", firstPath, secondPath);
        }
        // body (aka storedOutput and newOutput) is not defined and information is in the url
        // example: "https://open-api.bingx.com/openApi/spot/v1/trade/order?quoteOrderQty=5&side=BUY&symbol=LTC-USDT&timestamp=1698777135343&type=MARKET&signature=d55a7e4f7f9dbe56c4004c9f3ab340869d3cb004e2f0b5b861e5fbd1762fd9a0
        if (isTrue(isTrue((isEqual(storedOutput, null))) && isTrue((isEqual(newOutput, null)))))
        {
            if (isTrue(isTrue((!isEqual(storedUrl, null))) && isTrue((!isEqual(requestUrl, null)))))
            {
                object storedUrlParts = ((string)storedUrl).Split(new [] {((string)"?")}, StringSplitOptions.None).ToList<object>();
                object newUrlParts = ((string)requestUrl).Split(new [] {((string)"?")}, StringSplitOptions.None).ToList<object>();
                object storedUrlQuery = exchange.safeValue(storedUrlParts, 1);
                object newUrlQuery = exchange.safeValue(newUrlParts, 1);
                if (isTrue(isTrue((isEqual(storedUrlQuery, null))) && isTrue((isEqual(newUrlQuery, null)))))
                {
                    // might be a get request without any query parameters
                    // example: https://api.gateio.ws/api/v4/delivery/usdt/positions
                    return;
                }
                object storedUrlParams = this.urlencodedToDict(storedUrlQuery);
                object newUrlParams = this.urlencodedToDict(newUrlQuery);
                this.assertNewAndStoredOutput(exchange, skipKeys, newUrlParams, storedUrlParams);
                return;
            }
        }
        if (isTrue(isTrue(isTrue(isEqual(type, "json")) && isTrue((!isEqual(storedOutput, null)))) && isTrue((!isEqual(newOutput, null)))))
        {
            if (isTrue((storedOutput is string)))
            {
                storedOutput = jsonParse(storedOutput);
            }
            if (isTrue((newOutput is string)))
            {
                newOutput = jsonParse(newOutput);
            }
        } else if (isTrue(isTrue(isTrue(isEqual(type, "urlencoded")) && isTrue((!isEqual(storedOutput, null)))) && isTrue((!isEqual(newOutput, null)))))
        {
            storedOutput = this.urlencodedToDict(storedOutput);
            newOutput = this.urlencodedToDict(newOutput);
        } else if (isTrue(isEqual(type, "both")))
        {
            if (isTrue(isTrue(((string)storedOutput).StartsWith(((string)"{"))) || isTrue(((string)storedOutput).StartsWith(((string)"[")))))
            {
                storedOutput = jsonParse(storedOutput);
                newOutput = jsonParse(newOutput);
            } else
            {
                storedOutput = this.urlencodedToDict(storedOutput);
                newOutput = this.urlencodedToDict(newOutput);
            }
        }
        this.assertNewAndStoredOutput(exchange, skipKeys, newOutput, storedOutput);
    }

    public virtual void assertStaticResponseOutput(Exchange exchange, object skipKeys, object computedResult, object storedResult)
    {
        this.assertNewAndStoredOutput(exchange, skipKeys, computedResult, storedResult, false);
    }

    public virtual object sanitizeDataInput(object input)
    {
        // remove nulls and replace with unefined instead
        if (isTrue(isEqual(input, null)))
        {
            return null;
        }
        object newInput = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(input)); postFixIncrement(ref i))
        {
            object current = getValue(input, i);
            if (isTrue(isNullValue(current)))
            {
                ((IList<object>)newInput).Add(null);
            } else
            {
                ((IList<object>)newInput).Add(current);
            }
        }
        return newInput;
    }

    public async virtual Task testMethodStatically(Exchange exchange, object method, object data, object type, object skipKeys)
    {
        object output = null;
        object requestUrl = null;
        try
        {
            await callExchangeMethodDynamically(exchange, method, this.sanitizeDataInput(getValue(data, "input")));
        } catch(Exception e)
        {
            if (!isTrue((e is ProxyError)))
            {
                throw e;
            }
            output = exchange.last_request_body;
            requestUrl = exchange.last_request_url;
        }
        try
        {
            object callOutput = exchange.safeValue(data, "output");
            this.assertStaticRequestOutput(exchange, type, skipKeys, getValue(data, "url"), requestUrl, callOutput, output);
        } catch(Exception e)
        {
            this.requestTestsFailed = true;
            object errorMessage = add(add(add(add(add(add(add(add(add(add(add(add("[", this.lang), "][STATIC_REQUEST_TEST_FAILURE]"), "["), this.exchangeHint(exchange)), "]"), "["), method), "]"), "["), getValue(data, "description")), "]"), ((object)e).ToString());
            dump(add("[TEST_FAILURE]", errorMessage));
        }
    }

    public async virtual Task testResponseStatically(Exchange exchange, object method, object skipKeys, object data)
    {
        object expectedResult = exchange.safeValue(data, "parsedResponse");
        var mockedExchange = setFetchResponse(exchange, getValue(data, "httpResponse"));
        try
        {
            object unifiedResult = await callExchangeMethodDynamically(exchange, method, this.sanitizeDataInput(getValue(data, "input")));
            this.assertStaticResponseOutput(mockedExchange, skipKeys, unifiedResult, expectedResult);
        } catch(Exception e)
        {
            this.requestTestsFailed = true;
            object errorMessage = add(add(add(add(add(add(add(add(add(add(add(add("[", this.lang), "][STATIC_RESPONSE_TEST_FAILURE]"), "["), this.exchangeHint(exchange)), "]"), "["), method), "]"), "["), getValue(data, "description")), "]"), ((object)e).ToString());
            dump(add("[TEST_FAILURE]", errorMessage));
        }
        setFetchResponse(exchange, null); // reset state
    }

    public virtual Exchange initOfflineExchange(object exchangeName)
    {
        object markets = this.loadMarketsFromFile(exchangeName);
        object currencies = this.loadCurrenciesFromFile(exchangeName);
        Exchange exchange = initExchange(exchangeName, new Dictionary<string, object>() {
            { "markets", markets },
            { "currencies", currencies },
            { "enableRateLimit", false },
            { "rateLimit", 1 },
            { "httpProxy", "http://fake:8080" },
            { "httpsProxy", "http://fake:8080" },
            { "apiKey", "key" },
            { "secret", "secretsecret" },
            { "password", "password" },
            { "walletAddress", "wallet" },
            { "privateKey", "0xff3bdd43534543d421f05aec535965b5050ad6ac15345435345435453495e771" },
            { "uid", "uid" },
            { "token", "token" },
            { "accounts", new List<object>() {new Dictionary<string, object>() {
    { "id", "myAccount" },
    { "code", "USDT" },
}, new Dictionary<string, object>() {
    { "id", "myAccount" },
    { "code", "USDC" },
}} },
            { "options", new Dictionary<string, object>() {
                { "enableUnifiedAccount", true },
                { "enableUnifiedMargin", false },
                { "accessToken", "token" },
                { "expires", 999999999999999 },
                { "leverageBrackets", new Dictionary<string, object>() {} },
            } },
        });
        exchange.currencies = currencies; // not working in python if assigned  in the config dict
        return exchange;
    }

    public async virtual Task<object> testExchangeRequestStatically(object exchangeName, object exchangeData, object testName = null)
    {
        // instantiate the exchange and make sure that we sink the requests to avoid an actual request
        Exchange exchange = this.initOfflineExchange(exchangeName);
        object globalOptions = exchange.safeDict(exchangeData, "options", new Dictionary<string, object>() {});
        // exchange.options = exchange.deepExtend (exchange.options, globalOptions); // custom options to be used in the tests
        exchange.extendExchangeOptions(globalOptions);
        object methods = exchange.safeValue(exchangeData, "methods", new Dictionary<string, object>() {});
        object methodsNames = new List<object>(((IDictionary<string,object>)methods).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(methodsNames)); postFixIncrement(ref i))
        {
            object method = getValue(methodsNames, i);
            object results = getValue(methods, method);
            for (object j = 0; isLessThan(j, getArrayLength(results)); postFixIncrement(ref j))
            {
                object result = getValue(results, j);
                object oldExchangeOptions = exchange.options; // snapshot options;
                object testExchangeOptions = exchange.safeValue(result, "options", new Dictionary<string, object>() {});
                // exchange.options = exchange.deepExtend (oldExchangeOptions, testExchangeOptions); // custom options to be used in the tests
                exchange.extendExchangeOptions(exchange.deepExtend(oldExchangeOptions, testExchangeOptions));
                object description = exchange.safeValue(result, "description");
                if (isTrue(isTrue((!isEqual(testName, null))) && isTrue((!isEqual(testName, description)))))
                {
                    continue;
                }
                object isDisabled = exchange.safeBool(result, "disabled", false);
                if (isTrue(isDisabled))
                {
                    continue;
                }
                object type = exchange.safeString(exchangeData, "outputType");
                object skipKeys = exchange.safeValue(exchangeData, "skipKeys", new List<object>() {});
                await this.testMethodStatically(exchange, method, result, type, skipKeys);
                // reset options
                // exchange.options = exchange.deepExtend (oldExchangeOptions, {});
                exchange.extendExchangeOptions(exchange.deepExtend(oldExchangeOptions, new Dictionary<string, object>() {}));
            }
        }
        await close(exchange);
        return true;  // in c# methods that will be used with promiseAll need to return something
    }

    public async virtual Task<object> testExchangeResponseStatically(object exchangeName, object exchangeData, object testName = null)
    {
        Exchange exchange = this.initOfflineExchange(exchangeName);
        object methods = exchange.safeValue(exchangeData, "methods", new Dictionary<string, object>() {});
        object options = exchange.safeValue(exchangeData, "options", new Dictionary<string, object>() {});
        // exchange.options = exchange.deepExtend (exchange.options, options); // custom options to be used in the tests
        exchange.extendExchangeOptions(options);
        object methodsNames = new List<object>(((IDictionary<string,object>)methods).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(methodsNames)); postFixIncrement(ref i))
        {
            object method = getValue(methodsNames, i);
            object results = getValue(methods, method);
            for (object j = 0; isLessThan(j, getArrayLength(results)); postFixIncrement(ref j))
            {
                object result = getValue(results, j);
                object description = exchange.safeValue(result, "description");
                object oldExchangeOptions = exchange.options; // snapshot options;
                object testExchangeOptions = exchange.safeValue(result, "options", new Dictionary<string, object>() {});
                // exchange.options = exchange.deepExtend (oldExchangeOptions, testExchangeOptions); // custom options to be used in the tests
                exchange.extendExchangeOptions(exchange.deepExtend(oldExchangeOptions, testExchangeOptions));
                object isDisabled = exchange.safeBool(result, "disabled", false);
                if (isTrue(isDisabled))
                {
                    continue;
                }
                object isDisabledCSharp = exchange.safeBool(result, "disabledCS", false);
                if (isTrue(isTrue(isDisabledCSharp) && isTrue((isEqual(this.lang, "C#")))))
                {
                    continue;
                }
                object isDisabledPHP = exchange.safeBool(result, "disabledPHP", false);
                if (isTrue(isTrue(isDisabledPHP) && isTrue((isEqual(this.lang, "PHP")))))
                {
                    continue;
                }
                if (isTrue(isTrue((!isEqual(testName, null))) && isTrue((!isEqual(testName, description)))))
                {
                    continue;
                }
                object skipKeys = exchange.safeValue(exchangeData, "skipKeys", new List<object>() {});
                await this.testResponseStatically(exchange, method, skipKeys, result);
                // reset options
                // exchange.options = exchange.deepExtend (oldExchangeOptions, {});
                exchange.extendExchangeOptions(exchange.deepExtend(oldExchangeOptions, new Dictionary<string, object>() {}));
            }
        }
        await close(exchange);
        return true;  // in c# methods that will be used with promiseAll need to return something
    }

    public virtual object getNumberOfTestsFromExchange(Exchange exchange, object exchangeData, object testName = null)
    {
        if (isTrue(!isEqual(testName, null)))
        {
            return 1;
        }
        object sum = 0;
        object methods = getValue(exchangeData, "methods");
        object methodsNames = new List<object>(((IDictionary<string,object>)methods).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(methodsNames)); postFixIncrement(ref i))
        {
            object method = getValue(methodsNames, i);
            object results = getValue(methods, method);
            object resultsLength = getArrayLength(results);
            sum = exchange.sum(sum, resultsLength);
        }
        return sum;
    }

    public async virtual Task runStaticRequestTests(object targetExchange = null, object testName = null)
    {
        await this.runStaticTests("request", targetExchange, testName);
    }

    public async virtual Task runStaticTests(object type, object targetExchange = null, object testName = null)
    {
        object folder = add(add(add(this.rootDir, "./ts/src/test/static/"), type), "/");
        object staticData = this.loadStaticData(folder, targetExchange);
        if (isTrue(isEqual(staticData, null)))
        {
            return;
        }
        object exchanges = new List<object>(((IDictionary<string,object>)staticData).Keys);
        Exchange exchange = initExchange("Exchange", new Dictionary<string, object>() {}); // tmp to do the calculations until we have the ast-transpiler transpiling this code
        object promises = new List<object>() {};
        object sum = 0;
        if (isTrue(targetExchange))
        {
            dump(add("[INFO:MAIN] Exchange to test: ", targetExchange));
        }
        if (isTrue(testName))
        {
            dump(add("[INFO:MAIN] Testing only: ", testName));
        }
        for (object i = 0; isLessThan(i, getArrayLength(exchanges)); postFixIncrement(ref i))
        {
            object exchangeName = getValue(exchanges, i);
            object exchangeData = getValue(staticData, exchangeName);
            object numberOfTests = this.getNumberOfTestsFromExchange(exchange, exchangeData, testName);
            sum = exchange.sum(sum, numberOfTests);
            if (isTrue(isEqual(type, "request")))
            {
                ((IList<object>)promises).Add(this.testExchangeRequestStatically(exchangeName, exchangeData, testName));
            } else
            {
                ((IList<object>)promises).Add(this.testExchangeResponseStatically(exchangeName, exchangeData, testName));
            }
        }
        await promiseAll(promises);
        if (isTrue(isTrue(this.requestTestsFailed) || isTrue(this.responseTestsFailed)))
        {
            exitScript(1);
        } else
        {
            object successMessage = add(add(add(add(add(add("[", this.lang), "][TEST_SUCCESS] "), ((object)sum).ToString()), " static "), type), " tests passed.");
            dump(add("[INFO]", successMessage));
        }
    }

    public async virtual Task runStaticResponseTests(object exchangeName = null, object test = null)
    {
        //  -----------------------------------------------------------------------------
        //  --- Init of mockResponses tests functions------------------------------------
        //  -----------------------------------------------------------------------------
        await this.runStaticTests("response", exchangeName, test);
    }

    public async virtual Task runBrokerIdTests()
    {
        //  -----------------------------------------------------------------------------
        //  --- Init of brokerId tests functions-----------------------------------------
        //  -----------------------------------------------------------------------------
        object promises = new List<object> {this.testBinance(), this.testOkx(), this.testCryptocom(), this.testBybit(), this.testKucoin(), this.testKucoinfutures(), this.testBitget(), this.testMexc(), this.testHtx(), this.testWoo(), this.testBitmart(), this.testCoinex(), this.testBingx(), this.testPhemex(), this.testBlofin(), this.testHyperliquid(), this.testCoinbaseinternational(), this.testCoinbaseAdvanced()};
        await promiseAll(promises);
        object successMessage = add(add("[", this.lang), "][TEST_SUCCESS] brokerId tests passed.");
        dump(add("[INFO]", successMessage));
        exitScript(0);
    }

    public async virtual Task<object> testBinance()
    {
        Exchange exchange = this.initOfflineExchange("binance");
        object spotId = "x-R4BD3S82";
        object spotOrderRequest = null;
        try
        {
            await exchange.createOrder("BTC/USDT", "limit", "buy", 1, 20000);
        } catch(Exception e)
        {
            spotOrderRequest = this.urlencodedToDict(exchange.last_request_body);
        }
        object clientOrderId = getValue(spotOrderRequest, "newClientOrderId");
        object spotIdString = ((object)spotId).ToString();
        assert(((string)clientOrderId).StartsWith(((string)spotIdString)), add(add(add("binance - spot clientOrderId: ", clientOrderId), " does not start with spotId"), spotIdString));
        object swapId = "x-xcKtGhcu";
        object swapOrderRequest = null;
        try
        {
            await exchange.createOrder("BTC/USDT:USDT", "limit", "buy", 1, 20000);
        } catch(Exception e)
        {
            swapOrderRequest = this.urlencodedToDict(exchange.last_request_body);
        }
        object swapInverseOrderRequest = null;
        try
        {
            await exchange.createOrder("BTC/USD:BTC", "limit", "buy", 1, 20000);
        } catch(Exception e)
        {
            swapInverseOrderRequest = this.urlencodedToDict(exchange.last_request_body);
        }
        object clientOrderIdSwap = getValue(swapOrderRequest, "newClientOrderId");
        object swapIdString = ((object)swapId).ToString();
        assert(((string)clientOrderIdSwap).StartsWith(((string)swapIdString)), add(add(add("binance - swap clientOrderId: ", clientOrderIdSwap), " does not start with swapId"), swapIdString));
        object clientOrderIdInverse = getValue(swapInverseOrderRequest, "newClientOrderId");
        assert(((string)clientOrderIdInverse).StartsWith(((string)swapIdString)), add(add(add("binance - swap clientOrderIdInverse: ", clientOrderIdInverse), " does not start with swapId"), swapIdString));
        await close(exchange);
        return true;
    }

    public async virtual Task<object> testOkx()
    {
        Exchange exchange = this.initOfflineExchange("okx");
        object id = "e847386590ce4dBC";
        object spotOrderRequest = null;
        try
        {
            await exchange.createOrder("BTC/USDT", "limit", "buy", 1, 20000);
        } catch(Exception e)
        {
            spotOrderRequest = jsonParse(exchange.last_request_body);
        }
        object clientOrderId = getValue(getValue(spotOrderRequest, 0), "clOrdId"); // returns order inside array
        object idString = ((object)id).ToString();
        assert(((string)clientOrderId).StartsWith(((string)idString)), add(add(add("okx - spot clientOrderId: ", clientOrderId), " does not start with id: "), idString));
        object spotTag = getValue(getValue(spotOrderRequest, 0), "tag");
        assert(isEqual(spotTag, id), add(add(add("okx - id: ", id), " different from spot tag: "), spotTag));
        object swapOrderRequest = null;
        try
        {
            await exchange.createOrder("BTC/USDT:USDT", "limit", "buy", 1, 20000);
        } catch(Exception e)
        {
            swapOrderRequest = jsonParse(exchange.last_request_body);
        }
        object clientOrderIdSwap = getValue(getValue(swapOrderRequest, 0), "clOrdId");
        assert(((string)clientOrderIdSwap).StartsWith(((string)idString)), add(add(add("okx - swap clientOrderId: ", clientOrderIdSwap), " does not start with id: "), idString));
        object swapTag = getValue(getValue(swapOrderRequest, 0), "tag");
        assert(isEqual(swapTag, id), add(add(add("okx - id: ", id), " different from swap tag: "), swapTag));
        await close(exchange);
        return true;
    }

    public async virtual Task<object> testCryptocom()
    {
        Exchange exchange = this.initOfflineExchange("cryptocom");
        object id = "CCXT";
        await exchange.loadMarkets();
        object request = null;
        try
        {
            await exchange.createOrder("BTC/USDT", "limit", "buy", 1, 20000);
        } catch(Exception e)
        {
            request = jsonParse(exchange.last_request_body);
        }
        object brokerId = getValue(getValue(request, "params"), "broker_id");
        assert(isEqual(brokerId, id), add(add(add("cryptocom - id: ", id), " different from  broker_id: "), brokerId));
        await close(exchange);
        return true;
    }

    public async virtual Task<object> testBybit()
    {
        Exchange exchange = this.initOfflineExchange("bybit");
        object reqHeaders = null;
        object id = "CCXT";
        assert(isEqual(getValue(exchange.options, "brokerId"), id), "id not in options");
        try
        {
            await exchange.createOrder("BTC/USDT", "limit", "buy", 1, 20000);
        } catch(Exception e)
        {
            // we expect an error here, we're only interested in the headers
            reqHeaders = exchange.last_request_headers;
        }
        assert(isEqual(getValue(reqHeaders, "Referer"), id), add(add("bybit - id: ", id), " not in headers."));
        await close(exchange);
        return true;
    }

    public async virtual Task<object> testKucoin()
    {
        Exchange exchange = this.initOfflineExchange("kucoin");
        object reqHeaders = null;
        object spotId = getValue(getValue(getValue(exchange.options, "partner"), "spot"), "id");
        object spotKey = getValue(getValue(getValue(exchange.options, "partner"), "spot"), "key");
        assert(isEqual(spotId, "ccxt"), add(add("kucoin - id: ", spotId), " not in options"));
        assert(isEqual(spotKey, "9e58cc35-5b5e-4133-92ec-166e3f077cb8"), add(add("kucoin - key: ", spotKey), " not in options."));
        try
        {
            await exchange.createOrder("BTC/USDT", "limit", "buy", 1, 20000);
        } catch(Exception e)
        {
            // we expect an error here, we're only interested in the headers
            reqHeaders = exchange.last_request_headers;
        }
        object id = "ccxt";
        assert(isEqual(getValue(reqHeaders, "KC-API-PARTNER"), id), add(add("kucoin - id: ", id), " not in headers."));
        await close(exchange);
        return true;
    }

    public async virtual Task<object> testKucoinfutures()
    {
        Exchange exchange = this.initOfflineExchange("kucoinfutures");
        object reqHeaders = null;
        object id = "ccxtfutures";
        object futureId = getValue(getValue(getValue(exchange.options, "partner"), "future"), "id");
        object futureKey = getValue(getValue(getValue(exchange.options, "partner"), "future"), "key");
        assert(isEqual(futureId, id), add(add("kucoinfutures - id: ", futureId), " not in options."));
        assert(isEqual(futureKey, "1b327198-f30c-4f14-a0ac-918871282f15"), add(add("kucoinfutures - key: ", futureKey), " not in options."));
        try
        {
            await exchange.createOrder("BTC/USDT:USDT", "limit", "buy", 1, 20000);
        } catch(Exception e)
        {
            reqHeaders = exchange.last_request_headers;
        }
        assert(isEqual(getValue(reqHeaders, "KC-API-PARTNER"), id), add(add("kucoinfutures - id: ", id), " not in headers."));
        await close(exchange);
        return true;
    }

    public async virtual Task<object> testBitget()
    {
        Exchange exchange = this.initOfflineExchange("bitget");
        object reqHeaders = null;
        object id = "p4sve";
        assert(isEqual(getValue(exchange.options, "broker"), id), add(add("bitget - id: ", id), " not in options"));
        try
        {
            await exchange.createOrder("BTC/USDT", "limit", "buy", 1, 20000);
        } catch(Exception e)
        {
            reqHeaders = exchange.last_request_headers;
        }
        assert(isEqual(getValue(reqHeaders, "X-CHANNEL-API-CODE"), id), add(add("bitget - id: ", id), " not in headers."));
        await close(exchange);
        return true;
    }

    public async virtual Task<object> testMexc()
    {
        Exchange exchange = this.initOfflineExchange("mexc");
        object reqHeaders = null;
        object id = "CCXT";
        assert(isEqual(getValue(exchange.options, "broker"), id), add(add("mexc - id: ", id), " not in options"));
        await exchange.loadMarkets();
        try
        {
            await exchange.createOrder("BTC/USDT", "limit", "buy", 1, 20000);
        } catch(Exception e)
        {
            reqHeaders = exchange.last_request_headers;
        }
        assert(isEqual(getValue(reqHeaders, "source"), id), add(add("mexc - id: ", id), " not in headers."));
        await close(exchange);
        return true;
    }

    public async virtual Task<object> testHtx()
    {
        Exchange exchange = this.initOfflineExchange("htx");
        // spot test
        object id = "AA03022abc";
        object spotOrderRequest = null;
        try
        {
            await exchange.createOrder("BTC/USDT", "limit", "buy", 1, 20000);
        } catch(Exception e)
        {
            spotOrderRequest = jsonParse(exchange.last_request_body);
        }
        object clientOrderId = getValue(spotOrderRequest, "client-order-id");
        object idString = ((object)id).ToString();
        assert(((string)clientOrderId).StartsWith(((string)idString)), add(add(add("htx - spot clientOrderId ", clientOrderId), " does not start with id: "), idString));
        // swap test
        object swapOrderRequest = null;
        try
        {
            await exchange.createOrder("BTC/USDT:USDT", "limit", "buy", 1, 20000);
        } catch(Exception e)
        {
            swapOrderRequest = jsonParse(exchange.last_request_body);
        }
        object swapInverseOrderRequest = null;
        try
        {
            await exchange.createOrder("BTC/USD:BTC", "limit", "buy", 1, 20000);
        } catch(Exception e)
        {
            swapInverseOrderRequest = jsonParse(exchange.last_request_body);
        }
        object clientOrderIdSwap = getValue(swapOrderRequest, "channel_code");
        assert(((string)clientOrderIdSwap).StartsWith(((string)idString)), add(add(add("htx - swap channel_code ", clientOrderIdSwap), " does not start with id: "), idString));
        object clientOrderIdInverse = getValue(swapInverseOrderRequest, "channel_code");
        assert(((string)clientOrderIdInverse).StartsWith(((string)idString)), add(add(add("htx - swap inverse channel_code ", clientOrderIdInverse), " does not start with id: "), idString));
        await close(exchange);
        return true;
    }

    public async virtual Task<object> testWoo()
    {
        Exchange exchange = this.initOfflineExchange("woo");
        // spot test
        object id = "bc830de7-50f3-460b-9ee0-f430f83f9dad";
        object spotOrderRequest = null;
        try
        {
            await exchange.createOrder("BTC/USDT", "limit", "buy", 1, 20000);
        } catch(Exception e)
        {
            spotOrderRequest = this.urlencodedToDict(exchange.last_request_body);
        }
        object brokerId = getValue(spotOrderRequest, "broker_id");
        object idString = ((object)id).ToString();
        assert(((string)brokerId).StartsWith(((string)idString)), add(add(add("woo - broker_id: ", brokerId), " does not start with id: "), idString));
        // swap test
        object stopOrderRequest = null;
        try
        {
            await exchange.createOrder("BTC/USDT:USDT", "limit", "buy", 1, 20000, new Dictionary<string, object>() {
                { "stopPrice", 30000 },
            });
        } catch(Exception e)
        {
            stopOrderRequest = jsonParse(exchange.last_request_body);
        }
        object clientOrderIdStop = getValue(stopOrderRequest, "brokerId");
        assert(((string)clientOrderIdStop).StartsWith(((string)idString)), add(add(add("woo - brokerId: ", clientOrderIdStop), " does not start with id: "), idString));
        await close(exchange);
        return true;
    }

    public async virtual Task<object> testBitmart()
    {
        Exchange exchange = this.initOfflineExchange("bitmart");
        object reqHeaders = null;
        object id = "CCXTxBitmart000";
        assert(isEqual(getValue(exchange.options, "brokerId"), id), add(add("bitmart - id: ", id), " not in options"));
        await exchange.loadMarkets();
        try
        {
            await exchange.createOrder("BTC/USDT", "limit", "buy", 1, 20000);
        } catch(Exception e)
        {
            reqHeaders = exchange.last_request_headers;
        }
        assert(isEqual(getValue(reqHeaders, "X-BM-BROKER-ID"), id), add(add("bitmart - id: ", id), " not in headers"));
        await close(exchange);
        return true;
    }

    public async virtual Task<object> testCoinex()
    {
        Exchange exchange = this.initOfflineExchange("coinex");
        object id = "x-167673045";
        assert(isEqual(getValue(exchange.options, "brokerId"), id), add(add("coinex - id: ", id), " not in options"));
        object spotOrderRequest = null;
        try
        {
            await exchange.createOrder("BTC/USDT", "limit", "buy", 1, 20000);
        } catch(Exception e)
        {
            spotOrderRequest = jsonParse(exchange.last_request_body);
        }
        object clientOrderId = getValue(spotOrderRequest, "client_id");
        object idString = ((object)id).ToString();
        assert(((string)clientOrderId).StartsWith(((string)idString)), add(add(add("coinex - clientOrderId: ", clientOrderId), " does not start with id: "), idString));
        await close(exchange);
        return true;
    }

    public async virtual Task testBingx()
    {
        Exchange exchange = this.initOfflineExchange("bingx");
        object reqHeaders = null;
        object id = "CCXT";
        assert(isEqual(getValue(exchange.options, "broker"), id), add(add("bingx - id: ", id), " not in options"));
        try
        {
            await exchange.createOrder("BTC/USDT", "limit", "buy", 1, 20000);
        } catch(Exception e)
        {
            // we expect an error here, we're only interested in the headers
            reqHeaders = exchange.last_request_headers;
        }
        assert(isEqual(getValue(reqHeaders, "X-SOURCE-KEY"), id), add(add("bingx - id: ", id), " not in headers."));
        await close(exchange);
    }

    public async virtual Task testPhemex()
    {
        Exchange exchange = this.initOfflineExchange("phemex");
        object id = "CCXT123456";
        object request = null;
        try
        {
            await exchange.createOrder("BTC/USDT", "limit", "buy", 1, 20000);
        } catch(Exception e)
        {
            request = jsonParse(exchange.last_request_body);
        }
        object clientOrderId = getValue(request, "clOrdID");
        object idString = ((object)id).ToString();
        assert(((string)clientOrderId).StartsWith(((string)idString)), add(add(add("phemex - clOrdID: ", clientOrderId), " does not start with id: "), idString));
        await close(exchange);
    }

    public async virtual Task testBlofin()
    {
        Exchange exchange = this.initOfflineExchange("blofin");
        object id = "ec6dd3a7dd982d0b";
        object request = null;
        try
        {
            await exchange.createOrder("LTC/USDT:USDT", "market", "buy", 1);
        } catch(Exception e)
        {
            request = jsonParse(exchange.last_request_body);
        }
        object brokerId = getValue(request, "brokerId");
        object idString = ((object)id).ToString();
        assert(((string)brokerId).StartsWith(((string)idString)), add(add(add("blofin - brokerId: ", brokerId), " does not start with id: "), idString));
        await close(exchange);
    }

    public async virtual Task testHyperliquid()
    {
        Exchange exchange = this.initOfflineExchange("hyperliquid");
        object id = "1";
        object request = null;
        try
        {
            await exchange.createOrder("SOL/USDC:USDC", "limit", "buy", 1, 100);
        } catch(Exception e)
        {
            request = jsonParse(exchange.last_request_body);
        }
        object brokerId = ((object)(getValue(getValue(request, "action"), "brokerCode"))).ToString();
        assert(isEqual(brokerId, id), add(add(add("hyperliquid - brokerId: ", brokerId), " does not start with id: "), id));
        await close(exchange);
    }

    public async virtual Task<object> testCoinbaseinternational()
    {
        Exchange exchange = this.initOfflineExchange("coinbaseinternational");
        ((IDictionary<string,object>)exchange.options)["portfolio"] = "random";
        object id = "nfqkvdjp";
        assert(isEqual(getValue(exchange.options, "brokerId"), id), "id not in options");
        object request = null;
        try
        {
            await exchange.createOrder("BTC/USDC:USDC", "limit", "buy", 1, 20000);
        } catch(Exception e)
        {
            request = jsonParse(exchange.last_request_body);
        }
        object clientOrderId = getValue(request, "client_order_id");
        assert(((string)clientOrderId).StartsWith(((string)((object)id).ToString())), "clientOrderId does not start with id");
        await close(exchange);
        return true;
    }

    public async virtual Task<object> testCoinbaseAdvanced()
    {
        Exchange exchange = this.initOfflineExchange("coinbase");
        object id = "ccxt";
        assert(isEqual(getValue(exchange.options, "brokerId"), id), "id not in options");
        object request = null;
        try
        {
            await exchange.createOrder("BTC/USDC", "limit", "buy", 1, 20000);
        } catch(Exception e)
        {
            request = jsonParse(exchange.last_request_body);
        }
        object clientOrderId = getValue(request, "client_order_id");
        assert(((string)clientOrderId).StartsWith(((string)((object)id).ToString())), "clientOrderId does not start with id");
        await close(exchange);
        return true;
    }
}
