using ccxt.pro;
namespace Tests;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class BaseTest
{
    public void CacheTests()
    {
        var arrayCache = new ArrayCache(3);
        arrayCache.append(new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "data", 1 },
        });
        arrayCache.append(new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "data", 2 },
        });
        arrayCache.append(new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "data", 3 },
        });
        arrayCache.append(new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "data", 4 },
        });
        Assert(equals(arrayCache, new List<object>() {new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "data", 2 },
        }, new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "data", 3 },
        }, new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "data", 4 },
        }}));
        arrayCache.append(new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "data", 5 },
        });
        arrayCache.append(new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "data", 6 },
        });
        arrayCache.append(new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "data", 7 },
        });
        arrayCache.append(new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "data", 8 },
        });
        Assert(equals(arrayCache, new List<object>() {new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "data", 6 },
        }, new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "data", 7 },
        }, new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "data", 8 },
        }}));
        arrayCache.clear();
        arrayCache.append(new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "data", 1 },
        });
        Assert(equals(arrayCache, new List<object>() {new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "data", 1 },
        }}));
        
        // ----------------------------------------------------------------------------
        
        var arraycache2 = new ArrayCache(1);
        arraycache2.append(new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "data", 1 },
        });
        arraycache2.append(new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "data", 2 },
        });
        Assert(equals(arraycache2, new List<object>() {new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "data", 2 },
        }}));
        
        // ----------------------------------------------------------------------------
        
        var timestampCache = new ArrayCacheByTimestamp();
        object ohlcv1 = new List<object>() {100, 1, 2, 3};
        object ohlcv2 = new List<object>() {200, 5, 6, 7};
        timestampCache.append(ohlcv1);
        timestampCache.append(ohlcv2);
        Assert(equals(timestampCache, new List<object>() {ohlcv1, ohlcv2}));
        object modify2 = new List<object>() {200, 10, 11, 12};
        timestampCache.append(modify2);
        Assert(equals(timestampCache, new List<object>() {ohlcv1, modify2}));
        
        // ----------------------------------------------------------------------------
        
        var cacheSymbolId = new ArrayCacheBySymbolById();
        object object1 = new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "id", "abcdef" },
            { "i", 1 },
        };
        object object2 = new Dictionary<string, object>() {
            { "symbol", "ETH/USDT" },
            { "id", "qwerty" },
            { "i", 2 },
        };
        object object3 = new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "id", "abcdef" },
            { "i", 3 },
        };
        cacheSymbolId.append(object1);
        cacheSymbolId.append(object2);
        cacheSymbolId.append(object3); // should update index 0
        Assert(equals(cacheSymbolId, new List<object>() {object2, object3}));
        
        // ----------------------------------------------------------------------------
        
        var cacheSymbolId5 = new ArrayCacheBySymbolById(5);
        for (object i = 1; isLessThan(i, 11); postFixIncrement(ref i))
        {
            cacheSymbolId5.append(new Dictionary<string, object>() {
                { "symbol", "BTC/USDT" },
                { "id", ((object)i).ToString() },
                { "i", i },
            });
        }
        Assert(equals(cacheSymbolId5, new List<object>() {new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "id", "6" },
            { "i", 6 },
        }, new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "id", "7" },
            { "i", 7 },
        }, new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "id", "8" },
            { "i", 8 },
        }, new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "id", "9" },
            { "i", 9 },
        }, new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "id", "10" },
            { "i", 10 },
        }}));
        for (object i = 1; isLessThan(i, 11); postFixIncrement(ref i))
        {
            cacheSymbolId5.append(new Dictionary<string, object>() {
                { "symbol", "BTC/USDT" },
                { "id", ((object)i).ToString() },
                { "i", add(i, 10) },
            });
        }
        Assert(equals(cacheSymbolId5, new List<object>() {new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "id", "6" },
            { "i", 16 },
        }, new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "id", "7" },
            { "i", 17 },
        }, new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "id", "8" },
            { "i", 18 },
        }, new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "id", "9" },
            { "i", 19 },
        }, new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "id", "10" },
            { "i", 20 },
        }}));
        object middle = new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "id", "8" },
            { "i", 28 },
        };
        cacheSymbolId5.append(middle);
        Assert(equals(cacheSymbolId5, new List<object>() {new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "id", "6" },
            { "i", 16 },
        }, new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "id", "7" },
            { "i", 17 },
        }, new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "id", "9" },
            { "i", 19 },
        }, new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "id", "10" },
            { "i", 20 },
        }, new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "id", "8" },
            { "i", 28 },
        }}));
        object otherMiddle = new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "id", "7" },
            { "i", 27 },
        };
        cacheSymbolId5.append(otherMiddle);
        Assert(equals(cacheSymbolId5, new List<object>() {new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "id", "6" },
            { "i", 16 },
        }, new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "id", "9" },
            { "i", 19 },
        }, new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "id", "10" },
            { "i", 20 },
        }, new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "id", "8" },
            { "i", 28 },
        }, new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "id", "7" },
            { "i", 27 },
        }}));
        for (object i = 30; isLessThan(i, 33); postFixIncrement(ref i))
        {
            cacheSymbolId5.append(new Dictionary<string, object>() {
                { "symbol", "BTC/USDT" },
                { "id", ((object)i).ToString() },
                { "i", add(i, 10) },
            });
        }
        Assert(equals(cacheSymbolId5, new List<object>() {new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "id", "8" },
            { "i", 28 },
        }, new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "id", "7" },
            { "i", 27 },
        }, new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "id", "30" },
            { "i", 40 },
        }, new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "id", "31" },
            { "i", 41 },
        }, new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "id", "32" },
            { "i", 42 },
        }}));
        object first = new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "id", "8" },
            { "i", 38 },
        };
        cacheSymbolId5.append(first);
        Assert(equals(cacheSymbolId5, new List<object>() {new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "id", "7" },
            { "i", 27 },
        }, new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "id", "30" },
            { "i", 40 },
        }, new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "id", "31" },
            { "i", 41 },
        }, new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "id", "32" },
            { "i", 42 },
        }, new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "id", "8" },
            { "i", 38 },
        }}));
        object another = new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "id", "30" },
            { "i", 50 },
        };
        cacheSymbolId5.append(another);
        Assert(equals(cacheSymbolId5, new List<object>() {new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "id", "7" },
            { "i", 27 },
        }, new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "id", "31" },
            { "i", 41 },
        }, new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "id", "32" },
            { "i", 42 },
        }, new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "id", "8" },
            { "i", 38 },
        }, new Dictionary<string, object>() {
            { "symbol", "BTC/USDT" },
            { "id", "30" },
            { "i", 50 },
        }}));
        
        // ----------------------------------------------------------------------------
        
        // test ArrayCacheBySymbolById limit with symbol set
        object symbol = "BTC/USDT";
        var cacheSymbolId2 = new ArrayCacheBySymbolById();
        object initialLength = 5;
        for (object i = 0; isLessThan(i, initialLength); postFixIncrement(ref i))
        {
            cacheSymbolId2.append(new Dictionary<string, object>() {
                { "symbol", symbol },
                { "id", ((object)i).ToString() },
                { "i", i },
            });
        }
        object limited = cacheSymbolId2.getLimit(symbol, null);
        Assert(isEqual(initialLength, limited));
        
        // ----------------------------------------------------------------------------
        
        var cacheSymbolId3 = new ArrayCacheBySymbolById();
        object appendItemsLength = 3;
        for (object i = 0; isLessThan(i, appendItemsLength); postFixIncrement(ref i))
        {
            cacheSymbolId3.append(new Dictionary<string, object>() {
                { "symbol", symbol },
                { "id", ((object)i).ToString() },
                { "i", i },
            });
        }
        object outsideLimit = 5;
        limited = cacheSymbolId3.getLimit(symbol, outsideLimit);
        Assert(isEqual(appendItemsLength, limited));
        outsideLimit = 2; // if limit < newsUpdate that should be returned
        limited = cacheSymbolId3.getLimit(symbol, outsideLimit);
        Assert(isEqual(outsideLimit, limited));
        
        // ----------------------------------------------------------------------------
        
        // test ArrayCacheBySymbolById limit with symbol undefined
        symbol = "BTC/USDT";
        var cacheSymbolId4 = new ArrayCacheBySymbolById();
        initialLength = 5;
        for (object i = 0; isLessThan(i, initialLength); postFixIncrement(ref i))
        {
            cacheSymbolId4.append(new Dictionary<string, object>() {
                { "symbol", symbol },
                { "id", ((object)i).ToString() },
                { "i", i },
            });
        }
        limited = cacheSymbolId4.getLimit(null, null);
        Assert(isEqual(initialLength, limited));
        
        // ----------------------------------------------------------------------------
        
        var cacheSymbolId6 = new ArrayCacheBySymbolById();
        appendItemsLength = 3;
        for (object i = 0; isLessThan(i, appendItemsLength); postFixIncrement(ref i))
        {
            cacheSymbolId6.append(new Dictionary<string, object>() {
                { "symbol", symbol },
                { "id", ((object)i).ToString() },
                { "i", i },
            });
        }
        outsideLimit = 5;
        limited = cacheSymbolId6.getLimit(symbol, outsideLimit);
        Assert(isEqual(appendItemsLength, limited));
        outsideLimit = 2; // if limit < newsUpdate that should be returned
        limited = cacheSymbolId6.getLimit(symbol, outsideLimit);
        Assert(isEqual(outsideLimit, limited));
        
        // ----------------------------------------------------------------------------
        
        // test ArrayCacheBySymbolById, same order should not increase the limit
        var cacheSymbolId7 = new ArrayCacheBySymbolById();
        symbol = "BTC/USDT";
        object otherSymbol = "ETH/USDT";
        cacheSymbolId7.append(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "id", "singleId" },
            { "i", 3 },
        });
        cacheSymbolId7.append(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "id", "singleId" },
            { "i", 3 },
        });
        cacheSymbolId7.append(new Dictionary<string, object>() {
            { "symbol", otherSymbol },
            { "id", "singleId" },
            { "i", 3 },
        });
        outsideLimit = 5;
        limited = cacheSymbolId7.getLimit(symbol, outsideLimit);
        object limited2 = cacheSymbolId7.getLimit(null, outsideLimit);
        Assert(isEqual(limited, 1));
        Assert(isEqual(limited2, 2));
        
        // ----------------------------------------------------------------------------
        
        // test testLimitArrayCacheByTimestamp limit
        var timestampCache2 = new ArrayCacheByTimestamp();
        initialLength = 5;
        for (object i = 0; isLessThan(i, initialLength); postFixIncrement(ref i))
        {
            timestampCache2.append(new List<object>() {multiply(i, 10), multiply(i, 10), multiply(i, 10), multiply(i, 10)});
        }
        limited = timestampCache2.getLimit(null, null);
        Assert(isEqual(initialLength, limited));
        appendItemsLength = 3;
        for (object i = 0; isLessThan(i, appendItemsLength); postFixIncrement(ref i))
        {
            timestampCache2.append(new List<object>() {multiply(i, 4), multiply(i, 4), multiply(i, 4), multiply(i, 4)});
        }
        outsideLimit = 5;
        limited = timestampCache2.getLimit(null, outsideLimit);
        Assert(isEqual(appendItemsLength, limited));
        outsideLimit = 2; // if limit < newsUpdate that should be returned
        limited = timestampCache2.getLimit(null, outsideLimit);
        Assert(isEqual(outsideLimit, limited));
        
        // ----------------------------------------------------------------------------
        
        // test ArrayCacheBySymbolById, watch all orders, same symbol and order id gets updated
        var cacheSymbolId8 = new ArrayCacheBySymbolById();
        symbol = "BTC/USDT";
        outsideLimit = 5;
        cacheSymbolId8.append(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "id", "oneId" },
            { "i", 3 },
        }); // create first order
        cacheSymbolId8.getLimit(null, outsideLimit); // watch all orders
        cacheSymbolId8.append(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "id", "oneId" },
            { "i", 4 },
        }); // first order is closed
        cacheSymbolId8.getLimit(null, outsideLimit); // watch all orders
        cacheSymbolId8.append(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "id", "twoId" },
            { "i", 5 },
        }); // create second order
        cacheSymbolId8.getLimit(null, outsideLimit); // watch all orders
        cacheSymbolId8.append(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "id", "twoId" },
            { "i", 6 },
        }); // second order is closed
        limited = cacheSymbolId8.getLimit(null, outsideLimit); // watch all orders
        Assert(isEqual(limited, 1)); // one new update
        
        // ----------------------------------------------------------------------------
        
        // test ArrayCacheBySymbolById, watch all orders, and watchOrders (symbol) work independently
        var cacheSymbolId9 = new ArrayCacheBySymbolById();
        symbol = "BTC/USDT";
        object symbol2 = "ETH/USDT";
        outsideLimit = 5;
        cacheSymbolId9.append(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "id", "one" },
            { "i", 1 },
        }); // create first order
        cacheSymbolId9.append(new Dictionary<string, object>() {
            { "symbol", symbol2 },
            { "id", "two" },
            { "i", 1 },
        }); // create second order
        Assert(isEqual(cacheSymbolId9.getLimit(null, outsideLimit), 2)); // watch all orders
        Assert(isEqual(cacheSymbolId9.getLimit(symbol, outsideLimit), 1)); // watch by symbol
        cacheSymbolId9.append(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "id", "one" },
            { "i", 2 },
        }); // update first order
        cacheSymbolId9.append(new Dictionary<string, object>() {
            { "symbol", symbol2 },
            { "id", "two" },
            { "i", 2 },
        }); // update second order
        Assert(isEqual(cacheSymbolId9.getLimit(symbol, outsideLimit), 1)); // watch by symbol
        Assert(isEqual(cacheSymbolId9.getLimit(null, outsideLimit), 2)); // watch all orders
        cacheSymbolId9.append(new Dictionary<string, object>() {
            { "symbol", symbol2 },
            { "id", "two" },
            { "i", 3 },
        }); // update second order
        cacheSymbolId9.append(new Dictionary<string, object>() {
            { "symbol", symbol2 },
            { "id", "three" },
            { "i", 3 },
        }); // create third order
        Assert(isEqual(cacheSymbolId9.getLimit(null, outsideLimit), 2)); // watch all orders
        
        // ----------------------------------------------------------------------------
        
        // test ArrayCacheBySymbolBySide, watch all positions, same symbol and side id gets updated
        var cacheSymbolSide = new ArrayCacheBySymbolBySide();
        symbol = "BTC/USDT";
        outsideLimit = 5;
        cacheSymbolSide.append(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "side", "short" },
            { "contracts", 1 },
        }); // create first position
        cacheSymbolSide.append(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "side", "short" },
            { "contracts", 0 },
        }); // first position is closed
        Assert(isEqual(cacheSymbolSide.getLimit(symbol, outsideLimit), 1)); // limit position
        cacheSymbolSide.append(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "side", "short" },
            { "contracts", 1 },
        }); // create first position
        Assert(isEqual(cacheSymbolSide.getLimit(symbol, outsideLimit), 1)); // watch all positions
        
        // ----------------------------------------------------------------------------
        
        // test ArrayCacheBySymbolBySide, watch all positions, same symbol and side id gets updated
        var cacheSymbolSide2 = new ArrayCacheBySymbolBySide();
        symbol = "BTC/USDT";
        outsideLimit = 5;
        cacheSymbolSide2.append(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "side", "short" },
            { "contracts", 1 },
        }); // create first position
        Assert(isEqual(cacheSymbolSide2.getLimit(null, outsideLimit), 1)); // watch all positions
        cacheSymbolSide2.append(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "side", "short" },
            { "contracts", 0 },
        }); // first position is closed
        Assert(isEqual(cacheSymbolSide2.getLimit(null, outsideLimit), 1)); // watch all positions
        cacheSymbolSide2.append(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "side", "long" },
            { "contracts", 3 },
        }); // create second position
        Assert(isEqual(cacheSymbolSide2.getLimit(null, outsideLimit), 1)); // watch all positions
        cacheSymbolSide2.append(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "side", "long" },
            { "contracts", 2 },
        }); // second position is reduced
        cacheSymbolSide2.append(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "side", "long" },
            { "contracts", 1 },
        }); // second position is reduced
        Assert(isEqual(cacheSymbolSide2.getLimit(null, outsideLimit), 1)); // watch all orders
        
        // ----------------------------------------------------------------------------
        
        // test ArrayCacheBySymbolBySide, watchPositions, and watchPosition (symbol) work independently
        var cacheSymbolSide3 = new ArrayCacheBySymbolBySide();
        symbol = "BTC/USDT";
        symbol2 = "ETH/USDT";
        cacheSymbolSide3.append(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "side", "short" },
            { "contracts", 1 },
        }); // create first position
        cacheSymbolSide3.append(new Dictionary<string, object>() {
            { "symbol", symbol2 },
            { "side", "long" },
            { "contracts", 1 },
        }); // create second position
        Assert(isEqual(cacheSymbolSide3.getLimit(null, outsideLimit), 2)); // watch all positions
        Assert(isEqual(cacheSymbolSide3.getLimit(symbol, outsideLimit), 1)); // watch by symbol
        cacheSymbolSide3.append(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "side", "short" },
            { "contracts", 2 },
        }); // update first position
        cacheSymbolSide3.append(new Dictionary<string, object>() {
            { "symbol", symbol2 },
            { "side", "long" },
            { "contracts", 2 },
        }); // update second position
        Assert(isEqual(cacheSymbolSide3.getLimit(symbol, outsideLimit), 1)); // watch by symbol
        Assert(isEqual(cacheSymbolSide3.getLimit(null, outsideLimit), 2)); // watch all positions
        cacheSymbolSide3.append(new Dictionary<string, object>() {
            { "symbol", symbol2 },
            { "side", "long" },
            { "contracts", 3 },
        }); // update second position
        Assert(isEqual(cacheSymbolSide3.getLimit(null, outsideLimit), 1)); // watch all positions
    }
}