using ccxt;
using ccxt.pro;
namespace Tests;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class BaseTest
{
        public void testIndexBy()
        {
            var exchange = new ccxt.Exchange(new Dictionary<string, object>() {
                { "id", "sampleexchange" },
            });
            // Test 1: Basic list of dicts with string key
            object input1 = new List<object>() {new Dictionary<string, object>() {
            { "id", "a" },
            { "val", 1 },
        }, new Dictionary<string, object>() {
            { "id", "b" },
            { "val", 2 },
        }, new Dictionary<string, object>() {
            { "id", "c" },
            { "val", 3 },
        }};
            object expected1 = new Dictionary<string, object>() {
                { "a", new Dictionary<string, object>() {
                    { "id", "a" },
                    { "val", 1 },
                } },
                { "b", new Dictionary<string, object>() {
                    { "id", "b" },
                    { "val", 2 },
                } },
                { "c", new Dictionary<string, object>() {
                    { "id", "c" },
                    { "val", 3 },
                } },
            };
            object result1 = exchange.indexBy(input1, "id");
            AssertDeepEqual(exchange, null, "testIndexBy", result1, expected1);
            // Test 2: Skip elements with None/undefined values
            object input2 = new List<object>() {new Dictionary<string, object>() {
            { "id", "a" },
            { "val", 1 },
        }, new Dictionary<string, object>() {
            { "id", "b" },
            { "val", 3 },
        }};
            object expected2 = new Dictionary<string, object>() {
                { "a", new Dictionary<string, object>() {
                    { "id", "a" },
                    { "val", 1 },
                } },
                { "b", new Dictionary<string, object>() {
                    { "id", "b" },
                    { "val", 3 },
                } },
            };
            object result2 = exchange.indexBy(input2, "id");
            AssertDeepEqual(exchange, null, "testIndexBy", result2, expected2);
            // Test 3: Skip elements missing the key
            object input3 = new List<object>() {new Dictionary<string, object>() {
            { "id", "a" },
            { "val", 1 },
        }, new Dictionary<string, object>() {
            { "val", 2 },
        }, new Dictionary<string, object>() {
            { "id", "b" },
            { "val", 3 },
        }};
            object expected3 = new Dictionary<string, object>() {
                { "a", new Dictionary<string, object>() {
                    { "id", "a" },
                    { "val", 1 },
                } },
                { "b", new Dictionary<string, object>() {
                    { "id", "b" },
                    { "val", 3 },
                } },
            };
            object result3 = exchange.indexBy(input3, "id");
            AssertDeepEqual(exchange, null, "testIndexBy", result3, expected3);
            // Test 4: Empty array
            object input4 = new List<object>() {};
            object expected4 = new Dictionary<string, object>() {};
            object result4 = exchange.indexBy(input4, "id");
            AssertDeepEqual(exchange, null, "testIndexBy", result4, expected4);
            // Test 5: Duplicate keys (last one wins)
            object input5 = new List<object>() {new Dictionary<string, object>() {
            { "id", "a" },
            { "val", 1 },
        }, new Dictionary<string, object>() {
            { "id", "a" },
            { "val", 2 },
        }, new Dictionary<string, object>() {
            { "id", "a" },
            { "val", 3 },
        }};
            object expected5 = new Dictionary<string, object>() {
                { "a", new Dictionary<string, object>() {
                    { "id", "a" },
                    { "val", 3 },
                } },
            };
            object result5 = exchange.indexBy(input5, "id");
            AssertDeepEqual(exchange, null, "testIndexBy", result5, expected5);
            // Test 6: Numeric key values
            object input6 = new List<object>() {new Dictionary<string, object>() {
            { "code", 1 },
            { "name", "one" },
        }, new Dictionary<string, object>() {
            { "code", 2 },
            { "name", "two" },
        }, new Dictionary<string, object>() {
            { "code", 3 },
            { "name", "three" },
        }};
            object expected6 = new Dictionary<string, object>() {
                { "1", new Dictionary<string, object>() {
                    { "code", 1 },
                    { "name", "one" },
                } },
                { "2", new Dictionary<string, object>() {
                    { "code", 2 },
                    { "name", "two" },
                } },
                { "3", new Dictionary<string, object>() {
                    { "code", 3 },
                    { "name", "three" },
                } },
            };
            object result6 = exchange.indexBy(input6, "code");
            AssertDeepEqual(exchange, null, "testIndexBy", result6, expected6);
            // Test 7: List of arrays with integer key
            object input7 = new List<object>() {new List<object>() {"a", 1}, new List<object>() {"b", 2}, new List<object>() {"c", 3}};
            object expected7 = new Dictionary<string, object>() {
                { "a", new List<object>() {"a", 1} },
                { "b", new List<object>() {"b", 2} },
                { "c", new List<object>() {"c", 3} },
            };
            object result7 = exchange.indexBy(input7, 0);
            AssertDeepEqual(exchange, null, "testIndexBy", result7, expected7);
            // Test 8: Single element
            object input8 = new List<object>() {new Dictionary<string, object>() {
            { "id", "only" },
            { "val", 42 },
        }};
            object expected8 = new Dictionary<string, object>() {
                { "only", new Dictionary<string, object>() {
                    { "id", "only" },
                    { "val", 42 },
                } },
            };
            object result8 = exchange.indexBy(input8, "id");
            AssertDeepEqual(exchange, null, "testIndexBy", result8, expected8);
        }
}