using ccxt;
namespace Tests;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class testMainClass : BaseTest
{
    // ----------------------------------------------------------------------------
    public static void tcoDebug(Exchange exchange, object symbol, object message)
    {
        // just for debugging purposes
        object debugCreateOrder = true;
        if (isTrue(debugCreateOrder))
        {
            // for c# fix, extra step to convert them to string
            Console.WriteLine(" >>>>> testCreateOrder [", ((object)(getValue(exchange, "id"))).ToString(), " : ", symbol, "] ", message);
        }
    }
    // ----------------------------------------------------------------------------
    async static public Task testCreateOrder(Exchange exchange, object skippedProperties, object symbol)
    {
        object logPrefix = testSharedMethods.logTemplate(exchange, "createOrder", new List<object>() {symbol});
        assert(isTrue(isTrue(getValue(exchange.has, "cancelOrder")) || isTrue(getValue(exchange.has, "cancelOrders"))) || isTrue(getValue(exchange.has, "cancelAllOrders")), add(logPrefix, " does not have cancelOrder|cancelOrders|canelAllOrders method, which is needed to make tests for `createOrder` method. Skipping the test..."));
        // pre-define some coefficients, which will be used down below
        object limitPriceSafetyMultiplierFromMedian = 1.045; // todo: when this https://github.com/ccxt/ccxt/issues/22442 is implemented, we'll remove hardcoded value. atm 5% is enough
        object market = exchange.market(symbol);
        object isSwapFuture = isTrue(getValue(market, "swap")) || isTrue(getValue(market, "future"));
        assert(getValue(exchange.has, "fetchBalance"), add(logPrefix, " does not have fetchBalance() method, which is needed to make tests for `createOrder` method. Skipping the test..."));
        object balance = await exchange.fetchBalance();
        object initialBaseBalance = getValue(getValue(balance, getValue(market, "base")), "free");
        object initialQuoteBalance = getValue(getValue(balance, getValue(market, "quote")), "free");
        assert(!isEqual(initialQuoteBalance, null), add(add(add(logPrefix, " - testing account not have balance of"), getValue(market, "quote")), " in fetchBalance() which is required to test"));
        tcoDebug(exchange, symbol, add(add(add(add(add(add(add(add(add("fetched balance for ", symbol), " : "), ((object)initialBaseBalance).ToString()), " "), getValue(market, "base")), "/"), initialQuoteBalance), " "), getValue(market, "quote")));
        var bestBidbestAskVariable = await testSharedMethods.fetchBestBidAsk(exchange, "createOrder", symbol);
        var bestBid = ((IList<object>) bestBidbestAskVariable)[0];
        var bestAsk = ((IList<object>) bestBidbestAskVariable)[1];
        // **************** [Scenario 1 - START] **************** //
        tcoDebug(exchange, symbol, "### SCENARIO 1 ###");
        // create a "limit order" which IS GUARANTEED not to have a fill (i.e. being far from the real price)
        await tcoCreateUnfillableOrder(exchange, market, logPrefix, skippedProperties, bestBid, bestAsk, limitPriceSafetyMultiplierFromMedian, "buy", null);
        if (isTrue(isSwapFuture))
        {
            // for swap markets, we test sell orders too
            await tcoCreateUnfillableOrder(exchange, market, logPrefix, skippedProperties, bestBid, bestAsk, limitPriceSafetyMultiplierFromMedian, "sell", null);
        }
        tcoDebug(exchange, symbol, "### SCENARIO 1 PASSED ###");
        // **************** [Scenario 2 - START] **************** //
        tcoDebug(exchange, symbol, "### SCENARIO 2 ###");
        // create an order which IS GUARANTEED to have a fill (full or partial)
        await tcoCreateFillableOrder(exchange, market, logPrefix, skippedProperties, bestBid, bestAsk, limitPriceSafetyMultiplierFromMedian, "buy", null);
        if (isTrue(isSwapFuture))
        {
            // for swap markets, we test sell orders too
            await tcoCreateFillableOrder(exchange, market, logPrefix, skippedProperties, bestBid, bestAsk, limitPriceSafetyMultiplierFromMedian, "sell", null);
        }
        tcoDebug(exchange, symbol, "### SCENARIO 2 PASSED ###");
    }
    // ----------------------------------------------------------------------------
    async static public Task tcoCreateUnfillableOrder(Exchange exchange, object market, object logPrefix, object skippedProperties, object bestBid, object bestAsk, object limitPriceSafetyMultiplierFromMedian, object buyOrSell, object predefinedAmount = null)
    {
        try
        {
            object symbol = getValue(market, "symbol");
            object minimunPrices = exchange.safeDict(getValue(market, "limits"), "price", new Dictionary<string, object>() {});
            object minimumPrice = getValue(minimunPrices, "min");
            object maximumPrice = getValue(minimunPrices, "max");
            // below we set limit price, where the order will not be completed.
            // We do not use the extreme "limits" values for that market, because, even though min purchase amount for BTC/USDT can be 0.01 BTC, it means with 10$ you can buy 1000 BTC, which leads to unrealistic outcome. So, we just use around 5%-10% far price from the current price.
            object limitBuyPrice_nonFillable = divide(bestBid, limitPriceSafetyMultiplierFromMedian);
            if (isTrue(isTrue(!isEqual(minimumPrice, null)) && isTrue(isLessThan(limitBuyPrice_nonFillable, minimumPrice))))
            {
                limitBuyPrice_nonFillable = minimumPrice;
            }
            object limitSellPrice_nonFillable = multiply(bestAsk, limitPriceSafetyMultiplierFromMedian);
            if (isTrue(isTrue(!isEqual(maximumPrice, null)) && isTrue(isGreaterThan(limitSellPrice_nonFillable, maximumPrice))))
            {
                limitSellPrice_nonFillable = maximumPrice;
            }
            object createdOrder = null;
            if (isTrue(isEqual(buyOrSell, "buy")))
            {
                object orderAmount = tcoGetMinimumAmountForLimitPrice(exchange, market, limitBuyPrice_nonFillable, predefinedAmount);
                createdOrder = await tcoCreateOrderSafe(exchange, symbol, "limit", "buy", orderAmount, limitBuyPrice_nonFillable, new Dictionary<string, object>() {}, skippedProperties);
            } else
            {
                object orderAmount = tcoGetMinimumAmountForLimitPrice(exchange, market, limitSellPrice_nonFillable, predefinedAmount);
                createdOrder = await tcoCreateOrderSafe(exchange, symbol, "limit", "sell", orderAmount, limitSellPrice_nonFillable, new Dictionary<string, object>() {}, skippedProperties);
            }
            object fetchedOrder = await testSharedMethods.fetchOrder(exchange, symbol, getValue(createdOrder, "id"), skippedProperties);
            // test fetched order object
            if (isTrue(!isEqual(fetchedOrder, null)))
            {
                testOrder(exchange, skippedProperties, "createOrder", fetchedOrder, symbol, exchange.milliseconds());
            }
            // ensure that order is not filled
            testSharedMethods.assertOrderState(exchange, skippedProperties, "createdOrder", createdOrder, "open", false);
            testSharedMethods.assertOrderState(exchange, skippedProperties, "fetchedOrder", fetchedOrder, "open", true);
            // ensure that order side matches
            testSharedMethods.assertInArray(exchange, skippedProperties, "createdOrder", createdOrder, "side", new List<object>() {null, buyOrSell});
            testSharedMethods.assertInArray(exchange, skippedProperties, "fetchedOrder", fetchedOrder, "side", new List<object>() {null, buyOrSell});
            await tcoCancelOrder(exchange, symbol, getValue(createdOrder, "id"));
        } catch(Exception e)
        {
            throw new Exception ((string)add(add(logPrefix, " failed for Scenario 1: "), ((object)e).ToString())) ;
        }
    }
    async static public Task tcoCreateFillableOrder(Exchange exchange, object market, object logPrefix, object skippedProperties, object bestBid, object bestAsk, object limitPriceSafetyMultiplierFromMedian, object buyOrSellString, object predefinedAmount = null)
    {
        try
        {
            object isSwapFuture = isTrue(getValue(market, "swap")) || isTrue(getValue(market, "future"));
            object isBuy = (isEqual(buyOrSellString, "buy"));
            object entrySide = ((bool) isTrue(isBuy)) ? "buy" : "sell";
            object exitSide = ((bool) isTrue(isBuy)) ? "sell" : "buy";
            object entryorderPrice = ((bool) isTrue(isBuy)) ? multiply(bestAsk, limitPriceSafetyMultiplierFromMedian) : divide(bestBid, limitPriceSafetyMultiplierFromMedian);
            object exitorderPrice = ((bool) isTrue(isBuy)) ? divide(bestBid, limitPriceSafetyMultiplierFromMedian) : multiply(bestAsk, limitPriceSafetyMultiplierFromMedian); // todo revise: (tcoMininumCost (exchange, market) / amountToClose) / limitPriceSafetyMultiplierFromMedian;
            //
            //
            object symbol = getValue(market, "symbol");
            object entryAmount = tcoGetMinimumAmountForLimitPrice(exchange, market, entryorderPrice);
            object entryorderFilled = await tcoCreateOrderSafe(exchange, symbol, "limit", entrySide, entryAmount, entryorderPrice, new Dictionary<string, object>() {}, skippedProperties);
            // just for case, cancel any possible unfilled amount (though it is not be expected because the order was fillable)
            await tcoTryCancelOrder(exchange, symbol, entryorderFilled, skippedProperties);
            // now, as order is closed/canceled, we can reliably fetch the order information
            object entryorderFetched = await testSharedMethods.fetchOrder(exchange, symbol, getValue(entryorderFilled, "id"), skippedProperties);
            tcoAssertFilledOrder(exchange, market, logPrefix, skippedProperties, entryorderFilled, entryorderFetched, entrySide, entryAmount);
            //
            // ### close the traded position ###
            //
            object amountToClose = exchange.parseToNumeric(exchange.safeString(entryorderFetched, "filled"));
            object parameters = new Dictionary<string, object>() {};
            // as we want to close position, we should use 'reduceOnly' to ensure we don't open a margined position accidentally, because some exchanges might have automatically enabled margin-mode (on spot) or hedge-mode (on contracts)
            if (isTrue(isSwapFuture))
            {
                ((IDictionary<string,object>)parameters)["reduceOnly"] = true;
            }
            object exitorderFilled = await tcoCreateOrderSafe(exchange, symbol, "market", exitSide, amountToClose, (((bool) isTrue(getValue(market, "spot"))) ? null : exitorderPrice), parameters, skippedProperties);
            object exitorderFetched = await testSharedMethods.fetchOrder(exchange, symbol, getValue(exitorderFilled, "id"), skippedProperties);
            tcoAssertFilledOrder(exchange, market, logPrefix, skippedProperties, exitorderFilled, exitorderFetched, exitSide, amountToClose);
        } catch(Exception e)
        {
            throw new Exception ((string)add("failed for Scenario 2: ", ((object)e).ToString())) ;
        }
    }
    public static void tcoAssertFilledOrder(Exchange exchange, object market, object logPrefix, object skippedProperties, object createdOrder, object fetchedOrder, object requestedSide, object requestedAmount)
    {
        // test filled amount
        object precisionAmount = exchange.safeString(getValue(market, "precision"), "amount");
        object entryorderAmountString = exchange.numberToString(requestedAmount);
        object filledString = exchange.safeString(fetchedOrder, "filled");
        assert(!isEqual(filledString, null), add(add(logPrefix, " order should be filled, but it is not. "), exchange.json(fetchedOrder)));
        // filled amount should be whithin the expected range i.e. if you buy 100 DOGECOIN and amount-precision is 1,
        // and also considering possible roundings in implementation, then filled amount should be between 99 and 101
        object maxExpectedFilledAmount = Precise.stringAdd(entryorderAmountString, precisionAmount);
        object minExpectedFilledAmount = Precise.stringSub(entryorderAmountString, precisionAmount);
        assert(Precise.stringLe(filledString, maxExpectedFilledAmount), add(add(logPrefix, " filled amount is more than expected, possibly some implementation issue. "), exchange.json(fetchedOrder)));
        assert(Precise.stringGe(filledString, minExpectedFilledAmount), add(add(logPrefix, " filled amount is less than expected, possibly some implementation issue. "), exchange.json(fetchedOrder)));
        // order state should be "closed"
        testSharedMethods.assertOrderState(exchange, skippedProperties, "createdOrder", createdOrder, "closed", false);
        testSharedMethods.assertOrderState(exchange, skippedProperties, "fetchedOrder", fetchedOrder, "closed", true);
        // ensure that order side matches
        testSharedMethods.assertInArray(exchange, skippedProperties, "createdOrder", createdOrder, "side", new List<object>() {null, requestedSide});
        testSharedMethods.assertInArray(exchange, skippedProperties, "fetchedOrder", fetchedOrder, "side", new List<object>() {null, requestedSide});
    }
    // ----------------------------------------------------------------------------
    async static public Task tcoCancelOrder(Exchange exchange, object symbol, object orderId = null)
    {
        object logPrefix = testSharedMethods.logTemplate(exchange, "createOrder", new List<object>() {symbol});
        object usedMethod = "";
        object cancelResult = null;
        if (isTrue(isTrue(getValue(exchange.has, "cancelOrder")) && isTrue(!isEqual(orderId, null))))
        {
            usedMethod = "cancelOrder";
            cancelResult = await exchange.cancelOrder(orderId, symbol);
        } else if (isTrue(getValue(exchange.has, "cancelAllOrders")))
        {
            usedMethod = "cancelAllOrders";
            cancelResult = await exchange.cancelAllOrders(symbol);
        } else if (isTrue(getValue(exchange.has, "cancelOrders")))
        {
            throw new Exception ((string)add(logPrefix, " cancelOrders method is not unified yet, coming soon...")) ;
        }
        tcoDebug(exchange, symbol, add(add(add("canceled order using ", usedMethod), ":"), getValue(cancelResult, "id")));
    }
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    async static public Task<object> tcoCreateOrderSafe(Exchange exchange, object symbol, object orderType, object side, object amount, object price = null, object parameters = null, object skippedProperties = null)
    {
        parameters ??= new Dictionary<string, object>();
        skippedProperties ??= new Dictionary<string, object>();
        tcoDebug(exchange, symbol, add(add(add(add(add(add(add(add(add("Executing createOrder ", orderType), " "), side), " "), amount), " "), price), " "), exchange.json(parameters)));
        object order = await exchange.createOrder(symbol, orderType, side, amount, price, parameters);
        try
        {
            testOrder(exchange, skippedProperties, "createOrder", order, symbol, (new DateTimeOffset(DateTime.UtcNow)).ToUnixTimeMilliseconds());
        } catch(Exception e)
        {
            if (isTrue(!isEqual(orderType, "market")))
            {
                // if it was limit order, try to cancel it before exiting the script
                await tcoTryCancelOrder(exchange, symbol, order, skippedProperties);
            }
            throw e;
        }
        return order;
    }
    public static object tcoMininumAmount(Exchange exchange, object market)
    {
        object amountValues = exchange.safeDict(getValue(market, "limits"), "amount", new Dictionary<string, object>() {});
        object amountMin = exchange.safeNumber(amountValues, "min");
        assert(!isEqual(amountMin, null), add(add(add(exchange.id, " "), getValue(market, "symbol")), " can not determine minimum amount for order"));
        return amountMin;
    }
    public static object tcoMininumCost(Exchange exchange, object market)
    {
        object costValues = exchange.safeDict(getValue(market, "limits"), "cost", new Dictionary<string, object>() {});
        object costMin = exchange.safeNumber(costValues, "min");
        assert(!isEqual(costMin, null), add(add(add(exchange.id, " "), getValue(market, "symbol")), " can not determine minimum cost for order"));
        return costMin;
    }
    public static object tcoGetMinimumAmountForLimitPrice(Exchange exchange, object market, object price, object predefinedAmount = null)
    {
        // this method calculates the minimum realistic order amount:
        // at first it checks the "minimum hardcap limit" (i.e. 7 DOGE), however, if exchange also has "minimum cost" limits,
        // then we need to calculate the amount using cost, because of price is volatile, today's 7 DOGE cost could be 1$
        // but "minimum cost" requirement could be 5$ (which translates to 35 DOGE amount)
        object minimumAmount = tcoMininumAmount(exchange, market);
        object minimumCost = tcoMininumCost(exchange, market);
        object finalAmount = minimumAmount;
        if (isTrue(!isEqual(minimumCost, null)))
        {
            if (isTrue(isLessThan(multiply(finalAmount, price), minimumCost)))
            {
                finalAmount = divide(minimumCost, price);
            }
        }
        if (isTrue(!isEqual(predefinedAmount, null)))
        {
            finalAmount = mathMax(finalAmount, predefinedAmount);
        }
        // because it's possible that calculated value might get truncated down in "createOrder" (i.e. 0.129 -> 0.12), we should ensure that final amount * price would bypass minimum cost requirements, by adding the "minimum precision"
        object amountPrecision = exchange.safeNumber(getValue(market, "precision"), "amount");
        object isTickSizePrecision = isEqual(exchange.precisionMode, 4);
        if (isTrue(isEqual(amountPrecision, null)))
        {
            amountPrecision = 1e-15; // todo: revise this for better way in future
        } else
        {
            // todo: remove after TICK_SIZE unification
            if (!isTrue(isTickSizePrecision))
            {
                amountPrecision = divide(1, Math.Pow(Convert.ToDouble(10), Convert.ToDouble(amountPrecision))); // this converts DECIMAL_PRECISION into TICK_SIZE
            }
        }
        finalAmount = add(finalAmount, amountPrecision);
        finalAmount = multiply(finalAmount, 1.1); // add around 10% to ensure "cost" is enough
        finalAmount = parseFloat(exchange.decimalToPrecision(finalAmount, 2, getValue(getValue(market, "precision"), "amount"), exchange.precisionMode)); // 2 stands for ROUND_UP constant, 0 stands for TRUNCATE
        return finalAmount;
    }
    async static public Task tcoTryCancelOrder(Exchange exchange, object symbol, object order, object skippedProperties)
    {
        object orderFetched = await testSharedMethods.fetchOrder(exchange, symbol, getValue(order, "id"), skippedProperties);
        object needsCancel = exchange.inArray(getValue(orderFetched, "status"), new List<object>() {"open", "pending", null});
        // if it was not reported as closed/filled, then try to cancel it
        if (isTrue(needsCancel))
        {
            tcoDebug(exchange, symbol, "trying to cancel the remaining amount of partially filled order...");
            try
            {
                await tcoCancelOrder(exchange, symbol, getValue(order, "id"));
            } catch(Exception e)
            {
                // order might have been closed/filled already, before 'cancelOrder' call reaches server, so it is tolerable, we don't throw exception
                tcoDebug(exchange, symbol, add(" a moment ago order was reported as pending, but could not be cancelled at this moment. Exception message: ", ((object)e).ToString()));
            }
        } else
        {
            tcoDebug(exchange, symbol, "order is already closed/filled, no need to cancel it");
        }
    }

}