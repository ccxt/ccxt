using ccxt;
namespace Tests;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class testMainClass : BaseTest
{
    async static public Task<object> testFetchCurrencies(Exchange exchange, object skippedProperties)
    {
        object method = "fetchCurrencies";
        object currencies = await exchange.fetchCurrencies();
        // todo: try to invent something to avoid undefined undefined, i.e. maybe move into private and force it to have a value
        object numInactiveCurrencies = 0;
        object maxInactiveCurrenciesPercentage = exchange.safeInteger(skippedProperties, "maxInactiveCurrenciesPercentage", 50); // no more than X% currencies should be inactive
        object requiredActiveCurrencies = new List<object>() {"BTC", "ETH", "USDT", "USDC"};
        object features = exchange.features;
        object featuresSpot = exchange.safeDict(features, "spot", new Dictionary<string, object>() {});
        object fetchCurrencies = exchange.safeDict(featuresSpot, "fetchCurrencies", new Dictionary<string, object>() {});
        object isFetchCurrenciesPrivate = exchange.safeValue(fetchCurrencies, "private", false);
        if (!isTrue(isFetchCurrenciesPrivate))
        {
            object values = new List<object>(((IDictionary<string,object>)currencies).Values);
            testSharedMethods.assertNonEmtpyArray(exchange, skippedProperties, method, values);
            object currenciesLength = getArrayLength(values);
            // ensure exchange returns enough length of currencies
            object skipAmount = (inOp(skippedProperties, "amountOfCurrencies"));
            assert(isTrue(skipAmount) || isTrue(isGreaterThan(currenciesLength, 5)), add(add(add(add(exchange.id, " "), method), " must return at least several currencies, but it returned "), ((object)currenciesLength).ToString()));
            // allow skipped exchanges
            object skipActive = (inOp(skippedProperties, "activeCurrenciesQuota"));
            object skipMajorCurrencyCheck = (inOp(skippedProperties, "activeMajorCurrencies"));
            // loop
            for (object i = 0; isLessThan(i, currenciesLength); postFixIncrement(ref i))
            {
                object currency = getValue(values, i);
                testCurrency(exchange, skippedProperties, method, currency);
                // detailed check for deposit/withdraw
                object active = exchange.safeBool(currency, "active");
                if (isTrue(isEqual(active, false)))
                {
                    numInactiveCurrencies = add(numInactiveCurrencies, 1);
                }
                // ensure that major currencies are active and enabled for deposit and withdrawal
                object code = exchange.safeString(currency, "code", null);
                object withdraw = exchange.safeBool(currency, "withdraw");
                object deposit = exchange.safeBool(currency, "deposit");
                if (isTrue(exchange.inArray(code, requiredActiveCurrencies)))
                {
                    assert(isTrue(skipMajorCurrencyCheck) || isTrue((isTrue(withdraw) && isTrue(deposit))), add(add("Major currency ", code), " should have withdraw and deposit flags enabled"));
                }
            }
            // check at least X% of currencies are active
            object inactiveCurrenciesPercentage = multiply((divide(numInactiveCurrencies, currenciesLength)), 100);
            assert(isTrue(skipActive) || isTrue((isLessThan(inactiveCurrenciesPercentage, maxInactiveCurrenciesPercentage))), add(add(add(add("Percentage of inactive currencies is too high at ", ((object)inactiveCurrenciesPercentage).ToString()), "% that is more than the allowed maximum of "), ((object)maxInactiveCurrenciesPercentage).ToString()), "%"));
            detectCurrencyConflicts(exchange, currencies);
        }
        return true;
    }
    public static object detectCurrencyConflicts(Exchange exchange, object currencyValues)
    {
        // detect if there are currencies with different ids for the same code
        object ids = new Dictionary<string, object>() {};
        object keys = new List<object>(((IDictionary<string,object>)currencyValues).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object key = getValue(keys, i);
            object currency = getValue(currencyValues, key);
            object code = getValue(currency, "code");
            if (!isTrue((inOp(ids, code))))
            {
                ((IDictionary<string,object>)ids)[(string)code] = getValue(currency, "id");
            } else
            {
                object isDifferent = !isEqual(getValue(ids, code), getValue(currency, "id"));
                assert(!isTrue(isDifferent), add(add(add(add(add(add(exchange.id, " fetchCurrencies() has different ids for the same code: "), code), " "), getValue(ids, code)), " "), getValue(currency, "id")));
            }
        }
        return true;
    }

}