using ccxt;
using ccxt.pro;
namespace Tests;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class testMainClass : BaseTest
{
    async static public Task<object> testWatchLiquidationsForSymbols(Exchange exchange, object skippedProperties, object symbol)
    {
        object method = "watchLiquidationsForSymbols";
        // we have to skip some exchanges here due to the frequency of trading
        object skippedExchanges = new List<object>() {};
        if (isTrue(exchange.inArray(exchange.id, skippedExchanges)))
        {
            Console.WriteLine(exchange.id, add(method, "() test skipped"));
            return false;
        }
        if (!isTrue(getValue(exchange.has, method)))
        {
            Console.WriteLine(exchange.id, add(method, "() is not supported"));
            return false;
        }
        object response = null;
        object now = (new DateTimeOffset(DateTime.UtcNow)).ToUnixTimeMilliseconds();
        object ends = add(now, 10000);
        while (isLessThan(now, ends))
        {
            try
            {
                response = await ((Task<object>)callDynamically(exchange, method, new object[] { new List<object>() {symbol} }));
                now = (new DateTimeOffset(DateTime.UtcNow)).ToUnixTimeMilliseconds();
                object isArray = ((response is IList<object>) || (response.GetType().IsGenericType && response.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))));
                assert(isArray, "response must be an array");
                Console.WriteLine(exchange.iso8601(now), exchange.id, symbol, method, getArrayLength(new List<object>(((IDictionary<string,object>)response).Values)), "liquidations");
                // log.noLocate (asTable (response))
                for (object i = 0; isLessThan(i, getArrayLength(response)); postFixIncrement(ref i))
                {
                    testLiquidation(exchange, skippedProperties, method, getValue(response, i), symbol);
                }
            } catch(Exception e)
            {
                if (!isTrue((e is NetworkError)))
                {
                    throw e;
                }
                now = (new DateTimeOffset(DateTime.UtcNow)).ToUnixTimeMilliseconds();
            }
        }
        return response;
    }

}