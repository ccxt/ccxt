using ccxt;
using ccxt.pro;
namespace Tests;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class testMainClass : BaseTest
{
    async static public Task createOrderAfterDelay(Exchange exchange)
    {
        await exchange.sleep(3000);
        await exchange.createOrder("BTC/USDT:USDT", "market", "buy", 0.001);
    }
    async static public Task testUnwatchPositions(Exchange exchange, object skippedProperties, object symbol)
    {
        object method = "unWatchPositions";
        exchange.setSandboxMode(true);
        // First, we need to subscribe to positions to test the unsubscribe functionality
        object positionsSubscription = null;
        try
        {
            // First call uses snapshot
            positionsSubscription = await exchange.watchPositions();
            // trigger a position update
            exchange.spawn(createOrderAfterDelay, new object[] { exchange});
            // Second call uses subscription
            positionsSubscription = await exchange.watchPositions();
        } catch(Exception e)
        {
            if (!isTrue(testSharedMethods.isTemporaryFailure(e)))
            {
                throw e;
            }
            // If we can't subscribe, we can't test unsubscribe, so skip this test
            return;
        }
        // Verify that we have a subscription
        assert(((positionsSubscription is IList<object>) || (positionsSubscription.GetType().IsGenericType && positionsSubscription.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))), add(add(add(exchange.id, " "), method), " requires a valid positions subscription to test unsubscribe"));
        // Assert unWatchPositions for one symbol is not supported
        object errorResponse = null;
        try
        {
            errorResponse = await exchange.unWatchPositions(new List<object>() {symbol});
        } catch(Exception e)
        {
            errorResponse = e;
        }
        assert(!isEqual(errorResponse, null), add(add(add(add(exchange.id, " "), method), " must throw an error when unwatching a specific symbol, returned "), exchange.json(errorResponse)));
        // Test unwatching all positions (without specific symbols)
        object responseAll = null;
        try
        {
            responseAll = await exchange.unWatchPositions();
        } catch(Exception e)
        {
            if (!isTrue(testSharedMethods.isTemporaryFailure(e)))
            {
                throw e;
            }
            throw e;
        }
        // Verify the response for unwatching all positions
        assert(!isEqual(responseAll, null), add(add(add(add(exchange.id, " "), method), " must return a response when unwatching all positions, returned "), exchange.json(responseAll)));
        // Test that we can resubscribe after unwatching (to ensure cleanup was proper)
        object resubscribeResponse = null;
        try
        {
            resubscribeResponse = await exchange.watchPositions();
            exchange.spawn(createOrderAfterDelay, new object[] { exchange});
            resubscribeResponse = await exchange.watchPositions();
        } catch(Exception e)
        {
            if (!isTrue(testSharedMethods.isTemporaryFailure(e)))
            {
                throw e;
            }
            throw new Exception ((string)add(add(add(exchange.id, " "), method), " failed to resubscribe after unwatch, indicating potential cleanup issues")) ;
        }
        // Verify resubscription works
        assert(((resubscribeResponse is IList<object>) || (resubscribeResponse.GetType().IsGenericType && resubscribeResponse.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))), add(add(add(add(exchange.id, " "), method), " must allow resubscription after unwatch, returned "), exchange.json(resubscribeResponse)));
    }

}