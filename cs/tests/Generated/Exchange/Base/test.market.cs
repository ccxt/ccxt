using ccxt;
namespace Tests;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class testMainClass : BaseTest
{
    public static void testMarket(Exchange exchange, object skippedProperties, object method, object market)
    {
        object format = new Dictionary<string, object>() {
            { "id", "btcusd" },
            { "symbol", "BTC/USD" },
            { "base", "BTC" },
            { "quote", "USD" },
            { "taker", exchange.parseNumber("0.0011") },
            { "maker", exchange.parseNumber("0.0009") },
            { "baseId", "btc" },
            { "quoteId", "usd" },
            { "active", false },
            { "type", "spot" },
            { "linear", false },
            { "inverse", false },
            { "spot", false },
            { "swap", false },
            { "future", false },
            { "option", false },
            { "margin", false },
            { "contract", false },
            { "contractSize", exchange.parseNumber("0.001") },
            { "expiry", 1656057600000 },
            { "expiryDatetime", "2022-06-24T08:00:00.000Z" },
            { "optionType", "put" },
            { "strike", exchange.parseNumber("56000") },
            { "settle", "XYZ" },
            { "settleId", "Xyz" },
            { "precision", new Dictionary<string, object>() {
                { "price", exchange.parseNumber("0.001") },
                { "amount", exchange.parseNumber("0.001") },
                { "cost", exchange.parseNumber("0.001") },
            } },
            { "limits", new Dictionary<string, object>() {
                { "amount", new Dictionary<string, object>() {
                    { "min", exchange.parseNumber("0.01") },
                    { "max", exchange.parseNumber("1000") },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", exchange.parseNumber("0.01") },
                    { "max", exchange.parseNumber("1000") },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", exchange.parseNumber("0.01") },
                    { "max", exchange.parseNumber("1000") },
                } },
            } },
            { "marginModes", new Dictionary<string, object>() {
                { "cross", true },
                { "isolated", false },
            } },
            { "info", new Dictionary<string, object>() {} },
        };
        // temporary: only test QUANTO markets where that prop exists (todo: add in type later)
        if (isTrue(inOp(market, "quanto")))
        {
            ((IDictionary<string,object>)format)["quanto"] = false; // whether the market is QUANTO or not
        }
        // define locals
        object spot = getValue(market, "spot");
        object contract = getValue(market, "contract");
        object swap = getValue(market, "swap");
        object future = getValue(market, "future");
        object option = getValue(market, "option");
        object index = exchange.safeBool(market, "index"); // todo: unify
        object isIndex = isTrue((!isEqual(index, null))) && isTrue(index);
        object linear = getValue(market, "linear");
        object inverse = getValue(market, "inverse");
        object quanto = exchange.safeBool(market, "quanto"); // todo: unify
        object isQuanto = isTrue((!isEqual(quanto, null))) && isTrue(quanto);
        //
        object emptyAllowedFor = new List<object>() {"margin"};
        if (!isTrue(contract))
        {
            ((IList<object>)emptyAllowedFor).Add("contractSize");
            ((IList<object>)emptyAllowedFor).Add("linear");
            ((IList<object>)emptyAllowedFor).Add("inverse");
            ((IList<object>)emptyAllowedFor).Add("quanto");
            ((IList<object>)emptyAllowedFor).Add("settle");
            ((IList<object>)emptyAllowedFor).Add("settleId");
        }
        if (isTrue(!isTrue(future) && !isTrue(option)))
        {
            ((IList<object>)emptyAllowedFor).Add("expiry");
            ((IList<object>)emptyAllowedFor).Add("expiryDatetime");
        }
        if (!isTrue(option))
        {
            ((IList<object>)emptyAllowedFor).Add("optionType");
            ((IList<object>)emptyAllowedFor).Add("strike");
        }
        testSharedMethods.assertStructure(exchange, skippedProperties, method, market, format, emptyAllowedFor);
        testSharedMethods.assertSymbol(exchange, skippedProperties, method, market, "symbol");
        object logText = testSharedMethods.logTemplate(exchange, method, market);
        // check taker/maker
        // todo: check not all to be within 0-1.0
        testSharedMethods.assertGreater(exchange, skippedProperties, method, market, "taker", "-100");
        testSharedMethods.assertLess(exchange, skippedProperties, method, market, "taker", "100");
        testSharedMethods.assertGreater(exchange, skippedProperties, method, market, "maker", "-100");
        testSharedMethods.assertLess(exchange, skippedProperties, method, market, "maker", "100");
        // validate type
        object validTypes = new List<object>() {"spot", "margin", "swap", "future", "option", "index", "other"};
        testSharedMethods.assertInArray(exchange, skippedProperties, method, market, "type", validTypes);
        // validate subTypes
        object validSubTypes = new List<object>() {"linear", "inverse", "quanto", null};
        testSharedMethods.assertInArray(exchange, skippedProperties, method, market, "subType", validSubTypes);
        // check if 'type' is consistent
        object checkedTypes = new List<object>() {"spot", "swap", "future", "option"};
        for (object i = 0; isLessThan(i, getArrayLength(checkedTypes)); postFixIncrement(ref i))
        {
            object type = getValue(checkedTypes, i);
            if (isTrue(getValue(market, type)))
            {
                assert(isEqual(type, getValue(market, "type")), add(add(add(add(add("market.type (", getValue(market, "type")), ") not equal to \""), type), "\""), logText));
            }
        }
        // check if 'subType' is consistent
        if (isTrue(isTrue(swap) || isTrue(future)))
        {
            object checkedSubTypes = new List<object>() {"linear", "inverse"};
            for (object i = 0; isLessThan(i, getArrayLength(checkedSubTypes)); postFixIncrement(ref i))
            {
                object subType = getValue(checkedSubTypes, i);
                if (isTrue(getValue(market, subType)))
                {
                    assert(isEqual(subType, getValue(market, "subType")), add(add(add(add(add("market.subType (", getValue(market, "subType")), ") not equal to \""), subType), "\""), logText));
                }
            }
        }
        // margin check (todo: add margin as mandatory, instead of undefined)
        if (isTrue(spot))
        {
            // for spot market, 'margin' can be either true/false or undefined
            testSharedMethods.assertInArray(exchange, skippedProperties, method, market, "margin", new List<object>() {true, false, null});
        } else
        {
            // otherwise, it must be false or undefined
            testSharedMethods.assertInArray(exchange, skippedProperties, method, market, "margin", new List<object>() {false, null});
        }
        // check mutually exclusive fields
        if (isTrue(spot))
        {
            assert(isTrue(isTrue(isTrue(isTrue(!isTrue(contract) && isTrue(isEqual(linear, null))) && isTrue(isEqual(inverse, null))) && !isTrue(option)) && !isTrue(swap)) && !isTrue(future), add("for spot market, none of contract/linear/inverse/option/swap/future should be set", logText));
        } else
        {
            // if not spot, any of the below should be true
            assert(isTrue(contract) && isTrue((isTrue(isTrue(isTrue(future) || isTrue(swap)) || isTrue(option)) || isTrue(isIndex))), add("for non-spot markets, any of (future/swap/option/index) should be set", logText));
        }
        object contractSize = exchange.safeString(market, "contractSize");
        // contract fields
        if (isTrue(contract))
        {
            if (isTrue(isQuanto))
            {
                assert(isEqual(linear, false), add("linear must be false when \"quanto\" is true", logText));
                assert(isEqual(inverse, false), add("inverse must be false when \"quanto\" is true", logText));
            } else
            {
                // if false or undefined
                assert(!isEqual(inverse, null), add("inverse must be defined when \"contract\" is true", logText));
                assert(!isEqual(linear, null), add("linear must be defined when \"contract\" is true", logText));
                assert(!isEqual(linear, inverse), add("linear and inverse must not be the same", logText));
            }
            // contract size should be defined
            assert((isTrue((inOp(skippedProperties, "contractSize"))) || isTrue(!isEqual(contractSize, null))), add("\"contractSize\" must be defined when \"contract\" is true", logText));
            // contract size should be above zero
            assert(isTrue((inOp(skippedProperties, "contractSize"))) || isTrue(Precise.stringGt(contractSize, "0")), add("\"contractSize\" must be > 0 when \"contract\" is true", logText));
            // settle should be defined
            assert(isTrue((inOp(skippedProperties, "settle"))) || isTrue((isTrue(!isEqual(getValue(market, "settle"), null)) && isTrue(!isEqual(getValue(market, "settleId"), null)))), add("\"settle\" & \"settleId\" must be defined when \"contract\" is true", logText));
        } else
        {
            // linear & inverse needs to be undefined
            assert(isTrue(isTrue(isEqual(linear, null)) && isTrue(isEqual(inverse, null))) && isTrue(isEqual(quanto, null)), add("market linear and inverse (and quanto) must be undefined when \"contract\" is false", logText));
            // contract size should be undefined
            assert(isEqual(contractSize, null), add("\"contractSize\" must be undefined when \"contract\" is false", logText));
            // settle should be undefined
            assert(isTrue((isEqual(getValue(market, "settle"), null))) && isTrue((isEqual(getValue(market, "settleId"), null))), add("\"settle\" must be undefined when \"contract\" is false", logText));
        }
        // future, swap and option should be mutually exclusive
        if (isTrue(getValue(market, "future")))
        {
            assert(isTrue(!isTrue(getValue(market, "swap")) && !isTrue(getValue(market, "option"))) && !isTrue(isIndex), add("market swap and option must be false when \"future\" is true", logText));
        } else if (isTrue(getValue(market, "swap")))
        {
            assert(!isTrue(getValue(market, "future")) && !isTrue(getValue(market, "option")), add("market future and option must be false when \"swap\" is true", logText));
        } else if (isTrue(getValue(market, "option")))
        {
            assert(!isTrue(getValue(market, "future")) && !isTrue(getValue(market, "swap")), add("market future and swap must be false when \"option\" is true", logText));
        }
        // check specific fields for options & futures
        if (isTrue(isTrue(option) || isTrue(future)))
        {
            // future or option markets need 'expiry' and 'expiryDatetime'
            assert(!isEqual(getValue(market, "expiry"), null), add("\"expiry\" must be defined when \"future\" is true", logText));
            assert(!isEqual(getValue(market, "expiryDatetime"), null), add("\"expiryDatetime\" must be defined when \"future\" is true", logText));
            // expiry datetime should be correct
            object isoString = exchange.iso8601(getValue(market, "expiry"));
            assert(isEqual(getValue(market, "expiryDatetime"), isoString), add(add(add(add(add("expiryDatetime (\"", getValue(market, "expiryDatetime")), "\") must be equal to expiry in iso8601 format \""), isoString), "\""), logText));
            testSharedMethods.assertGreater(exchange, skippedProperties, method, market, "expiry", "0");
            if (isTrue(option))
            {
                // strike should be defined
                assert(!isEqual(getValue(market, "strike"), null), add("\"strike\" must be defined when \"option\" is true", logText));
                testSharedMethods.assertGreater(exchange, skippedProperties, method, market, "strike", "0");
                // optionType should be defined
                assert(!isEqual(getValue(market, "optionType"), null), add("\"optionType\" must be defined when \"option\" is true", logText));
                testSharedMethods.assertInArray(exchange, skippedProperties, method, market, "optionType", new List<object>() {"put", "call"});
            } else
            {
                // if not option, then strike and optionType should be undefined
                assert(isEqual(getValue(market, "strike"), null), add("\"strike\" must be undefined when \"option\" is false", logText));
                assert(isEqual(getValue(market, "optionType"), null), add("\"optionType\" must be undefined when \"option\" is false", logText));
            }
        } else
        {
            // otherwise, expiry needs to be undefined
            assert(isTrue((isEqual(getValue(market, "expiry"), null))) && isTrue((isEqual(getValue(market, "expiryDatetime"), null))), add("\"expiry\" and \"expiryDatetime\" must be undefined when it is not future|option market", logText));
        }
        // check precisions
        object precisionKeys = new List<object>(((IDictionary<string,object>)getValue(market, "precision")).Keys);
        object precisionKeysLen = getArrayLength(precisionKeys);
        assert(isGreaterThanOrEqual(precisionKeysLen, 2), add("precision should have \"amount\" and \"price\" keys at least", logText));
        for (object i = 0; isLessThan(i, getArrayLength(precisionKeys)); postFixIncrement(ref i))
        {
            object priceOrAmountKey = getValue(precisionKeys, i);
            // only allow very high priced markets (wher coin costs around 100k) to have a 5$ price tickSize
            object isExclusivePair = isEqual(getValue(market, "baseId"), "BTC");
            object isNonSpot = !isTrue(spot); // such high precision is only allowed in contract markets
            object isPrice = isEqual(priceOrAmountKey, "price");
            object isTickSize5 = Precise.stringEq("5", exchange.safeString(getValue(market, "precision"), priceOrAmountKey));
            if (isTrue(isTrue(isTrue(isTrue(isNonSpot) && isTrue(isPrice)) && isTrue(isExclusivePair)) && isTrue(isTickSize5)))
            {
                continue;
            }
            if (!isTrue((inOp(skippedProperties, "precision"))))
            {
                testSharedMethods.checkPrecisionAccuracy(exchange, skippedProperties, method, getValue(market, "precision"), priceOrAmountKey);
            }
        }
        object isInactiveMarket = isEqual(getValue(market, "active"), false);
        // check limits
        object limitsKeys = new List<object>(((IDictionary<string,object>)getValue(market, "limits")).Keys);
        object limitsKeysLength = getArrayLength(limitsKeys);
        assert(isGreaterThanOrEqual(limitsKeysLength, 3), add("limits should have \"amount\", \"price\" and \"cost\" keys at least", logText));
        for (object i = 0; isLessThan(i, getArrayLength(limitsKeys)); postFixIncrement(ref i))
        {
            object key = getValue(limitsKeys, i);
            object limitEntry = getValue(getValue(market, "limits"), key);
            if (isTrue(isInactiveMarket))
            {
                continue;
            } // check limits
            if (!isTrue((inOp(skippedProperties, "limits"))))
            {
                // min >= 0
                testSharedMethods.assertGreaterOrEqual(exchange, skippedProperties, method, limitEntry, "min", "0");
                // max >= 0
                testSharedMethods.assertGreater(exchange, skippedProperties, method, limitEntry, "max", "0");
                // max >= min
                object minString = exchange.safeString(limitEntry, "min");
                if (isTrue(!isEqual(minString, null)))
                {
                    testSharedMethods.assertGreaterOrEqual(exchange, skippedProperties, method, limitEntry, "max", minString);
                }
            }
        }
        // check currencies
        testSharedMethods.assertValidCurrencyIdAndCode(exchange, skippedProperties, method, market, getValue(market, "baseId"), getValue(market, "base"));
        testSharedMethods.assertValidCurrencyIdAndCode(exchange, skippedProperties, method, market, getValue(market, "quoteId"), getValue(market, "quote"));
        testSharedMethods.assertValidCurrencyIdAndCode(exchange, skippedProperties, method, market, getValue(market, "settleId"), getValue(market, "settle"));
        // check ts
        testSharedMethods.assertTimestamp(exchange, skippedProperties, method, market, null, "created");
        // margin modes
        if (!isTrue((inOp(skippedProperties, "marginModes"))))
        {
            object marginModes = exchange.safeDict(market, "marginModes"); // in future, remove safeDict
            assert(inOp(marginModes, "cross"), add("marginModes should have \"cross\" key", logText));
            assert(inOp(marginModes, "isolated"), add("marginModes should have \"isolated\" key", logText));
            testSharedMethods.assertInArray(exchange, skippedProperties, method, marginModes, "cross", new List<object>() {true, false, null});
            testSharedMethods.assertInArray(exchange, skippedProperties, method, marginModes, "isolated", new List<object>() {true, false, null});
        }
    }

}