using ccxt;
namespace Tests;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class testMainClass : BaseTest
{
    public partial class SharedMethods
    {
        public object logTemplate(Exchange exchange, object method, object entry)
        {
            // there are cases when exchange is undefined (eg. base tests)
            object id = ((bool) isTrue((!isEqual(exchange, null)))) ? exchange.id : "undefined";
            object methodString = ((bool) isTrue((!isEqual(method, null)))) ? method : "undefined";
            object entryString = ((bool) isTrue((!isEqual(exchange, null)))) ? exchange.json(entry) : "";
            return add(add(add(add(add(add(" <<< ", id), " "), methodString), " ::: "), entryString), " >>> ");
        }
        public object isTemporaryFailure(object e)
        {
            return isTrue((e is OperationFailed)) && isTrue((!isTrue((e is OnMaintenance))));
        }
        public object stringValue(object value)
        {
            object stringVal = null;
            if (isTrue((value is string)))
            {
                stringVal = value;
            } else if (isTrue(isEqual(value, null)))
            {
                stringVal = "undefined";
            } else
            {
                stringVal = ((object)value).ToString();
            }
            return stringVal;
        }
        public object assertType(Exchange exchange, object skippedProperties, object entry, object key, object format)
        {
            if (isTrue(inOp(skippedProperties, key)))
            {
                return null;
            }
            // because "typeof" string is not transpilable without === 'name', we list them manually at this moment
            object entryKeyVal = exchange.safeValue(entry, key);
            object formatKeyVal = exchange.safeValue(format, key);
            object same_string = isTrue(((entryKeyVal is string))) && isTrue(((formatKeyVal is string)));
            object same_numeric = isTrue(((entryKeyVal is Int64 || entryKeyVal is int || entryKeyVal is float || entryKeyVal is double))) && isTrue(((formatKeyVal is Int64 || formatKeyVal is int || formatKeyVal is float || formatKeyVal is double)));
            object same_boolean = isTrue((isTrue((isEqual(entryKeyVal, true))) || isTrue((isEqual(entryKeyVal, false))))) && isTrue((isTrue((isEqual(formatKeyVal, true))) || isTrue((isEqual(formatKeyVal, false)))));
            object same_array = isTrue(((entryKeyVal is IList<object>) || (entryKeyVal.GetType().IsGenericType && entryKeyVal.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))) && isTrue(((formatKeyVal is IList<object>) || (formatKeyVal.GetType().IsGenericType && formatKeyVal.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))));
            object same_object = isTrue(((entryKeyVal is IDictionary<string, object>))) && isTrue(((formatKeyVal is IDictionary<string, object>)));
            object result = isTrue(isTrue(isTrue(isTrue(isTrue((isEqual(entryKeyVal, null))) || isTrue(same_string)) || isTrue(same_numeric)) || isTrue(same_boolean)) || isTrue(same_array)) || isTrue(same_object);
            return result;
        }
        public void assertStructure(Exchange exchange, object skippedProperties, object method, object entry, object format, object emptyAllowedFor = null, object deep = null)
        {
            deep ??= false;
            object logText = logTemplate(exchange, method, entry);
            assert(!isEqual(entry, null), add("item is null/undefined", logText));
            // get all expected & predefined keys for this specific item and ensure thos ekeys exist in parsed structure
            object allowEmptySkips = exchange.safeList(skippedProperties, "allowNull", new List<object>() {});
            if (isTrue(!isEqual(emptyAllowedFor, null)))
            {
                emptyAllowedFor = concat(emptyAllowedFor, allowEmptySkips);
            }
            if (isTrue(((format is IList<object>) || (format.GetType().IsGenericType && format.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
            {
                assert(((entry is IList<object>) || (entry.GetType().IsGenericType && entry.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))), add("entry is not an array", logText));
                object realLength = getArrayLength(entry);
                object expectedLength = getArrayLength(format);
                assert(isEqual(realLength, expectedLength), add(add("entry length is not equal to expected length of ", ((object)expectedLength).ToString()), logText));
                for (object i = 0; isLessThan(i, getArrayLength(format)); postFixIncrement(ref i))
                {
                    object emptyAllowedForThisKey = isTrue((isEqual(emptyAllowedFor, null))) || isTrue(exchange.inArray(i, emptyAllowedFor));
                    object value = getValue(entry, i);
                    if (isTrue(inOp(skippedProperties, i)))
                    {
                        continue;
                    }
                    // check when:
                    // - it's not inside "allowe empty values" list
                    // - it's not undefined
                    if (isTrue(isTrue(emptyAllowedForThisKey) && isTrue((isEqual(value, null)))))
                    {
                        continue;
                    }
                    assert(!isEqual(value, null), add(add(((object)i).ToString(), " index is expected to have a value"), logText));
                    // because of other langs, this is needed for arrays
                    object typeAssertion = assertType(exchange, skippedProperties, entry, i, format);
                    assert(typeAssertion, add(add(((object)i).ToString(), " index does not have an expected type "), logText));
                }
            } else
            {
                assert((entry is IDictionary<string, object>), add("entry is not an object", logText));
                object keys = new List<object>(((IDictionary<string,object>)format).Keys);
                for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
                {
                    object key = getValue(keys, i);
                    if (isTrue(inOp(skippedProperties, key)))
                    {
                        continue;
                    }
                    assert(inOp(entry, key), add(add(add("\"", stringValue(key)), "\" key is missing from structure"), logText));
                    if (isTrue(inOp(skippedProperties, key)))
                    {
                        continue;
                    }
                    object emptyAllowedForThisKey = isTrue((isEqual(emptyAllowedFor, null))) || isTrue(exchange.inArray(key, emptyAllowedFor));
                    object value = getValue(entry, key);
                    // check when:
                    // - it's not inside "allowe empty values" list
                    // - it's not undefined
                    if (isTrue(isTrue(emptyAllowedForThisKey) && isTrue((isEqual(value, null)))))
                    {
                        continue;
                    }
                    // if it was in needed keys, then it should have value.
                    assert(!isEqual(value, null), add(add(add("\"", stringValue(key)), "\" key is expected to have a value"), logText));
                    // add exclusion for info key, as it can be any type
                    if (isTrue(!isEqual(key, "info")))
                    {
                        object typeAssertion = assertType(exchange, skippedProperties, entry, key, format);
                        assert(typeAssertion, add(add(add("\"", stringValue(key)), "\" key is neither undefined, neither of expected type"), logText));
                        if (isTrue(deep))
                        {
                            if (isTrue((value is IDictionary<string, object>)))
                            {
                                assertStructure(exchange, skippedProperties, method, value, getValue(format, key), emptyAllowedFor, deep);
                            }
                        }
                    }
                }
            }
        }
        public void assertTimestamp(Exchange exchange, object skippedProperties, object method, object entry, object nowToCheck = null, object keyNameOrIndex = null, object allowNull = null)
        {
            keyNameOrIndex ??= "timestamp";
            allowNull ??= true;
            object logText = logTemplate(exchange, method, entry);
            object skipValue = exchange.safeValue(skippedProperties, keyNameOrIndex);
            if (isTrue(!isEqual(skipValue, null)))
            {
                return;  // skipped
            }
            object isDateTimeObject = (keyNameOrIndex is string);
            if (isTrue(isDateTimeObject))
            {
                assert((inOp(entry, keyNameOrIndex)), add(add(add("timestamp key \"", keyNameOrIndex), "\" is missing from structure"), logText));
            } else
            {
                // if index was provided (mostly from fetchOHLCV) then we check if it exists, as mandatory
                assert(!isTrue((isEqual(getValue(entry, keyNameOrIndex), null))), add(add(add("timestamp index ", stringValue(keyNameOrIndex)), " is undefined"), logText));
            }
            object ts = getValue(entry, keyNameOrIndex);
            assert(isTrue(!isEqual(ts, null)) || isTrue(allowNull), add("timestamp is null", logText));
            if (isTrue(!isEqual(ts, null)))
            {
                assert((ts is Int64 || ts is int || ts is float || ts is double), add("timestamp is not numeric", logText));
                assert(((ts is int) || (ts is long) || (ts is Int32) || (ts is Int64)), add("timestamp should be an integer", logText));
                object minTs = 1230940800000; // 03 Jan 2009 - first block
                object maxTs = 2147483648000; // 19 Jan 2038 - max int
                assert(isGreaterThan(ts, minTs), add(add(add("timestamp is impossible to be before ", ((object)minTs).ToString()), " (03.01.2009)"), logText)); // 03 Jan 2009 - first block
                assert(isLessThan(ts, maxTs), add(add(add("timestamp more than ", ((object)maxTs).ToString()), " (19.01.2038)"), logText)); // 19 Jan 2038 - int32 overflows // 7258118400000  -> Jan 1 2200
                if (isTrue(!isEqual(nowToCheck, null)))
                {
                    object maxMsOffset = 60000; // 1 min
                    assert(isLessThan(ts, add(nowToCheck, maxMsOffset)), add(add(add(add(add("returned item timestamp (", exchange.iso8601(ts)), ") is ahead of the current time ("), exchange.iso8601(nowToCheck)), ")"), logText));
                }
            }
        }
        public void assertTimestampAndDatetime(Exchange exchange, object skippedProperties, object method, object entry, object nowToCheck = null, object keyNameOrIndex = null, object allowNull = null)
        {
            keyNameOrIndex ??= "timestamp";
            allowNull ??= true;
            object logText = logTemplate(exchange, method, entry);
            object skipValue = exchange.safeValue(skippedProperties, keyNameOrIndex);
            if (isTrue(!isEqual(skipValue, null)))
            {
                return;
            }
            assertTimestamp(exchange, skippedProperties, method, entry, nowToCheck, keyNameOrIndex);
            object isDateTimeObject = (keyNameOrIndex is string);
            // only in case if the entry is a dictionary, thus it must have 'timestamp' & 'datetime' string keys
            if (isTrue(isDateTimeObject))
            {
                // we also test 'datetime' here because it's certain sibling of 'timestamp'
                assert((inOp(entry, "datetime")), add("\"datetime\" key is missing from structure", logText));
                object dt = getValue(entry, "datetime");
                assert(isTrue(!isEqual(dt, null)) || isTrue(allowNull), add("timestamp is null", logText));
                if (isTrue(!isEqual(dt, null)))
                {
                    assert((dt is string), add("\"datetime\" key does not have a string value", logText));
                    // there are exceptional cases, like getting microsecond-targeted string '2022-08-08T22:03:19.014680Z', so parsed unified timestamp, which carries only 13 digits (millisecond precision) can not be stringified back to microsecond accuracy, causing the bellow assertion to fail
                    //    assert (dt === exchange.iso8601 (entry['timestamp']))
                    // so, we have to compare with millisecond accururacy
                    object dtParsed = exchange.parse8601(dt);
                    object tsMs = getValue(entry, "timestamp");
                    object diff = Math.Abs(Convert.ToDouble(subtract(dtParsed, tsMs)));
                    if (isTrue(isGreaterThanOrEqual(diff, 500)))
                    {
                        object dtParsedString = exchange.iso8601(dtParsed);
                        object dtEntryString = exchange.iso8601(tsMs);
                        assert(false, add(add(add(add(add("datetime is not iso8601 of timestamp:", dtParsedString), "(string) != "), dtEntryString), "(from ts)"), logText));
                    }
                }
            }
        }
        public void assertCurrencyCode(Exchange exchange, object skippedProperties, object method, object entry, object actualCode, object expectedCode = null, object allowNull = null)
        {
            allowNull ??= true;
            if (isTrue(isTrue((inOp(skippedProperties, "currency"))) || isTrue((inOp(skippedProperties, "currencyIdAndCode")))))
            {
                return;
            }
            object logText = logTemplate(exchange, method, entry);
            assert(isTrue(!isEqual(actualCode, null)) || isTrue(allowNull), add("currency code is null", logText));
            if (isTrue(!isEqual(actualCode, null)))
            {
                assert((actualCode is string), add("currency code should be either undefined or a string", logText));
                assert((inOp(exchange.currencies, actualCode)), add(add(add("currency code (\"", actualCode), "\") should be present in exchange.currencies"), logText));
                if (isTrue(!isEqual(expectedCode, null)))
                {
                    assert(isEqual(actualCode, expectedCode), add(add(add(add(add("currency code in response (\"", stringValue(actualCode)), "\") should be equal to expected code (\""), stringValue(expectedCode)), "\")"), logText));
                }
            }
        }
        public void assertValidCurrencyIdAndCode(Exchange exchange, object skippedProperties, object method, object entry, object currencyId, object currencyCode, object allowNull = null)
        {
            // this is exclusive exceptional key name to be used in `skip-tests.json`, to skip check for currency id and code
            allowNull ??= true;
            if (isTrue(isTrue((inOp(skippedProperties, "currency"))) || isTrue((inOp(skippedProperties, "currencyIdAndCode")))))
            {
                return;
            }
            object logText = logTemplate(exchange, method, entry);
            object undefinedValues = isTrue(isEqual(currencyId, null)) && isTrue(isEqual(currencyCode, null));
            object definedValues = isTrue(!isEqual(currencyId, null)) && isTrue(!isEqual(currencyCode, null));
            assert(isTrue(undefinedValues) || isTrue(definedValues), add("currencyId and currencyCode should be either both defined or both undefined", logText));
            assert(isTrue(definedValues) || isTrue(allowNull), add("currency code and id is not defined", logText));
            if (isTrue(definedValues))
            {
                // check by code
                object currencyByCode = exchange.currency(currencyCode);
                assert(isEqual(getValue(currencyByCode, "id"), currencyId), add(add(add(add(add("currencyId \"", stringValue(currencyId)), "\" does not match currency id from instance: \""), stringValue(getValue(currencyByCode, "id"))), "\""), logText));
                // check by id
                object currencyById = exchange.safeCurrency(currencyId);
                assert(isEqual(getValue(currencyById, "code"), currencyCode), add(add(add(add("currencyCode ", stringValue(currencyCode)), " does not match currency of id: "), stringValue(currencyId)), logText));
            }
        }
        public void assertSymbol(Exchange exchange, object skippedProperties, object method, object entry, object key, object expectedSymbol = null, object allowNull = null)
        {
            allowNull ??= true;
            if (isTrue(inOp(skippedProperties, key)))
            {
                return;
            }
            object logText = logTemplate(exchange, method, entry);
            object actualSymbol = exchange.safeString(entry, key);
            if (isTrue(!isEqual(actualSymbol, null)))
            {
                assert((actualSymbol is string), add("symbol should be either undefined or a string", logText));
            }
            if (isTrue(!isEqual(expectedSymbol, null)))
            {
                assert(isEqual(actualSymbol, expectedSymbol), add(add(add(add(add("symbol in response (\"", stringValue(actualSymbol)), "\") should be equal to expected symbol (\""), stringValue(expectedSymbol)), "\")"), logText));
            }
            object definedValues = isTrue(!isEqual(actualSymbol, null)) && isTrue(!isEqual(expectedSymbol, null));
            assert(isTrue(definedValues) || isTrue(allowNull), add("symbols are not defined", logText));
        }
        public void assertSymbolInMarkets(Exchange exchange, object skippedProperties, object method, object symbol)
        {
            object logText = logTemplate(exchange, method, new Dictionary<string, object>() {});
            assert((inOp(exchange.markets, symbol)), add("symbol should be present in exchange.symbols", logText));
        }
        public void assertGreater(Exchange exchange, object skippedProperties, object method, object entry, object key, object compareTo, object allowNull = null)
        {
            allowNull ??= true;
            if (isTrue(inOp(skippedProperties, key)))
            {
                return;
            }
            object logText = logTemplate(exchange, method, entry);
            object value = exchange.safeString(entry, key);
            assert(isTrue(!isEqual(value, null)) || isTrue(allowNull), add("value is null", logText));
            if (isTrue(!isEqual(value, null)))
            {
                assert(Precise.stringGt(value, compareTo), add(add(add(add(add(stringValue(key), " key (with a value of "), stringValue(value)), ") was expected to be > "), stringValue(compareTo)), logText));
            }
        }
        public void assertGreaterOrEqual(Exchange exchange, object skippedProperties, object method, object entry, object key, object compareTo, object allowNull = null)
        {
            allowNull ??= true;
            if (isTrue(inOp(skippedProperties, key)))
            {
                return;
            }
            object logText = logTemplate(exchange, method, entry);
            object value = exchange.safeString(entry, key);
            assert(isTrue(!isEqual(value, null)) || isTrue(allowNull), add("value is null", logText));
            if (isTrue(isTrue(!isEqual(value, null)) && isTrue(!isEqual(compareTo, null))))
            {
                assert(Precise.stringGe(value, compareTo), add(add(add(add(add(stringValue(key), " key (with a value of "), stringValue(value)), ") was expected to be >= "), stringValue(compareTo)), logText));
            }
        }
        public void assertLess(Exchange exchange, object skippedProperties, object method, object entry, object key, object compareTo, object allowNull = null)
        {
            allowNull ??= true;
            if (isTrue(inOp(skippedProperties, key)))
            {
                return;
            }
            object logText = logTemplate(exchange, method, entry);
            object value = exchange.safeString(entry, key);
            assert(isTrue(!isEqual(value, null)) || isTrue(allowNull), add("value is null", logText));
            if (isTrue(isTrue(!isEqual(value, null)) && isTrue(!isEqual(compareTo, null))))
            {
                assert(Precise.stringLt(value, compareTo), add(add(add(add(add(stringValue(key), " key (with a value of "), stringValue(value)), ") was expected to be < "), stringValue(compareTo)), logText));
            }
        }
        public void assertLessOrEqual(Exchange exchange, object skippedProperties, object method, object entry, object key, object compareTo, object allowNull = null)
        {
            allowNull ??= true;
            if (isTrue(inOp(skippedProperties, key)))
            {
                return;
            }
            object logText = logTemplate(exchange, method, entry);
            object value = exchange.safeString(entry, key);
            assert(isTrue(!isEqual(value, null)) || isTrue(allowNull), add("value is null", logText));
            if (isTrue(isTrue(!isEqual(value, null)) && isTrue(!isEqual(compareTo, null))))
            {
                assert(Precise.stringLe(value, compareTo), add(add(add(add(add(stringValue(key), " key (with a value of "), stringValue(value)), ") was expected to be <= "), stringValue(compareTo)), logText));
            }
        }
        public void assertEqual(Exchange exchange, object skippedProperties, object method, object entry, object key, object compareTo, object allowNull = null)
        {
            allowNull ??= true;
            if (isTrue(inOp(skippedProperties, key)))
            {
                return;
            }
            object logText = logTemplate(exchange, method, entry);
            object value = exchange.safeString(entry, key);
            assert(isTrue(!isEqual(value, null)) || isTrue(allowNull), add("value is null", logText));
            if (isTrue(isTrue(!isEqual(value, null)) && isTrue(!isEqual(compareTo, null))))
            {
                assert(Precise.stringEq(value, compareTo), add(add(add(add(add(stringValue(key), " key (with a value of "), stringValue(value)), ") was expected to be equal to "), stringValue(compareTo)), logText));
            }
        }
        public void assertNonEqual(Exchange exchange, object skippedProperties, object method, object entry, object key, object compareTo, object allowNull = null)
        {
            allowNull ??= true;
            if (isTrue(inOp(skippedProperties, key)))
            {
                return;
            }
            object logText = logTemplate(exchange, method, entry);
            object value = exchange.safeString(entry, key);
            assert(isTrue(!isEqual(value, null)) || isTrue(allowNull), add("value is null", logText));
            if (isTrue(!isEqual(value, null)))
            {
                assert(!isTrue(Precise.stringEq(value, compareTo)), add(add(add(add(add(stringValue(key), " key (with a value of "), stringValue(value)), ") was expected not to be equal to "), stringValue(compareTo)), logText));
            }
        }
        public void assertInArray(Exchange exchange, object skippedProperties, object method, object entry, object key, object expectedArray, object allowNull = null)
        {
            allowNull ??= true;
            if (isTrue(inOp(skippedProperties, key)))
            {
                return;
            }
            object logText = logTemplate(exchange, method, entry);
            object value = exchange.safeValue(entry, key);
            assert(isTrue(!isEqual(value, null)) || isTrue(allowNull), add("value is null", logText));
            // todo: remove undefined check
            if (isTrue(!isEqual(value, null)))
            {
                object stingifiedArrayValue = exchange.json(expectedArray); // don't use expectedArray.join (','), as it bugs in other languages, if values are bool, undefined or etc..
                assert(exchange.inArray(value, expectedArray), add(add(add(add(add(add(add("\"", stringValue(key)), "\" key (value \""), stringValue(value)), "\") is not from the expected list : ["), stingifiedArrayValue), "]"), logText));
            }
        }
        public void assertFeeStructure(Exchange exchange, object skippedProperties, object method, object entry, object key, object allowNull = null)
        {
            allowNull ??= true;
            object logText = logTemplate(exchange, method, entry);
            object keyString = stringValue(key);
            if (isTrue(((key is int) || (key is long) || (key is Int32) || (key is Int64))))
            {
                assert(((entry is IList<object>) || (entry.GetType().IsGenericType && entry.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))), add("fee container is expected to be an array", logText));
                assert(isLessThan(key, getArrayLength(entry)), add(add(add("fee key ", keyString), " was expected to be present in entry"), logText));
            } else
            {
                assert((entry is IDictionary<string, object>), add("fee container is expected to be an object", logText));
                assert(inOp(entry, key), add(add(add("fee key \"", key), "\" was expected to be present in entry"), logText));
            }
            object feeObject = exchange.safeValue(entry, key);
            assert(isTrue(!isEqual(feeObject, null)) || isTrue(allowNull), add("fee object is null", logText));
            // todo: remove undefined check to make stricter
            if (isTrue(!isEqual(feeObject, null)))
            {
                assert(inOp(feeObject, "cost"), add(add(keyString, " fee object should contain \"cost\" key"), logText));
                if (isTrue(isEqual(getValue(feeObject, "cost"), null)))
                {
                    return;  // todo: remove undefined check to make stricter
                }
                assert((getValue(feeObject, "cost") is Int64 || getValue(feeObject, "cost") is int || getValue(feeObject, "cost") is float || getValue(feeObject, "cost") is double), add(add(keyString, " \"cost\" must be numeric type"), logText));
                // assertGreaterOrEqual (exchange, skippedProperties, method, feeObject, 'cost', '0'); // fee might be negative in the case of a rebate or reward
                assert(inOp(feeObject, "currency"), add(add(add("\"", keyString), "\" fee object should contain \"currency\" key"), logText));
                assertCurrencyCode(exchange, skippedProperties, method, entry, getValue(feeObject, "currency"));
            }
        }
        public void assertTimestampOrder(Exchange exchange, object method, object codeOrSymbol, object items, object ascending = null)
        {
            ascending ??= true;
            for (object i = 0; isLessThan(i, getArrayLength(items)); postFixIncrement(ref i))
            {
                if (isTrue(isGreaterThan(i, 0)))
                {
                    object currentTs = getValue(getValue(items, subtract(i, 1)), "timestamp");
                    object nextTs = getValue(getValue(items, i), "timestamp");
                    if (isTrue(isTrue(!isEqual(currentTs, null)) && isTrue(!isEqual(nextTs, null))))
                    {
                        object ascendingOrDescending = ((bool) isTrue(ascending)) ? "ascending" : "descending";
                        object comparison = ((bool) isTrue(ascending)) ? (isLessThanOrEqual(currentTs, nextTs)) : (isGreaterThanOrEqual(currentTs, nextTs));
                        assert(comparison, add(add(add(add(add(add(add(add(add(add(add(add(exchange.id, " "), method), " "), stringValue(codeOrSymbol)), " must return a "), ascendingOrDescending), " sorted array of items by timestamp, but "), ((object)currentTs).ToString()), " is opposite with its next "), ((object)nextTs).ToString()), " "), exchange.json(items)));
                    }
                }
            }
        }
        public void assertInteger(Exchange exchange, object skippedProperties, object method, object entry, object key, object allowNull = null)
        {
            allowNull ??= true;
            if (isTrue(inOp(skippedProperties, key)))
            {
                return;
            }
            object logText = logTemplate(exchange, method, entry);
            if (isTrue(!isEqual(entry, null)))
            {
                object value = exchange.safeValue(entry, key);
                assert(isTrue(!isEqual(value, null)) || isTrue(allowNull), add("value is null", logText));
                if (isTrue(!isEqual(value, null)))
                {
                    object isInteger = ((value is int) || (value is long) || (value is Int32) || (value is Int64));
                    assert(isInteger, add(add(add(add(add("\"", stringValue(key)), "\" key (value \""), stringValue(value)), "\") is not an integer"), logText));
                }
            }
        }
        public void checkPrecisionAccuracy(Exchange exchange, object skippedProperties, object method, object entry, object key)
        {
            if (isTrue(inOp(skippedProperties, key)))
            {
                return;
            }
            if (isTrue(exchange.isTickPrecision()))
            {
                // TICK_SIZE should be above zero
                assertGreater(exchange, skippedProperties, method, entry, key, "0");
                // the below array of integers are inexistent tick-sizes (theoretically technically possible, but not in real-world cases), so their existence in our case indicates to incorrectly implemented tick-sizes, which might mistakenly be implemented with DECIMAL_PLACES, so we throw error
                object decimalNumbers = new List<object>() {"2", "3", "4", "5", "6", "7", "8", "9", "11", "12", "13", "14", "15", "16"};
                for (object i = 0; isLessThan(i, getArrayLength(decimalNumbers)); postFixIncrement(ref i))
                {
                    object num = getValue(decimalNumbers, i);
                    object numStr = num;
                    assertNonEqual(exchange, skippedProperties, method, entry, key, numStr);
                }
            } else
            {
                // todo: significant-digits return doubles from `this.parseNumber`, so for now can't assert against integer atm
                // assertInteger (exchange, skippedProperties, method, entry, key); // should be integer
                assertLessOrEqual(exchange, skippedProperties, method, entry, key, "18"); // should be under 18 decimals
                assertGreaterOrEqual(exchange, skippedProperties, method, entry, key, "-8"); // in real-world cases, there would not be less than that
            }
        }
        async public Task<object> fetchBestBidAsk(Exchange exchange, object method, object symbol)
        {
            object logText = logTemplate(exchange, method, new Dictionary<string, object>() {});
            // find out best bid/ask price
            object bestBid = null;
            object bestAsk = null;
            object usedMethod = null;
            if (isTrue(getValue(exchange.has, "fetchOrderBook")))
            {
                usedMethod = "fetchOrderBook";
                object orderbook = await exchange.fetchOrderBook(symbol);
                object bids = exchange.safeList(orderbook, "bids");
                object asks = exchange.safeList(orderbook, "asks");
                object bestBidArray = exchange.safeList(bids, 0);
                object bestAskArray = exchange.safeList(asks, 0);
                bestBid = exchange.safeNumber(bestBidArray, 0);
                bestAsk = exchange.safeNumber(bestAskArray, 0);
            } else if (isTrue(getValue(exchange.has, "fetchBidsAsks")))
            {
                usedMethod = "fetchBidsAsks";
                object tickers = await exchange.fetchBidsAsks(new List<object>() {symbol});
                object ticker = exchange.safeDict(tickers, symbol);
                bestBid = exchange.safeNumber(ticker, "bid");
                bestAsk = exchange.safeNumber(ticker, "ask");
            } else if (isTrue(getValue(exchange.has, "fetchTicker")))
            {
                usedMethod = "fetchTicker";
                object ticker = await exchange.fetchTicker(symbol);
                bestBid = exchange.safeNumber(ticker, "bid");
                bestAsk = exchange.safeNumber(ticker, "ask");
            } else if (isTrue(getValue(exchange.has, "fetchTickers")))
            {
                usedMethod = "fetchTickers";
                object tickers = await exchange.fetchTickers(new List<object>() {symbol});
                object ticker = exchange.safeDict(tickers, symbol);
                bestBid = exchange.safeNumber(ticker, "bid");
                bestAsk = exchange.safeNumber(ticker, "ask");
            }
            //
            assert(isTrue(!isEqual(bestBid, null)) && isTrue(!isEqual(bestAsk, null)), add(add(add(add(add(add(add(add(logText, " "), exchange.id), " could not get best bid/ask for "), symbol), " using "), usedMethod), " while testing "), method));
            return new List<object>() {bestBid, bestAsk};
        }
        async public Task<object> fetchOrder(Exchange exchange, object symbol, object orderId, object skippedProperties)
        {
            object fetchedOrder = null;
            object originalId = orderId;
            // set 'since' to 5 minute ago for optimal results
            object sinceTime = subtract(exchange.milliseconds(), multiply(multiply(1000, 60), 5));
            // iterate
            object methods_singular = new List<object>() {"fetchOrder", "fetchOpenOrder", "fetchClosedOrder", "fetchCanceledOrder"};
            for (object i = 0; isLessThan(i, getArrayLength(methods_singular)); postFixIncrement(ref i))
            {
                object singularFetchName = getValue(methods_singular, i);
                if (isTrue(getValue(exchange.has, singularFetchName)))
                {
                    object currentOrder = await ((Task<object>)callDynamically(exchange, singularFetchName, new object[] { originalId, symbol }));
                    // if there is an id inside the order, it means the order was fetched successfully
                    if (isTrue(isEqual(getValue(currentOrder, "id"), originalId)))
                    {
                        fetchedOrder = currentOrder;
                        break;
                    }
                }
            }
            //
            // search through plural methods
            if (isTrue(isEqual(fetchedOrder, null)))
            {
                object methods_plural = new List<object>() {"fetchOrders", "fetchOpenOrders", "fetchClosedOrders", "fetchCanceledOrders"};
                for (object i = 0; isLessThan(i, getArrayLength(methods_plural)); postFixIncrement(ref i))
                {
                    object pluralFetchName = getValue(methods_plural, i);
                    if (isTrue(getValue(exchange.has, pluralFetchName)))
                    {
                        object orders = await ((Task<object>)callDynamically(exchange, pluralFetchName, new object[] { symbol, sinceTime }));
                        object found = false;
                        for (object j = 0; isLessThan(j, getArrayLength(orders)); postFixIncrement(ref j))
                        {
                            object currentOrder = getValue(orders, j);
                            if (isTrue(isEqual(getValue(currentOrder, "id"), originalId)))
                            {
                                fetchedOrder = currentOrder;
                                found = true;
                                break;
                            }
                        }
                        if (isTrue(found))
                        {
                            break;
                        }
                    }
                }
            }
            return fetchedOrder;
        }
        public void assertOrderState(Exchange exchange, object skippedProperties, object method, object order, object assertedStatus, object strictCheck)
        {
            // note, `strictCheck` is `true` only from "fetchOrder" cases
            object logText = logTemplate(exchange, method, order);
            object msg = add(add(add("order should be ", assertedStatus), ", but it was not asserted"), logText);
            object filled = exchange.safeString(order, "filled");
            object amount = exchange.safeString(order, "amount");
            // shorthand variables
            object statusUndefined = (isEqual(getValue(order, "status"), null));
            object statusOpen = (isEqual(getValue(order, "status"), "open"));
            object statusClosed = (isEqual(getValue(order, "status"), "closed"));
            object statusClanceled = (isEqual(getValue(order, "status"), "canceled"));
            object filledDefined = (!isEqual(filled, null));
            object amountDefined = (!isEqual(amount, null));
            object condition = null;
            //
            // ### OPEN STATUS
            //
            // if strict check, then 'status' must be 'open' and filled amount should be less then whole order amount
            object strictOpen = isTrue(statusOpen) && isTrue((isTrue(isTrue(filledDefined) && isTrue(amountDefined)) && isTrue(isLessThan(filled, amount))));
            // if non-strict check, then accept & ignore undefined values
            object nonstrictOpen = isTrue((isTrue(statusOpen) || isTrue(statusUndefined))) && isTrue((isTrue((!isTrue(filledDefined) || !isTrue(amountDefined))) || isTrue(Precise.stringLt(filled, amount))));
            // check
            if (isTrue(isEqual(assertedStatus, "open")))
            {
                condition = ((bool) isTrue(strictCheck)) ? strictOpen : nonstrictOpen;
                assert(condition, msg);
                return;
            }
            //
            // ### CLOSED STATUS
            //
            // if strict check, then 'status' must be 'closed' and filled amount should be equal to the whole order amount
            object closedStrict = isTrue(statusClosed) && isTrue((isTrue(isTrue(filledDefined) && isTrue(amountDefined)) && isTrue(Precise.stringEq(filled, amount))));
            // if non-strict check, then accept & ignore undefined values
            object closedNonStrict = isTrue((isTrue(statusClosed) || isTrue(statusUndefined))) && isTrue((isTrue((!isTrue(filledDefined) || !isTrue(amountDefined))) || isTrue(Precise.stringEq(filled, amount))));
            // check
            if (isTrue(isEqual(assertedStatus, "closed")))
            {
                condition = ((bool) isTrue(strictCheck)) ? closedStrict : closedNonStrict;
                assert(condition, msg);
                return;
            }
            //
            // ### CANCELED STATUS
            //
            // if strict check, then 'status' must be 'canceled' and filled amount should be less then whole order amount
            object canceledStrict = isTrue(statusClanceled) && isTrue((isTrue(isTrue(filledDefined) && isTrue(amountDefined)) && isTrue(Precise.stringLt(filled, amount))));
            // if non-strict check, then accept & ignore undefined values
            object canceledNonStrict = isTrue((isTrue(statusClanceled) || isTrue(statusUndefined))) && isTrue((isTrue((!isTrue(filledDefined) || !isTrue(amountDefined))) || isTrue(Precise.stringLt(filled, amount))));
            // check
            if (isTrue(isEqual(assertedStatus, "canceled")))
            {
                condition = ((bool) isTrue(strictCheck)) ? canceledStrict : canceledNonStrict;
                assert(condition, msg);
                return;
            }
            //
            // ### CLOSED_or_CANCELED STATUS
            //
            if (isTrue(isEqual(assertedStatus, "closed_or_canceled")))
            {
                condition = ((bool) isTrue(strictCheck)) ? (isTrue(closedStrict) || isTrue(canceledStrict)) : (isTrue(closedNonStrict) || isTrue(canceledNonStrict));
                assert(condition, msg);
                return;
            }
        }
        public object getActiveMarkets(Exchange exchange, object includeUnknown = null)
        {
            includeUnknown ??= true;
            object filteredActive = exchange.filterBy(exchange.markets, "active", true);
            if (isTrue(includeUnknown))
            {
                object filteredUndefined = exchange.filterBy(exchange.markets, "active", null);
                return exchange.arrayConcat(filteredActive, filteredUndefined);
            }
            return filteredActive;
        }
        public object removeProxyOptions(Exchange exchange, object skippedProperties)
        {
            object proxyUrl = exchange.checkProxyUrlSettings();
            var httpProxyhttpsProxysocksProxyVariable = exchange.checkProxySettings();
            var httpProxy = ((IList<object>) httpProxyhttpsProxysocksProxyVariable)[0];
            var httpsProxy = ((IList<object>) httpProxyhttpsProxysocksProxyVariable)[1];
            var socksProxy = ((IList<object>) httpProxyhttpsProxysocksProxyVariable)[2];
            // because of bug in transpiled, about `.proxyUrl` being transpiled into `.proxy_url`, we have to use this workaround
            exchange.setProperty(exchange, "proxyUrl", null);
            exchange.setProperty(exchange, "proxy_url", null);
            exchange.setProperty(exchange, "httpProxy", null);
            exchange.setProperty(exchange, "http_proxy", null);
            exchange.setProperty(exchange, "httpsProxy", null);
            exchange.setProperty(exchange, "https_proxy", null);
            exchange.setProperty(exchange, "socksProxy", null);
            exchange.setProperty(exchange, "socks_proxy", null);
            return new List<object>() {proxyUrl, httpProxy, httpsProxy, socksProxy};
        }
        public void setProxyOptions(Exchange exchange, object skippedProperties, object proxyUrl, object httpProxy, object httpsProxy, object socksProxy)
        {
            exchange.proxyUrl = proxyUrl;
            exchange.httpProxy = httpProxy;
            exchange.httpsProxy = httpsProxy;
            exchange.socksProxy = socksProxy;
        }
        public object concat(object a = null, object b = null)
        {
            // we use this method temporarily, because of ast-transpiler issue across langs
            if (isTrue(isEqual(a, null)))
            {
                return b;
            } else if (isTrue(isEqual(b, null)))
            {
                return a;
            } else
            {
                object result = new List<object>() {};
                for (object i = 0; isLessThan(i, getArrayLength(a)); postFixIncrement(ref i))
                {
                    ((IList<object>)result).Add(getValue(a, i));
                }
                for (object j = 0; isLessThan(j, getArrayLength(b)); postFixIncrement(ref j))
                {
                    ((IList<object>)result).Add(getValue(b, j));
                }
                return result;
            }
        }
        public void assertNonEmtpyArray(Exchange exchange, object skippedProperties, object method, object entry, object hint = null)
        {
            object logText = logTemplate(exchange, method, entry);
            if (isTrue(!isEqual(hint, null)))
            {
                logText = add(add(logText, " "), hint);
            }
            assert(((entry is IList<object>) || (entry.GetType().IsGenericType && entry.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))), add("response is expected to be an array", logText));
            if (!isTrue((inOp(skippedProperties, "emptyResponse"))))
            {
                return;
            }
            assert(isGreaterThan(getArrayLength(entry), 0), add(add("response is expected to be a non-empty array", logText), " (add \"emptyResponse\" in skip-tests.json to skip this check)"));
        }
        public void assertRoundMinuteTimestamp(Exchange exchange, object skippedProperties, object method, object entry, object key)
        {
            if (isTrue(inOp(skippedProperties, key)))
            {
                return;
            }
            object logText = logTemplate(exchange, method, entry);
            object ts = exchange.safeString(entry, key);
            assert(isEqual(Precise.stringMod(ts, "60000"), "0"), add("timestamp should be a multiple of 60 seconds (1 minute)", logText));
        }
        public object deepEqual(Exchange exchange, object a, object b)
        {
            return isEqual(json(a), json(b));
        }
        public void assertDeepEqual(Exchange exchange, object skippedProperties, object method, object a, object b)
        {
            object logText = logTemplate(exchange, method, new Dictionary<string, object>() {});
            assert(deepEqual(exchange, a, b), add(add(add(add("two dicts do not match: ", json(a)), " != "), json(b)), logText));
        }

    }
}