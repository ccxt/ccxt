using ccxt;
namespace Tests;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class testMainClass : BaseTest
{
    public partial class SharedMethods
    {
        public object logTemplate(Exchange exchange, object method, object entry)
        {
            // there are cases when exchange is undefined (eg. base tests)
            object id = ((bool) isTrue((!isEqual(exchange, null)))) ? exchange.id : "undefined";
            object methodString = ((bool) isTrue((!isEqual(method, null)))) ? method : "undefined";
            object entryString = ((bool) isTrue((!isEqual(exchange, null)))) ? exchange.json(entry) : "";
            return add(add(add(add(add(add(" <<< ", id), " "), methodString), " ::: "), entryString), " >>> ");
        }
        public object isTemporaryFailure(object e)
        {
            return isTrue((e is OperationFailed)) && isTrue((!isTrue((e is OnMaintenance))));
        }
        public object stringValue(object value)
        {
            object stringVal = null;
            if (isTrue((value is string)))
            {
                stringVal = value;
            } else if (isTrue(isEqual(value, null)))
            {
                stringVal = "undefined";
            } else
            {
                stringVal = ((object)value).ToString();
            }
            return stringVal;
        }
        public object assertType(Exchange exchange, object skippedProperties, object entry, object key, object format)
        {
            if (isTrue(inOp(skippedProperties, key)))
            {
                return null;
            }
            // because "typeof" string is not transpilable without === 'name', we list them manually at this moment
            object entryKeyVal = exchange.safeValue(entry, key);
            object formatKeyVal = exchange.safeValue(format, key);
            object same_string = isTrue(((entryKeyVal is string))) && isTrue(((formatKeyVal is string)));
            object same_numeric = isTrue(((entryKeyVal is Int64 || entryKeyVal is int || entryKeyVal is float || entryKeyVal is double))) && isTrue(((formatKeyVal is Int64 || formatKeyVal is int || formatKeyVal is float || formatKeyVal is double)));
            object same_boolean = isTrue((isTrue((isEqual(entryKeyVal, true))) || isTrue((isEqual(entryKeyVal, false))))) && isTrue((isTrue((isEqual(formatKeyVal, true))) || isTrue((isEqual(formatKeyVal, false)))));
            object same_array = isTrue(((entryKeyVal is IList<object>) || (entryKeyVal.GetType().IsGenericType && entryKeyVal.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))) && isTrue(((formatKeyVal is IList<object>) || (formatKeyVal.GetType().IsGenericType && formatKeyVal.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))));
            object same_object = isTrue(((entryKeyVal is IDictionary<string, object>))) && isTrue(((formatKeyVal is IDictionary<string, object>)));
            object result = isTrue(isTrue(isTrue(isTrue(isTrue((isEqual(entryKeyVal, null))) || isTrue(same_string)) || isTrue(same_numeric)) || isTrue(same_boolean)) || isTrue(same_array)) || isTrue(same_object);
            return result;
        }
        public void assertStructure(Exchange exchange, object skippedProperties, object method, object entry, object format, object emptyAllowedFor = null)
        {
            emptyAllowedFor ??= new List<object>();
            object logText = logTemplate(exchange, method, entry);
            assert(entry, add("item is null/undefined", logText));
            // get all expected & predefined keys for this specific item and ensure thos ekeys exist in parsed structure
            if (isTrue(((format is IList<object>) || (format.GetType().IsGenericType && format.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>))))))
            {
                assert(((entry is IList<object>) || (entry.GetType().IsGenericType && entry.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))), add("entry is not an array", logText));
                object realLength = getArrayLength(entry);
                object expectedLength = getArrayLength(format);
                assert(isEqual(realLength, expectedLength), add(add("entry length is not equal to expected length of ", ((object)expectedLength).ToString()), logText));
                for (object i = 0; isLessThan(i, getArrayLength(format)); postFixIncrement(ref i))
                {
                    object emptyAllowedForThisKey = exchange.inArray(i, emptyAllowedFor);
                    object value = getValue(entry, i);
                    if (isTrue(inOp(skippedProperties, i)))
                    {
                        continue;
                    }
                    // check when:
                    // - it's not inside "allowe empty values" list
                    // - it's not undefined
                    if (isTrue(isTrue(emptyAllowedForThisKey) && isTrue((isEqual(value, null)))))
                    {
                        continue;
                    }
                    assert(!isEqual(value, null), add(add(((object)i).ToString(), " index is expected to have a value"), logText));
                    // because of other langs, this is needed for arrays
                    object typeAssertion = assertType(exchange, skippedProperties, entry, i, format);
                    assert(typeAssertion, add(add(((object)i).ToString(), " index does not have an expected type "), logText));
                }
            } else
            {
                assert((entry is IDictionary<string, object>), add("entry is not an object", logText));
                object keys = new List<object>(((IDictionary<string,object>)format).Keys);
                for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
                {
                    object key = getValue(keys, i);
                    if (isTrue(inOp(skippedProperties, key)))
                    {
                        continue;
                    }
                    assert(inOp(entry, key), add(add(add("\"", stringValue(key)), "\" key is missing from structure"), logText));
                    if (isTrue(inOp(skippedProperties, key)))
                    {
                        continue;
                    }
                    object emptyAllowedForThisKey = exchange.inArray(key, emptyAllowedFor);
                    object value = getValue(entry, key);
                    // check when:
                    // - it's not inside "allowe empty values" list
                    // - it's not undefined
                    if (isTrue(isTrue(emptyAllowedForThisKey) && isTrue((isEqual(value, null)))))
                    {
                        continue;
                    }
                    // if it was in needed keys, then it should have value.
                    assert(!isEqual(value, null), add(add(add("\"", stringValue(key)), "\" key is expected to have a value"), logText));
                    // add exclusion for info key, as it can be any type
                    if (isTrue(!isEqual(key, "info")))
                    {
                        object typeAssertion = assertType(exchange, skippedProperties, entry, key, format);
                        assert(typeAssertion, add(add(add("\"", stringValue(key)), "\" key is neither undefined, neither of expected type"), logText));
                    }
                }
            }
        }
        public void assertTimestamp(Exchange exchange, object skippedProperties, object method, object entry, object nowToCheck = null, object keyNameOrIndex = null)
        {
            keyNameOrIndex ??= "timestamp";
            object logText = logTemplate(exchange, method, entry);
            object skipValue = exchange.safeValue(skippedProperties, keyNameOrIndex);
            if (isTrue(!isEqual(skipValue, null)))
            {
                return;  // skipped
            }
            object isDateTimeObject = (keyNameOrIndex is string);
            if (isTrue(isDateTimeObject))
            {
                assert((inOp(entry, keyNameOrIndex)), add(add(add("timestamp key \"", keyNameOrIndex), "\" is missing from structure"), logText));
            } else
            {
                // if index was provided (mostly from fetchOHLCV) then we check if it exists, as mandatory
                assert(!isTrue((isEqual(getValue(entry, keyNameOrIndex), null))), add(add(add("timestamp index ", stringValue(keyNameOrIndex)), " is undefined"), logText));
            }
            object ts = getValue(entry, keyNameOrIndex);
            if (isTrue(!isEqual(ts, null)))
            {
                assert((ts is Int64 || ts is int || ts is float || ts is double), add("timestamp is not numeric", logText));
                assert(((ts is int) || (ts is long) || (ts is Int32) || (ts is Int64)), add("timestamp should be an integer", logText));
                object minTs = 1230940800000; // 03 Jan 2009 - first block
                object maxTs = 2147483648000; // 19 Jan 2038 - max int
                assert(isGreaterThan(ts, minTs), add(add(add("timestamp is impossible to be before ", ((object)minTs).ToString()), " (03.01.2009)"), logText)); // 03 Jan 2009 - first block
                assert(isLessThan(ts, maxTs), add(add(add("timestamp more than ", ((object)maxTs).ToString()), " (19.01.2038)"), logText)); // 19 Jan 2038 - int32 overflows // 7258118400000  -> Jan 1 2200
                if (isTrue(!isEqual(nowToCheck, null)))
                {
                    object maxMsOffset = 60000; // 1 min
                    assert(isLessThan(ts, add(nowToCheck, maxMsOffset)), add(add(add(add(add("returned item timestamp (", exchange.iso8601(ts)), ") is ahead of the current time ("), exchange.iso8601(nowToCheck)), ")"), logText));
                }
            }
        }
        public void assertTimestampAndDatetime(Exchange exchange, object skippedProperties, object method, object entry, object nowToCheck = null, object keyNameOrIndex = null)
        {
            keyNameOrIndex ??= "timestamp";
            object logText = logTemplate(exchange, method, entry);
            object skipValue = exchange.safeValue(skippedProperties, keyNameOrIndex);
            if (isTrue(!isEqual(skipValue, null)))
            {
                return;
            }
            assertTimestamp(exchange, skippedProperties, method, entry, nowToCheck, keyNameOrIndex);
            object isDateTimeObject = (keyNameOrIndex is string);
            // only in case if the entry is a dictionary, thus it must have 'timestamp' & 'datetime' string keys
            if (isTrue(isDateTimeObject))
            {
                // we also test 'datetime' here because it's certain sibling of 'timestamp'
                assert((inOp(entry, "datetime")), add("\"datetime\" key is missing from structure", logText));
                object dt = getValue(entry, "datetime");
                if (isTrue(!isEqual(dt, null)))
                {
                    assert((dt is string), add("\"datetime\" key does not have a string value", logText));
                    // there are exceptional cases, like getting microsecond-targeted string '2022-08-08T22:03:19.014680Z', so parsed unified timestamp, which carries only 13 digits (millisecond precision) can not be stringified back to microsecond accuracy, causing the bellow assertion to fail
                    //    assert (dt === exchange.iso8601 (entry['timestamp']))
                    // so, we have to compare with millisecond accururacy
                    object dtParsed = exchange.parse8601(dt);
                    assert(isEqual(exchange.iso8601(dtParsed), exchange.iso8601(getValue(entry, "timestamp"))), add("datetime is not iso8601 of timestamp", logText));
                }
            }
        }
        public void assertCurrencyCode(Exchange exchange, object skippedProperties, object method, object entry, object actualCode, object expectedCode = null)
        {
            if (isTrue(isTrue((inOp(skippedProperties, "currency"))) || isTrue((inOp(skippedProperties, "currencyIdAndCode")))))
            {
                return;
            }
            object logText = logTemplate(exchange, method, entry);
            if (isTrue(!isEqual(actualCode, null)))
            {
                assert((actualCode is string), add("currency code should be either undefined or a string", logText));
                assert((inOp(exchange.currencies, actualCode)), add(add(add("currency code (\"", actualCode), "\") should be present in exchange.currencies"), logText));
                if (isTrue(!isEqual(expectedCode, null)))
                {
                    assert(isEqual(actualCode, expectedCode), add(add(add(add(add("currency code in response (\"", stringValue(actualCode)), "\") should be equal to expected code (\""), stringValue(expectedCode)), "\")"), logText));
                }
            }
        }
        public void assertValidCurrencyIdAndCode(Exchange exchange, object skippedProperties, object method, object entry, object currencyId, object currencyCode)
        {
            // this is exclusive exceptional key name to be used in `skip-tests.json`, to skip check for currency id and code
            if (isTrue(isTrue((inOp(skippedProperties, "currency"))) || isTrue((inOp(skippedProperties, "currencyIdAndCode")))))
            {
                return;
            }
            object logText = logTemplate(exchange, method, entry);
            object undefinedValues = isTrue(isEqual(currencyId, null)) && isTrue(isEqual(currencyCode, null));
            object definedValues = isTrue(!isEqual(currencyId, null)) && isTrue(!isEqual(currencyCode, null));
            assert(isTrue(undefinedValues) || isTrue(definedValues), add("currencyId and currencyCode should be either both defined or both undefined", logText));
            if (isTrue(definedValues))
            {
                // check by code
                object currencyByCode = exchange.currency(currencyCode);
                assert(isEqual(getValue(currencyByCode, "id"), currencyId), add(add(add(add(add("currencyId \"", stringValue(currencyId)), "\" does not match currency of code: \""), stringValue(currencyCode)), "\""), logText));
                // check by id
                object currencyById = exchange.safeCurrency(currencyId);
                assert(isEqual(getValue(currencyById, "code"), currencyCode), add(add(add(add("currencyCode ", stringValue(currencyCode)), " does not match currency of id: "), stringValue(currencyId)), logText));
            }
        }
        public void assertSymbol(Exchange exchange, object skippedProperties, object method, object entry, object key, object expectedSymbol = null)
        {
            if (isTrue(inOp(skippedProperties, key)))
            {
                return;
            }
            object logText = logTemplate(exchange, method, entry);
            object actualSymbol = exchange.safeString(entry, key);
            if (isTrue(!isEqual(actualSymbol, null)))
            {
                assert((actualSymbol is string), add("symbol should be either undefined or a string", logText));
            }
            if (isTrue(!isEqual(expectedSymbol, null)))
            {
                assert(isEqual(actualSymbol, expectedSymbol), add(add(add(add(add("symbol in response (\"", stringValue(actualSymbol)), "\") should be equal to expected symbol (\""), stringValue(expectedSymbol)), "\")"), logText));
            }
        }
        public void assertSymbolInMarkets(Exchange exchange, object skippedProperties, object method, object symbol)
        {
            object logText = logTemplate(exchange, method, new Dictionary<string, object>() {});
            assert((inOp(exchange.markets, symbol)), add("symbol should be present in exchange.symbols", logText));
        }
        public void assertGreater(Exchange exchange, object skippedProperties, object method, object entry, object key, object compareTo)
        {
            if (isTrue(inOp(skippedProperties, key)))
            {
                return;
            }
            object logText = logTemplate(exchange, method, entry);
            object value = exchange.safeString(entry, key);
            if (isTrue(!isEqual(value, null)))
            {
                assert(Precise.stringGt(value, compareTo), add(add(add(add(add(stringValue(key), " key (with a value of "), stringValue(value)), ") was expected to be > "), stringValue(compareTo)), logText));
            }
        }
        public void assertGreaterOrEqual(Exchange exchange, object skippedProperties, object method, object entry, object key, object compareTo)
        {
            if (isTrue(inOp(skippedProperties, key)))
            {
                return;
            }
            object logText = logTemplate(exchange, method, entry);
            object value = exchange.safeString(entry, key);
            if (isTrue(isTrue(!isEqual(value, null)) && isTrue(!isEqual(compareTo, null))))
            {
                assert(Precise.stringGe(value, compareTo), add(add(add(add(add(stringValue(key), " key (with a value of "), stringValue(value)), ") was expected to be >= "), stringValue(compareTo)), logText));
            }
        }
        public void assertLess(Exchange exchange, object skippedProperties, object method, object entry, object key, object compareTo)
        {
            if (isTrue(inOp(skippedProperties, key)))
            {
                return;
            }
            object logText = logTemplate(exchange, method, entry);
            object value = exchange.safeString(entry, key);
            if (isTrue(isTrue(!isEqual(value, null)) && isTrue(!isEqual(compareTo, null))))
            {
                assert(Precise.stringLt(value, compareTo), add(add(add(add(add(stringValue(key), " key (with a value of "), stringValue(value)), ") was expected to be < "), stringValue(compareTo)), logText));
            }
        }
        public void assertLessOrEqual(Exchange exchange, object skippedProperties, object method, object entry, object key, object compareTo)
        {
            if (isTrue(inOp(skippedProperties, key)))
            {
                return;
            }
            object logText = logTemplate(exchange, method, entry);
            object value = exchange.safeString(entry, key);
            if (isTrue(isTrue(!isEqual(value, null)) && isTrue(!isEqual(compareTo, null))))
            {
                assert(Precise.stringLe(value, compareTo), add(add(add(add(add(stringValue(key), " key (with a value of "), stringValue(value)), ") was expected to be <= "), stringValue(compareTo)), logText));
            }
        }
        public void assertEqual(Exchange exchange, object skippedProperties, object method, object entry, object key, object compareTo)
        {
            if (isTrue(inOp(skippedProperties, key)))
            {
                return;
            }
            object logText = logTemplate(exchange, method, entry);
            object value = exchange.safeString(entry, key);
            if (isTrue(isTrue(!isEqual(value, null)) && isTrue(!isEqual(compareTo, null))))
            {
                assert(Precise.stringEq(value, compareTo), add(add(add(add(add(stringValue(key), " key (with a value of "), stringValue(value)), ") was expected to be equal to "), stringValue(compareTo)), logText));
            }
        }
        public void assertNonEqual(Exchange exchange, object skippedProperties, object method, object entry, object key, object compareTo)
        {
            if (isTrue(inOp(skippedProperties, key)))
            {
                return;
            }
            object logText = logTemplate(exchange, method, entry);
            object value = exchange.safeString(entry, key);
            if (isTrue(!isEqual(value, null)))
            {
                assert(!isTrue(Precise.stringEq(value, compareTo)), add(add(add(add(add(stringValue(key), " key (with a value of "), stringValue(value)), ") was expected not to be equal to "), stringValue(compareTo)), logText));
            }
        }
        public void assertInArray(Exchange exchange, object skippedProperties, object method, object entry, object key, object expectedArray)
        {
            if (isTrue(inOp(skippedProperties, key)))
            {
                return;
            }
            object logText = logTemplate(exchange, method, entry);
            object value = exchange.safeValue(entry, key);
            // todo: remove undefined check
            if (isTrue(!isEqual(value, null)))
            {
                object stingifiedArrayValue = exchange.json(expectedArray); // don't use expectedArray.join (','), as it bugs in other languages, if values are bool, undefined or etc..
                assert(exchange.inArray(value, expectedArray), add(add(add(add(add(add(add("\"", stringValue(key)), "\" key (value \""), stringValue(value)), "\") is not from the expected list : ["), stingifiedArrayValue), "]"), logText));
            }
        }
        public void assertFeeStructure(Exchange exchange, object skippedProperties, object method, object entry, object key)
        {
            object logText = logTemplate(exchange, method, entry);
            object keyString = stringValue(key);
            if (isTrue(((key is int) || (key is long) || (key is Int32) || (key is Int64))))
            {
                key = key;
                assert(((entry is IList<object>) || (entry.GetType().IsGenericType && entry.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))), add("fee container is expected to be an array", logText));
                assert(isLessThan(key, getArrayLength(entry)), add(add(add("fee key ", keyString), " was expected to be present in entry"), logText));
            } else
            {
                assert((entry is IDictionary<string, object>), add("fee container is expected to be an object", logText));
                assert(inOp(entry, key), add(add(add("fee key \"", key), "\" was expected to be present in entry"), logText));
            }
            object feeObject = exchange.safeValue(entry, key);
            // todo: remove undefined check to make stricter
            if (isTrue(!isEqual(feeObject, null)))
            {
                assert(inOp(feeObject, "cost"), add(add(keyString, " fee object should contain \"cost\" key"), logText));
                if (isTrue(isEqual(getValue(feeObject, "cost"), null)))
                {
                    return;  // todo: remove undefined check to make stricter
                }
                assert((getValue(feeObject, "cost") is Int64 || getValue(feeObject, "cost") is int || getValue(feeObject, "cost") is float || getValue(feeObject, "cost") is double), add(add(keyString, " \"cost\" must be numeric type"), logText));
                // assertGreaterOrEqual (exchange, skippedProperties, method, feeObject, 'cost', '0'); // fee might be negative in the case of a rebate or reward
                assert(inOp(feeObject, "currency"), add(add(add("\"", keyString), "\" fee object should contain \"currency\" key"), logText));
                assertCurrencyCode(exchange, skippedProperties, method, entry, getValue(feeObject, "currency"));
            }
        }
        public void assertTimestampOrder(Exchange exchange, object method, object codeOrSymbol, object items, object ascending = null)
        {
            ascending ??= true;
            for (object i = 0; isLessThan(i, getArrayLength(items)); postFixIncrement(ref i))
            {
                if (isTrue(isGreaterThan(i, 0)))
                {
                    object currentTs = getValue(getValue(items, subtract(i, 1)), "timestamp");
                    object nextTs = getValue(getValue(items, i), "timestamp");
                    if (isTrue(isTrue(!isEqual(currentTs, null)) && isTrue(!isEqual(nextTs, null))))
                    {
                        object ascendingOrDescending = ((bool) isTrue(ascending)) ? "ascending" : "descending";
                        object comparison = ((bool) isTrue(ascending)) ? (isLessThanOrEqual(currentTs, nextTs)) : (isGreaterThanOrEqual(currentTs, nextTs));
                        assert(comparison, add(add(add(add(add(add(add(add(add(add(add(add(exchange.id, " "), method), " "), stringValue(codeOrSymbol)), " must return a "), ascendingOrDescending), " sorted array of items by timestamp, but "), ((object)currentTs).ToString()), " is opposite with its next "), ((object)nextTs).ToString()), " "), exchange.json(items)));
                    }
                }
            }
        }
        public void assertInteger(Exchange exchange, object skippedProperties, object method, object entry, object key)
        {
            if (isTrue(inOp(skippedProperties, key)))
            {
                return;
            }
            object logText = logTemplate(exchange, method, entry);
            if (isTrue(!isEqual(entry, null)))
            {
                object value = exchange.safeValue(entry, key);
                if (isTrue(!isEqual(value, null)))
                {
                    object isInteger = ((value is int) || (value is long) || (value is Int32) || (value is Int64));
                    assert(isInteger, add(add(add(add(add("\"", stringValue(key)), "\" key (value \""), stringValue(value)), "\") is not an integer"), logText));
                }
            }
        }
        public void checkPrecisionAccuracy(Exchange exchange, object skippedProperties, object method, object entry, object key)
        {
            if (isTrue(inOp(skippedProperties, key)))
            {
                return;
            }
            if (isTrue(exchange.isTickPrecision()))
            {
                // TICK_SIZE should be above zero
                assertGreater(exchange, skippedProperties, method, entry, key, "0");
                // the below array of integers are inexistent tick-sizes (theoretically technically possible, but not in real-world cases), so their existence in our case indicates to incorrectly implemented tick-sizes, which might mistakenly be implemented with DECIMAL_PLACES, so we throw error
                object decimalNumbers = new List<object>() {"2", "3", "4", "6", "7", "8", "9", "11", "12", "13", "14", "15", "16"};
                for (object i = 0; isLessThan(i, getArrayLength(decimalNumbers)); postFixIncrement(ref i))
                {
                    object num = getValue(decimalNumbers, i);
                    object numStr = num;
                    assertNonEqual(exchange, skippedProperties, method, entry, key, numStr);
                }
            } else
            {
                // todo: significant-digits return doubles from `this.parseNumber`, so for now can't assert against integer atm
                // assertInteger (exchange, skippedProperties, method, entry, key); // should be integer
                assertLessOrEqual(exchange, skippedProperties, method, entry, key, "18"); // should be under 18 decimals
                assertGreaterOrEqual(exchange, skippedProperties, method, entry, key, "-8"); // in real-world cases, there would not be less than that
            }
        }
        public object removeProxyOptions(Exchange exchange, object skippedProperties)
        {
            object proxyUrl = exchange.checkProxyUrlSettings();
            var httpProxyhttpsProxysocksProxyVariable = exchange.checkProxySettings();
            var httpProxy = ((IList<object>) httpProxyhttpsProxysocksProxyVariable)[0];
            var httpsProxy = ((IList<object>) httpProxyhttpsProxysocksProxyVariable)[1];
            var socksProxy = ((IList<object>) httpProxyhttpsProxysocksProxyVariable)[2];
            // because of bug in transpiled, about `.proxyUrl` being transpiled into `.proxy_url`, we have to use this workaround
            exchange.setProperty(exchange, "proxyUrl", null);
            exchange.setProperty(exchange, "proxy_url", null);
            exchange.setProperty(exchange, "httpProxy", null);
            exchange.setProperty(exchange, "http_proxy", null);
            exchange.setProperty(exchange, "httpsProxy", null);
            exchange.setProperty(exchange, "https_proxy", null);
            exchange.setProperty(exchange, "socksProxy", null);
            exchange.setProperty(exchange, "socks_proxy", null);
            return new List<object>() {proxyUrl, httpProxy, httpsProxy, socksProxy};
        }
        public void setProxyOptions(Exchange exchange, object skippedProperties, object proxyUrl, object httpProxy, object httpsProxy, object socksProxy)
        {
            exchange.proxyUrl = proxyUrl;
            exchange.httpProxy = httpProxy;
            exchange.httpsProxy = httpsProxy;
            exchange.socksProxy = socksProxy;
        }
        public void assertNonEmtpyArray(Exchange exchange, object skippedProperties, object method, object entry, object hint = null)
        {
            object logText = logTemplate(exchange, method, entry);
            if (isTrue(!isEqual(hint, null)))
            {
                logText = add(add(logText, " "), hint);
            }
            assert(((entry is IList<object>) || (entry.GetType().IsGenericType && entry.GetType().GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))), add("response is expected to be an array", logText));
            if (!isTrue((inOp(skippedProperties, "emptyResponse"))))
            {
                return;
            }
            assert(isGreaterThan(getArrayLength(entry), 0), add(add("response is expected to be a non-empty array", logText), " (add \"emptyResponse\" in skip-tests.json to skip this check)"));
        }
        public void assertRoundMinuteTimestamp(Exchange exchange, object skippedProperties, object method, object entry, object key)
        {
            if (isTrue(inOp(skippedProperties, key)))
            {
                return;
            }
            object logText = logTemplate(exchange, method, entry);
            object ts = exchange.safeString(entry, key);
            assert(isEqual(Precise.stringMod(ts, "60000"), "0"), add("timestamp should be a multiple of 60 seconds (1 minute)", logText));
        }
        public object deepEqual(object a, object b)
        {
            return isEqual(json(a), json(b));
        }
        public void assertDeepEqual(Exchange exchange, object skippedProperties, object method, object a, object b)
        {
            object logText = logTemplate(exchange, method, new Dictionary<string, object>() {});
            assert(deepEqual(a, b), add(add(add(add("two dicts do not match: ", json(a)), " != "), json(b)), logText));
        }

    }
}