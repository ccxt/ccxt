using ccxt;
namespace Tests;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class testMainClass : BaseTest
{
    public static void testCurrency(Exchange exchange, object skippedProperties, object method, object entry)
    {
        object format = new Dictionary<string, object>() {
            { "id", "btc" },
            { "code", "BTC" },
        };
        // todo: remove fee from empty
        object emptyAllowedFor = new List<object>() {"name", "fee"};
        // todo: info key needs to be added in base, when exchange does not have fetchCurrencies
        object isNative = isTrue(getValue(exchange.has, "fetchCurrencies")) && isTrue(!isEqual(getValue(exchange.has, "fetchCurrencies"), "emulated"));
        object currencyType = exchange.safeString(entry, "type");
        if (isTrue(isNative))
        {
            ((IDictionary<string,object>)format)["info"] = new Dictionary<string, object>() {};
            // todo: 'name': 'Bitcoin', // uppercase string, base currency, 2 or more letters
            // these two fields are being dynamically added a bit below
            // format['withdraw'] = true; // withdraw enabled
            // format['deposit'] = true; // deposit enabled
            ((IDictionary<string,object>)format)["precision"] = exchange.parseNumber("0.0001"); // in case of SIGNIFICANT_DIGITS it will be 4 - number of digits "after the dot"
            ((IDictionary<string,object>)format)["fee"] = exchange.parseNumber("0.001");
            ((IDictionary<string,object>)format)["networks"] = new Dictionary<string, object>() {};
            ((IDictionary<string,object>)format)["limits"] = new Dictionary<string, object>() {
                { "withdraw", new Dictionary<string, object>() {
                    { "min", exchange.parseNumber("0.01") },
                    { "max", exchange.parseNumber("1000") },
                } },
                { "deposit", new Dictionary<string, object>() {
                    { "min", exchange.parseNumber("0.01") },
                    { "max", exchange.parseNumber("1000") },
                } },
            };
            // todo: format['type'] = 'fiat|crypto'; // after all exchanges have `type` defined, romove "if" check
            if (isTrue(!isEqual(currencyType, null)))
            {
                testSharedMethods.assertInArray(exchange, skippedProperties, method, entry, "type", new List<object>() {"fiat", "crypto", "other"});
            }
            // only require "deposit" & "withdraw" values, when currency is not fiat, or when it's fiat, but not skipped
            if (isTrue(isTrue(isEqual(currencyType, "crypto")) || !isTrue((inOp(skippedProperties, "depositForNonCrypto")))))
            {
                ((IDictionary<string,object>)format)["deposit"] = true;
            }
            if (isTrue(isTrue(isEqual(currencyType, "crypto")) || !isTrue((inOp(skippedProperties, "withdrawForNonCrypto")))))
            {
                ((IDictionary<string,object>)format)["withdraw"] = true;
            }
        }
        testSharedMethods.assertStructure(exchange, skippedProperties, method, entry, format, emptyAllowedFor);
        testSharedMethods.assertCurrencyCode(exchange, skippedProperties, method, entry, getValue(entry, "code"));
        //
        testSharedMethods.checkPrecisionAccuracy(exchange, skippedProperties, method, entry, "precision");
        testSharedMethods.assertGreaterOrEqual(exchange, skippedProperties, method, entry, "fee", "0");
        if (!isTrue((inOp(skippedProperties, "limits"))))
        {
            object limits = exchange.safeValue(entry, "limits", new Dictionary<string, object>() {});
            object withdrawLimits = exchange.safeValue(limits, "withdraw", new Dictionary<string, object>() {});
            object depositLimits = exchange.safeValue(limits, "deposit", new Dictionary<string, object>() {});
            testSharedMethods.assertGreaterOrEqual(exchange, skippedProperties, method, withdrawLimits, "min", "0");
            testSharedMethods.assertGreaterOrEqual(exchange, skippedProperties, method, withdrawLimits, "max", "0");
            testSharedMethods.assertGreaterOrEqual(exchange, skippedProperties, method, depositLimits, "min", "0");
            testSharedMethods.assertGreaterOrEqual(exchange, skippedProperties, method, depositLimits, "max", "0");
            // max should be more than min (withdrawal limits)
            object minStringWithdrawal = exchange.safeString(withdrawLimits, "min");
            if (isTrue(!isEqual(minStringWithdrawal, null)))
            {
                testSharedMethods.assertGreaterOrEqual(exchange, skippedProperties, method, withdrawLimits, "max", minStringWithdrawal);
            }
            // max should be more than min (deposit limits)
            object minStringDeposit = exchange.safeString(depositLimits, "min");
            if (isTrue(!isEqual(minStringDeposit, null)))
            {
                testSharedMethods.assertGreaterOrEqual(exchange, skippedProperties, method, depositLimits, "max", minStringDeposit);
            }
            // check valid ID & CODE
            testSharedMethods.assertValidCurrencyIdAndCode(exchange, skippedProperties, method, entry, getValue(entry, "id"), getValue(entry, "code"));
        }
    }

}