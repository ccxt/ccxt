using ccxt;
namespace Tests;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code


public partial class testMainClass : BaseTest
{
    public static void testTicker(Exchange exchange, object skippedProperties, object method, object entry, object symbol)
    {
        object format = new Dictionary<string, object>() {
            { "info", new Dictionary<string, object>() {} },
            { "symbol", "ETH/BTC" },
            { "timestamp", 1502962946216 },
            { "datetime", "2017-09-01T00:00:00" },
            { "high", exchange.parseNumber("1.234") },
            { "low", exchange.parseNumber("1.234") },
            { "bid", exchange.parseNumber("1.234") },
            { "bidVolume", exchange.parseNumber("1.234") },
            { "ask", exchange.parseNumber("1.234") },
            { "askVolume", exchange.parseNumber("1.234") },
            { "vwap", exchange.parseNumber("1.234") },
            { "open", exchange.parseNumber("1.234") },
            { "close", exchange.parseNumber("1.234") },
            { "last", exchange.parseNumber("1.234") },
            { "previousClose", exchange.parseNumber("1.234") },
            { "change", exchange.parseNumber("1.234") },
            { "percentage", exchange.parseNumber("1.234") },
            { "average", exchange.parseNumber("1.234") },
            { "baseVolume", exchange.parseNumber("1.234") },
            { "quoteVolume", exchange.parseNumber("1.234") },
        };
        // todo: atm, many exchanges fail, so temporarily decrease stict mode
        object emptyAllowedFor = new List<object>() {"timestamp", "datetime", "open", "high", "low", "close", "last", "baseVolume", "quoteVolume", "previousClose", "bidVolume", "askVolume", "vwap", "change", "percentage", "average"};
        // trick csharp-transpiler for string
        if (!isTrue((((object)method).ToString().Contains("BidsAsks"))))
        {
            ((IList<object>)emptyAllowedFor).Add("bid");
            ((IList<object>)emptyAllowedFor).Add("ask");
        }
        testSharedMethods.assertStructure(exchange, skippedProperties, method, entry, format, emptyAllowedFor);
        testSharedMethods.assertTimestampAndDatetime(exchange, skippedProperties, method, entry);
        object logText = testSharedMethods.logTemplate(exchange, method, entry);
        // check market
        object market = null;
        object symbolForMarket = ((bool) isTrue((!isEqual(symbol, null)))) ? symbol : exchange.safeString(entry, "symbol");
        if (isTrue(isTrue(!isEqual(symbolForMarket, null)) && isTrue((inOp(exchange.markets, symbolForMarket)))))
        {
            market = exchange.market(symbolForMarket);
        }
        // temp todo: skip inactive markets for now, as they sometimes have weird values and causing issues:
        if (!isTrue((inOp(skippedProperties, "checkInactiveMarkets"))))
        {
            if (isTrue(isTrue(!isEqual(market, null)) && isTrue(isEqual(getValue(market, "active"), false))))
            {
                return;
            }
        }
        // only check "above zero" values if exchange is not supposed to have exotic index markets
        object isStandardMarket = (isTrue(!isEqual(market, null)) && isTrue(exchange.inArray(getValue(market, "type"), new List<object>() {"spot", "swap", "future", "option"})));
        object valuesShouldBePositive = isStandardMarket; // || (market === undefined) atm, no check for index markets
        if (isTrue(isTrue(valuesShouldBePositive) && !isTrue((inOp(skippedProperties, "positiveValues")))))
        {
            testSharedMethods.assertGreater(exchange, skippedProperties, method, entry, "open", "0");
            testSharedMethods.assertGreater(exchange, skippedProperties, method, entry, "high", "0");
            testSharedMethods.assertGreater(exchange, skippedProperties, method, entry, "low", "0");
            testSharedMethods.assertGreater(exchange, skippedProperties, method, entry, "close", "0");
            testSharedMethods.assertGreater(exchange, skippedProperties, method, entry, "ask", "0");
            testSharedMethods.assertGreater(exchange, skippedProperties, method, entry, "bid", "0");
            testSharedMethods.assertGreater(exchange, skippedProperties, method, entry, "average", "0");
            testSharedMethods.assertGreaterOrEqual(exchange, skippedProperties, method, entry, "vwap", "0");
        }
        // volume can not be negative
        testSharedMethods.assertGreaterOrEqual(exchange, skippedProperties, method, entry, "askVolume", "0");
        testSharedMethods.assertGreaterOrEqual(exchange, skippedProperties, method, entry, "bidVolume", "0");
        testSharedMethods.assertGreaterOrEqual(exchange, skippedProperties, method, entry, "baseVolume", "0");
        testSharedMethods.assertGreaterOrEqual(exchange, skippedProperties, method, entry, "quoteVolume", "0");
        //
        // close price
        //
        object lastString = exchange.safeString(entry, "last");
        object closeString = exchange.safeString(entry, "close");
        assert(isTrue((isTrue((isEqual(closeString, null))) && isTrue((isEqual(lastString, null))))) || isTrue(Precise.stringEq(lastString, closeString)), add("`last` != `close`", logText));
        object openPrice = exchange.safeString(entry, "open");
        //
        // base & quote volumes
        //
        object baseVolume = exchange.omitZero(exchange.safeString(entry, "baseVolume"));
        object quoteVolume = exchange.omitZero(exchange.safeString(entry, "quoteVolume"));
        object high = exchange.omitZero(exchange.safeString(entry, "high"));
        object low = exchange.omitZero(exchange.safeString(entry, "low"));
        object open = exchange.omitZero(exchange.safeString(entry, "open"));
        object close = exchange.omitZero(exchange.safeString(entry, "close"));
        if (!isTrue((inOp(skippedProperties, "compareQuoteVolumeBaseVolume"))))
        {
            // assert (baseVolumeDefined === quoteVolumeDefined, 'baseVolume or quoteVolume should be either both defined or both undefined' + logText); // No, exchanges might not report both values
            if (isTrue(isTrue(isTrue(isTrue((!isEqual(baseVolume, null))) && isTrue((!isEqual(quoteVolume, null)))) && isTrue((!isEqual(high, null)))) && isTrue((!isEqual(low, null)))))
            {
                object baseLow = Precise.stringMul(baseVolume, low);
                object baseHigh = Precise.stringMul(baseVolume, high);
                // to avoid abnormal long precision issues (like https://discord.com/channels/690203284119617602/1338828283902689280/1338846071278927912 )
                object mPrecision = exchange.safeDict(market, "precision");
                object amountPrecision = exchange.safeString(mPrecision, "amount");
                object tolerance = "1.0001";
                if (isTrue(!isEqual(amountPrecision, null)))
                {
                    baseLow = Precise.stringMul(Precise.stringSub(baseVolume, amountPrecision), low);
                    baseHigh = Precise.stringMul(Precise.stringAdd(baseVolume, amountPrecision), high);
                } else
                {
                    // if nothing found, as an exclusion, just add 0.001%
                    baseLow = Precise.stringMul(Precise.stringDiv(baseVolume, tolerance), low);
                    baseHigh = Precise.stringMul(Precise.stringMul(baseVolume, tolerance), high);
                }
                // because of exchange engines might not rounding numbers propertly, we add some tolerance of calculated 24hr high/low
                baseLow = Precise.stringDiv(baseLow, tolerance);
                baseHigh = Precise.stringMul(baseHigh, tolerance);
                assert(Precise.stringGe(quoteVolume, baseLow), add("quoteVolume should be => baseVolume * low", logText));
                assert(Precise.stringLe(quoteVolume, baseHigh), add("quoteVolume should be <= baseVolume * high", logText));
            }
        }
        // open and close should be between High & Low
        if (isTrue(isTrue(isTrue(!isEqual(high, null)) && isTrue(!isEqual(low, null))) && !isTrue((inOp(skippedProperties, "compareOHLC")))))
        {
            if (isTrue(!isEqual(open, null)))
            {
                assert(Precise.stringGe(open, low), add("open should be >= low", logText));
                assert(Precise.stringLe(open, high), add("open should be <= high", logText));
            }
            if (isTrue(!isEqual(close, null)))
            {
                assert(Precise.stringGe(close, low), add("close should be >= low", logText));
                assert(Precise.stringLe(close, high), add("close should be <= high", logText));
            }
        }
        //
        // vwap
        //
        object vwap = exchange.safeString(entry, "vwap");
        if (isTrue(!isEqual(vwap, null)))
        {
            // todo
            // assert (high !== undefined, 'vwap is defined, but high is not' + logText);
            // assert (low !== undefined, 'vwap is defined, but low is not' + logText);
            // assert (vwap >= low && vwap <= high)
            // todo: calc compare
            assert(!isTrue(valuesShouldBePositive) || isTrue(Precise.stringGe(vwap, "0")), add("vwap is not greater than zero", logText));
            if (isTrue(!isEqual(baseVolume, null)))
            {
                assert(!isEqual(quoteVolume, null), add("baseVolume & vwap is defined, but quoteVolume is not", logText));
            }
            if (isTrue(!isEqual(quoteVolume, null)))
            {
                assert(!isEqual(baseVolume, null), add("quoteVolume & vwap is defined, but baseVolume is not", logText));
            }
        }
        object askString = exchange.safeString(entry, "ask");
        object bidString = exchange.safeString(entry, "bid");
        if (isTrue(isTrue(isTrue((!isEqual(askString, null))) && isTrue((!isEqual(bidString, null)))) && !isTrue((inOp(skippedProperties, "spread")))))
        {
            testSharedMethods.assertGreater(exchange, skippedProperties, method, entry, "ask", exchange.safeString(entry, "bid"));
        }
        object percentage = exchange.safeString(entry, "percentage");
        object change = exchange.safeString(entry, "change");
        if (!isTrue((inOp(skippedProperties, "maxIncrease"))))
        {
            //
            // percentage
            //
            object maxIncrease = "100"; // for testing purposes, if "increased" value is more than 100x, tests should break as implementation might be wrong. however, if something rarest event happens and some coin really had that huge increase, the tests will shortly recover in few hours, as new 24-hour cycle would stabilize tests)
            if (isTrue(!isEqual(percentage, null)))
            {
                // - should be above -100 and below MAX
                assert(Precise.stringGe(percentage, "-100"), add("percentage should be above -100% ", logText));
                assert(Precise.stringLe(percentage, Precise.stringMul("+100", maxIncrease)), add(add(add("percentage should be below ", maxIncrease), "00% "), logText));
            }
            //
            // change
            //
            object approxValue = exchange.safeStringN(entry, new List<object>() {"open", "close", "average", "bid", "ask", "vwap", "previousClose"});
            if (isTrue(!isEqual(change, null)))
            {
                // - should be between -price & +price*100
                assert(Precise.stringGe(change, Precise.stringNeg(approxValue)), add("change should be above -price ", logText));
                assert(Precise.stringLe(change, Precise.stringMul(approxValue, maxIncrease)), add(add(add("change should be below ", maxIncrease), "x price "), logText));
            }
        }
        //
        // ensure all expected values are defined
        //
        if (isTrue(!isEqual(lastString, null)))
        {
            if (isTrue(!isEqual(percentage, null)))
            {
                // if one knows 'last' and 'percentage' values, then 'change', 'open' and 'average' values should be determinable.
                assert(isTrue(!isEqual(openPrice, null)) && isTrue(!isEqual(change, null)), add("open & change should be defined if last & percentage are defined", logText)); // todo : add average price too
            } else if (isTrue(!isEqual(change, null)))
            {
                // if one knows 'last' and 'change' values, then 'percentage', 'open' and 'average' values should be determinable.
                assert(isTrue(!isEqual(openPrice, null)) && isTrue(!isEqual(percentage, null)), add("open & percentage should be defined if last & change are defined", logText)); // todo : add average price too
            }
        } else if (isTrue(!isEqual(openPrice, null)))
        {
            if (isTrue(!isEqual(percentage, null)))
            {
                // if one knows 'open' and 'percentage' values, then 'last', 'change' and 'average' values should be determinable.
                assert(isTrue(!isEqual(lastString, null)) && isTrue(!isEqual(change, null)), add("last & change should be defined if open & percentage are defined", logText)); // todo : add average price too
            } else if (isTrue(!isEqual(change, null)))
            {
                // if one knows 'open' and 'change' values, then 'last', 'percentage' and 'average' values should be determinable.
                assert(isTrue(!isEqual(lastString, null)) && isTrue(!isEqual(percentage, null)), add("last & percentage should be defined if open & change are defined", logText)); // todo : add average price too
            }
        }
        //
        // todo: rethink about this
        // else {
        //    assert ((askString === undefined) && (bidString === undefined), 'ask & bid should be both defined or both undefined' + logText);
        // }
        testSharedMethods.assertSymbol(exchange, skippedProperties, method, entry, "symbol", symbol);
    }

}