namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class delta : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "delta" },
            { "name", "Delta Exchange" },
            { "countries", new List<object>() {"VC"} },
            { "rateLimit", 300 },
            { "version", "v2" },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", false },
                { "swap", true },
                { "future", false },
                { "option", true },
                { "addMargin", true },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "closeAllPositions", true },
                { "closePosition", false },
                { "createOrder", true },
                { "createReduceOnlyOrder", true },
                { "editOrder", true },
                { "fetchBalance", true },
                { "fetchClosedOrders", true },
                { "fetchCurrencies", true },
                { "fetchDeposit", null },
                { "fetchDepositAddress", true },
                { "fetchDepositAddresses", false },
                { "fetchDepositAddressesByNetwork", false },
                { "fetchDeposits", null },
                { "fetchFundingHistory", false },
                { "fetchFundingRate", true },
                { "fetchFundingRateHistory", false },
                { "fetchFundingRates", true },
                { "fetchGreeks", true },
                { "fetchIndexOHLCV", true },
                { "fetchLedger", true },
                { "fetchLeverage", true },
                { "fetchLeverageTiers", false },
                { "fetchMarginMode", true },
                { "fetchMarginModes", false },
                { "fetchMarketLeverageTiers", false },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", true },
                { "fetchMySettlementHistory", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterest", true },
                { "fetchOpenOrders", true },
                { "fetchOption", true },
                { "fetchOptionChain", false },
                { "fetchOrderBook", true },
                { "fetchPosition", true },
                { "fetchPositionMode", false },
                { "fetchPositions", true },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchSettlementHistory", true },
                { "fetchStatus", true },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", true },
                { "fetchTrades", true },
                { "fetchTransfer", null },
                { "fetchTransfers", null },
                { "fetchUnderlyingAssets", false },
                { "fetchVolatilityHistory", false },
                { "fetchWithdrawal", null },
                { "fetchWithdrawals", null },
                { "reduceMargin", true },
                { "setLeverage", true },
                { "setMargin", false },
                { "setMarginMode", false },
                { "setPositionMode", false },
                { "transfer", false },
                { "withdraw", false },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "1m" },
                { "3m", "3m" },
                { "5m", "5m" },
                { "15m", "15m" },
                { "30m", "30m" },
                { "1h", "1h" },
                { "2h", "2h" },
                { "4h", "4h" },
                { "6h", "6h" },
                { "1d", "1d" },
                { "7d", "7d" },
                { "1w", "1w" },
                { "2w", "2w" },
                { "1M", "30d" },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://user-images.githubusercontent.com/1294454/99450025-3be60a00-2931-11eb-9302-f4fd8d8589aa.jpg" },
                { "test", new Dictionary<string, object>() {
                    { "public", "https://testnet-api.delta.exchange" },
                    { "private", "https://testnet-api.delta.exchange" },
                } },
                { "api", new Dictionary<string, object>() {
                    { "public", "https://api.delta.exchange" },
                    { "private", "https://api.delta.exchange" },
                } },
                { "www", "https://www.delta.exchange" },
                { "doc", new List<object>() {"https://docs.delta.exchange"} },
                { "fees", "https://www.delta.exchange/fees" },
                { "referral", "https://www.delta.exchange/app/signup/?code=IULYNB" },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new List<object>() {"assets", "indices", "products", "products/{symbol}", "tickers", "tickers/{symbol}", "l2orderbook/{symbol}", "trades/{symbol}", "stats", "history/candles", "history/sparklines", "settings"} },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new List<object>() {"orders", "products/{product_id}/orders/leverage", "positions/margined", "positions", "orders/history", "fills", "fills/history/download/csv", "wallet/balances", "wallet/transactions", "wallet/transactions/download", "wallets/sub_accounts_transfer_history", "users/trading_preferences", "sub_accounts", "profile", "deposits/address", "orders/leverage"} },
                    { "post", new List<object>() {"orders", "orders/bracket", "orders/batch", "products/{product_id}/orders/leverage", "positions/change_margin", "positions/close_all", "wallets/sub_account_balance_transfer", "orders/cancel_after", "orders/leverage"} },
                    { "put", new List<object>() {"orders", "orders/bracket", "orders/batch", "positions/auto_topup", "users/update_mmp", "users/reset_mmp"} },
                    { "delete", new List<object>() {"orders", "orders/all", "orders/batch"} },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "tierBased", true },
                    { "percentage", true },
                    { "taker", this.parseNumber("0.0015") },
                    { "maker", this.parseNumber("0.0010") },
                    { "tiers", new Dictionary<string, object>() {
                        { "taker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.0015")}, new List<object> {this.parseNumber("100"), this.parseNumber("0.0013")}, new List<object> {this.parseNumber("250"), this.parseNumber("0.0013")}, new List<object> {this.parseNumber("1000"), this.parseNumber("0.001")}, new List<object> {this.parseNumber("5000"), this.parseNumber("0.0009")}, new List<object> {this.parseNumber("10000"), this.parseNumber("0.00075")}, new List<object> {this.parseNumber("20000"), this.parseNumber("0.00065")}} },
                        { "maker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.001")}, new List<object> {this.parseNumber("100"), this.parseNumber("0.001")}, new List<object> {this.parseNumber("250"), this.parseNumber("0.0009")}, new List<object> {this.parseNumber("1000"), this.parseNumber("0.00075")}, new List<object> {this.parseNumber("5000"), this.parseNumber("0.0006")}, new List<object> {this.parseNumber("10000"), this.parseNumber("0.0005")}, new List<object> {this.parseNumber("20000"), this.parseNumber("0.0005")}} },
                    } },
                } },
            } },
            { "options", new Dictionary<string, object>() {
                { "networks", new Dictionary<string, object>() {
                    { "TRC20", "TRC20(TRON)" },
                    { "BEP20", "BEP20(BSC)" },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "requiredCredentials", new Dictionary<string, object>() {
                { "apiKey", true },
                { "secret", true },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "insufficient_margin", typeof(InsufficientFunds) },
                    { "order_size_exceed_available", typeof(InvalidOrder) },
                    { "risk_limits_breached", typeof(BadRequest) },
                    { "invalid_contract", typeof(BadSymbol) },
                    { "immediate_liquidation", typeof(InvalidOrder) },
                    { "out_of_bankruptcy", typeof(InvalidOrder) },
                    { "self_matching_disrupted_post_only", typeof(InvalidOrder) },
                    { "immediate_execution_post_only", typeof(InvalidOrder) },
                    { "bad_schema", typeof(BadRequest) },
                    { "invalid_api_key", typeof(AuthenticationError) },
                    { "invalid_signature", typeof(AuthenticationError) },
                    { "open_order_not_found", typeof(OrderNotFound) },
                    { "unavailable", typeof(ExchangeNotAvailable) },
                } },
                { "broad", new Dictionary<string, object>() {} },
            } },
        });
    }

    public override object createExpiredOptionMarket(object symbol)
    {
        // support expired option contracts
        object quote = "USDT";
        object optionParts = ((string)symbol).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
        object symbolBase = ((string)symbol).Split(new [] {((string)"/")}, StringSplitOptions.None).ToList<object>();
        object bs = null;
        object expiry = null;
        object optionType = null;
        if (isTrue(isGreaterThan(getIndexOf(symbol, "/"), -1)))
        {
            bs = this.safeString(symbolBase, 0);
            expiry = this.safeString(optionParts, 1);
            optionType = this.safeString(optionParts, 3);
        } else
        {
            bs = this.safeString(optionParts, 1);
            expiry = this.safeString(optionParts, 3);
            optionType = this.safeString(optionParts, 0);
        }
        object settle = quote;
        object strike = this.safeString(optionParts, 2);
        object datetime = this.convertExpireDate(expiry);
        object timestamp = this.parse8601(datetime);
        return new Dictionary<string, object>() {
            { "id", add(add(add(add(add(add(optionType, "-"), bs), "-"), strike), "-"), expiry) },
            { "symbol", add(add(add(add(add(add(add(add(add(add(bs, "/"), quote), ":"), settle), "-"), expiry), "-"), strike), "-"), optionType) },
            { "base", bs },
            { "quote", quote },
            { "settle", settle },
            { "baseId", bs },
            { "quoteId", quote },
            { "settleId", settle },
            { "active", false },
            { "type", "option" },
            { "linear", null },
            { "inverse", null },
            { "spot", false },
            { "swap", false },
            { "future", false },
            { "option", true },
            { "margin", false },
            { "contract", true },
            { "contractSize", this.parseNumber("1") },
            { "expiry", timestamp },
            { "expiryDatetime", datetime },
            { "optionType", ((bool) isTrue((isEqual(optionType, "C")))) ? "call" : "put" },
            { "strike", this.parseNumber(strike) },
            { "precision", new Dictionary<string, object>() {
                { "amount", null },
                { "price", null },
            } },
            { "limits", new Dictionary<string, object>() {
                { "amount", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
            } },
            { "info", null },
        };
    }

    public override object safeMarket(object marketId = null, object market = null, object delimiter = null, object marketType = null)
    {
        object isOption = isTrue((!isEqual(marketId, null))) && isTrue((isTrue(isTrue(isTrue((((string)marketId).EndsWith(((string)"-C")))) || isTrue((((string)marketId).EndsWith(((string)"-P"))))) || isTrue((((string)marketId).StartsWith(((string)"C-"))))) || isTrue((((string)marketId).StartsWith(((string)"P-"))))));
        if (isTrue(isTrue(isOption) && !isTrue((inOp(this.markets_by_id, marketId)))))
        {
            // handle expired option contracts
            return this.createExpiredOptionMarket(marketId);
        }
        return base.safeMarket(marketId, market, delimiter, marketType);
    }

    /**
     * @method
     * @name delta#fetchTime
     * @description fetches the current integer timestamp in milliseconds from the exchange server
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {int} the current integer timestamp in milliseconds from the exchange server
     */
    public async override Task<object> fetchTime(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetSettings(parameters);
        // full response sample under `fetchStatus`
        object result = this.safeDict(response, "result", new Dictionary<string, object>() {});
        return this.safeIntegerProduct(result, "server_time", 0.001);
    }

    /**
     * @method
     * @name delta#fetchStatus
     * @description the latest known information on the availability of the exchange API
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [status structure]{@link https://docs.ccxt.com/#/?id=exchange-status-structure}
     */
    public async override Task<object> fetchStatus(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetSettings(parameters);
        //
        //     {
        //         "result": {
        //           "deto_liquidity_mining_daily_reward": "40775",
        //           "deto_msp": "1.0",
        //           "deto_staking_daily_reward": "23764.08",
        //           "enabled_wallets": [
        //             "BTC",
        //             ...
        //           ],
        //           "portfolio_margin_params": {
        //             "enabled_portfolios": {
        //               ".DEAVAXUSDT": {
        //                 "asset_id": 5,
        //                 "futures_contingency_margin_percent": "1",
        //                 "interest_rate": "0",
        //                 "maintenance_margin_multiplier": "0.8",
        //                 "max_price_shock": "20",
        //                 "max_short_notional_limit": "2000",
        //                 "options_contingency_margin_percent": "1",
        //                 "options_discount_range": "10",
        //                 "options_liq_band_range_percentage": "25",
        //                 "settling_asset": "USDT",
        //                 "sort_priority": 5,
        //                 "underlying_asset": "AVAX",
        //                 "volatility_down_shock": "30",
        //                 "volatility_up_shock": "45"
        //               },
        //               ...
        //             },
        //             "portfolio_enabled_contracts": [
        //               "futures",
        //               "perpetual_futures",
        //               "call_options",
        //               "put_options"
        //             ]
        //           },
        //           "server_time": 1650640673500273,
        //           "trade_farming_daily_reward": "100000",
        //           "circulating_supply": "140000000",
        //           "circulating_supply_update_time": "1636752800",
        //           "deto_referral_mining_daily_reward": "0",
        //           "deto_total_reward_pool": "100000000",
        //           "deto_trade_mining_daily_reward": "0",
        //           "kyc_deposit_limit": "20",
        //           "kyc_withdrawal_limit": "10000",
        //           "maintenance_start_time": "1650387600000000",
        //           "msp_deto_commission_percent": "25",
        //           "under_maintenance": "false"
        //         },
        //         "success": true
        //     }
        //
        object result = this.safeDict(response, "result", new Dictionary<string, object>() {});
        object underMaintenance = this.safeString(result, "under_maintenance");
        object status = ((bool) isTrue((isEqual(underMaintenance, "true")))) ? "maintenance" : "ok";
        object updated = this.safeIntegerProduct(result, "server_time", 0.001, this.milliseconds());
        return new Dictionary<string, object>() {
            { "status", status },
            { "updated", updated },
            { "eta", null },
            { "url", null },
            { "info", response },
        };
    }

    /**
     * @method
     * @name delta#fetchCurrencies
     * @description fetches all available currencies on an exchange
     * @see https://docs.delta.exchange/#get-list-of-all-assets
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an associative dictionary of currencies
     */
    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetAssets(parameters);
        //
        //     {
        //         "result":[
        //             {
        //                 "base_withdrawal_fee":"0.0005",
        //                 "deposit_status":"enabled",
        //                 "id":2,
        //                 "interest_credit":true,
        //                 "interest_slabs":[
        //                     {"limit":"0.1","rate":"0"},
        //                     {"limit":"1","rate":"0.05"},
        //                     {"limit":"5","rate":"0.075"},
        //                     {"limit":"10","rate":"0.1"},
        //                     {"limit":"9999999999999999","rate":"0"}
        //                 ],
        //                 "kyc_deposit_limit":"10",
        //                 "kyc_withdrawal_limit":"2",
        //                 "min_withdrawal_amount":"0.001",
        //                 "minimum_precision":4,
        //                 "name":"Bitcoin",
        //                 "precision":8,
        //                 "sort_priority":1,
        //                 "symbol":"BTC",
        //                 "variable_withdrawal_fee":"0",
        //                 "withdrawal_status":"enabled"
        //             },
        //         ],
        //         "success":true
        //     }
        //
        object currencies = this.safeList(response, "result", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(currencies)); postFixIncrement(ref i))
        {
            object currency = getValue(currencies, i);
            object id = this.safeString(currency, "symbol");
            object numericId = this.safeInteger(currency, "id");
            object code = this.safeCurrencyCode(id);
            object depositStatus = this.safeString(currency, "deposit_status");
            object withdrawalStatus = this.safeString(currency, "withdrawal_status");
            object depositsEnabled = (isEqual(depositStatus, "enabled"));
            object withdrawalsEnabled = (isEqual(withdrawalStatus, "enabled"));
            object active = isTrue(depositsEnabled) && isTrue(withdrawalsEnabled);
            ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                { "id", id },
                { "numericId", numericId },
                { "code", code },
                { "name", this.safeString(currency, "name") },
                { "info", currency },
                { "active", active },
                { "deposit", depositsEnabled },
                { "withdraw", withdrawalsEnabled },
                { "fee", this.safeNumber(currency, "base_withdrawal_fee") },
                { "precision", this.parseNumber(this.parsePrecision(this.safeString(currency, "precision"))) },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", this.safeNumber(currency, "min_withdrawal_amount") },
                        { "max", null },
                    } },
                } },
                { "networks", new Dictionary<string, object>() {} },
            };
        }
        return result;
    }

    public async override Task<object> loadMarkets(object reload = null, object parameters = null)
    {
        reload ??= false;
        parameters ??= new Dictionary<string, object>();
        object markets = await base.loadMarkets(reload, parameters);
        object currenciesByNumericId = this.safeDict(this.options, "currenciesByNumericId");
        if (isTrue(isTrue((isEqual(currenciesByNumericId, null))) || isTrue(reload)))
        {
            ((IDictionary<string,object>)this.options)["currenciesByNumericId"] = this.indexByStringifiedNumericId(this.currencies);
        }
        object marketsByNumericId = this.safeDict(this.options, "marketsByNumericId");
        if (isTrue(isTrue((isEqual(marketsByNumericId, null))) || isTrue(reload)))
        {
            ((IDictionary<string,object>)this.options)["marketsByNumericId"] = this.indexByStringifiedNumericId(this.markets);
        }
        return markets;
    }

    public virtual object indexByStringifiedNumericId(object input)
    {
        object result = new Dictionary<string, object>() {};
        if (isTrue(isEqual(input, null)))
        {
            return null;
        }
        object keys = new List<object>(((IDictionary<string,object>)input).Keys);
        for (object i = 0; isLessThan(i, getArrayLength(keys)); postFixIncrement(ref i))
        {
            object key = getValue(keys, i);
            object item = getValue(input, key);
            object numericIdString = this.safeString(item, "numericId");
            if (isTrue(isEqual(numericIdString, null)))
            {
                continue;
            }
            ((IDictionary<string,object>)result)[(string)numericIdString] = item;
        }
        return result;
    }

    /**
     * @method
     * @name delta#fetchMarkets
     * @description retrieves data on all markets for delta
     * @see https://docs.delta.exchange/#get-list-of-products
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async override Task<object> fetchMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetProducts(parameters);
        //
        //     {
        //         "meta":{ "after":null, "before":null, "limit":100, "total_count":81 },
        //         "result":[
        //             // the below response represents item from perpetual market
        //             {
        //                 "annualized_funding":"5.475000000000000000",
        //                 "is_quanto":false,
        //                 "ui_config":{
        //                     "default_trading_view_candle":"15",
        //                     "leverage_slider_values":[1,3,5,10,25,50],
        //                     "price_clubbing_values":[0.001,0.005,0.05,0.1,0.5,1,5],
        //                     "show_bracket_orders":false,
        //                     "sort_priority":29,
        //                     "tags":[]
        //                 },
        //                 "basis_factor_max_limit":"0.15",
        //                 "symbol":"P-LINK-D-151120",
        //                 "id":1584,
        //                 "default_leverage":"5.000000000000000000",
        //                 "maker_commission_rate":"0.0005",
        //                 "contract_unit_currency":"LINK",
        //                 "strike_price":"12.507948",
        //                 "settling_asset":{
        //                     // asset structure
        //                 },
        //                 "auction_start_time":null,
        //                 "auction_finish_time":null,
        //                 "settlement_time":"2020-11-15T12:00:00Z",
        //                 "launch_time":"2020-11-14T11:55:05Z",
        //                 "spot_index":{
        //                     // index structure
        //                 },
        //                 "trading_status":"operational",
        //                 "tick_size":"0.001",
        //                 "position_size_limit":100000,
        //                 "notional_type":"vanilla", // vanilla, inverse
        //                 "price_band":"0.4",
        //                 "barrier_price":null,
        //                 "description":"Daily LINK PUT options quoted in USDT and settled in USDT",
        //                 "insurance_fund_margin_contribution":"1",
        //                 "quoting_asset":{
        //                     // asset structure
        //                 },
        //                 "liquidation_penalty_factor":"0.2",
        //                 "product_specs":{"max_volatility":3,"min_volatility":0.3,"spot_price_band":"0.40"},
        //                 "initial_margin_scaling_factor":"0.0001",
        //                 "underlying_asset":{
        //                     // asset structure
        //                 },
        //                 "state":"live",
        //                 "contract_value":"1",
        //                 "initial_margin":"2",
        //                 "impact_size":5000,
        //                 "settlement_price":null,
        //                 "contract_type":"put_options", // put_options, call_options, move_options, perpetual_futures, interest_rate_swaps, futures, spreads
        //                 "taker_commission_rate":"0.0005",
        //                 "maintenance_margin":"1",
        //                 "short_description":"LINK Daily PUT Options",
        //                 "maintenance_margin_scaling_factor":"0.00005",
        //                 "funding_method":"mark_price",
        //                 "max_leverage_notional":"20000"
        //             },
        //             // the below response represents item from spot market
        //             {
        //                 "position_size_limit": 10000000,
        //                 "settlement_price": null,
        //                 "funding_method": "mark_price",
        //                 "settling_asset": null,
        //                 "impact_size": 10,
        //                 "id": 32258,
        //                 "auction_finish_time": null,
        //                 "description": "Solana tether spot market",
        //                 "trading_status": "operational",
        //                 "tick_size": "0.01",
        //                 "liquidation_penalty_factor": "1",
        //                 "spot_index": {
        //                     "config": { "quoting_asset": "USDT", "service_id": 8, "underlying_asset": "SOL" },
        //                     "constituent_exchanges": [
        //                         { "exchange": "binance", "health_interval": 60, "health_priority": 1, "weight": 1 },
        //                         { "exchange": "huobi", "health_interval": 60, "health_priority": 2, "weight": 1 }
        //                     ],
        //                     "constituent_indices": null,
        //                     "description": "Solana index from binance and huobi",
        //                     "health_interval": 300,
        //                     "id": 105,
        //                     "impact_size": "40.000000000000000000",
        //                     "index_type": "spot_pair",
        //                     "is_composite": false,
        //                     "price_method": "ltp",
        //                     "quoting_asset_id": 5,
        //                     "symbol": ".DESOLUSDT",
        //                     "tick_size": "0.000100000000000000",
        //                     "underlying_asset_id": 66
        //                 },
        //                 "contract_type": "spot",
        //                 "launch_time": "2022-02-03T10:18:11Z",
        //                 "symbol": "SOL_USDT",
        //                 "disruption_reason": null,
        //                 "settlement_time": null,
        //                 "insurance_fund_margin_contribution": "1",
        //                 "is_quanto": false,
        //                 "maintenance_margin": "5",
        //                 "taker_commission_rate": "0.0005",
        //                 "auction_start_time": null,
        //                 "max_leverage_notional": "10000000",
        //                 "state": "live",
        //                 "annualized_funding": "0",
        //                 "notional_type": "vanilla",
        //                 "price_band": "100",
        //                 "product_specs": { "kyc_required": false, "max_order_size": 2000, "min_order_size": 0.01, "quoting_precision": 4, "underlying_precision": 2 },
        //                 "default_leverage": "1.000000000000000000",
        //                 "initial_margin": "10",
        //                 "maintenance_margin_scaling_factor": "1",
        //                 "ui_config": {
        //                     "default_trading_view_candle": "1d",
        //                     "leverage_slider_values": [],
        //                     "price_clubbing_values": [ 0.01, 0.05, 0.1, 0.5, 1, 2.5, 5 ],
        //                     "show_bracket_orders": false,
        //                     "sort_priority": 2,
        //                     "tags": []
        //                 },
        //                 "basis_factor_max_limit": "10000",
        //                 "contract_unit_currency": "SOL",
        //                 "strike_price": null,
        //                 "quoting_asset": {
        //                     "base_withdrawal_fee": "10.000000000000000000",
        //                     "deposit_status": "enabled",
        //                     "id": 5,
        //                     "interest_credit": false,
        //                     "interest_slabs": null,
        //                     "kyc_deposit_limit": "100000.000000000000000000",
        //                     "kyc_withdrawal_limit": "10000.000000000000000000",
        //                     "min_withdrawal_amount": "30.000000000000000000",
        //                     "minimum_precision": 2,
        //                     "name": "Tether",
        //                     "networks": [
        //                         { "base_withdrawal_fee": "25", "deposit_status": "enabled", "memo_required": false, "network": "ERC20", "variable_withdrawal_fee": "0", "withdrawal_status": "enabled" },
        //                         { "base_withdrawal_fee": "1", "deposit_status": "enabled", "memo_required": false, "network": "BEP20(BSC)", "variable_withdrawal_fee": "0", "withdrawal_status": "enabled" },
        //                         { "base_withdrawal_fee": "1", "deposit_status": "disabled", "memo_required": false, "network": "TRC20(TRON)", "variable_withdrawal_fee": "0", "withdrawal_status": "disabled" }
        //                     ],
        //                     "precision": 8,
        //                     "sort_priority": 1,
        //                     "symbol": "USDT",
        //                     "variable_withdrawal_fee": "0.000000000000000000",
        //                     "withdrawal_status": "enabled"
        //                 },
        //                 "maker_commission_rate": "0.0005",
        //                 "initial_margin_scaling_factor": "2",
        //                 "underlying_asset": {
        //                     "base_withdrawal_fee": "0.000000000000000000",
        //                     "deposit_status": "enabled",
        //                     "id": 66,
        //                     "interest_credit": false,
        //                     "interest_slabs": null,
        //                     "kyc_deposit_limit": "0.000000000000000000",
        //                     "kyc_withdrawal_limit": "0.000000000000000000",
        //                     "min_withdrawal_amount": "0.020000000000000000",
        //                     "minimum_precision": 4,
        //                     "name": "Solana",
        //                     "networks": [
        //                         { "base_withdrawal_fee": "0.01", "deposit_status": "enabled", "memo_required": false, "network": "SOLANA", "variable_withdrawal_fee": "0", "withdrawal_status": "enabled" },
        //                         { "base_withdrawal_fee": "0.01", "deposit_status": "enabled", "memo_required": false, "network": "BEP20(BSC)", "variable_withdrawal_fee": "0", "withdrawal_status": "enabled" }
        //                     ],
        //                     "precision": 8,
        //                     "sort_priority": 7,
        //                     "symbol": "SOL",
        //                     "variable_withdrawal_fee": "0.000000000000000000",
        //                     "withdrawal_status": "enabled"
        //                 },
        //                 "barrier_price": null,
        //                 "contract_value": "1",
        //                 "short_description": "SOL-USDT spot market"
        //             },
        //         ],
        //         "success":true
        //     }
        //
        object markets = this.safeList(response, "result", new List<object>() {});
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(markets)); postFixIncrement(ref i))
        {
            object market = getValue(markets, i);
            object type = this.safeString(market, "contract_type");
            if (isTrue(isEqual(type, "options_combos")))
            {
                continue;
            }
            // const settlingAsset = this.safeValue (market, 'settling_asset', {});
            object quotingAsset = this.safeDict(market, "quoting_asset", new Dictionary<string, object>() {});
            object underlyingAsset = this.safeDict(market, "underlying_asset", new Dictionary<string, object>() {});
            object settlingAsset = this.safeDict(market, "settling_asset");
            object productSpecs = this.safeDict(market, "product_specs", new Dictionary<string, object>() {});
            object baseId = this.safeString(underlyingAsset, "symbol");
            object quoteId = this.safeString(quotingAsset, "symbol");
            object settleId = this.safeString(settlingAsset, "symbol");
            object id = this.safeString(market, "symbol");
            object numericId = this.safeInteger(market, "id");
            object bs = this.safeCurrencyCode(baseId);
            object quote = this.safeCurrencyCode(quoteId);
            object settle = this.safeCurrencyCode(settleId);
            object callOptions = (isEqual(type, "call_options"));
            object putOptions = (isEqual(type, "put_options"));
            object moveOptions = (isEqual(type, "move_options"));
            object spot = (isEqual(type, "spot"));
            object swap = (isEqual(type, "perpetual_futures"));
            object future = (isEqual(type, "futures"));
            object option = (isTrue(isTrue(callOptions) || isTrue(putOptions)) || isTrue(moveOptions));
            object strike = this.safeString(market, "strike_price");
            object expiryDatetime = this.safeString(market, "settlement_time");
            object expiry = this.parse8601(expiryDatetime);
            object contractSize = this.safeNumber(market, "contract_value");
            object amountPrecision = null;
            if (isTrue(spot))
            {
                amountPrecision = this.parseNumber(this.parsePrecision(this.safeString(productSpecs, "underlying_precision"))); // seems inverse of 'impact_size'
            } else
            {
                // other markets (swap, futures, move, spread, irs) seem to use the step of '1' contract
                amountPrecision = this.parseNumber("1");
            }
            object linear = (isEqual(settle, quote));
            object optionType = null;
            object symbol = add(add(bs, "/"), quote);
            if (isTrue(isTrue(isTrue(swap) || isTrue(future)) || isTrue(option)))
            {
                symbol = add(add(symbol, ":"), settle);
                if (isTrue(isTrue(future) || isTrue(option)))
                {
                    symbol = add(add(symbol, "-"), this.yymmdd(expiry));
                    if (isTrue(option))
                    {
                        type = "option";
                        object letter = "C";
                        optionType = "call";
                        if (isTrue(putOptions))
                        {
                            letter = "P";
                            optionType = "put";
                        } else if (isTrue(moveOptions))
                        {
                            letter = "M";
                            optionType = "move";
                        }
                        symbol = add(add(add(add(symbol, "-"), strike), "-"), letter);
                    } else
                    {
                        type = "future";
                    }
                } else
                {
                    type = "swap";
                }
            }
            object state = this.safeString(market, "state");
            ((IList<object>)result).Add(new Dictionary<string, object>() {
                { "id", id },
                { "numericId", numericId },
                { "symbol", symbol },
                { "base", bs },
                { "quote", quote },
                { "settle", settle },
                { "baseId", baseId },
                { "quoteId", quoteId },
                { "settleId", settleId },
                { "type", type },
                { "spot", spot },
                { "margin", ((bool) isTrue(spot)) ? null : false },
                { "swap", swap },
                { "future", future },
                { "option", option },
                { "active", (isEqual(state, "live")) },
                { "contract", !isTrue(spot) },
                { "linear", ((bool) isTrue(spot)) ? null : linear },
                { "inverse", ((bool) isTrue(spot)) ? null : !isTrue(linear) },
                { "taker", this.safeNumber(market, "taker_commission_rate") },
                { "maker", this.safeNumber(market, "maker_commission_rate") },
                { "contractSize", contractSize },
                { "expiry", expiry },
                { "expiryDatetime", expiryDatetime },
                { "strike", this.parseNumber(strike) },
                { "optionType", optionType },
                { "precision", new Dictionary<string, object>() {
                    { "amount", amountPrecision },
                    { "price", this.safeNumber(market, "tick_size") },
                } },
                { "limits", new Dictionary<string, object>() {
                    { "leverage", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "amount", new Dictionary<string, object>() {
                        { "min", this.parseNumber("1") },
                        { "max", this.safeNumber(market, "position_size_limit") },
                    } },
                    { "price", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "cost", new Dictionary<string, object>() {
                        { "min", this.safeNumber(market, "min_size") },
                        { "max", null },
                    } },
                } },
                { "created", this.parse8601(this.safeString(market, "launch_time")) },
                { "info", market },
            });
        }
        return result;
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        // spot: fetchTicker, fetchTickers
        //
        //     {
        //         "close": 30634.0,
        //         "contract_type": "spot",
        //         "greeks": null,
        //         "high": 30780.0,
        //         "low": 30340.5,
        //         "mark_price": "48000",
        //         "oi": "0.0000",
        //         "oi_change_usd_6h": "0.0000",
        //         "oi_contracts": "0",
        //         "oi_value": "0.0000",
        //         "oi_value_symbol": "BTC",
        //         "oi_value_usd": "0.0000",
        //         "open": 30464.0,
        //         "price_band": null,
        //         "product_id": 8320,
        //         "quotes": {},
        //         "size": 2.6816639999999996,
        //         "spot_price": "30637.91465121",
        //         "symbol": "BTC_USDT",
        //         "timestamp": 1689139767621299,
        //         "turnover": 2.6816639999999996,
        //         "turnover_symbol": "BTC",
        //         "turnover_usd": 81896.45613400004,
        //         "volume": 2.6816639999999996
        //     }
        //
        // swap: fetchTicker, fetchTickers
        //
        //     {
        //         "close": 30600.5,
        //         "contract_type": "perpetual_futures",
        //         "funding_rate": "0.00602961",
        //         "greeks": null,
        //         "high": 30803.0,
        //         "low": 30265.5,
        //         "mark_basis": "-0.45601594",
        //         "mark_price": "30600.10481568",
        //         "oi": "469.9190",
        //         "oi_change_usd_6h": "2226314.9900",
        //         "oi_contracts": "469919",
        //         "oi_value": "469.9190",
        //         "oi_value_symbol": "BTC",
        //         "oi_value_usd": "14385640.6802",
        //         "open": 30458.5,
        //         "price_band": {
        //             "lower_limit": "29067.08312627",
        //             "upper_limit": "32126.77608693"
        //         },
        //         "product_id": 139,
        //         "quotes": {
        //             "ask_iv": null,
        //             "ask_size": "965",
        //             "best_ask": "30600.5",
        //             "best_bid": "30599.5",
        //             "bid_iv": null,
        //             "bid_size": "196",
        //             "impact_mid_price": null,
        //             "mark_iv": "-0.44931641"
        //         },
        //         "size": 1226303,
        //         "spot_price": "30612.85362773",
        //         "symbol": "BTCUSDT",
        //         "timestamp": 1689136597460456,
        //         "turnover": 37392218.45999999,
        //         "turnover_symbol": "USDT",
        //         "turnover_usd": 37392218.45999999,
        //         "volume": 1226.3029999999485
        //     }
        //
        // option: fetchTicker, fetchTickers
        //
        //     {
        //         "contract_type": "call_options",
        //         "greeks": {
        //             "delta": "0.60873994",
        //             "gamma": "0.00014854",
        //             "rho": "7.71808010",
        //             "spot": "30598.49040622",
        //             "theta": "-30.44743017",
        //             "vega": "24.83508248"
        //         },
        //         "mark_price": "1347.74819696",
        //         "mark_vol": "0.39966303",
        //         "oi": "2.7810",
        //         "oi_change_usd_6h": "0.0000",
        //         "oi_contracts": "2781",
        //         "oi_value": "2.7810",
        //         "oi_value_symbol": "BTC",
        //         "oi_value_usd": "85127.4337",
        //         "price_band": {
        //             "lower_limit": "91.27423497",
        //             "upper_limit": "7846.19454697"
        //         },
        //         "product_id": 107150,
        //         "quotes": {
        //             "ask_iv": "0.41023239",
        //             "ask_size": "2397",
        //             "best_ask": "1374",
        //             "best_bid": "1322",
        //             "bid_iv": "0.38929375",
        //             "bid_size": "3995",
        //             "impact_mid_price": null,
        //             "mark_iv": "0.39965618"
        //         },
        //         "spot_price": "30598.43379314",
        //         "strike_price": "30000",
        //         "symbol": "C-BTC-30000-280723",
        //         "timestamp": 1689136932893181,
        //         "turnover_symbol": "USDT"
        //     }
        //
        object timestamp = this.safeIntegerProduct(ticker, "timestamp", 0.001);
        object marketId = this.safeString(ticker, "symbol");
        object symbol = this.safeSymbol(marketId, market);
        object last = this.safeString(ticker, "close");
        object quotes = this.safeDict(ticker, "quotes", new Dictionary<string, object>() {});
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeNumber(ticker, "high") },
            { "low", this.safeNumber(ticker, "low") },
            { "bid", this.safeNumber(quotes, "best_bid") },
            { "bidVolume", this.safeNumber(quotes, "bid_size") },
            { "ask", this.safeNumber(quotes, "best_ask") },
            { "askVolume", this.safeNumber(quotes, "ask_size") },
            { "vwap", null },
            { "open", this.safeString(ticker, "open") },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", null },
            { "average", null },
            { "baseVolume", this.safeNumber(ticker, "volume") },
            { "quoteVolume", this.safeNumber(ticker, "turnover") },
            { "markPrice", this.safeNumber(ticker, "mark_price") },
            { "indexPrice", this.safeNumber(ticker, "spot_price") },
            { "info", ticker },
        }, market);
    }

    /**
     * @method
     * @name delta#fetchTicker
     * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://docs.delta.exchange/#get-ticker-for-a-product-by-symbol
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.publicGetTickersSymbol(this.extend(request, parameters));
        //
        // spot
        //
        //     {
        //         "result": {
        //             "close": 30634.0,
        //             "contract_type": "spot",
        //             "greeks": null,
        //             "high": 30780.0,
        //             "low": 30340.5,
        //             "mark_price": "48000",
        //             "oi": "0.0000",
        //             "oi_change_usd_6h": "0.0000",
        //             "oi_contracts": "0",
        //             "oi_value": "0.0000",
        //             "oi_value_symbol": "BTC",
        //             "oi_value_usd": "0.0000",
        //             "open": 30464.0,
        //             "price_band": null,
        //             "product_id": 8320,
        //             "quotes": {},
        //             "size": 2.6816639999999996,
        //             "spot_price": "30637.91465121",
        //             "symbol": "BTC_USDT",
        //             "timestamp": 1689139767621299,
        //             "turnover": 2.6816639999999996,
        //             "turnover_symbol": "BTC",
        //             "turnover_usd": 81896.45613400004,
        //             "volume": 2.6816639999999996
        //         },
        //         "success": true
        //     }
        //
        // swap
        //
        //     {
        //         "result": {
        //             "close": 30600.5,
        //             "contract_type": "perpetual_futures",
        //             "funding_rate": "0.00602961",
        //             "greeks": null,
        //             "high": 30803.0,
        //             "low": 30265.5,
        //             "mark_basis": "-0.45601594",
        //             "mark_price": "30600.10481568",
        //             "oi": "469.9190",
        //             "oi_change_usd_6h": "2226314.9900",
        //             "oi_contracts": "469919",
        //             "oi_value": "469.9190",
        //             "oi_value_symbol": "BTC",
        //             "oi_value_usd": "14385640.6802",
        //             "open": 30458.5,
        //             "price_band": {
        //                 "lower_limit": "29067.08312627",
        //                 "upper_limit": "32126.77608693"
        //             },
        //             "product_id": 139,
        //             "quotes": {
        //                 "ask_iv": null,
        //                 "ask_size": "965",
        //                 "best_ask": "30600.5",
        //                 "best_bid": "30599.5",
        //                 "bid_iv": null,
        //                 "bid_size": "196",
        //                 "impact_mid_price": null,
        //                 "mark_iv": "-0.44931641"
        //             },
        //             "size": 1226303,
        //             "spot_price": "30612.85362773",
        //             "symbol": "BTCUSDT",
        //             "timestamp": 1689136597460456,
        //             "turnover": 37392218.45999999,
        //             "turnover_symbol": "USDT",
        //             "turnover_usd": 37392218.45999999,
        //             "volume": 1226.3029999999485
        //         },
        //         "success": true
        //     }
        //
        // option
        //
        //     {
        //         "result": {
        //             "contract_type": "call_options",
        //             "greeks": {
        //                 "delta": "0.60873994",
        //                 "gamma": "0.00014854",
        //                 "rho": "7.71808010",
        //                 "spot": "30598.49040622",
        //                 "theta": "-30.44743017",
        //                 "vega": "24.83508248"
        //             },
        //             "mark_price": "1347.74819696",
        //             "mark_vol": "0.39966303",
        //             "oi": "2.7810",
        //             "oi_change_usd_6h": "0.0000",
        //             "oi_contracts": "2781",
        //             "oi_value": "2.7810",
        //             "oi_value_symbol": "BTC",
        //             "oi_value_usd": "85127.4337",
        //             "price_band": {
        //                 "lower_limit": "91.27423497",
        //                 "upper_limit": "7846.19454697"
        //             },
        //             "product_id": 107150,
        //             "quotes": {
        //                 "ask_iv": "0.41023239",
        //                 "ask_size": "2397",
        //                 "best_ask": "1374",
        //                 "best_bid": "1322",
        //                 "bid_iv": "0.38929375",
        //                 "bid_size": "3995",
        //                 "impact_mid_price": null,
        //                 "mark_iv": "0.39965618"
        //             },
        //             "spot_price": "30598.43379314",
        //             "strike_price": "30000",
        //             "symbol": "C-BTC-30000-280723",
        //             "timestamp": 1689136932893181,
        //             "turnover_symbol": "USDT"
        //         },
        //         "success": true
        //     }
        //
        object result = this.safeDict(response, "result", new Dictionary<string, object>() {});
        return this.parseTicker(result, market);
    }

    /**
     * @method
     * @name delta#fetchTickers
     * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
     * @see https://docs.delta.exchange/#get-tickers-for-products
     * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object response = await this.publicGetTickers(parameters);
        //
        // spot
        //
        //     {
        //         "result": [
        //             {
        //                 "close": 30634.0,
        //                 "contract_type": "spot",
        //                 "greeks": null,
        //                 "high": 30780.0,
        //                 "low": 30340.5,
        //                 "mark_price": "48000",
        //                 "oi": "0.0000",
        //                 "oi_change_usd_6h": "0.0000",
        //                 "oi_contracts": "0",
        //                 "oi_value": "0.0000",
        //                 "oi_value_symbol": "BTC",
        //                 "oi_value_usd": "0.0000",
        //                 "open": 30464.0,
        //                 "price_band": null,
        //                 "product_id": 8320,
        //                 "quotes": {},
        //                 "size": 2.6816639999999996,
        //                 "spot_price": "30637.91465121",
        //                 "symbol": "BTC_USDT",
        //                 "timestamp": 1689139767621299,
        //                 "turnover": 2.6816639999999996,
        //                 "turnover_symbol": "BTC",
        //                 "turnover_usd": 81896.45613400004,
        //                 "volume": 2.6816639999999996
        //             },
        //         ],
        //         "success":true
        //     }
        //
        // swap
        //
        //     {
        //         "result": [
        //             {
        //                 "close": 30600.5,
        //                 "contract_type": "perpetual_futures",
        //                 "funding_rate": "0.00602961",
        //                 "greeks": null,
        //                 "high": 30803.0,
        //                 "low": 30265.5,
        //                 "mark_basis": "-0.45601594",
        //                 "mark_price": "30600.10481568",
        //                 "oi": "469.9190",
        //                 "oi_change_usd_6h": "2226314.9900",
        //                 "oi_contracts": "469919",
        //                 "oi_value": "469.9190",
        //                 "oi_value_symbol": "BTC",
        //                 "oi_value_usd": "14385640.6802",
        //                 "open": 30458.5,
        //                 "price_band": {
        //                     "lower_limit": "29067.08312627",
        //                     "upper_limit": "32126.77608693"
        //                 },
        //                 "product_id": 139,
        //                 "quotes": {
        //                     "ask_iv": null,
        //                     "ask_size": "965",
        //                     "best_ask": "30600.5",
        //                     "best_bid": "30599.5",
        //                     "bid_iv": null,
        //                     "bid_size": "196",
        //                     "impact_mid_price": null,
        //                     "mark_iv": "-0.44931641"
        //                 },
        //                 "size": 1226303,
        //                 "spot_price": "30612.85362773",
        //                 "symbol": "BTCUSDT",
        //                 "timestamp": 1689136597460456,
        //                 "turnover": 37392218.45999999,
        //                 "turnover_symbol": "USDT",
        //                 "turnover_usd": 37392218.45999999,
        //                 "volume": 1226.3029999999485
        //             },
        //         ],
        //         "success":true
        //     }
        //
        // option
        //
        //     {
        //         "result": [
        //             {
        //                 "contract_type": "call_options",
        //                 "greeks": {
        //                     "delta": "0.60873994",
        //                     "gamma": "0.00014854",
        //                     "rho": "7.71808010",
        //                     "spot": "30598.49040622",
        //                     "theta": "-30.44743017",
        //                     "vega": "24.83508248"
        //                 },
        //                 "mark_price": "1347.74819696",
        //                 "mark_vol": "0.39966303",
        //                 "oi": "2.7810",
        //                 "oi_change_usd_6h": "0.0000",
        //                 "oi_contracts": "2781",
        //                 "oi_value": "2.7810",
        //                 "oi_value_symbol": "BTC",
        //                 "oi_value_usd": "85127.4337",
        //                 "price_band": {
        //                     "lower_limit": "91.27423497",
        //                     "upper_limit": "7846.19454697"
        //                 },
        //                 "product_id": 107150,
        //                 "quotes": {
        //                     "ask_iv": "0.41023239",
        //                     "ask_size": "2397",
        //                     "best_ask": "1374",
        //                     "best_bid": "1322",
        //                     "bid_iv": "0.38929375",
        //                     "bid_size": "3995",
        //                     "impact_mid_price": null,
        //                     "mark_iv": "0.39965618"
        //                 },
        //                 "spot_price": "30598.43379314",
        //                 "strike_price": "30000",
        //                 "symbol": "C-BTC-30000-280723",
        //                 "timestamp": 1689136932893181,
        //                 "turnover_symbol": "USDT"
        //             },
        //         ],
        //         "success":true
        //     }
        //
        object tickers = this.safeList(response, "result", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(tickers)); postFixIncrement(ref i))
        {
            object ticker = this.parseTicker(getValue(tickers, i));
            object symbol = getValue(ticker, "symbol");
            ((IDictionary<string,object>)result)[(string)symbol] = ticker;
        }
        return this.filterByArrayTickers(result, "symbol", symbols);
    }

    /**
     * @method
     * @name delta#fetchOrderBook
     * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://docs.delta.exchange/#get-l2-orderbook
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["depth"] = limit;
        }
        object response = await this.publicGetL2orderbookSymbol(this.extend(request, parameters));
        //
        //     {
        //         "result":{
        //             "buy":[
        //                 {"price":"15814.0","size":912},
        //                 {"price":"15813.5","size":1279},
        //                 {"price":"15813.0","size":1634},
        //             ],
        //             "sell":[
        //                 {"price":"15814.5","size":625},
        //                 {"price":"15815.0","size":982},
        //                 {"price":"15815.5","size":1328},
        //             ],
        //             "symbol":"BTCUSDT"
        //         },
        //         "success":true
        //     }
        //
        object result = this.safeDict(response, "result", new Dictionary<string, object>() {});
        return this.parseOrderBook(result, getValue(market, "symbol"), null, "buy", "sell", "price", "size");
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // public fetchTrades
        //
        //     {
        //         "buyer_role":"maker",
        //         "price":"15896.5",
        //         "seller_role":"taker",
        //         "size":241,
        //         "symbol":"BTCUSDT",
        //         "timestamp":1605376684714595
        //     }
        //
        // private fetchMyTrades
        //
        //     {
        //         "commission":"0.008335000000000000",
        //         "created_at":"2020-11-16T19:07:19Z",
        //         "fill_type":"normal",
        //         "id":"e7ff05c233a74245b72381f8dd91d1ce",
        //         "meta_data":{
        //             "effective_commission_rate":"0.0005",
        //             "order_price":"16249",
        //             "order_size":1,
        //             "order_type":"market_order",
        //             "order_unfilled_size":0,
        //             "trading_fee_credits_used":"0"
        //         },
        //         "order_id":"152999629",
        //         "price":"16669",
        //         "product":{
        //             "contract_type":"perpetual_futures",
        //             "contract_unit_currency":"BTC",
        //             "contract_value":"0.001",
        //             "id":139,
        //             "notional_type":"vanilla",
        //             "quoting_asset":{"minimum_precision":2,"precision":6,"symbol":"USDT"},
        //             "settling_asset":{"minimum_precision":2,"precision":6,"symbol":"USDT"},
        //             "symbol":"BTCUSDT",
        //             "tick_size":"0.5",
        //             "underlying_asset":{"minimum_precision":4,"precision":8,"symbol":"BTC"}
        //         },
        //         "product_id":139,
        //         "role":"taker",
        //         "side":"sell",
        //         "size":1
        //     }
        //
        object id = this.safeString(trade, "id");
        object orderId = this.safeString(trade, "order_id");
        object timestamp = this.parse8601(this.safeString(trade, "created_at"));
        timestamp = this.safeIntegerProduct(trade, "timestamp", 0.001, timestamp);
        object priceString = this.safeString(trade, "price");
        object amountString = this.safeString(trade, "size");
        object product = this.safeDict(trade, "product", new Dictionary<string, object>() {});
        object marketId = this.safeString(product, "symbol");
        object symbol = this.safeSymbol(marketId, market);
        object sellerRole = this.safeString(trade, "seller_role");
        object side = this.safeString(trade, "side");
        if (isTrue(isEqual(side, null)))
        {
            if (isTrue(isEqual(sellerRole, "taker")))
            {
                side = "sell";
            } else if (isTrue(isEqual(sellerRole, "maker")))
            {
                side = "buy";
            }
        }
        object takerOrMaker = this.safeString(trade, "role");
        object metaData = this.safeDict(trade, "meta_data", new Dictionary<string, object>() {});
        object type = this.safeString(metaData, "order_type");
        if (isTrue(!isEqual(type, null)))
        {
            type = ((string)type).Replace((string)"_order", (string)"");
        }
        object feeCostString = this.safeString(trade, "commission");
        object fee = null;
        if (isTrue(!isEqual(feeCostString, null)))
        {
            object settlingAsset = this.safeDict(product, "settling_asset", new Dictionary<string, object>() {});
            object feeCurrencyId = this.safeString(settlingAsset, "symbol");
            object feeCurrencyCode = this.safeCurrencyCode(feeCurrencyId);
            fee = new Dictionary<string, object>() {
                { "cost", feeCostString },
                { "currency", feeCurrencyCode },
            };
        }
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", id },
            { "order", orderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "type", type },
            { "side", side },
            { "price", priceString },
            { "amount", amountString },
            { "cost", null },
            { "takerOrMaker", takerOrMaker },
            { "fee", fee },
            { "info", trade },
        }, market);
    }

    /**
     * @method
     * @name delta#fetchTrades
     * @description get the list of most recent trades for a particular symbol
     * @see https://docs.delta.exchange/#get-public-trades
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch
     * @param {int} [limit] the maximum amount of trades to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.publicGetTradesSymbol(this.extend(request, parameters));
        //
        //     {
        //         "result":[
        //             {
        //                 "buyer_role":"maker",
        //                 "price":"15896.5",
        //                 "seller_role":"taker",
        //                 "size":241,
        //                 "symbol":"BTCUSDT",
        //                 "timestamp":1605376684714595
        //             }
        //         ],
        //         "success":true
        //     }
        //
        object result = this.safeList(response, "result", new List<object>() {});
        return this.parseTrades(result, market, since, limit);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     {
        //         "time":1605393120,
        //         "open":15989,
        //         "high":15989,
        //         "low":15987.5,
        //         "close":15987.5,
        //         "volume":565
        //     }
        //
        return new List<object> {this.safeTimestamp(ohlcv, "time"), this.safeNumber(ohlcv, "open"), this.safeNumber(ohlcv, "high"), this.safeNumber(ohlcv, "low"), this.safeNumber(ohlcv, "close"), this.safeNumber(ohlcv, "volume")};
    }

    /**
     * @method
     * @name delta#fetchOHLCV
     * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @see https://docs.delta.exchange/#delta-exchange-api-v2-historical-ohlc-candles-sparklines
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch
     * @param {int} [limit] the maximum amount of candles to fetch
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.until] timestamp in ms of the latest candle to fetch
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "resolution", this.safeString(this.timeframes, timeframe, timeframe) },
        };
        object duration = this.parseTimeframe(timeframe);
        limit = ((bool) isTrue(limit)) ? limit : 2000; // max 2000
        object until = this.safeIntegerProduct(parameters, "until", 0.001);
        object untilIsDefined = (!isEqual(until, null));
        if (isTrue(untilIsDefined))
        {
            until = this.parseToInt(until);
        }
        if (isTrue(isEqual(since, null)))
        {
            object end = ((bool) isTrue(untilIsDefined)) ? until : this.seconds();
            ((IDictionary<string,object>)request)["end"] = end;
            ((IDictionary<string,object>)request)["start"] = subtract(end, multiply(limit, duration));
        } else
        {
            object start = this.parseToInt(divide(since, 1000));
            ((IDictionary<string,object>)request)["start"] = start;
            ((IDictionary<string,object>)request)["end"] = ((bool) isTrue(untilIsDefined)) ? until : this.sum(start, multiply(limit, duration));
        }
        object price = this.safeString(parameters, "price");
        if (isTrue(isEqual(price, "mark")))
        {
            ((IDictionary<string,object>)request)["symbol"] = add("MARK:", getValue(market, "id"));
        } else if (isTrue(isEqual(price, "index")))
        {
            ((IDictionary<string,object>)request)["symbol"] = getValue(getValue(getValue(market, "info"), "spot_index"), "symbol");
        } else
        {
            ((IDictionary<string,object>)request)["symbol"] = getValue(market, "id");
        }
        parameters = this.omit(parameters, new List<object>() {"price", "until"});
        object response = await this.publicGetHistoryCandles(this.extend(request, parameters));
        //
        //     {
        //         "success":true,
        //         "result":[
        //             {"time":1605393120,"open":15989,"high":15989,"low":15987.5,"close":15987.5,"volume":565},
        //             {"time":1605393180,"open":15966,"high":15966,"low":15959,"close":15959,"volume":24},
        //             {"time":1605393300,"open":15973,"high":15973,"low":15973,"close":15973,"volume":1288},
        //         ]
        //     }
        //
        object result = this.safeList(response, "result", new List<object>() {});
        return this.parseOHLCVs(result, market, timeframe, since, limit);
    }

    public override object parseBalance(object response)
    {
        object balances = this.safeList(response, "result", new List<object>() {});
        object result = new Dictionary<string, object>() {
            { "info", response },
        };
        object currenciesByNumericId = this.safeDict(this.options, "currenciesByNumericId", new Dictionary<string, object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
        {
            object balance = getValue(balances, i);
            object currencyId = this.safeString(balance, "asset_id");
            object currency = this.safeDict(currenciesByNumericId, currencyId);
            object code = ((bool) isTrue((isEqual(currency, null)))) ? currencyId : getValue(currency, "code");
            object account = this.account();
            ((IDictionary<string,object>)account)["total"] = this.safeString(balance, "balance");
            ((IDictionary<string,object>)account)["free"] = this.safeString(balance, "available_balance");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    /**
     * @method
     * @name delta#fetchBalance
     * @description query for balance and get the amount of funds available for trading or funds locked in orders
     * @see https://docs.delta.exchange/#get-wallet-balances
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> fetchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetWalletBalances(parameters);
        //
        //     {
        //         "result":[
        //             {
        //                 "asset_id":1,
        //                 "available_balance":"0",
        //                 "balance":"0",
        //                 "commission":"0",
        //                 "id":154883,
        //                 "interest_credit":"0",
        //                 "order_margin":"0",
        //                 "pending_referral_bonus":"0",
        //                 "pending_trading_fee_credit":"0",
        //                 "position_margin":"0",
        //                 "trading_fee_credit":"0",
        //                 "user_id":22142
        //             },
        //         ],
        //         "success":true
        //     }
        //
        return this.parseBalance(response);
    }

    /**
     * @method
     * @name delta#fetchPosition
     * @description fetch data on a single open contract trade position
     * @see https://docs.delta.exchange/#get-position
     * @param {string} symbol unified market symbol of the market the position is held in, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public async override Task<object> fetchPosition(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "product_id", getValue(market, "numericId") },
        };
        object response = await this.privateGetPositions(this.extend(request, parameters));
        //
        //     {
        //         "result":{
        //             "entry_price":null,
        //             "size":0,
        //             "timestamp":1605454074268079
        //         },
        //         "success":true
        //     }
        //
        object result = this.safeDict(response, "result", new Dictionary<string, object>() {});
        return this.parsePosition(result, market);
    }

    /**
     * @method
     * @name delta#fetchPositions
     * @description fetch all open positions
     * @see https://docs.delta.exchange/#get-margined-positions
     * @param {string[]|undefined} symbols list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetPositionsMargined(parameters);
        //
        //     {
        //         "success": true,
        //         "result": [
        //           {
        //             "user_id": 0,
        //             "size": 0,
        //             "entry_price": "string",
        //             "margin": "string",
        //             "liquidation_price": "string",
        //             "bankruptcy_price": "string",
        //             "adl_level": 0,
        //             "product_id": 0,
        //             "product_symbol": "string",
        //             "commission": "string",
        //             "realized_pnl": "string",
        //             "realized_funding": "string"
        //           }
        //         ]
        //     }
        //
        object result = this.safeList(response, "result", new List<object>() {});
        return this.parsePositions(result, symbols);
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        // fetchPosition
        //
        //     {
        //         "entry_price":null,
        //         "size":0,
        //         "timestamp":1605454074268079
        //     }
        //
        //
        // fetchPositions
        //
        //     {
        //         "user_id": 0,
        //         "size": 0,
        //         "entry_price": "string",
        //         "margin": "string",
        //         "liquidation_price": "string",
        //         "bankruptcy_price": "string",
        //         "adl_level": 0,
        //         "product_id": 0,
        //         "product_symbol": "string",
        //         "commission": "string",
        //         "realized_pnl": "string",
        //         "realized_funding": "string"
        //     }
        //
        object marketId = this.safeString(position, "product_symbol");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object timestamp = this.safeIntegerProduct(position, "timestamp", 0.001);
        object sizeString = this.safeString(position, "size");
        object side = null;
        if (isTrue(!isEqual(sizeString, null)))
        {
            if (isTrue(Precise.stringGt(sizeString, "0")))
            {
                side = "buy";
            } else if (isTrue(Precise.stringLt(sizeString, "0")))
            {
                side = "sell";
            }
        }
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", null },
            { "symbol", symbol },
            { "notional", null },
            { "marginMode", null },
            { "liquidationPrice", this.safeNumber(position, "liquidation_price") },
            { "entryPrice", this.safeNumber(position, "entry_price") },
            { "unrealizedPnl", null },
            { "percentage", null },
            { "contracts", this.parseNumber(sizeString) },
            { "contractSize", this.safeNumber(market, "contractSize") },
            { "markPrice", null },
            { "side", side },
            { "hedged", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "maintenanceMargin", null },
            { "maintenanceMarginPercentage", null },
            { "collateral", null },
            { "initialMargin", null },
            { "initialMarginPercentage", null },
            { "leverage", null },
            { "marginRatio", null },
            { "stopLossPrice", null },
            { "takeProfitPrice", null },
        });
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "open", "open" },
            { "pending", "open" },
            { "closed", "closed" },
            { "cancelled", "canceled" },
        };
        return this.safeString(statuses, status, status);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // createOrder, cancelOrder, editOrder, fetchOpenOrders, fetchClosedOrders
        //
        //     {
        //         "average_fill_price":null,
        //         "bracket_order":null,
        //         "bracket_stop_loss_limit_price":null,
        //         "bracket_stop_loss_price":null,
        //         "bracket_take_profit_limit_price":null,
        //         "bracket_take_profit_price":null,
        //         "bracket_trail_amount":null,
        //         "cancellation_reason":null,
        //         "client_order_id":null,
        //         "close_on_trigger":"false",
        //         "commission":"0",
        //         "created_at":"2020-11-16T02:38:26Z",
        //         "id":152870626,
        //         "limit_price":"10000",
        //         "meta_data":{"source":"api"},
        //         "order_type":"limit_order",
        //         "paid_commission":"0",
        //         "product_id":139,
        //         "reduce_only":false,
        //         "side":"buy",
        //         "size":0,
        //         "state":"open",
        //         "stop_order_type":null,
        //         "stop_price":null,
        //         "stop_trigger_method":"mark_price",
        //         "time_in_force":"gtc",
        //         "trail_amount":null,
        //         "unfilled_size":0,
        //         "user_id":22142
        //     }
        //
        object id = this.safeString(order, "id");
        object clientOrderId = this.safeString(order, "client_order_id");
        object timestamp = this.parse8601(this.safeString(order, "created_at"));
        object marketId = this.safeString(order, "product_id");
        object marketsByNumericId = this.safeDict(this.options, "marketsByNumericId", new Dictionary<string, object>() {});
        market = this.safeValue(marketsByNumericId, marketId, market);
        object symbol = ((bool) isTrue((isEqual(market, null)))) ? marketId : getValue(market, "symbol");
        object status = this.parseOrderStatus(this.safeString(order, "state"));
        object side = this.safeString(order, "side");
        object type = this.safeString(order, "order_type");
        type = ((string)type).Replace((string)"_order", (string)"");
        object price = this.safeString(order, "limit_price");
        object amount = this.safeString(order, "size");
        object remaining = this.safeString(order, "unfilled_size");
        object average = this.safeString(order, "average_fill_price");
        object fee = null;
        object feeCostString = this.safeString(order, "paid_commission");
        if (isTrue(!isEqual(feeCostString, null)))
        {
            object feeCurrencyCode = null;
            if (isTrue(!isEqual(market, null)))
            {
                object settlingAsset = this.safeDict(getValue(market, "info"), "settling_asset", new Dictionary<string, object>() {});
                object feeCurrencyId = this.safeString(settlingAsset, "symbol");
                feeCurrencyCode = this.safeCurrencyCode(feeCurrencyId);
            }
            fee = new Dictionary<string, object>() {
                { "cost", feeCostString },
                { "currency", feeCurrencyCode },
            };
        }
        return this.safeOrder(new Dictionary<string, object>() {
            { "info", order },
            { "id", id },
            { "clientOrderId", clientOrderId },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", null },
            { "symbol", symbol },
            { "type", type },
            { "side", side },
            { "price", price },
            { "amount", amount },
            { "cost", null },
            { "average", average },
            { "filled", null },
            { "remaining", remaining },
            { "status", status },
            { "fee", fee },
            { "trades", null },
        }, market);
    }

    /**
     * @method
     * @name delta#createOrder
     * @description create a trade order
     * @see https://docs.delta.exchange/#place-order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of currency you want to trade in units of base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {bool} [params.reduceOnly] *contract only* indicates if this order is to reduce the size of a position
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object orderType = add(type, "_order");
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "product_id", getValue(market, "numericId") },
            { "size", this.amountToPrecision(getValue(market, "symbol"), amount) },
            { "side", side },
            { "order_type", orderType },
        };
        if (isTrue(isEqual(type, "limit")))
        {
            ((IDictionary<string,object>)request)["limit_price"] = this.priceToPrecision(getValue(market, "symbol"), price);
        }
        object clientOrderId = this.safeString2(parameters, "clientOrderId", "client_order_id");
        parameters = this.omit(parameters, new List<object>() {"clientOrderId", "client_order_id"});
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)request)["client_order_id"] = clientOrderId;
        }
        object reduceOnly = this.safeBool(parameters, "reduceOnly");
        if (isTrue(reduceOnly))
        {
            ((IDictionary<string,object>)request)["reduce_only"] = reduceOnly;
            parameters = this.omit(parameters, "reduceOnly");
        }
        object response = await this.privatePostOrders(this.extend(request, parameters));
        //
        //     {
        //         "result":{
        //             "average_fill_price":null,
        //             "bracket_order":null,
        //             "bracket_stop_loss_limit_price":null,
        //             "bracket_stop_loss_price":null,
        //             "bracket_take_profit_limit_price":null,
        //             "bracket_take_profit_price":null,
        //             "bracket_trail_amount":null,
        //             "cancellation_reason":null,
        //             "client_order_id":null,
        //             "close_on_trigger":"false",
        //             "commission":"0",
        //             "created_at":"2020-11-16T02:38:26Z",
        //             "id":152870626,
        //             "limit_price":"10000",
        //             "meta_data":{"source":"api"},
        //             "order_type":"limit_order",
        //             "paid_commission":"0",
        //             "product_id":139,
        //             "reduce_only":false,
        //             "side":"buy",
        //             "size":0,
        //             "state":"open",
        //             "stop_order_type":null,
        //             "stop_price":null,
        //             "stop_trigger_method":"mark_price",
        //             "time_in_force":"gtc",
        //             "trail_amount":null,
        //             "unfilled_size":0,
        //             "user_id":22142
        //         },
        //         "success":true
        //     }
        //
        object result = this.safeDict(response, "result", new Dictionary<string, object>() {});
        return this.parseOrder(result, market);
    }

    /**
     * @method
     * @name delta#editOrder
     * @description edit a trade order
     * @see https://docs.delta.exchange/#edit-order
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market' or 'limit'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of the currency you want to trade in units of the base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> editOrder(object id, object symbol, object type, object side, object amount = null, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "id", parseInt(id) },
            { "product_id", getValue(market, "numericId") },
        };
        if (isTrue(!isEqual(amount, null)))
        {
            ((IDictionary<string,object>)request)["size"] = parseInt(this.amountToPrecision(symbol, amount));
        }
        if (isTrue(!isEqual(price, null)))
        {
            ((IDictionary<string,object>)request)["limit_price"] = this.priceToPrecision(symbol, price);
        }
        object response = await this.privatePutOrders(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "result": {
        //             "id": "ashb1212",
        //             "product_id": 27,
        //             "limit_price": "9200",
        //             "side": "buy",
        //             "size": 100,
        //             "unfilled_size": 50,
        //             "user_id": 1,
        //             "order_type": "limit_order",
        //             "state": "open",
        //             "created_at": "..."
        //         }
        //     }
        //
        object result = this.safeDict(response, "result");
        return this.parseOrder(result, market);
    }

    /**
     * @method
     * @name delta#cancelOrder
     * @description cancels an open order
     * @see https://docs.delta.exchange/#cancel-order
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrder() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "id", parseInt(id) },
            { "product_id", getValue(market, "numericId") },
        };
        object response = await this.privateDeleteOrders(this.extend(request, parameters));
        //
        //     {
        //         "result":{
        //             "average_fill_price":null,
        //             "bracket_order":null,
        //             "bracket_stop_loss_limit_price":null,
        //             "bracket_stop_loss_price":null,
        //             "bracket_take_profit_limit_price":null,
        //             "bracket_take_profit_price":null,
        //             "bracket_trail_amount":null,
        //             "cancellation_reason":"cancelled_by_user",
        //             "client_order_id":null,
        //             "close_on_trigger":"false",
        //             "commission":"0",
        //             "created_at":"2020-11-16T02:38:26Z",
        //             "id":152870626,
        //             "limit_price":"10000",
        //             "meta_data":{"source":"api"},
        //             "order_type":"limit_order",
        //             "paid_commission":"0",
        //             "product_id":139,
        //             "reduce_only":false,
        //             "side":"buy",
        //             "size":0,
        //             "state":"cancelled",
        //             "stop_order_type":null,
        //             "stop_price":null,
        //             "stop_trigger_method":"mark_price",
        //             "time_in_force":"gtc",
        //             "trail_amount":null,
        //             "unfilled_size":0,
        //             "user_id":22142
        //         },
        //         "success":true
        //     }
        //
        object result = this.safeDict(response, "result");
        return this.parseOrder(result, market);
    }

    /**
     * @method
     * @name delta#cancelAllOrders
     * @description cancel all open orders in a market
     * @see https://docs.delta.exchange/#cancel-all-open-orders
     * @param {string} symbol unified market symbol of the market to cancel orders in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelAllOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "product_id", getValue(market, "numericId") },
        };
        object response = this.privateDeleteOrdersAll(this.extend(request, parameters));
        //
        //     {
        //         "result":{},
        //         "success":true
        //     }
        //
        return new List<object> {this.safeOrder(new Dictionary<string, object>() {
    { "info", response },
})};
    }

    /**
     * @method
     * @name delta#fetchOpenOrders
     * @description fetch all unfilled currently open orders
     * @see https://docs.delta.exchange/#get-active-orders
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch open orders for
     * @param {int} [limit] the maximum number of open order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.fetchOrdersWithMethod("privateGetOrders", symbol, since, limit, parameters);
    }

    /**
     * @method
     * @name delta#fetchClosedOrders
     * @description fetches information on multiple closed orders made by the user
     * @see https://docs.delta.exchange/#get-order-history-cancelled-and-closed
     * @param {string} symbol unified market symbol of the market orders were made in
     * @param {int} [since] the earliest time in ms to fetch orders for
     * @param {int} [limit] the maximum number of order structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchClosedOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.fetchOrdersWithMethod("privateGetOrdersHistory", symbol, since, limit, parameters);
    }

    public async virtual Task<object> fetchOrdersWithMethod(object method, object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["product_ids"] = getValue(market, "numericId"); // accepts a comma-separated list of ids
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_time"] = add(((object)since).ToString(), "000");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["page_size"] = limit;
        }
        object response = null;
        if (isTrue(isEqual(method, "privateGetOrders")))
        {
            response = await this.privateGetOrders(this.extend(request, parameters));
        } else if (isTrue(isEqual(method, "privateGetOrdersHistory")))
        {
            response = await this.privateGetOrdersHistory(this.extend(request, parameters));
        }
        //
        //     {
        //         "success": true,
        //         "result": [
        //             {
        //                 "id": "ashb1212",
        //                 "product_id": 27,
        //                 "limit_price": "9200",
        //                 "side": "buy",
        //                 "size": 100,
        //                 "unfilled_size": 50,
        //                 "user_id": 1,
        //                 "order_type": "limit_order",
        //                 "state": "open",
        //                 "created_at": "..."
        //             }
        //         ],
        //         "meta": {
        //             "after": "string",
        //             "before": "string"
        //         }
        //     }
        //
        object result = this.safeList(response, "result", new List<object>() {});
        return this.parseOrders(result, market, since, limit);
    }

    /**
     * @method
     * @name delta#fetchMyTrades
     * @description fetch all trades made by the user
     * @see https://docs.delta.exchange/#get-user-fills-by-filters
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum number of trades structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=trade-structure}
     */
    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["product_ids"] = getValue(market, "numericId"); // accepts a comma-separated list of ids
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["start_time"] = add(((object)since).ToString(), "000");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["page_size"] = limit;
        }
        object response = await this.privateGetFills(this.extend(request, parameters));
        //
        //     {
        //         "meta":{
        //             "after":null,
        //             "before":null,
        //             "limit":10,
        //             "total_count":2
        //         },
        //         "result":[
        //             {
        //                 "commission":"0.008335000000000000",
        //                 "created_at":"2020-11-16T19:07:19Z",
        //                 "fill_type":"normal",
        //                 "id":"e7ff05c233a74245b72381f8dd91d1ce",
        //                 "meta_data":{
        //                     "effective_commission_rate":"0.0005",
        //                     "order_price":"16249",
        //                     "order_size":1,
        //                     "order_type":"market_order",
        //                     "order_unfilled_size":0,
        //                     "trading_fee_credits_used":"0"
        //                 },
        //                 "order_id":"152999629",
        //                 "price":"16669",
        //                 "product":{
        //                     "contract_type":"perpetual_futures",
        //                     "contract_unit_currency":"BTC",
        //                     "contract_value":"0.001",
        //                     "id":139,
        //                     "notional_type":"vanilla",
        //                     "quoting_asset":{"minimum_precision":2,"precision":6,"symbol":"USDT"},
        //                     "settling_asset":{"minimum_precision":2,"precision":6,"symbol":"USDT"},
        //                     "symbol":"BTCUSDT",
        //                     "tick_size":"0.5",
        //                     "underlying_asset":{"minimum_precision":4,"precision":8,"symbol":"BTC"}
        //                 },
        //                 "product_id":139,
        //                 "role":"taker",
        //                 "side":"sell",
        //                 "size":1
        //             }
        //         ],
        //         "success":true
        //     }
        //
        object result = this.safeList(response, "result", new List<object>() {});
        return this.parseTrades(result, market, since, limit);
    }

    /**
     * @method
     * @name delta#fetchLedger
     * @description fetch the history of changes, actions done by the user or operations that altered the balance of the user
     * @see https://docs.delta.exchange/#get-wallet-transactions
     * @param {string} [code] unified currency code, default is undefined
     * @param {int} [since] timestamp in ms of the earliest ledger entry, default is undefined
     * @param {int} [limit] max number of ledger entries to return, default is undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ledger structure]{@link https://docs.ccxt.com/#/?id=ledger}
     */
    public async override Task<object> fetchLedger(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["asset_id"] = getValue(currency, "numericId");
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["page_size"] = limit;
        }
        object response = await this.privateGetWalletTransactions(this.extend(request, parameters));
        //
        //     {
        //         "meta":{"after":null,"before":null,"limit":10,"total_count":1},
        //         "result":[
        //             {
        //                 "amount":"29.889184",
        //                 "asset_id":5,
        //                 "balance":"29.889184",
        //                 "created_at":"2020-11-15T21:25:01Z",
        //                 "meta_data":{
        //                     "deposit_id":3884,
        //                     "transaction_id":"0x41a60174849828530abb5008e98fc63c9b598288743ec4ba9620bcce900a3b8d"
        //                 },
        //                 "transaction_type":"deposit",
        //                 "user_id":22142,
        //                 "uuid":"70bb5679da3c4637884e2dc63efaa846"
        //             }
        //         ],
        //         "success":true
        //     }
        //
        object result = this.safeList(response, "result", new List<object>() {});
        return this.parseLedger(result, currency, since, limit);
    }

    public virtual object parseLedgerEntryType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "pnl", "pnl" },
            { "deposit", "transaction" },
            { "withdrawal", "transaction" },
            { "commission", "fee" },
            { "conversion", "trade" },
            { "referral_bonus", "referral" },
            { "commission_rebate", "rebate" },
        };
        return this.safeString(types, type, type);
    }

    public override object parseLedgerEntry(object item, object currency = null)
    {
        //
        //     {
        //         "amount":"29.889184",
        //         "asset_id":5,
        //         "balance":"29.889184",
        //         "created_at":"2020-11-15T21:25:01Z",
        //         "meta_data":{
        //             "deposit_id":3884,
        //             "transaction_id":"0x41a60174849828530abb5008e98fc63c9b598288743ec4ba9620bcce900a3b8d"
        //         },
        //         "transaction_type":"deposit",
        //         "user_id":22142,
        //         "uuid":"70bb5679da3c4637884e2dc63efaa846"
        //     }
        //
        object id = this.safeString(item, "uuid");
        object direction = null;
        object account = null;
        object metaData = this.safeDict(item, "meta_data", new Dictionary<string, object>() {});
        object referenceId = this.safeString(metaData, "transaction_id");
        object referenceAccount = null;
        object type = this.safeString(item, "transaction_type");
        if (isTrue(isTrue(isTrue(isTrue(isTrue(isTrue((isEqual(type, "deposit"))) || isTrue((isEqual(type, "commission_rebate")))) || isTrue((isEqual(type, "referral_bonus")))) || isTrue((isEqual(type, "pnl")))) || isTrue((isEqual(type, "withdrawal_cancellation")))) || isTrue((isEqual(type, "promo_credit")))))
        {
            direction = "in";
        } else if (isTrue(isTrue(isTrue(isTrue((isEqual(type, "withdrawal"))) || isTrue((isEqual(type, "commission")))) || isTrue((isEqual(type, "conversion")))) || isTrue((isEqual(type, "perpetual_futures_funding")))))
        {
            direction = "out";
        }
        type = this.parseLedgerEntryType(type);
        object currencyId = this.safeString(item, "asset_id");
        object currenciesByNumericId = this.safeDict(this.options, "currenciesByNumericId");
        currency = this.safeValue(currenciesByNumericId, currencyId, currency);
        object code = ((bool) isTrue((isEqual(currency, null)))) ? null : getValue(currency, "code");
        object amount = this.safeString(item, "amount");
        object timestamp = this.parse8601(this.safeString(item, "created_at"));
        object after = this.safeString(item, "balance");
        object before = Precise.stringMax("0", Precise.stringSub(after, amount));
        object status = "ok";
        return this.safeLedgerEntry(new Dictionary<string, object>() {
            { "info", item },
            { "id", id },
            { "direction", direction },
            { "account", account },
            { "referenceId", referenceId },
            { "referenceAccount", referenceAccount },
            { "type", type },
            { "currency", code },
            { "amount", this.parseNumber(amount) },
            { "before", this.parseNumber(before) },
            { "after", this.parseNumber(after) },
            { "status", status },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "fee", null },
        }, currency);
    }

    /**
     * @method
     * @name delta#fetchDepositAddress
     * @description fetch the deposit address for a currency associated with this account
     * @param {string} code unified currency code
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.network] unified network code
     * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
     */
    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "asset_symbol", getValue(currency, "id") },
        };
        object networkCode = this.safeStringUpper(parameters, "network");
        if (isTrue(!isEqual(networkCode, null)))
        {
            ((IDictionary<string,object>)request)["network"] = this.networkCodeToId(networkCode, code);
            parameters = this.omit(parameters, "network");
        }
        object response = await this.privateGetDepositsAddress(this.extend(request, parameters));
        //
        //    {
        //        "success": true,
        //        "result": {
        //            "id": 1915615,
        //            "user_id": 27854758,
        //            "address": "TXYB4GdKsXKEWbeSNPsmGZu4ZVCkhVh1Zz",
        //            "memo": "",
        //            "status": "active",
        //            "updated_at": "2023-01-12T06:03:46.000Z",
        //            "created_at": "2023-01-12T06:03:46.000Z",
        //            "asset_symbol": "USDT",
        //            "network": "TRC20(TRON)",
        //            "custodian": "fireblocks"
        //        }
        //    }
        //
        object result = this.safeDict(response, "result", new Dictionary<string, object>() {});
        return this.parseDepositAddress(result, currency);
    }

    public override object parseDepositAddress(object depositAddress, object currency = null)
    {
        //
        //    {
        //        "id": 1915615,
        //        "user_id": 27854758,
        //        "address": "TXYB4GdKsXKEWbeSNPsmGZu4ZVCkhVh1Zz",
        //        "memo": "",
        //        "status": "active",
        //        "updated_at": "2023-01-12T06:03:46.000Z",
        //        "created_at": "2023-01-12T06:03:46.000Z",
        //        "asset_symbol": "USDT",
        //        "network": "TRC20(TRON)",
        //        "custodian": "fireblocks"
        //    }
        //
        object address = this.safeString(depositAddress, "address");
        object marketId = this.safeString(depositAddress, "asset_symbol");
        object networkId = this.safeString(depositAddress, "network");
        this.checkAddress(address);
        return new Dictionary<string, object>() {
            { "info", depositAddress },
            { "currency", this.safeCurrencyCode(marketId, currency) },
            { "network", this.networkIdToCode(networkId) },
            { "address", address },
            { "tag", this.safeString(depositAddress, "memo") },
        };
    }

    /**
     * @method
     * @name delta#fetchFundingRate
     * @description fetch the current funding rate
     * @see https://docs.delta.exchange/#get-ticker-for-a-product-by-symbol
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [funding rate structure]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
     */
    public async override Task<object> fetchFundingRate(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "swap")))
        {
            throw new BadSymbol ((string)add(this.id, " fetchFundingRate() supports swap contracts only")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.publicGetTickersSymbol(this.extend(request, parameters));
        //
        //     {
        //         "result": {
        //             "close": 30600.5,
        //             "contract_type": "perpetual_futures",
        //             "funding_rate": "0.00602961",
        //             "greeks": null,
        //             "high": 30803.0,
        //             "low": 30265.5,
        //             "mark_basis": "-0.45601594",
        //             "mark_price": "30600.10481568",
        //             "oi": "469.9190",
        //             "oi_change_usd_6h": "2226314.9900",
        //             "oi_contracts": "469919",
        //             "oi_value": "469.9190",
        //             "oi_value_symbol": "BTC",
        //             "oi_value_usd": "14385640.6802",
        //             "open": 30458.5,
        //             "price_band": {
        //                 "lower_limit": "29067.08312627",
        //                 "upper_limit": "32126.77608693"
        //             },
        //             "product_id": 139,
        //             "quotes": {
        //                 "ask_iv": null,
        //                 "ask_size": "965",
        //                 "best_ask": "30600.5",
        //                 "best_bid": "30599.5",
        //                 "bid_iv": null,
        //                 "bid_size": "196",
        //                 "impact_mid_price": null,
        //                 "mark_iv": "-0.44931641"
        //             },
        //             "size": 1226303,
        //             "spot_price": "30612.85362773",
        //             "symbol": "BTCUSDT",
        //             "timestamp": 1689136597460456,
        //             "turnover": 37392218.45999999,
        //             "turnover_symbol": "USDT",
        //             "turnover_usd": 37392218.45999999,
        //             "volume": 1226.3029999999485
        //         },
        //         "success": true
        //     }
        //
        object result = this.safeDict(response, "result", new Dictionary<string, object>() {});
        return this.parseFundingRate(result, market);
    }

    /**
     * @method
     * @name delta#fetchFundingRates
     * @description fetch the funding rate for multiple markets
     * @see https://docs.delta.exchange/#get-tickers-for-products
     * @param {string[]|undefined} symbols list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} a list of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rates-structure}, indexed by market symbols
     */
    public async override Task<object> fetchFundingRates(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object request = new Dictionary<string, object>() {
            { "contract_types", "perpetual_futures" },
        };
        object response = await this.publicGetTickers(this.extend(request, parameters));
        //
        //     {
        //         "result": [
        //             {
        //                 "close": 30600.5,
        //                 "contract_type": "perpetual_futures",
        //                 "funding_rate": "0.00602961",
        //                 "greeks": null,
        //                 "high": 30803.0,
        //                 "low": 30265.5,
        //                 "mark_basis": "-0.45601594",
        //                 "mark_price": "30600.10481568",
        //                 "oi": "469.9190",
        //                 "oi_change_usd_6h": "2226314.9900",
        //                 "oi_contracts": "469919",
        //                 "oi_value": "469.9190",
        //                 "oi_value_symbol": "BTC",
        //                 "oi_value_usd": "14385640.6802",
        //                 "open": 30458.5,
        //                 "price_band": {
        //                     "lower_limit": "29067.08312627",
        //                     "upper_limit": "32126.77608693"
        //                 },
        //                 "product_id": 139,
        //                 "quotes": {
        //                     "ask_iv": null,
        //                     "ask_size": "965",
        //                     "best_ask": "30600.5",
        //                     "best_bid": "30599.5",
        //                     "bid_iv": null,
        //                     "bid_size": "196",
        //                     "impact_mid_price": null,
        //                     "mark_iv": "-0.44931641"
        //                 },
        //                 "size": 1226303,
        //                 "spot_price": "30612.85362773",
        //                 "symbol": "BTCUSDT",
        //                 "timestamp": 1689136597460456,
        //                 "turnover": 37392218.45999999,
        //                 "turnover_symbol": "USDT",
        //                 "turnover_usd": 37392218.45999999,
        //                 "volume": 1226.3029999999485
        //             },
        //         ],
        //         "success":true
        //     }
        //
        object rates = this.safeList(response, "result", new List<object>() {});
        object result = this.parseFundingRates(rates);
        return this.filterByArray(result, "symbol", symbols);
    }

    public override object parseFundingRate(object contract, object market = null)
    {
        //
        //     {
        //         "close": 30600.5,
        //         "contract_type": "perpetual_futures",
        //         "funding_rate": "0.00602961",
        //         "greeks": null,
        //         "high": 30803.0,
        //         "low": 30265.5,
        //         "mark_basis": "-0.45601594",
        //         "mark_price": "30600.10481568",
        //         "oi": "469.9190",
        //         "oi_change_usd_6h": "2226314.9900",
        //         "oi_contracts": "469919",
        //         "oi_value": "469.9190",
        //         "oi_value_symbol": "BTC",
        //         "oi_value_usd": "14385640.6802",
        //         "open": 30458.5,
        //         "price_band": {
        //             "lower_limit": "29067.08312627",
        //             "upper_limit": "32126.77608693"
        //         },
        //         "product_id": 139,
        //         "quotes": {
        //             "ask_iv": null,
        //             "ask_size": "965",
        //             "best_ask": "30600.5",
        //             "best_bid": "30599.5",
        //             "bid_iv": null,
        //             "bid_size": "196",
        //             "impact_mid_price": null,
        //             "mark_iv": "-0.44931641"
        //         },
        //         "size": 1226303,
        //         "spot_price": "30612.85362773",
        //         "symbol": "BTCUSDT",
        //         "timestamp": 1689136597460456,
        //         "turnover": 37392218.45999999,
        //         "turnover_symbol": "USDT",
        //         "turnover_usd": 37392218.45999999,
        //         "volume": 1226.3029999999485
        //     }
        //
        object timestamp = this.safeIntegerProduct(contract, "timestamp", 0.001);
        object marketId = this.safeString(contract, "symbol");
        object fundingRateString = this.safeString(contract, "funding_rate");
        object fundingRate = Precise.stringDiv(fundingRateString, "100");
        return new Dictionary<string, object>() {
            { "info", contract },
            { "symbol", this.safeSymbol(marketId, market) },
            { "markPrice", this.safeNumber(contract, "mark_price") },
            { "indexPrice", this.safeNumber(contract, "spot_price") },
            { "interestRate", null },
            { "estimatedSettlePrice", null },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "fundingRate", this.parseNumber(fundingRate) },
            { "fundingTimestamp", null },
            { "fundingDatetime", null },
            { "nextFundingRate", null },
            { "nextFundingTimestamp", null },
            { "nextFundingDatetime", null },
            { "previousFundingRate", null },
            { "previousFundingTimestamp", null },
            { "previousFundingDatetime", null },
            { "interval", null },
        };
    }

    /**
     * @method
     * @name delta#addMargin
     * @description add margin
     * @see https://docs.delta.exchange/#add-remove-position-margin
     * @param {string} symbol unified market symbol
     * @param {float} amount amount of margin to add
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=add-margin-structure}
     */
    public async override Task<object> addMargin(object symbol, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.modifyMarginHelper(symbol, amount, "add", parameters);
    }

    /**
     * @method
     * @name delta#reduceMargin
     * @description remove margin from a position
     * @see https://docs.delta.exchange/#add-remove-position-margin
     * @param {string} symbol unified market symbol
     * @param {float} amount the amount of margin to remove
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [margin structure]{@link https://docs.ccxt.com/#/?id=reduce-margin-structure}
     */
    public async override Task<object> reduceMargin(object symbol, object amount, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        return await this.modifyMarginHelper(symbol, amount, "reduce", parameters);
    }

    public async virtual Task<object> modifyMarginHelper(object symbol, object amount, object type, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        amount = ((object)amount).ToString();
        if (isTrue(isEqual(type, "reduce")))
        {
            amount = Precise.stringMul(amount, "-1");
        }
        object request = new Dictionary<string, object>() {
            { "product_id", getValue(market, "numericId") },
            { "delta_margin", amount },
        };
        object response = await this.privatePostPositionsChangeMargin(this.extend(request, parameters));
        //
        //     {
        //         "result": {
        //             "auto_topup": false,
        //             "bankruptcy_price": "24934.12",
        //             "commission": "0.01197072",
        //             "created_at": "2023-07-20T03:49:09.159401Z",
        //             "entry_price": "29926.8",
        //             "liquidation_price": "25083.754",
        //             "margin": "4.99268",
        //             "margin_mode": "isolated",
        //             "product_id": 84,
        //             "product_symbol": "BTCUSDT",
        //             "realized_cashflow": "0",
        //             "realized_funding": "0",
        //             "realized_pnl": "0",
        //             "size": 1,
        //             "updated_at": "2023-07-20T03:49:09.159401Z",
        //             "user_id": 30084879
        //         },
        //         "success": true
        //     }
        //
        object result = this.safeDict(response, "result", new Dictionary<string, object>() {});
        return this.parseMarginModification(result, market);
    }

    public override object parseMarginModification(object data, object market = null)
    {
        //
        //     {
        //         "auto_topup": false,
        //         "bankruptcy_price": "24934.12",
        //         "commission": "0.01197072",
        //         "created_at": "2023-07-20T03:49:09.159401Z",
        //         "entry_price": "29926.8",
        //         "liquidation_price": "25083.754",
        //         "margin": "4.99268",
        //         "margin_mode": "isolated",
        //         "product_id": 84,
        //         "product_symbol": "BTCUSDT",
        //         "realized_cashflow": "0",
        //         "realized_funding": "0",
        //         "realized_pnl": "0",
        //         "size": 1,
        //         "updated_at": "2023-07-20T03:49:09.159401Z",
        //         "user_id": 30084879
        //     }
        //
        object marketId = this.safeString(data, "product_symbol");
        market = this.safeMarket(marketId, market);
        return new Dictionary<string, object>() {
            { "info", data },
            { "symbol", getValue(market, "symbol") },
            { "type", null },
            { "marginMode", "isolated" },
            { "amount", null },
            { "total", this.safeNumber(data, "margin") },
            { "code", null },
            { "status", null },
            { "timestamp", null },
            { "datetime", null },
        };
    }

    /**
     * @method
     * @name delta#fetchOpenInterest
     * @description retrieves the open interest of a derivative market
     * @see https://docs.delta.exchange/#get-ticker-for-a-product-by-symbol
     * @param {string} symbol unified market symbol
     * @param {object} [params] exchange specific parameters
     * @returns {object} an open interest structure{@link https://docs.ccxt.com/#/?id=open-interest-structure}
     */
    public async override Task<object> fetchOpenInterest(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "contract")))
        {
            throw new BadRequest ((string)add(this.id, " fetchOpenInterest() supports contract markets only")) ;
        }
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.publicGetTickersSymbol(this.extend(request, parameters));
        //
        //     {
        //         "result": {
        //             "close": 894.0,
        //             "contract_type": "call_options",
        //             "greeks": {
        //                 "delta": "0.67324861",
        //                 "gamma": "0.00022178",
        //                 "rho": "4.34638266",
        //                 "spot": "30178.53195697",
        //                 "theta": "-35.64972577",
        //                 "vega": "16.34381277"
        //             },
        //             "high": 946.0,
        //             "low": 893.0,
        //             "mark_price": "1037.07582681",
        //             "mark_vol": "0.35899491",
        //             "oi": "0.0910",
        //             "oi_change_usd_6h": "-90.5500",
        //             "oi_contracts": "91",
        //             "oi_value": "0.0910",
        //             "oi_value_symbol": "BTC",
        //             "oi_value_usd": "2746.3549",
        //             "open": 946.0,
        //             "price_band": {
        //                 "lower_limit": "133.37794509",
        //                 "upper_limit": "5663.66930164"
        //             },
        //             "product_id": 116171,
        //             "quotes": {
        //                 "ask_iv": "0.36932389",
        //                 "ask_size": "1321",
        //                 "best_ask": "1054",
        //                 "best_bid": "1020",
        //                 "bid_iv": "0.34851914",
        //                 "bid_size": "2202",
        //                 "impact_mid_price": null,
        //                 "mark_iv": "0.35896335"
        //             },
        //             "size": 152,
        //             "spot_price": "30178.53195697",
        //             "strike_price": "29500",
        //             "symbol": "C-BTC-29500-280723",
        //             "timestamp": 1689834695286094,
        //             "turnover": 4546.601744940001,
        //             "turnover_symbol": "USDT",
        //             "turnover_usd": 4546.601744940001,
        //             "volume": 0.15200000000000002
        //         },
        //         "success": true
        //     }
        //
        object result = this.safeDict(response, "result", new Dictionary<string, object>() {});
        return this.parseOpenInterest(result, market);
    }

    public override object parseOpenInterest(object interest, object market = null)
    {
        //
        //     {
        //         "close": 894.0,
        //         "contract_type": "call_options",
        //         "greeks": {
        //             "delta": "0.67324861",
        //             "gamma": "0.00022178",
        //             "rho": "4.34638266",
        //             "spot": "30178.53195697",
        //             "theta": "-35.64972577",
        //             "vega": "16.34381277"
        //         },
        //         "high": 946.0,
        //         "low": 893.0,
        //         "mark_price": "1037.07582681",
        //         "mark_vol": "0.35899491",
        //         "oi": "0.0910",
        //         "oi_change_usd_6h": "-90.5500",
        //         "oi_contracts": "91",
        //         "oi_value": "0.0910",
        //         "oi_value_symbol": "BTC",
        //         "oi_value_usd": "2746.3549",
        //         "open": 946.0,
        //         "price_band": {
        //             "lower_limit": "133.37794509",
        //             "upper_limit": "5663.66930164"
        //         },
        //         "product_id": 116171,
        //         "quotes": {
        //             "ask_iv": "0.36932389",
        //             "ask_size": "1321",
        //             "best_ask": "1054",
        //             "best_bid": "1020",
        //             "bid_iv": "0.34851914",
        //             "bid_size": "2202",
        //             "impact_mid_price": null,
        //             "mark_iv": "0.35896335"
        //         },
        //         "size": 152,
        //         "spot_price": "30178.53195697",
        //         "strike_price": "29500",
        //         "symbol": "C-BTC-29500-280723",
        //         "timestamp": 1689834695286094,
        //         "turnover": 4546.601744940001,
        //         "turnover_symbol": "USDT",
        //         "turnover_usd": 4546.601744940001,
        //         "volume": 0.15200000000000002
        //     }
        //
        object timestamp = this.safeIntegerProduct(interest, "timestamp", 0.001);
        object marketId = this.safeString(interest, "symbol");
        return this.safeOpenInterest(new Dictionary<string, object>() {
            { "symbol", this.safeSymbol(marketId, market) },
            { "baseVolume", this.safeNumber(interest, "oi_value") },
            { "quoteVolume", this.safeNumber(interest, "oi_value_usd") },
            { "openInterestAmount", this.safeNumber(interest, "oi_contracts") },
            { "openInterestValue", this.safeNumber(interest, "oi") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "info", interest },
        }, market);
    }

    /**
     * @method
     * @name delta#fetchLeverage
     * @description fetch the set leverage for a market
     * @see https://docs.delta.exchange/#get-order-leverage
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [leverage structure]{@link https://docs.ccxt.com/#/?id=leverage-structure}
     */
    public async override Task<object> fetchLeverage(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "product_id", getValue(market, "numericId") },
        };
        object response = await this.privateGetProductsProductIdOrdersLeverage(this.extend(request, parameters));
        //
        //     {
        //         "result": {
        //             "index_symbol": null,
        //             "leverage": "10",
        //             "margin_mode": "isolated",
        //             "order_margin": "0",
        //             "product_id": 84,
        //             "user_id": 30084879
        //         },
        //         "success": true
        //     }
        //
        object result = this.safeDict(response, "result", new Dictionary<string, object>() {});
        return this.parseLeverage(result, market);
    }

    public override object parseLeverage(object leverage, object market = null)
    {
        object marketId = this.safeString(leverage, "index_symbol");
        object leverageValue = this.safeInteger(leverage, "leverage");
        return new Dictionary<string, object>() {
            { "info", leverage },
            { "symbol", this.safeSymbol(marketId, market) },
            { "marginMode", this.safeStringLower(leverage, "margin_mode") },
            { "longLeverage", leverageValue },
            { "shortLeverage", leverageValue },
        };
    }

    /**
     * @method
     * @name delta#setLeverage
     * @description set the level of leverage for a market
     * @see https://docs.delta.exchange/#change-order-leverage
     * @param {float} leverage the rate of leverage
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} response from the exchange
     */
    public async override Task<object> setLeverage(object leverage, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " setLeverage() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "product_id", getValue(market, "numericId") },
            { "leverage", leverage },
        };
        //
        //     {
        //         "result": {
        //             "leverage": "20",
        //             "margin_mode": "isolated",
        //             "order_margin": "0",
        //             "product_id": 84
        //         },
        //         "success": true
        //     }
        //
        return await this.privatePostProductsProductIdOrdersLeverage(this.extend(request, parameters));
    }

    /**
     * @method
     * @name delta#fetchSettlementHistory
     * @description fetches historical settlement records
     * @see https://docs.delta.exchange/#get-product-settlement-prices
     * @param {string} symbol unified market symbol of the settlement history
     * @param {int} [since] timestamp in ms
     * @param {int} [limit] number of records
     * @param {object} [params] exchange specific params
     * @returns {object[]} a list of [settlement history objects]{@link https://docs.ccxt.com/#/?id=settlement-history-structure}
     */
    public async virtual Task<object> fetchSettlementHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object request = new Dictionary<string, object>() {
            { "states", "expired" },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["page_size"] = limit;
        }
        object response = await this.publicGetProducts(this.extend(request, parameters));
        //
        //     {
        //         "result": [
        //             {
        //                 "contract_value": "0.001",
        //                 "basis_factor_max_limit": "10.95",
        //                 "maker_commission_rate": "0.0003",
        //                 "launch_time": "2023-07-19T04:30:03Z",
        //                 "trading_status": "operational",
        //                 "product_specs": {
        //                     "backup_vol_expiry_time": 31536000,
        //                     "max_deviation_from_external_vol": 0.75,
        //                     "max_lower_deviation_from_external_vol": 0.75,
        //                     "max_upper_deviation_from_external_vol": 0.5,
        //                     "max_volatility": 3,
        //                     "min_volatility": 0.1,
        //                     "premium_commission_rate": 0.1,
        //                     "settlement_index_price": "29993.536675710806",
        //                     "vol_calculation_method": "orderbook",
        //                     "vol_expiry_time": 31536000
        //                 },
        //                 "description": "BTC call option expiring on 19-7-2023",
        //                 "settlement_price": "0",
        //                 "disruption_reason": null,
        //                 "settling_asset": {},
        //                 "initial_margin": "1",
        //                 "tick_size": "0.1",
        //                 "maintenance_margin": "0.5",
        //                 "id": 117542,
        //                 "notional_type": "vanilla",
        //                 "ui_config": {},
        //                 "contract_unit_currency": "BTC",
        //                 "symbol": "C-BTC-30900-190723",
        //                 "insurance_fund_margin_contribution": "1",
        //                 "price_band": "2",
        //                 "annualized_funding": "10.95",
        //                 "impact_size": 200,
        //                 "contract_type": "call_options",
        //                 "position_size_limit": 255633,
        //                 "max_leverage_notional": "200000",
        //                 "initial_margin_scaling_factor": "0.000002",
        //                 "strike_price": "30900",
        //                 "is_quanto": false,
        //                 "settlement_time": "2023-07-19T12:00:00Z",
        //                 "liquidation_penalty_factor": "0.5",
        //                 "funding_method": "mark_price",
        //                 "taker_commission_rate": "0.0003",
        //                 "default_leverage": "100.000000000000000000",
        //                 "state": "expired",
        //                 "auction_start_time": null,
        //                 "short_description": "BTC  Call",
        //                 "quoting_asset": {},
        //                 "maintenance_margin_scaling_factor":"0.000002"
        //             }
        //         ],
        //         "success": true
        //     }
        //
        object result = this.safeList(response, "result", new List<object>() {});
        object settlements = this.parseSettlements(result, market);
        object sorted = this.sortBy(settlements, "timestamp");
        return this.filterBySymbolSinceLimit(sorted, getValue(market, "symbol"), since, limit);
    }

    public virtual object parseSettlement(object settlement, object market)
    {
        //
        //     {
        //         "contract_value": "0.001",
        //         "basis_factor_max_limit": "10.95",
        //         "maker_commission_rate": "0.0003",
        //         "launch_time": "2023-07-19T04:30:03Z",
        //         "trading_status": "operational",
        //         "product_specs": {
        //             "backup_vol_expiry_time": 31536000,
        //             "max_deviation_from_external_vol": 0.75,
        //             "max_lower_deviation_from_external_vol": 0.75,
        //             "max_upper_deviation_from_external_vol": 0.5,
        //             "max_volatility": 3,
        //             "min_volatility": 0.1,
        //             "premium_commission_rate": 0.1,
        //             "settlement_index_price": "29993.536675710806",
        //             "vol_calculation_method": "orderbook",
        //             "vol_expiry_time": 31536000
        //         },
        //         "description": "BTC call option expiring on 19-7-2023",
        //         "settlement_price": "0",
        //         "disruption_reason": null,
        //         "settling_asset": {},
        //         "initial_margin": "1",
        //         "tick_size": "0.1",
        //         "maintenance_margin": "0.5",
        //         "id": 117542,
        //         "notional_type": "vanilla",
        //         "ui_config": {},
        //         "contract_unit_currency": "BTC",
        //         "symbol": "C-BTC-30900-190723",
        //         "insurance_fund_margin_contribution": "1",
        //         "price_band": "2",
        //         "annualized_funding": "10.95",
        //         "impact_size": 200,
        //         "contract_type": "call_options",
        //         "position_size_limit": 255633,
        //         "max_leverage_notional": "200000",
        //         "initial_margin_scaling_factor": "0.000002",
        //         "strike_price": "30900",
        //         "is_quanto": false,
        //         "settlement_time": "2023-07-19T12:00:00Z",
        //         "liquidation_penalty_factor": "0.5",
        //         "funding_method": "mark_price",
        //         "taker_commission_rate": "0.0003",
        //         "default_leverage": "100.000000000000000000",
        //         "state": "expired",
        //         "auction_start_time": null,
        //         "short_description": "BTC  Call",
        //         "quoting_asset": {},
        //         "maintenance_margin_scaling_factor":"0.000002"
        //     }
        //
        object datetime = this.safeString(settlement, "settlement_time");
        object marketId = this.safeString(settlement, "symbol");
        return new Dictionary<string, object>() {
            { "info", settlement },
            { "symbol", this.safeSymbol(marketId, market) },
            { "price", this.safeNumber(settlement, "settlement_price") },
            { "timestamp", this.parse8601(datetime) },
            { "datetime", datetime },
        };
    }

    public virtual object parseSettlements(object settlements, object market)
    {
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(settlements)); postFixIncrement(ref i))
        {
            ((IList<object>)result).Add(this.parseSettlement(getValue(settlements, i), market));
        }
        return result;
    }

    /**
     * @method
     * @name delta#fetchGreeks
     * @description fetches an option contracts greeks, financial metrics used to measure the factors that affect the price of an options contract
     * @see https://docs.delta.exchange/#get-ticker-for-a-product-by-symbol
     * @param {string} symbol unified symbol of the market to fetch greeks for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [greeks structure]{@link https://docs.ccxt.com/#/?id=greeks-structure}
     */
    public async override Task<object> fetchGreeks(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.publicGetTickersSymbol(this.extend(request, parameters));
        //
        //     {
        //         "result": {
        //             "close": 6793.0,
        //             "contract_type": "call_options",
        //             "greeks": {
        //                 "delta": "0.94739174",
        //                 "gamma": "0.00002206",
        //                 "rho": "11.00890725",
        //                 "spot": "36839.58124652",
        //                 "theta": "-18.18365310",
        //                 "vega": "7.85209698"
        //             },
        //             "high": 7556.0,
        //             "low": 6793.0,
        //             "mark_price": "6955.70698909",
        //             "mark_vol": "0.66916863",
        //             "oi": "1.8980",
        //             "oi_change_usd_6h": "110.4600",
        //             "oi_contracts": "1898",
        //             "oi_value": "1.8980",
        //             "oi_value_symbol": "BTC",
        //             "oi_value_usd": "69940.7319",
        //             "open": 7.2e3,
        //             "price_band": {
        //                 "lower_limit": "5533.89814767",
        //                 "upper_limit": "11691.37688371"
        //             },
        //             "product_id": 129508,
        //             "quotes": {
        //                 "ask_iv": "0.90180438",
        //                 "ask_size": "1898",
        //                 "best_ask": "7210",
        //                 "best_bid": "6913",
        //                 "bid_iv": "0.60881706",
        //                 "bid_size": "3163",
        //                 "impact_mid_price": null,
        //                 "mark_iv": "0.66973549"
        //             },
        //             "size": 5,
        //             "spot_price": "36839.58153868",
        //             "strike_price": "30000",
        //             "symbol": "C-BTC-30000-241123",
        //             "timestamp": 1699584998504530,
        //             "turnover": 184.41206804,
        //             "turnover_symbol": "USDT",
        //             "turnover_usd": 184.41206804,
        //             "volume": 0.005
        //         },
        //         "success": true
        //     }
        //
        object result = this.safeDict(response, "result", new Dictionary<string, object>() {});
        return this.parseGreeks(result, market);
    }

    public override object parseGreeks(object greeks, object market = null)
    {
        //
        //     {
        //         "close": 6793.0,
        //         "contract_type": "call_options",
        //         "greeks": {
        //             "delta": "0.94739174",
        //             "gamma": "0.00002206",
        //             "rho": "11.00890725",
        //             "spot": "36839.58124652",
        //             "theta": "-18.18365310",
        //             "vega": "7.85209698"
        //         },
        //         "high": 7556.0,
        //         "low": 6793.0,
        //         "mark_price": "6955.70698909",
        //         "mark_vol": "0.66916863",
        //         "oi": "1.8980",
        //         "oi_change_usd_6h": "110.4600",
        //         "oi_contracts": "1898",
        //         "oi_value": "1.8980",
        //         "oi_value_symbol": "BTC",
        //         "oi_value_usd": "69940.7319",
        //         "open": 7.2e3,
        //         "price_band": {
        //             "lower_limit": "5533.89814767",
        //             "upper_limit": "11691.37688371"
        //         },
        //         "product_id": 129508,
        //         "quotes": {
        //             "ask_iv": "0.90180438",
        //             "ask_size": "1898",
        //             "best_ask": "7210",
        //             "best_bid": "6913",
        //             "bid_iv": "0.60881706",
        //             "bid_size": "3163",
        //             "impact_mid_price": null,
        //             "mark_iv": "0.66973549"
        //         },
        //         "size": 5,
        //         "spot_price": "36839.58153868",
        //         "strike_price": "30000",
        //         "symbol": "C-BTC-30000-241123",
        //         "timestamp": 1699584998504530,
        //         "turnover": 184.41206804,
        //         "turnover_symbol": "USDT",
        //         "turnover_usd": 184.41206804,
        //         "volume": 0.005
        //     }
        //
        object timestamp = this.safeIntegerProduct(greeks, "timestamp", 0.001);
        object marketId = this.safeString(greeks, "symbol");
        object symbol = this.safeSymbol(marketId, market);
        object stats = this.safeDict(greeks, "greeks", new Dictionary<string, object>() {});
        object quotes = this.safeDict(greeks, "quotes", new Dictionary<string, object>() {});
        return new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "delta", this.safeNumber(stats, "delta") },
            { "gamma", this.safeNumber(stats, "gamma") },
            { "theta", this.safeNumber(stats, "theta") },
            { "vega", this.safeNumber(stats, "vega") },
            { "rho", this.safeNumber(stats, "rho") },
            { "bidSize", this.safeNumber(quotes, "bid_size") },
            { "askSize", this.safeNumber(quotes, "ask_size") },
            { "bidImpliedVolatility", this.safeNumber(quotes, "bid_iv") },
            { "askImpliedVolatility", this.safeNumber(quotes, "ask_iv") },
            { "markImpliedVolatility", this.safeNumber(quotes, "mark_iv") },
            { "bidPrice", this.safeNumber(quotes, "best_bid") },
            { "askPrice", this.safeNumber(quotes, "best_ask") },
            { "markPrice", this.safeNumber(greeks, "mark_price") },
            { "lastPrice", null },
            { "underlyingPrice", this.safeNumber(greeks, "spot_price") },
            { "info", greeks },
        };
    }

    /**
     * @method
     * @name delta#closeAllPositions
     * @description closes all open positions for a market type
     * @see https://docs.delta.exchange/#close-all-positions
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.user_id] the users id
     * @returns {object[]} A list of [position structures]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public async override Task<object> closeAllPositions(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "close_all_portfolio", true },
            { "close_all_isolated", true },
        };
        object response = await this.privatePostPositionsCloseAll(this.extend(request, parameters));
        //
        // {"result":{},"success":true}
        //
        object position = this.parsePosition(this.safeDict(response, "result", new Dictionary<string, object>() {}));
        return new List<object>() {position};
    }

    /**
     * @method
     * @name delta#fetchMarginMode
     * @description fetches the margin mode of a trading pair
     * @see https://docs.delta.exchange/#get-user
     * @param {string} symbol unified symbol of the market to fetch the margin mode for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [margin mode structure]{@link https://docs.ccxt.com/#/?id=margin-mode-structure}
     */
    public async override Task<object> fetchMarginMode(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object response = await this.privateGetProfile(parameters);
        //
        //     {
        //         "result": {
        //             "is_password_set": true,
        //             "kyc_expiry_date": null,
        //             "phishing_code": "12345",
        //             "preferences": {
        //                 "favorites": []
        //             },
        //             "is_kyc_provisioned": false,
        //             "country": "Canada",
        //             "margin_mode": "isolated",
        //             "mfa_updated_at": "2023-07-19T01:04:43Z",
        //             "last_name": "",
        //             "oauth_apple_active": false,
        //             "pf_index_symbol": null,
        //             "proof_of_identity_status": "approved",
        //             "dob": null,
        //             "email": "abc_123@gmail.com",
        //             "force_change_password": false,
        //             "nick_name": "still-breeze-123",
        //             "oauth_google_active": false,
        //             "phone_verification_status": "verified",
        //             "id": 12345678,
        //             "last_seen": null,
        //             "is_withdrawal_enabled": true,
        //             "force_change_mfa": false,
        //             "enable_bots": false,
        //             "kyc_verified_on": null,
        //             "created_at": "2023-07-19T01:02:32Z",
        //             "withdrawal_blocked_till": null,
        //             "proof_of_address_status": "approved",
        //             "is_password_change_blocked": false,
        //             "is_mfa_enabled": true,
        //             "is_kyc_done": true,
        //             "oauth": null,
        //             "account_name": "Main",
        //             "sub_account_permissions": null,
        //             "phone_number": null,
        //             "tracking_info": {
        //                 "ga_cid": "1234.4321",
        //                 "is_kyc_gtm_tracked": true,
        //                 "sub_account_config": {
        //                     "cross": 2,
        //                     "isolated": 2,
        //                     "portfolio": 2
        //                 }
        //             },
        //             "first_name": "",
        //             "phone_verified_on": null,
        //             "seen_intro": false,
        //             "password_updated_at": null,
        //             "is_login_enabled": true,
        //             "registration_date": "2023-07-19T01:02:32Z",
        //             "permissions": {},
        //             "max_sub_accounts_limit": 2,
        //             "country_calling_code": null,
        //             "is_sub_account": false,
        //             "is_kyc_refresh_required": false
        //         },
        //         "success": true
        //     }
        //
        object result = this.safeDict(response, "result", new Dictionary<string, object>() {});
        return this.parseMarginMode(result, market);
    }

    public override object parseMarginMode(object marginMode, object market = null)
    {
        object symbol = null;
        if (isTrue(!isEqual(market, null)))
        {
            symbol = getValue(market, "symbol");
        }
        return new Dictionary<string, object>() {
            { "info", marginMode },
            { "symbol", symbol },
            { "marginMode", this.safeString(marginMode, "margin_mode") },
        };
    }

    /**
     * @method
     * @name delta#fetchOption
     * @description fetches option data that is commonly found in an option chain
     * @see https://docs.delta.exchange/#get-ticker-for-a-product-by-symbol
     * @param {string} symbol unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [option chain structure]{@link https://docs.ccxt.com/#/?id=option-chain-structure}
     */
    public async override Task<object> fetchOption(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "symbol", getValue(market, "id") },
        };
        object response = await this.publicGetTickersSymbol(this.extend(request, parameters));
        //
        //     {
        //         "result": {
        //             "close": 6793.0,
        //             "contract_type": "call_options",
        //             "greeks": {
        //                 "delta": "0.94739174",
        //                 "gamma": "0.00002206",
        //                 "rho": "11.00890725",
        //                 "spot": "36839.58124652",
        //                 "theta": "-18.18365310",
        //                 "vega": "7.85209698"
        //             },
        //             "high": 7556.0,
        //             "low": 6793.0,
        //             "mark_price": "6955.70698909",
        //             "mark_vol": "0.66916863",
        //             "oi": "1.8980",
        //             "oi_change_usd_6h": "110.4600",
        //             "oi_contracts": "1898",
        //             "oi_value": "1.8980",
        //             "oi_value_symbol": "BTC",
        //             "oi_value_usd": "69940.7319",
        //             "open": 7.2e3,
        //             "price_band": {
        //                 "lower_limit": "5533.89814767",
        //                 "upper_limit": "11691.37688371"
        //             },
        //             "product_id": 129508,
        //             "quotes": {
        //                 "ask_iv": "0.90180438",
        //                 "ask_size": "1898",
        //                 "best_ask": "7210",
        //                 "best_bid": "6913",
        //                 "bid_iv": "0.60881706",
        //                 "bid_size": "3163",
        //                 "impact_mid_price": null,
        //                 "mark_iv": "0.66973549"
        //             },
        //             "size": 5,
        //             "spot_price": "36839.58153868",
        //             "strike_price": "30000",
        //             "symbol": "C-BTC-30000-241123",
        //             "timestamp": 1699584998504530,
        //             "turnover": 184.41206804,
        //             "turnover_symbol": "USDT",
        //             "turnover_usd": 184.41206804,
        //             "volume": 0.005
        //         },
        //         "success": true
        //     }
        //
        object result = this.safeDict(response, "result", new Dictionary<string, object>() {});
        return this.parseOption(result, null, market);
    }

    public override object parseOption(object chain, object currency = null, object market = null)
    {
        //
        //     {
        //         "close": 6793.0,
        //         "contract_type": "call_options",
        //         "greeks": {
        //             "delta": "0.94739174",
        //             "gamma": "0.00002206",
        //             "rho": "11.00890725",
        //             "spot": "36839.58124652",
        //             "theta": "-18.18365310",
        //             "vega": "7.85209698"
        //         },
        //         "high": 7556.0,
        //         "low": 6793.0,
        //         "mark_price": "6955.70698909",
        //         "mark_vol": "0.66916863",
        //         "oi": "1.8980",
        //         "oi_change_usd_6h": "110.4600",
        //         "oi_contracts": "1898",
        //         "oi_value": "1.8980",
        //         "oi_value_symbol": "BTC",
        //         "oi_value_usd": "69940.7319",
        //         "open": 7.2e3,
        //         "price_band": {
        //             "lower_limit": "5533.89814767",
        //             "upper_limit": "11691.37688371"
        //         },
        //         "product_id": 129508,
        //         "quotes": {
        //             "ask_iv": "0.90180438",
        //             "ask_size": "1898",
        //             "best_ask": "7210",
        //             "best_bid": "6913",
        //             "bid_iv": "0.60881706",
        //             "bid_size": "3163",
        //             "impact_mid_price": null,
        //             "mark_iv": "0.66973549"
        //         },
        //         "size": 5,
        //         "spot_price": "36839.58153868",
        //         "strike_price": "30000",
        //         "symbol": "C-BTC-30000-241123",
        //         "timestamp": 1699584998504530,
        //         "turnover": 184.41206804,
        //         "turnover_symbol": "USDT",
        //         "turnover_usd": 184.41206804,
        //         "volume": 0.005
        //     }
        //
        object marketId = this.safeString(chain, "symbol");
        market = this.safeMarket(marketId, market);
        object quotes = this.safeDict(chain, "quotes", new Dictionary<string, object>() {});
        object timestamp = this.safeIntegerProduct(chain, "timestamp", 0.001);
        return new Dictionary<string, object>() {
            { "info", chain },
            { "currency", null },
            { "symbol", getValue(market, "symbol") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "impliedVolatility", this.safeNumber(quotes, "mark_iv") },
            { "openInterest", this.safeNumber(chain, "oi") },
            { "bidPrice", this.safeNumber(quotes, "best_bid") },
            { "askPrice", this.safeNumber(quotes, "best_ask") },
            { "midPrice", this.safeNumber(quotes, "impact_mid_price") },
            { "markPrice", this.safeNumber(chain, "mark_price") },
            { "lastPrice", null },
            { "underlyingPrice", this.safeNumber(chain, "spot_price") },
            { "change", null },
            { "percentage", null },
            { "baseVolume", this.safeNumber(chain, "volume") },
            { "quoteVolume", null },
        };
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object requestPath = add(add(add("/", this.version), "/"), this.implodeParams(path, parameters));
        object url = add(getValue(getValue(this.urls, "api"), api), requestPath);
        object query = this.omit(parameters, this.extractParams(path));
        if (isTrue(isEqual(api, "public")))
        {
            if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
            {
                url = add(url, add("?", this.urlencode(query)));
            }
        } else if (isTrue(isEqual(api, "private")))
        {
            this.checkRequiredCredentials();
            object timestamp = ((object)this.seconds()).ToString();
            headers = new Dictionary<string, object>() {
                { "api-key", this.apiKey },
                { "timestamp", timestamp },
            };
            object auth = add(add(method, timestamp), requestPath);
            if (isTrue(isTrue((isEqual(method, "GET"))) || isTrue((isEqual(method, "DELETE")))))
            {
                if (isTrue(getArrayLength(new List<object>(((IDictionary<string,object>)query).Keys))))
                {
                    object queryString = add("?", this.urlencode(query));
                    auth = add(auth, queryString);
                    url = add(url, queryString);
                }
            } else
            {
                body = this.json(query);
                auth = add(auth, body);
                ((IDictionary<string,object>)headers)["Content-Type"] = "application/json";
            }
            object signature = this.hmac(this.encode(auth), this.encode(this.secret), sha256);
            ((IDictionary<string,object>)headers)["signature"] = signature;
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;
        }
        //
        // {"error":{"code":"insufficient_margin","context":{"available_balance":"0.000000000000000000","required_additional_balance":"1.618626000000000000000000000"}},"success":false}
        //
        object error = this.safeDict(response, "error", new Dictionary<string, object>() {});
        object errorCode = this.safeString(error, "code");
        if (isTrue(!isEqual(errorCode, null)))
        {
            object feedback = add(add(this.id, " "), body);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), errorCode, feedback);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), errorCode, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }
}
