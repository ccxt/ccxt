namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

public partial class oxfun : Exchange
{
    public override object describe()
    {
        return this.deepExtend(base.describe(), new Dictionary<string, object>() {
            { "id", "oxfun" },
            { "name", "OXFUN" },
            { "countries", new List<object>() {"PA"} },
            { "version", "v3" },
            { "rateLimit", 120 },
            { "pro", true },
            { "has", new Dictionary<string, object>() {
                { "CORS", null },
                { "spot", true },
                { "margin", false },
                { "swap", true },
                { "future", false },
                { "option", false },
                { "addMargin", false },
                { "cancelAllOrders", true },
                { "cancelOrder", true },
                { "cancelOrders", true },
                { "closeAllPositions", false },
                { "closePosition", false },
                { "createDepositAddress", false },
                { "createMarketBuyOrderWithCost", true },
                { "createMarketOrderWithCost", false },
                { "createMarketSellOrderWithCost", false },
                { "createOrder", true },
                { "createOrders", true },
                { "createPostOnlyOrder", true },
                { "createReduceOnlyOrder", false },
                { "createStopLimitOrder", true },
                { "createStopMarketOrder", true },
                { "createStopOrder", true },
                { "deposit", false },
                { "editOrder", false },
                { "fetchAccounts", true },
                { "fetchBalance", true },
                { "fetchBidsAsks", false },
                { "fetchBorrowInterest", false },
                { "fetchBorrowRateHistories", false },
                { "fetchBorrowRateHistory", false },
                { "fetchCanceledOrders", false },
                { "fetchClosedOrder", false },
                { "fetchClosedOrders", false },
                { "fetchCrossBorrowRate", false },
                { "fetchCrossBorrowRates", false },
                { "fetchCurrencies", true },
                { "fetchDeposit", false },
                { "fetchDepositAddress", true },
                { "fetchDepositAddresses", false },
                { "fetchDepositAddressesByNetwork", false },
                { "fetchDeposits", true },
                { "fetchDepositWithdrawFee", false },
                { "fetchDepositWithdrawFees", false },
                { "fetchFundingHistory", true },
                { "fetchFundingRate", "emulated" },
                { "fetchFundingRateHistory", true },
                { "fetchFundingRates", true },
                { "fetchIndexOHLCV", false },
                { "fetchIsolatedBorrowRate", false },
                { "fetchIsolatedBorrowRates", false },
                { "fetchL3OrderBook", false },
                { "fetchLedger", false },
                { "fetchLeverage", false },
                { "fetchLeverageTiers", true },
                { "fetchMarketLeverageTiers", "emulated" },
                { "fetchMarkets", true },
                { "fetchMarkOHLCV", false },
                { "fetchMyTrades", true },
                { "fetchOHLCV", true },
                { "fetchOpenInterestHistory", false },
                { "fetchOpenOrder", false },
                { "fetchOpenOrders", true },
                { "fetchOrder", true },
                { "fetchOrderBook", true },
                { "fetchOrderBooks", false },
                { "fetchOrders", false },
                { "fetchOrderTrades", false },
                { "fetchPosition", false },
                { "fetchPositionHistory", false },
                { "fetchPositionMode", false },
                { "fetchPositions", true },
                { "fetchPositionsForSymbol", false },
                { "fetchPositionsHistory", false },
                { "fetchPositionsRisk", false },
                { "fetchPremiumIndexOHLCV", false },
                { "fetchStatus", false },
                { "fetchTicker", true },
                { "fetchTickers", true },
                { "fetchTime", false },
                { "fetchTrades", true },
                { "fetchTradingFee", false },
                { "fetchTradingFees", false },
                { "fetchTradingLimits", false },
                { "fetchTransactionFee", false },
                { "fetchTransactionFees", false },
                { "fetchTransactions", false },
                { "fetchTransfers", true },
                { "fetchWithdrawal", false },
                { "fetchWithdrawals", true },
                { "fetchWithdrawalWhitelist", false },
                { "reduceMargin", false },
                { "repayCrossMargin", false },
                { "repayIsolatedMargin", false },
                { "sandbox", true },
                { "setLeverage", false },
                { "setMargin", false },
                { "setMarginMode", false },
                { "setPositionMode", false },
                { "signIn", false },
                { "transfer", true },
                { "withdraw", true },
                { "ws", true },
            } },
            { "timeframes", new Dictionary<string, object>() {
                { "1m", "60s" },
                { "5m", "300s" },
                { "15m", "900s" },
                { "30m", "1800s" },
                { "1h", "3600s" },
                { "2h", "7200s" },
                { "4h", "14400s" },
                { "1d", "86400s" },
            } },
            { "urls", new Dictionary<string, object>() {
                { "logo", "https://github.com/ccxt/ccxt/assets/43336371/6a196124-c1ee-4fae-8573-962071b61a85" },
                { "referral", "https://ox.fun/register?shareAccountId=5ZUD4a7G" },
                { "api", new Dictionary<string, object>() {
                    { "public", "https://api.ox.fun" },
                    { "private", "https://api.ox.fun" },
                } },
                { "test", new Dictionary<string, object>() {
                    { "public", "https://stgapi.ox.fun" },
                    { "private", "https://stgapi.ox.fun" },
                } },
                { "www", "https://ox.fun/" },
                { "doc", "https://docs.ox.fun/" },
                { "fees", "https://support.ox.fun/en/articles/8819866-trading-fees" },
            } },
            { "api", new Dictionary<string, object>() {
                { "public", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "v3/markets", 1 },
                        { "v3/assets", 1 },
                        { "v3/tickers", 1 },
                        { "v3/funding/estimates", 1 },
                        { "v3/candles", 1 },
                        { "v3/depth", 1 },
                        { "v3/markets/operational", 1 },
                        { "v3/exchange-trades", 1 },
                        { "v3/funding/rates", 1 },
                        { "v3/leverage/tiers", 1 },
                    } },
                } },
                { "private", new Dictionary<string, object>() {
                    { "get", new Dictionary<string, object>() {
                        { "v3/account", 1 },
                        { "v3/account/names", 1 },
                        { "v3/wallet", 1 },
                        { "v3/transfer", 1 },
                        { "v3/balances", 1 },
                        { "v3/positions", 1 },
                        { "v3/funding", 1 },
                        { "v3/deposit-addresses", 1 },
                        { "v3/deposit", 1 },
                        { "v3/withdrawal-addresses", 1 },
                        { "v3/withdrawal", 1 },
                        { "v3/withdrawal-fees", 1 },
                        { "v3/orders/status", 1 },
                        { "v3/orders/working", 1 },
                        { "v3/trades", 1 },
                    } },
                    { "post", new Dictionary<string, object>() {
                        { "v3/transfer", 1 },
                        { "v3/withdrawal", 1 },
                        { "v3/orders/place", 1 },
                    } },
                    { "delete", new Dictionary<string, object>() {
                        { "v3/orders/cancel", 1 },
                        { "v3/orders/cancel-all", 1 },
                    } },
                } },
            } },
            { "fees", new Dictionary<string, object>() {
                { "trading", new Dictionary<string, object>() {
                    { "tierBased", true },
                    { "percentage", true },
                    { "maker", this.parseNumber("0.00020") },
                    { "taker", this.parseNumber("0.00070") },
                    { "tiers", new Dictionary<string, object>() {
                        { "maker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.00020")}, new List<object> {this.parseNumber("2500000"), this.parseNumber("0.00010")}, new List<object> {this.parseNumber("25000000"), this.parseNumber("0")}} },
                        { "taker", new List<object>() {new List<object> {this.parseNumber("0"), this.parseNumber("0.00070")}, new List<object> {this.parseNumber("2500000"), this.parseNumber("0.00050")}, new List<object> {this.parseNumber("25000000"), this.parseNumber("0.00040")}} },
                    } },
                } },
            } },
            { "precisionMode", TICK_SIZE },
            { "options", new Dictionary<string, object>() {
                { "sandboxMode", false },
                { "networks", new Dictionary<string, object>() {
                    { "BTC", "Bitcoin" },
                    { "ERC20", "Ethereum" },
                    { "AVAX", "Avalanche" },
                    { "SOL", "Solana" },
                    { "ARB", "Arbitrum" },
                    { "MATIC", "Polygon" },
                    { "FTM", "Fantom" },
                    { "BNB", "BNBSmartChain" },
                    { "OPTIMISM", "Optimism" },
                } },
                { "networksById", new Dictionary<string, object>() {
                    { "Bitcoin", "BTC" },
                    { "Ethereum", "ERC20" },
                    { "Avalanche", "AVAX" },
                    { "Solana", "SOL" },
                    { "Arbitrum", "ARB" },
                    { "Polygon", "MATIC" },
                    { "Fantom", "FTM" },
                    { "Base", "BASE" },
                    { "BNBSmartChain", "BNB" },
                    { "Optimism", "OPTIMISM" },
                } },
            } },
            { "features", new Dictionary<string, object>() {
                { "default", new Dictionary<string, object>() {
                    { "sandbox", true },
                    { "createOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "triggerPrice", true },
                        { "triggerDirection", false },
                        { "triggerPriceType", null },
                        { "stopLossPrice", false },
                        { "takeProfitPrice", false },
                        { "attachedStopLossTakeProfit", null },
                        { "timeInForce", new Dictionary<string, object>() {
                            { "IOC", true },
                            { "FOK", true },
                            { "PO", true },
                            { "GTD", false },
                        } },
                        { "hedged", false },
                        { "trailing", false },
                        { "leverage", false },
                        { "marketBuyByCost", true },
                        { "marketBuyRequiresPrice", false },
                        { "selfTradePrevention", true },
                        { "iceberg", true },
                    } },
                    { "createOrders", new Dictionary<string, object>() {
                        { "max", 10 },
                    } },
                    { "fetchMyTrades", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", 500 },
                        { "daysBack", 100000 },
                        { "untilDays", 7 },
                        { "symbolRequired", false },
                    } },
                    { "fetchOrder", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchOpenOrders", new Dictionary<string, object>() {
                        { "marginMode", false },
                        { "limit", null },
                        { "trigger", false },
                        { "trailing", false },
                        { "symbolRequired", false },
                    } },
                    { "fetchOrders", null },
                    { "fetchClosedOrders", null },
                    { "fetchOHLCV", new Dictionary<string, object>() {
                        { "limit", 500 },
                    } },
                } },
                { "spot", new Dictionary<string, object>() {
                    { "extends", "default" },
                } },
                { "swap", new Dictionary<string, object>() {
                    { "linear", new Dictionary<string, object>() {
                        { "extends", "default" },
                    } },
                    { "inverse", null },
                } },
                { "future", new Dictionary<string, object>() {
                    { "linear", null },
                    { "inverse", null },
                } },
            } },
            { "exceptions", new Dictionary<string, object>() {
                { "exact", new Dictionary<string, object>() {
                    { "-0010", typeof(OperationFailed) },
                    { "-429", typeof(RateLimitExceeded) },
                    { "-05001", typeof(AuthenticationError) },
                    { "-10001", typeof(ExchangeError) },
                    { "-20000", typeof(BadRequest) },
                    { "-20001", typeof(BadRequest) },
                    { "-20002", typeof(BadRequest) },
                    { "-20003", typeof(NotSupported) },
                    { "-20005", typeof(AuthenticationError) },
                    { "-20006", typeof(BadRequest) },
                    { "-20007", typeof(AuthenticationError) },
                    { "-20008", typeof(BadRequest) },
                    { "-20009", typeof(BadRequest) },
                    { "-20010", typeof(ArgumentsRequired) },
                    { "-20011", typeof(ArgumentsRequired) },
                    { "-20012", typeof(ArgumentsRequired) },
                    { "-20013", typeof(ArgumentsRequired) },
                    { "-20014", typeof(BadRequest) },
                    { "-20015", typeof(BadSymbol) },
                    { "-20016", typeof(BadRequest) },
                    { "-20017", typeof(BadRequest) },
                    { "-20018", typeof(BadRequest) },
                    { "-20019", typeof(BadRequest) },
                    { "-20020", typeof(BadRequest) },
                    { "-20021", typeof(BadRequest) },
                    { "-20022", typeof(ArgumentsRequired) },
                    { "-20023", typeof(ArgumentsRequired) },
                    { "-20024", typeof(ExchangeError) },
                    { "-20025", typeof(AuthenticationError) },
                    { "-20026", typeof(BadRequest) },
                    { "-20027", typeof(BadRequest) },
                    { "-20028", typeof(BadRequest) },
                    { "-20029", typeof(BadRequest) },
                    { "-20030", typeof(BadRequest) },
                    { "-20031", typeof(MarketClosed) },
                    { "-20032", typeof(NetworkError) },
                    { "-20033", typeof(BadRequest) },
                    { "-20034", typeof(BadRequest) },
                    { "-20050", typeof(ExchangeError) },
                    { "-30001", typeof(BadRequest) },
                    { "-35034", typeof(AuthenticationError) },
                    { "-35046", typeof(AuthenticationError) },
                    { "-40001", typeof(ExchangeError) },
                    { "-50001", typeof(ExchangeError) },
                    { "-300001", typeof(AccountNotEnabled) },
                    { "-300011", typeof(InvalidOrder) },
                    { "-300012", typeof(InvalidOrder) },
                    { "-100005", typeof(OrderNotFound) },
                    { "-100006", typeof(InvalidOrder) },
                    { "-100008", typeof(BadRequest) },
                    { "-100015", typeof(NetworkError) },
                    { "-710001", typeof(ExchangeError) },
                    { "-710002", typeof(BadRequest) },
                    { "-710003", typeof(BadRequest) },
                    { "-710004", typeof(BadRequest) },
                    { "-710005", typeof(InsufficientFunds) },
                    { "-710006", typeof(InsufficientFunds) },
                    { "-710007", typeof(InsufficientFunds) },
                    { "-000101", typeof(NetworkError) },
                    { "-000201", typeof(NetworkError) },
                } },
                { "broad", new Dictionary<string, object>() {
                    { "-20001", typeof(OperationFailed) },
                    { "-200050", typeof(RequestTimeout) },
                } },
            } },
        });
    }

    /**
     * @method
     * @name oxfun#fetchMarkets
     * @description retrieves data on all markets for bitmex
     * @see https://docs.ox.fun/?json#get-v3-markets
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object[]} an array of objects representing market data
     */
    public async override Task<object> fetchMarkets(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        var responseFromMarketsresponseFromTickersVariable = await promiseAll(new List<object> {this.publicGetV3Markets(parameters), this.publicGetV3Tickers(parameters)});
        var responseFromMarkets = ((IList<object>) responseFromMarketsresponseFromTickersVariable)[0];
        var responseFromTickers = ((IList<object>) responseFromMarketsresponseFromTickersVariable)[1];
        object marketsFromMarkets = this.safeList(responseFromMarkets, "data", new List<object>() {});
        //
        //         {
        //             success: true,
        //             data: [
        //                 {
        //                     marketCode: 'OX-USD-SWAP-LIN',
        //                     name: 'OX/USD Perp',
        //                     referencePair: 'OX/USDT',
        //                     base: 'OX',
        //                     counter: 'USD',
        //                     type: 'FUTURE',
        //                     tickSize: '0.00001',
        //                     minSize: '1',
        //                     listedAt: '1704766320000',
        //                     upperPriceBound: '0.02122',
        //                     lowerPriceBound: '0.01142',
        //                     markPrice: '0.01632',
        //                     indexPrice: '0.01564',
        //                     lastUpdatedAt: '1714762235569'
        //                 },
        //                 {
        //                     marketCode: 'BTC-USD-SWAP-LIN',
        //                     name: 'BTC/USD Perp',
        //                     referencePair: 'BTC/USDT',
        //                     base: 'BTC',
        //                     counter: 'USD',
        //                     type: 'FUTURE',
        //                     tickSize: '1',
        //                     minSize: '0.0001',
        //                     listedAt: '1704686640000',
        //                     upperPriceBound: '67983',
        //                     lowerPriceBound: '55621',
        //                     markPrice: '61802',
        //                     indexPrice: '61813',
        //                     lastUpdatedAt: '1714762234765'
        //                 },
        //                 {
        //                     "marketCode": "MILK-OX",
        //                     "name": "MILK/OX",
        //                     "referencePair": "MILK/OX",
        //                     "base": "MILK",
        //                     "counter": "OX",
        //                     "type": "SPOT",
        //                     "tickSize": "0.0001",
        //                     "minSize": "1",
        //                     "listedAt": "1706608500000",
        //                     "upperPriceBound": "1.0000",
        //                     "lowerPriceBound": "-1.0000",
        //                     "markPrice": "0.0269",
        //                     "indexPrice": "0.0269",
        //                     "lastUpdatedAt": "1714757402185"
        //                 },
        //                 ...
        //             ]
        //         }
        //
        object marketsFromTickers = this.safeList(responseFromTickers, "data", new List<object>() {});
        //
        //     {
        //         "success": true,
        //         "data": [
        //             {
        //                 "marketCode": "DYM-USD-SWAP-LIN",
        //                 "markPrice": "3.321",
        //                 "open24h": "3.315",
        //                 "high24h": "3.356",
        //                 "low24h": "3.255",
        //                 "volume24h": "0",
        //                 "currencyVolume24h": "0",
        //                 "openInterest": "1768.1",
        //                 "lastTradedPrice": "3.543",
        //                 "lastTradedQuantity": "1.0",
        //                 "lastUpdatedAt": "1714853388102"
        //             },
        //             ...
        //         ]
        //     }
        //
        object markets = this.arrayConcat(marketsFromMarkets, marketsFromTickers);
        return this.parseMarkets(markets);
    }

    public override object parseMarkets(object markets)
    {
        object marketIds = new List<object>() {};
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(markets)); postFixIncrement(ref i))
        {
            object market = getValue(markets, i);
            object marketId = this.safeString(market, "marketCode");
            if (!isTrue((this.inArray(marketId, marketIds))))
            {
                ((IList<object>)marketIds).Add(marketId);
                ((IList<object>)result).Add(this.parseMarket(market));
            }
        }
        return result;
    }

    public override object parseMarket(object market)
    {
        object id = this.safeString(market, "marketCode", "");
        object parts = ((string)id).Split(new [] {((string)"-")}, StringSplitOptions.None).ToList<object>();
        object baseId = this.safeString(parts, 0);
        object quoteId = this.safeString(parts, 1);
        object bs = this.safeCurrencyCode(baseId);
        object quote = this.safeCurrencyCode(quoteId);
        object symbol = add(add(bs, "/"), quote);
        object type = this.safeStringLower(market, "type", "spot"); // markets from v3/tickers are spot and have no type
        object settleId = null;
        object settle = null;
        object isFuture = (isEqual(type, "future")); // the exchange has only perpetual futures
        if (isTrue(isFuture))
        {
            type = "swap";
            settleId = "OX";
            settle = this.safeCurrencyCode("OX");
            symbol = add(add(symbol, ":"), settle);
        }
        object isSpot = isEqual(type, "spot");
        return this.safeMarketStructure(new Dictionary<string, object>() {
            { "id", id },
            { "numericId", null },
            { "symbol", symbol },
            { "base", bs },
            { "quote", quote },
            { "settle", settle },
            { "baseId", baseId },
            { "quoteId", quoteId },
            { "settleId", settleId },
            { "type", type },
            { "spot", isSpot },
            { "margin", false },
            { "swap", isFuture },
            { "future", false },
            { "option", false },
            { "active", true },
            { "contract", isFuture },
            { "linear", ((bool) isTrue(isFuture)) ? true : null },
            { "inverse", ((bool) isTrue(isFuture)) ? false : null },
            { "taker", getValue(getValue(this.fees, "trading"), "taker") },
            { "maker", getValue(getValue(this.fees, "trading"), "maker") },
            { "contractSize", ((bool) isTrue(isFuture)) ? 1 : null },
            { "expiry", null },
            { "expiryDatetime", null },
            { "strike", null },
            { "optionType", null },
            { "precision", new Dictionary<string, object>() {
                { "amount", null },
                { "price", this.safeNumber(market, "tickSize") },
            } },
            { "limits", new Dictionary<string, object>() {
                { "leverage", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "amount", new Dictionary<string, object>() {
                    { "min", this.safeNumber(market, "minSize") },
                    { "max", null },
                } },
                { "price", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
                { "cost", new Dictionary<string, object>() {
                    { "min", null },
                    { "max", null },
                } },
            } },
            { "created", this.safeInteger(market, "listedAt") },
            { "index", null },
            { "info", market },
        });
    }

    /**
     * @method
     * @name oxfun#fetchCurrencies
     * @description fetches all available currencies on an exchange
     * @see https://docs.ox.fun/?json#get-v3-assets
     * @param {dict} [params] extra parameters specific to the exchange API endpoint
     * @returns {dict} an associative dictionary of currencies
     */
    public async override Task<object> fetchCurrencies(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object response = await this.publicGetV3Assets(parameters);
        //
        //     {
        //         "success": true,
        //         "data":  [
        //             {
        //                 "asset": "OX",
        //                 "isCollateral": true,
        //                 "loanToValue": "1.000000000",
        //                 "loanToValueFactor": "0.000000000",
        //                 "networkList":  [
        //                     {
        //                         "network": "BNBSmartChain",
        //                         "tokenId": "0x78a0A62Fba6Fb21A83FE8a3433d44C73a4017A6f",
        //                         "transactionPrecision": "18",
        //                         "isWithdrawalFeeChargedToUser": true,
        //                         "canDeposit": true,
        //                         "canWithdraw": false,
        //                         "minDeposit": "0.00010",
        //                         "minWithdrawal": "0.00010"
        //                     },
        //                     {
        //                         "network": "Polygon",
        //                         "tokenId": "0x78a0A62Fba6Fb21A83FE8a3433d44C73a4017A6f",
        //                         "transactionPrecision": "18",
        //                         "isWithdrawalFeeChargedToUser": true,
        //                         "canDeposit": true,
        //                         "canWithdraw": false,
        //                         "minDeposit": "0.00010",
        //                         "minWithdrawal": "0.00010"
        //                     },
        //                     {
        //                         "network": "Arbitrum",
        //                         "tokenId": "0xba0Dda8762C24dA9487f5FA026a9B64b695A07Ea",
        //                         "transactionPrecision": "18",
        //                         "isWithdrawalFeeChargedToUser": true,
        //                         "canDeposit": true,
        //                         "canWithdraw": true,
        //                         "minDeposit": "0.00010",
        //                         "minWithdrawal": "0.00010"
        //                     },
        //                     {
        //                         "network": "Ethereum",
        //                         "tokenId": "0xba0Dda8762C24dA9487f5FA026a9B64b695A07Ea",
        //                         "transactionPrecision": "18",
        //                         "isWithdrawalFeeChargedToUser": true,
        //                         "canDeposit": true,
        //                         "canWithdraw": true,
        //                         "minDeposit": "0.00010",
        //                         "minWithdrawal": "0.00010"
        //                     },
        //                     {
        //                         "network": "Arbitrum",
        //                         "tokenId": "0x78a0A62Fba6Fb21A83FE8a3433d44C73a4017A6f",
        //                         "transactionPrecision": "18",
        //                         "isWithdrawalFeeChargedToUser": true,
        //                         "canDeposit": true,
        //                         "canWithdraw": false,
        //                         "minDeposit": "0.00010",
        //                         "minWithdrawal": "0.00010"
        //                     },
        //                     {
        //                         "network": "Avalanche",
        //                         "tokenId": "0x78a0A62Fba6Fb21A83FE8a3433d44C73a4017A6f",
        //                         "transactionPrecision": "18",
        //                         "isWithdrawalFeeChargedToUser": true,
        //                         "canDeposit": true,
        //                         "canWithdraw": false,
        //                         "minDeposit": "0.00010",
        //                         "minWithdrawal": "0.00010"
        //                     },
        //                     {
        //                         "network": "Solana",
        //                         "tokenId": "DV3845GEAVXfwpyVGGgWbqBVCtzHdCXNCGfcdboSEuZz",
        //                         "transactionPrecision": "8",
        //                         "isWithdrawalFeeChargedToUser": true,
        //                         "canDeposit": true,
        //                         "canWithdraw": true,
        //                         "minDeposit": "0.00010",
        //                         "minWithdrawal": "0.00010"
        //                     },
        //                     {
        //                         "network": "Ethereum",
        //                         "tokenId": "0x78a0A62Fba6Fb21A83FE8a3433d44C73a4017A6f",
        //                         "transactionPrecision": "18",
        //                         "isWithdrawalFeeChargedToUser": true,
        //                         "canDeposit": true,
        //                         "canWithdraw": false,
        //                         "minDeposit": "0.00010",
        //                         "minWithdrawal": "0.00010"
        //                     }
        //                 ]
        //             },
        //             {
        //                 "asset": "BTC",
        //                 "isCollateral": true,
        //                 "loanToValue": "0.950000000",
        //                 "loanToValueFactor": "0.000000000",
        //                 "networkList":  [
        //                     {
        //                         "network": "Bitcoin",
        //                         "transactionPrecision": "8",
        //                         "isWithdrawalFeeChargedToUser": true,
        //                         "canDeposit": true,
        //                         "canWithdraw": true,
        //                         "minDeposit": "0.00010",
        //                         "minWithdrawal": "0.00010"
        //                     }
        //                 ]
        //             },
        //             {
        //                 "asset": "USDT.ARB",
        //                 "isCollateral": true,
        //                 "loanToValue": "0.950000000",
        //                 "loanToValueFactor": "0.000000000",
        //                 "networkList": [
        //                     {
        //                         "network": "Arbitrum",
        //                         "tokenId": "0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9",
        //                         "transactionPrecision": "18",
        //                         "isWithdrawalFeeChargedToUser": true,
        //                         "canDeposit": true,
        //                         "canWithdraw": true,
        //                         "minDeposit": "0.00010",
        //                         "minWithdrawal": "0.00010"
        //                     }
        //                 ]
        //             },
        //             ...
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object result = new Dictionary<string, object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object currency = getValue(data, i);
            object fullId = this.safeString(currency, "asset", "");
            object parts = ((string)fullId).Split(new [] {((string)".")}, StringSplitOptions.None).ToList<object>();
            object id = getValue(parts, 0);
            object code = this.safeCurrencyCode(id);
            object networks = new Dictionary<string, object>() {};
            object chains = this.safeList(currency, "networkList", new List<object>() {});
            object currencyMaxPrecision = null;
            object currencyDepositEnabled = null;
            object currencyWithdrawEnabled = null;
            for (object j = 0; isLessThan(j, getArrayLength(chains)); postFixIncrement(ref j))
            {
                object chain = getValue(chains, j);
                object networkId = this.safeString(chain, "network");
                object networkCode = this.networkIdToCode(networkId);
                object deposit = this.safeBool(chain, "canDeposit");
                object withdraw = this.safeBool(chain, "canWithdraw");
                object active = (isTrue(deposit) && isTrue(withdraw));
                object minDeposit = this.safeString(chain, "minDeposit");
                object minWithdrawal = this.safeString(chain, "minWithdrawal");
                object precision = this.parsePrecision(this.safeString(chain, "transactionPrecision"));
                ((IDictionary<string,object>)networks)[(string)networkCode] = new Dictionary<string, object>() {
                    { "id", networkId },
                    { "network", networkCode },
                    { "margin", null },
                    { "deposit", deposit },
                    { "withdraw", withdraw },
                    { "active", active },
                    { "fee", null },
                    { "precision", this.parseNumber(precision) },
                    { "limits", new Dictionary<string, object>() {
                        { "deposit", new Dictionary<string, object>() {
                            { "min", minDeposit },
                            { "max", null },
                        } },
                        { "withdraw", new Dictionary<string, object>() {
                            { "min", minWithdrawal },
                            { "max", null },
                        } },
                    } },
                    { "info", chain },
                };
                if (isTrue(isTrue((isEqual(currencyDepositEnabled, null))) || isTrue(deposit)))
                {
                    currencyDepositEnabled = deposit;
                }
                if (isTrue(isTrue((isEqual(currencyWithdrawEnabled, null))) || isTrue(withdraw)))
                {
                    currencyWithdrawEnabled = withdraw;
                }
                if (isTrue(isTrue((isEqual(currencyMaxPrecision, null))) || isTrue(Precise.stringGt(currencyMaxPrecision, precision))))
                {
                    currencyMaxPrecision = precision;
                }
            }
            if (isTrue(inOp(result, code)))
            {
                // checking for specific ids as USDC.ARB
                networks = this.extend(getValue(getValue(result, code), "networks"), networks);
            }
            ((IDictionary<string,object>)result)[(string)code] = new Dictionary<string, object>() {
                { "id", id },
                { "code", code },
                { "name", null },
                { "type", null },
                { "active", null },
                { "deposit", currencyDepositEnabled },
                { "withdraw", currencyWithdrawEnabled },
                { "fee", null },
                { "precision", this.parseNumber(currencyMaxPrecision) },
                { "limits", new Dictionary<string, object>() {
                    { "amount", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                    { "withdraw", new Dictionary<string, object>() {
                        { "min", null },
                        { "max", null },
                    } },
                } },
                { "networks", networks },
                { "info", currency },
            };
        }
        return result;
    }

    /**
     * @method
     * @name oxfun#fetchTickers
     * @description fetches price tickers for multiple markets, statistical information calculated over the past 24 hours for each market
     * @see https://docs.ox.fun/?json#get-v3-tickers
     * @param {string[]|undefined} symbols unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [ticker structures]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTickers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object response = await this.publicGetV3Tickers(parameters);
        //
        //     {
        //         "success": true,
        //         "data": [
        //             {
        //                 "marketCode": "NII-USDT",
        //                 "markPrice": "0",
        //                 "open24h": "0",
        //                 "high24h": "0",
        //                 "low24h": "0",
        //                 "volume24h": "0",
        //                 "currencyVolume24h": "0",
        //                 "openInterest": "0",
        //                 "lastTradedPrice": "0",
        //                 "lastTradedQuantity": "0",
        //                 "lastUpdatedAt": "1714853388621"
        //             },
        //             {
        //                 "marketCode": "GEC-USDT",
        //                 "markPrice": "0",
        //                 "open24h": "0",
        //                 "high24h": "0",
        //                 "low24h": "0",
        //                 "volume24h": "0",
        //                 "currencyVolume24h": "0",
        //                 "openInterest": "0",
        //                 "lastTradedPrice": "0",
        //                 "lastTradedQuantity": "0",
        //                 "lastUpdatedAt": "1714853388621"
        //             },
        //             {
        //                 "marketCode": "DYM-USD-SWAP-LIN",
        //                 "markPrice": "3.321",
        //                 "open24h": "3.315",
        //                 "high24h": "3.356",
        //                 "low24h": "3.255",
        //                 "volume24h": "0",
        //                 "currencyVolume24h": "0",
        //                 "openInterest": "1768.1",
        //                 "lastTradedPrice": "3.543",
        //                 "lastTradedQuantity": "1.0",
        //                 "lastUpdatedAt": "1714853388102"
        //             },
        //             ...
        //         ]
        //     }
        //
        object tickers = this.safeList(response, "data", new List<object>() {});
        return this.parseTickers(tickers, symbols);
    }

    /**
     * @method
     * @name oxfun#fetchTicker
     * @description fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
     * @see https://docs.ox.fun/?json#get-v3-tickers
     * @param {string} symbol unified symbol of the market to fetch the ticker for
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [ticker structure]{@link https://docs.ccxt.com/#/?id=ticker-structure}
     */
    public async override Task<object> fetchTicker(object symbol, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "marketCode", getValue(market, "id") },
        };
        object response = await this.publicGetV3Tickers(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "data": [
        //             {
        //                 "marketCode": "BTC-USD-SWAP-LIN",
        //                 "markPrice": "64276",
        //                 "open24h": "63674",
        //                 "high24h": "64607",
        //                 "low24h": "62933",
        //                 "volume24h": "306317655.80000",
        //                 "currencyVolume24h": "48.06810",
        //                 "openInterest": "72.39250",
        //                 "lastTradedPrice": "64300.0",
        //                 "lastTradedQuantity": "1.0",
        //                 "lastUpdatedAt": "1714925196034"
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object ticker = this.safeDict(data, 0, new Dictionary<string, object>() {});
        return this.parseTicker(ticker, market);
    }

    public override object parseTicker(object ticker, object market = null)
    {
        //
        //     {
        //         "marketCode": "BTC-USD-SWAP-LIN",
        //         "markPrice": "64276",
        //         "open24h": "63674",
        //         "high24h": "64607",
        //         "low24h": "62933",
        //         "volume24h": "306317655.80000",
        //         "currencyVolume24h": "48.06810",
        //         "openInterest": "72.39250",
        //         "lastTradedPrice": "64300.0",
        //         "lastTradedQuantity": "1.0",
        //         "lastUpdatedAt": "1714925196034"
        //     }
        //
        object timestamp = this.safeInteger(ticker, "lastUpdatedAt");
        object marketId = this.safeString(ticker, "marketCode");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object last = this.safeString(ticker, "lastTradedPrice");
        return this.safeTicker(new Dictionary<string, object>() {
            { "symbol", symbol },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "high", this.safeString(ticker, "high24h") },
            { "low", this.safeString(ticker, "low24h") },
            { "bid", null },
            { "bidVolume", null },
            { "ask", null },
            { "askVolume", null },
            { "vwap", null },
            { "open", this.safeString(ticker, "open24h") },
            { "close", last },
            { "last", last },
            { "previousClose", null },
            { "change", null },
            { "percentage", null },
            { "average", null },
            { "baseVolume", this.safeString(ticker, "currencyVolume24h") },
            { "quoteVolume", null },
            { "markPrice", this.safeString(ticker, "markPrice") },
            { "info", ticker },
        }, market);
    }

    /**
     * @method
     * @name oxfun#fetchOHLCV
     * @description fetches historical candlestick data containing the open, high, low, and close price, and the volume of a market
     * @see https://docs.ox.fun/?json#get-v3-candles
     * @param {string} symbol unified symbol of the market to fetch OHLCV data for
     * @param {string} timeframe the length of time each candle represents
     * @param {int} [since] timestamp in ms of the earliest candle to fetch (default 24 hours ago)
     * @param {int} [limit] the maximum amount of candles to fetch (default 200, max 500)
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest candle to fetch (default now)
     * @returns {int[][]} A list of candles ordered as timestamp, open, high, low, close, volume
     */
    public async override Task<object> fetchOHLCV(object symbol, object timeframe = null, object since = null, object limit = null, object parameters = null)
    {
        timeframe ??= "1m";
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        timeframe = this.safeString(this.timeframes, timeframe, timeframe);
        object request = new Dictionary<string, object>() {
            { "marketCode", getValue(market, "id") },
            { "timeframe", timeframe },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since; // startTime and endTime must be within 7 days of each other
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object until = this.safeInteger(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = until;
            parameters = this.omit(parameters, "until");
        } else if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = this.sum(since, multiply(multiply(multiply(multiply(7, 24), 60), 60), 1000)); // for the exchange not to throw an exception if since is younger than 7 days
        }
        object response = await this.publicGetV3Candles(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "timeframe": "3600s",
        //         "data": [
        //             {
        //                 "open": "0.03240000",
        //                 "high": "0.03240000",
        //                 "low": "0.03240000",
        //                 "close": "0.03240000",
        //                 "volume": "0",
        //                 "currencyVolume": "0",
        //                 "openedAt": "1714906800000"
        //             },
        //             {
        //                 "open": "0.03240000",
        //                 "high": "0.03240000",
        //                 "low": "0.03240000",
        //                 "close": "0.03240000",
        //                 "volume": "0",
        //                 "currencyVolume": "0",
        //                 "openedAt": "1714903200000"
        //             },
        //             ...
        //         ]
        //     }
        //
        object result = this.safeList(response, "data", new List<object>() {});
        return this.parseOHLCVs(result, market, timeframe, since, limit);
    }

    public override object parseOHLCV(object ohlcv, object market = null)
    {
        //
        //     {
        //         "open": "0.03240000",
        //         "high": "0.03240000",
        //         "low": "0.03240000",
        //         "close": "0.03240000",
        //         "volume": "0",
        //         "currencyVolume": "0",
        //         "openedAt": "1714906800000"
        //     }
        //
        return new List<object> {this.safeInteger(ohlcv, "openedAt"), this.safeNumber(ohlcv, "open"), this.safeNumber(ohlcv, "high"), this.safeNumber(ohlcv, "low"), this.safeNumber(ohlcv, "close"), this.safeNumber(ohlcv, "currencyVolume")};
    }

    /**
     * @method
     * @name oxfun#fetchOrderBook
     * @description fetches information on open orders with bid (buy) and ask (sell) prices, volumes and other data
     * @see https://docs.ox.fun/?json#get-v3-depth
     * @param {string} symbol unified symbol of the market to fetch the order book for
     * @param {int} [limit] the maximum amount of order book entries to return (default 5, max 100)
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} A dictionary of [order book structures]{@link https://docs.ccxt.com/#/?id=order-book-structure} indexed by market symbols
     */
    public async override Task<object> fetchOrderBook(object symbol, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "marketCode", getValue(market, "id") },
        };
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["level"] = limit;
        }
        object response = await this.publicGetV3Depth(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "level": "5",
        //         "data": {
        //             "marketCode": "BTC-USD-SWAP-LIN",
        //             "lastUpdatedAt": "1714933499266",
        //             "asks": [
        //                 [ 64073.0, 8.4622 ],
        //                 [ 64092.0, 8.1912 ],
        //                 [ 64111.0, 8.0669 ],
        //                 [ 64130.0, 11.7195 ],
        //                 [ 64151.0, 10.1798 ]
        //             ],
        //             "bids": [
        //                 [ 64022.0, 10.1292 ],
        //                 [ 64003.0, 8.1619 ],
        //                 [ 64000.0, 1.0 ],
        //                 [ 63984.0, 12.7724 ],
        //                 [ 63963.0, 11.0073 ]
        //             ]
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        object timestamp = this.safeInteger(data, "lastUpdatedAt");
        return this.parseOrderBook(data, getValue(market, "symbol"), timestamp);
    }

    /**
     * @method
     * @name oxfun#fetchFundingRates
     * @description fetch the current funding rates for multiple markets
     * @see https://docs.ox.fun/?json#get-v3-funding-estimates
     * @param {string[]} symbols unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {Order[]} an array of [funding rate structures]{@link https://docs.ccxt.com/#/?id=funding-rate-structure}
     */
    public async override Task<object> fetchFundingRates(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object response = await this.publicGetV3FundingEstimates(parameters);
        //
        //     {
        //         "success": true,
        //         "data": [
        //             {
        //                 "marketCode": "OX-USD-SWAP-LIN",
        //                 "fundingAt": "1715515200000",
        //                 "estFundingRate": "0.000200000"
        //             },
        //             {
        //                 "marketCode": "BTC-USD-SWAP-LIN",
        //                 "fundingAt": "1715515200000",
        //                 "estFundingRate": "0.000003"
        //             },
        //             ...
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseFundingRates(data, symbols);
    }

    public override object parseFundingRate(object fundingRate, object market = null)
    {
        //
        //     {
        //         "marketCode": "OX-USD-SWAP-LIN",
        //         "fundingAt": "1715515200000",
        //         "estFundingRate": "0.000200000"
        //     }
        //
        object symbol = this.safeString(fundingRate, "marketCode");
        market = this.market(symbol);
        object estFundingRateTimestamp = this.safeInteger(fundingRate, "fundingAt");
        return new Dictionary<string, object>() {
            { "info", fundingRate },
            { "symbol", getValue(market, "symbol") },
            { "markPrice", null },
            { "indexPrice", null },
            { "interestRate", this.parseNumber("0") },
            { "estimatedSettlePrice", null },
            { "timestamp", estFundingRateTimestamp },
            { "datetime", this.iso8601(estFundingRateTimestamp) },
            { "fundingRate", this.safeNumber(fundingRate, "estFundingRate") },
            { "fundingTimestamp", null },
            { "fundingDatetime", null },
            { "nextFundingRate", null },
            { "nextFundingTimestamp", null },
            { "nextFundingDatetime", null },
            { "previousFundingRate", null },
            { "previousFundingTimestamp", null },
            { "previousFundingDatetime", null },
            { "interval", null },
        };
    }

    /**
     * @method
     * @name oxfun#fetchFundingRateHistory
     * @description Fetches the history of funding rates
     * @see https://docs.ox.fun/?json#get-v3-funding-rates
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch (default 24 hours ago)
     * @param {int} [limit] the maximum amount of trades to fetch (default 200, max 500)
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest trade to fetch (default now)
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> fetchFundingRateHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "marketCode", getValue(market, "id") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since; // startTime and endTime must be within 7 days of each other
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object until = this.safeInteger(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = until;
            parameters = this.omit(parameters, "until");
        }
        object response = await this.publicGetV3FundingRates(this.extend(request, parameters));
        //
        //     {
        //         success: true,
        //         data: [
        //         {
        //             marketCode: 'NEAR-USD-SWAP-LIN',
        //             fundingRate: '-0.000010000',
        //             createdAt: '1715428870755'
        //         },
        //         {
        //             marketCode: 'ENA-USD-SWAP-LIN',
        //             fundingRate: '0.000150000',
        //             createdAt: '1715428868616'
        //         },
        //         ...
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseFundingRateHistories(data, market, since, limit);
    }

    public override object parseFundingRateHistory(object info, object market = null)
    {
        //
        //     {
        //         success: true,
        //         data: [
        //         {
        //             marketCode: 'NEAR-USD-SWAP-LIN',
        //             fundingRate: '-0.000010000',
        //             createdAt: '1715428870755'
        //         },
        //         {
        //             marketCode: 'ENA-USD-SWAP-LIN',
        //             fundingRate: '0.000150000',
        //             createdAt: '1715428868616'
        //         },
        //         ...
        //     }
        //
        object marketId = this.safeString(info, "marketCode");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object timestamp = this.safeInteger(info, "createdAt");
        return new Dictionary<string, object>() {
            { "info", info },
            { "symbol", symbol },
            { "fundingRate", this.safeNumber(info, "fundingRate") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
        };
    }

    /**
     * @method
     * @name oxfun#fetchFundingHistory
     * @description fetches the history of funding payments
     * @see https://docs.ox.fun/?json#get-v3-funding
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch (default 24 hours ago)
     * @param {int} [limit] the maximum amount of trades to fetch (default 200, max 500)
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest trade to fetch (default now)
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> fetchFundingHistory(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "marketCode", getValue(market, "id") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since; // startTime and endTime must be within 7 days of each other
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object until = this.safeInteger(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = until;
            parameters = this.omit(parameters, "until");
        }
        object response = await this.privateGetV3Funding(this.extend(request, parameters));
        //
        //     {
        //         success: true,
        //         data: [
        //             {
        //                 id: '966709913041305605',
        //                 marketCode: 'ETH-USD-SWAP-LIN',
        //                 payment: '-0.00430822',
        //                 fundingRate: '0.000014',
        //                 position: '0.001',
        //                 indexPrice: '3077.3',
        //                 createdAt: '1715086852890'
        //             },
        //             {
        //                 id: '966698111997509637',
        //                 marketCode: 'ETH-USD-SWAP-LIN',
        //                 payment: '-0.0067419',
        //                 fundingRate: '0.000022',
        //                 position: '0.001',
        //                 indexPrice: '3064.5',
        //                 createdAt: '1715083251516'
        //             },
        //             ...
        //         ]
        //     }
        //
        object result = this.safeList(response, "data", new List<object>() {});
        return this.parseIncomes(result, market, since, limit);
    }

    public override object parseIncome(object income, object market = null)
    {
        //
        //     {
        //         id: '966709913041305605',
        //         marketCode: 'ETH-USD-SWAP-LIN',
        //         payment: '-0.00430822',
        //         fundingRate: '0.000014',
        //         position: '0.001',
        //         indexPrice: '3077.3',
        //         createdAt: '1715086852890'
        //     },
        //
        object marketId = this.safeString(income, "marketCode");
        object symbol = this.safeSymbol(marketId, market);
        object amount = this.safeNumber(income, "payment");
        object code = this.safeCurrencyCode("OX");
        object id = this.safeString(income, "id");
        object timestamp = this.safeTimestamp(income, "createdAt");
        object rate = this.safeNumber(income, "fundingRate");
        return new Dictionary<string, object>() {
            { "info", income },
            { "symbol", symbol },
            { "code", code },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "id", id },
            { "amount", amount },
            { "rate", rate },
        };
    }

    /**
     * @method
     * @name oxfun#fetchLeverageTiers
     * @description retrieve information on the maximum leverage, and maintenance margin for trades of varying trade sizes, if a market has a leverage tier of 0, then the leverage tiers cannot be obtained for this market
     * @see https://docs.ox.fun/?json#get-v3-leverage-tiers
     * @param {string[]} [symbols] list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [leverage tiers structures]{@link https://docs.ccxt.com/#/?id=leverage-tiers-structure}, indexed by market symbols
     */
    public async override Task<object> fetchLeverageTiers(object symbols = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.publicGetV3LeverageTiers(parameters);
        //
        //     {
        //         success: true,
        //         data: [
        //            {
        //                 marketCode: 'SOL-USD-SWAP-LIN',
        //                 tiers: [
        //                     {
        //                         tier: '1',
        //                         leverage: '10',
        //                         positionFloor: '0',
        //                         positionCap: '200000000',
        //                         initialMargin: '0.1',
        //                         maintenanceMargin: '0.05',
        //                         maintenanceAmount: '0'
        //                     },
        //                     {
        //                         tier: '2',
        //                         leverage: '5',
        //                         positionFloor: '200000000',
        //                         positionCap: '280000000',
        //                         initialMargin: '0.2',
        //                         maintenanceMargin: '0.1',
        //                         maintenanceAmount: '7000000'
        //                     },
        //                     {
        //                         tier: '3',
        //                         leverage: '4',
        //                         positionFloor: '280000000',
        //                         positionCap: '460000000',
        //                         initialMargin: '0.25',
        //                         maintenanceMargin: '0.125',
        //                         maintenanceAmount: '14000000'
        //                     },
        //                     ...
        //                 ]
        //             },
        //             ...
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseLeverageTiers(data, symbols, "marketCode");
    }

    public override object parseMarketLeverageTiers(object info, object market = null)
    {
        //
        //     {
        //         marketCode: 'SOL-USD-SWAP-LIN',
        //         tiers: [
        //             {
        //                 tier: '1',
        //                 leverage: '10',
        //                 positionFloor: '0',
        //                 positionCap: '200000000',
        //                 initialMargin: '0.1',
        //                 maintenanceMargin: '0.05',
        //                 maintenanceAmount: '0'
        //             ...
        //         ]
        //     },
        //
        object marketId = this.safeString(info, "marketCode");
        market = this.safeMarket(marketId, market);
        object listOfTiers = this.safeList(info, "tiers", new List<object>() {});
        object tiers = new List<object>() {};
        for (object j = 0; isLessThan(j, getArrayLength(listOfTiers)); postFixIncrement(ref j))
        {
            object tier = getValue(listOfTiers, j);
            ((IList<object>)tiers).Add(new Dictionary<string, object>() {
                { "tier", this.safeNumber(tier, "tier") },
                { "symbol", this.safeSymbol(marketId, market) },
                { "currency", getValue(market, "settle") },
                { "minNotional", this.safeNumber(tier, "positionFloor") },
                { "maxNotional", this.safeNumber(tier, "positionCap") },
                { "maintenanceMarginRate", this.safeNumber(tier, "maintenanceMargin") },
                { "maxLeverage", this.safeNumber(tier, "leverage") },
                { "info", tier },
            });
        }
        return tiers;
    }

    /**
     * @method
     * @name oxfun#fetchTrades
     * @description get the list of most recent trades for a particular symbol
     * @see https://docs.ox.fun/?json#get-v3-exchange-trades
     * @param {string} symbol unified symbol of the market to fetch trades for
     * @param {int} [since] timestamp in ms of the earliest trade to fetch (default 24 hours ago)
     * @param {int} [limit] the maximum amount of trades to fetch (default 200, max 500)
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest trade to fetch (default now)
     * @returns {Trade[]} a list of [trade structures]{@link https://docs.ccxt.com/#/?id=public-trades}
     */
    public async override Task<object> fetchTrades(object symbol, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "marketCode", getValue(market, "id") },
        };
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since; // startTime and endTime must be within 7 days of each other
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object until = this.safeInteger(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = until;
            parameters = this.omit(parameters, "until");
        } else if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = this.sum(since, multiply(multiply(multiply(multiply(7, 24), 60), 60), 1000)); // for the exchange not to throw an exception if since is younger than 7 days
        }
        object response = await this.publicGetV3ExchangeTrades(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "data": [
        //             {
        //                 "marketCode": "BTC-USD-SWAP-LIN",
        //                 "matchPrice": "63900",
        //                 "matchQuantity": "1",
        //                 "side": "SELL",
        //                 "matchType": "TAKER",
        //                 "matchedAt": "1714934112352"
        //             },
        //             ...
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTrades(data, market, since, limit);
    }

    /**
     * @method
     * @name oxfun#fetchMyTrades
     * @description fetch all trades made by the user
     * @see https://docs.ox.fun/?json#get-v3-trades
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch trades for
     * @param {int} [limit] the maximum amount of trades to fetch (default 200, max 500)
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] timestamp in ms of the latest trade to fetch (default now)
     * @returns {Trade[]} a list of [trade structures]{@link https://github.com/ccxt/ccxt/wiki/Manual#trade-structure}
     */
    public async override Task<object> fetchMyTrades(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
            ((IDictionary<string,object>)request)["marketCode"] = getValue(market, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since;
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object until = this.safeInteger(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = until;
            parameters = this.omit(parameters, "until");
        } else if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = this.sum(since, multiply(multiply(multiply(multiply(7, 24), 60), 60), 1000)); // for the exchange not to throw an exception if since is younger than 7 days
        }
        object response = await this.privateGetV3Trades(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "data": [
        //             {
        //                 "orderId": "1000104903698",
        //                 "clientOrderId": "1715000260094",
        //                 "matchId": "400017129522773178",
        //                 "marketCode": "ETH-USD-SWAP-LIN",
        //                 "side": "BUY",
        //                 "matchedQuantity": "0.001",
        //                 "matchPrice": "3100.2",
        //                 "total": "310.02",
        //                 "orderMatchType": "MAKER",
        //                 "feeAsset": "OX",
        //                 "fee": "0.062004",
        //                 "source": "0",
        //                 "matchedAt": "1715000267420"
        //             }
        //         ]
        //     }
        //
        object result = this.safeList(response, "data", new List<object>() {});
        return this.parseTrades(result, market, since, limit);
    }

    public override object parseTrade(object trade, object market = null)
    {
        //
        // public fetchTrades
        //
        //     {
        //         "marketCode": "BTC-USD-SWAP-LIN",
        //         "matchPrice": "63900",
        //         "matchQuantity": "1",
        //         "side": "SELL",
        //         "matchType": "TAKER",
        //         "matchedAt": "1714934112352"
        //     }
        //
        //
        // private fetchMyTrades
        //
        //     {
        //         "orderId": "1000104903698",
        //         "clientOrderId": "1715000260094",
        //         "matchId": "400017129522773178",
        //         "marketCode": "ETH-USD-SWAP-LIN",
        //         "side": "BUY",
        //         "matchedQuantity": "0.001",
        //         "matchPrice": "3100.2",
        //         "total": "310.02",
        //         "orderMatchType": "MAKER",
        //         "feeAsset": "OX",
        //         "fee": "0.062004",
        //         "source": "0",
        //         "matchedAt": "1715000267420"
        //     }
        //
        object marketId = this.safeString(trade, "marketCode");
        market = this.safeMarket(marketId, market);
        object symbol = getValue(market, "symbol");
        object timestamp = this.safeInteger(trade, "matchedAt");
        object fee = new Dictionary<string, object>() {
            { "cost", this.safeString(trade, "fee") },
            { "currency", this.safeCurrencyCode(this.safeString(trade, "feeAsset")) },
        };
        return this.safeTrade(new Dictionary<string, object>() {
            { "id", this.safeString(trade, "matchId") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "symbol", symbol },
            { "type", null },
            { "order", this.safeString(trade, "orderId") },
            { "side", this.safeStringLower(trade, "side") },
            { "takerOrMaker", this.safeStringLower2(trade, "matchType", "orderMatchType") },
            { "price", this.safeString(trade, "matchPrice") },
            { "amount", this.safeString2(trade, "matchQuantity", "matchedQuantity") },
            { "cost", null },
            { "fee", fee },
            { "info", trade },
        }, market);
    }

    /**
     * @method
     * @name oxfun#fetchBalance
     * @description query for balance and get the amount of funds available for trading or funds locked in orders
     * @see https://docs.ox.fun/?json#get-v3-balances
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.asset] currency id, if empty the exchange returns info about all currencies
     * @param {string} [params.subAcc] Name of sub account. If no subAcc is given, then the response contains only the account linked to the API-Key.
     * @returns {object} a [balance structure]{@link https://docs.ccxt.com/#/?id=balance-structure}
     */
    public async override Task<object> fetchBalance(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object response = await this.privateGetV3Balances(parameters);
        //
        //     {
        //         "success": true,
        //         "data": [
        //             {
        //                 "accountId": "106490",
        //                 "name": "main",
        //                 "balances": [
        //                     {
        //                         "asset": "OX",
        //                         "total": "-7.55145065000",
        //                         "available": "-71.16445065000",
        //                         "reserved": "0",
        //                         "lastUpdatedAt": "1715000448946"
        //                     },
        //                     {
        //                         "asset": "ETH",
        //                         "total": "0.01",
        //                         "available": "0.01",
        //                         "reserved": "0",
        //                         "lastUpdatedAt": "1714914512750"
        //                     },
        //                     ...
        //                 ]
        //             },
        //             ...
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object balance = getValue(data, 0);
        object subAcc = this.safeString(parameters, "subAcc");
        if (isTrue(!isEqual(subAcc, null)))
        {
            for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
            {
                object b = getValue(data, i);
                object name = this.safeString(b, "name");
                if (isTrue(isEqual(name, subAcc)))
                {
                    balance = b;
                    break;
                }
            }
        }
        return this.parseBalance(balance);
    }

    public override object parseBalance(object balance)
    {
        //
        //     {
        //         "accountId": "106490",
        //         "name": "main",
        //         "balances": [
        //             {
        //                 "asset": "OX",
        //                 "total": "-7.55145065000",
        //                 "available": "-71.16445065000",
        //                 "reserved": "0",
        //                 "lastUpdatedAt": "1715000448946"
        //             },
        //             {
        //                 "asset": "ETH",
        //                 "total": "0.01",
        //                 "available": "0.01",
        //                 "reserved": "0",
        //                 "lastUpdatedAt": "1714914512750"
        //             },
        //             ...
        //         ]
        //     }
        //
        object result = new Dictionary<string, object>() {
            { "info", balance },
        };
        object balances = this.safeList(balance, "balances", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(balances)); postFixIncrement(ref i))
        {
            object balanceEntry = getValue(balances, i);
            object currencyId = this.safeString(balanceEntry, "asset");
            object code = this.safeCurrencyCode(currencyId);
            object account = this.account();
            ((IDictionary<string,object>)account)["total"] = this.safeString(balanceEntry, "total");
            ((IDictionary<string,object>)account)["free"] = this.safeString(balanceEntry, "available");
            ((IDictionary<string,object>)account)["used"] = this.safeString(balanceEntry, "reserved");
            ((IDictionary<string,object>)result)[(string)code] = account;
        }
        return this.safeBalance(result);
    }

    /**
     * @method
     * @name oxfun#fetchAccounts
     * @description fetch subaccounts associated with a profile
     * @see https://docs.ox.fun/?json#get-v3-account-names
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a dictionary of [account structures]{@link https://docs.ccxt.com/#/?id=account-structure} indexed by the account type
     */
    public async override Task<object> fetchAccounts(object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        // this endpoint can only be called using API keys paired with the parent account! Returns all active subaccounts.
        object response = await this.privateGetV3AccountNames(parameters);
        //
        //     {
        //         "success": true,
        //         "data": [
        //             {
        //                 "accountId": "106526",
        //                 "name": "testSubAccount"
        //             },
        //             ...
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseAccounts(data, parameters);
    }

    public override object parseAccount(object account)
    {
        //
        //     {
        //         "accountId": "106526",
        //         "name": "testSubAccount"
        //     },
        //
        return new Dictionary<string, object>() {
            { "id", this.safeString(account, "accountId") },
            { "type", null },
            { "code", null },
            { "info", account },
        };
    }

    /**
     * @method
     * @name oxfun#transfer
     * @description transfer currency internally between wallets on the same account
     * @see https://docs.ox.fun/?json#post-v3-transfer
     * @param {string} code unified currency code
     * @param {float} amount amount to transfer
     * @param {string} fromAccount account id to transfer from
     * @param {string} toAccount account id to transfer to
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} a [transfer structure]{@link https://docs.ccxt.com/#/?id=transfer-structure}
     */
    public async override Task<object> transfer(object code, object amount, object fromAccount, object toAccount, object parameters = null)
    {
        // transferring funds between sub-accounts is restricted to API keys linked to the parent account.
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "asset", getValue(currency, "id") },
            { "quantity", this.currencyToPrecision(code, amount) },
            { "fromAccount", fromAccount },
            { "toAccount", toAccount },
        };
        object response = await this.privatePostV3Transfer(this.extend(request, parameters));
        //
        //     {
        //         timestamp: 1715430036267,
        //         datetime: '2024-05-11T12:20:36.267Z',
        //         currency: 'OX',
        //         amount: 10,
        //         fromAccount: '106464',
        //         toAccount: '106570',
        //         info: {
        //         asset: 'OX',
        //         quantity: '10',
        //         fromAccount: '106464',
        //         toAccount: '106570',
        //         transferredAt: '1715430036267'
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseTransfer(data, currency);
    }

    /**
     * @method
     * @name oxfun#fetchTransfers
     * @description fetch a history of internal transfers made on an account
     * @see https://docs.ox.fun/?json#get-v3-transfer
     * @param {string} code unified currency code of the currency transferred
     * @param {int} [since] the earliest time in ms to fetch transfers for (default 24 hours ago)
     * @param {int} [limit] the maximum number of transfer structures to retrieve (default 50, max 200)
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch transfers for (default time now)
     * @returns {object[]} a list of [transfer structures]{@link https://docs.ccxt.com/#/?id=transfer-structure}
     */
    public async override Task<object> fetchTransfers(object code = null, object since = null, object limit = null, object parameters = null)
    {
        // API keys linked to the parent account can get all account transfers, while API keys linked to a sub-account can only see transfers where the sub-account is either the "fromAccount" or "toAccount"
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["asset"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since; // startTime and endTime must be within 7 days of each other
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object until = this.safeInteger(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = until;
            parameters = this.omit(parameters, "until");
        } else if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = this.sum(since, multiply(multiply(multiply(multiply(7, 24), 60), 60), 1000)); // for the exchange not to throw an exception if since is younger than 7 days
        }
        object response = await this.privateGetV3Transfer(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "data": [
        //             {
        //                 "asset": "USDT",
        //                 "quantity": "5",
        //                 "fromAccount": "106490",
        //                 "toAccount": "106526",
        //                 "id": "966706320886267905",
        //                 "status": "COMPLETED",
        //                 "transferredAt": "1715085756708"
        //             },
        //             ...
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseTransfers(data, currency, since, limit);
    }

    public override object parseTransfer(object transfer, object currency = null)
    {
        //
        // fetchTransfers
        //
        //     {
        //         "asset": "USDT",
        //         "quantity": "5",
        //         "fromAccount": "106490",
        //         "toAccount": "106526",
        //         "id": "966706320886267905",
        //         "status": "COMPLETED",
        //         "transferredAt": "1715085756708"
        //     }
        //
        object timestamp = this.safeInteger(transfer, "transferredAt");
        object currencyId = this.safeString(transfer, "asset");
        return new Dictionary<string, object>() {
            { "id", this.safeString(transfer, "id") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "currency", this.safeCurrencyCode(currencyId, currency) },
            { "amount", this.safeNumber(transfer, "quantity") },
            { "fromAccount", this.safeString(transfer, "fromAccount") },
            { "toAccount", this.safeString(transfer, "toAccount") },
            { "status", this.parseTransferStatus(this.safeString(transfer, "status")) },
            { "info", transfer },
        };
    }

    public virtual object parseTransferStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "COMPLETED", "ok" },
        };
        return this.safeString(statuses, status, status);
    }

    /**
     * @method
     * @name oxfun#fetchDepositAddress
     * @description fetch the deposit address for a currency associated with this account
     * @see https://docs.ox.fun/?json#get-v3-deposit-addresses
     * @param {string} code unified currency code
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.network] network for fetch deposit address
     * @returns {object} an [address structure]{@link https://docs.ccxt.com/#/?id=address-structure}
     */
    public async override Task<object> fetchDepositAddress(object code, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object networkCode = this.safeString(parameters, "network");
        object networkId = this.networkCodeToId(networkCode, code);
        if (isTrue(isEqual(networkId, null)))
        {
            throw new BadRequest ((string)add(this.id, " fetchDepositAddress() require network parameter")) ;
        }
        await this.loadMarkets();
        object currency = this.currency(code);
        object request = new Dictionary<string, object>() {
            { "asset", getValue(currency, "id") },
            { "network", networkId },
        };
        parameters = this.omit(parameters, "network");
        object response = await this.privateGetV3DepositAddresses(this.extend(request, parameters));
        //
        //     {"success":true,"data":{"address":"0x998dEc76151FB723963Bd8AFD517687b38D33dE8"}}
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseDepositAddress(data, currency);
    }

    public override object parseDepositAddress(object depositAddress, object currency = null)
    {
        //
        //     {"address":"0x998dEc76151FB723963Bd8AFD517687b38D33dE8"}
        //
        object address = this.safeString(depositAddress, "address");
        this.checkAddress(address);
        return new Dictionary<string, object>() {
            { "info", depositAddress },
            { "currency", getValue(currency, "code") },
            { "network", null },
            { "address", address },
            { "tag", null },
        };
    }

    /**
     * @method
     * @name oxfun#fetchDeposits
     * @description fetch all deposits made to an account
     * @see https://docs.ox.fun/?json#get-v3-deposit
     * @param {string} code unified currency code of the currency transferred
     * @param {int} [since] the earliest time in ms to fetch transfers for (default 24 hours ago)
     * @param {int} [limit] the maximum number of transfer structures to retrieve (default 50, max 200)
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch transfers for (default time now)
     * @returns {object[]} a list of [transfer structures]{@link https://docs.ccxt.com/#/?id=transfer-structure}
     */
    public async override Task<object> fetchDeposits(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["asset"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since; // startTime and endTime must be within 7 days of each other
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object until = this.safeInteger(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = until;
            parameters = this.omit(parameters, "until");
        }
        object response = await this.privateGetV3Deposit(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "data": [
        //             {
        //                 "asset":"USDC",
        //                 "network":"Ethereum",
        //                 "address": "0x998dEc76151FB723963Bd8AFD517687b38D33dE8",
        //                 "quantity":"50",
        //                 "id":"5914",
        //                 "status": "COMPLETED",
        //                 "txId":"0xf5e79663830a0c6f94d46638dcfbc134566c12facf1832396f81ecb55d3c75dc",
        //                 "creditedAt":"1714821645154"
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            ((IDictionary<string,object>)getValue(data, i))["type"] = "deposit";
        }
        return this.parseTransactions(data, currency, since, limit);
    }

    /**
     * @method
     * @name oxfun#fetchWithdrawals
     * @description fetch all withdrawals made from an account
     * @see https://docs.ox.fun/?json#get-v3-withdrawal
     * @param {string} code unified currency code of the currency transferred
     * @param {int} [since] the earliest time in ms to fetch transfers for (default 24 hours ago)
     * @param {int} [limit] the maximum number of transfer structures to retrieve (default 50, max 200)
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.until] the latest time in ms to fetch transfers for (default time now)
     * @returns {object[]} a list of [transaction structures]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> fetchWithdrawals(object code = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object currency = null;
        if (isTrue(!isEqual(code, null)))
        {
            currency = this.currency(code);
            ((IDictionary<string,object>)request)["asset"] = getValue(currency, "id");
        }
        if (isTrue(!isEqual(since, null)))
        {
            ((IDictionary<string,object>)request)["startTime"] = since; // startTime and endTime must be within 7 days of each other
        }
        if (isTrue(!isEqual(limit, null)))
        {
            ((IDictionary<string,object>)request)["limit"] = limit;
        }
        object until = this.safeInteger(parameters, "until");
        if (isTrue(!isEqual(until, null)))
        {
            ((IDictionary<string,object>)request)["endTime"] = until;
            parameters = this.omit(parameters, "until");
        }
        object response = await this.privateGetV3Withdrawal(this.extend(request, parameters));
        //
        //     {
        //         success: true,
        //         data: [
        //             {
        //                 id: '968163212989431811',
        //                 asset: 'OX',
        //                 network: 'Arbitrum',
        //                 address: '0x90fc1fB49a4ED8f485dd02A2a1Cf576897f6Bfc9',
        //                 quantity: '11.7444',
        //                 fee: '1.744400000',
        //                 status: 'COMPLETED',
        //                 txId: '0xe96b2d128b737fdbca927edf355cff42202e65b0fb960e64ffb9bd68c121f69f',
        //                 requestedAt: '1715530365450',
        //                 completedAt: '1715530527000'
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            ((IDictionary<string,object>)getValue(data, i))["type"] = "withdrawal";
        }
        return this.parseTransactions(data, currency, since, limit);
    }

    public override object parseTransactions(object transactions, object currency = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object result = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(transactions)); postFixIncrement(ref i))
        {
            ((List<object>)transactions)[Convert.ToInt32(i)] = this.extend(getValue(transactions, i), parameters);
            object transaction = this.parseTransaction(getValue(transactions, i), currency);
            ((IList<object>)result).Add(transaction);
        }
        result = this.sortBy(result, "timestamp");
        object code = ((bool) isTrue((!isEqual(currency, null)))) ? getValue(currency, "code") : null;
        return this.filterByCurrencySinceLimit(result, code, since, limit);
    }

    public override object parseTransaction(object transaction, object currency = null)
    {
        //
        //  fetchDeposits
        //     {
        //         "asset":"USDC",
        //         "network":"Ethereum",
        //         "address": "0x998dEc76151FB723963Bd8AFD517687b38D33dE8",
        //         "quantity":"50",
        //         "id":"5914",
        //         "status": "COMPLETED",
        //         "txId":"0xf5e79663830a0c6f94d46638dcfbc134566c12facf1832396f81ecb55d3c75dc",
        //         "creditedAt":"1714821645154"
        //     }
        //
        // fetchWithdrawals
        //     {
        //         id: '968163212989431811',
        //         asset: 'OX',
        //         network: 'Arbitrum',
        //         address: '0x90fc1fB49a4ED8f485dd02A2a1Cf576897f6Bfc9',
        //         quantity: '11.7444',
        //         fee: '1.744400000',
        //         status: 'COMPLETED',
        //         txId: '0xe96b2d128b737fdbca927edf355cff42202e65b0fb960e64ffb9bd68c121f69f',
        //         requestedAt: '1715530365450',
        //         completedAt: '1715530527000'
        //     }
        //
        // withdraw
        //     {
        //         "id": "968364664449302529",
        //         "asset": "OX",
        //         "network": "Arbitrum",
        //         "address": "0x90fc1fB49a4ED8f485dd02A2a1Cf576897f6Bfc9",
        //         "quantity": "10",
        //         "externalFee": false,
        //         "fee": "1.6728",
        //         "status": "PENDING",
        //         "requestedAt": "1715591843616"
        //     }
        //
        object id = this.safeString(transaction, "id");
        object type = this.safeString(transaction, "type");
        transaction = this.omit(transaction, "type");
        object address = null;
        object addressTo = null;
        object status = null;
        if (isTrue(isEqual(type, "deposit")))
        {
            address = this.safeString(transaction, "address");
            status = this.parseDepositStatus(this.safeString(transaction, "status"));
        } else if (isTrue(isEqual(type, "withdrawal")))
        {
            addressTo = this.safeString(transaction, "address");
            status = this.parseWithdrawalStatus(this.safeString(transaction, "status"));
        }
        object txid = this.safeString(transaction, "txId");
        object currencyId = this.safeString(transaction, "asset");
        object code = this.safeCurrencyCode(currencyId, currency);
        object network = this.safeString(transaction, "network");
        object networkCode = this.networkIdToCode(network);
        object timestamp = this.safeInteger2(transaction, "creditedAt", "requestedAt");
        object amount = this.safeNumber(transaction, "quantity");
        object feeCost = this.safeNumber(transaction, "fee");
        object fee = null;
        if (isTrue(!isEqual(feeCost, null)))
        {
            fee = new Dictionary<string, object>() {
                { "cost", feeCost },
                { "currency", code },
            };
        }
        return new Dictionary<string, object>() {
            { "info", transaction },
            { "id", id },
            { "txid", txid },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "network", networkCode },
            { "address", address },
            { "addressTo", addressTo },
            { "addressFrom", null },
            { "tag", null },
            { "tagTo", null },
            { "tagFrom", null },
            { "type", type },
            { "amount", amount },
            { "currency", code },
            { "status", status },
            { "updated", null },
            { "internal", null },
            { "comment", null },
            { "fee", fee },
        };
    }

    public virtual object parseDepositStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "COMPLETED", "ok" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object parseWithdrawalStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "COMPLETED", "ok" },
            { "PROCESSING", "pending" },
            { "IN SWEEPING", "pending" },
            { "PENDING", "pending" },
            { "ON HOLD", "pending" },
            { "CANCELED", "canceled" },
            { "FAILED", "failed" },
        };
        return this.safeString(statuses, status, status);
    }

    /**
     * @method
     * @name oxfun#withdraw
     * @description make a withdrawal
     * @see https://docs.ox.fun/?json#post-v3-withdrawal
     * @param {string} code unified currency code
     * @param {float} amount the amount to withdraw
     * @param {string} address the address to withdraw to
     * @param {string} tag
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {string} [params.network] network for withdraw
     * @param {bool} [params.externalFee] if false, then the fee is taken from the quantity, also with the burn fee for asset SOLO
     *
     * EXCHANGE SPECIFIC PARAMETERS
     * @param {string} [params.tfaType] GOOGLE, or AUTHY_SECRET, or YUBIKEY, for 2FA
     * @param {string} [params.code] 2FA code
     * @returns {object} a [transaction structure]{@link https://docs.ccxt.com/#/?id=transaction-structure}
     */
    public async override Task<object> withdraw(object code, object amount, object address, object tag = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        var tagparametersVariable = this.handleWithdrawTagAndParams(tag, parameters);
        tag = ((IList<object>)tagparametersVariable)[0];
        parameters = ((IList<object>)tagparametersVariable)[1];
        await this.loadMarkets();
        object currency = this.currency(code);
        object stringAmount = this.currencyToPrecision(code, amount);
        object request = new Dictionary<string, object>() {
            { "asset", getValue(currency, "id") },
            { "address", address },
            { "quantity", stringAmount },
        };
        if (isTrue(!isEqual(tag, null)))
        {
            ((IDictionary<string,object>)request)["memo"] = tag;
        }
        object networkCode = null;
        var networkCodeparametersVariable = this.handleNetworkCodeAndParams(parameters);
        networkCode = ((IList<object>)networkCodeparametersVariable)[0];
        parameters = ((IList<object>)networkCodeparametersVariable)[1];
        if (isTrue(!isEqual(networkCode, null)))
        {
            ((IDictionary<string,object>)request)["network"] = this.networkCodeToId(networkCode);
        }
        ((IDictionary<string,object>)request)["externalFee"] = false;
        object response = await this.privatePostV3Withdrawal(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "id": "968364664449302529",
        //             "asset": "OX",
        //             "network": "Arbitrum",
        //             "address": "0x90fc1fB49a4ED8f485dd02A2a1Cf576897f6Bfc9",
        //             "quantity": "10",
        //             "externalFee": false,
        //             "fee": "1.6728",
        //             "status": "PENDING",
        //             "requestedAt": "1715591843616"
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        ((IDictionary<string,object>)data)["type"] = "withdrawal";
        return this.parseTransaction(data, currency);
    }

    /**
     * @method
     * @name oxfun#fetchPositions
     * @description fetch all open positions
     * @see https://docs.ox.fun/?json#get-v3-positions
     * @param {string[]|undefined} symbols list of unified market symbols
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {boolean} [params.subAcc]
     * @returns {object[]} a list of [position structure]{@link https://docs.ccxt.com/#/?id=position-structure}
     */
    public async override Task<object> fetchPositions(object symbols = null, object parameters = null)
    {
        // Calling this endpoint using an API key pair linked to the parent account with the parameter "subAcc"
        // allows the caller to include positions of additional sub-accounts in the response.
        // This feature does not work when using API key pairs linked to a sub-account
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        symbols = this.marketSymbols(symbols);
        object response = await this.privateGetV3Positions(parameters);
        //
        //     {
        //         "success": true,
        //         "data": [
        //             {
        //                 "accountId": "106490",
        //                 "name": "main",
        //                 "positions": [
        //                     {
        //                         "marketCode": "BTC-USD-SWAP-LIN",
        //                         "baseAsset": "BTC",
        //                         "counterAsset": "USD",
        //                         "position": "0.00010",
        //                         "entryPrice": "64300.0",
        //                         "markPrice": "63278",
        //                         "positionPnl": "-10.1900",
        //                         "estLiquidationPrice": "0",
        //                         "lastUpdatedAt": "1714915841448"
        //                     },
        //                     ...
        //                 ]
        //             },
        //             {
        //                 "accountId": "106526",
        //                 "name": "testSubAccount",
        //                 "positions": [
        //                     {
        //                         "marketCode": "ETH-USD-SWAP-LIN",
        //                         "baseAsset": "ETH",
        //                         "counterAsset": "USD",
        //                         "position": "0.001",
        //                         "entryPrice": "3080.5",
        //                         "markPrice": "3062.0",
        //                         "positionPnl": "-1.8500",
        //                         "estLiquidationPrice": "0",
        //                         "lastUpdatedAt": "1715089678013"
        //                     },
        //                     ...
        //                 ]
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object allPositions = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(data)); postFixIncrement(ref i))
        {
            object account = getValue(data, i);
            object positions = this.safeList(account, "positions", new List<object>() {});
            allPositions = this.arrayConcat(allPositions, positions);
        }
        return this.parsePositions(allPositions, symbols);
    }

    public override object parsePosition(object position, object market = null)
    {
        //
        //     {
        //         "marketCode": "ETH-USD-SWAP-LIN",
        //         "baseAsset": "ETH",
        //         "counterAsset": "USD",
        //         "position": "0.001",
        //         "entryPrice": "3080.5",
        //         "markPrice": "3062.0",
        //         "positionPnl": "-1.8500",
        //         "estLiquidationPrice": "0",
        //         "lastUpdatedAt": "1715089678013"
        //     }
        //
        object marketId = this.safeString(position, "marketCode");
        market = this.safeMarket(marketId, market);
        return this.safePosition(new Dictionary<string, object>() {
            { "info", position },
            { "id", null },
            { "symbol", getValue(market, "symbol") },
            { "notional", null },
            { "marginMode", "cross" },
            { "liquidationPrice", this.safeNumber(position, "estLiquidationPrice") },
            { "entryPrice", this.safeNumber(position, "entryPrice") },
            { "unrealizedPnl", this.safeNumber(position, "positionPnl") },
            { "realizedPnl", null },
            { "percentage", null },
            { "contracts", this.safeNumber(position, "position") },
            { "contractSize", null },
            { "markPrice", this.safeNumber(position, "markPrice") },
            { "lastPrice", null },
            { "side", null },
            { "hedged", null },
            { "timestamp", null },
            { "datetime", null },
            { "lastUpdateTimestamp", this.safeInteger(position, "lastUpdatedAt") },
            { "maintenanceMargin", null },
            { "maintenanceMarginPercentage", null },
            { "collateral", null },
            { "initialMargin", null },
            { "initialMarginPercentage", null },
            { "leverage", null },
            { "marginRatio", null },
            { "stopLossPrice", null },
            { "takeProfitPrice", null },
        });
    }

    /**
     * @method
     * @name oxfun#createOrder
     * @description create a trade order
     * @see https://docs.ox.fun/?json#post-v3-orders-place
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {string} type 'market', 'limit', 'STOP_LIMIT' or 'STOP_MARKET'
     * @param {string} side 'buy' or 'sell'
     * @param {float} amount how much of currency you want to trade in units of base currency
     * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.clientOrderId] a unique id for the order
     * @param {int} [params.timestamp] in milliseconds. If an order reaches the matching engine and the current timestamp exceeds timestamp + recvWindow, then the order will be rejected.
     * @param {int} [params.recvWindow] in milliseconds. If an order reaches the matching engine and the current timestamp exceeds timestamp + recvWindow, then the order will be rejected. If timestamp is provided without recvWindow, then a default recvWindow of 1000ms is used.
     * @param {string} [params.responseType] FULL or ACK
     * @param {float} [params.cost] the quote quantity that can be used as an alternative for the amount for market buy orders
     * @param {float} [params.triggerPrice] The price at which a trigger order is triggered at
     * @param {float} [params.limitPrice] Limit price for the STOP_LIMIT order
     * @param {bool} [params.postOnly] if true, the order will only be posted if it will be a maker order
     * @param {string} [params.timeInForce] GTC (default), IOC, FOK, PO, MAKER_ONLY or MAKER_ONLY_REPRICE (reprices order to the best maker only price if the specified price were to lead to a taker trade)
     * @param {string} [params.selfTradePreventionMode] NONE, EXPIRE_MAKER, EXPIRE_TAKER or EXPIRE_BOTH for more info check here {@link https://docs.ox.fun/?json#self-trade-prevention-modes}
     * @param {string} [params.displayQuantity] for an iceberg order, pass both quantity and displayQuantity fields in the order request
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrder(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "responseType", this.safeString(parameters, "responseType", "FULL") },
            { "timestamp", this.safeInteger(parameters, "timestamp", this.milliseconds()) },
        };
        parameters = this.omit(parameters, new List<object>() {"responseType", "timestamp"});
        object recvWindow = this.safeInteger(parameters, "recvWindow");
        if (isTrue(!isEqual(recvWindow, null)))
        {
            ((IDictionary<string,object>)request)["recvWindow"] = recvWindow;
            parameters = this.omit(parameters, "recvWindow");
        }
        object orderRequest = this.createOrderRequest(symbol, type, side, amount, price, parameters);
        ((IDictionary<string,object>)request)["orders"] = new List<object>() {orderRequest};
        object response = await this.privatePostV3OrdersPlace(request);
        //
        // accepted market order responseType FULL
        //     {
        //         "success": true,
        //         "data": [
        //             {
        //                 "notice": "OrderMatched",
        //                 "accountId": "106490",
        //                 "orderId": "1000109901865",
        //                 "submitted": true,
        //                 "clientOrderId": "0",
        //                 "marketCode": "OX-USDT",
        //                 "status": "FILLED",
        //                 "side": "SELL",
        //                 "isTriggered": false,
        //                 "quantity": "150.0",
        //                 "amount": "0.0",
        //                 "remainQuantity": "0.0",
        //                 "matchId": "100017047880451399",
        //                 "matchPrice": "0.01465",
        //                 "matchQuantity": "150.0",
        //                 "feeInstrumentId": "USDT",
        //                 "fees": "0.0015382500",
        //                 "orderType": "MARKET",
        //                 "createdAt": "1715592472236",
        //                 "lastMatchedAt": "1715592472200",
        //                 "displayQuantity": "150.0"
        //             }
        //         ]
        //     }
        //
        // accepted limit order responseType FULL
        //     {
        //         "success": true,
        //         "data": [
        //             {
        //                 "notice": "OrderOpened",
        //                 "accountId": "106490",
        //                 "orderId": "1000111482406",
        //                 "submitted": true,
        //                 "clientOrderId": "0",
        //                 "marketCode": "ETH-USD-SWAP-LIN",
        //                 "status": "OPEN",
        //                 "side": "SELL",
        //                 "price": "4000.0",
        //                 "isTriggered": false,
        //                 "quantity": "0.01",
        //                 "amount": "0.0",
        //                 "orderType": "LIMIT",
        //                 "timeInForce": "GTC",
        //                 "createdAt": "1715763507682",
        //                 "displayQuantity": "0.01"
        //             }
        //         ]
        //     }
        //
        // accepted order responseType ACK
        //     {
        //         "success": true,
        //         "data": [
        //             {
        //                 "accountId": "106490",
        //                 "orderId": "1000109892193",
        //                 "submitted": true,
        //                 "marketCode": "OX-USDT",
        //                 "side": "BUY",
        //                 "price": "0.01961",
        //                 "isTriggered": false,
        //                 "quantity": "100",
        //                 "orderType": "MARKET",
        //                 "timeInForce": "IOC",
        //                 "createdAt": "1715591529057",
        //                 "selfTradePreventionMode": "NONE"
        //             }
        //         ]
        //     }
        //
        //  rejected order (balance insufficient)
        //     {
        //         "success": true,
        //         "data": [
        //             {
        //                 "code": "710001",
        //                 "message": "System failure, exception thrown -> null",
        //                 "submitted": false,
        //                 "marketCode": "OX-USDT",
        //                 "side": "BUY",
        //                 "price": "0.01961",
        //                 "amount": "100",
        //                 "orderType": "MARKET",
        //                 "timeInForce": "IOC",
        //                 "createdAt": "1715591678835",
        //                 "source": 11,
        //                 "selfTradePreventionMode": "NONE"
        //             }
        //         ]
        //     }
        //
        // rejected order (bad request)
        //     {
        //         "success": true,
        //         "data": [
        //             {
        //                 "code": "20044",
        //                 "message": "Amount is not supported for this order type",
        //                 "submitted": false,
        //                 "marketCode": "OX-USDT",
        //                 "side": "SELL",
        //                 "amount": "200",
        //                 "orderType": "MARKET",
        //                 "createdAt": "1715592079986",
        //                 "source": 11
        //             }
        //         ]
        //     }
        //
        object data = this.safeList(response, "data", new List<object>() {});
        object order = this.safeDict(data, 0, new Dictionary<string, object>() {});
        return this.parseOrder(order);
    }

    /**
     * @method
     * @name oxfun#createOrders
     * @description create a list of trade orders
     * @see https://docs.ox.fun/?json#post-v3-orders-place
     * @param {Array} orders list of orders to create, each object should contain the parameters required by createOrder, namely symbol, type, side, amount, price and params
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.timestamp] *for all orders* in milliseconds. If orders reach the matching engine and the current timestamp exceeds timestamp + recvWindow, then all orders will be rejected.
     * @param {int} [params.recvWindow] *for all orders* in milliseconds. If orders reach the matching engine and the current timestamp exceeds timestamp + recvWindow, then all orders will be rejected. If timestamp is provided without recvWindow, then a default recvWindow of 1000ms is used.
     * @param {string} [params.responseType] *for all orders* FULL or ACK
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createOrders(object orders, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object ordersRequests = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(orders)); postFixIncrement(ref i))
        {
            object rawOrder = getValue(orders, i);
            object symbol = this.safeString(rawOrder, "symbol");
            object type = this.safeString(rawOrder, "type");
            object side = this.safeString(rawOrder, "side");
            object amount = this.safeNumber(rawOrder, "amount");
            object price = this.safeNumber(rawOrder, "price");
            object orderParams = this.safeDict(rawOrder, "params", new Dictionary<string, object>() {});
            object orderRequest = this.createOrderRequest(symbol, type, side, amount, price, orderParams);
            ((IList<object>)ordersRequests).Add(orderRequest);
        }
        object request = new Dictionary<string, object>() {
            { "responseType", "FULL" },
            { "timestamp", this.milliseconds() },
            { "orders", ordersRequests },
        };
        object response = await this.privatePostV3OrdersPlace(this.extend(request, parameters));
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOrders(data);
    }

    public virtual object createOrderRequest(object symbol, object type, object side, object amount, object price = null, object parameters = null)
    {
        /**
        * @param {string} symbol unified symbol of the market to create an order in
        * @param {string} type 'market', 'limit', 'STOP_LIMIT' or 'STOP_MARKET'
        * @param {string} side 'buy' or 'sell'
        * @param {float} amount how much of currency you want to trade in units of base currency
        * @param {float} [price] the price at which the order is to be fulfilled, in units of the quote currency, ignored in market orders
        * @param {object} [params] extra parameters specific to the exchange API endpoint
        * @param {int} [params.clientOrderId] a unique id for the order
        * @param {float} [params.cost] the quote quantity that can be used as an alternative for the amount for market buy orders
        * @param {float} [params.triggerPrice] The price at which a trigger order is triggered at
        * @param {float} [params.limitPrice] Limit price for the STOP_LIMIT order
        * @param {bool} [params.postOnly] if true, the order will only be posted if it will be a maker order
        * @param {string} [params.timeInForce] GTC (default), IOC, FOK, PO, MAKER_ONLY or MAKER_ONLY_REPRICE (reprices order to the best maker only price if the specified price were to lead to a taker trade)
        * @param {string} [params.selfTradePreventionMode] NONE, EXPIRE_MAKER, EXPIRE_TAKER or EXPIRE_BOTH for more info check here {@link https://docs.ox.fun/?json#self-trade-prevention-modes}
        * @param {string} [params.displayQuantity] for an iceberg order, pass both quantity and displayQuantity fields in the order request
        */
        parameters ??= new Dictionary<string, object>();
        object market = this.market(symbol);
        object request = new Dictionary<string, object>() {
            { "marketCode", getValue(market, "id") },
            { "side", ((string)side).ToUpper() },
            { "source", 1000 },
        };
        object cost = this.safeString2(parameters, "cost", "amount");
        if (isTrue(!isEqual(cost, null)))
        {
            ((IDictionary<string,object>)request)["amount"] = cost; // todo costToPrecision
            parameters = this.omit(parameters, new List<object>() {"cost", "amount"});
        } else
        {
            ((IDictionary<string,object>)request)["quantity"] = amount; // todo amountToPrecision
        }
        object triggerPrice = this.safeString2(parameters, "triggerPrice", "stopPrice");
        object orderType = ((string)type).ToUpper();
        if (isTrue(!isEqual(triggerPrice, null)))
        {
            if (isTrue(isEqual(orderType, "MARKET")))
            {
                orderType = "STOP_MARKET";
            } else if (isTrue(isEqual(orderType, "LIMIT")))
            {
                orderType = "STOP_LIMIT";
            }
            ((IDictionary<string,object>)request)["stopPrice"] = triggerPrice; // todo priceToPrecision
            parameters = this.omit(parameters, new List<object>() {"triggerPrice", "stopPrice"});
        }
        ((IDictionary<string,object>)request)["orderType"] = orderType;
        if (isTrue(isEqual(orderType, "STOP_LIMIT")))
        {
            ((IDictionary<string,object>)request)["limitPrice"] = price; // todo priceToPrecision
        } else if (isTrue(!isEqual(price, null)))
        {
            ((IDictionary<string,object>)request)["price"] = price; // todo priceToPrecision
        }
        object postOnly = null;
        object isMarketOrder = isTrue((isEqual(orderType, "MARKET"))) || isTrue((isEqual(orderType, "STOP_MARKET")));
        var postOnlyparametersVariable = this.handlePostOnly(isMarketOrder, false, parameters);
        postOnly = ((IList<object>)postOnlyparametersVariable)[0];
        parameters = ((IList<object>)postOnlyparametersVariable)[1];
        object timeInForce = this.safeStringUpper(parameters, "timeInForce");
        if (isTrue(isTrue(postOnly) && isTrue((!isEqual(timeInForce, "MAKER_ONLY_REPRICE")))))
        {
            ((IDictionary<string,object>)request)["timeInForce"] = "MAKER_ONLY";
        }
        return this.extend(request, parameters);
    }

    /**
     * @method
     * @name oxfun#createMarketBuyOrderWithCost
     * @description create a market buy order by providing the symbol and cost
     * @see https://open.big.one/docs/spot_orders.html#create-order
     * @param {string} symbol unified symbol of the market to create an order in
     * @param {float} cost how much you want to trade in units of the quote currency
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} an [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> createMarketBuyOrderWithCost(object symbol, object cost, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object market = this.market(symbol);
        if (!isTrue(getValue(market, "spot")))
        {
            throw new NotSupported ((string)add(this.id, " createMarketBuyOrderWithCost() supports spot orders only")) ;
        }
        object request = new Dictionary<string, object>() {
            { "cost", cost },
        };
        return await this.createOrder(symbol, "market", "buy", null, null, this.extend(request, parameters));
    }

    /**
     * @method
     * @name oxfun#fetchOrder
     * @see https://docs.ox.fun/?json#get-v3-orders-status
     * @description fetches information on an order made by the user
     * @param {string} id a unique id for the order
     * @param {string} [symbol] not used by oxfun fetchOrder
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.clientOrderId] the client order id of the order
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {
            { "orderId", id },
        };
        object response = await this.privateGetV3OrdersStatus(this.extend(request, parameters));
        //
        //     {
        //         "success": true,
        //         "data": {
        //             "orderId": "1000111762980",
        //             "clientOrderId": "0",
        //             "marketCode": "ETH-USD-SWAP-LIN",
        //             "status": "OPEN",
        //             "side": "BUY",
        //             "price": "2700.0",
        //             "isTriggered": false,
        //             "remainQuantity": "0.01",
        //             "totalQuantity": "0.01",
        //             "amount": "0",
        //             "displayQuantity": "0.01",
        //             "cumulativeMatchedQuantity": "0",
        //             "orderType": "STOP_LIMIT",
        //             "timeInForce": "GTC",
        //             "source": "11",
        //             "createdAt": "1715794191277"
        //         }
        //     }
        //
        object data = this.safeDict(response, "data", new Dictionary<string, object>() {});
        return this.parseOrder(data);
    }

    /**
     * @method
     * @name oxfun#fetchOpenOrders
     * @description fetch all unfilled currently open orders
     * @see https://docs.ox.fun/?json#get-v3-orders-working
     * @param {string} symbol unified market symbol
     * @param {int} [since] the earliest time in ms to fetch open orders for
     * @param {int} [limit] the maximum number of  open orders structures to retrieve
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.orderId] a unique id for the order
     * @param {int} [params.clientOrderId] the client order id of the order
     * @returns {Order[]} a list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> fetchOpenOrders(object symbol = null, object since = null, object limit = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        await this.loadMarkets();
        object request = new Dictionary<string, object>() {};
        object market = null;
        if (isTrue(!isEqual(symbol, null)))
        {
            market = this.market(symbol);
        }
        object response = await this.privateGetV3OrdersWorking(this.extend(request, parameters));
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOrders(data, market, since, limit);
    }

    /**
     * @method
     * @name oxfun#cancelOrder
     * @description cancels an open order
     * @see https://docs.ox.fun/?json#delete-v3-orders-cancel
     * @param {string} id order id
     * @param {string} symbol unified symbol of the market the order was made in
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.clientOrderId] a unique id for the order
     * @param {int} [params.timestamp] in milliseconds
     * @param {int} [params.recvWindow] in milliseconds
     * @param {string} [params.responseType] 'FULL' or 'ACK'
     * @returns {object} An [order structure]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async override Task<object> cancelOrder(object id, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrder() requires a symbol argument")) ;
        }
        object market = this.market(symbol);
        object marketId = getValue(market, "id");
        object request = new Dictionary<string, object>() {
            { "timestamp", this.milliseconds() },
            { "responseType", "FULL" },
        };
        object orderRequest = new Dictionary<string, object>() {
            { "marketCode", marketId },
            { "orderId", id },
        };
        object clientOrderId = this.safeInteger(parameters, "clientOrderId");
        if (isTrue(!isEqual(clientOrderId, null)))
        {
            ((IDictionary<string,object>)orderRequest)["clientOrderId"] = clientOrderId;
        }
        ((IDictionary<string,object>)request)["orders"] = new List<object>() {orderRequest};
        object response = await this.privateDeleteV3OrdersCancel(this.extend(request, parameters));
        object data = this.safeList(response, "data", new List<object>() {});
        object order = this.safeDict(data, 0, new Dictionary<string, object>() {});
        return this.parseOrder(order);
    }

    /**
     * @method
     * @name oxfun#cancelAllOrders
     * @description cancel all open orders
     * @see https://docs.ox.fun/?json#delete-v3-orders-cancel-all
     * @param {string} symbol unified market symbol, only orders in the market of this symbol are cancelled when symbol is not undefined
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @returns {object} response from exchange
     */
    public async override Task<object> cancelAllOrders(object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        object request = new Dictionary<string, object>() {};
        if (isTrue(!isEqual(symbol, null)))
        {
            object market = this.market(symbol);
            ((IDictionary<string,object>)request)["marketCode"] = getValue(market, "id");
        }
        //
        //     {
        //         "success": true,
        //         "data": { "notice": "Orders queued for cancelation" }
        //     }
        //
        //     {
        //         "success": true,
        //         "data": { "notice": "No working orders found" }
        //     }
        //
        return await this.privateDeleteV3OrdersCancelAll(this.extend(request, parameters));
    }

    /**
     * @method
     * @name oxfun#cancelOrders
     * @description cancel multiple orders
     * @see https://docs.ox.fun/?json#delete-v3-orders-cancel
     * @param {string[]} ids order ids
     * @param {string} [symbol] unified market symbol
     * @param {object} [params] extra parameters specific to the exchange API endpoint
     * @param {int} [params.timestamp] in milliseconds
     * @param {int} [params.recvWindow] in milliseconds
     * @param {string} [params.responseType] 'FULL' or 'ACK'
     * @returns {object} an list of [order structures]{@link https://docs.ccxt.com/#/?id=order-structure}
     */
    public async virtual Task<object> cancelOrders(object ids, object symbol = null, object parameters = null)
    {
        parameters ??= new Dictionary<string, object>();
        if (isTrue(isEqual(symbol, null)))
        {
            throw new ArgumentsRequired ((string)add(this.id, " cancelOrders() requires a symbol argument")) ;
        }
        await this.loadMarkets();
        object market = this.market(symbol);
        object marketId = getValue(market, "id");
        object request = new Dictionary<string, object>() {
            { "timestamp", this.milliseconds() },
            { "responseType", "FULL" },
        };
        object orders = new List<object>() {};
        for (object i = 0; isLessThan(i, getArrayLength(ids)); postFixIncrement(ref i))
        {
            object order = new Dictionary<string, object>() {
                { "marketCode", marketId },
                { "orderId", getValue(ids, i) },
            };
            ((IList<object>)orders).Add(order);
        }
        ((IDictionary<string,object>)request)["orders"] = orders;
        object response = await this.privateDeleteV3OrdersCancel(this.extend(request, parameters));
        object data = this.safeList(response, "data", new List<object>() {});
        return this.parseOrders(data, market);
    }

    public override object parseOrder(object order, object market = null)
    {
        //
        // accepted market order responseType FULL
        //     {
        //         "notice": "OrderMatched",
        //         "accountId": "106490",
        //         "orderId": "1000109901865",
        //         "submitted": true,
        //         "clientOrderId": "0",
        //         "marketCode": "OX-USDT",
        //         "status": "FILLED",
        //         "side": "SELL",
        //         "isTriggered": false,
        //         "quantity": "150.0",
        //         "amount": "0.0",
        //         "remainQuantity": "0.0",
        //         "matchId": "100017047880451399",
        //         "matchPrice": "0.01465",
        //         "matchQuantity": "150.0",
        //         "feeInstrumentId": "USDT",
        //         "fees": "0.0015382500",
        //         "orderType": "MARKET",
        //         "createdAt": "1715592472236",
        //         "lastMatchedAt": "1715592472200",
        //         "displayQuantity": "150.0"
        //     }
        //
        // accepted limit order responseType FULL
        //     {
        //         "notice": "OrderOpened",
        //         "accountId": "106490",
        //         "orderId": "1000111482406",
        //         "submitted": true,
        //         "clientOrderId": "0",
        //         "marketCode": "ETH-USD-SWAP-LIN",
        //         "status": "OPEN",
        //         "side": "SELL",
        //         "price": "4000.0",
        //         "isTriggered": false,
        //         "quantity": "0.01",
        //         "amount": "0.0",
        //         "orderType": "LIMIT",
        //         "timeInForce": "GTC",
        //         "createdAt": "1715763507682",
        //         "displayQuantity": "0.01"
        //     }
        //
        // accepted order responseType ACK
        //     {
        //         "accountId": "106490",
        //         "orderId": "1000109892193",
        //         "submitted": true,
        //         "marketCode": "OX-USDT",
        //         "side": "BUY",
        //         "price": "0.01961",
        //         "isTriggered": false,
        //         "quantity": "100",
        //         "orderType": "MARKET",
        //         "timeInForce": "IOC",
        //         "createdAt": "1715591529057",
        //         "selfTradePreventionMode": "NONE"
        //     }
        //
        //  rejected order (balance insufficient)
        //     {
        //         "code": "710001",
        //         "message": "System failure, exception thrown -> null",
        //         "submitted": false,
        //         "marketCode": "OX-USDT",
        //         "side": "BUY",
        //         "price": "0.01961",
        //         "amount": "100",
        //         "orderType": "MARKET",
        //         "timeInForce": "IOC",
        //         "createdAt": "1715591678835",
        //         "source": 11,
        //         "selfTradePreventionMode": "NONE"
        //     }
        //
        // rejected order (bad request)
        //     {
        //         "code": "20044",
        //         "message": "Amount is not supported for this order type",
        //         "submitted": false,
        //         "marketCode": "OX-USDT",
        //         "side": "SELL",
        //         "amount": "200",
        //         "orderType": "MARKET",
        //         "createdAt": "1715592079986",
        //         "source": 11
        //     }
        //
        // fetchOrder
        //     {
        //         "orderId": "1000111762980",
        //         "clientOrderId": "0",
        //         "marketCode": "ETH-USD-SWAP-LIN",
        //         "status": "OPEN",
        //         "side": "BUY",
        //         "price": "2700.0",
        //         "isTriggered": false,
        //         "remainQuantity": "0.01",
        //         "totalQuantity": "0.01",
        //         "amount": "0",
        //         "displayQuantity": "0.01",
        //         "cumulativeMatchedQuantity": "0",
        //         "orderType": "STOP_LIMIT",
        //         "timeInForce": "GTC",
        //         "source": "11",
        //         "createdAt": "1715794191277"
        //     }
        //
        object marketId = this.safeString(order, "marketCode");
        market = this.safeMarket(marketId, market);
        object timestamp = this.safeInteger(order, "createdAt");
        object fee = null;
        object feeCurrency = this.safeString(order, "feeInstrumentId");
        if (isTrue(!isEqual(feeCurrency, null)))
        {
            fee = new Dictionary<string, object>() {
                { "currency", this.safeCurrencyCode(feeCurrency) },
                { "cost", this.safeNumber(order, "fees") },
            };
        }
        object status = this.safeString(order, "status");
        object code = this.safeInteger(order, "code"); // rejected orders have code of the error
        if (isTrue(!isEqual(code, null)))
        {
            status = "rejected";
        }
        object triggerPrice = this.safeString(order, "stopPrice");
        return this.safeOrder(new Dictionary<string, object>() {
            { "id", this.safeString(order, "orderId") },
            { "clientOrderId", this.safeString(order, "clientOrderId") },
            { "timestamp", timestamp },
            { "datetime", this.iso8601(timestamp) },
            { "lastTradeTimestamp", this.safeInteger(order, "lastMatchedAt") },
            { "lastUpdateTimestamp", this.safeInteger(order, "lastModifiedAt") },
            { "status", this.parseOrderStatus(status) },
            { "symbol", getValue(market, "symbol") },
            { "type", this.parseOrderType(this.safeString(order, "orderType")) },
            { "timeInForce", this.parseOrderTimeInForce(this.safeString(order, "timeInForce")) },
            { "side", this.safeStringLower(order, "side") },
            { "price", this.safeStringN(order, new List<object>() {"price", "matchPrice", "limitPrice"}) },
            { "average", null },
            { "amount", this.safeString2(order, "totalQuantity", "quantity") },
            { "filled", this.safeString2(order, "cumulativeMatchedQuantity", "matchQuantity") },
            { "remaining", this.safeString(order, "remainQuantity") },
            { "triggerPrice", triggerPrice },
            { "stopLossPrice", triggerPrice },
            { "cost", this.omitZero(this.safeString(order, "amount")) },
            { "trades", null },
            { "fee", fee },
            { "info", order },
        }, market);
    }

    public virtual object parseOrderStatus(object status)
    {
        object statuses = new Dictionary<string, object>() {
            { "OPEN", "open" },
            { "PARTIALLY_FILLED", "open" },
            { "PARTIAL_FILL", "open" },
            { "FILLED", "closed" },
            { "CANCELED", "canceled" },
            { "CANCELED_BY_USER", "canceled" },
            { "CANCELED_BY_MAKER_ONLY", "rejected" },
            { "CANCELED_BY_FOK", "rejected" },
            { "CANCELED_ALL_BY_IOC", "rejected" },
            { "CANCELED_PARTIAL_BY_IOC", "canceled" },
            { "CANCELED_BY_SELF_TRADE_PROTECTION", "rejected" },
        };
        return this.safeString(statuses, status, status);
    }

    public virtual object parseOrderType(object type)
    {
        object types = new Dictionary<string, object>() {
            { "LIMIT", "limit" },
            { "STOP_LIMIT", "limit" },
            { "MARKET", "market" },
            { "STOP_MARKET", "market" },
        };
        return this.safeString(types, type, type);
    }

    public virtual object parseOrderTimeInForce(object type)
    {
        object types = new Dictionary<string, object>() {
            { "GTC", "GTC" },
            { "IOC", "IOC" },
            { "FOK", "FOK" },
            { "MAKER_ONLY", "PO" },
            { "MAKER_ONLY_REPRICE", "PO" },
        };
        return this.safeString(types, type, type);
    }

    public override object sign(object path, object api = null, object method = null, object parameters = null, object headers = null, object body = null)
    {
        api ??= "public";
        method ??= "GET";
        parameters ??= new Dictionary<string, object>();
        object baseUrl = getValue(getValue(this.urls, "api"), api);
        object url = add(add(baseUrl, "/"), path);
        object queryString = "";
        if (isTrue(isEqual(method, "GET")))
        {
            queryString = this.urlencode(parameters);
            if (isTrue(!isEqual(((string)queryString).Length, 0)))
            {
                url = add(url, add("?", queryString));
            }
        }
        if (isTrue(isEqual(api, "private")))
        {
            this.checkRequiredCredentials();
            object timestamp = this.milliseconds();
            object isoDatetime = this.iso8601(timestamp);
            object datetimeParts = ((string)isoDatetime).Split(new [] {((string)".")}, StringSplitOptions.None).ToList<object>();
            object datetime = getValue(datetimeParts, 0);
            object nonce = this.nonce();
            object urlParts = ((string)baseUrl).Split(new [] {((string)"//")}, StringSplitOptions.None).ToList<object>();
            if (isTrue(isTrue((isEqual(method, "POST"))) || isTrue((isEqual(method, "DELETE")))))
            {
                body = this.json(parameters);
                queryString = body;
            }
            object msgString = add(add(add(add(add(add(add(add(add(add(datetime, "\n"), ((object)nonce).ToString()), "\n"), method), "\n"), getValue(urlParts, 1)), "\n/"), path), "\n"), queryString);
            object signature = this.hmac(this.encode(msgString), this.encode(this.secret), sha256, "base64");
            headers = new Dictionary<string, object>() {
                { "Content-Type", "application/json" },
                { "AccessKey", this.apiKey },
                { "Timestamp", datetime },
                { "Signature", signature },
                { "Nonce", ((object)nonce).ToString() },
            };
        }
        return new Dictionary<string, object>() {
            { "url", url },
            { "method", method },
            { "body", body },
            { "headers", headers },
        };
    }

    public override object handleErrors(object code, object reason, object url, object method, object headers, object body, object response, object requestHeaders, object requestBody)
    {
        if (isTrue(isEqual(response, null)))
        {
            return null;
        }
        if (isTrue(!isEqual(code, 200)))
        {
            object responseCode = this.safeString(response, "code", null);
            object feedback = add(add(this.id, " "), body);
            this.throwBroadlyMatchedException(getValue(this.exceptions, "broad"), body, feedback);
            this.throwExactlyMatchedException(getValue(this.exceptions, "exact"), responseCode, feedback);
            throw new ExchangeError ((string)feedback) ;
        }
        return null;
    }
}
